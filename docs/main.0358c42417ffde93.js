(self.webpackChunkmap_fog_style=self.webpackChunkmap_fog_style||[]).push([[179],{1205:(Lt,ut,y)=>{"use strict";var $={};function V(t){return"function"==typeof t}function H(t){const e=t(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}y.r($),y.d($,{addImpl:()=>QB,bincountImpl:()=>qI,bincountReduceImpl:()=>i3,bitwiseAndImpl:()=>s3,castImpl:()=>qB,ceilImpl:()=>o3,concatImpl:()=>a3,equalImpl:()=>c3,expImpl:()=>d3,expm1Impl:()=>p3,floorImpl:()=>y3,gatherNdImpl:()=>v3,gatherV2Impl:()=>_3,greaterEqualImpl:()=>E3,greaterImpl:()=>x3,lessEqualImpl:()=>w3,lessImpl:()=>C3,linSpaceImpl:()=>b3,logImpl:()=>I3,maxImpl:()=>S3,maximumImpl:()=>T3,minimumImpl:()=>N3,multiplyImpl:()=>QI,negImpl:()=>M3,notEqualImpl:()=>P3,prodImpl:()=>k3,raggedGatherImpl:()=>$3,raggedRangeImpl:()=>z3,raggedTensorToTensorImpl:()=>W3,rangeImpl:()=>G3,rsqrtImpl:()=>H3,scatterImpl:()=>qd,sigmoidImpl:()=>ylt,simpleAbsImpl:()=>t3,sliceImpl:()=>r3,sparseFillEmptyRowsImpl:()=>K3,sparseReshapeImpl:()=>X3,sparseSegmentReductionImpl:()=>iS,sqrtImpl:()=>jpt,staticRegexReplaceImpl:()=>Z3,stridedSliceImpl:()=>Y3,stringNGramsImpl:()=>q3,stringSplitImpl:()=>Q3,stringToHashBucketFastImpl:()=>J3,subImpl:()=>m3,tileImpl:()=>tz,topKImpl:()=>nz,transposeImpl:()=>ZI,uniqueImpl:()=>iz});const q=H(t=>function(e){t(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,i)=>`${i+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function Y(t,n){if(t){const e=t.indexOf(n);0<=e&&t.splice(e,1)}}class R{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const s of e)s.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(V(r))try{r()}catch(s){n=s instanceof q?s.errors:[s]}const{_finalizers:i}=this;if(i){this._finalizers=null;for(const s of i)try{A(s)}catch(o){n=n??[],o instanceof q?n=[...n,...o.errors]:n.push(o)}}if(n)throw new q(n)}}add(n){var e;if(n&&n!==this)if(this.closed)A(n);else{if(n instanceof R){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(n)}}_hasParent(n){const{_parentage:e}=this;return e===n||Array.isArray(e)&&e.includes(n)}_addParent(n){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(n),e):e?[e,n]:n}_removeParent(n){const{_parentage:e}=this;e===n?this._parentage=null:Array.isArray(e)&&Y(e,n)}remove(n){const{_finalizers:e}=this;e&&Y(e,n),n instanceof R&&n._removeParent(this)}}R.EMPTY=(()=>{const t=new R;return t.closed=!0,t})();const W=R.EMPTY;function k(t){return t instanceof R||t&&"closed"in t&&V(t.remove)&&V(t.add)&&V(t.unsubscribe)}function A(t){V(t)?t():t.unsubscribe()}const X={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Z={setTimeout(t,n,...e){const{delegate:r}=Z;return r?.setTimeout?r.setTimeout(t,n,...e):setTimeout(t,n,...e)},clearTimeout(t){const{delegate:n}=Z;return(n?.clearTimeout||clearTimeout)(t)},delegate:void 0};function G(t){Z.setTimeout(()=>{const{onUnhandledError:n}=X;if(!n)throw t;n(t)})}function it(){}const bt=et("C",void 0,void 0);function et(t,n,e){return{kind:t,value:n,error:e}}let dt=null;function lt(t){if(X.useDeprecatedSynchronousErrorHandling){const n=!dt;if(n&&(dt={errorThrown:!1,error:null}),t(),n){const{errorThrown:e,error:r}=dt;if(dt=null,e)throw r}}else t()}class Q extends R{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,k(n)&&n.add(this)):this.destination=Gt}static create(n,e,r){return new ot(n,e,r)}next(n){this.isStopped?nt(function st(t){return et("N",t,void 0)}(n),this):this._next(n)}error(n){this.isStopped?nt(function K(t){return et("E",void 0,t)}(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?nt(bt,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const ft=Function.prototype.bind;function pt(t,n){return ft.call(t,n)}class B{constructor(n){this.partialObserver=n}next(n){const{partialObserver:e}=this;if(e.next)try{e.next(n)}catch(r){P(r)}}error(n){const{partialObserver:e}=this;if(e.error)try{e.error(n)}catch(r){P(r)}else P(n)}complete(){const{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(e){P(e)}}}class ot extends Q{constructor(n,e,r){let i;if(super(),V(n)||!n)i={next:n??void 0,error:e??void 0,complete:r??void 0};else{let s;this&&X.useDeprecatedNextContext?(s=Object.create(n),s.unsubscribe=()=>this.unsubscribe(),i={next:n.next&&pt(n.next,s),error:n.error&&pt(n.error,s),complete:n.complete&&pt(n.complete,s)}):i=n}this.destination=new B(i)}}function P(t){X.useDeprecatedSynchronousErrorHandling?function St(t){X.useDeprecatedSynchronousErrorHandling&&dt&&(dt.errorThrown=!0,dt.error=t)}(t):G(t)}function nt(t,n){const{onStoppedNotification:e}=X;e&&Z.setTimeout(()=>e(t,n))}const Gt={closed:!0,next:it,error:function at(t){throw t},complete:it},O="function"==typeof Symbol&&Symbol.observable||"@@observable";function Ct(t){return t}function vt(t){return 0===t.length?Ct:1===t.length?t[0]:function(e){return t.reduce((r,i)=>i(r),e)}}let xt=(()=>{class t{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,i){const s=function re(t){return t&&t instanceof Q||function It(t){return t&&V(t.next)&&V(t.error)&&V(t.complete)}(t)&&k(t)}(e)?e:new ot(e,r,i);return lt(()=>{const{operator:o,source:a}=this;s.add(o?o.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=Mt(r))((i,s)=>{const o=new ot({next:a=>{try{e(a)}catch(u){s(u),o.unsubscribe()}},error:s,complete:i});this.subscribe(o)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[O](){return this}pipe(...e){return vt(e)(this)}toPromise(e){return new(e=Mt(e))((r,i)=>{let s;this.subscribe(o=>s=o,o=>i(o),()=>r(s))})}}return t.create=n=>new t(n),t})();function Mt(t){var n;return null!==(n=t??X.Promise)&&void 0!==n?n:Promise}const Bt=H(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let ee=(()=>{class t extends xt{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new jt(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new Bt}next(e){lt(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){lt(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){lt(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:i,observers:s}=this;return r||i?W:(this.currentObservers=null,s.push(e),new R(()=>{this.currentObservers=null,Y(s,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:i,isStopped:s}=this;r?e.error(i):s&&e.complete()}asObservable(){const e=new xt;return e.source=this,e}}return t.create=(n,e)=>new jt(n,e),t})();class jt extends ee{constructor(n,e){super(),this.destination=n,this.source=e}next(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,n)}error(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,n)}complete(){var n,e;null===(e=null===(n=this.destination)||void 0===n?void 0:n.complete)||void 0===e||e.call(n)}_subscribe(n){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(n))&&void 0!==r?r:W}}function se(t){return V(t?.lift)}function be(t){return n=>{if(se(n))return n.lift(function(e){try{return t(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function Me(t,n,e,r,i){return new Xe(t,n,e,r,i)}class Xe extends Q{constructor(n,e,r,i,s,o){super(n),this.onFinalize=s,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(u){n.error(u)}}:super._next,this._error=i?function(a){try{i(a)}catch(u){n.error(u)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(n=this.onFinalize)||void 0===n||n.call(this))}}}function Ue(t,n){return be((e,r)=>{let i=0;e.subscribe(Me(r,s=>{r.next(t.call(n,s,i++))}))})}var De=function(t,n){return(De=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(e[i]=r[i])})(t,n)};function Ce(t){return this instanceof Ce?(this.v=t,this):new Ce(t)}function te(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t=function yn(t){var n="function"==typeof Symbol&&Symbol.iterator,e=n&&t[n],r=0;if(e)return e.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(s){e[s]=t[s]&&function(o){return new Promise(function(a,u){!function i(s,o,a,u){Promise.resolve(u).then(function(c){s({value:c,done:a})},o)}(a,u,(o=t[s](o)).done,o.value)})}}}"function"==typeof SuppressedError&&SuppressedError;const tr=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function dr(t){return V(t?.then)}function zn(t){return V(t[O])}function vn(t){return Symbol.asyncIterator&&V(t?.[Symbol.asyncIterator])}function sr(t){return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const Qn=function Jr(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function wr(t){return V(t?.[Qn])}function Dn(t){return function Et(t,n,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,r=e.apply(t,n||[]),s=[];return i={},o("next"),o("throw"),o("return"),i[Symbol.asyncIterator]=function(){return this},i;function o(v){r[v]&&(i[v]=function(x){return new Promise(function(w,b){s.push([v,x,w,b])>1||a(v,x)})})}function a(v,x){try{!function u(v){v.value instanceof Ce?Promise.resolve(v.value.v).then(c,d):p(s[0][2],v)}(r[v](x))}catch(w){p(s[0][3],w)}}function c(v){a("next",v)}function d(v){a("throw",v)}function p(v,x){v(x),s.shift(),s.length&&a(s[0][0],s[0][1])}}(this,arguments,function*(){const e=t.getReader();try{for(;;){const{value:r,done:i}=yield Ce(e.read());if(i)return yield Ce(void 0);yield yield Ce(r)}}finally{e.releaseLock()}})}function si(t){return V(t?.getReader)}function Rr(t){if(t instanceof xt)return t;if(null!=t){if(zn(t))return function er(t){return new xt(n=>{const e=t[O]();if(V(e.subscribe))return e.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(t);if(tr(t))return function Zi(t){return new xt(n=>{for(let e=0;e<t.length&&!n.closed;e++)n.next(t[e]);n.complete()})}(t);if(dr(t))return function fi(t){return new xt(n=>{t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,G)})}(t);if(vn(t))return zr(t);if(wr(t))return function oi(t){return new xt(n=>{for(const e of t)if(n.next(e),n.closed)return;n.complete()})}(t);if(si(t))return function js(t){return zr(Dn(t))}(t)}throw sr(t)}function zr(t){return new xt(n=>{(function ho(t,n){var e,r,i,s;return function hi(t,n,e,r){return new(e||(e=Promise))(function(s,o){function a(d){try{c(r.next(d))}catch(p){o(p)}}function u(d){try{c(r.throw(d))}catch(p){o(p)}}function c(d){d.done?s(d.value):function i(s){return s instanceof e?s:new e(function(o){o(s)})}(d.value).then(a,u)}c((r=r.apply(t,n||[])).next())})}(this,void 0,void 0,function*(){try{for(e=te(t);!(r=yield e.next()).done;)if(n.next(r.value),n.closed)return}catch(o){i={error:o}}finally{try{r&&!r.done&&(s=e.return)&&(yield s.call(e))}finally{if(i)throw i.error}}n.complete()})})(t,n).catch(e=>n.error(e))})}function Es(t,n,e,r=0,i=!1){const s=n.schedule(function(){e(),i?t.add(this.schedule(null,r)):this.unsubscribe()},r);if(t.add(s),!i)return s}function Ss(t,n,e=1/0){return V(n)?Ss((r,i)=>Ue((s,o)=>n(r,s,i,o))(Rr(t(r,i))),e):("number"==typeof n&&(e=n),be((r,i)=>function Ks(t,n,e,r,i,s,o,a){const u=[];let c=0,d=0,p=!1;const v=()=>{p&&!u.length&&!c&&n.complete()},x=b=>c<r?w(b):u.push(b),w=b=>{s&&n.next(b),c++;let T=!1;Rr(e(b,d++)).subscribe(Me(n,N=>{i?.(N),s?x(N):n.next(N)},()=>{T=!0},void 0,()=>{if(T)try{for(c--;u.length&&c<r;){const N=u.shift();o?Es(n,o,()=>w(N)):w(N)}v()}catch(N){n.error(N)}}))};return t.subscribe(Me(n,x,()=>{p=!0,v()})),()=>{a?.()}}(r,i,t,e)))}function ti(t=1/0){return Ss(Ct,t)}const Vr=new xt(t=>t.complete());function rs(t){return t[t.length-1]}function Oa(t){return V(rs(t))?t.pop():void 0}function eo(t){return function Pa(t){return t&&V(t.schedule)}(rs(t))?t.pop():void 0}function ys(t,n=0){return be((e,r)=>{e.subscribe(Me(r,i=>Es(r,t,()=>r.next(i),n),()=>Es(r,t,()=>r.complete(),n),i=>Es(r,t,()=>r.error(i),n)))})}function Wa(t,n=0){return be((e,r)=>{r.add(t.schedule(()=>e.subscribe(r),n))})}function fu(t,n){if(!t)throw new Error("Iterable cannot be null");return new xt(e=>{Es(e,n,()=>{const r=t[Symbol.asyncIterator]();Es(e,n,()=>{r.next().then(i=>{i.done?e.complete():e.next(i.value)})},0,!0)})})}function ss(t,n){return n?function Ga(t,n){if(null!=t){if(zn(t))return function bu(t,n){return Rr(t).pipe(Wa(n),ys(n))}(t,n);if(tr(t))return function $r(t,n){return new xt(e=>{let r=0;return n.schedule(function(){r===t.length?e.complete():(e.next(t[r++]),e.closed||this.schedule())})})}(t,n);if(dr(t))return function Ra(t,n){return Rr(t).pipe(Wa(n),ys(n))}(t,n);if(vn(t))return fu(t,n);if(wr(t))return function pr(t,n){return new xt(e=>{let r;return Es(e,n,()=>{r=t[Qn](),Es(e,n,()=>{let i,s;try{({value:i,done:s}=r.next())}catch(o){return void e.error(o)}s?e.complete():e.next(i)},0,!0)}),()=>V(r?.return)&&r.return()})}(t,n);if(si(t))return function Xs(t,n){return fu(Dn(t),n)}(t,n)}throw sr(t)}(t,n):Rr(t)}class jr extends ee{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){const e=super._subscribe(n);return!e.closed&&n.next(this._value),e}getValue(){const{hasError:n,thrownError:e,_value:r}=this;if(n)throw e;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}}function qn(...t){return ss(t,eo(t))}function ga(t={}){const{connector:n=(()=>new ee),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:i=!0}=t;return s=>{let o,a,u,c=0,d=!1,p=!1;const v=()=>{a?.unsubscribe(),a=void 0},x=()=>{v(),o=u=void 0,d=p=!1},w=()=>{const b=o;x(),b?.unsubscribe()};return be((b,T)=>{c++,!p&&!d&&v();const N=u=u??n();T.add(()=>{c--,0===c&&!p&&!d&&(a=nr(w,i))}),N.subscribe(T),!o&&c>0&&(o=new ot({next:S=>N.next(S),error:S=>{p=!0,v(),a=nr(x,e,S),N.error(S)},complete:()=>{d=!0,v(),a=nr(x,r),N.complete()}}),Rr(b).subscribe(o))})(s)}}function nr(t,n,...e){if(!0===n)return void t();if(!1===n)return;const r=new ot({next:()=>{r.unsubscribe(),t()}});return Rr(n(...e)).subscribe(r)}function bo(t,n){return be((e,r)=>{let i=null,s=0,o=!1;const a=()=>o&&!i&&r.complete();e.subscribe(Me(r,u=>{i?.unsubscribe();let c=0;const d=s++;Rr(t(u,d)).subscribe(i=Me(r,p=>r.next(n?n(u,p,d,c++):p),()=>{i=null,a()}))},()=>{o=!0,a()}))})}function ya(t,n){return t===n}function Xn(t){for(let n in t)if(t[n]===Xn)return n;throw Error("Could not find renamed property on target object.")}function Cs(t,n){for(const e in n)n.hasOwnProperty(e)&&!t.hasOwnProperty(e)&&(t[e]=n[e])}function Yi(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(Yi).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const n=t.toString();if(null==n)return""+n;const e=n.indexOf("\n");return-1===e?n:n.substring(0,e)}function La(t,n){return null==t||""===t?null===n?"":n:null==n||""===n?t:t+" "+n}const an=Xn({__forward_ref__:Xn});function ei(t){return t.__forward_ref__=ei,t.toString=function(){return Yi(this())},t}function Fn(t){return Ds(t)?t():t}function Ds(t){return"function"==typeof t&&t.hasOwnProperty(an)&&t.__forward_ref__===ei}function Io(t){return t&&!!t.\u0275providers}class We extends Error{constructor(n,e){super(function Kr(t,n){return`NG0${Math.abs(t)}${n?": "+n:""}`}(n,e)),this.code=n}}function mr(t){return"string"==typeof t?t:null==t?"":String(t)}function Wr(t,n){throw new We(-201,!1)}function Yt(t,n){null==t&&function kt(t,n,e,r){throw new Error(`ASSERTION ERROR: ${t}`+(null==r?"":` [Expected=> ${e} ${r} ${n} <=Actual]`))}(n,t,null,"!=")}function $e(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function $n(t){return{providers:t.providers||[],imports:t.imports||[]}}function Vn(t){return wn(t,Zs)||wn(t,tn)}function wn(t,n){return t.hasOwnProperty(n)?t[n]:null}function ni(t){return t&&(t.hasOwnProperty(Xr)||t.hasOwnProperty(Su))?t[Xr]:null}const Zs=Xn({\u0275prov:Xn}),Xr=Xn({\u0275inj:Xn}),tn=Xn({ngInjectableDef:Xn}),Su=Xn({ngInjectorDef:Xn});var xr=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}(xr||{});let qi;function vs(t){const n=qi;return qi=t,n}function ku(t,n,e){const r=Vn(t);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&xr.Optional?null:void 0!==n?n:void Wr(Yi(t))}const us=globalThis;class In{constructor(n,e){this._desc=n,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=$e({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}const Br={},es="__NG_DI_FLAG__",ru="ngTempTokenPath",ls=/\n/gm,va="__source";let Vo;function po(t){const n=Vo;return Vo=t,n}function Jo(t,n=xr.Default){if(void 0===Vo)throw new We(-203,!1);return null===Vo?ku(t,void 0,n):Vo.get(t,n&xr.Optional?null:void 0,n)}function Wn(t,n=xr.Default){return(function fo(){return qi}()||Jo)(Fn(t),n)}function Mn(t,n=xr.Default){return Wn(t,la(n))}function la(t){return typeof t>"u"||"number"==typeof t?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function xa(t){const n=[];for(let e=0;e<t.length;e++){const r=Fn(t[e]);if(Array.isArray(r)){if(0===r.length)throw new We(900,!1);let i,s=xr.Default;for(let o=0;o<r.length;o++){const a=r[o],u=mo(a);"number"==typeof u?-1===u?i=a.token:s|=u:i=a}n.push(Wn(i,s))}else n.push(Wn(r))}return n}function cs(t,n){return t[es]=n,t.prototype[es]=n,t}function mo(t){return t[es]}function $s(t){return{toString:t}.toString()}var Uo=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}(Uo||{}),Ea=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}(Ea||{});const mi={},yi=[],ka=Xn({\u0275cmp:Xn}),Du=Xn({\u0275dir:Xn}),Ha=Xn({\u0275pipe:Xn}),pl=Xn({\u0275mod:Xn}),ta=Xn({\u0275fac:Xn}),Wo=Xn({__NG_ELEMENT_ID__:Xn}),Ns=Xn({__NG_ENV_ID__:Xn});function Tu(t,n,e){let r=t.length;for(;;){const i=t.indexOf(n,e);if(-1===i)return i;if(0===i||t.charCodeAt(i-1)<=32){const s=n.length;if(i+s===r||t.charCodeAt(i+s)<=32)return i}e=i+1}}function Bs(t,n,e){let r=0;for(;r<e.length;){const i=e[r];if("number"==typeof i){if(0!==i)break;r++;const s=e[r++],o=e[r++],a=e[r++];t.setAttribute(n,o,a,s)}else{const s=i,o=e[++r];Ca(s)?t.setProperty(n,s,o):t.setAttribute(n,s,o),r++}}return r}function Go(t){return 3===t||4===t||6===t}function Ca(t){return 64===t.charCodeAt(0)}function Nu(t,n){if(null!==n&&0!==n.length)if(null===t||0===t.length)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){const i=n[r];"number"==typeof i?e=i:0===e||gu(t,e,i,null,-1===e||2===e?n[++r]:null)}}return t}function gu(t,n,e,r,i){let s=0,o=t.length;if(-1===n)o=-1;else for(;s<t.length;){const a=t[s++];if("number"==typeof a){if(a===n){o=-1;break}if(a>n){o=s-1;break}}}for(;s<t.length;){const a=t[s];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==i&&(t[s+1]=i));if(r===t[s+1])return void(t[s+2]=i)}s++,null!==r&&s++,null!==i&&s++}-1!==o&&(t.splice(o,0,n),s=o+1),t.splice(s++,0,e),null!==r&&t.splice(s++,0,r),null!==i&&t.splice(s++,0,i)}const ja="ng-template";function wa(t,n,e){let r=0,i=!0;for(;r<t.length;){let s=t[r++];if("string"==typeof s&&i){const o=t[r++];if(e&&"class"===s&&-1!==Tu(o.toLowerCase(),n,0))return!0}else{if(1===s){for(;r<t.length&&"string"==typeof(s=t[r++]);)if(s.toLowerCase()===n)return!0;return!1}"number"==typeof s&&(i=!1)}}return!1}function qs(t){return 4===t.type&&t.value!==ja}function ea(t,n,e){return n===(4!==t.type||e?t.value:ja)}function go(t,n,e){let r=4;const i=t.attrs||[],s=function Do(t){for(let n=0;n<t.length;n++)if(Go(t[n]))return n;return t.length}(i);let o=!1;for(let a=0;a<n.length;a++){const u=n[a];if("number"!=typeof u){if(!o)if(4&r){if(r=2|1&r,""!==u&&!ea(t,u,e)||""===u&&1===n.length){if(Fa(r))return!1;o=!0}}else{const c=8&r?u:n[++a];if(8&r&&null!==t.attrs){if(!wa(t.attrs,c,e)){if(Fa(r))return!1;o=!0}continue}const p=yu(8&r?"class":u,i,qs(t),e);if(-1===p){if(Fa(r))return!1;o=!0;continue}if(""!==c){let v;v=p>s?"":i[p+1].toLowerCase();const x=8&r?v:null;if(x&&-1!==Tu(x,c,0)||2&r&&c!==v){if(Fa(r))return!1;o=!0}}}}else{if(!o&&!Fa(r)&&!Fa(u))return!1;if(o&&Fa(u))continue;o=!1,r=u|1&r}}return Fa(r)||o}function Fa(t){return 0==(1&t)}function yu(t,n,e,r){if(null===n)return-1;let i=0;if(r||!e){let s=!1;for(;i<n.length;){const o=n[i];if(o===t)return i;if(3===o||6===o)s=!0;else{if(1===o||2===o){let a=n[++i];for(;"string"==typeof a;)a=n[++i];continue}if(4===o)break;if(0===o){i+=4;continue}}i+=s?1:2}return-1}return function ca(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){const r=t[e];if("number"==typeof r)return-1;if(r===n)return e;e++}return-1}(n,t)}function So(t,n,e=!1){for(let r=0;r<n.length;r++)if(go(t,n[r],e))return!0;return!1}function Il(t,n){return t?":not("+n.trim()+")":n}function Au(t){let n=t[0],e=1,r=2,i="",s=!1;for(;e<t.length;){let o=t[e];if("string"==typeof o)if(2&r){const a=t[++e];i+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?i+="."+o:4&r&&(i+=" "+o);else""!==i&&!Fa(o)&&(n+=Il(s,i),i=""),r=o,s=s||!Fa(r);e++}return""!==i&&(n+=Il(s,i)),n}function ha(t){return $s(()=>{const n=_t(t),e={...n,decls:t.decls,vars:t.vars,template:t.template,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,onPush:t.changeDetection===Uo.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&t.dependencies||null,getStandaloneInjector:null,signals:t.signals??!1,data:t.data||{},encapsulation:t.encapsulation||Ea.Emulated,styles:t.styles||yi,_:null,schemas:t.schemas||null,tView:null,id:""};Nt(e);const r=t.dependencies;return e.directiveDefs=Kt(r,!1),e.pipeDefs=Kt(r,!0),e.id=function Ee(t){let n=0;const e=[t.selectors,t.ngContentSelectors,t.hostVars,t.hostAttrs,t.consts,t.vars,t.decls,t.encapsulation,t.standalone,t.signals,t.exportAs,JSON.stringify(t.inputs),JSON.stringify(t.outputs),Object.getOwnPropertyNames(t.type.prototype),!!t.contentQueries,!!t.viewQuery].join("|");for(const i of e)n=Math.imul(31,n)+i.charCodeAt(0)<<0;return n+=2147483648,"c"+n}(e),e})}function Kl(t){return Tr(t)||ri(t)}function Ka(t){return null!==t}function Yr(t){return $s(()=>({type:t.type,bootstrap:t.bootstrap||yi,declarations:t.declarations||yi,imports:t.imports||yi,exports:t.exports||yi,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function vu(t,n){if(null==t)return mi;const e={};for(const r in t)if(t.hasOwnProperty(r)){let i=t[r],s=i;Array.isArray(i)&&(s=i[1],i=i[0]),e[i]=r,n&&(n[i]=s)}return e}function or(t){return $s(()=>{const n=_t(t);return Nt(n),n})}function ws(t){return{type:t.type,name:t.name,factory:null,pure:!1!==t.pure,standalone:!0===t.standalone,onDestroy:t.type.prototype.ngOnDestroy||null}}function Tr(t){return t[ka]||null}function ri(t){return t[Du]||null}function fs(t){return t[Ha]||null}function ct(t,n){const e=t[pl]||null;if(!e&&!0===n)throw new Error(`Type ${Yi(t)} does not have '\u0275mod' property.`);return e}function _t(t){const n={};return{type:t.type,providersResolver:null,factory:null,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:n,inputTransforms:null,inputConfig:t.inputs||mi,exportAs:t.exportAs||null,standalone:!0===t.standalone,signals:!0===t.signals,selectors:t.selectors||yi,viewQuery:t.viewQuery||null,features:t.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:vu(t.inputs,n),outputs:vu(t.outputs)}}function Nt(t){t.features?.forEach(n=>n(t))}function Kt(t,n){if(!t)return null;const e=n?fs:Kl;return()=>("function"==typeof t?t():t).map(r=>e(r)).filter(Ka)}const Te=0,xe=1,Pe=2,fn=3,f=4,E=5,D=6,j=7,mt=8,Ft=9,ce=10,ye=11,Ve=12,sn=13,bn=14,Pn=15,Nr=16,yo=17,Qi=18,ro=19,jo=20,na=21,fa=22,cr=23,ou=24,Lr=25,Qs=1,As=2,bs=7,ra=9,l=11;function m(t){return Array.isArray(t)&&"object"==typeof t[Qs]}function _(t){return Array.isArray(t)&&!0===t[Qs]}function C(t){return 0!=(4&t.flags)}function F(t){return t.componentOffset>-1}function rt(t){return 1==(1&t.flags)}function Dt(t){return!!t.template}function Qt(t){return 0!=(512&t[Pe])}function ah(t,n){return t.hasOwnProperty(ta)?t[ta]:null}let Ba=null,lf=!1;function gl(t){const n=Ba;return Ba=t,n}const cy={version:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{}};function cf(t){if(!_d(t)||t.dirty){if(!t.producerMustRecompute(t)&&!py(t))return void(t.dirty=!1);t.producerRecomputeValue(t),t.dirty=!1}}function fy(t){t.dirty=!0,function dy(t){if(void 0===t.liveConsumerNode)return;const n=lf;lf=!0;try{for(const e of t.liveConsumerNode)e.dirty||fy(e)}finally{lf=n}}(t),t.consumerMarkedDirty?.(t)}function Zp(t){return t&&(t.nextProducerIndex=0),gl(t)}function Yp(t,n){if(gl(n),t&&void 0!==t.producerNode&&void 0!==t.producerIndexOfThis&&void 0!==t.producerLastReadVersion){if(_d(t))for(let e=t.nextProducerIndex;e<t.producerNode.length;e++)hf(t.producerNode[e],t.producerIndexOfThis[e]);for(;t.producerNode.length>t.nextProducerIndex;)t.producerNode.pop(),t.producerLastReadVersion.pop(),t.producerIndexOfThis.pop()}}function py(t){Ph(t);for(let n=0;n<t.producerNode.length;n++){const e=t.producerNode[n],r=t.producerLastReadVersion[n];if(r!==e.version||(cf(e),r!==e.version))return!0}return!1}function my(t){if(Ph(t),_d(t))for(let n=0;n<t.producerNode.length;n++)hf(t.producerNode[n],t.producerIndexOfThis[n]);t.producerNode.length=t.producerLastReadVersion.length=t.producerIndexOfThis.length=0,t.liveConsumerNode&&(t.liveConsumerNode.length=t.liveConsumerIndexOfThis.length=0)}function hf(t,n){if(function yy(t){t.liveConsumerNode??=[],t.liveConsumerIndexOfThis??=[]}(t),Ph(t),1===t.liveConsumerNode.length)for(let r=0;r<t.producerNode.length;r++)hf(t.producerNode[r],t.producerIndexOfThis[r]);const e=t.liveConsumerNode.length-1;if(t.liveConsumerNode[n]=t.liveConsumerNode[e],t.liveConsumerIndexOfThis[n]=t.liveConsumerIndexOfThis[e],t.liveConsumerNode.length--,t.liveConsumerIndexOfThis.length--,n<t.liveConsumerNode.length){const r=t.liveConsumerIndexOfThis[n],i=t.liveConsumerNode[n];Ph(i),i.producerIndexOfThis[r]=n}}function _d(t){return t.consumerIsAlwaysLive||(t?.liveConsumerNode?.length??0)>0}function Ph(t){t.producerNode??=[],t.producerIndexOfThis??=[],t.producerLastReadVersion??=[]}let Zl=null;const Ey=()=>{},F1=(()=>({...cy,consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!1,consumerMarkedDirty:t=>{t.schedule(t.ref)},hasRun:!1,cleanupFn:Ey}))();class $1{constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function yl(){return Cy}function Cy(t){return t.type.prototype.ngOnChanges&&(t.setInput=z1),B1}function B1(){const t=by(this),n=t?.current;if(n){const e=t.previous;if(e===mi)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function z1(t,n,e,r){const i=this.declaredInputs[e],s=by(t)||function V1(t,n){return t[wy]=n}(t,{previous:mi,current:null}),o=s.current||(s.current={}),a=s.previous,u=a[i];o[i]=new $1(u&&u.currentValue,n,a===mi),t[r]=n}yl.ngInherit=!0;const wy="__ngSimpleChanges__";function by(t){return t[wy]||null}const Yl=function(t,n,e){};function vo(t){for(;Array.isArray(t);)t=t[Te];return t}function df(t,n){return vo(n[t])}function $u(t,n){return vo(n[t.index])}function Dy(t,n){return t.data[n]}function tl(t,n){const e=n[t];return m(e)?e:e[Te]}function kc(t,n){return null==n?null:t[n]}function Ht(t){t[yo]=0}function Vt(t){1024&t[Pe]||(t[Pe]|=1024,Ut(t,1))}function $t(t){1024&t[Pe]&&(t[Pe]&=-1025,Ut(t,-1))}function Ut(t,n){let e=t[fn];if(null===e)return;e[E]+=n;let r=e;for(e=e[fn];null!==e&&(1===n&&1===r[E]||-1===n&&0===r[E]);)e[E]+=n,r=e,e=e[fn]}const qt={lFrame:zS(null),bindingsEnabled:!0,skipHydrationRootTNode:null};function rr(){return qt.bindingsEnabled}function qe(){return qt.lFrame.lView}function kr(){return qt.lFrame.tView}function wi(){let t=Po();for(;null!==t&&64===t.type;)t=t.parent;return t}function Po(){return qt.lFrame.currentTNode}function ms(t,n){const e=qt.lFrame;e.currentTNode=t,e.isParent=n}function Oo(){return qt.lFrame.isParent}function Nl(){return qt.lFrame.bindingIndex++}function IV(t,n){const e=qt.lFrame;e.bindingIndex=e.bindingRootIndex=t,K1(n)}function K1(t){qt.lFrame.currentDirectiveIndex=t}function FS(){return qt.lFrame.currentQueryIndex}function Z1(t){qt.lFrame.currentQueryIndex=t}function DV(t){const n=t[xe];return 2===n.type?n.declTNode:1===n.type?t[D]:null}function $S(t,n,e){if(e&xr.SkipSelf){let i=n,s=t;for(;!(i=i.parent,null!==i||e&xr.Host||(i=DV(s),null===i||(s=s[bn],10&i.type))););if(null===i)return!1;n=i,t=s}const r=qt.lFrame=BS();return r.currentTNode=n,r.lView=t,!0}function Y1(t){const n=BS(),e=t[xe];qt.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function BS(){const t=qt.lFrame,n=null===t?null:t.child;return null===n?zS(t):n}function zS(t){const n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=n),n}function VS(){const t=qt.lFrame;return qt.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const US=VS;function q1(){const t=VS();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function nl(){return qt.lFrame.selectedIndex}function xd(t){qt.lFrame.selectedIndex=t}let GS=!0;function Ty(){return GS}function Rh(t){GS=t}function Ny(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){const s=t.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:u,ngAfterViewChecked:c,ngOnDestroy:d}=s;o&&(t.contentHooks??=[]).push(-e,o),a&&((t.contentHooks??=[]).push(e,a),(t.contentCheckHooks??=[]).push(e,a)),u&&(t.viewHooks??=[]).push(-e,u),c&&((t.viewHooks??=[]).push(e,c),(t.viewCheckHooks??=[]).push(e,c)),null!=d&&(t.destroyHooks??=[]).push(e,d)}}function Ay(t,n,e){HS(t,n,3,e)}function My(t,n,e,r){(3&t[Pe])===e&&HS(t,n,e,r)}function Q1(t,n){let e=t[Pe];(3&e)===n&&(e&=8191,e+=1,t[Pe]=e)}function HS(t,n,e,r){const s=r??-1,o=n.length-1;let a=0;for(let u=void 0!==r?65535&t[yo]:0;u<o;u++)if("number"==typeof n[u+1]){if(a=n[u],null!=r&&a>=r)break}else n[u]<0&&(t[yo]+=65536),(a<s||-1==s)&&(LV(t,e,n,u),t[yo]=(4294901760&t[yo])+u+2),u++}function jS(t,n){Yl(4,t,n);const e=gl(null);try{n.call(t)}finally{gl(e),Yl(5,t,n)}}function LV(t,n,e,r){const i=e[r]<0,s=e[r+1],a=t[i?-e[r]:e[r]];i?t[Pe]>>13<t[yo]>>16&&(3&t[Pe])===n&&(t[Pe]+=8192,jS(a,s)):jS(a,s)}const ff=-1;class em{constructor(n,e,r){this.factory=n,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function tx(t){return t!==ff}function nm(t){return 32767&t}function rm(t,n){let e=function BV(t){return t>>16}(t),r=n;for(;e>0;)r=r[bn],e--;return r}let ex=!0;function Py(t){const n=ex;return ex=t,n}const KS=255,XS=5;let zV=0;const Fc={};function Oy(t,n){const e=ZS(t,n);if(-1!==e)return e;const r=n[xe];r.firstCreatePass&&(t.injectorIndex=n.length,nx(r.data,t),nx(n,null),nx(r.blueprint,null));const i=Ry(t,n),s=t.injectorIndex;if(tx(i)){const o=nm(i),a=rm(i,n),u=a[xe].data;for(let c=0;c<8;c++)n[s+c]=a[o+c]|u[o+c]}return n[s+8]=i,s}function nx(t,n){t.push(0,0,0,0,0,0,0,0,n)}function ZS(t,n){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===n[t.injectorIndex+8]?-1:t.injectorIndex}function Ry(t,n){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let e=0,r=null,i=n;for(;null!==i;){if(r=nD(i),null===r)return ff;if(e++,i=i[bn],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return ff}function rx(t,n,e){!function VV(t,n,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(Wo)&&(r=e[Wo]),null==r&&(r=e[Wo]=zV++);const i=r&KS;n.data[t+(i>>XS)]|=1<<i}(t,n,e)}function YS(t,n,e){if(e&xr.Optional||void 0!==t)return t;Wr()}function qS(t,n,e,r){if(e&xr.Optional&&void 0===r&&(r=null),!(e&(xr.Self|xr.Host))){const i=t[Ft],s=vs(void 0);try{return i?i.get(n,r,e&xr.Optional):ku(n,r,e&xr.Optional)}finally{vs(s)}}return YS(r,0,e)}function QS(t,n,e,r=xr.Default,i){if(null!==t){if(2048&n[Pe]&&!(r&xr.Self)){const o=function KV(t,n,e,r,i){let s=t,o=n;for(;null!==s&&null!==o&&2048&o[Pe]&&!(512&o[Pe]);){const a=JS(s,o,e,r|xr.Self,Fc);if(a!==Fc)return a;let u=s.parent;if(!u){const c=o[jo];if(c){const d=c.get(e,Fc,r);if(d!==Fc)return d}u=nD(o),o=o[bn]}s=u}return i}(t,n,e,r,Fc);if(o!==Fc)return o}const s=JS(t,n,e,r,Fc);if(s!==Fc)return s}return qS(n,e,r,i)}function JS(t,n,e,r,i){const s=function GV(t){if("string"==typeof t)return t.charCodeAt(0)||0;const n=t.hasOwnProperty(Wo)?t[Wo]:void 0;return"number"==typeof n?n>=0?n&KS:jV:n}(e);if("function"==typeof s){if(!$S(n,t,r))return r&xr.Host?YS(i,0,r):qS(n,e,r,i);try{let o;if(o=s(r),null!=o||r&xr.Optional)return o;Wr()}finally{US()}}else if("number"==typeof s){let o=null,a=ZS(t,n),u=ff,c=r&xr.Host?n[Pn][D]:null;for((-1===a||r&xr.SkipSelf)&&(u=-1===a?Ry(t,n):n[a+8],u!==ff&&eD(r,!1)?(o=n[xe],a=nm(u),n=rm(u,n)):a=-1);-1!==a;){const d=n[xe];if(tD(s,a,d.data)){const p=WV(a,n,e,o,r,c);if(p!==Fc)return p}u=n[a+8],u!==ff&&eD(r,n[xe].data[a+8]===c)&&tD(s,a,n)?(o=d,a=nm(u),n=rm(u,n)):a=-1}}return i}function WV(t,n,e,r,i,s){const o=n[xe],a=o.data[t+8],d=Ly(a,o,e,null==r?F(a)&&ex:r!=o&&0!=(3&a.type),i&xr.Host&&s===a);return null!==d?Ed(n,o,d,a):Fc}function Ly(t,n,e,r,i){const s=t.providerIndexes,o=n.data,a=1048575&s,u=t.directiveStart,d=s>>20,v=i?a+d:t.directiveEnd;for(let x=r?a:a+d;x<v;x++){const w=o[x];if(x<u&&e===w||x>=u&&w.type===e)return x}if(i){const x=o[u];if(x&&Dt(x)&&x.type===e)return u}return null}function Ed(t,n,e,r){let i=t[e];const s=n.data;if(function kV(t){return t instanceof em}(i)){const o=i;o.resolving&&function Kn(t,n){const e=n?`. Dependency path: ${n.join(" > ")} > ${t}`:"";throw new We(-200,`Circular dependency in DI detected for ${t}${e}`)}(function ai(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():mr(t)}(s[e]));const a=Py(o.canSeeViewProviders);o.resolving=!0;const c=o.injectImpl?vs(o.injectImpl):null;$S(t,r,xr.Default);try{i=t[e]=o.factory(void 0,s,t,r),n.firstCreatePass&&e>=r.directiveStart&&function RV(t,n,e){const{ngOnChanges:r,ngOnInit:i,ngDoCheck:s}=n.type.prototype;if(r){const o=Cy(n);(e.preOrderHooks??=[]).push(t,o),(e.preOrderCheckHooks??=[]).push(t,o)}i&&(e.preOrderHooks??=[]).push(0-t,i),s&&((e.preOrderHooks??=[]).push(t,s),(e.preOrderCheckHooks??=[]).push(t,s))}(e,s[e],n)}finally{null!==c&&vs(c),Py(a),o.resolving=!1,US()}}return i}function tD(t,n,e){return!!(e[n+(t>>XS)]&1<<t)}function eD(t,n){return!(t&xr.Self||t&xr.Host&&n)}class rl{constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return QS(this._tNode,this._lView,n,la(r),e)}}function jV(){return new rl(wi(),qe())}function Mu(t){return $s(()=>{const n=t.prototype.constructor,e=n[ta]||ix(n),r=Object.prototype;let i=Object.getPrototypeOf(t.prototype).constructor;for(;i&&i!==r;){const s=i[ta]||ix(i);if(s&&s!==e)return s;i=Object.getPrototypeOf(i)}return s=>new s})}function ix(t){return Ds(t)?()=>{const n=ix(Fn(t));return n&&n()}:ah(t)}function nD(t){const n=t[xe],e=n.type;return 2===e?n.declTNode:1===e?t[D]:null}const pf="__annotations__",mf="__parameters__",gf="__prop__metadata__";function rD(t,n,e,r,i){return $s(()=>{const s=sx(n);function o(...a){if(this instanceof o)return s.call(this,...a),this;const u=new o(...a);return function(d){return i&&i(d,...a),(d.hasOwnProperty(pf)?d[pf]:Object.defineProperty(d,pf,{value:[]})[pf]).push(u),r&&r(d),d}}return e&&(o.prototype=Object.create(e.prototype)),o.prototype.ngMetadataName=t,o.annotationCls=o,o})}function sx(t){return function(...e){if(t){const r=t(...e);for(const i in r)this[i]=r[i]}}}function yf(t,n,e){return $s(()=>{const r=sx(n);function i(...s){if(this instanceof i)return r.apply(this,s),this;const o=new i(...s);return a.annotation=o,a;function a(u,c,d){const p=u.hasOwnProperty(mf)?u[mf]:Object.defineProperty(u,mf,{value:[]})[mf];for(;p.length<=d;)p.push(null);return(p[d]=p[d]||[]).push(o),u}}return e&&(i.prototype=Object.create(e.prototype)),i.prototype.ngMetadataName=t,i.annotationCls=i,i})}const XV=yf("Attribute",t=>({attributeName:t,__NG_ELEMENT_ID__:()=>function ky(t){return function UV(t,n){if("class"===n)return t.classes;if("style"===n)return t.styles;const e=t.attrs;if(e){const r=e.length;let i=0;for(;i<r;){const s=e[i];if(Go(s))break;if(0===s)i+=2;else if("number"==typeof s)for(i++;i<r&&"string"==typeof e[i];)i++;else{if(s===n)return e[i+1];i+=2}}}return null}(wi(),t)}(t)}));function lu(t){const n=us.ng;if(n&&n.\u0275compilerFacade)return n.\u0275compilerFacade;throw new Error("JIT compiler unavailable")}const qV=Function;function sm(t){return"function"==typeof t}function _f(t,n){t.forEach(e=>Array.isArray(e)?_f(e,n):n(e))}function iD(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function Fy(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}function om(t,n){const e=[];for(let r=0;r<t;r++)e.push(n);return e}function Al(t,n,e){let r=xf(t,n);return r>=0?t[1|r]=e:(r=~r,function tU(t,n,e,r){let i=t.length;if(i==n)t.push(e,r);else if(1===i)t.push(r,t[0]),t[0]=e;else{for(i--,t.push(t[i-1],t[i]);i>n;)t[i]=t[i-2],i--;t[n]=e,t[n+1]=r}}(t,r,n,e)),r}function ox(t,n){const e=xf(t,n);if(e>=0)return t[1|e]}function xf(t,n){return function sD(t,n,e){let r=0,i=t.length>>e;for(;i!==r;){const s=r+(i-r>>1),o=t[s<<e];if(n===o)return s<<e;o>n?i=s:r=s+1}return~(i<<e)}(t,n,1)}const eU=/^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/,nU=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/,rU=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/,iU=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;class oU{constructor(n){this._reflect=n||us.Reflect}factory(n){return(...e)=>new n(...e)}_zipTypesAndAnnotations(n,e){let r;r=om(typeof n>"u"?e.length:n.length);for(let i=0;i<r.length;i++)r[i]=typeof n>"u"?[]:n[i]&&n[i]!=Object?[n[i]]:[],e&&null!=e[i]&&(r[i]=r[i].concat(e[i]));return r}_ownParameters(n,e){if(function sU(t){return eU.test(t)||iU.test(t)||nU.test(t)&&!rU.test(t)}(n.toString()))return null;if(n.parameters&&n.parameters!==e.parameters)return n.parameters;const i=n.ctorParameters;if(i&&i!==e.ctorParameters){const a="function"==typeof i?i():i,u=a.map(d=>d&&d.type),c=a.map(d=>d&&ax(d.decorators));return this._zipTypesAndAnnotations(u,c)}const s=n.hasOwnProperty(mf)&&n[mf],o=this._reflect&&this._reflect.getOwnMetadata&&this._reflect.getOwnMetadata("design:paramtypes",n);return o||s?this._zipTypesAndAnnotations(o,s):om(n.length)}parameters(n){if(!sm(n))return[];const e=$y(n);let r=this._ownParameters(n,e);return!r&&e!==Object&&(r=this.parameters(e)),r||[]}_ownAnnotations(n,e){if(n.annotations&&n.annotations!==e.annotations){let r=n.annotations;return"function"==typeof r&&r.annotations&&(r=r.annotations),r}return n.decorators&&n.decorators!==e.decorators?ax(n.decorators):n.hasOwnProperty(pf)?n[pf]:null}annotations(n){if(!sm(n))return[];const e=$y(n),r=this._ownAnnotations(n,e)||[];return(e!==Object?this.annotations(e):[]).concat(r)}_ownPropMetadata(n,e){if(n.propMetadata&&n.propMetadata!==e.propMetadata){let r=n.propMetadata;return"function"==typeof r&&r.propMetadata&&(r=r.propMetadata),r}if(n.propDecorators&&n.propDecorators!==e.propDecorators){const r=n.propDecorators,i={};return Object.keys(r).forEach(s=>{i[s]=ax(r[s])}),i}return n.hasOwnProperty(gf)?n[gf]:null}propMetadata(n){if(!sm(n))return{};const e=$y(n),r={};if(e!==Object){const s=this.propMetadata(e);Object.keys(s).forEach(o=>{r[o]=s[o]})}const i=this._ownPropMetadata(n,e);return i&&Object.keys(i).forEach(s=>{const o=[];r.hasOwnProperty(s)&&o.push(...r[s]),o.push(...i[s]),r[s]=o}),r}ownPropMetadata(n){return sm(n)&&this._ownPropMetadata(n,$y(n))||{}}hasLifecycleHook(n,e){return n instanceof qV&&e in n.prototype}}function ax(t){return t?t.map(n=>new(0,n.type.annotationCls)(...n.args?n.args:[])):[]}function $y(t){const n=t.prototype?Object.getPrototypeOf(t.prototype):null;return(n?n.constructor:null)||Object}const aU=cs(yf("Inject",t=>({token:t})),-1),By=cs(yf("Optional"),8),uU=cs(yf("Self"),2),zy=cs(yf("SkipSelf"),4),lU=cs(yf("Host"),1);let oD=null;function Vy(t){return aD(function ux(){return oD=oD||new oU}().parameters(t))}function aD(t){return t.map(n=>function cU(t){const n={token:null,attribute:null,host:!1,optional:!1,self:!1,skipSelf:!1};if(Array.isArray(t)&&t.length>0)for(let e=0;e<t.length;e++){const r=t[e];if(void 0===r)continue;const i=Object.getPrototypeOf(r);if(r instanceof By||"Optional"===i.ngMetadataName)n.optional=!0;else if(r instanceof zy||"SkipSelf"===i.ngMetadataName)n.skipSelf=!0;else if(r instanceof uU||"Self"===i.ngMetadataName)n.self=!0;else if(r instanceof lU||"Host"===i.ngMetadataName)n.host=!0;else if(r instanceof aU)n.token=r.token;else if(r instanceof XV){if(void 0===r.attributeName)throw new We(204,!1);n.attribute=r.attributeName}else n.token=r}else n.token=void 0===t||Array.isArray(t)&&0===t.length?null:t;return n}(n))}function Hy(t){return 128==(128&t.flags)}var Lh=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}(Lh||{});const hx=new Map;let bU=0;const fx="__ngContext__";function zu(t,n){m(n)?(t[fx]=n[ro],function SU(t){hx.set(t[ro],t)}(n)):t[fx]=n}let px;function mx(t,n){return px(t,n)}function lm(t){const n=t[fn];return _(n)?n[fn]:n}function ID(t){return DD(t[Ve])}function SD(t){return DD(t[f])}function DD(t){for(;null!==t&&!_(t);)t=t[f];return t}function wf(t,n,e,r,i){if(null!=r){let s,o=!1;_(r)?s=r:m(r)&&(o=!0,r=r[Te]);const a=vo(r);0===t&&null!==e?null==i?MD(n,e,a):Cd(n,e,a,i||null,!0):1===t&&null!==e?Cd(n,e,a,i||null,!0):2===t?function Qy(t,n,e){const r=Yy(t,n);r&&function HU(t,n,e,r){t.removeChild(n,e,r)}(t,r,n,e)}(n,a,o):3===t&&n.destroyNode(a),null!=s&&function XU(t,n,e,r,i){const s=e[bs];s!==vo(e)&&wf(n,t,r,s,i);for(let a=l;a<e.length;a++){const u=e[a];hm(u[xe],u,t,n,r,s)}}(n,t,s,e,i)}}function Xy(t,n,e){return t.createElement(n,e)}function ND(t,n){const e=t[ra],r=e.indexOf(n);$t(n),e.splice(r,1)}function Zy(t,n){if(t.length<=l)return;const e=l+n,r=t[e];if(r){const i=r[Nr];null!==i&&i!==t&&ND(i,r),n>0&&(t[e-1][f]=r[f]);const s=Fy(t,l+n);!function FU(t,n){hm(t,n,n[ye],2,null,null),n[Te]=null,n[D]=null}(r[xe],r);const o=s[Qi];null!==o&&o.detachView(s[xe]),r[fn]=null,r[f]=null,r[Pe]&=-129}return r}function yx(t,n){if(!(256&n[Pe])){const e=n[ye];n[cr]&&my(n[cr]),n[ou]&&my(n[ou]),e.destroyNode&&hm(t,n,e,3,null,null),function zU(t){let n=t[Ve];if(!n)return vx(t[xe],t);for(;n;){let e=null;if(m(n))e=n[Ve];else{const r=n[l];r&&(e=r)}if(!e){for(;n&&!n[f]&&n!==t;)m(n)&&vx(n[xe],n),n=n[fn];null===n&&(n=t),m(n)&&vx(n[xe],n),e=n&&n[f]}n=e}}(n)}}function vx(t,n){if(!(256&n[Pe])){n[Pe]&=-129,n[Pe]|=256,function GU(t,n){let e;if(null!=t&&null!=(e=t.destroyHooks))for(let r=0;r<e.length;r+=2){const i=n[e[r]];if(!(i instanceof em)){const s=e[r+1];if(Array.isArray(s))for(let o=0;o<s.length;o+=2){const a=i[s[o]],u=s[o+1];Yl(4,a,u);try{u.call(a)}finally{Yl(5,a,u)}}else{Yl(4,i,s);try{s.call(i)}finally{Yl(5,i,s)}}}}}(t,n),function WU(t,n){const e=t.cleanup,r=n[j];if(null!==e)for(let s=0;s<e.length-1;s+=2)if("string"==typeof e[s]){const o=e[s+3];o>=0?r[o]():r[-o].unsubscribe(),s+=2}else e[s].call(r[e[s+1]]);null!==r&&(n[j]=null);const i=n[na];if(null!==i){n[na]=null;for(let s=0;s<i.length;s++)(0,i[s])()}}(t,n),1===n[xe].type&&n[ye].destroy();const e=n[Nr];if(null!==e&&_(n[fn])){e!==n[fn]&&ND(e,n);const r=n[Qi];null!==r&&r.detachView(t)}!function DU(t){hx.delete(t[ro])}(n)}}function _x(t,n,e){return function AD(t,n,e){let r=n;for(;null!==r&&40&r.type;)r=(n=r).parent;if(null===r)return e[Te];{const{componentOffset:i}=r;if(i>-1){const{encapsulation:s}=t.data[r.directiveStart+i];if(s===Ea.None||s===Ea.Emulated)return null}return $u(r,e)}}(t,n.parent,e)}function Cd(t,n,e,r,i){t.insertBefore(n,e,r,i)}function MD(t,n,e){t.appendChild(n,e)}function PD(t,n,e,r,i){null!==r?Cd(t,n,e,r,i):MD(t,n,e)}function Yy(t,n){return t.parentNode(n)}let xx,bx,LD=function RD(t,n,e){return 40&t.type?$u(t,e):null};function qy(t,n,e,r){const i=_x(t,r,n),s=n[ye],a=function OD(t,n,e){return LD(t,n,e)}(r.parent||n[D],r,n);if(null!=i)if(Array.isArray(e))for(let u=0;u<e.length;u++)PD(s,i,e[u],a,!1);else PD(s,i,e,a,!1);void 0!==xx&&xx(s,r,n,e,i)}function cm(t,n){if(null!==n){const e=n.type;if(3&e)return $u(n,t);if(4&e)return Ex(-1,t[n.index]);if(8&e){const r=n.child;if(null!==r)return cm(t,r);{const i=t[n.index];return _(i)?Ex(-1,i):vo(i)}}if(32&e)return mx(n,t)()||vo(t[n.index]);{const r=FD(t,n);return null!==r?Array.isArray(r)?r[0]:cm(lm(t[Pn]),r):cm(t,n.next)}}return null}function FD(t,n){return null!==n?t[Pn][D].projection[n.projection]:null}function Ex(t,n){const e=l+t+1;if(e<n.length){const r=n[e],i=r[xe].firstChild;if(null!==i)return cm(r,i)}return n[bs]}function Cx(t,n,e,r,i,s,o){for(;null!=e;){const a=r[e.index],u=e.type;if(o&&0===n&&(a&&zu(vo(a),r),e.flags|=2),32!=(32&e.flags))if(8&u)Cx(t,n,e.child,r,i,s,!1),wf(n,t,i,a,s);else if(32&u){const c=mx(e,r);let d;for(;d=c();)wf(n,t,i,d,s);wf(n,t,i,a,s)}else 16&u?BD(t,n,r,e,i,s):wf(n,t,i,a,s);e=o?e.projectionNext:e.next}}function hm(t,n,e,r,i,s){Cx(e,r,t.firstChild,n,i,s,!1)}function BD(t,n,e,r,i,s){const o=e[Pn],u=o[D].projection[r.projection];if(Array.isArray(u))for(let c=0;c<u.length;c++)wf(n,t,i,u[c],s);else{let c=u;const d=o[fn];Hy(r)&&(c.flags|=128),Cx(t,n,c,d,i,s,!0)}}function zD(t,n,e){""===e?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function VD(t,n,e){const{mergedAttrs:r,classes:i,styles:s}=e;null!==r&&Bs(t,n,r),null!==i&&zD(t,n,i),null!==s&&function YU(t,n,e){t.setAttribute(n,"style",e)}(t,n,s)}class HD{constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}const mm=new In("ENVIRONMENT_INITIALIZER"),eT=new In("INJECTOR",-1),nT=new In("INJECTOR_DEF_TYPES");class Ax{get(n,e=Br){if(e===Br){const r=new Error(`NullInjectorError: No provider for ${Yi(n)}!`);throw r.name="NullInjectorError",r}return e}}function w4(...t){return{\u0275providers:iT(0,t),\u0275fromNgModule:!0}}function iT(t,...n){const e=[],r=new Set;let i;const s=o=>{e.push(o)};return _f(n,o=>{const a=o;n0(a,s,[],r)&&(i||=[],i.push(a))}),void 0!==i&&sT(i,s),e}function sT(t,n){for(let e=0;e<t.length;e++){const{ngModule:r,providers:i}=t[e];Mx(i,s=>{n(s,r)})}}function n0(t,n,e,r){if(!(t=Fn(t)))return!1;let i=null,s=ni(t);const o=!s&&Tr(t);if(s||o){if(o&&!o.standalone)return!1;i=t}else{const u=t.ngModule;if(s=ni(u),!s)return!1;i=u}const a=r.has(i);if(o){if(a)return!1;if(r.add(i),o.dependencies){const u="function"==typeof o.dependencies?o.dependencies():o.dependencies;for(const c of u)n0(c,n,e,r)}}else{if(!s)return!1;{if(null!=s.imports&&!a){let c;r.add(i);try{_f(s.imports,d=>{n0(d,n,e,r)&&(c||=[],c.push(d))})}finally{}void 0!==c&&sT(c,n)}if(!a){const c=ah(i)||(()=>new i);n({provide:i,useFactory:c,deps:yi},i),n({provide:nT,useValue:i,multi:!0},i),n({provide:mm,useValue:()=>Wn(i),multi:!0},i)}const u=s.providers;if(null!=u&&!a){const c=t;Mx(u,d=>{n(d,c)})}}}return i!==t&&void 0!==t.providers}function Mx(t,n){for(let e of t)Io(e)&&(e=e.\u0275providers),Array.isArray(e)?Mx(e,n):n(e)}const b4=Xn({provide:String,useValue:Xn});function Px(t){return null!==t&&"object"==typeof t&&b4 in t}function wd(t){return"function"==typeof t}const Ox=new In("Set Injector scope."),r0={},S4={};let Rx;function s0(){return void 0===Rx&&(Rx=new Ax),Rx}class Ql{}class Df extends Ql{get destroyed(){return this._destroyed}constructor(n,e,r,i){super(),this.parent=e,this.source=r,this.scopes=i,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,kx(n,o=>this.processProvider(o)),this.records.set(eT,Tf(void 0,this)),i.has("environment")&&this.records.set(Ql,Tf(void 0,this));const s=this.records.get(Ox);null!=s&&"string"==typeof s.value&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(nT.multi,yi,xr.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const e of this._ngOnDestroyHooks)e.ngOnDestroy();const n=this._onDestroyHooks;this._onDestroyHooks=[];for(const e of n)e()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear()}}onDestroy(n){return this.assertNotDestroyed(),this._onDestroyHooks.push(n),()=>this.removeOnDestroy(n)}runInContext(n){this.assertNotDestroyed();const e=po(this),r=vs(void 0);try{return n()}finally{po(e),vs(r)}}get(n,e=Br,r=xr.Default){if(this.assertNotDestroyed(),n.hasOwnProperty(Ns))return n[Ns](this);r=la(r);const s=po(this),o=vs(void 0);try{if(!(r&xr.SkipSelf)){let u=this.records.get(n);if(void 0===u){const c=function M4(t){return"function"==typeof t||"object"==typeof t&&t instanceof In}(n)&&Vn(n);u=c&&this.injectableDefInScope(c)?Tf(Lx(n),r0):null,this.records.set(n,u)}if(null!=u)return this.hydrate(n,u)}return(r&xr.Self?s0():this.parent).get(n,e=r&xr.Optional&&e===Br?null:e)}catch(a){if("NullInjectorError"===a.name){if((a[ru]=a[ru]||[]).unshift(Yi(n)),s)throw a;return function su(t,n,e,r){const i=t[ru];throw n[va]&&i.unshift(n[va]),t.message=function Ys(t,n,e,r=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.slice(2):t;let i=Yi(n);if(Array.isArray(n))i=n.map(Yi).join(" -> ");else if("object"==typeof n){let s=[];for(let o in n)if(n.hasOwnProperty(o)){let a=n[o];s.push(o+":"+("string"==typeof a?JSON.stringify(a):Yi(a)))}i=`{${s.join(", ")}}`}return`${e}${r?"("+r+")":""}[${i}]: ${t.replace(ls,"\n  ")}`}("\n"+t.message,i,e,r),t.ngTokenPath=i,t[ru]=null,t}(a,n,"R3InjectorError",this.source)}throw a}finally{vs(o),po(s)}}resolveInjectorInitializers(){const n=po(this),e=vs(void 0);try{const i=this.get(mm.multi,yi,xr.Self);for(const s of i)s()}finally{po(n),vs(e)}}toString(){const n=[],e=this.records;for(const r of e.keys())n.push(Yi(r));return`R3Injector[${n.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new We(205,!1)}processProvider(n){let e=wd(n=Fn(n))?n:Fn(n&&n.provide);const r=function T4(t){return Px(t)?Tf(void 0,t.useValue):Tf(uT(t),r0)}(n);if(wd(n)||!0!==n.multi)this.records.get(e);else{let i=this.records.get(e);i||(i=Tf(void 0,r0,!0),i.factory=()=>xa(i.multi),this.records.set(e,i)),e=n,i.multi.push(n)}this.records.set(e,r)}hydrate(n,e){return e.value===r0&&(e.value=S4,e.value=e.factory()),"object"==typeof e.value&&e.value&&function A4(t){return null!==t&&"object"==typeof t&&"function"==typeof t.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(n){if(!n.providedIn)return!1;const e=Fn(n.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(n){const e=this._onDestroyHooks.indexOf(n);-1!==e&&this._onDestroyHooks.splice(e,1)}}function Lx(t){const n=Vn(t),e=null!==n?n.factory:ah(t);if(null!==e)return e;if(t instanceof In)throw new We(204,!1);if(t instanceof Function)return function D4(t){const n=t.length;if(n>0)throw om(n,"?"),new We(204,!1);const e=function _r(t){return t&&(t[Zs]||t[tn])||null}(t);return null!==e?()=>e.factory(t):()=>new t}(t);throw new We(204,!1)}function uT(t,n,e){let r;if(wd(t)){const i=Fn(t);return ah(i)||Lx(i)}if(Px(t))r=()=>Fn(t.useValue);else if(function aT(t){return!(!t||!t.useFactory)}(t))r=()=>t.useFactory(...xa(t.deps||[]));else if(function oT(t){return!(!t||!t.useExisting)}(t))r=()=>Wn(Fn(t.useExisting));else{const i=Fn(t&&(t.useClass||t.provide));if(!function N4(t){return!!t.deps}(t))return ah(i)||Lx(i);r=()=>new i(...xa(t.deps))}return r}function Tf(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function kx(t,n){for(const e of t)Array.isArray(e)?kx(e,n):e&&Io(e)?kx(e.\u0275providers,n):n(e)}const o0=new In("AppId",{providedIn:"root",factory:()=>P4}),P4="ng",lT=new In("Platform Initializer"),Nf=new In("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),cT=new In("CSP nonce",{providedIn:"root",factory:()=>function If(){if(void 0!==bx)return bx;if(typeof document<"u")return document;throw new We(210,!1)}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});let hT=(t,n,e)=>null;function Gx(t,n,e=!1){return hT(t,n,e)}class U4{}class pT{}class G4{resolveComponentFactory(n){throw function W4(t){const n=Error(`No component factory found for ${Yi(t)}.`);return n.ngComponent=t,n}(n)}}let d0=(()=>{class t{static#t=this.NULL=new G4}return t})();function H4(){return Pf(wi(),qe())}function Pf(t,n){return new Ml($u(t,n))}let Ml=(()=>{class t{constructor(e){this.nativeElement=e}static#t=this.__NG_ELEMENT_ID__=H4}return t})();function j4(t){return t instanceof Ml?t.nativeElement:t}class gT{}let ch=(()=>{class t{constructor(){this.destroyNode=null}static#t=this.__NG_ELEMENT_ID__=()=>function K4(){const t=qe(),e=tl(wi().index,t);return(m(e)?e:t)[ye]}()}return t})(),X4=(()=>{class t{static#t=this.\u0275prov=$e({token:t,providedIn:"root",factory:()=>null})}return t})();class vm{constructor(n){this.full=n,this.major=n.split(".")[0],this.minor=n.split(".")[1],this.patch=n.split(".").slice(2).join(".")}}const Z4=new vm("16.2.12"),Kx={},yT={\u0275\u0275defineInjectable:$e,\u0275\u0275defineInjector:$n,\u0275\u0275inject:Wn,\u0275\u0275invalidFactoryDep:function Mo(t){throw new We(202,!1)},resolveForwardRef:Fn};const q4=Xn({provide:String,useValue:Xn});function vT(t){return void 0!==t.useClass}function _T(t){return void 0!==t.useFactory}const eW=rD("Injectable",void 0,void 0,void 0,(t,n)=>function Y4(t,n){let e=null,r=null;t.hasOwnProperty(Zs)||Object.defineProperty(t,Zs,{get:()=>(null===e&&(e=lu().compileInjectable(yT,`ng:///${t.name}/\u0275prov.js`,function tW(t,n){const e=n||{providedIn:null},r={name:t.name,type:t,typeArgumentCount:0,providedIn:e.providedIn};return(vT(e)||_T(e))&&void 0!==e.deps&&(r.deps=aD(e.deps)),vT(e)?r.useClass=e.useClass:function Q4(t){return q4 in t}(e)?r.useValue=e.useValue:_T(e)?r.useFactory=e.useFactory:function J4(t){return void 0!==t.useExisting}(e)&&(r.useExisting=e.useExisting),r}(t,n))),e)}),t.hasOwnProperty(ta)||Object.defineProperty(t,ta,{get:()=>{if(null===r){const i=lu();r=i.compileFactory(yT,`ng:///${t.name}/\u0275fac.js`,{name:t.name,type:t,typeArgumentCount:0,deps:Vy(t),target:i.FactoryTarget.Injectable})}return r},configurable:!0})}(t,n));function xT(t,n=null,e=null,r){const i=ET(t,n,e,r);return i.resolveInjectorInitializers(),i}function ET(t,n=null,e=null,r,i=new Set){const s=[e||yi,w4(t)];return r=r||("object"==typeof t?void 0:Yi(t)),new Df(s,n||s0(),r||null,i)}let Pl=(()=>{class t{static#t=this.THROW_IF_NOT_FOUND=Br;static#e=this.NULL=new Ax;static create(e,r){if(Array.isArray(e))return xT({name:""},r,e,"");{const i=e.name??"";return xT({name:i},e.parent,e.providers,i)}}static#n=this.\u0275prov=$e({token:t,providedIn:"any",factory:()=>Wn(eT)});static#r=this.__NG_ELEMENT_ID__=-1}return t})();function Zx(t){return t.ngOriginalError}class hh{constructor(){this._console=console}handleError(n){const e=this._findOriginalError(n);this._console.error("ERROR",n),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(n){let e=n&&Zx(n);for(;e&&Zx(e);)e=Zx(e);return e||null}}function qx(t){return n=>{setTimeout(t,void 0,n)}}const Sa=class rW extends ee{constructor(n=!1){super(),this.__isAsync=n}emit(n){super.next(n)}subscribe(n,e,r){let i=n,s=e||(()=>null),o=r;if(n&&"object"==typeof n){const u=n;i=u.next?.bind(u),s=u.error?.bind(u),o=u.complete?.bind(u)}this.__isAsync&&(s=qx(s),i&&(i=qx(i)),o&&(o=qx(o)));const a=super.subscribe({next:i,error:s,complete:o});return n instanceof R&&n.add(a),a}};function wT(...t){}class Ro{constructor({enableLongStackTrace:n=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Sa(!1),this.onMicrotaskEmpty=new Sa(!1),this.onStable=new Sa(!1),this.onError=new Sa(!1),typeof Zone>"u")throw new We(908,!1);Zone.assertZonePatched();const i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),n&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!r&&e,i.shouldCoalesceRunChangeDetection=r,i.lastRequestAnimationFrameId=-1,i.nativeRequestAnimationFrame=function iW(){const t="function"==typeof us.requestAnimationFrame;let n=us[t?"requestAnimationFrame":"setTimeout"],e=us[t?"cancelAnimationFrame":"clearTimeout"];if(typeof Zone<"u"&&n&&e){const r=n[Zone.__symbol__("OriginalDelegate")];r&&(n=r);const i=e[Zone.__symbol__("OriginalDelegate")];i&&(e=i)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function aW(t){const n=()=>{!function oW(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(us,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,Jx(t),t.isCheckStableRunning=!0,Qx(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),Jx(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,i,s,o,a)=>{if(function lW(t){return!(!Array.isArray(t)||1!==t.length)&&!0===t[0].data?.__ignore_ng_zone__}(a))return e.invokeTask(i,s,o,a);try{return bT(t),e.invokeTask(i,s,o,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===s.type||t.shouldCoalesceRunChangeDetection)&&n(),IT(t)}},onInvoke:(e,r,i,s,o,a,u)=>{try{return bT(t),e.invoke(i,s,o,a,u)}finally{t.shouldCoalesceRunChangeDetection&&n(),IT(t)}},onHasTask:(e,r,i,s)=>{e.hasTask(i,s),r===i&&("microTask"==s.change?(t._hasPendingMicrotasks=s.microTask,Jx(t),Qx(t)):"macroTask"==s.change&&(t.hasPendingMacrotasks=s.macroTask))},onHandleError:(e,r,i,s)=>(e.handleError(i,s),t.runOutsideAngular(()=>t.onError.emit(s)),!1)})}(i)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Ro.isInAngularZone())throw new We(909,!1)}static assertNotInAngularZone(){if(Ro.isInAngularZone())throw new We(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,i){const s=this._inner,o=s.scheduleEventTask("NgZoneEvent: "+i,n,sW,wT,wT);try{return s.runTask(o,e,r)}finally{s.cancelTask(o)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}}const sW={};function Qx(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function Jx(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function bT(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function IT(t){t._nesting--,Qx(t)}class uW{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Sa,this.onMicrotaskEmpty=new Sa,this.onStable=new Sa,this.onError=new Sa}run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,i){return n.apply(e,r)}}const ST=new In("",{providedIn:"root",factory:DT});function DT(){const t=Mn(Ro);let n=!0;return function An(...t){const n=eo(t),e=function wo(t,n){return"number"==typeof rs(t)?t.pop():n}(t,1/0),r=t;return r.length?1===r.length?Rr(r[0]):ti(e)(ss(r,n)):Vr}(new xt(i=>{n=t.isStable&&!t.hasPendingMacrotasks&&!t.hasPendingMicrotasks,t.runOutsideAngular(()=>{i.next(n),i.complete()})}),new xt(i=>{let s;t.runOutsideAngular(()=>{s=t.onStable.subscribe(()=>{Ro.assertNotInAngularZone(),queueMicrotask(()=>{!n&&!t.hasPendingMacrotasks&&!t.hasPendingMicrotasks&&(n=!0,i.next(!0))})})});const o=t.onUnstable.subscribe(()=>{Ro.assertInAngularZone(),n&&(n=!1,t.runOutsideAngular(()=>{i.next(!1)}))});return()=>{s.unsubscribe(),o.unsubscribe()}}).pipe(ga()))}function dh(t){return t instanceof Function?t():t}let tE=(()=>{class t{constructor(){this.renderDepth=0,this.handler=null}begin(){this.handler?.validateBegin(),this.renderDepth++}end(){this.renderDepth--,0===this.renderDepth&&this.handler?.execute()}ngOnDestroy(){this.handler?.destroy(),this.handler=null}static#t=this.\u0275prov=$e({token:t,providedIn:"root",factory:()=>new t})}return t})();function _m(t){for(;t;){t[Pe]|=64;const n=lm(t);if(Qt(t)&&!n)return t;t=n}return null}const PT=new In("",{providedIn:"root",factory:()=>!1});let p0=null;function kT(t,n){return t[n]??BT()}function FT(t,n){const e=BT();e.producerNode?.length&&(t[n]=p0,e.lView=t,p0=$T())}const _W={...cy,consumerIsAlwaysLive:!0,consumerMarkedDirty:t=>{_m(t.lView)},lView:null};function $T(){return Object.create(_W)}function BT(){return p0??=$T(),p0}const ui={};function Fh(t){zT(kr(),qe(),nl()+t,!1)}function zT(t,n,e,r){if(!r)if(3==(3&n[Pe])){const s=t.preOrderCheckHooks;null!==s&&Ay(n,s,e)}else{const s=t.preOrderHooks;null!==s&&My(n,s,0,e)}xd(e)}function xn(t,n=xr.Default){const e=qe();return null===e?Wn(t,n):QS(wi(),e,Fn(t),n)}function m0(t,n,e,r,i,s,o,a,u,c,d){const p=n.blueprint.slice();return p[Te]=i,p[Pe]=140|r,(null!==c||t&&2048&t[Pe])&&(p[Pe]|=2048),Ht(p),p[fn]=p[bn]=t,p[mt]=e,p[ce]=o||t&&t[ce],p[ye]=a||t&&t[ye],p[Ft]=u||t&&t[Ft]||null,p[D]=s,p[ro]=function IU(){return bU++}(),p[fa]=d,p[jo]=c,p[Pn]=2==n.type?t[Pn]:p,p}function Lf(t,n,e,r,i){let s=t.data[n];if(null===s)s=function eE(t,n,e,r,i){const s=Po(),o=Oo(),u=t.data[n]=function DW(t,n,e,r,i,s){let o=n?n.injectorIndex:-1,a=0;return function fr(){return null!==qt.skipHydrationRootTNode}()&&(a|=128),{type:e,index:r,insertBeforeIndex:null,injectorIndex:o,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:i,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?s:s&&s.parent,e,n,r,i);return null===t.firstChild&&(t.firstChild=u),null!==s&&(o?null==s.child&&null!==u.parent&&(s.child=u):null===s.next&&(s.next=u,u.prev=s)),u}(t,n,e,r,i),function bV(){return qt.lFrame.inI18n}()&&(s.flags|=32);else if(64&s.type){s.type=e,s.value=r,s.attrs=i;const o=function zs(){const t=qt.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}();s.injectorIndex=null===o?-1:o.injectorIndex}return ms(s,!0),s}function xm(t,n,e,r){if(0===e)return-1;const i=n.length;for(let s=0;s<e;s++)n.push(r),t.blueprint.push(r),t.data.push(null);return i}function UT(t,n,e,r,i){const s=kT(n,cr),o=nl(),a=2&r;try{xd(-1),a&&n.length>Lr&&zT(t,n,Lr,!1),Yl(a?2:0,i);const c=a?s:null,d=Zp(c);try{null!==c&&(c.dirty=!1),e(r,i)}finally{Yp(c,d)}}finally{a&&null===n[cr]&&FT(n,cr),xd(o),Yl(a?3:1,i)}}function nE(t,n,e){if(C(n)){const r=gl(null);try{const s=n.directiveEnd;for(let o=n.directiveStart;o<s;o++){const a=t.data[o];a.contentQueries&&a.contentQueries(1,e[o],o)}}finally{gl(r)}}}function WT(t){const n=t.tView;return null===n||n.incompleteFirstPass?t.tView=sE(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts,t.id):n}function sE(t,n,e,r,i,s,o,a,u,c,d){const p=Lr+r,v=p+i,x=function EW(t,n){const e=[];for(let r=0;r<n;r++)e.push(r<t?null:ui);return e}(p,v),w="function"==typeof c?c():c;return x[xe]={type:t,blueprint:x,template:e,queries:null,viewQuery:a,declTNode:n,data:x.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:v,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof s?s():s,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:u,consts:w,incompleteFirstPass:!1,ssrId:d}}let GT=t=>null;function HT(t,n,e,r){for(let i in t)if(t.hasOwnProperty(i)){e=null===e?{}:e;const s=t[i];null===r?jT(e,n,i,s):r.hasOwnProperty(i)&&jT(e,n,r[i],s)}return e}function jT(t,n,e,r){t.hasOwnProperty(e)?t[e].push(n,r):t[e]=[n,r]}function KT(t,n,e,r,i,s){for(let c=0;c<r.length;c++)rx(Oy(e,n),t,r[c].type);!function BW(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}(e,t.data.length,r.length);for(let c=0;c<r.length;c++){const d=r[c];d.providersResolver&&d.providersResolver(d)}let o=!1,a=!1,u=xm(t,n,r.length,null);for(let c=0;c<r.length;c++){const d=r[c];e.mergedAttrs=Nu(e.mergedAttrs,d.hostAttrs),zW(t,e,n,u,d),$W(u,d,i),null!==d.contentQueries&&(e.flags|=4),(null!==d.hostBindings||null!==d.hostAttrs||0!==d.hostVars)&&(e.flags|=64);const p=d.type.prototype;!o&&(p.ngOnChanges||p.ngOnInit||p.ngDoCheck)&&((t.preOrderHooks??=[]).push(e.index),o=!0),!a&&(p.ngOnChanges||p.ngDoCheck)&&((t.preOrderCheckHooks??=[]).push(e.index),a=!0),u++}!function TW(t,n,e){const i=n.directiveEnd,s=t.data,o=n.attrs,a=[];let u=null,c=null;for(let d=n.directiveStart;d<i;d++){const p=s[d],v=e?e.get(p):null,w=v?v.outputs:null;u=HT(p.inputs,d,u,v?v.inputs:null),c=HT(p.outputs,d,c,w);const b=null===u||null===o||qs(n)?null:WW(u,d,o);a.push(b)}null!==u&&(u.hasOwnProperty("class")&&(n.flags|=8),u.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=u,n.outputs=c}(t,e,s)}function XT(t,n,e){const r=e.directiveStart,i=e.directiveEnd,s=e.index,o=function SV(){return qt.lFrame.currentDirectiveIndex}();try{xd(s);for(let a=r;a<i;a++){const u=t.data[a],c=n[a];K1(a),(null!==u.hostBindings||0!==u.hostVars||null!==u.hostAttrs)&&LW(u,c)}}finally{xd(-1),K1(o)}}function LW(t,n){null!==t.hostBindings&&t.hostBindings(1,n)}function aE(t,n,e){n.componentOffset=e,(t.components??=[]).push(n.index)}function $W(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;Dt(n)&&(e[""]=t)}}function zW(t,n,e,r,i){t.data[r]=i;const s=i.factory||(i.factory=ah(i.type)),o=new em(s,Dt(i),xn);t.blueprint[r]=o,e[r]=o,function PW(t,n,e,r,i){const s=i.hostBindings;if(s){let o=t.hostBindingOpCodes;null===o&&(o=t.hostBindingOpCodes=[]);const a=~n.index;(function OW(t){let n=t.length;for(;n>0;){const e=t[--n];if("number"==typeof e&&e<0)return e}return 0})(o)!=a&&o.push(a),o.push(e,r,s)}}(t,n,r,xm(t,e,i.hostVars,ui),i)}function UW(t,n,e,r,i,s){const o=s[n];if(null!==o)for(let a=0;a<o.length;)ZT(r,e,o[a++],o[a++],o[a++])}function ZT(t,n,e,r,i){const s=gl(null);try{const o=t.inputTransforms;null!==o&&o.hasOwnProperty(r)&&(i=o[r].call(n,i)),null!==t.setInput?t.setInput(n,i,e,r):n[r]=i}finally{gl(s)}}function WW(t,n,e){let r=null,i=0;for(;i<e.length;){const s=e[i];if(0!==s)if(5!==s){if("number"==typeof s)break;if(t.hasOwnProperty(s)){null===r&&(r=[]);const o=t[s];for(let a=0;a<o.length;a+=2)if(o[a]===n){r.push(s,o[a+1],e[i+1]);break}}i+=2}else i+=2;else i+=4}return r}function qT(t,n){const e=t.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r+1];if(-1!==s){const o=t.data[s];Z1(e[r]),o.contentQueries(2,n[s],s)}}}function g0(t,n){return t[Ve]?t[sn][f]=n:t[Ve]=n,t[sn]=n,n}function lE(t,n,e){Z1(0);const r=gl(null);try{n(t,e)}finally{gl(r)}}function QT(t){return t[j]||(t[j]=[])}function JT(t){return t.cleanup||(t.cleanup=[])}function eN(t,n){const e=t[Ft],r=e?e.get(hh,null):null;r&&r.handleError(n)}function cE(t,n,e,r,i){for(let s=0;s<e.length;){const o=e[s++],a=e[s++];ZT(t.data[o],n[o],r,a,i)}}function GW(t,n){const e=tl(n,t),r=e[xe];!function HW(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])}(r,e);const i=e[Te];null!==i&&null===e[fa]&&(e[fa]=Gx(i,e[Ft])),hE(r,e,e[mt])}function hE(t,n,e){Y1(n);try{const r=t.viewQuery;null!==r&&lE(1,r,e);const i=t.template;null!==i&&UT(t,n,i,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&qT(t,n),t.staticViewQueries&&lE(2,t.viewQuery,e);const s=t.components;null!==s&&function jW(t,n){for(let e=0;e<n.length;e++)GW(t,n[e])}(n,s)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[Pe]&=-5,q1()}}let nN=(()=>{class t{constructor(){this.all=new Set,this.queue=new Map}create(e,r,i){const s=typeof Zone>"u"?null:Zone.current,o=function k1(t,n,e){const r=Object.create(F1);e&&(r.consumerAllowSignalWrites=!0),r.fn=t,r.schedule=n;const i=o=>{r.cleanupFn=o};return r.ref={notify:()=>fy(r),run:()=>{if(r.dirty=!1,r.hasRun&&!py(r))return;r.hasRun=!0;const o=Zp(r);try{r.cleanupFn(),r.cleanupFn=Ey,r.fn(i)}finally{Yp(r,o)}},cleanup:()=>r.cleanupFn()},r.ref}(e,c=>{this.all.has(c)&&this.queue.set(c,s)},i);let a;this.all.add(o),o.notify();const u=()=>{o.cleanup(),a?.(),this.all.delete(o),this.queue.delete(o)};return a=r?.onDestroy(u),{destroy:u}}flush(){if(0!==this.queue.size)for(const[e,r]of this.queue)this.queue.delete(e),r?r.run(()=>e.run()):e.run()}get isQueueEmpty(){return 0===this.queue.size}static#t=this.\u0275prov=$e({token:t,providedIn:"root",factory:()=>new t})}return t})();function y0(t,n,e){let r=e?t.styles:null,i=e?t.classes:null,s=0;if(null!==n)for(let o=0;o<n.length;o++){const a=n[o];"number"==typeof a?s=a:1==s?i=La(i,a):2==s&&(r=La(r,a+": "+n[++o]+";"))}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=i:t.classesWithoutHost=i}function Em(t,n,e,r,i=!1){for(;null!==e;){const s=n[e.index];null!==s&&r.push(vo(s)),_(s)&&rN(s,r);const o=e.type;if(8&o)Em(t,n,e.child,r);else if(32&o){const a=mx(e,n);let u;for(;u=a();)r.push(u)}else if(16&o){const a=FD(n,e);if(Array.isArray(a))r.push(...a);else{const u=lm(n[Pn]);Em(u[xe],u,a,r,!0)}}e=i?e.projectionNext:e.next}return r}function rN(t,n){for(let e=l;e<t.length;e++){const r=t[e],i=r[xe].firstChild;null!==i&&Em(r[xe],r,i,n)}t[bs]!==t[Te]&&n.push(t[bs])}function v0(t,n,e,r=!0){const i=n[ce],s=i.rendererFactory,o=i.afterRenderEventManager;s.begin?.(),o?.begin();try{iN(t,n,t.template,e)}catch(u){throw r&&eN(n,u),u}finally{s.end?.(),i.effectManager?.flush(),o?.end()}}function iN(t,n,e,r){const i=n[Pe];if(256!=(256&i)){n[ce].effectManager?.flush(),Y1(n);try{Ht(n),function uh(t){return qt.lFrame.bindingIndex=t}(t.bindingStartIndex),null!==e&&UT(t,n,e,2,r);const o=3==(3&i);if(o){const c=t.preOrderCheckHooks;null!==c&&Ay(n,c,null)}else{const c=t.preOrderHooks;null!==c&&My(n,c,0,null),Q1(n,0)}if(function ZW(t){for(let n=ID(t);null!==n;n=SD(n)){if(!n[As])continue;const e=n[ra];for(let r=0;r<e.length;r++){Vt(e[r])}}}(n),sN(n,2),null!==t.contentQueries&&qT(t,n),o){const c=t.contentCheckHooks;null!==c&&Ay(n,c)}else{const c=t.contentHooks;null!==c&&My(n,c,1),Q1(n,1)}!function xW(t,n){const e=t.hostBindingOpCodes;if(null===e)return;const r=kT(n,ou);try{for(let i=0;i<e.length;i++){const s=e[i];if(s<0)xd(~s);else{const o=s,a=e[++i],u=e[++i];IV(a,o),r.dirty=!1;const c=Zp(r);try{u(2,n[o])}finally{Yp(r,c)}}}}finally{null===n[ou]&&FT(n,ou),xd(-1)}}(t,n);const a=t.components;null!==a&&aN(n,a,0);const u=t.viewQuery;if(null!==u&&lE(2,u,r),o){const c=t.viewCheckHooks;null!==c&&Ay(n,c)}else{const c=t.viewHooks;null!==c&&My(n,c,2),Q1(n,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),n[Pe]&=-73,$t(n)}finally{q1()}}}function sN(t,n){for(let e=ID(t);null!==e;e=SD(e))for(let r=l;r<e.length;r++)oN(e[r],n)}function YW(t,n,e){oN(tl(n,t),e)}function oN(t,n){if(!function H1(t){return 128==(128&t[Pe])}(t))return;const e=t[xe],r=t[Pe];if(80&r&&0===n||1024&r||2===n)iN(e,t,e.template,t[mt]);else if(t[E]>0){sN(t,1);const i=e.components;null!==i&&aN(t,i,1)}}function aN(t,n,e){for(let r=0;r<n.length;r++)YW(t,n[r],e)}class Cm{get rootNodes(){const n=this._lView,e=n[xe];return Em(e,n,e.firstChild,[])}constructor(n,e){this._lView=n,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[mt]}set context(n){this._lView[mt]=n}get destroyed(){return 256==(256&this._lView[Pe])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const n=this._lView[fn];if(_(n)){const e=n[8],r=e?e.indexOf(this):-1;r>-1&&(Zy(n,r),Fy(e,r))}this._attachedToViewContainer=!1}yx(this._lView[xe],this._lView)}onDestroy(n){!function Zt(t,n){if(256==(256&t[Pe]))throw new We(911,!1);null===t[na]&&(t[na]=[]),t[na].push(n)}(this._lView,n)}markForCheck(){_m(this._cdRefInjectingView||this._lView)}detach(){this._lView[Pe]&=-129}reattach(){this._lView[Pe]|=128}detectChanges(){v0(this._lView[xe],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new We(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function BU(t,n){hm(t,n,n[ye],2,null,null)}(this._lView[xe],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new We(902,!1);this._appRef=n}}class qW extends Cm{constructor(n){super(n),this._view=n}detectChanges(){const n=this._view;v0(n[xe],n,n[mt],!1)}checkNoChanges(){}get context(){return null}}class uN extends d0{constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){const e=Tr(n);return new wm(e,this.ngModule)}}function lN(t){const n=[];for(let e in t)t.hasOwnProperty(e)&&n.push({propName:t[e],templateName:e});return n}class JW{constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){r=la(r);const i=this.injector.get(n,Kx,r);return i!==Kx||e===Kx?i:this.parentInjector.get(n,e,r)}}class wm extends pT{get inputs(){const n=this.componentDef,e=n.inputTransforms,r=lN(n.inputs);if(null!==e)for(const i of r)e.hasOwnProperty(i.propName)&&(i.transform=e[i.propName]);return r}get outputs(){return lN(this.componentDef.outputs)}constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=function Ho(t){return t.map(Au).join(",")}(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!e}create(n,e,r,i){let s=(i=i||this.ngModule)instanceof Ql?i:i?.injector;s&&null!==this.componentDef.getStandaloneInjector&&(s=this.componentDef.getStandaloneInjector(s)||s);const o=s?new JW(n,s):n,a=o.get(gT,null);if(null===a)throw new We(407,!1);const p={rendererFactory:a,sanitizer:o.get(X4,null),effectManager:o.get(nN,null),afterRenderEventManager:o.get(tE,null)},v=a.createRenderer(null,this.componentDef),x=this.componentDef.selectors[0][0]||"div",w=r?function CW(t,n,e,r){const s=r.get(PT,!1)||e===Ea.ShadowDom,o=t.selectRootElement(n,s);return function wW(t){GT(t)}(o),o}(v,r,this.componentDef.encapsulation,o):Xy(v,x,function QW(t){const n=t.toLowerCase();return"svg"===n?"svg":"math"===n?"math":null}(x)),N=this.componentDef.signals?4608:this.componentDef.onPush?576:528;let S=null;null!==w&&(S=Gx(w,o,!0));const U=sE(0,null,null,1,0,null,null,null,null,null,null),J=m0(null,U,null,N,null,null,p,v,o,null,S);let ht,Tt;Y1(J);try{const Pt=this.componentDef;let zt,Ot=null;Pt.findHostDirectiveDefs?(zt=[],Ot=new Map,Pt.findHostDirectiveDefs(Pt,zt,Ot),zt.push(Pt)):zt=[Pt];const le=function eG(t,n){const e=t[xe],r=Lr;return t[r]=n,Lf(e,r,2,"#host",null)}(J,w),ge=function nG(t,n,e,r,i,s,o){const a=i[xe];!function rG(t,n,e,r){for(const i of t)n.mergedAttrs=Nu(n.mergedAttrs,i.hostAttrs);null!==n.mergedAttrs&&(y0(n,n.mergedAttrs,!0),null!==e&&VD(r,e,n))}(r,t,n,o);let u=null;null!==n&&(u=Gx(n,i[Ft]));const c=s.rendererFactory.createRenderer(n,e);let d=16;e.signals?d=4096:e.onPush&&(d=64);const p=m0(i,WT(e),null,d,i[t.index],t,s,c,null,null,u);return a.firstCreatePass&&aE(a,t,r.length-1),g0(i,p),i[t.index]=p}(le,w,Pt,zt,J,p,v);Tt=Dy(U,Lr),w&&function sG(t,n,e,r){if(r)Bs(t,e,["ng-version",Z4.full]);else{const{attrs:i,classes:s}=function ds(t){const n=[],e=[];let r=1,i=2;for(;r<t.length;){let s=t[r];if("string"==typeof s)2===i?""!==s&&n.push(s,t[++r]):8===i&&e.push(s);else{if(!Fa(i))break;i=s}r++}return{attrs:n,classes:e}}(n.selectors[0]);i&&Bs(t,e,i),s&&s.length>0&&zD(t,e,s.join(" "))}}(v,Pt,w,r),void 0!==e&&function oG(t,n,e){const r=t.projection=[];for(let i=0;i<n.length;i++){const s=e[i];r.push(null!=s?Array.from(s):null)}}(Tt,this.ngContentSelectors,e),ht=function iG(t,n,e,r,i,s){const o=wi(),a=i[xe],u=$u(o,i);KT(a,i,o,e,null,r);for(let d=0;d<e.length;d++)zu(Ed(i,a,o.directiveStart+d,o),i);XT(a,i,o),u&&zu(u,i);const c=Ed(i,a,o.directiveStart+o.componentOffset,o);if(t[mt]=i[mt]=c,null!==s)for(const d of s)d(c,n);return nE(a,o,t),c}(ge,Pt,zt,Ot,J,[aG]),hE(U,J,null)}finally{q1()}return new tG(this.componentType,ht,Pf(Tt,J),J,Tt)}}class tG extends U4{constructor(n,e,r,i,s){super(),this.location=r,this._rootLView=i,this._tNode=s,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new qW(i),this.componentType=n}setInput(n,e){const r=this._tNode.inputs;let i;if(null!==r&&(i=r[n])){if(this.previousInputValues??=new Map,this.previousInputValues.has(n)&&Object.is(this.previousInputValues.get(n),e))return;const s=this._rootLView;cE(s[xe],s,i,n,e),this.previousInputValues.set(n,e),_m(tl(this._tNode.index,s))}}get injector(){return new rl(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}}function aG(){const t=wi();Ny(qe()[xe],t)}function so(t){let n=function cN(t){return Object.getPrototypeOf(t.prototype).constructor}(t.type),e=!0;const r=[t];for(;n;){let i;if(Dt(t))i=n.\u0275cmp||n.\u0275dir;else{if(n.\u0275cmp)throw new We(903,!1);i=n.\u0275dir}if(i){if(e){r.push(i);const o=t;o.inputs=_0(t.inputs),o.inputTransforms=_0(t.inputTransforms),o.declaredInputs=_0(t.declaredInputs),o.outputs=_0(t.outputs);const a=i.hostBindings;a&&hG(t,a);const u=i.viewQuery,c=i.contentQueries;if(u&&lG(t,u),c&&cG(t,c),Cs(t.inputs,i.inputs),Cs(t.declaredInputs,i.declaredInputs),Cs(t.outputs,i.outputs),null!==i.inputTransforms&&(null===o.inputTransforms&&(o.inputTransforms={}),Cs(o.inputTransforms,i.inputTransforms)),Dt(i)&&i.data.animation){const d=t.data;d.animation=(d.animation||[]).concat(i.data.animation)}}const s=i.features;if(s)for(let o=0;o<s.length;o++){const a=s[o];a&&a.ngInherit&&a(t),a===so&&(e=!1)}}n=Object.getPrototypeOf(n)}!function uG(t){let n=0,e=null;for(let r=t.length-1;r>=0;r--){const i=t[r];i.hostVars=n+=i.hostVars,i.hostAttrs=Nu(i.hostAttrs,e=Nu(e,i.hostAttrs))}}(r)}function _0(t){return t===mi?{}:t===yi?[]:t}function lG(t,n){const e=t.viewQuery;t.viewQuery=e?(r,i)=>{n(r,i),e(r,i)}:n}function cG(t,n){const e=t.contentQueries;t.contentQueries=e?(r,i,s)=>{n(r,i,s),e(r,i,s)}:n}function hG(t,n){const e=t.hostBindings;t.hostBindings=e?(r,i)=>{n(r,i),e(r,i)}:n}function Vu(t,n,e){return!Object.is(t[n],e)&&(t[n]=e,!0)}function Hf(t,n,e){const r=qe();return Vu(r,Nl(),n)&&function Ol(t,n,e,r,i,s,o,a){const u=$u(n,e);let d,c=n.inputs;!a&&null!=c&&(d=c[r])?(cE(t,e,d,r,i),F(n)&&function AW(t,n){const e=tl(n,t);16&e[Pe]||(e[Pe]|=64)}(e,n.index)):3&n.type&&(r=function NW(t){return"class"===t?"className":"for"===t?"htmlFor":"formaction"===t?"formAction":"innerHtml"===t?"innerHTML":"readonly"===t?"readOnly":"tabindex"===t?"tabIndex":t}(r),i=null!=o?o(i,n.value||"",r):i,s.setProperty(u,r,i))}(kr(),function pa(){const t=qt.lFrame;return Dy(t.tView,t.selectedIndex)}(),r,t,n,r[ye],e,!1),Hf}function vE(t,n,e,r,i){const o=i?"class":"style";cE(t,e,n.inputs[o],o,r)}function Xa(t,n,e,r){const i=qe(),s=kr(),o=Lr+t,a=i[ye],u=s.firstCreatePass?function UG(t,n,e,r,i,s){const o=n.consts,u=Lf(n,t,2,r,kc(o,i));return function oE(t,n,e,r){if(rr()){const i=null===r?null:{"":-1},s=function kW(t,n){const e=t.directiveRegistry;let r=null,i=null;if(e)for(let s=0;s<e.length;s++){const o=e[s];if(So(n,o.selectors,!1))if(r||(r=[]),Dt(o))if(null!==o.findHostDirectiveDefs){const a=[];i=i||new Map,o.findHostDirectiveDefs(o,a,i),r.unshift(...a,o),aE(t,n,a.length)}else r.unshift(o),aE(t,n,0);else i=i||new Map,o.findHostDirectiveDefs?.(o,r,i),r.push(o)}return null===r?null:[r,i]}(t,e);let o,a;null===s?o=a=null:[o,a]=s,null!==o&&KT(t,n,e,o,i,a),i&&function FW(t,n,e){if(n){const r=t.localNames=[];for(let i=0;i<n.length;i+=2){const s=e[n[i+1]];if(null==s)throw new We(-301,!1);r.push(n[i],s)}}}(e,r,i)}e.mergedAttrs=Nu(e.mergedAttrs,e.attrs)}(n,e,u,kc(o,s)),null!==u.attrs&&y0(u,u.attrs,!1),null!==u.mergedAttrs&&y0(u,u.mergedAttrs,!0),null!==n.queries&&n.queries.elementStart(n,u),u}(o,s,i,n,e,r):s.data[o],c=NN(s,i,u,a,n,t);i[o]=c;const d=rt(u);return ms(u,!0),VD(a,c,u),32!=(32&u.flags)&&Ty()&&qy(s,i,c,u),0===function He(){return qt.lFrame.elementDepthCount}()&&zu(c,i),function ln(){qt.lFrame.elementDepthCount++}(),d&&(function rE(t,n,e){rr()&&(function RW(t,n,e,r){const i=e.directiveStart,s=e.directiveEnd;F(e)&&function VW(t,n,e){const r=$u(n,t),i=WT(e);let o=16;e.signals?o=4096:e.onPush&&(o=64);const a=g0(t,m0(t,i,null,o,r,n,null,t[ce].rendererFactory.createRenderer(r,e),null,null,null));t[n.index]=a}(n,e,t.data[i+e.componentOffset]),t.firstCreatePass||Oy(e,n),zu(r,n);const o=e.initialInputs;for(let a=i;a<s;a++){const u=t.data[a],c=Ed(n,t,a,e);zu(c,n),null!==o&&UW(0,a-i,c,u,0,o),Dt(u)&&(tl(e.index,n)[mt]=Ed(n,t,a,e))}}(t,n,e,$u(e,n)),64==(64&e.flags)&&XT(t,n,e))}(s,i,u),nE(s,u,i)),null!==r&&function iE(t,n,e=$u){const r=n.localNames;if(null!==r){let i=n.index+1;for(let s=0;s<r.length;s+=2){const o=r[s+1],a=-1===o?e(n,t):t[o];t[i++]=a}}}(i,u),Xa}function Za(){let t=wi();Oo()?function Bu(){qt.lFrame.isParent=!1}():(t=t.parent,ms(t,!1));const n=t;(function vi(t){return qt.skipHydrationRootTNode===t})(n)&&function au(){qt.skipHydrationRootTNode=null}(),function hn(){qt.lFrame.elementDepthCount--}();const e=kr();return e.firstCreatePass&&(Ny(e,t),C(t)&&e.queries.elementEnd(t)),null!=n.classesWithoutHost&&function FV(t){return 0!=(8&t.flags)}(n)&&vE(e,n,qe(),n.classesWithoutHost,!0),null!=n.stylesWithoutHost&&function $V(t){return 0!=(16&t.flags)}(n)&&vE(e,n,qe(),n.stylesWithoutHost,!1),Za}function _u(t,n,e,r){return Xa(t,n,e,r),Za(),_u}let NN=(t,n,e,r,i,s)=>(Rh(!0),Xy(r,i,function WS(){return qt.lFrame.currentNamespace}()));function Tm(t){return!!t&&"function"==typeof t.then}function PN(t){return!!t&&"function"==typeof t.subscribe}function xu(t,n,e,r){const i=qe(),s=kr(),o=wi();return function RN(t,n,e,r,i,s,o){const a=rt(r),c=t.firstCreatePass&&JT(t),d=n[mt],p=QT(n);let v=!0;if(3&r.type||o){const b=$u(r,n),T=o?o(b):b,N=p.length,S=o?J=>o(vo(J[r.index])):r.index;let U=null;if(!o&&a&&(U=function ZG(t,n,e,r){const i=t.cleanup;if(null!=i)for(let s=0;s<i.length-1;s+=2){const o=i[s];if(o===e&&i[s+1]===r){const a=n[j],u=i[s+2];return a.length>u?a[u]:null}"string"==typeof o&&(s+=2)}return null}(t,n,i,r.index)),null!==U)(U.__ngLastListenerFn__||U).__ngNextListenerFn__=s,U.__ngLastListenerFn__=s,v=!1;else{s=kN(r,n,d,s,!1);const J=e.listen(T,i,s);p.push(s,J),c&&c.push(i,S,N,N+1)}}else s=kN(r,n,d,s,!1);const x=r.outputs;let w;if(v&&null!==x&&(w=x[i])){const b=w.length;if(b)for(let T=0;T<b;T+=2){const ht=n[w[T]][w[T+1]].subscribe(s),Tt=p.length;p.push(s,ht),c&&c.push(i,r.index,Tt,-(Tt+1))}}}(s,i,i[ye],o,t,n,r),xu}function LN(t,n,e,r){try{return Yl(6,n,e),!1!==e(r)}catch(i){return eN(t,i),!1}finally{Yl(7,n,e)}}function kN(t,n,e,r,i){return function s(o){if(o===Function)return r;_m(t.componentOffset>-1?tl(t.index,n):n);let u=LN(n,e,r,o),c=s.__ngNextListenerFn__;for(;c;)u=LN(n,e,c,o)&&u,c=c.__ngNextListenerFn__;return i&&!1===u&&o.preventDefault(),u}}function I0(t,n){return t<<17|n<<2}function $h(t){return t>>17&32767}function CE(t){return 2|t}function Id(t){return(131068&t)>>2}function wE(t,n){return-131069&t|n<<2}function bE(t){return 1|t}function jN(t,n,e,r,i){const s=t[e+1],o=null===n;let a=r?$h(s):Id(s),u=!1;for(;0!==a&&(!1===u||o);){const d=t[a+1];s5(t[a],n)&&(u=!0,t[a+1]=r?bE(d):CE(d)),a=r?$h(d):Id(d)}u&&(t[e+1]=r?CE(s):bE(s))}function s5(t,n){return null===t||null==n||(Array.isArray(t)?t[1]:t)===n||!(!Array.isArray(t)||"string"!=typeof n)&&xf(t,n)>=0}function S0(t,n){return function gc(t,n,e,r){const i=qe(),s=kr(),o=function mc(t){const n=qt.lFrame,e=n.bindingIndex;return n.bindingIndex=n.bindingIndex+t,e}(2);s.firstUpdatePass&&function eA(t,n,e,r){const i=t.data;if(null===i[e+1]){const s=i[nl()],o=function tA(t,n){return n>=t.expandoStartIndex}(t,e);(function sA(t,n){return 0!=(t.flags&(n?8:16))})(s,r)&&null===n&&!o&&(n=!1),n=function p5(t,n,e,r){const i=function X1(t){const n=qt.lFrame.currentDirectiveIndex;return-1===n?null:t[n]}(t);let s=r?n.residualClasses:n.residualStyles;if(null===i)0===(r?n.classBindings:n.styleBindings)&&(e=Nm(e=IE(null,t,n,e,r),n.attrs,r),s=null);else{const o=n.directiveStylingLast;if(-1===o||t[o]!==i)if(e=IE(i,t,n,e,r),null===s){let u=function m5(t,n,e){const r=e?n.classBindings:n.styleBindings;if(0!==Id(r))return t[$h(r)]}(t,n,r);void 0!==u&&Array.isArray(u)&&(u=IE(null,t,n,u[1],r),u=Nm(u,n.attrs,r),function g5(t,n,e,r){t[$h(e?n.classBindings:n.styleBindings)]=r}(t,n,r,u))}else s=function y5(t,n,e){let r;const i=n.directiveEnd;for(let s=1+n.directiveStylingLast;s<i;s++)r=Nm(r,t[s].hostAttrs,e);return Nm(r,n.attrs,e)}(t,n,r)}return void 0!==s&&(r?n.residualClasses=s:n.residualStyles=s),e}(i,s,n,r),function r5(t,n,e,r,i,s){let o=s?n.classBindings:n.styleBindings,a=$h(o),u=Id(o);t[r]=e;let d,c=!1;if(Array.isArray(e)?(d=e[1],(null===d||xf(e,d)>0)&&(c=!0)):d=e,i)if(0!==u){const v=$h(t[a+1]);t[r+1]=I0(v,a),0!==v&&(t[v+1]=wE(t[v+1],r)),t[a+1]=function e5(t,n){return 131071&t|n<<17}(t[a+1],r)}else t[r+1]=I0(a,0),0!==a&&(t[a+1]=wE(t[a+1],r)),a=r;else t[r+1]=I0(u,0),0===a?a=r:t[u+1]=wE(t[u+1],r),u=r;c&&(t[r+1]=CE(t[r+1])),jN(t,d,r,!0),jN(t,d,r,!1),function i5(t,n,e,r,i){const s=i?t.residualClasses:t.residualStyles;null!=s&&"string"==typeof n&&xf(s,n)>=0&&(e[r+1]=bE(e[r+1]))}(n,d,t,r,s),o=I0(a,u),s?n.classBindings=o:n.styleBindings=o}(i,s,n,e,o,r)}}(s,t,o,r),n!==ui&&Vu(i,o,n)&&function rA(t,n,e,r,i,s,o,a){if(!(3&n.type))return;const u=t.data,c=u[a+1],d=function n5(t){return 1==(1&t)}(c)?iA(u,n,e,i,Id(c),o):void 0;D0(d)||(D0(s)||function t5(t){return 2==(2&t)}(c)&&(s=iA(u,null,e,i,a,o)),function ZU(t,n,e,r,i){if(n)i?t.addClass(e,r):t.removeClass(e,r);else{let s=-1===r.indexOf("-")?void 0:Lh.DashCase;null==i?t.removeStyle(e,r,s):("string"==typeof i&&i.endsWith("!important")&&(i=i.slice(0,-10),s|=Lh.Important),t.setStyle(e,r,i,s))}}(r,o,df(nl(),e),i,s))}(s,s.data[nl()],i,i[ye],t,i[o+1]=function E5(t,n){return null==t||""===t||("string"==typeof n?t+=n:"object"==typeof t&&(t=Yi(function kh(t){return t instanceof HD?t.changingThisBreaksApplicationSecurity:t}(t)))),t}(n,e),r,o)}(t,n,null,!0),S0}function IE(t,n,e,r,i){let s=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(s=n[a],r=Nm(r,s.hostAttrs,i),s!==t);)a++;return null!==t&&(e.directiveStylingLast=a),r}function Nm(t,n,e){const r=e?1:2;let i=-1;if(null!==n)for(let s=0;s<n.length;s++){const o=n[s];"number"==typeof o?i=o:i===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),Al(t,o,!!e||n[++s]))}return void 0===t?null:t}function iA(t,n,e,r,i,s){const o=null===n;let a;for(;i>0;){const u=t[i],c=Array.isArray(u),d=c?u[1]:u,p=null===d;let v=e[i+1];v===ui&&(v=p?yi:void 0);let x=p?ox(v,r):d===r?v:void 0;if(c&&!D0(x)&&(x=ox(u,r)),D0(x)&&(a=x,o))return a;const w=t[i+1];i=o?$h(w):Id(w)}if(null!==n){let u=s?n.residualClasses:n.residualStyles;null!=u&&(a=ox(u,r))}return a}function D0(t){return void 0!==t}function tc(t,n=""){const e=qe(),r=kr(),i=t+Lr,s=r.firstCreatePass?Lf(r,i,1,n,null):r.data[i],o=oA(r,e,s,n,t);e[i]=o,Ty()&&qy(r,e,o,s),ms(s,!1)}let oA=(t,n,e,r,i)=>(Rh(!0),function Ky(t,n){return t.createText(n)}(n[ye],r));function SE(t){return Am("",t,""),SE}function Am(t,n,e){const r=qe(),i=function Ff(t,n,e,r){return Vu(t,Nl(),e)?n+mr(e)+r:ui}(r,t,n,e);return i!==ui&&function fh(t,n,e){const r=df(n,t);!function TD(t,n,e){t.setValue(n,e)}(t[ye],r,e)}(r,nl(),i),Am}const Sd=void 0;var W5=["en",[["a","p"],["AM","PM"],Sd],[["AM","PM"],Sd,Sd],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Sd,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Sd,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Sd,"{1} 'at' {0}",Sd],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function U5(t){const e=Math.floor(Math.abs(t)),r=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===r?1:5}];let Kf={};function il(t){const n=function G5(t){return t.toLowerCase().replace(/_/g,"-")}(t);let e=DA(n);if(e)return e;const r=n.split("-")[0];if(e=DA(r),e)return e;if("en"===r)return W5;throw new We(701,!1)}function DA(t){return t in Kf||(Kf[t]=us.ng&&us.ng.common&&us.ng.common.locales&&us.ng.common.locales[t]),Kf[t]}var Lo=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}(Lo||{});const Xf="en-US";let TA=Xf;function NE(t,n,e,r,i){if(t=Fn(t),Array.isArray(t))for(let s=0;s<t.length;s++)NE(t[s],n,e,r,i);else{const s=kr(),o=qe(),a=wi();let u=wd(t)?t:Fn(t.provide);const c=uT(t),d=1048575&a.providerIndexes,p=a.directiveStart,v=a.providerIndexes>>20;if(wd(t)||!t.multi){const x=new em(c,i,xn),w=ME(u,n,i?d:d+v,p);-1===w?(rx(Oy(a,o),s,u),AE(s,t,n.length),n.push(u),a.directiveStart++,a.directiveEnd++,i&&(a.providerIndexes+=1048576),e.push(x),o.push(x)):(e[w]=x,o[w]=x)}else{const x=ME(u,n,d+v,p),w=ME(u,n,d,d+v),T=w>=0&&e[w];if(i&&!T||!i&&!(x>=0&&e[x])){rx(Oy(a,o),s,u);const N=function U6(t,n,e,r,i){const s=new em(t,e,xn);return s.multi=[],s.index=n,s.componentProviders=0,JA(s,i,r&&!e),s}(i?V6:z6,e.length,i,r,c);!i&&T&&(e[w].providerFactory=N),AE(s,t,n.length,0),n.push(u),a.directiveStart++,a.directiveEnd++,i&&(a.providerIndexes+=1048576),e.push(N),o.push(N)}else AE(s,t,x>-1?x:w,JA(e[i?w:x],c,!i&&r));!i&&r&&T&&e[w].componentProviders++}}}function AE(t,n,e,r){const i=wd(n),s=function I4(t){return!!t.useClass}(n);if(i||s){const u=(s?Fn(n.useClass):n).prototype.ngOnDestroy;if(u){const c=t.destroyHooks||(t.destroyHooks=[]);if(!i&&n.multi){const d=c.indexOf(e);-1===d?c.push(e,[r,u]):c[d+1].push(r,u)}else c.push(e,u)}}}function JA(t,n,e){return e&&t.componentProviders++,t.multi.push(n)-1}function ME(t,n,e,r){for(let i=e;i<r;i++)if(n[i]===t)return i;return-1}function z6(t,n,e,r){return PE(this.multi,[])}function V6(t,n,e,r){const i=this.multi;let s;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=Ed(e,e[xe],this.providerFactory.index,r);s=a.slice(0,o),PE(i,s);for(let u=o;u<a.length;u++)s.push(a[u])}else s=[],PE(i,s);return s}function PE(t,n){for(let e=0;e<t.length;e++)n.push((0,t[e])());return n}function ia(t,n=[]){return e=>{e.providersResolver=(r,i)=>function B6(t,n,e){const r=kr();if(r.firstCreatePass){const i=Dt(t);NE(e,r.data,r.blueprint,i,!0),NE(n,r.data,r.blueprint,i,!1)}}(r,i?i(t):t,n)}}class Dd{}class tM{}class OE extends Dd{constructor(n,e,r){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new uN(this);const i=ct(n);this._bootstrapComponents=dh(i.bootstrap),this._r3Injector=ET(n,e,[{provide:Dd,useValue:this},{provide:d0,useValue:this.componentFactoryResolver},...r],Yi(n),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(n)}get injector(){return this._r3Injector}destroy(){const n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}}class RE extends tM{constructor(n){super(),this.moduleType=n}create(n){return new OE(this.moduleType,n,[])}}class eM extends Dd{constructor(n){super(),this.componentFactoryResolver=new uN(this),this.instance=null;const e=new Df([...n.providers,{provide:Dd,useValue:this},{provide:d0,useValue:this.componentFactoryResolver}],n.parent||s0(),n.debugName,new Set(["environment"]));this.injector=e,n.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}}function LE(t,n,e=null){return new eM({providers:t,parent:n,debugName:e,runEnvironmentInitializers:!0}).injector}let H6=(()=>{class t{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e)){const r=iT(0,e.type),i=r.length>0?LE([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e,i)}return this.cachedInjectors.get(e)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}static#t=this.\u0275prov=$e({token:t,providedIn:"environment",factory:()=>new t(Wn(Ql))})}return t})();function nM(t){t.getStandaloneInjector=n=>n.get(H6).getOrCreateStandaloneInjector(t)}function cM(t,n,e,r,i,s,o){const a=n+e;return function bd(t,n,e,r){const i=Vu(t,n,e);return Vu(t,n+1,r)||i}(t,a,i,s)?function Bc(t,n,e){return t[n]=e}(t,a+2,o?r.call(o,i,s):r(i,s)):function km(t,n){const e=t[n];return e===ui?void 0:e}(t,a+2)}function mM(t,n,e,r){const i=t+Lr,s=qe(),o=function Oh(t,n){return t[n]}(s,i);return function Fm(t,n){return t[xe].data[n].pure}(s,i)?cM(s,function Ia(){const t=qt.lFrame;let n=t.bindingRootIndex;return-1===n&&(n=t.bindingRootIndex=t.tView.bindingStartIndex),n}(),n,o.transform,e,r,o):o.transform(e,r)}function mH(){return this._results[Symbol.iterator]()}class FE{static#t=Symbol.iterator;get changes(){return this._changes||(this._changes=new Sa)}constructor(n=!1){this._emitDistinctChangesOnly=n,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=FE.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=mH)}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){const r=this;r.dirty=!1;const i=function ql(t){return t.flat(Number.POSITIVE_INFINITY)}(n);(this._changesDetected=!function QV(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let i=t[r],s=n[r];if(e&&(i=e(i),s=e(s)),s!==i)return!1}return!0}(r._results,i,e))&&(r._results=i,r.length=i.length,r.last=i[this.length-1],r.first=i[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}function yH(t,n,e,r=!0){const i=n[xe];if(function VU(t,n,e,r){const i=l+r,s=e.length;r>0&&(e[i-1][f]=n),r<s-l?(n[f]=e[i],iD(e,l+r,n)):(e.push(n),n[f]=null),n[fn]=e;const o=n[Nr];null!==o&&e!==o&&function UU(t,n){const e=t[ra];n[Pn]!==n[fn][fn][Pn]&&(t[As]=!0),null===e?t[ra]=[n]:e.push(n)}(o,n);const a=n[Qi];null!==a&&a.insertView(t),n[Pe]|=128}(i,n,t,e),r){const s=Ex(e,t),o=n[ye],a=Yy(o,t[bs]);null!==a&&function $U(t,n,e,r,i,s){r[Te]=i,r[D]=n,hm(t,r,e,1,i,s)}(i,t[D],o,n,a,s)}}let ph=(()=>{class t{static#t=this.__NG_ELEMENT_ID__=xH}return t})();const vH=ph,_H=class extends vH{constructor(n,e,r){super(),this._declarationLView=n,this._declarationTContainer=e,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(n,e){return this.createEmbeddedViewImpl(n,e)}createEmbeddedViewImpl(n,e,r){const i=function gH(t,n,e,r){const i=n.tView,a=m0(t,i,e,4096&t[Pe]?4096:16,null,n,null,null,null,r?.injector??null,r?.hydrationInfo??null);a[Nr]=t[n.index];const c=t[Qi];return null!==c&&(a[Qi]=c.createEmbeddedView(i)),hE(i,a,e),a}(this._declarationLView,this._declarationTContainer,n,{injector:e,hydrationInfo:r});return new Cm(i)}};function xH(){return P0(wi(),qe())}function P0(t,n){return 4&t.type?new _H(n,t,Pf(t,n)):null}let vc=(()=>{class t{static#t=this.__NG_ELEMENT_ID__=SH}return t})();function SH(){return CM(wi(),qe())}const DH=vc,xM=class extends DH{constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return Pf(this._hostTNode,this._hostLView)}get injector(){return new rl(this._hostTNode,this._hostLView)}get parentInjector(){const n=Ry(this._hostTNode,this._hostLView);if(tx(n)){const e=rm(n,this._hostLView),r=nm(n);return new rl(e[xe].data[r+8],e)}return new rl(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){const e=EM(this._lContainer);return null!==e&&e[n]||null}get length(){return this._lContainer.length-l}createEmbeddedView(n,e,r){let i,s;"number"==typeof r?i=r:null!=r&&(i=r.index,s=r.injector);const a=n.createEmbeddedViewImpl(e||{},s,null);return this.insertImpl(a,i,false),a}createComponent(n,e,r,i,s){const o=n&&!sm(n);let a;if(o)a=e;else{const b=e||{};a=b.index,r=b.injector,i=b.projectableNodes,s=b.environmentInjector||b.ngModuleRef}const u=o?n:new wm(Tr(n)),c=r||this.parentInjector;if(!s&&null==u.ngModule){const T=(o?c:this.parentInjector).get(Ql,null);T&&(s=T)}Tr(u.componentType??{});const x=u.create(c,i,null,s);return this.insertImpl(x.hostView,a,false),x}insert(n,e){return this.insertImpl(n,e,!1)}insertImpl(n,e,r){const i=n._lView;if(function j1(t){return _(t[fn])}(i)){const u=this.indexOf(n);if(-1!==u)this.detach(u);else{const c=i[fn],d=new xM(c,c[D],c[fn]);d.detach(d.indexOf(n))}}const o=this._adjustIndex(e),a=this._lContainer;return yH(a,i,o,!r),n.attachToViewContainerRef(),iD($E(a),o,n),n}move(n,e){return this.insert(n,e)}indexOf(n){const e=EM(this._lContainer);return null!==e?e.indexOf(n):-1}remove(n){const e=this._adjustIndex(n,-1),r=Zy(this._lContainer,e);r&&(Fy($E(this._lContainer),e),yx(r[xe],r))}detach(n){const e=this._adjustIndex(n,-1),r=Zy(this._lContainer,e);return r&&null!=Fy($E(this._lContainer),e)?new Cm(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function EM(t){return t[8]}function $E(t){return t[8]||(t[8]=[])}function CM(t,n){let e;const r=n[t.index];return _(r)?e=r:(e=function YT(t,n,e,r){return[t,!0,!1,n,null,0,r,e,null,null,null]}(r,n,null,t),n[t.index]=e,g0(n,e)),wM(e,n,t,r),new xM(e,t,n)}let wM=function bM(t,n,e,r){if(t[bs])return;let i;i=8&e.type?vo(r):function TH(t,n){const e=t[ye],r=e.createComment(""),i=$u(n,t);return Cd(e,Yy(e,i),r,function jU(t,n){return t.nextSibling(n)}(e,i),!1),r}(n,e),t[bs]=i};class BE{constructor(n){this.queryList=n,this.matches=null}clone(){return new BE(this.queryList)}setDirty(){this.queryList.setDirty()}}class zE{constructor(n=[]){this.queries=n}createEmbeddedView(n){const e=n.queries;if(null!==e){const r=null!==n.contentQueries?n.contentQueries[0]:e.length,i=[];for(let s=0;s<r;s++){const o=e.getByIndex(s);i.push(this.queries[o.indexInDeclarationView].clone())}return new zE(i)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)null!==AM(n,e).matches&&this.queries[e].setDirty()}}class IM{constructor(n,e,r=null){this.predicate=n,this.flags=e,this.read=r}}class VE{constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){const i=null!==e?e.length:0,s=this.getByIndex(r).embeddedTView(n,i);s&&(s.indexInDeclarationView=r,null!==e?e.push(s):e=[s])}return null!==e?new VE(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}}class UE{constructor(n,e=-1){this.metadata=n,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new UE(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=n.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let i=0;i<r.length;i++){const s=r[i];this.matchTNodeWithReadOption(n,e,MH(e,s)),this.matchTNodeWithReadOption(n,e,Ly(e,n,s,!1,!1))}else r===ph?4&e.type&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,Ly(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(null!==r){const i=this.metadata.read;if(null!==i)if(i===Ml||i===vc||i===ph&&4&e.type)this.addMatch(e.index,-2);else{const s=Ly(e,n,i,!1,!1);null!==s&&this.addMatch(e.index,s)}else this.addMatch(e.index,r)}}addMatch(n,e){null===this.matches?this.matches=[n,e]:this.matches.push(n,e)}}function MH(t,n){const e=t.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1];return null}function OH(t,n,e,r){return-1===e?function PH(t,n){return 11&t.type?Pf(t,n):4&t.type?P0(t,n):null}(n,t):-2===e?function RH(t,n,e){return e===Ml?Pf(n,t):e===ph?P0(n,t):e===vc?CM(n,t):void 0}(t,n,r):Ed(t,t[xe],e,n)}function SM(t,n,e,r){const i=n[Qi].queries[r];if(null===i.matches){const s=t.data,o=e.matches,a=[];for(let u=0;u<o.length;u+=2){const c=o[u];a.push(c<0?null:OH(n,s[c],o[u+1],e.metadata.read))}i.matches=a}return i.matches}function WE(t,n,e,r){const i=t.queries.getByIndex(e),s=i.matches;if(null!==s){const o=SM(t,n,i,e);for(let a=0;a<s.length;a+=2){const u=s[a];if(u>0)r.push(o[a/2]);else{const c=s[a+1],d=n[-u];for(let p=l;p<d.length;p++){const v=d[p];v[Nr]===v[fn]&&WE(v[xe],v,c,r)}if(null!==d[ra]){const p=d[ra];for(let v=0;v<p.length;v++){const x=p[v];WE(x[xe],x,c,r)}}}}}return r}function R0(t){const n=qe(),e=kr(),r=FS();Z1(r+1);const i=AM(e,r);if(t.dirty&&function G1(t){return 4==(4&t[Pe])}(n)===(2==(2&i.metadata.flags))){if(null===i.matches)t.reset([]);else{const s=i.crossesNgTemplate?WE(e,n,r,[]):SM(e,n,i,r);t.reset(s,j4),t.notifyOnChanges()}return!0}return!1}function GE(t,n,e){const r=kr();r.firstCreatePass&&(function NM(t,n,e){null===t.queries&&(t.queries=new VE),t.queries.track(new UE(n,e))}(r,new IM(t,n,e),-1),2==(2&n)&&(r.staticViewQueries=!0)),function TM(t,n,e){const r=new FE(4==(4&e));(function SW(t,n,e,r){const i=QT(n);i.push(e),t.firstCreatePass&&JT(t).push(r,i.length-1)})(t,n,r,r.destroy),null===n[Qi]&&(n[Qi]=new zE),n[Qi].queries.push(new BE(r))}(r,qe(),n)}function L0(){return function LH(t,n){return t[Qi].queries[n].queryList}(qe(),FS())}function AM(t,n){return t.queries.getByIndex(n)}const YE=new In("Application Initializer");let qE=(()=>{class t{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,r)=>{this.resolve=e,this.reject=r}),this.appInits=Mn(YE,{optional:!0})??[]}runInitializers(){if(this.initialized)return;const e=[];for(const i of this.appInits){const s=i();if(Tm(s))e.push(s);else if(PN(s)){const o=new Promise((a,u)=>{s.subscribe({complete:a,error:u})});e.push(o)}}const r=()=>{this.done=!0,this.resolve()};Promise.all(e).then(()=>{r()}).catch(i=>{this.reject(i)}),0===e.length&&r(),this.initialized=!0}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),KM=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"platform"})}return t})();const mh=new In("LocaleId",{providedIn:"root",factory:()=>Mn(mh,xr.Optional|xr.SkipSelf)||function i8(){return typeof $localize<"u"&&$localize.locale||Xf}()});let XM=(()=>{class t{constructor(){this.taskId=0,this.pendingTasks=new Set,this.hasPendingTasks=new jr(!1)}add(){this.hasPendingTasks.next(!0);const e=this.taskId++;return this.pendingTasks.add(e),e}remove(e){this.pendingTasks.delete(e),0===this.pendingTasks.size&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks.next(!1)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();class a8{constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}}let ZM=(()=>{class t{compileModuleSync(e){return new RE(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),s=dh(ct(e).declarations).reduce((o,a)=>{const u=Tr(a);return u&&o.push(new wm(u)),o},[]);return new a8(r,s)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();const JM=new In(""),$0=new In("");let nC,tC=(()=>{class t{constructor(e,r,i){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,nC||(function N8(t){nC=t}(i),i.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Ro.assertNotInAngularZone(),queueMicrotask(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())queueMicrotask(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,i){let s=-1;r&&r>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==s),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:s,updateCb:i})}whenStable(e,r,i){if(i&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,i),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,i){return[]}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(Ro),Wn(eC),Wn($0))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})(),eC=(()=>{class t{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return nC?.findTestabilityInTree(this,e,r)??null}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"platform"})}return t})(),Bh=null;const tP=new In("AllowMultipleToken"),rC=new In("PlatformDestroyListeners"),iC=new In("appBootstrapListener");class nP{constructor(n,e){this.name=n,this.token=e}}function iP(t,n,e=[]){const r=`Platform: ${n}`,i=new In(r);return(s=[])=>{let o=sC();if(!o||o.injector.get(tP,!1)){const a=[...e,...s,{provide:i,useValue:!0}];t?t(a):function P8(t){if(Bh&&!Bh.get(tP,!1))throw new We(400,!1);(function eP(){!function M1(t){Zl=t}(()=>{throw new We(600,!1)})})(),Bh=t;const n=t.get(oP);(function rP(t){t.get(lT,null)?.forEach(e=>e())})(t)}(function sP(t=[],n){return Pl.create({name:n,providers:[{provide:Ox,useValue:"platform"},{provide:rC,useValue:new Set([()=>Bh=null])},...t]})}(a,r))}return function R8(t){const n=sC();if(!n)throw new We(401,!1);return n}()}}function sC(){return Bh?.get(oP)??null}let oP=(()=>{class t{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const i=function L8(t="zone.js",n){return"noop"===t?new uW:"zone.js"===t?new Ro(n):t}(r?.ngZone,function aP(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:t?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:t?.runCoalescing??!1}}({eventCoalescing:r?.ngZoneEventCoalescing,runCoalescing:r?.ngZoneRunCoalescing}));return i.run(()=>{const s=function G6(t,n,e){return new OE(t,n,e)}(e.moduleType,this.injector,function dP(t){return[{provide:Ro,useFactory:t},{provide:mm,multi:!0,useFactory:()=>{const n=Mn(F8,{optional:!0});return()=>n.initialize()}},{provide:hP,useFactory:k8},{provide:ST,useFactory:DT}]}(()=>i)),o=s.injector.get(hh,null);return i.runOutsideAngular(()=>{const a=i.onError.subscribe({next:u=>{o.handleError(u)}});s.onDestroy(()=>{B0(this._modules,s),a.unsubscribe()})}),function uP(t,n,e){try{const r=e();return Tm(r)?r.catch(i=>{throw n.runOutsideAngular(()=>t.handleError(i)),i}):r}catch(r){throw n.runOutsideAngular(()=>t.handleError(r)),r}}(o,i,()=>{const a=s.injector.get(qE);return a.runInitializers(),a.donePromise.then(()=>(function NA(t){Yt(t,"Expected localeId to be defined"),"string"==typeof t&&(TA=t.toLowerCase().replace(/_/g,"-"))}(s.injector.get(mh,Xf)||Xf),this._moduleDoBootstrap(s),s))})})}bootstrapModule(e,r=[]){const i=lP({},r);return function A8(t,n,e){const r=new RE(e);return Promise.resolve(r)}(0,0,e).then(s=>this.bootstrapModuleFactory(s,i))}_moduleDoBootstrap(e){const r=e.injector.get(qf);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(i=>r.bootstrap(i));else{if(!e.instance.ngDoBootstrap)throw new We(-403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new We(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(rC,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(Pl))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"platform"})}return t})();function lP(t,n){return Array.isArray(n)?n.reduce(lP,t):{...t,...n}}let qf=(()=>{class t{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=Mn(hP),this.zoneIsStable=Mn(ST),this.componentTypes=[],this.components=[],this.isStable=Mn(XM).hasPendingTasks.pipe(bo(e=>e?qn(!1):this.zoneIsStable),function Yu(t,n=Ct){return t=t??ya,be((e,r)=>{let i,s=!0;e.subscribe(Me(r,o=>{const a=n(o);(s||!t(i,a))&&(s=!1,i=a,r.next(o))}))})}(),ga()),this._injector=Mn(Ql)}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const i=e instanceof pT;if(!this._injector.get(qE).done)throw!i&&function gt(t){const n=Tr(t)||ri(t)||fs(t);return null!==n&&n.standalone}(e),new We(405,!1);let o;o=i?e:this._injector.get(d0).resolveComponentFactory(e),this.componentTypes.push(o.componentType);const a=function M8(t){return t.isBoundToModule}(o)?void 0:this._injector.get(Dd),c=o.create(Pl.NULL,[],r||o.selector,a),d=c.location.nativeElement,p=c.injector.get(JM,null);return p?.registerApplication(d),c.onDestroy(()=>{this.detachView(c.hostView),B0(this.components,c),p?.unregisterApplication(d)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new We(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this.internalErrorHandler(e)}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;B0(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const r=this._injector.get(iC,[]);r.push(...this._bootstrapListeners),r.forEach(i=>i(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>B0(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new We(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function B0(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}const hP=new In("",{providedIn:"root",factory:()=>Mn(hh).handleError.bind(void 0)});function k8(){const t=Mn(Ro),n=Mn(hh);return e=>t.runOutsideAngular(()=>n.handleError(e))}let F8=(()=>{class t{constructor(){this.zone=Mn(Ro),this.applicationRef=Mn(qf)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();let z0=(()=>{class t{static#t=this.__NG_ELEMENT_ID__=B8}return t})();function B8(t){return function z8(t,n,e){if(F(t)&&!e){const r=tl(t.index,n);return new Cm(r,r)}return 47&t.type?new Cm(n[Pn],n):null}(wi(),qe(),16==(16&t))}const J8=iP(null,"core",[]);let tj=(()=>{class t{constructor(e){}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(qf))};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({})}return t})();let hC=null;function zh(){return hC}class pj{}const ec=new In("DocumentToken");let dC=(()=>{class t{historyGo(e){throw new Error("Not implemented")}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(gj)},providedIn:"platform"})}return t})();const mj=new In("Location Initialized");let gj=(()=>{class t extends dC{constructor(){super(),this._doc=Mn(ec),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return zh().getBaseHref(this._doc)}onPopState(e){const r=zh().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=zh().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,i){this._history.pushState(e,r,i)}replaceState(e,r,i){this._history.replaceState(e,r,i)}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return new t},providedIn:"platform"})}return t})();function fC(t,n){if(0==t.length)return n;if(0==n.length)return t;let e=0;return t.endsWith("/")&&e++,n.startsWith("/")&&e++,2==e?t+n.substring(1):1==e?t+n:t+"/"+n}function AP(t){const n=t.match(/#|\?|$/),e=n&&n.index||t.length;return t.slice(0,e-("/"===t[e-1]?1:0))+t.slice(e)}function gh(t){return t&&"?"!==t[0]?"?"+t:t}let Nd=(()=>{class t{historyGo(e){throw new Error("Not implemented")}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(PP)},providedIn:"root"})}return t})();const MP=new In("appBaseHref");let PP=(()=>{class t extends Nd{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Mn(ec).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return fC(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+gh(this._platformLocation.search),i=this._platformLocation.hash;return i&&e?`${r}${i}`:r}pushState(e,r,i,s){const o=this.prepareExternalUrl(i+gh(s));this._platformLocation.pushState(e,r,o)}replaceState(e,r,i,s){const o=this.prepareExternalUrl(i+gh(s));this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(dC),Wn(MP,8))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),yj=(()=>{class t extends Nd{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=fC(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,i,s){let o=this.prepareExternalUrl(i+gh(s));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,r,o)}replaceState(e,r,i,s){let o=this.prepareExternalUrl(i+gh(s));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(dC),Wn(MP,8))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})(),pC=(()=>{class t{constructor(e){this._subject=new Sa,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._basePath=function xj(t){if(new RegExp("^(https?:)?//").test(t)){const[,e]=t.split(/\/\/[^\/]+/);return e}return t}(AP(OP(r))),this._locationStrategy.onPopState(i=>{this._subject.emit({url:this.path(!0),pop:!0,state:i.state,type:i.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+gh(r))}normalize(e){return t.stripTrailingSlash(function _j(t,n){if(!t||!n.startsWith(t))return n;const e=n.substring(t.length);return""===e||["/",";","?","#"].includes(e[0])?e:n}(this._basePath,OP(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",i=null){this._locationStrategy.pushState(i,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+gh(r)),i)}replaceState(e,r="",i=null){this._locationStrategy.replaceState(i,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+gh(r)),i)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(i=>i(e,r))}subscribe(e,r,i){return this._subject.subscribe({next:e,error:r,complete:i})}static#t=this.normalizeQueryParams=gh;static#e=this.joinWithSlash=fC;static#n=this.stripTrailingSlash=AP;static#r=this.\u0275fac=function(r){return new(r||t)(Wn(Nd))};static#i=this.\u0275prov=$e({token:t,factory:function(){return function vj(){return new pC(Wn(Nd))}()},providedIn:"root"})}return t})();function OP(t){return t.replace(/\/index.html$/,"")}var H0=function(t){return t[t.Decimal=0]="Decimal",t[t.Percent=1]="Percent",t[t.Currency=2]="Currency",t[t.Scientific=3]="Scientific",t}(H0||{}),za=function(t){return t[t.Decimal=0]="Decimal",t[t.Group=1]="Group",t[t.List=2]="List",t[t.PercentSign=3]="PercentSign",t[t.PlusSign=4]="PlusSign",t[t.MinusSign=5]="MinusSign",t[t.Exponential=6]="Exponential",t[t.SuperscriptingExponent=7]="SuperscriptingExponent",t[t.PerMille=8]="PerMille",t[t.Infinity=9]="Infinity",t[t.NaN=10]="NaN",t[t.TimeSeparator=11]="TimeSeparator",t[t.CurrencyDecimal=12]="CurrencyDecimal",t[t.CurrencyGroup=13]="CurrencyGroup",t}(za||{});function nc(t,n){const e=il(t),r=e[Lo.NumberSymbols][n];if(typeof r>"u"){if(n===za.CurrencyDecimal)return e[Lo.NumberSymbols][za.Decimal];if(n===za.CurrencyGroup)return e[Lo.NumberSymbols][za.Group]}return r}const Kj=/^(\d+)?\.((\d+)(-(\d+))?)?$/;function CC(t){const n=parseInt(t);if(isNaN(n))throw new Error("Invalid integer literal when parsing "+t);return n}let XP=(()=>{class t{constructor(e){this._locale=e}transform(e,r,i){if(!function DC(t){return!(null==t||""===t||t!=t)}(e))return null;i=i||this._locale;try{return function Jj(t,n,e){return function xC(t,n,e,r,i,s,o=!1){let a="",u=!1;if(isFinite(t)){let c=function eK(t){let r,i,s,o,a,n=Math.abs(t)+"",e=0;for((i=n.indexOf("."))>-1&&(n=n.replace(".","")),(s=n.search(/e/i))>0?(i<0&&(i=s),i+=+n.slice(s+1),n=n.substring(0,s)):i<0&&(i=n.length),s=0;"0"===n.charAt(s);s++);if(s===(a=n.length))r=[0],i=1;else{for(a--;"0"===n.charAt(a);)a--;for(i-=s,r=[],o=0;s<=a;s++,o++)r[o]=Number(n.charAt(s))}return i>22&&(r=r.splice(0,21),e=i-1,i=1),{digits:r,exponent:e,integerLen:i}}(t);o&&(c=function tK(t){if(0===t.digits[0])return t;const n=t.digits.length-t.integerLen;return t.exponent?t.exponent+=2:(0===n?t.digits.push(0,0):1===n&&t.digits.push(0),t.integerLen+=2),t}(c));let d=n.minInt,p=n.minFrac,v=n.maxFrac;if(s){const S=s.match(Kj);if(null===S)throw new Error(`${s} is not a valid digit info`);const U=S[1],J=S[3],ht=S[5];null!=U&&(d=CC(U)),null!=J&&(p=CC(J)),null!=ht?v=CC(ht):null!=J&&p>v&&(v=p)}!function nK(t,n,e){if(n>e)throw new Error(`The minimum number of digits after fraction (${n}) is higher than the maximum (${e}).`);let r=t.digits,i=r.length-t.integerLen;const s=Math.min(Math.max(n,i),e);let o=s+t.integerLen,a=r[o];if(o>0){r.splice(Math.max(t.integerLen,o));for(let p=o;p<r.length;p++)r[p]=0}else{i=Math.max(0,i),t.integerLen=1,r.length=Math.max(1,o=s+1),r[0]=0;for(let p=1;p<o;p++)r[p]=0}if(a>=5)if(o-1<0){for(let p=0;p>o;p--)r.unshift(0),t.integerLen++;r.unshift(1),t.integerLen++}else r[o-1]++;for(;i<Math.max(0,s);i++)r.push(0);let u=0!==s;const c=n+t.integerLen,d=r.reduceRight(function(p,v,x,w){return w[x]=(v+=p)<10?v:v-10,u&&(0===w[x]&&x>=c?w.pop():u=!1),v>=10?1:0},0);d&&(r.unshift(d),t.integerLen++)}(c,p,v);let x=c.digits,w=c.integerLen;const b=c.exponent;let T=[];for(u=x.every(S=>!S);w<d;w++)x.unshift(0);for(;w<0;w++)x.unshift(0);w>0?T=x.splice(w,x.length):(T=x,x=[0]);const N=[];for(x.length>=n.lgSize&&N.unshift(x.splice(-n.lgSize,x.length).join(""));x.length>n.gSize;)N.unshift(x.splice(-n.gSize,x.length).join(""));x.length&&N.unshift(x.join("")),a=N.join(nc(e,r)),T.length&&(a+=nc(e,i)+T.join("")),b&&(a+=nc(e,za.Exponential)+"+"+b)}else a=nc(e,za.Infinity);return a=t<0&&!u?n.negPre+a+n.negSuf:n.posPre+a+n.posSuf,a}(t,function EC(t,n="-"){const e={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},r=t.split(";"),i=r[0],s=r[1],o=-1!==i.indexOf(".")?i.split("."):[i.substring(0,i.lastIndexOf("0")+1),i.substring(i.lastIndexOf("0")+1)],a=o[0],u=o[1]||"";e.posPre=a.substring(0,a.indexOf("#"));for(let d=0;d<u.length;d++){const p=u.charAt(d);"0"===p?e.minFrac=e.maxFrac=d+1:"#"===p?e.maxFrac=d+1:e.posSuf+=p}const c=a.split(",");if(e.gSize=c[1]?c[1].length:0,e.lgSize=c[2]||c[1]?(c[2]||c[1]).length:0,s){const d=i.length-e.posPre.length-e.posSuf.length,p=s.indexOf("#");e.negPre=s.substring(0,p).replace(/'/g,""),e.negSuf=s.slice(p+d).replace(/'/g,"")}else e.negPre=n+e.posPre,e.negSuf=e.posSuf;return e}(function mC(t,n){return il(t)[Lo.NumberFormats][n]}(n,H0.Decimal),nc(n,za.MinusSign)),n,za.Group,za.Decimal,e)}(function TC(t){if("string"==typeof t&&!isNaN(Number(t)-parseFloat(t)))return Number(t);if("number"!=typeof t)throw new Error(`${t} is not a number`);return t}(e),i,r)}catch(s){throw function xc(t,n){return new We(2100,!1)}()}}static#t=this.\u0275fac=function(r){return new(r||t)(xn(mh,16))};static#e=this.\u0275pipe=ws({name:"number",type:t,pure:!0,standalone:!0})}return t})();let RK=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({})}return t})();function YP(t){return"server"===t}let $K=(()=>{class t{static#t=this.\u0275prov=$e({token:t,providedIn:"root",factory:()=>new BK(Wn(ec),window)})}return t})();class BK{constructor(n,e){this.document=n,this.window=e,this.offset=()=>[0,0]}setOffset(n){this.offset=Array.isArray(n)?()=>n:n}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(n){this.supportsScrolling()&&this.window.scrollTo(n[0],n[1])}scrollToAnchor(n){if(!this.supportsScrolling())return;const e=function zK(t,n){const e=t.getElementById(n)||t.getElementsByName(n)[0];if(e)return e;if("function"==typeof t.createTreeWalker&&t.body&&"function"==typeof t.body.attachShadow){const r=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let i=r.currentNode;for(;i;){const s=i.shadowRoot;if(s){const o=s.getElementById(n)||s.querySelector(`[name="${n}"]`);if(o)return o}i=r.nextNode()}}return null}(this.document,n);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(n){this.supportsScrolling()&&(this.window.history.scrollRestoration=n)}scrollToElement(n){const e=n.getBoundingClientRect(),r=e.left+this.window.pageXOffset,i=e.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(r-s[0],i-s[1])}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}class c9 extends pj{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class MC extends c9{static makeCurrent(){!function fj(t){hC||(hC=t)}(new MC)}onAndCancel(n,e,r){return n.addEventListener(e,r),()=>{n.removeEventListener(e,r)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.parentNode&&n.parentNode.removeChild(n)}createElement(n,e){return(e=e||this.getDefaultDocument()).createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return"window"===e?window:"document"===e?n:"body"===e?n.body:null}getBaseHref(n){const e=function h9(){return Gm=Gm||document.querySelector("base"),Gm?Gm.getAttribute("href"):null}();return null==e?null:function d9(t){rv=rv||document.createElement("a"),rv.setAttribute("href",t);const n=rv.pathname;return"/"===n.charAt(0)?n:`/${n}`}(e)}resetBaseElement(){Gm=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return function iK(t,n){n=encodeURIComponent(n);for(const e of t.split(";")){const r=e.indexOf("="),[i,s]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(i.trim()===n)return decodeURIComponent(s)}return null}(document.cookie,n)}}let rv,Gm=null,p9=(()=>{class t{build(){return new XMLHttpRequest}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();const PC=new In("EventManagerPlugins");let eO=(()=>{class t{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(i=>{i.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,i){return this._findPluginFor(r).addEventListener(e,r,i)}getZone(){return this._zone}_findPluginFor(e){let r=this._eventNameToPlugin.get(e);if(r)return r;if(r=this._plugins.find(s=>s.supports(e)),!r)throw new We(5101,!1);return this._eventNameToPlugin.set(e,r),r}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(PC),Wn(Ro))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();class nO{constructor(n){this._doc=n}}const OC="ng-app-id";let rO=(()=>{class t{constructor(e,r,i,s={}){this.doc=e,this.appId=r,this.nonce=i,this.platformId=s,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=YP(s),this.resetHostNodes()}addStyles(e){for(const r of e)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(e){for(const r of e)this.changeUsageCount(r,-1)<=0&&this.onStyleRemoved(r)}ngOnDestroy(){const e=this.styleNodesInDOM;e&&(e.forEach(r=>r.remove()),e.clear());for(const r of this.getAllStyles())this.onStyleRemoved(r);this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(e){for(const r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){const r=this.styleRef;r.get(e)?.elements?.forEach(i=>i.remove()),r.delete(e)}collectServerRenderedStyles(){const e=this.doc.head?.querySelectorAll(`style[${OC}="${this.appId}"]`);if(e?.length){const r=new Map;return e.forEach(i=>{null!=i.textContent&&r.set(i.textContent,i)}),r}return null}changeUsageCount(e,r){const i=this.styleRef;if(i.has(e)){const s=i.get(e);return s.usage+=r,s.usage}return i.set(e,{usage:r,elements:[]}),r}getStyleElement(e,r){const i=this.styleNodesInDOM,s=i?.get(r);if(s?.parentNode===e)return i.delete(r),s.removeAttribute(OC),s;{const o=this.doc.createElement("style");return this.nonce&&o.setAttribute("nonce",this.nonce),o.textContent=r,this.platformIsServer&&o.setAttribute(OC,this.appId),o}}addStyleToHost(e,r){const i=this.getStyleElement(e,r);e.appendChild(i);const s=this.styleRef,o=s.get(r)?.elements;o?o.push(i):s.set(r,{elements:[i],usage:1})}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(ec),Wn(o0),Wn(cT,8),Wn(Nf))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();const RC={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},LC=/%COMP%/g,v9=new In("RemoveStylesOnCompDestroy",{providedIn:"root",factory:()=>!1});function sO(t,n){return n.map(e=>e.replace(LC,t))}let oO=(()=>{class t{constructor(e,r,i,s,o,a,u,c=null){this.eventManager=e,this.sharedStylesHost=r,this.appId=i,this.removeStylesOnCompDestroy=s,this.doc=o,this.platformId=a,this.ngZone=u,this.nonce=c,this.rendererByCompId=new Map,this.platformIsServer=YP(a),this.defaultRenderer=new kC(e,o,u,this.platformIsServer)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===Ea.ShadowDom&&(r={...r,encapsulation:Ea.Emulated});const i=this.getOrCreateRenderer(e,r);return i instanceof uO?i.applyToHost(e):i instanceof FC&&i.applyStyles(),i}getOrCreateRenderer(e,r){const i=this.rendererByCompId;let s=i.get(r.id);if(!s){const o=this.doc,a=this.ngZone,u=this.eventManager,c=this.sharedStylesHost,d=this.removeStylesOnCompDestroy,p=this.platformIsServer;switch(r.encapsulation){case Ea.Emulated:s=new uO(u,c,r,this.appId,d,o,a,p);break;case Ea.ShadowDom:return new C9(u,c,e,r,o,a,this.nonce,p);default:s=new FC(u,c,r,d,o,a,p)}i.set(r.id,s)}return s}ngOnDestroy(){this.rendererByCompId.clear()}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(eO),Wn(rO),Wn(o0),Wn(v9),Wn(ec),Wn(Nf),Wn(Ro),Wn(cT))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();class kC{constructor(n,e,r,i){this.eventManager=n,this.doc=e,this.ngZone=r,this.platformIsServer=i,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(n,e){return e?this.doc.createElementNS(RC[e]||e,n):this.doc.createElement(n)}createComment(n){return this.doc.createComment(n)}createText(n){return this.doc.createTextNode(n)}appendChild(n,e){(aO(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(aO(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){n&&n.removeChild(e)}selectRootElement(n,e){let r="string"==typeof n?this.doc.querySelector(n):n;if(!r)throw new We(-5104,!1);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,i){if(i){e=i+":"+e;const s=RC[i];s?n.setAttributeNS(s,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){const i=RC[r];i?n.removeAttributeNS(i,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,i){i&(Lh.DashCase|Lh.Important)?n.style.setProperty(e,r,i&Lh.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&Lh.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n[e]=r}setValue(n,e){n.nodeValue=e}listen(n,e,r){if("string"==typeof n&&!(n=zh().getGlobalEventTarget(this.doc,n)))throw new Error(`Unsupported event target ${n} for event ${e}`);return this.eventManager.addEventListener(n,e,this.decoratePreventDefault(r))}decoratePreventDefault(n){return e=>{if("__ngUnwrap__"===e)return n;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>n(e)):n(e))&&e.preventDefault()}}}function aO(t){return"TEMPLATE"===t.tagName&&void 0!==t.content}class C9 extends kC{constructor(n,e,r,i,s,o,a,u){super(n,s,o,u),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const c=sO(i.id,i.styles);for(const d of c){const p=document.createElement("style");a&&p.setAttribute("nonce",a),p.textContent=d,this.shadowRoot.appendChild(p)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(this.nodeOrShadowRoot(n),e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class FC extends kC{constructor(n,e,r,i,s,o,a,u){super(n,s,o,a),this.sharedStylesHost=e,this.removeStylesOnCompDestroy=i,this.styles=u?sO(u,r.styles):r.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles)}destroy(){this.removeStylesOnCompDestroy&&this.sharedStylesHost.removeStyles(this.styles)}}class uO extends FC{constructor(n,e,r,i,s,o,a,u){const c=i+"-"+r.id;super(n,e,r,s,o,a,u,c),this.contentAttr=function _9(t){return"_ngcontent-%COMP%".replace(LC,t)}(c),this.hostAttr=function x9(t){return"_nghost-%COMP%".replace(LC,t)}(c)}applyToHost(n){this.applyStyles(),this.setAttribute(n,this.hostAttr,"")}createElement(n,e){const r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}}let w9=(()=>{class t extends nO{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,i){return e.addEventListener(r,i,!1),()=>this.removeEventListener(e,r,i)}removeEventListener(e,r,i){return e.removeEventListener(r,i)}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(ec))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();const lO=["alt","control","meta","shift"],b9={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},I9={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let S9=(()=>{class t extends nO{constructor(e){super(e)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,r,i){const s=t.parseEventName(r),o=t.eventCallback(s.fullKey,i,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>zh().onAndCancel(e,s.domEventName,o))}static parseEventName(e){const r=e.toLowerCase().split("."),i=r.shift();if(0===r.length||"keydown"!==i&&"keyup"!==i)return null;const s=t._normalizeKey(r.pop());let o="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),o="code."),lO.forEach(c=>{const d=r.indexOf(c);d>-1&&(r.splice(d,1),o+=c+".")}),o+=s,0!=r.length||0===s.length)return null;const u={};return u.domEventName=i,u.fullKey=o,u}static matchEventFullKeyCode(e,r){let i=b9[e.key]||e.key,s="";return r.indexOf("code.")>-1&&(i=e.code,s="code."),!(null==i||!i)&&(i=i.toLowerCase()," "===i?i="space":"."===i&&(i="dot"),lO.forEach(o=>{o!==i&&(0,I9[o])(e)&&(s+=o+".")}),s+=i,s===r)}static eventCallback(e,r,i){return s=>{t.matchEventFullKeyCode(s,e)&&i.runGuarded(()=>r(s))}}static _normalizeKey(e){return"esc"===e?"escape":e}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(ec))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();const A9=iP(J8,"browser",[{provide:Nf,useValue:"browser"},{provide:lT,useValue:function D9(){MC.makeCurrent()},multi:!0},{provide:ec,useFactory:function N9(){return function t4(t){bx=t}(document),document},deps:[]}]),M9=new In(""),dO=[{provide:$0,useClass:class f9{addToWindow(n){us.getAngularTestability=(r,i=!0)=>{const s=n.findTestabilityInTree(r,i);if(null==s)throw new We(5103,!1);return s},us.getAllAngularTestabilities=()=>n.getAllTestabilities(),us.getAllAngularRootElements=()=>n.getAllRootElements(),us.frameworkStabilizers||(us.frameworkStabilizers=[]),us.frameworkStabilizers.push(r=>{const i=us.getAllAngularTestabilities();let s=i.length,o=!1;const a=function(u){o=o||u,s--,0==s&&r(o)};i.forEach(u=>{u.whenStable(a)})})}findTestabilityInTree(n,e,r){return null==e?null:n.getTestability(e)??(r?zh().isShadowRoot(e)?this.findTestabilityInTree(n,e.host,!0):this.findTestabilityInTree(n,e.parentElement,!0):null)}},deps:[]},{provide:JM,useClass:tC,deps:[Ro,eC,$0]},{provide:tC,useClass:tC,deps:[Ro,eC,$0]}],fO=[{provide:Ox,useValue:"root"},{provide:hh,useFactory:function T9(){return new hh},deps:[]},{provide:PC,useClass:w9,multi:!0,deps:[ec,Ro,Nf]},{provide:PC,useClass:S9,multi:!0,deps:[ec]},oO,rO,eO,{provide:gT,useExisting:oO},{provide:class VK{},useClass:p9,deps:[]},[]];let P9=(()=>{class t{constructor(e){}static withServerTransition(e){return{ngModule:t,providers:[{provide:o0,useValue:e.appId}]}}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(M9,12))};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({providers:[...fO,...dO],imports:[RK,tj]})}return t})(),pO=(()=>{class t{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(ec))};static#e=this.\u0275prov=$e({token:t,factory:function(r){let i=null;return i=r?new r:function R9(){return new pO(Wn(ec))}(),i},providedIn:"root"})}return t})();typeof window<"u"&&window;const{isArray:z9}=Array,{getPrototypeOf:V9,prototype:U9,keys:W9}=Object;function vO(t){if(1===t.length){const n=t[0];if(z9(n))return{args:n,keys:null};if(function G9(t){return t&&"object"==typeof t&&V9(t)===U9}(n)){const e=W9(n);return{args:e.map(r=>n[r]),keys:e}}}return{args:t,keys:null}}const{isArray:H9}=Array;function BC(t){return Ue(n=>function j9(t,n){return H9(n)?t(...n):t(n)}(t,n))}function _O(t,n){return t.reduce((e,r,i)=>(e[r]=n[i],e),{})}function zC(...t){const n=eo(t),e=Oa(t),{args:r,keys:i}=vO(t);if(0===r.length)return ss([],n);const s=new xt(function K9(t,n,e=Ct){return r=>{xO(n,()=>{const{length:i}=t,s=new Array(i);let o=i,a=i;for(let u=0;u<i;u++)xO(n,()=>{const c=ss(t[u],n);let d=!1;c.subscribe(Me(r,p=>{s[u]=p,d||(d=!0,a--),a||r.next(e(s.slice()))},()=>{--o||r.complete()}))},r)},r)}}(r,n,i?o=>_O(i,o):Ct));return e?s.pipe(BC(e)):s}function xO(t,n,e){t?Es(e,t,n):n()}const iv=H(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"});function VC(...t){return function X9(){return ti(1)}()(ss(t,eo(t)))}function EO(t){return new xt(n=>{Rr(t()).subscribe(n)})}function Hm(t,n){const e=V(t)?t:()=>t,r=i=>i.error(e());return new xt(n?i=>n.schedule(r,0,i):r)}function UC(){return be((t,n)=>{let e=null;t._refCount++;const r=Me(n,void 0,void 0,void 0,()=>{if(!t||t._refCount<=0||0<--t._refCount)return void(e=null);const i=t._connection,s=e;e=null,i&&(!s||i===s)&&i.unsubscribe(),n.unsubscribe()});t.subscribe(r),r.closed||(e=t.connect())})}class CO extends xt{constructor(n,e){super(),this.source=n,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,se(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){const n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new R;const e=this.getSubject();n.add(this.source.subscribe(Me(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=R.EMPTY)}return n}refCount(){return UC()(this)}}function tp(t){return t<=0?()=>Vr:be((n,e)=>{let r=0;n.subscribe(Me(e,i=>{++r<=t&&(e.next(i),t<=r&&e.complete())}))})}function Uh(t,n){return be((e,r)=>{let i=0;e.subscribe(Me(r,s=>t.call(n,s,i++)&&r.next(s)))})}function sv(t){return be((n,e)=>{let r=!1;n.subscribe(Me(e,i=>{r=!0,e.next(i)},()=>{r||e.next(t),e.complete()}))})}function wO(t=Y9){return be((n,e)=>{let r=!1;n.subscribe(Me(e,i=>{r=!0,e.next(i)},()=>r?e.complete():e.error(t())))})}function Y9(){return new iv}function Ad(t,n){const e=arguments.length>=2;return r=>r.pipe(t?Uh((i,s)=>t(i,s,r)):Ct,tp(1),e?sv(n):wO(()=>new iv))}function jm(t,n){return V(n)?Ss(t,n,1):Ss(t,1)}function Uu(t,n,e){const r=V(t)||n||e?{next:t,error:n,complete:e}:t;return r?be((i,s)=>{var o;null===(o=r.subscribe)||void 0===o||o.call(r);let a=!0;i.subscribe(Me(s,u=>{var c;null===(c=r.next)||void 0===c||c.call(r,u),s.next(u)},()=>{var u;a=!1,null===(u=r.complete)||void 0===u||u.call(r),s.complete()},u=>{var c;a=!1,null===(c=r.error)||void 0===c||c.call(r,u),s.error(u)},()=>{var u,c;a&&(null===(u=r.unsubscribe)||void 0===u||u.call(r)),null===(c=r.finalize)||void 0===c||c.call(r)}))}):Ct}function Md(t){return be((n,e)=>{let s,r=null,i=!1;r=n.subscribe(Me(e,void 0,void 0,o=>{s=Rr(t(o,Md(t)(n))),r?(r.unsubscribe(),r=null,s.subscribe(e)):i=!0})),i&&(r.unsubscribe(),r=null,s.subscribe(e))})}function WC(t){return t<=0?()=>Vr:be((n,e)=>{let r=[];n.subscribe(Me(e,i=>{r.push(i),t<r.length&&r.shift()},()=>{for(const i of r)e.next(i);e.complete()},void 0,()=>{r=null}))})}function GC(t){return be((n,e)=>{try{n.subscribe(e)}finally{e.add(t)}})}const gi="primary",Km=Symbol("RouteTitle");class n7{constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function ep(t){return new n7(t)}function r7(t,n,e){const r=e.path.split("/");if(r.length>t.length||"full"===e.pathMatch&&(n.hasChildren()||r.length<t.length))return null;const i={};for(let s=0;s<r.length;s++){const o=r[s],a=t[s];if(o.startsWith(":"))i[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:t.slice(0,r.length),posParams:i}}function Wc(t,n){const e=t?Object.keys(t):void 0,r=n?Object.keys(n):void 0;if(!e||!r||e.length!=r.length)return!1;let i;for(let s=0;s<e.length;s++)if(i=e[s],!bO(t[i],n[i]))return!1;return!0}function bO(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;const e=[...t].sort(),r=[...n].sort();return e.every((i,s)=>r[s]===i)}return t===n}function IO(t){return t.length>0?t[t.length-1]:null}function Wh(t){return function B9(t){return!!t&&(t instanceof xt||V(t.lift)&&V(t.subscribe))}(t)?t:Tm(t)?ss(Promise.resolve(t)):qn(t)}const s7={exact:function TO(t,n,e){if(!Pd(t.segments,n.segments)||!ov(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children)if(!t.children[r]||!TO(t.children[r],n.children[r],e))return!1;return!0},subset:NO},SO={exact:function o7(t,n){return Wc(t,n)},subset:function a7(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>bO(t[e],n[e]))},ignored:()=>!0};function DO(t,n,e){return s7[e.paths](t.root,n.root,e.matrixParams)&&SO[e.queryParams](t.queryParams,n.queryParams)&&!("exact"===e.fragment&&t.fragment!==n.fragment)}function NO(t,n,e){return AO(t,n,n.segments,e)}function AO(t,n,e,r){if(t.segments.length>e.length){const i=t.segments.slice(0,e.length);return!(!Pd(i,e)||n.hasChildren()||!ov(i,e,r))}if(t.segments.length===e.length){if(!Pd(t.segments,e)||!ov(t.segments,e,r))return!1;for(const i in n.children)if(!t.children[i]||!NO(t.children[i],n.children[i],r))return!1;return!0}{const i=e.slice(0,t.segments.length),s=e.slice(t.segments.length);return!!(Pd(t.segments,i)&&ov(t.segments,i,r)&&t.children[gi])&&AO(t.children[gi],n,s,r)}}function ov(t,n,e){return n.every((r,i)=>SO[e](t[i].parameters,r.parameters))}class np{constructor(n=new oo([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=ep(this.queryParams)),this._queryParamMap}toString(){return c7.serialize(this)}}class oo{constructor(n,e){this.segments=n,this.children=e,this.parent=null,Object.values(e).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return av(this)}}class Xm{constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=ep(this.parameters)),this._parameterMap}toString(){return OO(this)}}function Pd(t,n){return t.length===n.length&&t.every((e,r)=>e.path===n[r].path)}let Zm=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return new HC},providedIn:"root"})}return t})();class HC{parse(n){const e=new E7(n);return new np(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){const e=`/${Ym(n.root,!0)}`,r=function f7(t){const n=Object.keys(t).map(e=>{const r=t[e];return Array.isArray(r)?r.map(i=>`${uv(e)}=${uv(i)}`).join("&"):`${uv(e)}=${uv(r)}`}).filter(e=>!!e);return n.length?`?${n.join("&")}`:""}(n.queryParams);return`${e}${r}${"string"==typeof n.fragment?`#${function h7(t){return encodeURI(t)}(n.fragment)}`:""}`}}const c7=new HC;function av(t){return t.segments.map(n=>OO(n)).join("/")}function Ym(t,n){if(!t.hasChildren())return av(t);if(n){const e=t.children[gi]?Ym(t.children[gi],!1):"",r=[];return Object.entries(t.children).forEach(([i,s])=>{i!==gi&&r.push(`${i}:${Ym(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function l7(t,n){let e=[];return Object.entries(t.children).forEach(([r,i])=>{r===gi&&(e=e.concat(n(i,r)))}),Object.entries(t.children).forEach(([r,i])=>{r!==gi&&(e=e.concat(n(i,r)))}),e}(t,(r,i)=>i===gi?[Ym(t.children[gi],!1)]:[`${i}:${Ym(r,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children[gi]?`${av(t)}/${e[0]}`:`${av(t)}/(${e.join("//")})`}}function MO(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function uv(t){return MO(t).replace(/%3B/gi,";")}function jC(t){return MO(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function lv(t){return decodeURIComponent(t)}function PO(t){return lv(t.replace(/\+/g,"%20"))}function OO(t){return`${jC(t.path)}${function d7(t){return Object.keys(t).map(n=>`;${jC(n)}=${jC(t[n])}`).join("")}(t.parameters)}`}const p7=/^[^\/()?;#]+/;function KC(t){const n=t.match(p7);return n?n[0]:""}const m7=/^[^\/()?;=#]+/,y7=/^[^=?&#]+/,_7=/^[^&#]+/;class E7{constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new oo([],{}):new oo([],this.parseChildren())}parseQueryParams(){const n={};if(this.consumeOptional("?"))do{this.parseQueryParam(n)}while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(e).length>0)&&(r[gi]=new oo(n,e)),r}parseSegment(){const n=KC(this.remaining);if(""===n&&this.peekStartsWith(";"))throw new We(4009,!1);return this.capture(n),new Xm(lv(n),this.parseMatrixParams())}parseMatrixParams(){const n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){const e=function g7(t){const n=t.match(m7);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=KC(this.remaining);i&&(r=i,this.capture(r))}n[lv(e)]=lv(r)}parseQueryParam(n){const e=function v7(t){const n=t.match(y7);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const o=function x7(t){const n=t.match(_7);return n?n[0]:""}(this.remaining);o&&(r=o,this.capture(r))}const i=PO(e),s=PO(r);if(n.hasOwnProperty(i)){let o=n[i];Array.isArray(o)||(o=[o],n[i]=o),o.push(s)}else n[i]=s}parseParens(n){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=KC(this.remaining),i=this.remaining[r.length];if("/"!==i&&")"!==i&&";"!==i)throw new We(4010,!1);let s;r.indexOf(":")>-1?(s=r.slice(0,r.indexOf(":")),this.capture(s),this.capture(":")):n&&(s=gi);const o=this.parseChildren();e[s]=1===Object.keys(o).length?o[gi]:new oo([],o),this.consumeOptional("//")}return e}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return!!this.peekStartsWith(n)&&(this.remaining=this.remaining.substring(n.length),!0)}capture(n){if(!this.consumeOptional(n))throw new We(4011,!1)}}function RO(t){return t.segments.length>0?new oo([],{[gi]:t}):t}function LO(t){const n={};for(const r of Object.keys(t.children)){const s=LO(t.children[r]);if(r===gi&&0===s.segments.length&&s.hasChildren())for(const[o,a]of Object.entries(s.children))n[o]=a;else(s.segments.length>0||s.hasChildren())&&(n[r]=s)}return function C7(t){if(1===t.numberOfChildren&&t.children[gi]){const n=t.children[gi];return new oo(t.segments.concat(n.segments),n.children)}return t}(new oo(t.segments,n))}function Od(t){return t instanceof np}function kO(t){let n;const i=RO(function e(s){const o={};for(const u of s.children){const c=e(u);o[u.outlet]=c}const a=new oo(s.url,o);return s===t&&(n=a),a}(t.root));return n??i}function FO(t,n,e,r){let i=t;for(;i.parent;)i=i.parent;if(0===n.length)return XC(i,i,i,e,r);const s=function b7(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new BO(!0,0,t);let n=0,e=!1;const r=t.reduce((i,s,o)=>{if("object"==typeof s&&null!=s){if(s.outlets){const a={};return Object.entries(s.outlets).forEach(([u,c])=>{a[u]="string"==typeof c?c.split("/"):c}),[...i,{outlets:a}]}if(s.segmentPath)return[...i,s.segmentPath]}return"string"!=typeof s?[...i,s]:0===o?(s.split("/").forEach((a,u)=>{0==u&&"."===a||(0==u&&""===a?e=!0:".."===a?n++:""!=a&&i.push(a))}),i):[...i,s]},[]);return new BO(e,n,r)}(n);if(s.toRoot())return XC(i,i,new oo([],{}),e,r);const o=function I7(t,n,e){if(t.isAbsolute)return new hv(n,!0,0);if(!e)return new hv(n,!1,NaN);if(null===e.parent)return new hv(e,!0,0);const r=cv(t.commands[0])?0:1;return function S7(t,n,e){let r=t,i=n,s=e;for(;s>i;){if(s-=i,r=r.parent,!r)throw new We(4005,!1);i=r.segments.length}return new hv(r,!1,i-s)}(e,e.segments.length-1+r,t.numberOfDoubleDots)}(s,i,t),a=o.processChildren?Qm(o.segmentGroup,o.index,s.commands):zO(o.segmentGroup,o.index,s.commands);return XC(i,o.segmentGroup,a,e,r)}function cv(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function qm(t){return"object"==typeof t&&null!=t&&t.outlets}function XC(t,n,e,r,i){let o,s={};r&&Object.entries(r).forEach(([u,c])=>{s[u]=Array.isArray(c)?c.map(d=>`${d}`):`${c}`}),o=t===n?e:$O(t,n,e);const a=RO(LO(o));return new np(a,s,i)}function $O(t,n,e){const r={};return Object.entries(t.children).forEach(([i,s])=>{r[i]=s===n?e:$O(s,n,e)}),new oo(t.segments,r)}class BO{constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&cv(r[0]))throw new We(4003,!1);const i=r.find(qm);if(i&&i!==IO(r))throw new We(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class hv{constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}}function zO(t,n,e){if(t||(t=new oo([],{})),0===t.segments.length&&t.hasChildren())return Qm(t,n,e);const r=function T7(t,n,e){let r=0,i=n;const s={match:!1,pathIndex:0,commandIndex:0};for(;i<t.segments.length;){if(r>=e.length)return s;const o=t.segments[i],a=e[r];if(qm(a))break;const u=`${a}`,c=r<e.length-1?e[r+1]:null;if(i>0&&void 0===u)break;if(u&&c&&"object"==typeof c&&void 0===c.outlets){if(!UO(u,c,o))return s;r+=2}else{if(!UO(u,{},o))return s;r++}i++}return{match:!0,pathIndex:i,commandIndex:r}}(t,n,e),i=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const s=new oo(t.segments.slice(0,r.pathIndex),{});return s.children[gi]=new oo(t.segments.slice(r.pathIndex),t.children),Qm(s,0,i)}return r.match&&0===i.length?new oo(t.segments,{}):r.match&&!t.hasChildren()?ZC(t,n,e):r.match?Qm(t,0,i):ZC(t,n,e)}function Qm(t,n,e){if(0===e.length)return new oo(t.segments,{});{const r=function D7(t){return qm(t[0])?t[0].outlets:{[gi]:t}}(e),i={};if(Object.keys(r).some(s=>s!==gi)&&t.children[gi]&&1===t.numberOfChildren&&0===t.children[gi].segments.length){const s=Qm(t.children[gi],n,e);return new oo(t.segments,s.children)}return Object.entries(r).forEach(([s,o])=>{"string"==typeof o&&(o=[o]),null!==o&&(i[s]=zO(t.children[s],n,o))}),Object.entries(t.children).forEach(([s,o])=>{void 0===r[s]&&(i[s]=o)}),new oo(t.segments,i)}}function ZC(t,n,e){const r=t.segments.slice(0,n);let i=0;for(;i<e.length;){const s=e[i];if(qm(s)){const u=N7(s.outlets);return new oo(r,u)}if(0===i&&cv(e[0])){r.push(new Xm(t.segments[n].path,VO(e[0]))),i++;continue}const o=qm(s)?s.outlets[gi]:`${s}`,a=i<e.length-1?e[i+1]:null;o&&a&&cv(a)?(r.push(new Xm(o,VO(a))),i+=2):(r.push(new Xm(o,{})),i++)}return new oo(r,{})}function N7(t){const n={};return Object.entries(t).forEach(([e,r])=>{"string"==typeof r&&(r=[r]),null!==r&&(n[e]=ZC(new oo([],{}),0,r))}),n}function VO(t){const n={};return Object.entries(t).forEach(([e,r])=>n[e]=`${r}`),n}function UO(t,n,e){return t==e.path&&Wc(n,e.parameters)}const Jm="imperative";class Gc{constructor(n,e){this.id=n,this.url=e}}class dv extends Gc{constructor(n,e,r="imperative",i=null){super(n,e),this.type=0,this.navigationTrigger=r,this.restoredState=i}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Gh extends Gc{constructor(n,e,r){super(n,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class tg extends Gc{constructor(n,e,r,i){super(n,e),this.reason=r,this.code=i,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class rp extends Gc{constructor(n,e,r,i){super(n,e),this.reason=r,this.code=i,this.type=16}}class fv extends Gc{constructor(n,e,r,i){super(n,e),this.error=r,this.target=i,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class WO extends Gc{constructor(n,e,r,i){super(n,e),this.urlAfterRedirects=r,this.state=i,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class A7 extends Gc{constructor(n,e,r,i){super(n,e),this.urlAfterRedirects=r,this.state=i,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class M7 extends Gc{constructor(n,e,r,i,s){super(n,e),this.urlAfterRedirects=r,this.state=i,this.shouldActivate=s,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class P7 extends Gc{constructor(n,e,r,i){super(n,e),this.urlAfterRedirects=r,this.state=i,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class O7 extends Gc{constructor(n,e,r,i){super(n,e),this.urlAfterRedirects=r,this.state=i,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class R7{constructor(n){this.route=n,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class L7{constructor(n){this.route=n,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class k7{constructor(n){this.snapshot=n,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class F7{constructor(n){this.snapshot=n,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class $7{constructor(n){this.snapshot=n,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class B7{constructor(n){this.snapshot=n,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class GO{constructor(n,e,r){this.routerEvent=n,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class YC{}class qC{constructor(n){this.url=n}}class z7{constructor(){this.outlet=null,this.route=null,this.injector=null,this.children=new eg,this.attachRef=null}}let eg=(()=>{class t{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const i=this.getOrCreateContext(e);i.outlet=r,this.contexts.set(e,i)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new z7,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();class HO{constructor(n){this._root=n}get root(){return this._root.value}parent(n){const e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){const e=QC(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){const e=QC(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){const e=JC(n,this._root);return e.length<2?[]:e[e.length-2].children.map(i=>i.value).filter(i=>i!==n)}pathFromRoot(n){return JC(n,this._root).map(e=>e.value)}}function QC(t,n){if(t===n.value)return n;for(const e of n.children){const r=QC(t,e);if(r)return r}return null}function JC(t,n){if(t===n.value)return[n];for(const e of n.children){const r=JC(t,e);if(r.length)return r.unshift(n),r}return[]}class _h{constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}}function ip(t){const n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}class jO extends HO{constructor(n,e){super(n),this.snapshot=e,tw(this,n)}toString(){return this.snapshot.toString()}}function KO(t,n){const e=function V7(t,n){const o=new pv([],{},{},"",{},gi,n,null,{});return new ZO("",new _h(o,[]))}(0,n),r=new jr([new Xm("",{})]),i=new jr({}),s=new jr({}),o=new jr({}),a=new jr(""),u=new sp(r,i,o,a,s,gi,n,e.root);return u.snapshot=e.root,new jO(new _h(u,[]),e)}class sp{constructor(n,e,r,i,s,o,a,u){this.urlSubject=n,this.paramsSubject=e,this.queryParamsSubject=r,this.fragmentSubject=i,this.dataSubject=s,this.outlet=o,this.component=a,this._futureSnapshot=u,this.title=this.dataSubject?.pipe(Ue(c=>c[Km]))??qn(void 0),this.url=n,this.params=e,this.queryParams=r,this.fragment=i,this.data=s}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Ue(n=>ep(n)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Ue(n=>ep(n)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function XO(t,n="emptyOnly"){const e=t.pathFromRoot;let r=0;if("always"!==n)for(r=e.length-1;r>=1;){const i=e[r],s=e[r-1];if(i.routeConfig&&""===i.routeConfig.path)r--;else{if(s.component)break;r--}}return function U7(t){return t.reduce((n,e)=>({params:{...n.params,...e.params},data:{...n.data,...e.data},resolve:{...e.data,...n.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class pv{get title(){return this.data?.[Km]}constructor(n,e,r,i,s,o,a,u,c){this.url=n,this.params=e,this.queryParams=r,this.fragment=i,this.data=s,this.outlet=o,this.component=a,this.routeConfig=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=ep(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=ep(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class ZO extends HO{constructor(n,e){super(e),this.url=n,tw(this,e)}toString(){return YO(this._root)}}function tw(t,n){n.value._routerState=t,n.children.forEach(e=>tw(t,e))}function YO(t){const n=t.children.length>0?` { ${t.children.map(YO).join(", ")} } `:"";return`${t.value}${n}`}function ew(t){if(t.snapshot){const n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,Wc(n.queryParams,e.queryParams)||t.queryParamsSubject.next(e.queryParams),n.fragment!==e.fragment&&t.fragmentSubject.next(e.fragment),Wc(n.params,e.params)||t.paramsSubject.next(e.params),function i7(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!Wc(t[e],n[e]))return!1;return!0}(n.url,e.url)||t.urlSubject.next(e.url),Wc(n.data,e.data)||t.dataSubject.next(e.data)}else t.snapshot=t._futureSnapshot,t.dataSubject.next(t._futureSnapshot.data)}function nw(t,n){const e=Wc(t.params,n.params)&&function u7(t,n){return Pd(t,n)&&t.every((e,r)=>Wc(e.parameters,n[r].parameters))}(t.url,n.url);return e&&!(!t.parent!=!n.parent)&&(!t.parent||nw(t.parent,n.parent))}let qO=(()=>{class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=gi,this.activateEvents=new Sa,this.deactivateEvents=new Sa,this.attachEvents=new Sa,this.detachEvents=new Sa,this.parentContexts=Mn(eg),this.location=Mn(vc),this.changeDetector=Mn(z0),this.environmentInjector=Mn(Ql),this.inputBinder=Mn(mv,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:i}=e.name;if(r)return;this.isTrackedInParentContexts(i)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(i)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new We(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new We(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new We(4012,!1);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new We(4013,!1);this._activatedRoute=e;const i=this.location,o=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,u=new W7(e,a,i.injector);this.activated=i.createComponent(o,{index:i.length,injector:u,environmentInjector:r??this.environmentInjector}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275dir=or({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[yl]})}return t})();class W7{constructor(n,e,r){this.route=n,this.childContexts=e,this.parent=r}get(n,e){return n===sp?this.route:n===eg?this.childContexts:this.parent.get(n,e)}}const mv=new In("");let QO=(()=>{class t{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(e){this.unsubscribeFromRouteData(e),this.subscribeToRouteData(e)}unsubscribeFromRouteData(e){this.outletDataSubscriptions.get(e)?.unsubscribe(),this.outletDataSubscriptions.delete(e)}subscribeToRouteData(e){const{activatedRoute:r}=e,i=zC([r.queryParams,r.params,r.data]).pipe(bo(([s,o,a],u)=>(a={...s,...o,...a},0===u?qn(a):Promise.resolve(a)))).subscribe(s=>{if(!e.isActivated||!e.activatedComponentRef||e.activatedRoute!==r||null===r.component)return void this.unsubscribeFromRouteData(e);const o=function dj(t){const n=Tr(t);if(!n)return null;const e=new wm(n);return{get selector(){return e.selector},get type(){return e.componentType},get inputs(){return e.inputs},get outputs(){return e.outputs},get ngContentSelectors(){return e.ngContentSelectors},get isStandalone(){return n.standalone},get isSignal(){return n.signals}}}(r.component);if(o)for(const{templateName:a}of o.inputs)e.activatedComponentRef.setInput(a,s[a]);else this.unsubscribeFromRouteData(e)});this.outletDataSubscriptions.set(e,i)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();function ng(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=n.value;const i=function H7(t,n,e){return n.children.map(r=>{for(const i of e.children)if(t.shouldReuseRoute(r.value,i.value.snapshot))return ng(t,r,i);return ng(t,r)})}(t,n,e);return new _h(r,i)}{if(t.shouldAttach(n.value)){const s=t.retrieve(n.value);if(null!==s){const o=s.route;return o.value._futureSnapshot=n.value,o.children=n.children.map(a=>ng(t,a)),o}}const r=function j7(t){return new sp(new jr(t.url),new jr(t.params),new jr(t.queryParams),new jr(t.fragment),new jr(t.data),t.outlet,t.component,t)}(n.value),i=n.children.map(s=>ng(t,s));return new _h(r,i)}}const rw="ngNavigationCancelingError";function JO(t,n){const{redirectTo:e,navigationBehaviorOptions:r}=Od(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,i=tR(!1,0,n);return i.url=e,i.navigationBehaviorOptions=r,i}function tR(t,n,e){const r=new Error("NavigationCancelingError: "+(t||""));return r[rw]=!0,r.cancellationCode=n,e&&(r.url=e),r}function eR(t){return t&&t[rw]}let nR=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275cmp=ha({type:t,selectors:[["ng-component"]],standalone:!0,features:[nM],decls:1,vars:0,template:function(r,i){1&r&&_u(0,"router-outlet")},dependencies:[qO],encapsulation:2})}return t})();function iw(t){const n=t.children&&t.children.map(iw),e=n?{...t,children:n}:{...t};return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==gi&&(e.component=nR),e}function Ec(t){return t.outlet||gi}function rg(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let n=t.parent;n;n=n.parent){const e=n.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class tX{constructor(n,e,r,i,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=i,this.inputBindingEnabled=s}activate(n){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),ew(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){const i=ip(e);n.children.forEach(s=>{const o=s.value.outlet;this.deactivateRoutes(s,i[o],r),delete i[o]}),Object.values(i).forEach(s=>{this.deactivateRouteAndItsChildren(s,r)})}deactivateRoutes(n,e,r){const i=n.value,s=e?e.value:null;if(i===s)if(i.component){const o=r.getContext(i.outlet);o&&this.deactivateChildRoutes(n,e,o.children)}else this.deactivateChildRoutes(n,e,r);else s&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){const r=e.getContext(n.value.outlet),i=r&&n.value.component?r.children:e,s=ip(n);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],i);if(r&&r.outlet){const o=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:o,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){const r=e.getContext(n.value.outlet),i=r&&n.value.component?r.children:e,s=ip(n);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],i);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(n,e,r){const i=ip(e);n.children.forEach(s=>{this.activateRoutes(s,i[s.value.outlet],r),this.forwardEvent(new B7(s.value.snapshot))}),n.children.length&&this.forwardEvent(new F7(n.value.snapshot))}activateRoutes(n,e,r){const i=n.value,s=e?e.value:null;if(ew(i),i===s)if(i.component){const o=r.getOrCreateContext(i.outlet);this.activateChildRoutes(n,e,o.children)}else this.activateChildRoutes(n,e,r);else if(i.component){const o=r.getOrCreateContext(i.outlet);if(this.routeReuseStrategy.shouldAttach(i.snapshot)){const a=this.routeReuseStrategy.retrieve(i.snapshot);this.routeReuseStrategy.store(i.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),ew(a.route.value),this.activateChildRoutes(n,null,o.children)}else{const a=rg(i.snapshot);o.attachRef=null,o.route=i,o.injector=a,o.outlet&&o.outlet.activateWith(i,o.injector),this.activateChildRoutes(n,null,o.children)}}else this.activateChildRoutes(n,null,r)}}class rR{constructor(n){this.path=n,this.route=this.path[this.path.length-1]}}class gv{constructor(n,e){this.component=n,this.route=e}}function eX(t,n,e){const r=t._root;return ig(r,n?n._root:null,e,[r.value])}function op(t,n){const e=Symbol(),r=n.get(t,e);return r===e?"function"!=typeof t||function vr(t){return null!==Vn(t)}(t)?n.get(t):t:r}function ig(t,n,e,r,i={canDeactivateChecks:[],canActivateChecks:[]}){const s=ip(n);return t.children.forEach(o=>{(function rX(t,n,e,r,i={canDeactivateChecks:[],canActivateChecks:[]}){const s=t.value,o=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(o&&s.routeConfig===o.routeConfig){const u=function iX(t,n,e){if("function"==typeof e)return e(t,n);switch(e){case"pathParamsChange":return!Pd(t.url,n.url);case"pathParamsOrQueryParamsChange":return!Pd(t.url,n.url)||!Wc(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!nw(t,n)||!Wc(t.queryParams,n.queryParams);default:return!nw(t,n)}}(o,s,s.routeConfig.runGuardsAndResolvers);u?i.canActivateChecks.push(new rR(r)):(s.data=o.data,s._resolvedData=o._resolvedData),ig(t,n,s.component?a?a.children:null:e,r,i),u&&a&&a.outlet&&a.outlet.isActivated&&i.canDeactivateChecks.push(new gv(a.outlet.component,o))}else o&&sg(n,a,i),i.canActivateChecks.push(new rR(r)),ig(t,null,s.component?a?a.children:null:e,r,i)})(o,s[o.value.outlet],e,r.concat([o.value]),i),delete s[o.value.outlet]}),Object.entries(s).forEach(([o,a])=>sg(a,e.getContext(o),i)),i}function sg(t,n,e){const r=ip(t),i=t.value;Object.entries(r).forEach(([s,o])=>{sg(o,i.component?n?n.children.getContext(s):null:n,e)}),e.canDeactivateChecks.push(new gv(i.component&&n&&n.outlet&&n.outlet.isActivated?n.outlet.component:null,i))}function og(t){return"function"==typeof t}function iR(t){return t instanceof iv||"EmptyError"===t?.name}const yv=Symbol("INITIAL_VALUE");function ap(){return bo(t=>zC(t.map(n=>n.pipe(tp(1),function Z9(...t){const n=eo(t);return be((e,r)=>{(n?VC(t,e,n):VC(t,e)).subscribe(r)})}(yv)))).pipe(Ue(n=>{for(const e of n)if(!0!==e){if(e===yv)return yv;if(!1===e||e instanceof np)return e}return!0}),Uh(n=>n!==yv),tp(1)))}function sR(t){return function yt(...t){return vt(t)}(Uu(n=>{if(Od(n))throw JO(0,n)}),Ue(n=>!0===n))}class vv{constructor(n){this.segmentGroup=n||null}}class oR{constructor(n){this.urlTree=n}}function up(t){return Hm(new vv(t))}function aR(t){return Hm(new oR(t))}class bX{constructor(n,e){this.urlSerializer=n,this.urlTree=e}noMatchError(n){return new We(4002,!1)}lineralizeSegments(n,e){let r=[],i=e.root;for(;;){if(r=r.concat(i.segments),0===i.numberOfChildren)return qn(r);if(i.numberOfChildren>1||!i.children[gi])return Hm(new We(4e3,!1));i=i.children[gi]}}applyRedirectCommands(n,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),n,r)}applyRedirectCreateUrlTree(n,e,r,i){const s=this.createSegmentGroup(n,e.root,r,i);return new np(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){const r={};return Object.entries(n).forEach(([i,s])=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[i]=e[a]}else r[i]=s}),r}createSegmentGroup(n,e,r,i){const s=this.createSegments(n,e.segments,r,i);let o={};return Object.entries(e.children).forEach(([a,u])=>{o[a]=this.createSegmentGroup(n,u,r,i)}),new oo(s,o)}createSegments(n,e,r,i){return e.map(s=>s.path.startsWith(":")?this.findPosParam(n,s,i):this.findOrReturn(s,r))}findPosParam(n,e,r){const i=r[e.path.substring(1)];if(!i)throw new We(4001,!1);return i}findOrReturn(n,e){let r=0;for(const i of e){if(i.path===n.path)return e.splice(r),i;r++}return n}}const sw={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function IX(t,n,e,r,i){const s=ow(t,n,e);return s.matched?(r=function X7(t,n){return t.providers&&!t._injector&&(t._injector=LE(t.providers,n,`Route: ${t.path}`)),t._injector??n}(n,r),function EX(t,n,e,r){const i=n.canMatch;return i&&0!==i.length?qn(i.map(o=>{const a=op(o,t);return Wh(function cX(t){return t&&og(t.canMatch)}(a)?a.canMatch(n,e):t.runInContext(()=>a(n,e)))})).pipe(ap(),sR()):qn(!0)}(r,n,e).pipe(Ue(o=>!0===o?s:{...sw}))):qn(s)}function ow(t,n,e){if(""===n.path)return"full"===n.pathMatch&&(t.hasChildren()||e.length>0)?{...sw}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const i=(n.matcher||r7)(e,t,n);if(!i)return{...sw};const s={};Object.entries(i.posParams??{}).forEach(([a,u])=>{s[a]=u.path});const o=i.consumed.length>0?{...s,...i.consumed[i.consumed.length-1].parameters}:s;return{matched:!0,consumedSegments:i.consumed,remainingSegments:e.slice(i.consumed.length),parameters:o,positionalParamSegments:i.posParams??{}}}function uR(t,n,e,r){return e.length>0&&function TX(t,n,e){return e.some(r=>_v(t,n,r)&&Ec(r)!==gi)}(t,e,r)?{segmentGroup:new oo(n,DX(r,new oo(e,t.children))),slicedSegments:[]}:0===e.length&&function NX(t,n,e){return e.some(r=>_v(t,n,r))}(t,e,r)?{segmentGroup:new oo(t.segments,SX(t,0,e,r,t.children)),slicedSegments:e}:{segmentGroup:new oo(t.segments,t.children),slicedSegments:e}}function SX(t,n,e,r,i){const s={};for(const o of r)if(_v(t,e,o)&&!i[Ec(o)]){const a=new oo([],{});s[Ec(o)]=a}return{...i,...s}}function DX(t,n){const e={};e[gi]=n;for(const r of t)if(""===r.path&&Ec(r)!==gi){const i=new oo([],{});e[Ec(r)]=i}return e}function _v(t,n,e){return(!(t.hasChildren()||n.length>0)||"full"!==e.pathMatch)&&""===e.path}class OX{constructor(n,e,r,i,s,o,a){this.injector=n,this.configLoader=e,this.rootComponentType=r,this.config=i,this.urlTree=s,this.paramsInheritanceStrategy=o,this.urlSerializer=a,this.allowRedirects=!0,this.applyRedirects=new bX(this.urlSerializer,this.urlTree)}noMatchError(n){return new We(4002,!1)}recognize(){const n=uR(this.urlTree.root,[],[],this.config).segmentGroup;return this.processSegmentGroup(this.injector,this.config,n,gi).pipe(Md(e=>{if(e instanceof oR)return this.allowRedirects=!1,this.urlTree=e.urlTree,this.match(e.urlTree);throw e instanceof vv?this.noMatchError(e):e}),Ue(e=>{const r=new pv([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},gi,this.rootComponentType,null,{}),i=new _h(r,e),s=new ZO("",i),o=function w7(t,n,e=null,r=null){return FO(kO(t),n,e,r)}(r,[],this.urlTree.queryParams,this.urlTree.fragment);return o.queryParams=this.urlTree.queryParams,s.url=this.urlSerializer.serialize(o),this.inheritParamsAndData(s._root),{state:s,tree:o}}))}match(n){return this.processSegmentGroup(this.injector,this.config,n.root,gi).pipe(Md(r=>{throw r instanceof vv?this.noMatchError(r):r}))}inheritParamsAndData(n){const e=n.value,r=XO(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),n.children.forEach(i=>this.inheritParamsAndData(i))}processSegmentGroup(n,e,r,i){return 0===r.segments.length&&r.hasChildren()?this.processChildren(n,e,r):this.processSegment(n,e,r,r.segments,i,!0)}processChildren(n,e,r){const i=[];for(const s of Object.keys(r.children))"primary"===s?i.unshift(s):i.push(s);return ss(i).pipe(jm(s=>{const o=r.children[s],a=function Q7(t,n){const e=t.filter(r=>Ec(r)===n);return e.push(...t.filter(r=>Ec(r)!==n)),e}(e,s);return this.processSegmentGroup(n,a,o,s)}),function Q9(t,n){return be(function q9(t,n,e,r,i){return(s,o)=>{let a=e,u=n,c=0;s.subscribe(Me(o,d=>{const p=c++;u=a?t(u,d,p):(a=!0,d),r&&o.next(u)},i&&(()=>{a&&o.next(u),o.complete()})))}}(t,n,arguments.length>=2,!0))}((s,o)=>(s.push(...o),s)),sv(null),function J9(t,n){const e=arguments.length>=2;return r=>r.pipe(t?Uh((i,s)=>t(i,s,r)):Ct,WC(1),e?sv(n):wO(()=>new iv))}(),Ss(s=>{if(null===s)return up(r);const o=lR(s);return function RX(t){t.sort((n,e)=>n.value.outlet===gi?-1:e.value.outlet===gi?1:n.value.outlet.localeCompare(e.value.outlet))}(o),qn(o)}))}processSegment(n,e,r,i,s,o){return ss(e).pipe(jm(a=>this.processSegmentAgainstRoute(a._injector??n,e,a,r,i,s,o).pipe(Md(u=>{if(u instanceof vv)return qn(null);throw u}))),Ad(a=>!!a),Md(a=>{if(iR(a))return function MX(t,n,e){return 0===n.length&&!t.children[e]}(r,i,s)?qn([]):up(r);throw a}))}processSegmentAgainstRoute(n,e,r,i,s,o,a){return function AX(t,n,e,r){return!!(Ec(t)===r||r!==gi&&_v(n,e,t))&&("**"===t.path||ow(n,t,e).matched)}(r,i,s,o)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(n,i,r,s,o,a):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(n,i,e,r,s,o):up(i):up(i)}expandSegmentAgainstRouteUsingRedirect(n,e,r,i,s,o){return"**"===i.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(n,r,i,o):this.expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,i,s,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(n,e,r,i){const s=this.applyRedirects.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?aR(s):this.applyRedirects.lineralizeSegments(r,s).pipe(Ss(o=>{const a=new oo(o,{});return this.processSegment(n,e,a,o,i,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,i,s,o){const{matched:a,consumedSegments:u,remainingSegments:c,positionalParamSegments:d}=ow(e,i,s);if(!a)return up(e);const p=this.applyRedirects.applyRedirectCommands(u,i.redirectTo,d);return i.redirectTo.startsWith("/")?aR(p):this.applyRedirects.lineralizeSegments(i,p).pipe(Ss(v=>this.processSegment(n,r,e,v.concat(c),o,!1)))}matchSegmentAgainstRoute(n,e,r,i,s,o){let a;if("**"===r.path){const u=i.length>0?IO(i).parameters:{};a=qn({snapshot:new pv(i,u,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,cR(r),Ec(r),r.component??r._loadedComponent??null,r,hR(r)),consumedSegments:[],remainingSegments:[]}),e.children={}}else a=IX(e,r,i,n).pipe(Ue(({matched:u,consumedSegments:c,remainingSegments:d,parameters:p})=>u?{snapshot:new pv(c,p,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,cR(r),Ec(r),r.component??r._loadedComponent??null,r,hR(r)),consumedSegments:c,remainingSegments:d}:null));return a.pipe(bo(u=>null===u?up(e):this.getChildConfig(n=r._injector??n,r,i).pipe(bo(({routes:c})=>{const d=r._loadedInjector??n,{snapshot:p,consumedSegments:v,remainingSegments:x}=u,{segmentGroup:w,slicedSegments:b}=uR(e,v,x,c);if(0===b.length&&w.hasChildren())return this.processChildren(d,c,w).pipe(Ue(N=>null===N?null:[new _h(p,N)]));if(0===c.length&&0===b.length)return qn([new _h(p,[])]);const T=Ec(r)===s;return this.processSegment(d,c,w,b,T?gi:s,!0).pipe(Ue(N=>[new _h(p,N)]))}))))}getChildConfig(n,e,r){return e.children?qn({routes:e.children,injector:n}):e.loadChildren?void 0!==e._loadedRoutes?qn({routes:e._loadedRoutes,injector:e._loadedInjector}):function xX(t,n,e,r){const i=n.canLoad;return void 0===i||0===i.length?qn(!0):qn(i.map(o=>{const a=op(o,t);return Wh(function oX(t){return t&&og(t.canLoad)}(a)?a.canLoad(n,e):t.runInContext(()=>a(n,e)))})).pipe(ap(),sR())}(n,e,r).pipe(Ss(i=>i?this.configLoader.loadChildren(n,e).pipe(Uu(s=>{e._loadedRoutes=s.routes,e._loadedInjector=s.injector})):function wX(t){return Hm(tR(!1,3))}())):qn({routes:[],injector:n})}}function LX(t){const n=t.value.routeConfig;return n&&""===n.path}function lR(t){const n=[],e=new Set;for(const r of t){if(!LX(r)){n.push(r);continue}const i=n.find(s=>r.value.routeConfig===s.value.routeConfig);void 0!==i?(i.children.push(...r.children),e.add(i)):n.push(r)}for(const r of e){const i=lR(r.children);n.push(new _h(r.value,i))}return n.filter(r=>!e.has(r))}function cR(t){return t.data||{}}function hR(t){return t.resolve||{}}function dR(t){return"string"==typeof t.title||null===t.title}function aw(t){return bo(n=>{const e=t(n);return e?ss(e).pipe(Ue(()=>n)):qn(n)})}const lp=new In("ROUTES");let uw=(()=>{class t{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=Mn(ZM)}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return qn(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=Wh(e.loadComponent()).pipe(Ue(fR),Uu(s=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=s}),GC(()=>{this.componentLoaders.delete(e)})),i=new CO(r,()=>new ee).pipe(UC());return this.componentLoaders.set(e,i),i}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return qn({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const s=function UX(t,n,e,r){return Wh(t.loadChildren()).pipe(Ue(fR),Ss(i=>i instanceof tM||Array.isArray(i)?qn(i):ss(n.compileModuleAsync(i))),Ue(i=>{r&&r(t);let s,o,a=!1;return Array.isArray(i)?(o=i,!0):(s=i.create(e).injector,o=s.get(lp,[],{optional:!0,self:!0}).flat()),{routes:o.map(iw),injector:s}}))}(r,this.compiler,e,this.onLoadEndListener).pipe(GC(()=>{this.childrenLoaders.delete(r)})),o=new CO(s,()=>new ee).pipe(UC());return this.childrenLoaders.set(r,o),o}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function fR(t){return function WX(t){return t&&"object"==typeof t&&"default"in t}(t)?t.default:t}let xv=(()=>{class t{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.currentTransition=null,this.lastSuccessfulNavigation=null,this.events=new ee,this.transitionAbortSubject=new ee,this.configLoader=Mn(uw),this.environmentInjector=Mn(Ql),this.urlSerializer=Mn(Zm),this.rootContexts=Mn(eg),this.inputBindingEnabled=null!==Mn(mv,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>qn(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=i=>this.events.next(new L7(i)),this.configLoader.onLoadStartListener=i=>this.events.next(new R7(i))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:r})}setupNavigations(e,r,i){return this.transitions=new jr({id:0,currentUrlTree:r,currentRawUrl:r,currentBrowserUrl:r,extractedUrl:e.urlHandlingStrategy.extract(r),urlAfterRedirects:e.urlHandlingStrategy.extract(r),rawUrl:r,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:Jm,restoredState:null,currentSnapshot:i.snapshot,targetSnapshot:null,currentRouterState:i,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(Uh(s=>0!==s.id),Ue(s=>({...s,extractedUrl:e.urlHandlingStrategy.extract(s.rawUrl)})),bo(s=>{this.currentTransition=s;let o=!1,a=!1;return qn(s).pipe(Uu(u=>{this.currentNavigation={id:u.id,initialUrl:u.rawUrl,extractedUrl:u.extractedUrl,trigger:u.source,extras:u.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),bo(u=>{const c=u.currentBrowserUrl.toString(),d=!e.navigated||u.extractedUrl.toString()!==c||c!==u.currentUrlTree.toString();if(!d&&"reload"!==(u.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const v="";return this.events.next(new rp(u.id,this.urlSerializer.serialize(u.rawUrl),v,0)),u.resolve(null),Vr}if(e.urlHandlingStrategy.shouldProcessUrl(u.rawUrl))return qn(u).pipe(bo(v=>{const x=this.transitions?.getValue();return this.events.next(new dv(v.id,this.urlSerializer.serialize(v.extractedUrl),v.source,v.restoredState)),x!==this.transitions?.getValue()?Vr:Promise.resolve(v)}),function kX(t,n,e,r,i,s){return Ss(o=>function PX(t,n,e,r,i,s,o="emptyOnly"){return new OX(t,n,e,r,i,o,s).recognize()}(t,n,e,r,o.extractedUrl,i,s).pipe(Ue(({state:a,tree:u})=>({...o,targetSnapshot:a,urlAfterRedirects:u}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),Uu(v=>{s.targetSnapshot=v.targetSnapshot,s.urlAfterRedirects=v.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:v.urlAfterRedirects};const x=new WO(v.id,this.urlSerializer.serialize(v.extractedUrl),this.urlSerializer.serialize(v.urlAfterRedirects),v.targetSnapshot);this.events.next(x)}));if(d&&e.urlHandlingStrategy.shouldProcessUrl(u.currentRawUrl)){const{id:v,extractedUrl:x,source:w,restoredState:b,extras:T}=u,N=new dv(v,this.urlSerializer.serialize(x),w,b);this.events.next(N);const S=KO(0,this.rootComponentType).snapshot;return this.currentTransition=s={...u,targetSnapshot:S,urlAfterRedirects:x,extras:{...T,skipLocationChange:!1,replaceUrl:!1}},qn(s)}{const v="";return this.events.next(new rp(u.id,this.urlSerializer.serialize(u.extractedUrl),v,1)),u.resolve(null),Vr}}),Uu(u=>{const c=new A7(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}),Ue(u=>(this.currentTransition=s={...u,guards:eX(u.targetSnapshot,u.currentSnapshot,this.rootContexts)},s)),function dX(t,n){return Ss(e=>{const{targetSnapshot:r,currentSnapshot:i,guards:{canActivateChecks:s,canDeactivateChecks:o}}=e;return 0===o.length&&0===s.length?qn({...e,guardsResult:!0}):function fX(t,n,e,r){return ss(t).pipe(Ss(i=>function _X(t,n,e,r,i){const s=n&&n.routeConfig?n.routeConfig.canDeactivate:null;return s&&0!==s.length?qn(s.map(a=>{const u=rg(n)??i,c=op(a,u);return Wh(function lX(t){return t&&og(t.canDeactivate)}(c)?c.canDeactivate(t,n,e,r):u.runInContext(()=>c(t,n,e,r))).pipe(Ad())})).pipe(ap()):qn(!0)}(i.component,i.route,e,n,r)),Ad(i=>!0!==i,!0))}(o,r,i,t).pipe(Ss(a=>a&&function sX(t){return"boolean"==typeof t}(a)?function pX(t,n,e,r){return ss(n).pipe(jm(i=>VC(function gX(t,n){return null!==t&&n&&n(new k7(t)),qn(!0)}(i.route.parent,r),function mX(t,n){return null!==t&&n&&n(new $7(t)),qn(!0)}(i.route,r),function vX(t,n,e){const r=n[n.length-1],s=n.slice(0,n.length-1).reverse().map(o=>function nX(t){const n=t.routeConfig?t.routeConfig.canActivateChild:null;return n&&0!==n.length?{node:t,guards:n}:null}(o)).filter(o=>null!==o).map(o=>EO(()=>qn(o.guards.map(u=>{const c=rg(o.node)??e,d=op(u,c);return Wh(function uX(t){return t&&og(t.canActivateChild)}(d)?d.canActivateChild(r,t):c.runInContext(()=>d(r,t))).pipe(Ad())})).pipe(ap())));return qn(s).pipe(ap())}(t,i.path,e),function yX(t,n,e){const r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||0===r.length)return qn(!0);const i=r.map(s=>EO(()=>{const o=rg(n)??e,a=op(s,o);return Wh(function aX(t){return t&&og(t.canActivate)}(a)?a.canActivate(n,t):o.runInContext(()=>a(n,t))).pipe(Ad())}));return qn(i).pipe(ap())}(t,i.route,e))),Ad(i=>!0!==i,!0))}(r,s,t,n):qn(a)),Ue(a=>({...e,guardsResult:a})))})}(this.environmentInjector,u=>this.events.next(u)),Uu(u=>{if(s.guardsResult=u.guardsResult,Od(u.guardsResult))throw JO(0,u.guardsResult);const c=new M7(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot,!!u.guardsResult);this.events.next(c)}),Uh(u=>!!u.guardsResult||(this.cancelNavigationTransition(u,"",3),!1)),aw(u=>{if(u.guards.canActivateChecks.length)return qn(u).pipe(Uu(c=>{const d=new P7(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(d)}),bo(c=>{let d=!1;return qn(c).pipe(function FX(t,n){return Ss(e=>{const{targetSnapshot:r,guards:{canActivateChecks:i}}=e;if(!i.length)return qn(e);let s=0;return ss(i).pipe(jm(o=>function $X(t,n,e,r){const i=t.routeConfig,s=t._resolve;return void 0!==i?.title&&!dR(i)&&(s[Km]=i.title),function BX(t,n,e,r){const i=function zX(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}(t);if(0===i.length)return qn({});const s={};return ss(i).pipe(Ss(o=>function VX(t,n,e,r){const i=rg(n)??r,s=op(t,i);return Wh(s.resolve?s.resolve(n,e):i.runInContext(()=>s(n,e)))}(t[o],n,e,r).pipe(Ad(),Uu(a=>{s[o]=a}))),WC(1),function t7(t){return Ue(()=>t)}(s),Md(o=>iR(o)?Vr:Hm(o)))}(s,t,n,r).pipe(Ue(o=>(t._resolvedData=o,t.data=XO(t,e).resolve,i&&dR(i)&&(t.data[Km]=i.title),null)))}(o.route,r,t,n)),Uu(()=>s++),WC(1),Ss(o=>s===i.length?qn(e):Vr))})}(e.paramsInheritanceStrategy,this.environmentInjector),Uu({next:()=>d=!0,complete:()=>{d||this.cancelNavigationTransition(c,"",2)}}))}),Uu(c=>{const d=new O7(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(d)}))}),aw(u=>{const c=d=>{const p=[];d.routeConfig?.loadComponent&&!d.routeConfig._loadedComponent&&p.push(this.configLoader.loadComponent(d.routeConfig).pipe(Uu(v=>{d.component=v}),Ue(()=>{})));for(const v of d.children)p.push(...c(v));return p};return zC(c(u.targetSnapshot.root)).pipe(sv(),tp(1))}),aw(()=>this.afterPreactivation()),Ue(u=>{const c=function G7(t,n,e){const r=ng(t,n._root,e?e._root:void 0);return new jO(r,n)}(e.routeReuseStrategy,u.targetSnapshot,u.currentRouterState);return this.currentTransition=s={...u,targetRouterState:c},s}),Uu(()=>{this.events.next(new YC)}),((t,n,e,r)=>Ue(i=>(new tX(n,i.targetRouterState,i.currentRouterState,e,r).activate(t),i)))(this.rootContexts,e.routeReuseStrategy,u=>this.events.next(u),this.inputBindingEnabled),tp(1),Uu({next:u=>{o=!0,this.lastSuccessfulNavigation=this.currentNavigation,this.events.next(new Gh(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects))),e.titleStrategy?.updateTitle(u.targetRouterState.snapshot),u.resolve(!0)},complete:()=>{o=!0}}),function e7(t){return be((n,e)=>{Rr(t).subscribe(Me(e,()=>e.complete(),it)),!e.closed&&n.subscribe(e)})}(this.transitionAbortSubject.pipe(Uu(u=>{throw u}))),GC(()=>{o||a||this.cancelNavigationTransition(s,"",1),this.currentNavigation?.id===s.id&&(this.currentNavigation=null)}),Md(u=>{if(a=!0,eR(u))this.events.next(new tg(s.id,this.urlSerializer.serialize(s.extractedUrl),u.message,u.cancellationCode)),function K7(t){return eR(t)&&Od(t.url)}(u)?this.events.next(new qC(u.url)):s.resolve(!1);else{this.events.next(new fv(s.id,this.urlSerializer.serialize(s.extractedUrl),u,s.targetSnapshot??void 0));try{s.resolve(e.errorHandler(u))}catch(c){s.reject(c)}}return Vr}))}))}cancelNavigationTransition(e,r,i){const s=new tg(e.id,this.urlSerializer.serialize(e.extractedUrl),r,i);this.events.next(s),e.resolve(!1)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function pR(t){return t!==Jm}let mR=(()=>{class t{buildTitle(e){let r,i=e.root;for(;void 0!==i;)r=this.getResolvedTitleForRoute(i)??r,i=i.children.find(s=>s.outlet===gi);return r}getResolvedTitleForRoute(e){return e.data[Km]}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(GX)},providedIn:"root"})}return t})(),GX=(()=>{class t extends mR{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(pO))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),HX=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(KX)},providedIn:"root"})}return t})();class jX{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}}let KX=(()=>{class t extends jX{static#t=this.\u0275fac=function(){let e;return function(i){return(e||(e=Mu(t)))(i||t)}}();static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();const Ev=new In("",{providedIn:"root",factory:()=>({})});let XX=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(ZX)},providedIn:"root"})}return t})(),ZX=(()=>{class t{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();var ag=function(t){return t[t.COMPLETE=0]="COMPLETE",t[t.FAILED=1]="FAILED",t[t.REDIRECTING=2]="REDIRECTING",t}(ag||{});function gR(t,n){t.events.pipe(Uh(e=>e instanceof Gh||e instanceof tg||e instanceof fv||e instanceof rp),Ue(e=>e instanceof Gh||e instanceof rp?ag.COMPLETE:e instanceof tg&&(0===e.code||1===e.code)?ag.REDIRECTING:ag.FAILED),Uh(e=>e!==ag.REDIRECTING),tp(1)).subscribe(()=>{n()})}function YX(t){throw t}function qX(t,n,e){return n.parse("/")}const QX={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},JX={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let ic=(()=>{class t{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){return"computed"!==this.canceledNavigationResolution?this.currentPageId:this.location.getState()?.\u0275routerPageId??this.currentPageId}get events(){return this._events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=Mn(KM),this.isNgZoneEnabled=!1,this._events=new ee,this.options=Mn(Ev,{optional:!0})||{},this.pendingTasks=Mn(XM),this.errorHandler=this.options.errorHandler||YX,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||qX,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=Mn(XX),this.routeReuseStrategy=Mn(HX),this.titleStrategy=Mn(mR),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=Mn(lp,{optional:!0})?.flat()??[],this.navigationTransitions=Mn(xv),this.urlSerializer=Mn(Zm),this.location=Mn(pC),this.componentInputBindingEnabled=!!Mn(mv,{optional:!0}),this.eventsSubscription=new R,this.isNgZoneEnabled=Mn(Ro)instanceof Ro&&Ro.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new np,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=KO(0,null),this.navigationTransitions.setupNavigations(this,this.currentUrlTree,this.routerState).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)}),this.subscribeToNavigationEvents()}subscribeToNavigationEvents(){const e=this.navigationTransitions.events.subscribe(r=>{try{const{currentTransition:i}=this.navigationTransitions;if(null===i)return void(yR(r)&&this._events.next(r));if(r instanceof dv)pR(i.source)&&(this.browserUrlTree=i.extractedUrl);else if(r instanceof rp)this.rawUrlTree=i.rawUrl;else if(r instanceof WO){if("eager"===this.urlUpdateStrategy){if(!i.extras.skipLocationChange){const s=this.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl);this.setBrowserUrl(s,i)}this.browserUrlTree=i.urlAfterRedirects}}else if(r instanceof YC)this.currentUrlTree=i.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl),this.routerState=i.targetRouterState,"deferred"===this.urlUpdateStrategy&&(i.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,i),this.browserUrlTree=i.urlAfterRedirects);else if(r instanceof tg)0!==r.code&&1!==r.code&&(this.navigated=!0),(3===r.code||2===r.code)&&this.restoreHistory(i);else if(r instanceof qC){const s=this.urlHandlingStrategy.merge(r.url,i.currentRawUrl),o={skipLocationChange:i.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||pR(i.source)};this.scheduleNavigation(s,Jm,null,o,{resolve:i.resolve,reject:i.reject,promise:i.promise})}r instanceof fv&&this.restoreHistory(i,!0),r instanceof Gh&&(this.navigated=!0),yR(r)&&this._events.next(r)}catch(i){this.navigationTransitions.transitionAbortSubject.next(i)}});this.eventsSubscription.add(e)}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),Jm,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,r,e.state)},0)}))}navigateToSyncWithBrowser(e,r,i){const s={replaceUrl:!0},o=i?.navigationId?i:null;if(i){const u={...i};delete u.navigationId,delete u.\u0275routerPageId,0!==Object.keys(u).length&&(s.state=u)}const a=this.parseUrl(e);this.scheduleNavigation(a,r,o,s)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(e){this.config=e.map(iw),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(e,r={}){const{relativeTo:i,queryParams:s,fragment:o,queryParamsHandling:a,preserveFragment:u}=r,c=u?this.currentUrlTree.fragment:o;let p,d=null;switch(a){case"merge":d={...this.currentUrlTree.queryParams,...s};break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=s||null}null!==d&&(d=this.removeEmptyProps(d));try{p=kO(i?i.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof e[0]||!e[0].startsWith("/"))&&(e=[]),p=this.currentUrlTree.root}return FO(p,e,d,c??null)}navigateByUrl(e,r={skipLocationChange:!1}){const i=Od(e)?e:this.parseUrl(e),s=this.urlHandlingStrategy.merge(i,this.rawUrlTree);return this.scheduleNavigation(s,Jm,null,r)}navigate(e,r={skipLocationChange:!1}){return function tZ(t){for(let n=0;n<t.length;n++)if(null==t[n])throw new We(4008,!1)}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(i){r=this.malformedUriErrorHandler(i,this.urlSerializer,e)}return r}isActive(e,r){let i;if(i=!0===r?{...QX}:!1===r?{...JX}:r,Od(e))return DO(this.currentUrlTree,e,i);const s=this.parseUrl(e);return DO(this.currentUrlTree,s,i)}removeEmptyProps(e){return Object.keys(e).reduce((r,i)=>{const s=e[i];return null!=s&&(r[i]=s),r},{})}scheduleNavigation(e,r,i,s,o){if(this.disposed)return Promise.resolve(!1);let a,u,c;o?(a=o.resolve,u=o.reject,c=o.promise):c=new Promise((p,v)=>{a=p,u=v});const d=this.pendingTasks.add();return gR(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(d))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:i,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,currentBrowserUrl:this.browserUrlTree,rawUrl:e,extras:s,resolve:a,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(p=>Promise.reject(p))}setBrowserUrl(e,r){const i=this.urlSerializer.serialize(e);if(this.location.isCurrentPathEqualTo(i)||r.extras.replaceUrl){const o={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(i,"",o)}else{const s={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId+1)};this.location.go(i,"",s)}}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-this.browserPageId;0!==s?this.location.historyGo(s):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function yR(t){return!(t instanceof YC||t instanceof qC)}class vR{}let rZ=(()=>{class t{constructor(e,r,i,s,o){this.router=e,this.injector=i,this.preloadingStrategy=s,this.loader=o}setUpPreloading(){this.subscription=this.router.events.pipe(Uh(e=>e instanceof Gh),jm(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const i=[];for(const s of r){s.providers&&!s._injector&&(s._injector=LE(s.providers,e,`Route: ${s.path}`));const o=s._injector??e,a=s._loadedInjector??o;(s.loadChildren&&!s._loadedRoutes&&void 0===s.canLoad||s.loadComponent&&!s._loadedComponent)&&i.push(this.preloadConfig(o,s)),(s.children||s._loadedRoutes)&&i.push(this.processRoutes(a,s.children??s._loadedRoutes))}return ss(i).pipe(ti())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let i;i=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):qn(null);const s=i.pipe(Ss(o=>null===o?qn(void 0):(r._loadedRoutes=o.routes,r._loadedInjector=o.injector,this.processRoutes(o.injector??e,o.routes))));return r.loadComponent&&!r._loadedComponent?ss([s,this.loader.loadComponent(r)]).pipe(ti()):s})}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(ic),Wn(ZM),Wn(Ql),Wn(vR),Wn(uw))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();const cw=new In("");let _R=(()=>{class t{constructor(e,r,i,s,o={}){this.urlSerializer=e,this.transitions=r,this.viewportScroller=i,this.zone=s,this.options=o,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},o.scrollPositionRestoration=o.scrollPositionRestoration||"disabled",o.anchorScrolling=o.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof dv?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Gh?(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment)):e instanceof rp&&0===e.code&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof GO&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new GO(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}static#t=this.\u0275fac=function(r){!function VT(){throw new Error("invalid")}()};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();function xh(t,n){return{\u0275kind:t,\u0275providers:n}}function ER(){const t=Mn(Pl);return n=>{const e=t.get(qf);if(n!==e.components[0])return;const r=t.get(ic),i=t.get(CR);1===t.get(hw)&&r.initialNavigation(),t.get(wR,null,xr.Optional)?.setUpPreloading(),t.get(cw,null,xr.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),i.closed||(i.next(),i.complete(),i.unsubscribe())}}const CR=new In("",{factory:()=>new ee}),hw=new In("",{providedIn:"root",factory:()=>1}),wR=new In("");function aZ(t){return xh(0,[{provide:wR,useExisting:rZ},{provide:vR,useExisting:t}])}const bR=new In("ROUTER_FORROOT_GUARD"),lZ=[pC,{provide:Zm,useClass:HC},ic,eg,{provide:sp,useFactory:function xR(t){return t.routerState.root},deps:[ic]},uw,[]];function cZ(){return new nP("Router",ic)}let IR=(()=>{class t{constructor(e){}static forRoot(e,r){return{ngModule:t,providers:[lZ,[],{provide:lp,multi:!0,useValue:e},{provide:bR,useFactory:pZ,deps:[[ic,new By,new zy]]},{provide:Ev,useValue:r||{}},r?.useHash?{provide:Nd,useClass:yj}:{provide:Nd,useClass:PP},{provide:cw,useFactory:()=>{const t=Mn($K),n=Mn(Ro),e=Mn(Ev),r=Mn(xv),i=Mn(Zm);return e.scrollOffset&&t.setOffset(e.scrollOffset),new _R(i,r,t,n,e)}},r?.preloadingStrategy?aZ(r.preloadingStrategy).\u0275providers:[],{provide:nP,multi:!0,useFactory:cZ},r?.initialNavigation?mZ(r):[],r?.bindToComponentInputs?xh(8,[QO,{provide:mv,useExisting:QO}]).\u0275providers:[],[{provide:SR,useFactory:ER},{provide:iC,multi:!0,useExisting:SR}]]}}static forChild(e){return{ngModule:t,providers:[{provide:lp,multi:!0,useValue:e}]}}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(bR,8))};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({})}return t})();function pZ(t){return"guarded"}function mZ(t){return["disabled"===t.initialNavigation?xh(3,[{provide:YE,multi:!0,useFactory:()=>{const n=Mn(ic);return()=>{n.setUpLocationChangeListener()}}},{provide:hw,useValue:2}]).\u0275providers:[],"enabledBlocking"===t.initialNavigation?xh(2,[{provide:hw,useValue:0},{provide:YE,multi:!0,deps:[Pl],useFactory:n=>{const e=n.get(mj,Promise.resolve());return()=>e.then(()=>new Promise(r=>{const i=n.get(ic),s=n.get(CR);gR(i,()=>{r(!0)}),n.get(xv).afterPreactivation=()=>(r(!0),s.closed?qn(void 0):s),i.initialNavigation()}))}}]).\u0275providers:[]]}const SR=new In(""),yZ=[];let vZ=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({imports:[IR.forRoot(yZ),IR]})}return t})();var El=y(8433),Wu=(y(3727),6371008.8),DR={centimeters:100*Wu,centimetres:100*Wu,degrees:Wu/111325,feet:3.28084*Wu,inches:39.37*Wu,kilometers:Wu/1e3,kilometres:Wu/1e3,meters:Wu,metres:Wu,miles:Wu/1609.344,millimeters:1e3*Wu,millimetres:1e3*Wu,nauticalmiles:Wu/1852,radians:1,yards:1.0936*Wu};function Hc(t,n,e){void 0===e&&(e={});var r={type:"Feature"};return(0===e.id||e.id)&&(r.id=e.id),e.bbox&&(r.bbox=e.bbox),r.properties=n||{},r.geometry=t,r}function cp(t,n,e){if(void 0===e&&(e={}),!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!fw(t[0])||!fw(t[1]))throw new Error("coordinates must contain numbers");return Hc({type:"Point",coordinates:t},n,e)}function ug(t,n,e){void 0===e&&(e={});for(var r=0,i=t;r<i.length;r++){var s=i[r];if(s.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var o=0;o<s[s.length-1].length;o++)if(s[s.length-1][o]!==s[0][o])throw new Error("First and last Position are not equivalent.")}return Hc({type:"Polygon",coordinates:t},n,e)}function Cv(t,n,e){if(void 0===e&&(e={}),t.length<2)throw new Error("coordinates must be an array of two or more positions");return Hc({type:"LineString",coordinates:t},n,e)}function hp(t,n){void 0===n&&(n={});var e={type:"FeatureCollection"};return n.id&&(e.id=n.id),n.bbox&&(e.bbox=n.bbox),e.features=t,e}function fw(t){return!isNaN(t)&&null!==t&&!Array.isArray(t)}function lg(t,n,e){if(null!==t)for(var r,i,s,o,a,u,c,v,d=0,p=0,x=t.type,w="FeatureCollection"===x,b="Feature"===x,T=w?t.features.length:1,N=0;N<T;N++){a=(v=!!(c=w?t.features[N].geometry:b?t.geometry:t)&&"GeometryCollection"===c.type)?c.geometries.length:1;for(var S=0;S<a;S++){var U=0,J=0;if(null!==(o=v?c.geometries[S]:c)){u=o.coordinates;var ht=o.type;switch(d=!e||"Polygon"!==ht&&"MultiPolygon"!==ht?0:1,ht){case null:break;case"Point":if(!1===n(u,p,N,U,J))return!1;p++,U++;break;case"LineString":case"MultiPoint":for(r=0;r<u.length;r++){if(!1===n(u[r],p,N,U,J))return!1;p++,"MultiPoint"===ht&&U++}"LineString"===ht&&U++;break;case"Polygon":case"MultiLineString":for(r=0;r<u.length;r++){for(i=0;i<u[r].length-d;i++){if(!1===n(u[r][i],p,N,U,J))return!1;p++}"MultiLineString"===ht&&U++,"Polygon"===ht&&J++}"Polygon"===ht&&U++;break;case"MultiPolygon":for(r=0;r<u.length;r++){for(J=0,i=0;i<u[r].length;i++){for(s=0;s<u[r][i].length-d;s++){if(!1===n(u[r][i][s],p,N,U,J))return!1;p++}J++}U++}break;case"GeometryCollection":for(r=0;r<o.geometries.length;r++)if(!1===lg(o.geometries[r],n,e))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function pw(t,n){if("Feature"===t.type)n(t,0);else if("FeatureCollection"===t.type)for(var e=0;e<t.features.length&&!1!==n(t.features[e],e);e++);}function wv(t,n){var e,r,i,s,o,a,u,c,d,p,v=0,x="FeatureCollection"===t.type,w="Feature"===t.type,b=x?t.features.length:1;for(e=0;e<b;e++){for(c=x?t.features[e].properties:w?t.properties:{},d=x?t.features[e].bbox:w?t.bbox:void 0,p=x?t.features[e].id:w?t.id:void 0,o=(u=!!(a=x?t.features[e].geometry:w?t.geometry:t)&&"GeometryCollection"===a.type)?a.geometries.length:1,i=0;i<o;i++)if(null!==(s=u?a.geometries[i]:a))switch(s.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===n(s,v,c,d,p))return!1;break;case"GeometryCollection":for(r=0;r<s.geometries.length;r++)if(!1===n(s.geometries[r],v,c,d,p))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===n(null,v,c,d,p))return!1;v++}}function mw(t){var n=[1/0,1/0,-1/0,-1/0];return lg(t,function(e){n[0]>e[0]&&(n[0]=e[0]),n[1]>e[1]&&(n[1]=e[1]),n[2]<e[0]&&(n[2]=e[0]),n[3]<e[1]&&(n[3]=e[1])}),n}mw.default=mw;const MR=mw;function yw(t,n,e){if(void 0===e&&(e={}),!t)throw new Error("point is required");if(!n)throw new Error("polygon is required");var r=function DZ(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if("Feature"===t.type&&null!==t.geometry&&"Point"===t.geometry.type)return t.geometry.coordinates;if("Point"===t.type)return t.coordinates}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return t;throw new Error("coord must be GeoJSON Point or an Array of numbers")}(t),i=function AZ(t){return"Feature"===t.type?t.geometry:t}(n),s=i.type,o=n.bbox,a=i.coordinates;if(o&&!1===function zZ(t,n){return n[0]<=t[0]&&n[1]<=t[1]&&n[2]>=t[0]&&n[3]>=t[1]}(r,o))return!1;"Polygon"===s&&(a=[a]);for(var u=!1,c=0;c<a.length&&!u;c++)if(LR(r,a[c][0],e.ignoreBoundary)){for(var d=!1,p=1;p<a[c].length&&!d;)LR(r,a[c][p],!e.ignoreBoundary)&&(d=!0),p++;d||(u=!0)}return u}function LR(t,n,e){var r=!1;n[0][0]===n[n.length-1][0]&&n[0][1]===n[n.length-1][1]&&(n=n.slice(0,n.length-1));for(var i=0,s=n.length-1;i<n.length;s=i++){var o=n[i][0],a=n[i][1],u=n[s][0],c=n[s][1];if(t[1]*(o-u)+a*(u-t[0])+c*(t[0]-o)==0&&(o-t[0])*(u-t[0])<=0&&(a-t[1])*(c-t[1])<=0)return!e;a>t[1]!=c>t[1]&&t[0]<(u-o)*(t[1]-a)/(c-a)+o&&(r=!r)}return r}y(4772),y(3664);var FR=new ArrayBuffer(16);new Float64Array(FR),new Uint32Array(FR),y(7861),function(){function t(n){this.points=n.points||[],this.duration=n.duration||1e4,this.sharpness=n.sharpness||.85,this.centers=[],this.controls=[],this.stepLength=n.stepLength||60,this.length=this.points.length,this.delay=0;for(var e=0;e<this.length;e++)this.points[e].z=this.points[e].z||0;for(e=0;e<this.length-1;e++){var r=this.points[e],i=this.points[e+1];this.centers.push({x:(r.x+i.x)/2,y:(r.y+i.y)/2,z:(r.z+i.z)/2})}for(this.controls.push([this.points[0],this.points[0]]),e=0;e<this.centers.length-1;e++){var s=this.points[e+1].x-(this.centers[e].x+this.centers[e+1].x)/2,o=this.points[e+1].y-(this.centers[e].y+this.centers[e+1].y)/2,a=this.points[e+1].z-(this.centers[e].y+this.centers[e+1].z)/2;this.controls.push([{x:(1-this.sharpness)*this.points[e+1].x+this.sharpness*(this.centers[e].x+s),y:(1-this.sharpness)*this.points[e+1].y+this.sharpness*(this.centers[e].y+o),z:(1-this.sharpness)*this.points[e+1].z+this.sharpness*(this.centers[e].z+a)},{x:(1-this.sharpness)*this.points[e+1].x+this.sharpness*(this.centers[e+1].x+s),y:(1-this.sharpness)*this.points[e+1].y+this.sharpness*(this.centers[e+1].y+o),z:(1-this.sharpness)*this.points[e+1].z+this.sharpness*(this.centers[e+1].z+a)}])}return this.controls.push([this.points[this.length-1],this.points[this.length-1]]),this.steps=this.cacheSteps(this.stepLength),this}t.prototype.cacheSteps=function(n){var e=[],r=this.pos(0);e.push(0);for(var i=0;i<this.duration;i+=10){var s=this.pos(i);Math.sqrt((s.x-r.x)*(s.x-r.x)+(s.y-r.y)*(s.y-r.y)+(s.z-r.z)*(s.z-r.z))>n&&(e.push(i),r=s)}return e},t.prototype.vector=function(n){var e=this.pos(n+10),r=this.pos(n-10);return{angle:180*Math.atan2(e.y-r.y,e.x-r.x)/3.14,speed:Math.sqrt((r.x-e.x)*(r.x-e.x)+(r.y-e.y)*(r.y-e.y)+(r.z-e.z)*(r.z-e.z))}},t.prototype.pos=function(n){var e=n-this.delay;e<0&&(e=0),e>this.duration&&(e=this.duration-1);var r=e/this.duration;if(r>=1)return this.points[this.length-1];var i=Math.floor((this.points.length-1)*r);return function nY(t,n,e,r,i){var s=function rY(t){var n=t*t;return[n*t,3*n*(1-t),3*t*(1-t)*(1-t),(1-t)*(1-t)*(1-t)]}(t);return{x:i.x*s[0]+r.x*s[1]+e.x*s[2]+n.x*s[3],y:i.y*s[0]+r.y*s[1]+e.y*s[2]+n.y*s[3],z:i.z*s[0]+r.z*s[1]+e.z*s[2]+n.z*s[3]}}((this.length-1)*r-i,this.points[i],this.controls[i][1],this.controls[i+1][0],this.points[i+1])}}();y(9145),y(5665);var KR=6378137;function ww(t){return function bZ(t,n,e){var r=e;return wv(t,function(i,s,o,a,u){r=0===s&&void 0===e?i:n(r,i,s,o,a,u)}),r}(t,function(n,e){return n+function CY(t){var e,n=0;switch(t.type){case"Polygon":return XR(t.coordinates);case"MultiPolygon":for(e=0;e<t.coordinates.length;e++)n+=XR(t.coordinates[e]);return n;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0}return 0}(e)},0)}function XR(t){var n=0;if(t&&t.length>0){n+=Math.abs(ZR(t[0]));for(var e=1;e<t.length;e++)n-=Math.abs(ZR(t[e]))}return n}function ZR(t){var n,e,i,s,o,a,u=0,c=t.length;if(c>2){for(a=0;a<c;a++)a===c-2?(i=c-2,s=c-1,o=0):a===c-1?(i=c-1,s=0,o=1):(i=a,s=a+1,o=a+2),n=t[i],e=t[s],u+=(bw(t[o][0])-bw(n[0]))*Math.sin(bw(e[1]));u=u*KR*KR/2}return u}function bw(t){return t*Math.PI/180}var t2=Math.PI/180,e2=180/Math.PI,dg=function(t,n){this.lon=t,this.lat=n,this.x=t2*t,this.y=t2*n};dg.prototype.view=function(){return String(this.lon).slice(0,4)+","+String(this.lat).slice(0,4)},dg.prototype.antipode=function(){return new dg(this.lon<0?180+this.lon:-1*(180-this.lon),-1*this.lat)};var n2=function(){this.coords=[],this.length=0};n2.prototype.move_to=function(t){this.length++,this.coords.push(t)};var Iw=function(t){this.properties=t||{},this.geometries=[]};Iw.prototype.json=function(){if(this.geometries.length<=0)return{geometry:{type:"LineString",coordinates:null},type:"Feature",properties:this.properties};if(1===this.geometries.length)return{geometry:{type:"LineString",coordinates:this.geometries[0].coords},type:"Feature",properties:this.properties};for(var t=[],n=0;n<this.geometries.length;n++)t.push(this.geometries[n].coords);return{geometry:{type:"MultiLineString",coordinates:t},type:"Feature",properties:this.properties}},Iw.prototype.wkt=function(){for(var t="",n="LINESTRING(",e=function(s){n+=s[0]+" "+s[1]+","},r=0;r<this.geometries.length;r++){if(0===this.geometries[r].coords.length)return"LINESTRING(empty)";this.geometries[r].coords.forEach(e),t+=n.substring(0,n.length-1)+")"}return t};var Sw=function(t,n,e){if(!t||void 0===t.x||void 0===t.y)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");if(!n||void 0===n.x||void 0===n.y)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");this.start=new dg(t.x,t.y),this.end=new dg(n.x,n.y),this.properties=e||{};var r=this.start.x-this.end.x,s=Math.pow(Math.sin((this.start.y-this.end.y)/2),2)+Math.cos(this.start.y)*Math.cos(this.end.y)*Math.pow(Math.sin(r/2),2);if(this.g=2*Math.asin(Math.sqrt(s)),this.g===Math.PI)throw new Error("it appears "+t.view()+" and "+n.view()+" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");if(isNaN(this.g))throw new Error("could not calculate great circle between "+t+" and "+n)};Sw.prototype.interpolate=function(t){var n=Math.sin((1-t)*this.g)/Math.sin(this.g),e=Math.sin(t*this.g)/Math.sin(this.g),r=n*Math.cos(this.start.y)*Math.cos(this.start.x)+e*Math.cos(this.end.y)*Math.cos(this.end.x),i=n*Math.cos(this.start.y)*Math.sin(this.start.x)+e*Math.cos(this.end.y)*Math.sin(this.end.x),s=n*Math.sin(this.start.y)+e*Math.sin(this.end.y),o=e2*Math.atan2(s,Math.sqrt(Math.pow(r,2)+Math.pow(i,2)));return[e2*Math.atan2(i,r),o]},Sw.prototype.Arc=function(t,n){var e=[];if(!t||t<=2)e.push([this.start.lon,this.start.lat]),e.push([this.end.lon,this.end.lat]);else for(var r=1/(t-1),i=0;i<t;++i){var o=this.interpolate(r*i);e.push(o)}for(var a=!1,u=0,c=n&&n.offset?n.offset:10,d=180-c,p=-180+c,v=360-c,x=1;x<e.length;++x){var w=e[x-1][0],b=e[x][0],T=Math.abs(b-w);T>v&&(b>d&&w<p||w>d&&b<p)?a=!0:T>u&&(u=T)}var N=[];if(a&&u<c){var S=[];N.push(S);for(var U=0;U<e.length;++U){var J=parseFloat(e[U][0]);if(U>0&&Math.abs(J-e[U-1][0])>v){var ht=parseFloat(e[U-1][0]),Tt=parseFloat(e[U-1][1]),Pt=parseFloat(e[U][0]),zt=parseFloat(e[U][1]);if(ht>-180&&ht<p&&180===Pt&&U+1<e.length&&e[U-1][0]>-180&&e[U-1][0]<p){S.push([-180,e[U][1]]),U++,S.push([e[U][0],e[U][1]]);continue}if(ht>d&&ht<180&&-180===Pt&&U+1<e.length&&e[U-1][0]>d&&e[U-1][0]<180){S.push([180,e[U][1]]),U++,S.push([e[U][0],e[U][1]]);continue}if(ht<p&&Pt>d){var Ot=ht;ht=Pt,Pt=Ot;var le=Tt;Tt=zt,zt=le}if(ht>d&&Pt<p&&(Pt+=360),ht<=180&&Pt>=180&&ht<Pt){var ge=(180-ht)/(Pt-ht),Ae=ge*zt+(1-ge)*Tt;S.push([e[U-1][0]>d?180:-180,Ae]),(S=[]).push([e[U-1][0]>d?-180:180,Ae]),N.push(S)}else N.push(S=[]);S.push([J,e[U][1]])}else S.push([e[U][0],e[U][1]])}}else{var Re=[];N.push(Re);for(var ve=0;ve<e.length;++ve)Re.push([e[ve][0],e[ve][1]])}for(var Ne=new Iw(this.properties),Se=0;Se<N.length;++Se){var Ke=new n2;Ne.geometries.push(Ke);for(var Le=N[Se],Be=0;Be<Le.length;++Be)Ke.move_to(Le[Be])}return Ne},y(3970);var bi=[],Ii=[],Si=[],Di=[],Ti=[],Ni=[],Ai=[],Mi=[],Pi=[],Oi=[],Ri=[],Li=[],ki=[],Fi=[],$i=[],Bi=[],zi=[],Vi=[],Ui=[],Wi=[],Gi=[],Hi=[],ji=[],Ki=[];Ai[85]=Oi[85]=-1,Mi[85]=Ri[85]=0,Pi[85]=Li[85]=1,Ui[85]=Hi[85]=1,Wi[85]=ji[85]=0,Gi[85]=Ki[85]=1,bi[85]=Di[85]=0,Ii[85]=Ti[85]=-1,Si[85]=$i[85]=0,Bi[85]=ki[85]=0,zi[85]=Fi[85]=1,Ni[85]=Vi[85]=1,Hi[1]=Hi[169]=0,ji[1]=ji[169]=-1,Ki[1]=Ki[169]=0,ki[1]=ki[169]=-1,Fi[1]=Fi[169]=0,$i[1]=$i[169]=0,Oi[4]=Oi[166]=0,Ri[4]=Ri[166]=-1,Li[4]=Li[166]=1,Bi[4]=Bi[166]=1,zi[4]=zi[166]=0,Vi[4]=Vi[166]=0,Ai[16]=Ai[154]=0,Mi[16]=Mi[154]=1,Pi[16]=Pi[154]=1,Di[16]=Di[154]=1,Ti[16]=Ti[154]=0,Ni[16]=Ni[154]=1,Ui[64]=Ui[106]=0,Wi[64]=Wi[106]=1,Gi[64]=Gi[106]=0,bi[64]=bi[106]=-1,Ii[64]=Ii[106]=0,Si[64]=Si[106]=1,Ui[2]=Ui[168]=0,Wi[2]=Wi[168]=-1,Gi[2]=Gi[168]=1,Hi[2]=Hi[168]=0,ji[2]=ji[168]=-1,Ki[2]=Ki[168]=0,ki[2]=ki[168]=-1,Fi[2]=Fi[168]=0,$i[2]=$i[168]=0,Bi[2]=Bi[168]=-1,zi[2]=zi[168]=0,Vi[2]=Vi[168]=1,Ai[8]=Ai[162]=0,Mi[8]=Mi[162]=-1,Pi[8]=Pi[162]=0,Oi[8]=Oi[162]=0,Ri[8]=Ri[162]=-1,Li[8]=Li[162]=1,ki[8]=ki[162]=1,Fi[8]=Fi[162]=0,$i[8]=$i[162]=1,Bi[8]=Bi[162]=1,zi[8]=zi[162]=0,Vi[8]=Vi[162]=0,Ai[32]=Ai[138]=0,Mi[32]=Mi[138]=1,Pi[32]=Pi[138]=1,Oi[32]=Oi[138]=0,Ri[32]=Ri[138]=1,Li[32]=Li[138]=0,bi[32]=bi[138]=1,Ii[32]=Ii[138]=0,Si[32]=Si[138]=0,Di[32]=Di[138]=1,Ti[32]=Ti[138]=0,Ni[32]=Ni[138]=1,Hi[128]=Hi[42]=0,ji[128]=ji[42]=1,Ki[128]=Ki[42]=1,Ui[128]=Ui[42]=0,Wi[128]=Wi[42]=1,Gi[128]=Gi[42]=0,bi[128]=bi[42]=-1,Ii[128]=Ii[42]=0,Si[128]=Si[42]=1,Di[128]=Di[42]=-1,Ti[128]=Ti[42]=0,Ni[128]=Ni[42]=0,Oi[5]=Oi[165]=-1,Ri[5]=Ri[165]=0,Li[5]=Li[165]=0,Hi[5]=Hi[165]=1,ji[5]=ji[165]=0,Ki[5]=Ki[165]=0,Bi[20]=Bi[150]=0,zi[20]=zi[150]=1,Vi[20]=Vi[150]=1,Di[20]=Di[150]=0,Ti[20]=Ti[150]=-1,Ni[20]=Ni[150]=1,Ai[80]=Ai[90]=-1,Mi[80]=Mi[90]=0,Pi[80]=Pi[90]=1,Ui[80]=Ui[90]=1,Wi[80]=Wi[90]=0,Gi[80]=Gi[90]=1,ki[65]=ki[105]=0,Fi[65]=Fi[105]=1,$i[65]=$i[105]=0,bi[65]=bi[105]=0,Ii[65]=Ii[105]=-1,Si[65]=Si[105]=0,Ai[160]=Ai[10]=-1,Mi[160]=Mi[10]=0,Pi[160]=Pi[10]=1,Oi[160]=Oi[10]=-1,Ri[160]=Ri[10]=0,Li[160]=Li[10]=0,Hi[160]=Hi[10]=1,ji[160]=ji[10]=0,Ki[160]=Ki[10]=0,Ui[160]=Ui[10]=1,Wi[160]=Wi[10]=0,Gi[160]=Gi[10]=1,Bi[130]=Bi[40]=0,zi[130]=zi[40]=1,Vi[130]=Vi[40]=1,ki[130]=ki[40]=0,Fi[130]=Fi[40]=1,$i[130]=$i[40]=0,bi[130]=bi[40]=0,Ii[130]=Ii[40]=-1,Si[130]=Si[40]=0,Di[130]=Di[40]=0,Ti[130]=Ti[40]=-1,Ni[130]=Ni[40]=1,Oi[37]=Oi[133]=0,Ri[37]=Ri[133]=1,Li[37]=Li[133]=1,Hi[37]=Hi[133]=0,ji[37]=ji[133]=1,Ki[37]=Ki[133]=0,bi[37]=bi[133]=-1,Ii[37]=Ii[133]=0,Si[37]=Si[133]=0,Di[37]=Di[133]=1,Ti[37]=Ti[133]=0,Ni[37]=Ni[133]=0,Bi[148]=Bi[22]=-1,zi[148]=zi[22]=0,Vi[148]=Vi[22]=0,Hi[148]=Hi[22]=0,ji[148]=ji[22]=-1,Ki[148]=Ki[22]=1,Ui[148]=Ui[22]=0,Wi[148]=Wi[22]=1,Gi[148]=Gi[22]=1,Di[148]=Di[22]=-1,Ti[148]=Ti[22]=0,Ni[148]=Ni[22]=1,Ai[82]=Ai[88]=0,Mi[82]=Mi[88]=-1,Pi[82]=Pi[88]=1,Bi[82]=Bi[88]=1,zi[82]=zi[88]=0,Vi[82]=Vi[88]=1,ki[82]=ki[88]=-1,Fi[82]=Fi[88]=0,$i[82]=$i[88]=1,Ui[82]=Ui[88]=0,Wi[82]=Wi[88]=-1,Gi[82]=Gi[88]=0,Ai[73]=Ai[97]=0,Mi[73]=Mi[97]=1,Pi[73]=Pi[97]=0,Oi[73]=Oi[97]=0,Ri[73]=Ri[97]=-1,Li[73]=Li[97]=0,ki[73]=ki[97]=1,Fi[73]=Fi[97]=0,$i[73]=$i[97]=0,bi[73]=bi[97]=1,Ii[73]=Ii[97]=0,Si[73]=Si[97]=1,Ai[145]=Ai[25]=0,Mi[145]=Mi[25]=-1,Pi[145]=Pi[25]=0,ki[145]=ki[25]=1,Fi[145]=Fi[25]=0,$i[145]=$i[25]=1,Hi[145]=Hi[25]=0,ji[145]=ji[25]=1,Ki[145]=Ki[25]=1,Di[145]=Di[25]=-1,Ti[145]=Ti[25]=0,Ni[145]=Ni[25]=0,Oi[70]=Oi[100]=0,Ri[70]=Ri[100]=1,Li[70]=Li[100]=0,Bi[70]=Bi[100]=-1,zi[70]=zi[100]=0,Vi[70]=Vi[100]=1,Ui[70]=Ui[100]=0,Wi[70]=Wi[100]=-1,Gi[70]=Gi[100]=1,bi[70]=bi[100]=1,Ii[70]=Ii[100]=0,Si[70]=Si[100]=0,Oi[101]=Oi[69]=0,Ri[101]=Ri[69]=1,Li[101]=Li[69]=0,bi[101]=bi[69]=1,Ii[101]=Ii[69]=0,Si[101]=Si[69]=0,Hi[149]=Hi[21]=0,ji[149]=ji[21]=1,Ki[149]=Ki[21]=1,Di[149]=Di[21]=-1,Ti[149]=Ti[21]=0,Ni[149]=Ni[21]=0,Bi[86]=Bi[84]=-1,zi[86]=zi[84]=0,Vi[86]=Vi[84]=1,Ui[86]=Ui[84]=0,Wi[86]=Wi[84]=-1,Gi[86]=Gi[84]=1,Ai[89]=Ai[81]=0,Mi[89]=Mi[81]=-1,Pi[89]=Pi[81]=0,ki[89]=ki[81]=1,Fi[89]=Fi[81]=0,$i[89]=$i[81]=1,Ai[96]=Ai[74]=0,Mi[96]=Mi[74]=1,Pi[96]=Pi[74]=0,Oi[96]=Oi[74]=-1,Ri[96]=Ri[74]=0,Li[96]=Li[74]=1,Ui[96]=Ui[74]=1,Wi[96]=Wi[74]=0,Gi[96]=Gi[74]=0,bi[96]=bi[74]=1,Ii[96]=Ii[74]=0,Si[96]=Si[74]=1,Ai[24]=Ai[146]=0,Mi[24]=Mi[146]=-1,Pi[24]=Pi[146]=1,Bi[24]=Bi[146]=1,zi[24]=zi[146]=0,Vi[24]=Vi[146]=1,ki[24]=ki[146]=0,Fi[24]=Fi[146]=1,$i[24]=$i[146]=1,Di[24]=Di[146]=0,Ti[24]=Ti[146]=-1,Ni[24]=Ni[146]=0,Oi[6]=Oi[164]=-1,Ri[6]=Ri[164]=0,Li[6]=Li[164]=1,Bi[6]=Bi[164]=-1,zi[6]=zi[164]=0,Vi[6]=Vi[164]=0,Hi[6]=Hi[164]=0,ji[6]=ji[164]=-1,Ki[6]=Ki[164]=1,Ui[6]=Ui[164]=1,Wi[6]=Wi[164]=0,Gi[6]=Gi[164]=0,ki[129]=ki[41]=0,Fi[129]=Fi[41]=1,$i[129]=$i[41]=1,Hi[129]=Hi[41]=0,ji[129]=ji[41]=1,Ki[129]=Ki[41]=0,bi[129]=bi[41]=-1,Ii[129]=Ii[41]=0,Si[129]=Si[41]=0,Di[129]=Di[41]=0,Ti[129]=Ti[41]=-1,Ni[129]=Ni[41]=0,Bi[66]=Bi[104]=0,zi[66]=zi[104]=1,Vi[66]=Vi[104]=0,ki[66]=ki[104]=-1,Fi[66]=Fi[104]=0,$i[66]=$i[104]=1,Ui[66]=Ui[104]=0,Wi[66]=Wi[104]=-1,Gi[66]=Gi[104]=0,bi[66]=bi[104]=0,Ii[66]=Ii[104]=-1,Si[66]=Si[104]=1,Ai[144]=Ai[26]=-1,Mi[144]=Mi[26]=0,Pi[144]=Pi[26]=0,Hi[144]=Hi[26]=1,ji[144]=ji[26]=0,Ki[144]=Ki[26]=1,Ui[144]=Ui[26]=0,Wi[144]=Wi[26]=1,Gi[144]=Gi[26]=1,Di[144]=Di[26]=-1,Ti[144]=Ti[26]=0,Ni[144]=Ni[26]=1,Oi[36]=Oi[134]=0,Ri[36]=Ri[134]=1,Li[36]=Li[134]=1,Bi[36]=Bi[134]=0,zi[36]=zi[134]=1,Vi[36]=Vi[134]=0,bi[36]=bi[134]=0,Ii[36]=Ii[134]=-1,Si[36]=Si[134]=1,Di[36]=Di[134]=1,Ti[36]=Ti[134]=0,Ni[36]=Ni[134]=0,Ai[9]=Ai[161]=-1,Mi[9]=Mi[161]=0,Pi[9]=Pi[161]=0,Oi[9]=Oi[161]=0,Ri[9]=Ri[161]=-1,Li[9]=Li[161]=0,ki[9]=ki[161]=1,Fi[9]=Fi[161]=0,$i[9]=$i[161]=0,Hi[9]=Hi[161]=1,ji[9]=ji[161]=0,Ki[9]=Ki[161]=1,Ai[136]=0,Mi[136]=1,Pi[136]=1,Oi[136]=0,Ri[136]=1,Li[136]=0,Bi[136]=-1,zi[136]=0,Vi[136]=1,ki[136]=-1,Fi[136]=0,$i[136]=0,Hi[136]=0,ji[136]=-1,Ki[136]=0,Ui[136]=0,Wi[136]=-1,Gi[136]=1,bi[136]=1,Ii[136]=0,Si[136]=0,Di[136]=1,Ti[136]=0,Ni[136]=1,Ai[34]=0,Mi[34]=-1,Pi[34]=0,Oi[34]=0,Ri[34]=-1,Li[34]=1,Bi[34]=1,zi[34]=0,Vi[34]=0,ki[34]=1,Fi[34]=0,$i[34]=1,Hi[34]=0,ji[34]=1,Ki[34]=1,Ui[34]=0,Wi[34]=1,Gi[34]=0,bi[34]=-1,Ii[34]=0,Si[34]=1,Di[34]=-1,Ti[34]=0,Ni[34]=0,Ai[35]=0,Mi[35]=1,Pi[35]=1,Oi[35]=0,Ri[35]=-1,Li[35]=1,Bi[35]=1,zi[35]=0,Vi[35]=0,ki[35]=-1,Fi[35]=0,$i[35]=0,Hi[35]=0,ji[35]=-1,Ki[35]=0,Ui[35]=0,Wi[35]=1,Gi[35]=0,bi[35]=-1,Ii[35]=0,Si[35]=1,Di[35]=1,Ti[35]=0,Ni[35]=1,Ai[153]=0,Mi[153]=1,Pi[153]=1,ki[153]=-1,Fi[153]=0,$i[153]=0,Hi[153]=0,ji[153]=-1,Ki[153]=0,Di[153]=1,Ti[153]=0,Ni[153]=1,Oi[102]=0,Ri[102]=-1,Li[102]=1,Bi[102]=1,zi[102]=0,Vi[102]=0,Ui[102]=0,Wi[102]=1,Gi[102]=0,bi[102]=-1,Ii[102]=0,Si[102]=1,Ai[155]=0,Mi[155]=-1,Pi[155]=0,ki[155]=1,Fi[155]=0,$i[155]=1,Hi[155]=0,ji[155]=1,Ki[155]=1,Di[155]=-1,Ti[155]=0,Ni[155]=0,Oi[103]=0,Ri[103]=1,Li[103]=0,Bi[103]=-1,zi[103]=0,Vi[103]=1,Ui[103]=0,Wi[103]=-1,Gi[103]=1,bi[103]=1,Ii[103]=0,Si[103]=0,Ai[152]=0,Mi[152]=1,Pi[152]=1,Bi[152]=-1,zi[152]=0,Vi[152]=1,ki[152]=-1,Fi[152]=0,$i[152]=0,Hi[152]=0,ji[152]=-1,Ki[152]=0,Ui[152]=0,Wi[152]=-1,Gi[152]=1,Di[152]=1,Ti[152]=0,Ni[152]=1,Ai[156]=0,Mi[156]=-1,Pi[156]=1,Bi[156]=1,zi[156]=0,Vi[156]=1,ki[156]=-1,Fi[156]=0,$i[156]=0,Hi[156]=0,ji[156]=-1,Ki[156]=0,Ui[156]=0,Wi[156]=1,Gi[156]=1,Di[156]=-1,Ti[156]=0,Ni[156]=1,Ai[137]=0,Mi[137]=1,Pi[137]=1,Oi[137]=0,Ri[137]=1,Li[137]=0,ki[137]=-1,Fi[137]=0,$i[137]=0,Hi[137]=0,ji[137]=-1,Ki[137]=0,bi[137]=1,Ii[137]=0,Si[137]=0,Di[137]=1,Ti[137]=0,Ni[137]=1,Ai[139]=0,Mi[139]=1,Pi[139]=1,Oi[139]=0,Ri[139]=-1,Li[139]=0,ki[139]=1,Fi[139]=0,$i[139]=0,Hi[139]=0,ji[139]=1,Ki[139]=0,bi[139]=-1,Ii[139]=0,Si[139]=0,Di[139]=1,Ti[139]=0,Ni[139]=1,Ai[98]=0,Mi[98]=-1,Pi[98]=0,Oi[98]=0,Ri[98]=-1,Li[98]=1,Bi[98]=1,zi[98]=0,Vi[98]=0,ki[98]=1,Fi[98]=0,$i[98]=1,Ui[98]=0,Wi[98]=1,Gi[98]=0,bi[98]=-1,Ii[98]=0,Si[98]=1,Ai[99]=0,Mi[99]=1,Pi[99]=0,Oi[99]=0,Ri[99]=-1,Li[99]=1,Bi[99]=1,zi[99]=0,Vi[99]=0,ki[99]=-1,Fi[99]=0,$i[99]=1,Ui[99]=0,Wi[99]=-1,Gi[99]=0,bi[99]=1,Ii[99]=0,Si[99]=1,Oi[38]=0,Ri[38]=-1,Li[38]=1,Bi[38]=1,zi[38]=0,Vi[38]=0,Hi[38]=0,ji[38]=1,Ki[38]=1,Ui[38]=0,Wi[38]=1,Gi[38]=0,bi[38]=-1,Ii[38]=0,Si[38]=1,Di[38]=-1,Ti[38]=0,Ni[38]=0,Oi[39]=0,Ri[39]=1,Li[39]=1,Bi[39]=-1,zi[39]=0,Vi[39]=0,Hi[39]=0,ji[39]=-1,Ki[39]=1,Ui[39]=0,Wi[39]=1,Gi[39]=0,bi[39]=-1,Ii[39]=0,Si[39]=1,Di[39]=1,Ti[39]=0,Ni[39]=0;var Aw=function(t){return[[t.bottomleft,0],[0,0],[0,t.leftbottom]]},Mw=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0]]},Pw=function(t){return[[t.topright,1],[1,1],[1,t.righttop]]},Ow=function(t){return[[0,t.lefttop],[0,1],[t.topleft,1]]},Rw=function(t){return[[t.bottomright,0],[t.bottomleft,0],[0,t.leftbottom],[0,t.lefttop]]},Lw=function(t){return[[t.bottomright,0],[t.bottomleft,0],[1,t.righttop],[1,t.rightbottom]]},kw=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.topleft,1],[t.topright,1]]},Fw=function(t){return[[0,t.leftbottom],[0,t.lefttop],[t.topleft,1],[t.topright,1]]},Zn=[],jn=[],gr=[],hr=[],Ar=[],Sr=[],Xi=[],ts=[];hr[1]=Ar[1]=18,hr[169]=Ar[169]=18,gr[4]=jn[4]=12,gr[166]=jn[166]=12,Zn[16]=ts[16]=4,Zn[154]=ts[154]=4,Sr[64]=Xi[64]=22,Sr[106]=Xi[106]=22,gr[2]=Sr[2]=17,hr[2]=Ar[2]=18,gr[168]=Sr[168]=17,hr[168]=Ar[168]=18,Zn[8]=hr[8]=9,jn[8]=gr[8]=12,Zn[162]=hr[162]=9,jn[162]=gr[162]=12,Zn[32]=ts[32]=4,jn[32]=Xi[32]=1,Zn[138]=ts[138]=4,jn[138]=Xi[138]=1,Ar[128]=ts[128]=21,Sr[128]=Xi[128]=22,Ar[42]=ts[42]=21,Sr[42]=Xi[42]=22,jn[5]=Ar[5]=14,jn[165]=Ar[165]=14,gr[20]=ts[20]=6,gr[150]=ts[150]=6,Zn[80]=Sr[80]=11,Zn[90]=Sr[90]=11,hr[65]=Xi[65]=3,hr[105]=Xi[105]=3,Zn[160]=Sr[160]=11,jn[160]=Ar[160]=14,Zn[10]=Sr[10]=11,jn[10]=Ar[10]=14,gr[130]=ts[130]=6,hr[130]=Xi[130]=3,gr[40]=ts[40]=6,hr[40]=Xi[40]=3,jn[101]=Xi[101]=1,jn[69]=Xi[69]=1,Ar[149]=ts[149]=21,Ar[21]=ts[21]=21,gr[86]=Sr[86]=17,gr[84]=Sr[84]=17,Zn[89]=hr[89]=9,Zn[81]=hr[81]=9,Zn[96]=Xi[96]=0,jn[96]=Sr[96]=15,Zn[74]=Xi[74]=0,jn[74]=Sr[74]=15,Zn[24]=gr[24]=8,hr[24]=ts[24]=7,Zn[146]=gr[146]=8,hr[146]=ts[146]=7,jn[6]=Sr[6]=15,gr[6]=Ar[6]=16,jn[164]=Sr[164]=15,gr[164]=Ar[164]=16,hr[129]=ts[129]=7,Ar[129]=Xi[129]=20,hr[41]=ts[41]=7,Ar[41]=Xi[41]=20,gr[66]=Xi[66]=2,hr[66]=Sr[66]=19,gr[104]=Xi[104]=2,hr[104]=Sr[104]=19,Zn[144]=Ar[144]=10,Sr[144]=ts[144]=23,Zn[26]=Ar[26]=10,Sr[26]=ts[26]=23,jn[36]=ts[36]=5,gr[36]=Xi[36]=2,jn[134]=ts[134]=5,gr[134]=Xi[134]=2,Zn[9]=Ar[9]=10,jn[9]=hr[9]=13,Zn[161]=Ar[161]=10,jn[161]=hr[161]=13,jn[37]=ts[37]=5,Ar[37]=Xi[37]=20,jn[133]=ts[133]=5,Ar[133]=Xi[133]=20,gr[148]=Ar[148]=16,Sr[148]=ts[148]=23,gr[22]=Ar[22]=16,Sr[22]=ts[22]=23,Zn[82]=gr[82]=8,hr[82]=Sr[82]=19,Zn[88]=gr[88]=8,hr[88]=Sr[88]=19,Zn[73]=Xi[73]=0,jn[73]=hr[73]=13,Zn[97]=Xi[97]=0,jn[97]=hr[97]=13,Zn[145]=hr[145]=9,Ar[145]=ts[145]=21,Zn[25]=hr[25]=9,Ar[25]=ts[25]=21,jn[70]=Xi[70]=1,gr[70]=Sr[70]=17,jn[100]=Xi[100]=1,gr[100]=Sr[100]=17,Zn[34]=hr[34]=9,jn[34]=gr[34]=12,Ar[34]=ts[34]=21,Sr[34]=Xi[34]=22,Zn[136]=ts[136]=4,jn[136]=Xi[136]=1,gr[136]=Sr[136]=17,hr[136]=Ar[136]=18,Zn[35]=ts[35]=4,jn[35]=gr[35]=12,hr[35]=Ar[35]=18,Sr[35]=Xi[35]=22,Zn[153]=ts[153]=4,hr[153]=Ar[153]=18,jn[102]=gr[102]=12,Sr[102]=Xi[102]=22,Zn[155]=hr[155]=9,Ar[155]=ts[155]=23,jn[103]=Xi[103]=1,gr[103]=Sr[103]=17,Zn[152]=ts[152]=4,gr[152]=Sr[152]=17,hr[152]=Ar[152]=18,Zn[156]=gr[156]=8,hr[156]=Ar[156]=18,Sr[156]=ts[156]=23,Zn[137]=ts[137]=4,jn[137]=Xi[137]=1,hr[137]=Ar[137]=18,Zn[139]=ts[139]=4,jn[139]=hr[139]=13,Ar[139]=Xi[139]=20,Zn[98]=hr[98]=9,jn[98]=gr[98]=12,Sr[98]=Xi[98]=22,Zn[99]=Xi[99]=0,jn[99]=gr[99]=12,hr[99]=Sr[99]=19,jn[38]=gr[38]=12,Ar[38]=ts[38]=21,Sr[38]=Xi[38]=22,jn[39]=ts[39]=5,gr[39]=Ar[39]=16,Sr[39]=Xi[39]=22;var Rn=[];function zw(t,n,e){return function Kq(t){return(t>0)-(t<0)||+t}((n[0]-t[0])*(e[1]-n[1])-(e[0]-n[0])*(n[1]-t[1]))}function v2(t,n){return n.geometry.coordinates[0].every(function(e){return yw(cp(e),t)})}Rn[1]=Rn[169]=Aw,Rn[4]=Rn[166]=Mw,Rn[16]=Rn[154]=Pw,Rn[64]=Rn[106]=Ow,Rn[168]=Rn[2]=Rw,Rn[162]=Rn[8]=Lw,Rn[138]=Rn[32]=kw,Rn[42]=Rn[128]=Fw,Rn[5]=Rn[165]=function(t){return[[0,0],[0,t.leftbottom],[1,t.rightbottom],[1,0]]},Rn[20]=Rn[150]=function(t){return[[1,0],[t.bottomright,0],[t.topright,1],[1,1]]},Rn[80]=Rn[90]=function(t){return[[1,1],[1,t.righttop],[0,t.lefttop],[0,1]]},Rn[65]=Rn[105]=function(t){return[[t.bottomleft,0],[0,0],[0,1],[t.topleft,1]]},Rn[160]=Rn[10]=function(t){return[[1,t.righttop],[1,t.rightbottom],[0,t.leftbottom],[0,t.lefttop]]},Rn[130]=Rn[40]=function(t){return[[t.topleft,1],[t.topright,1],[t.bottomright,0],[t.bottomleft,0]]},Rn[85]=function(){return[[0,0],[0,1],[1,1],[1,0]]},Rn[101]=Rn[69]=function(t){return[[1,t.rightbottom],[1,0],[0,0],[0,1],[t.topleft,1]]},Rn[149]=Rn[21]=function(t){return[[t.topright,1],[1,1],[1,0],[0,0],[0,t.leftbottom]]},Rn[86]=Rn[84]=function(t){return[[1,0],[t.bottomright,0],[0,t.lefttop],[0,1],[1,1]]},Rn[89]=Rn[81]=function(t){return[[1,1],[1,t.righttop],[t.bottomleft,0],[0,0],[0,1]]},Rn[96]=Rn[74]=function(t){return[[1,t.righttop],[1,t.rightbottom],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[24]=Rn[146]=function(t){return[[1,1],[1,t.righttop],[t.bottomright,0],[t.bottomleft,0],[t.topright,1]]},Rn[6]=Rn[164]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[0,t.leftbottom],[0,t.lefttop]]},Rn[129]=Rn[41]=function(t){return[[t.topright,1],[t.bottomleft,0],[0,0],[0,t.leftbottom],[t.topleft,1]]},Rn[66]=Rn[104]=function(t){return[[t.bottomright,0],[t.bottomleft,0],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[144]=Rn[26]=function(t){return[[1,1],[1,t.righttop],[0,t.leftbottom],[0,t.lefttop],[t.topright,1]]},Rn[36]=Rn[134]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[t.topleft,1],[t.topright,1]]},Rn[9]=Rn[161]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomleft,0],[0,0],[0,t.leftbottom]]},Rn[37]=Rn[133]=function(t){return[[1,t.rightbottom],[1,0],[0,0],[0,t.leftbottom],[t.topleft,1],[t.topright,1]]},Rn[148]=Rn[22]=function(t){return[[1,1],[1,0],[t.bottomright,0],[0,t.leftbottom],[0,t.lefttop],[t.topright,1]]},Rn[82]=Rn[88]=function(t){return[[1,1],[1,t.righttop],[t.bottomright,0],[t.bottomleft,0],[0,t.lefttop],[0,1]]},Rn[73]=Rn[97]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomleft,0],[0,0],[0,1],[t.topleft,1]]},Rn[145]=Rn[25]=function(t){return[[1,1],[1,t.righttop],[t.bottomleft,0],[0,0],[0,t.leftbottom],[t.topright,1]]},Rn[70]=Rn[100]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[34]=function(t){return[Fw(t),Lw(t)]},Rn[35]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomright,0],[t.bottomleft,0],[0,t.leftbottom],[0,t.lefttop],[t.topleft,1],[t.topright,1]]},Rn[136]=function(t){return[kw(t),Rw(t)]},Rn[153]=function(t){return[Pw(t),Aw(t)]},Rn[102]=function(t){return[Mw(t),Ow(t)]},Rn[155]=function(t){return[[1,1],[1,t.righttop],[t.bottomleft,0],[0,0],[0,t.leftbottom],[t.topright,1]]},Rn[103]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[152]=function(t){return[Pw(t),Rw(t)]},Rn[156]=function(t){return[[1,1],[1,t.righttop],[t.bottomright,0],[t.bottomleft,0],[0,t.leftbottom],[0,t.lefttop],[t.topright,1]]},Rn[137]=function(t){return[kw(t),Aw(t)]},Rn[139]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomleft,0],[0,0],[0,t.leftbottom],[t.topleft,1],[t.topright,1]]},Rn[98]=function(t){return[Lw(t),Ow(t)]},Rn[99]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomright,0],[t.bottomleft,0],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[38]=function(t){return[Mw(t),Fw(t)]},Rn[39]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[0,t.leftbottom],[0,t.lefttop],[t.topleft,1],[t.topright,1]]};const _2=function(){function t(n){this.id=t.buildId(n),this.coordinates=n,this.innerEdges=[],this.outerEdges=[],this.outerEdgesSorted=!1}return t.buildId=function(n){return n.join(",")},t.prototype.removeInnerEdge=function(n){this.innerEdges=this.innerEdges.filter(function(e){return e.from.id!==n.from.id})},t.prototype.removeOuterEdge=function(n){this.outerEdges=this.outerEdges.filter(function(e){return e.to.id!==n.to.id})},t.prototype.addOuterEdge=function(n){this.outerEdges.push(n),this.outerEdgesSorted=!1},t.prototype.sortOuterEdges=function(){var n=this;this.outerEdgesSorted||(this.outerEdges.sort(function(e,r){var i=e.to,s=r.to;if(i.coordinates[0]-n.coordinates[0]>=0&&s.coordinates[0]-n.coordinates[0]<0)return 1;if(i.coordinates[0]-n.coordinates[0]<0&&s.coordinates[0]-n.coordinates[0]>=0)return-1;if(i.coordinates[0]-n.coordinates[0]==0&&s.coordinates[0]-n.coordinates[0]==0)return i.coordinates[1]-n.coordinates[1]>=0||s.coordinates[1]-n.coordinates[1]>=0?i.coordinates[1]-s.coordinates[1]:s.coordinates[1]-i.coordinates[1];var o=zw(n.coordinates,i.coordinates,s.coordinates);return o<0?1:o>0?-1:Math.pow(i.coordinates[0]-n.coordinates[0],2)+Math.pow(i.coordinates[1]-n.coordinates[1],2)-(Math.pow(s.coordinates[0]-n.coordinates[0],2)+Math.pow(s.coordinates[1]-n.coordinates[1],2))}),this.outerEdgesSorted=!0)},t.prototype.getOuterEdges=function(){return this.sortOuterEdges(),this.outerEdges},t.prototype.getOuterEdge=function(n){return this.sortOuterEdges(),this.outerEdges[n]},t.prototype.addInnerEdge=function(n){this.innerEdges.push(n)},t}(),Qq=function(){function t(n,e){this.from=n,this.to=e,this.next=void 0,this.label=void 0,this.symetric=void 0,this.ring=void 0,this.from.addOuterEdge(this),this.to.addInnerEdge(this)}return t.prototype.getSymetric=function(){return this.symetric||(this.symetric=new t(this.to,this.from),this.symetric.symetric=this),this.symetric},t.prototype.deleteEdge=function(){this.from.removeOuterEdge(this),this.to.removeInnerEdge(this)},t.prototype.isEqual=function(n){return this.from.id===n.from.id&&this.to.id===n.to.id},t.prototype.toString=function(){return"Edge { "+this.from.id+" -> "+this.to.id+" }"},t.prototype.toLineString=function(){return Cv([this.from.coordinates,this.to.coordinates])},t.prototype.compareTo=function(n){return zw(n.from.coordinates,n.to.coordinates,this.to.coordinates)},t}(),tQ=function(){function t(){this.edges=[],this.polygon=void 0,this.envelope=void 0}return t.prototype.push=function(n){this.edges.push(n),this.polygon=this.envelope=void 0},t.prototype.get=function(n){return this.edges[n]},Object.defineProperty(t.prototype,"length",{get:function(){return this.edges.length},enumerable:!0,configurable:!0}),t.prototype.forEach=function(n){this.edges.forEach(n)},t.prototype.map=function(n){return this.edges.map(n)},t.prototype.some=function(n){return this.edges.some(n)},t.prototype.isValid=function(){return!0},t.prototype.isHole=function(){var n=this,e=this.edges.reduce(function(o,a,u){return a.from.coordinates[1]>n.edges[o].from.coordinates[1]&&(o=u),o},0),r=(0===e?this.length:e)-1,i=(e+1)%this.length,s=zw(this.edges[r].from.coordinates,this.edges[e].from.coordinates,this.edges[i].from.coordinates);return 0===s?this.edges[r].from.coordinates[0]>this.edges[i].from.coordinates[0]:s>0},t.prototype.toMultiPoint=function(){return function NR(t,n,e){return void 0===e&&(e={}),Hc({type:"MultiPoint",coordinates:t},n,e)}(this.edges.map(function(n){return n.from.coordinates}))},t.prototype.toPolygon=function(){if(this.polygon)return this.polygon;var n=this.edges.map(function(e){return e.from.coordinates});return n.push(this.edges[0].from.coordinates),this.polygon=ug([n])},t.prototype.getEnvelope=function(){return this.envelope?this.envelope:this.envelope=function oY(t){return function sY(t,n){void 0===n&&(n={});var e=Number(t[0]),r=Number(t[1]),i=Number(t[2]),s=Number(t[3]);if(6===t.length)throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");var o=[e,r];return ug([[o,[i,r],[i,s],[e,s],o]],n.properties,{bbox:t,id:n.id})}(MR(t))}(this.toPolygon())},t.findEdgeRingContaining=function(n,e){var i,s,r=n.getEnvelope();return e.forEach(function(o){var a=o.getEnvelope();if(s&&(i=s.getEnvelope()),!function Xq(t,n){var e=t.geometry.coordinates[0].map(function(o){return o[0]}),r=t.geometry.coordinates[0].map(function(o){return o[1]}),i=n.geometry.coordinates[0].map(function(o){return o[0]}),s=n.geometry.coordinates[0].map(function(o){return o[1]});return Math.max.apply(null,e)===Math.max.apply(null,i)&&Math.max.apply(null,r)===Math.max.apply(null,s)&&Math.min.apply(null,e)===Math.min.apply(null,i)&&Math.min.apply(null,r)===Math.min.apply(null,s)}(a,r)&&v2(a,r)){for(var u=n.map(function(w){return w.from.coordinates}),c=void 0,d=function(w){o.some(function(b){return function Zq(t,n){return t[0]===n[0]&&t[1]===n[1]}(w,b.from.coordinates)})||(c=w)},p=0,v=u;p<v.length;p++)d(v[p]);c&&o.inside(cp(c))&&(!s||v2(i,a))&&(s=o)}}),s},t.prototype.inside=function(n){return yw(n,this.toPolygon())},t}();function T2(t){for(var n=t,e=[];n.parent;)e.unshift(n),n=n.parent;return e}!function(){function t(){this.edges=[],this.nodes={}}t.fromGeoJson=function(n){!function eQ(t){if(!t)throw new Error("No geojson passed");if("FeatureCollection"!==t.type&&"GeometryCollection"!==t.type&&"MultiLineString"!==t.type&&"LineString"!==t.type&&"Feature"!==t.type)throw new Error("Invalid input type '"+t.type+"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature")}(n);var e=new t;return function bv(t,n){wv(t,function(e,r,i,s,o){var u,a=null===e?null:e.type;switch(a){case null:case"Point":case"LineString":case"Polygon":return!1!==n(Hc(e,i,{bbox:s,id:o}),r,0)&&void 0}switch(a){case"MultiPoint":u="Point";break;case"MultiLineString":u="LineString";break;case"MultiPolygon":u="Polygon"}for(var c=0;c<e.coordinates.length;c++)if(!1===n(Hc({type:u,coordinates:e.coordinates[c]},i),r,c))return!1})}(n,function(r){(function NZ(t,n,e){if(!t)throw new Error("No feature passed");if(!e)throw new Error(".featureOf() requires a name");if(!t||"Feature"!==t.type||!t.geometry)throw new Error("Invalid input to "+e+", Feature with geometry required");if(!t.geometry||t.geometry.type!==n)throw new Error("Invalid input to "+e+": must be a "+n+", given "+t.geometry.type)})(r,"LineString","Graph::fromGeoJson"),function CZ(t,n,e,r){var i=e;lg(t,function(s,o,a,u,c){i=0===o&&void 0===e?s:n(i,s,o,a,u,c)},r)}(r,function(i,s){if(i){var o=e.getNode(i),a=e.getNode(s);e.addEdge(o,a)}return s})}),e},t.prototype.getNode=function(n){var e=_2.buildId(n),r=this.nodes[e];return r||(r=this.nodes[e]=new _2(n)),r},t.prototype.addEdge=function(n,e){var r=new Qq(n,e),i=r.getSymetric();this.edges.push(r),this.edges.push(i)},t.prototype.deleteDangles=function(){var n=this;Object.keys(this.nodes).map(function(e){return n.nodes[e]}).forEach(function(e){return n._removeIfDangle(e)})},t.prototype._removeIfDangle=function(n){var e=this;if(n.innerEdges.length<=1){var r=n.getOuterEdges().map(function(i){return i.to});this.removeNode(n),r.forEach(function(i){return e._removeIfDangle(i)})}},t.prototype.deleteCutEdges=function(){var n=this;this._computeNextCWEdges(),this._findLabeledEdgeRings(),this.edges.forEach(function(e){e.label===e.symetric.label&&(n.removeEdge(e.symetric),n.removeEdge(e))})},t.prototype._computeNextCWEdges=function(n){var e=this;typeof n>"u"?Object.keys(this.nodes).forEach(function(r){return e._computeNextCWEdges(e.nodes[r])}):n.getOuterEdges().forEach(function(r,i){n.getOuterEdge((0===i?n.getOuterEdges().length:i)-1).symetric.next=r})},t.prototype._computeNextCCWEdges=function(n,e){for(var i,s,r=n.getOuterEdges(),o=r.length-1;o>=0;--o){var a=r[o],u=a.symetric,c=void 0,d=void 0;a.label===e&&(c=a),u.label===e&&(d=u),c&&d&&(d&&(s=d),c&&(s&&(s.next=c,s=void 0),i||(i=c)))}s&&(s.next=i)},t.prototype._findLabeledEdgeRings=function(){var n=[],e=0;return this.edges.forEach(function(r){if(!(r.label>=0)){n.push(r);var i=r;do{i.label=e,i=i.next}while(!r.isEqual(i));e++}}),n},t.prototype.getEdgeRings=function(){var n=this;this._computeNextCWEdges(),this.edges.forEach(function(r){r.label=void 0}),this._findLabeledEdgeRings().forEach(function(r){n._findIntersectionNodes(r).forEach(function(i){n._computeNextCCWEdges(i,r.label)})});var e=[];return this.edges.forEach(function(r){r.ring||e.push(n._findEdgeRing(r))}),e},t.prototype._findIntersectionNodes=function(n){var e=[],r=n,i=function(){var s=0;r.from.getOuterEdges().forEach(function(o){o.label===n.label&&++s}),s>1&&e.push(r.from),r=r.next};do{i()}while(!n.isEqual(r));return e},t.prototype._findEdgeRing=function(n){var e=n,r=new tQ;do{r.push(e),e.ring=r,e=e.next}while(!n.isEqual(e));return r},t.prototype.removeNode=function(n){var e=this;n.getOuterEdges().forEach(function(r){return e.removeEdge(r)}),n.innerEdges.forEach(function(r){return e.removeEdge(r)}),delete this.nodes[n.id]},t.prototype.removeEdge=function(n){this.edges=this.edges.filter(function(e){return!e.isEqual(n)}),n.deleteEdge()}}(),y(3198),y(3367),y(3282);var Mv={search:function(t,n,e,r){t.cleanDirty();var i=(r=r||{}).heuristic||Mv.heuristics.manhattan,s=r.closest||!1,o=function yQ(){return new N2(function(t){return t.f})}(),a=n;for(n.h=i(n,e),o.push(n);o.size()>0;){var u=o.pop();if(u===e)return T2(u);u.closed=!0;for(var c=t.neighbors(u),d=0,p=c.length;d<p;++d){var v=c[d];if(!v.closed&&!v.isWall()){var x=u.g+v.getCost(u),w=v.visited;(!w||x<v.g)&&(v.visited=!0,v.parent=u,v.h=v.h||i(v,e),v.g=x,v.f=v.g+v.h,t.markDirty(v),s&&(v.h<a.h||v.h===a.h&&v.g<a.g)&&(a=v),w?o.rescoreElement(v):o.push(v))}}}return s?T2(a):[]},heuristics:{manhattan:function(t,n){return Math.abs(n.x-t.x)+Math.abs(n.y-t.y)},diagonal:function(t,n){var r=Math.sqrt(2),i=Math.abs(n.x-t.x),s=Math.abs(n.y-t.y);return 1*(i+s)+(r-2)*Math.min(i,s)}},cleanNode:function(t){t.f=0,t.g=0,t.h=0,t.visited=!1,t.closed=!1,t.parent=null}};function fp(t,n){n=n||{},this.nodes=[],this.diagonal=!!n.diagonal,this.grid=[];for(var e=0;e<t.length;e++){this.grid[e]=[];for(var r=0,i=t[e];r<i.length;r++){var s=new Pv(e,r,i[r]);this.grid[e][r]=s,this.nodes.push(s)}}this.init()}function Pv(t,n,e){this.x=t,this.y=n,this.weight=e}function N2(t){this.content=[],this.scoreFunction=t}function Uw(){this._=null}function Ov(t){t.U=t.C=t.L=t.R=t.P=t.N=null}function pg(t,n){var e=n,r=n.R,i=e.U;i?i.L===e?i.L=r:i.R=r:t._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function mg(t,n){var e=n,r=n.L,i=e.U;i?i.L===e?i.L=r:i.R=r:t._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function A2(t){for(;t.L;)t=t.L;return t}fp.prototype.init=function(){this.dirtyNodes=[];for(var t=0;t<this.nodes.length;t++)Mv.cleanNode(this.nodes[t])},fp.prototype.cleanDirty=function(){for(var t=0;t<this.dirtyNodes.length;t++)Mv.cleanNode(this.dirtyNodes[t]);this.dirtyNodes=[]},fp.prototype.markDirty=function(t){this.dirtyNodes.push(t)},fp.prototype.neighbors=function(t){var n=[],e=t.x,r=t.y,i=this.grid;return i[e-1]&&i[e-1][r]&&n.push(i[e-1][r]),i[e+1]&&i[e+1][r]&&n.push(i[e+1][r]),i[e]&&i[e][r-1]&&n.push(i[e][r-1]),i[e]&&i[e][r+1]&&n.push(i[e][r+1]),this.diagonal&&(i[e-1]&&i[e-1][r-1]&&n.push(i[e-1][r-1]),i[e+1]&&i[e+1][r-1]&&n.push(i[e+1][r-1]),i[e-1]&&i[e-1][r+1]&&n.push(i[e-1][r+1]),i[e+1]&&i[e+1][r+1]&&n.push(i[e+1][r+1])),n},fp.prototype.toString=function(){for(var e,r,i,s,t=[],n=this.grid,o=0,a=n.length;o<a;o++){for(e=[],i=0,s=(r=n[o]).length;i<s;i++)e.push(r[i].weight);t.push(e.join(" "))}return t.join("\n")},Pv.prototype.toString=function(){return"["+this.x+" "+this.y+"]"},Pv.prototype.getCost=function(t){return t&&t.x!==this.x&&t.y!==this.y?1.41421*this.weight:this.weight},Pv.prototype.isWall=function(){return 0===this.weight},N2.prototype={push:function(t){this.content.push(t),this.sinkDown(this.content.length-1)},pop:function(){var t=this.content[0],n=this.content.pop();return this.content.length>0&&(this.content[0]=n,this.bubbleUp(0)),t},remove:function(t){var n=this.content.indexOf(t),e=this.content.pop();n!==this.content.length-1&&(this.content[n]=e,this.scoreFunction(e)<this.scoreFunction(t)?this.sinkDown(n):this.bubbleUp(n))},size:function(){return this.content.length},rescoreElement:function(t){this.sinkDown(this.content.indexOf(t))},sinkDown:function(t){for(var n=this.content[t];t>0;){var e=(t+1>>1)-1,r=this.content[e];if(!(this.scoreFunction(n)<this.scoreFunction(r)))break;this.content[e]=n,this.content[t]=r,t=e}},bubbleUp:function(t){for(var n=this.content.length,e=this.content[t],r=this.scoreFunction(e);;){var a,i=t+1<<1,s=i-1,o=null;if(s<n&&(a=this.scoreFunction(this.content[s]))<r&&(o=s),i<n&&this.scoreFunction(this.content[i])<(null===o?r:a)&&(o=i),null===o)break;this.content[t]=this.content[o],this.content[o]=e,t=o}}},Uw.prototype={constructor:Uw,insert:function(t,n){var e,r,i;if(t){if(n.P=t,n.N=t.N,t.N&&(t.N.P=n),t.N=n,t.R){for(t=t.R;t.L;)t=t.L;t.L=n}else t.R=n;e=t}else this._?(t=A2(this._),n.P=null,n.N=t,t.P=t.L=n,e=t):(n.P=n.N=null,this._=n,e=null);for(n.L=n.R=null,n.U=e,n.C=!0,t=n;e&&e.C;)e===(r=e.U).L?(i=r.R)&&i.C?(e.C=i.C=!1,r.C=!0,t=r):(t===e.R&&(pg(this,e),e=(t=e).U),e.C=!1,r.C=!0,mg(this,r)):(i=r.L)&&i.C?(e.C=i.C=!1,r.C=!0,t=r):(t===e.L&&(mg(this,e),e=(t=e).U),e.C=!1,r.C=!0,pg(this,r)),e=t.U;this._.C=!1},remove:function(t){t.N&&(t.N.P=t.P),t.P&&(t.P.N=t.N),t.N=t.P=null;var e,s,o,n=t.U,r=t.L,i=t.R;if(s=r?i?A2(i):r:i,n?n.L===t?n.L=s:n.R=s:this._=s,r&&i?(o=s.C,s.C=t.C,s.L=r,r.U=s,s!==i?(n=s.U,s.U=t.U,n.L=t=s.R,s.R=i,i.U=s):(s.U=n,n=s,t=s.R)):(o=t.C,t=s),t&&(t.U=n),!o){if(t&&t.C)return void(t.C=!1);do{if(t===this._)break;if(t===n.L){if((e=n.R).C&&(e.C=!1,n.C=!0,pg(this,n),e=n.R),e.L&&e.L.C||e.R&&e.R.C){(!e.R||!e.R.C)&&(e.L.C=!1,e.C=!0,mg(this,e),e=n.R),e.C=n.C,n.C=e.R.C=!1,pg(this,n),t=this._;break}}else if((e=n.L).C&&(e.C=!1,n.C=!0,mg(this,n),e=n.L),e.L&&e.L.C||e.R&&e.R.C){(!e.L||!e.L.C)&&(e.R.C=!1,e.C=!0,pg(this,e),e=n.L),e.C=n.C,n.C=e.L.C=!1,mg(this,n),t=this._;break}e.C=!0,t=n,n=n.U}while(!t.C);t&&(t.C=!1)}}};const M2=Uw;function gg(t,n,e,r){var i=[null,null],s=Gu.push(i)-1;return i.left=t,i.right=n,e&&Rv(i,t,n,e),r&&Rv(i,n,t,r),Ll[t.index].halfedges.push(s),Ll[n.index].halfedges.push(s),i}function yg(t,n,e){var r=[n,e];return r.left=t,r}function Rv(t,n,e,r){t[0]||t[1]?t.left===e?t[1]=r:t[0]=r:(t[0]=r,t.left=n,t.right=e)}function _Q(t,n,e,r,i){var b,s=t[0],o=t[1],a=s[0],u=s[1],p=0,v=1,x=o[0]-a,w=o[1]-u;if(b=n-a,x||!(b>0)){if(b/=x,x<0){if(b<p)return;b<v&&(v=b)}else if(x>0){if(b>v)return;b>p&&(p=b)}if(b=r-a,x||!(b<0)){if(b/=x,x<0){if(b>v)return;b>p&&(p=b)}else if(x>0){if(b<p)return;b<v&&(v=b)}if(b=e-u,w||!(b>0)){if(b/=w,w<0){if(b<p)return;b<v&&(v=b)}else if(w>0){if(b>v)return;b>p&&(p=b)}if(b=i-u,w||!(b<0)){if(b/=w,w<0){if(b>v)return;b>p&&(p=b)}else if(w>0){if(b<p)return;b<v&&(v=b)}return!(p>0)&&!(v<1)||(p>0&&(t[0]=[a+p*x,u+p*w]),v<1&&(t[1]=[a+v*x,u+v*w])),!0}}}}}function xQ(t,n,e,r,i){var s=t[1];if(s)return!0;var b,T,o=t[0],a=t.left,u=t.right,c=a[0],d=a[1],p=u[0],v=u[1],x=(c+p)/2;if(v===d){if(x<n||x>=r)return;if(c>p){if(o){if(o[1]>=i)return}else o=[x,e];s=[x,i]}else{if(o){if(o[1]<e)return}else o=[x,i];s=[x,e]}}else if(T=(d+v)/2-(b=(c-p)/(v-d))*x,b<-1||b>1)if(c>p){if(o){if(o[1]>=i)return}else o=[(e-T)/b,e];s=[(i-T)/b,i]}else{if(o){if(o[1]<e)return}else o=[(i-T)/b,i];s=[(e-T)/b,e]}else if(d<v){if(o){if(o[0]>=r)return}else o=[n,b*n+T];s=[r,b*r+T]}else{if(o){if(o[0]<n)return}else o=[r,b*r+T];s=[n,b*n+T]}return t[0]=o,t[1]=s,!0}function wQ(t,n){var e=t.site,r=n.left,i=n.right;return e===i&&(i=r,r=e),i?Math.atan2(i[1]-r[1],i[0]-r[0]):(e===r?(r=n[1],i=n[0]):(r=n[0],i=n[1]),Math.atan2(r[0]-i[0],i[1]-r[1]))}function P2(t,n){return n[+(n.left!==t.site)]}function bQ(t,n){return n[+(n.left===t.site)]}var Ww,O2=[];function DQ(){Ov(this),this.x=this.y=this.arc=this.site=this.cy=null}function pp(t){var n=t.P,e=t.N;if(n&&e){var r=n.site,i=t.site,s=e.site;if(r!==s){var o=i[0],a=i[1],u=r[0]-o,c=r[1]-a,d=s[0]-o,p=s[1]-a,v=2*(u*p-c*d);if(!(v>=-PQ)){var x=u*u+c*c,w=d*d+p*p,b=(p*x-c*w)/v,T=(u*w-d*x)/v,N=O2.pop()||new DQ;N.arc=t,N.site=i,N.x=b+o,N.y=(N.cy=T+a)+Math.sqrt(b*b+T*T),t.circle=N;for(var S=null,U=vg._;U;)if(N.y<U.y||N.y===U.y&&N.x<=U.x){if(!U.L){S=U.P;break}U=U.L}else{if(!U.R){S=U;break}U=U.R}vg.insert(S,N),S||(Ww=N)}}}}function mp(t){var n=t.circle;n&&(n.P||(Ww=n.N),vg.remove(n),O2.push(n),Ov(n),t.circle=null)}var R2=[];function TQ(){Ov(this),this.edge=this.site=this.circle=null}function L2(t){var n=R2.pop()||new TQ;return n.site=t,n}function Gw(t){mp(t),gp.remove(t),R2.push(t),Ov(t)}function NQ(t){var n=t.circle,e=n.x,r=n.cy,i=[e,r],s=t.P,o=t.N,a=[t];Gw(t);for(var u=s;u.circle&&Math.abs(e-u.circle.x)<sa&&Math.abs(r-u.circle.cy)<sa;)s=u.P,a.unshift(u),Gw(u),u=s;a.unshift(u),mp(u);for(var c=o;c.circle&&Math.abs(e-c.circle.x)<sa&&Math.abs(r-c.circle.cy)<sa;)o=c.N,a.push(c),Gw(c),c=o;a.push(c),mp(c);var p,d=a.length;for(p=1;p<d;++p)Rv((c=a[p]).edge,(u=a[p-1]).site,c.site,i);(c=a[d-1]).edge=gg((u=a[0]).site,c.site,null,i),pp(u),pp(c)}function AQ(t){for(var r,i,s,o,n=t[0],e=t[1],a=gp._;a;)if((s=k2(a,e)-n)>sa)a=a.L;else{if(!((o=n-MQ(a,e))>sa)){s>-sa?(r=a.P,i=a):o>-sa?(r=a,i=a.N):r=i=a;break}if(!a.R){r=a;break}a=a.R}!function CQ(t){Ll[t.index]={site:t,halfedges:[]}}(t);var u=L2(t);if(gp.insert(r,u),r||i){if(r===i)return mp(r),i=L2(r.site),gp.insert(u,i),u.edge=i.edge=gg(r.site,u.site),pp(r),void pp(i);if(!i)return void(u.edge=gg(r.site,u.site));mp(r),mp(i);var c=r.site,d=c[0],p=c[1],v=t[0]-d,x=t[1]-p,w=i.site,b=w[0]-d,T=w[1]-p,N=2*(v*T-x*b),S=v*v+x*x,U=b*b+T*T,J=[(T*S-x*U)/N+d,(v*U-b*S)/N+p];Rv(i.edge,c,w,J),u.edge=gg(c,t,null,J),i.edge=gg(t,w,null,J),pp(r),pp(i)}}function k2(t,n){var e=t.site,r=e[0],i=e[1],s=i-n;if(!s)return r;var o=t.P;if(!o)return-1/0;var a=(e=o.site)[0],u=e[1],c=u-n;if(!c)return a;var d=a-r,p=1/s-1/c,v=d/c;return p?(-v+Math.sqrt(v*v-2*p*(d*d/(-2*c)-u+c/2+i-s/2)))/p+r:(r+a)/2}function MQ(t,n){var e=t.N;if(e)return k2(e,n);var r=t.site;return r[1]===n?r[0]:1/0}var gp,Ll,vg,Gu,sa=1e-6,PQ=1e-12;function OQ(t,n,e){return(t[0]-e[0])*(n[1]-t[1])-(t[0]-n[0])*(e[1]-t[1])}function RQ(t,n){return n[1]-t[1]||n[0]-t[0]}function F2(t,n){var r,i,s,e=t.sort(RQ).pop();for(Gu=[],Ll=new Array(t.length),gp=new M2,vg=new M2;;)if(s=Ww,e&&(!s||e[1]<s.y||e[1]===s.y&&e[0]<s.x))(e[0]!==r||e[1]!==i)&&(AQ(e),r=e[0],i=e[1]),e=t.pop();else{if(!s)break;NQ(s.arc)}if(function IQ(){for(var e,r,i,s,t=0,n=Ll.length;t<n;++t)if((e=Ll[t])&&(s=(r=e.halfedges).length)){var o=new Array(s),a=new Array(s);for(i=0;i<s;++i)o[i]=i,a[i]=wQ(e,Gu[r[i]]);for(o.sort(function(u,c){return a[c]-a[u]}),i=0;i<s;++i)a[i]=r[o[i]];for(i=0;i<s;++i)r[i]=a[i]}}(),n){var o=+n[0][0],a=+n[0][1],u=+n[1][0],c=+n[1][1];(function EQ(t,n,e,r){for(var s,i=Gu.length;i--;)xQ(s=Gu[i],t,n,e,r)&&_Q(s,t,n,e,r)&&(Math.abs(s[0][0]-s[1][0])>sa||Math.abs(s[0][1]-s[1][1])>sa)||delete Gu[i]})(o,a,u,c),function SQ(t,n,e,r){var s,o,a,u,c,d,p,v,x,w,b,T,i=Ll.length,N=!0;for(s=0;s<i;++s)if(o=Ll[s]){for(a=o.site,u=(c=o.halfedges).length;u--;)Gu[c[u]]||c.splice(u,1);for(u=0,d=c.length;u<d;)b=(w=bQ(o,Gu[c[u]]))[0],T=w[1],v=(p=P2(o,Gu[c[++u%d]]))[0],x=p[1],(Math.abs(b-v)>sa||Math.abs(T-x)>sa)&&(c.splice(u,0,Gu.push(yg(a,w,Math.abs(b-t)<sa&&r-T>sa?[t,Math.abs(v-t)<sa?x:r]:Math.abs(T-r)<sa&&e-b>sa?[Math.abs(x-r)<sa?v:e,r]:Math.abs(b-e)<sa&&T-n>sa?[e,Math.abs(v-e)<sa?x:n]:Math.abs(T-n)<sa&&b-t>sa?[Math.abs(x-n)<sa?v:t,n]:null))-1),++d);d&&(N=!1)}if(N){var S,U,J,ht=1/0;for(s=0,N=null;s<i;++s)(o=Ll[s])&&(J=(S=(a=o.site)[0]-t)*S+(U=a[1]-n)*U)<ht&&(ht=J,N=o);if(N){var Tt=[t,n],Pt=[t,r],zt=[e,r],Ot=[e,n];N.halfedges.push(Gu.push(yg(a=N.site,Tt,Pt))-1,Gu.push(yg(a,Pt,zt))-1,Gu.push(yg(a,zt,Ot))-1,Gu.push(yg(a,Ot,Tt))-1)}}for(s=0;s<i;++s)(o=Ll[s])&&(o.halfedges.length||delete Ll[s])}(o,a,u,c)}this.edges=Gu,this.cells=Ll,gp=vg=Gu=Ll=null}F2.prototype={constructor:F2,polygons:function(){var t=this.edges;return this.cells.map(function(n){var e=n.halfedges.map(function(r){return P2(n,t[r])});return e.data=n.site.data,e})},triangles:function(){var t=[],n=this.edges;return this.cells.forEach(function(e,r){if(a=(s=e.halfedges).length)for(var s,a,u,i=e.site,o=-1,c=n[s[a-1]],d=c.left===i?c.right:c.left;++o<a;)u=d,d=(c=n[s[o]]).left===i?c.right:c.left,u&&d&&r<u.index&&r<d.index&&OQ(i,u,d)<0&&t.push([i.data,u.data,d.data])}),t},links:function(){return this.edges.filter(function(t){return t.right}).map(function(t){return{source:t.left.data,target:t.right.data}})},find:function(t,n,e){for(var i,a,r=this,s=r._found||0,o=r.cells.length;!(a=r.cells[s]);)if(++s>=o)return null;var u=t-a.site[0],c=n-a.site[1],d=u*u+c*c;do{a=r.cells[i=s],s=null,a.halfedges.forEach(function(p){var v=r.edges[p],x=v.left;if(x!==a.site&&x||(x=v.right)){var w=t-x[0],b=n-x[1],T=w*w+b*b;T<d&&(d=T,s=x.index)}})}while(null!==s);return r._found=i,null==e||d<=e*e?a.site:null}},y(8464);var jw=y(4855);function Hh(){return new Lv}function Lv(){this.reset()}Lv.prototype={constructor:Lv,reset:function(){this.s=this.t=0},add:function(t){X2(kv,t,this.t),X2(this,kv.s,this.s),this.s?this.t+=kv.t:this.s=kv.t},valueOf:function(){return this.s}};var kv=new Lv;function X2(t,n,e){var r=t.s=n+e,i=r-n;t.t=n-(r-i)+(e-i)}var Ws=1e-6,Ps=Math.PI,Cl=Ps/2,Fv=Ps/4,kl=2*Ps,Cc=180/Ps,_s=Ps/180,oa=Math.abs,_g=Math.atan,Eh=Math.atan2,li=Math.cos,qr=(Math,Math,Math,Math,Math,Math.sin),oc=(Math,Math.sqrt);Math;function Q2(t){return t>1?0:t<-1?Ps:Math.acos(t)}function Ch(t){return t>1?Cl:t<-1?-Cl:Math.asin(t)}function ma(){}function $v(t,n){t&&tL.hasOwnProperty(t.type)&&tL[t.type](t,n)}var J2={Feature:function(t,n){$v(t.geometry,n)},FeatureCollection:function(t,n){for(var e=t.features,r=-1,i=e.length;++r<i;)$v(e[r].geometry,n)}},tL={Sphere:function(t,n){n.sphere()},Point:function(t,n){n.point((t=t.coordinates)[0],t[1],t[2])},MultiPoint:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)n.point((t=e[r])[0],t[1],t[2])},LineString:function(t,n){Kw(t.coordinates,n,0)},MultiLineString:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)Kw(e[r],n,0)},Polygon:function(t,n){eL(t.coordinates,n)},MultiPolygon:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)eL(e[r],n)},GeometryCollection:function(t,n){for(var e=t.geometries,r=-1,i=e.length;++r<i;)$v(e[r],n)}};function Kw(t,n,e){var s,r=-1,i=t.length-e;for(n.lineStart();++r<i;)n.point((s=t[r])[0],s[1],s[2]);n.lineEnd()}function eL(t,n){var e=-1,r=t.length;for(n.polygonStart();++e<r;)Kw(t[e],n,1);n.polygonEnd()}function Vv(t){return[Eh(t[1],t[0]),Ch(t[2])]}function Ld(t){var n=t[0],e=t[1],r=li(e);return[r*li(n),r*qr(n),qr(e)]}function Uv(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function yp(t,n){return[t[1]*n[2]-t[2]*n[1],t[2]*n[0]-t[0]*n[2],t[0]*n[1]-t[1]*n[0]]}function qw(t,n){t[0]+=n[0],t[1]+=n[1],t[2]+=n[2]}function Wv(t,n){return[t[0]*n,t[1]*n,t[2]*n]}function Gv(t){var n=oc(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]/=n,t[1]/=n,t[2]/=n}function vL(t,n){function e(r,i){return r=t(r,i),n(r[0],r[1])}return t.invert&&n.invert&&(e.invert=function(r,i){return(r=n.invert(r,i))&&t.invert(r[0],r[1])}),e}function rb(t,n){return[t>Ps?t-kl:t<-Ps?t+kl:t,n]}function xL(t){return function(n,e){return[(n+=t)>Ps?n-kl:n<-Ps?n+kl:n,e]}}function EL(t){var n=xL(t);return n.invert=xL(-t),n}function CL(t,n){var e=li(t),r=qr(t),i=li(n),s=qr(n);function o(a,u){var c=li(u),d=li(a)*c,p=qr(a)*c,v=qr(u),x=v*e+d*r;return[Eh(p*i-x*s,d*e-v*r),Ch(x*i+p*s)]}return o.invert=function(a,u){var c=li(u),d=li(a)*c,p=qr(a)*c,v=qr(u),x=v*i-p*s;return[Eh(p*i+v*s,d*e+x*r),Ch(x*e-d*r)]},o}function bL(t,n){(n=Ld(n))[0]-=t,Gv(n);var e=Q2(-n[1]);return((-n[2]<0?-e:e)+kl-Ws)%kl}function IL(){var n,t=[];return{point:function(e,r){n.push([e,r])},lineStart:function(){t.push(n=[])},lineEnd:ma,rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))},result:function(){var e=t;return t=[],n=null,e}}}function Qv(t,n){return oa(t[0]-n[0])<Ws&&oa(t[1]-n[1])<Ws}function Jv(t,n,e,r){this.x=t,this.z=n,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function SL(t,n,e,r,i){var a,u,s=[],o=[];if(t.forEach(function(w){if(!((b=w.length-1)<=0)){var b,S,T=w[0],N=w[b];if(Qv(T,N)){for(i.lineStart(),a=0;a<b;++a)i.point((T=w[a])[0],T[1]);return void i.lineEnd()}s.push(S=new Jv(T,w,null,!0)),o.push(S.o=new Jv(T,null,S,!1)),s.push(S=new Jv(N,w,null,!1)),o.push(S.o=new Jv(N,null,S,!0))}}),s.length){for(o.sort(n),DL(s),DL(o),a=0,u=o.length;a<u;++a)o[a].e=e=!e;for(var d,p,c=s[0];;){for(var v=c,x=!0;v.v;)if((v=v.n)===c)return;d=v.z,i.lineStart();do{if(v.v=v.o.v=!0,v.e){if(x)for(a=0,u=d.length;a<u;++a)i.point((p=d[a])[0],p[1]);else r(v.x,v.n.x,1,i);v=v.n}else{if(x)for(a=(d=v.p.z).length-1;a>=0;--a)i.point((p=d[a])[0],p[1]);else r(v.x,v.p.x,-1,i);v=v.p}d=(v=v.o).z,x=!x}while(!v.v);i.lineEnd()}}}function DL(t){if(n=t.length){for(var n,i,e=0,r=t[0];++e<n;)r.n=i=t[e],i.p=r,r=i;r.n=i=t[0],i.p=r}}function TL(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function ML(t){for(var e,s,o,n=t.length,r=-1,i=0;++r<n;)i+=t[r].length;for(s=new Array(i);--n>=0;)for(e=(o=t[n]).length;--e>=0;)s[--i]=o[e];return s}Hh(),Hh(),Hh(),rb.invert=rb,function oJ(t){1===t.length&&(t=function aJ(t){return function(n,e){return TL(t(n),e)}}(t))}(TL),Math.sqrt(50),Math.sqrt(10),Math.sqrt(2);var wg=1e9,t_=-wg;var ab=Hh();Hh(),Hh(),Hh();var xp=1/0,s_=xp,bg=-xp,o_=bg;const HL={point:function EJ(t,n){t<xp&&(xp=t),t>bg&&(bg=t),n<s_&&(s_=n),n>o_&&(o_=n)},lineStart:ma,lineEnd:ma,polygonStart:ma,polygonEnd:ma,result:function(){var t=[[xp,s_],[bg,o_]];return bg=o_=-(s_=xp=1/0),t}};function ek(t,n,e,r){return function(i,s){var p,v,x,o=n(s),a=i.invert(r[0],r[1]),u=IL(),c=n(u),d=!1,w={point:b,lineStart:N,lineEnd:S,polygonStart:function(){w.point=U,w.lineStart=J,w.lineEnd=ht,v=[],p=[]},polygonEnd:function(){w.point=b,w.lineStart=N,w.lineEnd=S,v=ML(v);var Tt=function OL(t,n){var e=n[0],r=n[1],i=[qr(e),-li(e),0],s=0,o=0;ab.reset();for(var a=0,u=t.length;a<u;++a)if(d=(c=t[a]).length)for(var c,d,p=c[d-1],v=p[0],x=p[1]/2+Fv,w=qr(x),b=li(x),T=0;T<d;++T,v=S,w=J,b=ht,p=N){var N=c[T],S=N[0],U=N[1]/2+Fv,J=qr(U),ht=li(U),Tt=S-v,Pt=Tt>=0?1:-1,zt=Pt*Tt,Ot=zt>Ps,le=w*J;if(ab.add(Eh(le*Pt*qr(zt),b*ht+le*li(zt))),s+=Ot?Tt+Pt*kl:Tt,Ot^v>=e^S>=e){var ge=yp(Ld(p),Ld(N));Gv(ge);var Ae=yp(i,ge);Gv(Ae);var Re=(Ot^Tt>=0?-1:1)*Ch(Ae[2]);(r>Re||r===Re&&(ge[0]||ge[1]))&&(o+=Ot^Tt>=0?1:-1)}}return(s<-Ws||s<Ws&&ab<-Ws)^1&o}(p,a);v.length?(d||(s.polygonStart(),d=!0),SL(v,MJ,Tt,e,s)):Tt&&(d||(s.polygonStart(),d=!0),s.lineStart(),e(null,null,1,s),s.lineEnd()),d&&(s.polygonEnd(),d=!1),v=p=null},sphere:function(){s.polygonStart(),s.lineStart(),e(null,null,1,s),s.lineEnd(),s.polygonEnd()}};function b(Tt,Pt){var zt=i(Tt,Pt);t(Tt=zt[0],Pt=zt[1])&&s.point(Tt,Pt)}function T(Tt,Pt){var zt=i(Tt,Pt);o.point(zt[0],zt[1])}function N(){w.point=T,o.lineStart()}function S(){w.point=b,o.lineEnd()}function U(Tt,Pt){x.push([Tt,Pt]);var zt=i(Tt,Pt);c.point(zt[0],zt[1])}function J(){c.lineStart(),x=[]}function ht(){U(x[0][0],x[0][1]),c.lineEnd();var zt,le,ge,Ae,Tt=c.clean(),Pt=u.result(),Ot=Pt.length;if(x.pop(),p.push(x),x=null,Ot){if(1&Tt){if((le=(ge=Pt[0]).length-1)>0){for(d||(s.polygonStart(),d=!0),s.lineStart(),zt=0;zt<le;++zt)s.point((Ae=ge[zt])[0],Ae[1]);s.lineEnd()}return}Ot>1&&2&Tt&&Pt.push(Pt.pop().concat(Pt.shift())),v.push(Pt.filter(AJ))}}return w}}function AJ(t){return t.length>1}function MJ(t,n){return((t=t.x)[0]<0?t[1]-Cl-Ws:Cl-t[1])-((n=n.x)[0]<0?n[1]-Cl-Ws:Cl-n[1])}Hh(),function tk(t){return"m0,"+t+"a"+t+","+t+" 0 1,1 0,"+-2*t+"a"+t+","+t+" 0 1,1 0,"+2*t+"z"}(4.5);const nk=ek(function(){return!0},function PJ(t){var i,n=NaN,e=NaN,r=NaN;return{lineStart:function(){t.lineStart(),i=1},point:function(s,o){var a=s>0?Ps:-Ps,u=oa(s-n);oa(u-Ps)<Ws?(t.point(n,e=(e+o)/2>0?Cl:-Cl),t.point(r,e),t.lineEnd(),t.lineStart(),t.point(a,e),t.point(s,e),i=0):r!==a&&u>=Ps&&(oa(n-r)<Ws&&(n-=r*Ws),oa(s-a)<Ws&&(s-=a*Ws),e=function OJ(t,n,e,r){var i,s,o=qr(t-e);return oa(o)>Ws?_g((qr(n)*(s=li(r))*qr(e)-qr(r)*(i=li(n))*qr(t))/(i*s*o)):(n+r)/2}(n,e,s,o),t.point(r,e),t.lineEnd(),t.lineStart(),t.point(a,e),i=0),t.point(n=s,e=o),r=a},lineEnd:function(){t.lineEnd(),n=e=NaN},clean:function(){return 2-i}}},function RJ(t,n,e,r){var i;if(null==t)r.point(-Ps,i=e*Cl),r.point(0,i),r.point(Ps,i),r.point(Ps,0),r.point(Ps,-i),r.point(0,-i),r.point(-Ps,-i),r.point(-Ps,0),r.point(-Ps,i);else if(oa(t[0]-n[0])>Ws){var s=t[0]<n[0]?Ps:-Ps;r.point(-s,i=e*s/2),r.point(0,i),r.point(s,i)}else r.point(n[0],n[1])},[-Ps,-Cl]);function rk(t){return t}function Cb(t){return function(n){var e=new wb;for(var r in t)e[r]=t[r];return e.stream=n,e}}function wb(){}function ik(t,n,e){var r=n[1][0]-n[0][0],i=n[1][1]-n[0][1],s=t.clipExtent&&t.clipExtent();t.scale(150).translate([0,0]),null!=s&&t.clipExtent(null),function nL(t,n){t&&J2.hasOwnProperty(t.type)?J2[t.type](t,n):$v(t,n)}(e,t.stream(HL));var o=HL.result(),a=Math.min(r/(o[1][0]-o[0][0]),i/(o[1][1]-o[0][1])),u=+n[0][0]+(r-a*(o[1][0]+o[0][0]))/2,c=+n[0][1]+(i-a*(o[1][1]+o[0][1]))/2;return null!=s&&t.clipExtent(s),t.scale(150*a).translate([u,c])}wb.prototype={constructor:wb,point:function(t,n){this.stream.point(t,n)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};var sk=16,FJ=li(30*_s);function ok(t,n){return+n?function BJ(t,n){function e(r,i,s,o,a,u,c,d,p,v,x,w,b,T){var N=c-r,S=d-i,U=N*N+S*S;if(U>4*n&&b--){var J=o+v,ht=a+x,Tt=u+w,Pt=oc(J*J+ht*ht+Tt*Tt),zt=Ch(Tt/=Pt),Ot=oa(oa(Tt)-1)<Ws||oa(s-p)<Ws?(s+p)/2:Eh(ht,J),le=t(Ot,zt),ge=le[0],Ae=le[1],Re=ge-r,ve=Ae-i,Ne=S*Re-N*ve;(Ne*Ne/U>n||oa((N*Re+S*ve)/U-.5)>.3||o*v+a*x+u*w<FJ)&&(e(r,i,s,o,a,u,ge,Ae,Ot,J/=Pt,ht/=Pt,Tt,b,T),T.point(ge,Ae),e(ge,Ae,Ot,J,ht,Tt,c,d,p,v,x,w,b,T))}}return function(r){var i,s,o,a,u,c,d,p,v,x,w,b,T={point:N,lineStart:S,lineEnd:J,polygonStart:function(){r.polygonStart(),T.lineStart=ht},polygonEnd:function(){r.polygonEnd(),T.lineStart=S}};function N(zt,Ot){zt=t(zt,Ot),r.point(zt[0],zt[1])}function S(){p=NaN,T.point=U,r.lineStart()}function U(zt,Ot){var le=Ld([zt,Ot]),ge=t(zt,Ot);e(p,v,d,x,w,b,p=ge[0],v=ge[1],d=zt,x=le[0],w=le[1],b=le[2],sk,r),r.point(p,v)}function J(){T.point=N,r.lineEnd()}function ht(){S(),T.point=Tt,T.lineEnd=Pt}function Tt(zt,Ot){U(i=zt,Ot),s=p,o=v,a=x,u=w,c=b,T.point=U}function Pt(){e(p,v,d,x,w,b,s,o,i,a,u,c,sk,r),T.lineEnd=J,J()}return T}}(t,n):function $J(t){return Cb({point:function(n,e){n=t(n,e),this.stream.point(n[0],n[1])}})}(t)}var zJ=Cb({point:function(t,n){this.stream.point(t*_s,n*_s)}});function VJ(t){return function UJ(t){var n,s,o,v,x,N,S,U,Pt,zt,e=150,r=480,i=250,a=0,u=0,c=0,d=0,p=0,w=null,b=nk,T=null,J=rk,ht=.5,Tt=ok(ge,ht);function Ot(ve){return[(ve=x(ve[0]*_s,ve[1]*_s))[0]*e+s,o-ve[1]*e]}function le(ve){return(ve=x.invert((ve[0]-s)/e,(o-ve[1])/e))&&[ve[0]*Cc,ve[1]*Cc]}function ge(ve,Ne){return[(ve=n(ve,Ne))[0]*e+s,o-ve[1]*e]}function Ae(){x=vL(v=function _L(t,n,e){return(t%=kl)?n||e?vL(EL(t),CL(n,e)):EL(t):n||e?CL(n,e):rb}(c,d,p),n);var ve=n(a,u);return s=r-ve[0]*e,o=i+ve[1]*e,Re()}function Re(){return Pt=zt=null,Ot}return Ot.stream=function(ve){return Pt&&zt===ve?Pt:Pt=zJ(b(v,Tt(J(zt=ve))))},Ot.clipAngle=function(ve){return arguments.length?(b=+ve?function LJ(t,n){var e=li(t),r=e>0,i=oa(e)>Ws;function o(d,p){return li(d)*li(p)>e}function u(d,p,v){var b=[1,0,0],T=yp(Ld(d),Ld(p)),N=Uv(T,T),S=T[0],U=N-S*S;if(!U)return!v&&d;var J=e*N/U,ht=-e*S/U,Tt=yp(b,T),Pt=Wv(b,J);qw(Pt,Wv(T,ht));var Ot=Tt,le=Uv(Pt,Ot),ge=Uv(Ot,Ot),Ae=le*le-ge*(Uv(Pt,Pt)-1);if(!(Ae<0)){var Re=oc(Ae),ve=Wv(Ot,(-le-Re)/ge);if(qw(ve,Pt),ve=Vv(ve),!v)return ve;var Be,Ne=d[0],Se=p[0],Ke=d[1],Le=p[1];Se<Ne&&(Be=Ne,Ne=Se,Se=Be);var on=Se-Ne,rn=oa(on-Ps)<Ws;if(!rn&&Le<Ke&&(Be=Ke,Ke=Le,Le=Be),rn||on<Ws?rn?Ke+Le>0^ve[1]<(oa(ve[0]-Ne)<Ws?Ke:Le):Ke<=ve[1]&&ve[1]<=Le:on>Ps^(Ne<=ve[0]&&ve[0]<=Se)){var Qe=Wv(Ot,(-le+Re)/ge);return qw(Qe,Pt),[ve,Vv(Qe)]}}}function c(d,p){var v=r?t:Ps-t,x=0;return d<-v?x|=1:d>v&&(x|=2),p<-v?x|=4:p>v&&(x|=8),x}return ek(o,function a(d){var p,v,x,w,b;return{lineStart:function(){w=x=!1,b=1},point:function(T,N){var U,S=[T,N],J=o(T,N),ht=r?J?0:c(T,N):J?c(T+(T<0?Ps:-Ps),N):0;if(!p&&(w=x=J)&&d.lineStart(),J!==x&&(!(U=u(p,S))||Qv(p,U)||Qv(S,U))&&(S[0]+=Ws,S[1]+=Ws,J=o(S[0],S[1])),J!==x)b=0,J?(d.lineStart(),U=u(S,p),d.point(U[0],U[1])):(U=u(p,S),d.point(U[0],U[1]),d.lineEnd()),p=U;else if(i&&p&&r^J){var Tt;!(ht&v)&&(Tt=u(S,p,!0))&&(b=0,r?(d.lineStart(),d.point(Tt[0][0],Tt[0][1]),d.point(Tt[1][0],Tt[1][1]),d.lineEnd()):(d.point(Tt[1][0],Tt[1][1]),d.lineEnd(),d.lineStart(),d.point(Tt[0][0],Tt[0][1])))}J&&(!p||!Qv(p,S))&&d.point(S[0],S[1]),p=S,x=J,v=ht},lineEnd:function(){x&&d.lineEnd(),p=null},clean:function(){return b|(w&&x)<<1}}},function s(d,p,v,x){!function wL(t,n,e,r,i,s){if(e){var o=li(n),a=qr(n),u=r*e;null==i?(i=n+r*kl,s=n-u/2):(i=bL(o,i),s=bL(o,s),(r>0?i<s:i>s)&&(i+=r*kl));for(var c,d=i;r>0?d>s:d<s;d-=u)c=Vv([o,-a*li(d),-a*qr(d)]),t.point(c[0],c[1])}}(x,t,n,v,d,p)},r?[0,-t]:[-Ps,t-Ps])}(w=ve*_s,6*_s):(w=null,nk),Re()):w*Cc},Ot.clipExtent=function(ve){return arguments.length?(J=null==ve?(T=N=S=U=null,rk):function PL(t,n,e,r){function i(c,d){return t<=c&&c<=e&&n<=d&&d<=r}function s(c,d,p,v){var x=0,w=0;if(null==c||(x=o(c,p))!==(w=o(d,p))||u(c,d)<0^p>0)do{v.point(0===x||3===x?t:e,x>1?r:n)}while((x=(x+p+4)%4)!==w);else v.point(d[0],d[1])}function o(c,d){return oa(c[0]-t)<Ws?d>0?0:3:oa(c[0]-e)<Ws?d>0?2:1:oa(c[1]-n)<Ws?d>0?1:0:d>0?3:2}function a(c,d){return u(c.x,d.x)}function u(c,d){var p=o(c,1),v=o(d,1);return p!==v?p-v:0===p?d[1]-c[1]:1===p?c[0]-d[0]:2===p?c[1]-d[1]:d[0]-c[0]}return function(c){var v,x,w,b,T,N,S,U,J,ht,Tt,d=c,p=IL(),Pt={point:zt,lineStart:function Ae(){Pt.point=ve,x&&x.push(w=[]),ht=!0,J=!1,S=U=NaN},lineEnd:function Re(){v&&(ve(b,T),N&&J&&p.rejoin(),v.push(p.result())),Pt.point=zt,J&&d.lineEnd()},polygonStart:function le(){d=p,v=[],x=[],Tt=!0},polygonEnd:function ge(){var Ne=function Ot(){for(var Ne=0,Se=0,Ke=x.length;Se<Ke;++Se)for(var pn,Qe,Le=x[Se],Be=1,on=Le.length,rn=Le[0],gn=rn[0],dn=rn[1];Be<on;++Be)pn=gn,Qe=dn,gn=(rn=Le[Be])[0],dn=rn[1],Qe<=r?dn>r&&(gn-pn)*(r-Qe)>(dn-Qe)*(t-pn)&&++Ne:dn<=r&&(gn-pn)*(r-Qe)<(dn-Qe)*(t-pn)&&--Ne;return Ne}(),Se=Tt&&Ne,Ke=(v=ML(v)).length;(Se||Ke)&&(c.polygonStart(),Se&&(c.lineStart(),s(null,null,1,c),c.lineEnd()),Ke&&SL(v,a,Ne,s,c),c.polygonEnd()),d=c,v=x=w=null}};function zt(Ne,Se){i(Ne,Se)&&d.point(Ne,Se)}function ve(Ne,Se){var Ke=i(Ne,Se);if(x&&w.push([Ne,Se]),ht)b=Ne,T=Se,N=Ke,ht=!1,Ke&&(d.lineStart(),d.point(Ne,Se));else if(Ke&&J)d.point(Ne,Se);else{var Le=[S=Math.max(t_,Math.min(wg,S)),U=Math.max(t_,Math.min(wg,U))],Be=[Ne=Math.max(t_,Math.min(wg,Ne)),Se=Math.max(t_,Math.min(wg,Se))];!function sJ(t,n,e,r,i,s){var w,o=t[0],a=t[1],d=0,p=1,v=n[0]-o,x=n[1]-a;if(w=e-o,v||!(w>0)){if(w/=v,v<0){if(w<d)return;w<p&&(p=w)}else if(v>0){if(w>p)return;w>d&&(d=w)}if(w=i-o,v||!(w<0)){if(w/=v,v<0){if(w>p)return;w>d&&(d=w)}else if(v>0){if(w<d)return;w<p&&(p=w)}if(w=r-a,x||!(w>0)){if(w/=x,x<0){if(w<d)return;w<p&&(p=w)}else if(x>0){if(w>p)return;w>d&&(d=w)}if(w=s-a,x||!(w<0)){if(w/=x,x<0){if(w>p)return;w>d&&(d=w)}else if(x>0){if(w<d)return;w<p&&(p=w)}return d>0&&(t[0]=o+d*v,t[1]=a+d*x),p<1&&(n[0]=o+p*v,n[1]=a+p*x),!0}}}}}(Le,Be,t,n,e,r)?Ke&&(d.lineStart(),d.point(Ne,Se),Tt=!1):(J||(d.lineStart(),d.point(Le[0],Le[1])),d.point(Be[0],Be[1]),Ke||d.lineEnd(),Tt=!1)}S=Ne,U=Se,J=Ke}return Pt}}(T=+ve[0][0],N=+ve[0][1],S=+ve[1][0],U=+ve[1][1]),Re()):null==T?null:[[T,N],[S,U]]},Ot.scale=function(ve){return arguments.length?(e=+ve,Ae()):e},Ot.translate=function(ve){return arguments.length?(r=+ve[0],i=+ve[1],Ae()):[r,i]},Ot.center=function(ve){return arguments.length?(a=ve[0]%360*_s,u=ve[1]%360*_s,Ae()):[a*Cc,u*Cc]},Ot.rotate=function(ve){return arguments.length?(c=ve[0]%360*_s,d=ve[1]%360*_s,p=ve.length>2?ve[2]%360*_s:0,Ae()):[c*Cc,d*Cc,p*Cc]},Ot.precision=function(ve){return arguments.length?(Tt=ok(ge,ht=ve*ve),Re()):oc(ht)},Ot.fitExtent=function(ve,Ne){return ik(Ot,ve,Ne)},Ot.fitSize=function(ve,Ne){return function kJ(t,n,e){return ik(t,[[0,0],n],e)}(Ot,ve,Ne)},function(){return n=t.apply(this,arguments),Ot.invert=n.invert&&le,Ae()}}(function(){return t})()}function ak(t){return function(n,e){var r=li(n),i=li(e),s=t(r*i);return[s*i*qr(n),s*qr(e)]}}function Ng(t){return function(n,e){var r=oc(n*n+e*e),i=t(r),s=qr(i),o=li(i);return[Eh(n*s,r*o),Ch(r&&e*s/r)]}}ak(function(t){return oc(2/(1+t))}).invert=Ng(function(t){return 2*Ch(t/2)});var lk=ak(function(t){return(t=Q2(t))&&t/qr(t)});function Ib(t,n){return[t,n]}function h_(t,n,e,r){var i=t.properties||{},s="Feature"===t.type?t.geometry:t;if("GeometryCollection"===s.type){var o=[];return wv(t,function(b){var T=h_(b,n,e,r);T&&o.push(T)}),hp(o)}var a=function YJ(t){var n=function cY(t,n){void 0===n&&(n={});var e=MR(t);return cp([(e[0]+e[2])/2,(e[1]+e[3])/2],n.properties,n)}(t).geometry.coordinates,e=[-n[0],-n[1]];return function HJ(){return VJ(lk).scale(79.4188).clipAngle(179.999)}().rotate(e).scale(Wu)}(s),u={type:s.type,coordinates:gk(s.coordinates,a)},d=(new jw.GeoJSONReader).read(u),p=function AR(t,n){void 0===n&&(n="kilometers");var e=DR[n];if(!e)throw new Error(n+" units is invalid");return t*e}(function dw(t,n){void 0===n&&(n="kilometers");var e=DR[n];if(!e)throw new Error(n+" units is invalid");return t/e}(n,e),"meters"),v=jw.BufferOp.bufferOp(d,p,r);if(!mk((v=(new jw.GeoJSONWriter).write(v)).coordinates))return Hc({type:v.type,coordinates:yk(v.coordinates,a)},i)}function mk(t){return Array.isArray(t[0])?mk(t[0]):isNaN(t[0])}function gk(t,n){return"object"!=typeof t[0]?n(t):t.map(function(e){return gk(e,n)})}function yk(t,n){return"object"!=typeof t[0]?n.invert(t):t.map(function(e){return yk(e,n)})}lk.invert=Ng(function(t){return t}),Ib.invert=Ib,Ng(_g),Ng(Ch),Ng(function(t){return 2*_g(t)});const rtt=["addListener","removeListener"],itt=["addEventListener","removeEventListener"],stt=["on","off"];function Sb(t,n,e,r){if(V(e)&&(r=e,e=void 0),r)return Sb(t,n,e).pipe(BC(r));const[i,s]=function utt(t){return V(t.addEventListener)&&V(t.removeEventListener)}(t)?itt.map(o=>a=>t[o](n,a,e)):function ott(t){return V(t.addListener)&&V(t.removeListener)}(t)?rtt.map(_k(t,n)):function att(t){return V(t.on)&&V(t.off)}(t)?stt.map(_k(t,n)):[];if(!i&&tr(t))return Ss(o=>Sb(o,n,e))(Rr(t));if(!i)throw new TypeError("Invalid event target");return new xt(o=>{const a=(...u)=>o.next(1<u.length?u:u[0]);return i(a),()=>s(a)})}function _k(t,n){return e=>r=>t[e](n,r)}var ltt={error:"cordova_not_available"},ctt={error:"plugin_not_installed"};function d_(t){if(typeof window<"u"&&window.angular){var e=window.document,r=window.angular.element(e.querySelector("[ng-app]")||e.body).injector();if(r)return r.get("$q")(function(s,o){t(s,o)});console.warn("Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.")}return function(){if(Promise)return new Promise(function(s,o){t(s,o)});console.error("No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.")}()}function xk(t,n,e){var r,i,s;return"string"==typeof t?r=t:(r=t.constructor.getPluginRef(),e=t.constructor.getPluginName(),s=t.constructor.getPluginInstallName()),!(!(i=Ck(r))||n&&typeof i[n]>"u")||(typeof window>"u"||!window.cordova?(function ytt(t,n){typeof process>"u"&&console.warn(n?"Native: tried calling "+t+"."+n+", but Cordova is not available. Make sure to include cordova.js or run in a device/simulator":"Native: tried accessing the "+t+" plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator")}(e,n),ltt):(function gtt(t,n,e){console.warn(e?"Native: tried calling "+t+"."+e+", but the "+t+" plugin is not installed.":"Native: tried accessing the "+t+" plugin but it's not installed."),n&&console.warn("Install the "+t+" plugin: 'ionic cordova plugin add "+n+"'")}(e,s,n),ctt))}function Kh(t,n,e,r,i,s){void 0===r&&(r={}),e=function Ek(t,n,e,r){if(void 0===n&&(n={}),n.sync)return t;if("reverse"===n.callbackOrder)t.unshift(r),t.unshift(e);else if("node"===n.callbackStyle)t.push(function(a,u){a?r(a):e(u)});else if("object"===n.callbackStyle&&n.successName&&n.errorName){var i={};i[n.successName]=e,i[n.errorName]=r,t.push(i)}else if(typeof n.successIndex<"u"||typeof n.errorIndex<"u"){var s=function(){n.successIndex>t.length?t[n.successIndex]=e:t.splice(n.successIndex,0,e)},o=function(){n.errorIndex>t.length?t[n.errorIndex]=r:t.splice(n.errorIndex,0,r)};n.successIndex>n.errorIndex?(o(),s()):(s(),o())}else t.push(e),t.push(r);return t}(e,r,i,s);var o=xk(t,n);if(!0===o){var a=Ck(t.constructor.getPluginRef());return a[n].apply(a,e)}return o}function Ck(t){return typeof window<"u"?wk(window,t):null}function wk(t,n){for(var e=n.split("."),r=t,i=0;i<e.length;i++){if(!r)return null;r=r[e[i]]}return r}var vtt=function(t,n,e){return void 0===e&&(e={}),function(){for(var r=[],i=0;i<arguments.length;i++)r[i]=arguments[i];return e.sync?Kh(t,n,r,e):e.observable?function ftt(t,n,e,r){return void 0===r&&(r={}),new xt(function(i){var s;return s=r.destruct?Kh(t,n,e,r,function(){for(var o=[],a=0;a<arguments.length;a++)o[a]=arguments[a];return i.next(o)},function(){for(var o=[],a=0;a<arguments.length;a++)o[a]=arguments[a];return i.error(o)}):Kh(t,n,e,r,i.next.bind(i),i.error.bind(i)),s&&s.error&&(i.error(s.error),i.complete()),function(){try{if(r.clearFunction)return r.clearWithArgs?Kh(t,r.clearFunction,e,r,i.next.bind(i),i.error.bind(i)):Kh(t,r.clearFunction,[])}catch(o){console.warn("Unable to clear the previous observable watch for",t.constructor.getPluginName(),n),console.warn(o)}}})}(t,n,r,e):e.eventObservable&&e.event?function ptt(t,n){return Sb(n=typeof window<"u"&&n?wk(window,n):n||(typeof window<"u"?window:{}),t)}(e.event,e.element):e.otherPromise?function dtt(t,n,e,r){return void 0===r&&(r={}),d_(function(i,s){var o=Kh(t,n,e,r);o?o.error?s(o.error):o.then&&o.then(i).catch(s):s({error:"unexpected_error"})})}(t,n,r,e):function htt(t,n,e,r){void 0===r&&(r={});var i,s,o=d_(function(a,u){i=r.destruct?Kh(t,n,e,r,function(){for(var c=[],d=0;d<arguments.length;d++)c[d]=arguments[d];return a(c)},function(){for(var c=[],d=0;d<arguments.length;d++)c[d]=arguments[d];return u(c)}):Kh(t,n,e,r,a,u),s=u});return i&&i.error&&(o.catch(function(){}),"function"==typeof s&&s(i.error)),o}(t,n,r,e)}},xtt=function(){function t(){}return t.installed=function(){return!0===xk(this.pluginRef)},t.getPlugin=function(){return typeof window<"u"?function _tt(t,n){for(var e=n.split("."),r=t,i=0;i<e.length;i++){if(!r)return null;r=r[e[i]]}return r}(window,this.pluginRef):null},t.getPluginName=function(){return this.pluginName},t.getPluginRef=function(){return this.pluginRef},t.getPluginInstallName=function(){return this.plugin},t.getSupportedPlatforms=function(){return this.platforms},t.pluginName="",t.pluginRef="",t.plugin="",t.repo="",t.platforms=[],t.install="",t}();function _o(t,n,e,r){return vtt(t,n,e).apply(this,r)}!function ntt(){if(typeof process>"u"){var t=typeof window<"u"?window:{},e=Date.now(),r=!1;t.document.addEventListener("deviceready",function(){console.log("Ionic Native: deviceready event fired after "+(Date.now()-e)+" ms"),r=!0}),setTimeout(function(){!r&&t.cordova&&console.warn("Ionic Native: deviceready did not fire within 5000ms. This can happen when plugins are in an inconsistent state. Try removing plugins from plugins/ and reinstalling them.")},5e3)}}();var bk=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return function Tn(t,n){if("function"!=typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function e(){this.constructor=t}De(t,n),t.prototype=null===n?Object.create(n):(e.prototype=n.prototype,new e)}(n,t),n.prototype.configure=function(e){return _o(this,"configure",{},arguments)},n.prototype.start=function(){return _o(this,"start",{},arguments)},n.prototype.stop=function(){return _o(this,"stop",{},arguments)},n.prototype.finish=function(){return _o(this,"finish",{platforms:["iOS"]},arguments)},n.prototype.changePace=function(e){return _o(this,"changePace",{platforms:["iOS"]},arguments)},n.prototype.setConfig=function(e){return _o(this,"setConfig",{callbackOrder:"reverse"},arguments)},n.prototype.getStationaryLocation=function(){return _o(this,"getStationaryLocation",{platforms:["iOS"]},arguments)},n.prototype.onStationary=function(){return _o(this,"onStationary",{platforms:["iOS"]},arguments)},n.prototype.isLocationEnabled=function(){return _o(this,"isLocationEnabled",{platforms:["Android"]},arguments)},n.prototype.showAppSettings=function(){return _o(this,"showAppSettings",{sync:!0},arguments)},n.prototype.showLocationSettings=function(){return _o(this,"showLocationSettings",{sync:!0},arguments)},n.prototype.watchLocationMode=function(){return _o(this,"watchLocationMode",{platforms:["Android"],observable:!0},arguments)},n.prototype.stopWatchingLocationMode=function(){return _o(this,"stopWatchingLocationMode",{platforms:["Android"]},arguments)},n.prototype.getLocations=function(){return _o(this,"getLocations",{platforms:["Android"]},arguments)},n.prototype.getValidLocations=function(){return _o(this,"getValidLocations",{},arguments)},n.prototype.deleteLocation=function(e){return _o(this,"deleteLocation",{platforms:["Android"]},arguments)},n.prototype.deleteAllLocations=function(){return _o(this,"deleteAllLocations",{platforms:["Android"]},arguments)},n.prototype.switchMode=function(e){return _o(this,"switchMode",{platforms:["iOS"]},arguments)},n.prototype.getLogEntries=function(e,r,i){return _o(this,"getLogEntries",{},arguments)},n.prototype.getConfig=function(){return _o(this,"getConfig",{},arguments)},n.prototype.getCurrentLocation=function(e){return _o(this,"getCurrentLocation",{callbackOrder:"reverse"},arguments)},n.prototype.checkStatus=function(){return _o(this,"checkStatus",{},arguments)},n.prototype.startTask=function(){return _o(this,"startTask",{platforms:["IOS"]},arguments)},n.prototype.endTask=function(e){return _o(this,"endTask",{platforms:["IOS"]},arguments)},n.prototype.headlessTask=function(e){return _o(this,"headlessTask",{},arguments)},n.prototype.forceSync=function(){return _o(this,"forceSync",{},arguments)},n.prototype.on=function(e){return _o(this,"on",{observable:!0},arguments)},n.prototype.removeAllListeners=function(e){return _o(this,"removeAllListeners",{},arguments)},n.pluginName="BackgroundGeolocation",n.plugin="@mauron85/cordova-plugin-background-geolocation",n.pluginRef="BackgroundGeolocation",n.repo="https://github.com/mauron85/cordova-plugin-background-geolocation",n.platforms=["Android","iOS"],n.decorators=[{type:eW}],n}(xtt);let Ik=(()=>{class t{constructor(e){this.backgroundGeolocation=e}startBackgroundGeolocation(){return this.backgroundGeolocation.configure({desiredAccuracy:10,stationaryRadius:20,distanceFilter:30,debug:!0,stopOnTerminate:!1,startForeground:!0}),ss(this.backgroundGeolocation.start())}static#t=this.\u0275fac=function(r){return new(r||t)(Wn(bk))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),Sk=(()=>{class t{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=i=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}static#t=this.\u0275fac=function(r){return new(r||t)(xn(ch),xn(Ml))};static#e=this.\u0275dir=or({type:t})}return t})(),Bd=(()=>{class t extends Sk{static#t=this.\u0275fac=function(){let e;return function(i){return(e||(e=Mu(t)))(i||t)}}();static#e=this.\u0275dir=or({type:t,features:[so]})}return t})();const Yc=new In("NgValueAccessor"),Att={provide:Yc,useExisting:ei(()=>f_),multi:!0},Ptt=new In("CompositionEventMode");let f_=(()=>{class t extends Sk{constructor(e,r,i){super(e,r),this._compositionMode=i,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function Mtt(){const t=zh()?zh().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}static#t=this.\u0275fac=function(r){return new(r||t)(xn(ch),xn(Ml),xn(Ptt,8))};static#e=this.\u0275dir=or({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(r,i){1&r&&xu("input",function(o){return i._handleInput(o.target.value)})("blur",function(){return i.onTouched()})("compositionstart",function(){return i._compositionStart()})("compositionend",function(o){return i._compositionEnd(o.target.value)})},features:[ia([Att]),so]})}return t})();const Hu=new In("NgValidators"),Zh=new In("NgAsyncValidators");function Fk(t){return null!=t}function $k(t){return Tm(t)?ss(t):t}function Bk(t){let n={};return t.forEach(e=>{n=null!=e?{...n,...e}:n}),0===Object.keys(n).length?null:n}function zk(t,n){return n.map(e=>e(t))}function Vk(t){return t.map(n=>function Rtt(t){return!t.validate}(n)?n:e=>n.validate(e))}function Db(t){return null!=t?function Uk(t){if(!t)return null;const n=t.filter(Fk);return 0==n.length?null:function(e){return Bk(zk(e,n))}}(Vk(t)):null}function Tb(t){return null!=t?function Wk(t){if(!t)return null;const n=t.filter(Fk);return 0==n.length?null:function(e){return function Ttt(...t){const n=Oa(t),{args:e,keys:r}=vO(t),i=new xt(s=>{const{length:o}=e;if(!o)return void s.complete();const a=new Array(o);let u=o,c=o;for(let d=0;d<o;d++){let p=!1;Rr(e[d]).subscribe(Me(s,v=>{p||(p=!0,c--),a[d]=v},()=>u--,void 0,()=>{(!u||!p)&&(c||s.next(r?_O(r,a):a),s.complete())}))}});return n?i.pipe(BC(n)):i}(zk(e,n).map($k)).pipe(Ue(Bk))}}(Vk(t)):null}function Gk(t,n){return null===t?[n]:Array.isArray(t)?[...t,n]:[t,n]}function Nb(t){return t?Array.isArray(t)?t:[t]:[]}function m_(t,n){return Array.isArray(t)?t.includes(n):t===n}function Kk(t,n){const e=Nb(n);return Nb(t).forEach(i=>{m_(e,i)||e.push(i)}),e}function Xk(t,n){return Nb(n).filter(e=>!m_(t,e))}class Zk{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(n){this._rawValidators=n||[],this._composedValidatorFn=Db(this._rawValidators)}_setAsyncValidators(n){this._rawAsyncValidators=n||[],this._composedAsyncValidatorFn=Tb(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(n){this._onDestroyCallbacks.push(n)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(n=>n()),this._onDestroyCallbacks=[]}reset(n=void 0){this.control&&this.control.reset(n)}hasError(n,e){return!!this.control&&this.control.hasError(n,e)}getError(n,e){return this.control?this.control.getError(n,e):null}}class cl extends Zk{get formDirective(){return null}get path(){return null}}class Yh extends Zk{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class Yk{constructor(n){this._cd=n}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let qk=(()=>{class t extends Yk{constructor(e){super(e)}static#t=this.\u0275fac=function(r){return new(r||t)(xn(Yh,2))};static#e=this.\u0275dir=or({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(r,i){2&r&&S0("ng-untouched",i.isUntouched)("ng-touched",i.isTouched)("ng-pristine",i.isPristine)("ng-dirty",i.isDirty)("ng-valid",i.isValid)("ng-invalid",i.isInvalid)("ng-pending",i.isPending)},features:[so]})}return t})();const Ag="VALID",y_="INVALID",Cp="PENDING",Mg="DISABLED";function v_(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}class eF{constructor(n,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(n),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(n){this._rawValidators=this._composedValidatorFn=n}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(n){this._rawAsyncValidators=this._composedAsyncValidatorFn=n}get parent(){return this._parent}get valid(){return this.status===Ag}get invalid(){return this.status===y_}get pending(){return this.status==Cp}get disabled(){return this.status===Mg}get enabled(){return this.status!==Mg}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(n){this._assignValidators(n)}setAsyncValidators(n){this._assignAsyncValidators(n)}addValidators(n){this.setValidators(Kk(n,this._rawValidators))}addAsyncValidators(n){this.setAsyncValidators(Kk(n,this._rawAsyncValidators))}removeValidators(n){this.setValidators(Xk(n,this._rawValidators))}removeAsyncValidators(n){this.setAsyncValidators(Xk(n,this._rawAsyncValidators))}hasValidator(n){return m_(this._rawValidators,n)}hasAsyncValidator(n){return m_(this._rawAsyncValidators,n)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(n={}){this.touched=!0,this._parent&&!n.onlySelf&&this._parent.markAsTouched(n)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(n=>n.markAllAsTouched())}markAsUntouched(n={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!n.onlySelf&&this._parent._updateTouched(n)}markAsDirty(n={}){this.pristine=!1,this._parent&&!n.onlySelf&&this._parent.markAsDirty(n)}markAsPristine(n={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!n.onlySelf&&this._parent._updatePristine(n)}markAsPending(n={}){this.status=Cp,!1!==n.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!n.onlySelf&&this._parent.markAsPending(n)}disable(n={}){const e=this._parentMarkedDirty(n.onlySelf);this.status=Mg,this.errors=null,this._forEachChild(r=>{r.disable({...n,onlySelf:!0})}),this._updateValue(),!1!==n.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...n,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(n={}){const e=this._parentMarkedDirty(n.onlySelf);this.status=Ag,this._forEachChild(r=>{r.enable({...n,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent}),this._updateAncestors({...n,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(n){this._parent&&!n.onlySelf&&(this._parent.updateValueAndValidity(n),n.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(n){this._parent=n}getRawValue(){return this.value}updateValueAndValidity(n={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===Ag||this.status===Cp)&&this._runAsyncValidator(n.emitEvent)),!1!==n.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!n.onlySelf&&this._parent.updateValueAndValidity(n)}_updateTreeValidity(n={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(n)),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Mg:Ag}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(n){if(this.asyncValidator){this.status=Cp,this._hasOwnPendingAsyncValidator=!0;const e=$k(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:n})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(n,e={}){this.errors=n,this._updateControlsErrors(!1!==e.emitEvent)}get(n){let e=n;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,i)=>r&&r._find(i),this)}getError(n,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[n]:null}hasError(n,e){return!!this.getError(n,e)}get root(){let n=this;for(;n._parent;)n=n._parent;return n}_updateControlsErrors(n){this.status=this._calculateStatus(),n&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(n)}_initObservables(){this.valueChanges=new Sa,this.statusChanges=new Sa}_calculateStatus(){return this._allControlsDisabled()?Mg:this.errors?y_:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(Cp)?Cp:this._anyControlsHaveStatus(y_)?y_:Ag}_anyControlsHaveStatus(n){return this._anyControls(e=>e.status===n)}_anyControlsDirty(){return this._anyControls(n=>n.dirty)}_anyControlsTouched(){return this._anyControls(n=>n.touched)}_updatePristine(n={}){this.pristine=!this._anyControlsDirty(),this._parent&&!n.onlySelf&&this._parent._updatePristine(n)}_updateTouched(n={}){this.touched=this._anyControlsTouched(),this._parent&&!n.onlySelf&&this._parent._updateTouched(n)}_registerOnCollectionChange(n){this._onCollectionChange=n}_setUpdateStrategy(n){v_(n)&&null!=n.updateOn&&(this._updateOn=n.updateOn)}_parentMarkedDirty(n){return!n&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(n){return null}_assignValidators(n){this._rawValidators=Array.isArray(n)?n.slice():n,this._composedValidatorFn=function Btt(t){return Array.isArray(t)?Db(t):t||null}(this._rawValidators)}_assignAsyncValidators(n){this._rawAsyncValidators=Array.isArray(n)?n.slice():n,this._composedAsyncValidatorFn=function ztt(t){return Array.isArray(t)?Tb(t):t||null}(this._rawAsyncValidators)}}const wp=new In("CallSetDisabledState",{providedIn:"root",factory:()=>__}),__="always";function Pg(t,n,e=__){(function Lb(t,n){const e=function Hk(t){return t._rawValidators}(t);null!==n.validator?t.setValidators(Gk(e,n.validator)):"function"==typeof e&&t.setValidators([e]);const r=function jk(t){return t._rawAsyncValidators}(t);null!==n.asyncValidator?t.setAsyncValidators(Gk(r,n.asyncValidator)):"function"==typeof r&&t.setAsyncValidators([r]);const i=()=>t.updateValueAndValidity();C_(n._rawValidators,i),C_(n._rawAsyncValidators,i)})(t,n),n.valueAccessor.writeValue(t.value),(t.disabled||"always"===e)&&n.valueAccessor.setDisabledState?.(t.disabled),function Wtt(t,n){n.valueAccessor.registerOnChange(e=>{t._pendingValue=e,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&nF(t,n)})}(t,n),function Htt(t,n){const e=(r,i)=>{n.valueAccessor.writeValue(r),i&&n.viewToModelUpdate(r)};t.registerOnChange(e),n._registerOnDestroy(()=>{t._unregisterOnChange(e)})}(t,n),function Gtt(t,n){n.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&nF(t,n),"submit"!==t.updateOn&&t.markAsTouched()})}(t,n),function Utt(t,n){if(n.valueAccessor.setDisabledState){const e=r=>{n.valueAccessor.setDisabledState(r)};t.registerOnDisabledChange(e),n._registerOnDestroy(()=>{t._unregisterOnDisabledChange(e)})}}(t,n)}function C_(t,n){t.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(n)})}function nF(t,n){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),n.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function sF(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}function oF(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}const aF=class extends eF{constructor(n=null,e,r){super(function Pb(t){return(v_(t)?t.validators:t)||null}(e),function Ob(t,n){return(v_(n)?n.asyncValidators:t)||null}(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(n),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),v_(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=oF(n)?n.value:n)}setValue(n,e={}){this.value=this._pendingValue=n,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(n,e={}){this.setValue(n,e)}reset(n=this.defaultValue,e={}){this._applyFormState(n),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(n){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(n){this._onChange.push(n)}_unregisterOnChange(n){sF(this._onChange,n)}registerOnDisabledChange(n){this._onDisabledChange.push(n)}_unregisterOnDisabledChange(n){sF(this._onDisabledChange,n)}_forEachChild(n){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(n){oF(n)?(this.value=this._pendingValue=n.value,n.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=n}},Jtt={provide:Yh,useExisting:ei(()=>zb)},cF=(()=>Promise.resolve())();let zb=(()=>{class t extends Yh{constructor(e,r,i,s,o,a){super(),this._changeDetectorRef=o,this.callSetDisabledState=a,this.control=new aF,this._registered=!1,this.name="",this.update=new Sa,this._parent=e,this._setValidators(r),this._setAsyncValidators(i),this.valueAccessor=function $b(t,n){if(!n)return null;let e,r,i;return Array.isArray(n),n.forEach(s=>{s.constructor===f_?e=s:function Xtt(t){return Object.getPrototypeOf(t.constructor)===Bd}(s)?r=s:i=s}),i||r||e||null}(0,s)}ngOnChanges(e){if(this._checkForErrors(),!this._registered||"name"in e){if(this._registered&&(this._checkName(),this.formDirective)){const r=e.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in e&&this._updateDisabled(e),function Fb(t,n){if(!t.hasOwnProperty("model"))return!1;const e=t.model;return!!e.isFirstChange()||!Object.is(n,e.currentValue)}(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){Pg(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){cF.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(e){const r=e.isDisabled.currentValue,i=0!==r&&function Qf(t){return"boolean"==typeof t?t:null!=t&&"false"!==t}(r);cF.then(()=>{i&&!this.control.disabled?this.control.disable():!i&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(e){return this._parent?function x_(t,n){return[...n.path,t]}(e,this._parent):[e]}static#t=this.\u0275fac=function(r){return new(r||t)(xn(cl,9),xn(Hu,10),xn(Zh,10),xn(Yc,10),xn(z0,8),xn(wp,8))};static#e=this.\u0275dir=or({type:t,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[ia([Jtt]),so,yl]})}return t})();const eet={provide:Yc,useExisting:ei(()=>Vb),multi:!0};let Vb=(()=>{class t extends Bd{writeValue(e){this.setProperty("value",e??"")}registerOnChange(e){this.onChange=r=>{e(""==r?null:parseFloat(r))}}static#t=this.\u0275fac=function(){let e;return function(i){return(e||(e=Mu(t)))(i||t)}}();static#e=this.\u0275dir=or({type:t,selectors:[["input","type","number","formControlName",""],["input","type","number","formControl",""],["input","type","number","ngModel",""]],hostBindings:function(r,i){1&r&&xu("input",function(o){return i.onChange(o.target.value)})("blur",function(){return i.onTouched()})},features:[ia([eet]),so]})}return t})(),hF=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({})}return t})(),Iet=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({imports:[hF]})}return t})(),Tet=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:wp,useValue:e.callSetDisabledState??__}]}}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({imports:[Iet]})}return t})();var Mr=y(5861),g=y(6300),cn=y(4251),_i=y(3062),Jn=y(8737),b_=y(6034);const NF={kernelName:cn.SYM,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,b_.N)((0,_i.p)(e,"float32"),-1))}}};var Ua=y(3530),uc=y(5048),ju=y(8661),bp=y(930),Ou=y(7527),Bl=y(1191);const Net={kernelName:cn.VGw,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=(0,Ou.h)((0,_i.p)(e,"float32")),i=(0,bp._)((0,Bl.l)((0,ju.i)(1),r));return(0,uc.W)((0,Ua.h)(t,i))}}}},Aet={kernelName:cn.SpW,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=(0,bp._)((0,Bl.l)((0,Ou.h)((0,_i.p)(e,"float32")),1));return(0,Ua.h)(t,r)}}}};var Fo=y(3239),Dr=y(5715),Ko=y(9929);const Met={kernelName:cn.mm_,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=Fo.assertAndGetBroadcastShape(e.shape,r.shape);return{a:()=>{let a=t;const u=Fo.getReductionAxes(e.shape,i);return u.length>0&&(a=(0,Ko.S)(a,u)),(0,Dr.X)(a,e.shape)},b:()=>{let a=t;const u=Fo.getReductionAxes(r.shape,i);return u.length>0&&(a=(0,Ko.S)(a,u)),(0,Dr.X)(a,r.shape)}}}},Pet={kernelName:cn.Xze,saveAllInputs:!0,gradFunc:(t,n)=>{const e={};return n.forEach((r,i)=>{e[i]=()=>t.clone()}),e}};var Na=y(3143);const Oet={kernelName:cn.sJF,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Na.P)(e)}}},Ret={kernelName:cn.aJk,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Na.P)(e)}}},Let={kernelName:cn.M2y,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ua.h)(t,(0,bp._)((0,Bl.l)((0,ju.i)(1),(0,Ou.h)((0,_i.p)(e,"float32")))))}}};var bc=y(7066);const ket={kernelName:cn.qw7,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=(0,bp._)((0,bc.I)((0,ju.i)(1),(0,Ou.h)((0,_i.p)(e,"float32"))));return(0,Ua.h)(t,r)}}}},Fet={kernelName:cn.QCc,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,Fo.assertAndGetBroadcastShape)(e.shape,r.shape);return{a:()=>{const a=(0,bc.I)((0,Ou.h)(e),(0,Ou.h)(r));let u=(0,Jn.d)(t,(0,Ua.h)(r,a));const c=(0,Fo.getReductionAxes)(e.shape,i);return c.length>0&&(u=(0,Ko.S)(u,c)),(0,Dr.X)(u,e.shape)},b:()=>{const a=(0,bc.I)((0,Ou.h)(e),(0,Ou.h)(r));let u=(0,uc.W)((0,Jn.d)(t,(0,Ua.h)(e,a)));const c=(0,Fo.getReductionAxes)(r.shape,i);return c.length>0&&(u=(0,Ko.S)(u,c)),(0,Dr.X)(u,r.shape)}}}},$et={kernelName:cn.jMg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ua.h)(t,(0,bc.I)((0,Ou.h)((0,_i.p)(e,"float32")),1))}}},Bet={kernelName:cn.Oyi,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ua.h)(t,(0,Bl.l)((0,ju.i)(1),(0,Ou.h)((0,_i.p)(e,"float32"))))}}};var Ic=y(687),qc=y(1257),Os=y(5359),qh=y(5551),Ip=y(4195);const Vet=(0,Ip.op)({avgPool3dGrad_:function zet(t,n,e,r,i,s){const o=(0,qc._1)(t,"dy","avgPool3dGrad"),a=(0,qc._1)(n,"input","avgPool3dGrad");let u=o,c=a,d=!1;4===a.rank&&(d=!0,u=(0,Dr.X)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=(0,Dr.X)(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Os.hu(5===u.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),Os.hu(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),(0,qh.m)("avgPool3dGrad",i,s);const x=Ic.BV.runKernel(cn.IMb,{dy:u,input:c},{filterSize:e,strides:r,pad:i,dimRoundingMode:s});return d?(0,Dr.X)(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}}),Uet={kernelName:cn._k9,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:i,strides:s,pad:o,dimRoundingMode:a}=e;return{x:()=>Vet(t,r,i,s,o,a)}}},Get=(0,Ip.op)({avgPoolGrad_:function Wet(t,n,e,r,i){const s=(0,qc._1)(t,"dy","avgPoolGrad"),o=(0,qc._1)(n,"input","avgPoolGrad");Os.hu(o.rank===s.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`);let a=o,u=s,c=!1;3===o.rank&&(c=!0,a=(0,Dr.X)(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=(0,Dr.X)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Os.hu(4===u.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),Os.hu(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const v=Ic.BV.runKernel(cn.ROF,{dy:u,input:a},{filterSize:e,strides:r,pad:i});return c?(0,Dr.X)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),Het={kernelName:cn.JhU,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:i,strides:s,pad:o}=e;return{x:()=>Get(t,r,i,s,o)}}};var Sh=y(5592);const jet={kernelName:cn.XLW,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{const[r,i]=n,{transposeA:s,transposeB:o}=e;return s||o?!s&&o?{a:()=>(0,Sh.O)(t,i,!1,!1),b:()=>(0,Sh.O)(t,r,!0,!1)}:s&&!o?{a:()=>(0,Sh.O)(i,t,!1,!0),b:()=>(0,Sh.O)(r,t,!1,!1)}:{a:()=>(0,Sh.O)(i,t,!0,!0),b:()=>(0,Sh.O)(t,r,!0,!0)}:{a:()=>(0,Sh.O)(t,i,!1,!0),b:()=>(0,Sh.O)(r,t,!0,!1)}}};var AF=y(9619);const Ket={kernelName:cn.zws,gradFunc:(t,n,e)=>{const{blockShape:r,crops:i}=e;return{x:()=>(0,AF.f)(t,r,i)}}},Xet={kernelName:cn.Ly9,gradFunc:(t,n,e)=>{const i=e.inputShape,s=e.shape,o=Array.from(s);for(let u=i.length-1;u>=0;u--)if(i[u]===s[u])o[u]=1;else if(1!==i[u])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${s}].`);const a=[];for(let u=0;u<o.length;u++)o[u]>1&&a.push(u);return{x:()=>(0,Ko.S)(t,a,!0)}}},Zet={kernelName:cn.RFZ,gradFunc:t=>({x:()=>t.clone()})},Yet={kernelName:cn.gJX,gradFunc:t=>({x:()=>(0,Na.P)(t)})};var I_=y(9886),S_=y(2223),Xb=y(3080),Qh=y(2190);const qet={kernelName:cn.xnO,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{clipValueMin:i,clipValueMax:s}=e;return{x:()=>(0,Qh.a)((0,Xb.H)((0,I_.b)(r,i),(0,S_.z)(r,s)),t,(0,Na.P)(t))}}},Qet={kernelName:cn.yj2,inputsToSave:["x"],gradFunc:NF.gradFunc};var MF=y(8874);const Jet={kernelName:cn.Eh3,saveAllInputs:!0,gradFunc:(t,n,e)=>{const r=n.map(u=>u.shape),{axis:i}=e,s=(0,Os.EC)(i,n[0].shape)[0],o=r.map(u=>u[s]);return(0,MF.V)(t,o,s).map(u=>()=>u)}};var PF=y(443),tnt=y(5743);const ent={kernelName:cn.mhS,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,i]=n,{dilations:s,strides:o,pad:a,dataFormat:u}=e;return Os.hu(qh.I0(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>(0,tnt._)(r.shape,t,i,o,a,u),filter:()=>(0,PF.p)(r,t,i.shape,o,a,u)}}};var OF=y(4451);const nnt={kernelName:cn.wm,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{const[r,i]=n,{strides:s,pad:o,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>(0,OF.T)(t,i,s,o,a,1,u),filter:()=>(0,PF.p)(t,r,i.shape,s,o,a,u)}}},int=(0,Ip.op)({conv3DBackpropFilter_:function rnt(t,n,e,r,i){let s=t;4===t.rank&&(s=(0,Dr.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=n;return 4===o.rank&&(o=(0,Dr.X)(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),Os.hu(5===s.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),Os.hu(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),Os.hu(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),Os.hu(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),Os.hu(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),Ic.BV.runKernel(cn.o2y,{x:s,dy:o},{strides:r,pad:i,filterShape:e})}});var snt=y(7022);const ont={kernelName:cn.x12,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:i,pad:s}=e;Os.hu((0,qh.I0)(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=n;return{x:()=>(0,snt._)(o.shape,t,a,i,s),filter:()=>int(o,t,a.shape,i,s)}}};var RF=y(2438);const ant={kernelName:cn.mc4,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,uc.W)((0,RF.O)((0,_i.p)(e,"float32"))),t)}}};var LF=y(319);const unt={kernelName:cn.TR1,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,LF.R)((0,_i.p)(e,"float32")),t)}}};var Jh=y(929),kF=y(7157),Vd=y(9194);const lnt={kernelName:cn.iHb,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:i,exclusive:s,reverse:o}=e;return{x:()=>{const a=(0,Jh.Q3)([i],r.rank);let u=(0,kF.z)(t,i,s,!o);return null!=a&&(u=(0,Vd.p)(u,a)),u}}}};var cnt=y(366),hnt=y(519);const dnt={kernelName:cn.cie,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:i,pad:s,dimRoundingMode:o}=e,a=r??[1,1];Os.hu(qh.I0(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[u,c]=n;return Os.hu(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),Os.hu(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),Os.hu(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),Os.hu(qh.jT(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),qh.m("depthwiseConv2d",s,o),{x:()=>(0,hnt.v)(u.shape,t,c,i,s,a,o),filter:()=>(0,cnt.z)(u,t,c.shape,i,s,a,o)}}},fnt={kernelName:cn.p4S,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,i]=n,s={x:r,filter:i,dy:t},o={x:r,filter:i,dy:t};return{x:()=>Ic.BV.runKernel(cn.ekb,s,e),filter:()=>Ic.BV.runKernel(cn.Vn9,o,e)}}},pnt={kernelName:cn.SX0,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n,r={dy:t,y:e};return{x:()=>Ic.BV.runKernel(cn.HEU,r)}}};var Rg=y(5109);const mnt={kernelName:cn.Omj,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=(0,Jn.d)((0,Rg.Q)((0,uc.W)((0,Ou.h)(e))),2/Math.sqrt(Math.PI));return{x:()=>(0,Jn.d)(t,r)}}},gnt={kernelName:cn.NEP,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,e)}}},ynt={kernelName:cn.YFo,inputsToSave:["input"],gradFunc:(t,n)=>{const[e]=n;return{input:()=>(0,Dr.X)(t,e.shape)}}},vnt={kernelName:cn.Y0y,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,Rg.Q)(e))}}},_nt={kernelName:cn.OR,gradFunc:t=>({x:()=>(0,Na.P)(t)})},xnt={kernelName:cn.jeX,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,Fo.assertAndGetBroadcastShape)(e.shape,r.shape);return{a:()=>{const a=(0,Ua.h)(t,(0,_i.p)(r,"float32")),u=(0,Fo.getReductionAxes)(e.shape,i);return u.length>0?(0,Dr.X)((0,Ko.S)(a,u),e.shape):a},b:()=>{let a=(0,Jn.d)(t,(0,_i.p)(e,"float32"));const u=(0,Fo.getReductionAxes)(r.shape,i);u.length>0&&(a=(0,Dr.X)((0,Ko.S)(a,u),r.shape));const c=(0,Ou.h)(r);return(0,uc.W)((0,Ua.h)(a,(0,_i.p)(c,"float32")))}}}};var FF=y(8893),$F=y(2005);const Ent={kernelName:cn.sHE,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{const{varianceEpsilon:r}=e,[i,s,o,a]=n,u=a??(0,ju.i)(1),c=(0,Fo.getReductionAxes)(s.shape,i.shape),d=[];if(1===s.rank){for(let J=0;J<i.shape.length-1;++J)d.push(i.shape[J]);d.push(1)}const p=(0,Bl.l)(i,s),v=(0,Jn.d)(t,u),x=(0,FF.b)((0,bc.I)(o,(0,ju.i)(r))),w=(0,Jn.d)((0,Jn.d)((0,Jn.d)(x,x),x),(0,ju.i)(-.5));return{x:()=>(0,Dr.X)((0,Jn.d)((0,Jn.d)(t,1===s.rank?(0,$F.G)((0,Dr.X)(x,[1,1,1,s.shape[0]]),d):x),u),i.shape),mean:()=>{let J=(0,Jn.d)((0,Jn.d)(x,(0,ju.i)(-1)),v);return 1===s.rank&&(J=(0,Ko.S)(J,c)),(0,Dr.X)(J,s.shape)},variance:()=>{let J=(0,Jn.d)((0,Jn.d)(w,p),v);return 1===s.rank&&(J=(0,Ko.S)(J,c)),(0,Dr.X)(J,s.shape)},scale:()=>{const J=(0,Jn.d)(p,x);let ht=(0,Jn.d)(t,J);return 1===s.rank&&(ht=(0,Ko.S)(ht,c)),(0,Dr.X)(ht,s.shape)},offset:()=>{let J=t;return 1===s.rank&&(J=(0,Ko.S)(J,c)),(0,Dr.X)(J,s.shape)}}}};var Zb=y(7958),BF=y(7715);const Cnt={kernelName:cn.qi_,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{const[r,i]=n,{axis:s,batchDims:o}=e,a=(0,Os.EC)(s,r.shape)[0],u=(c,d,p)=>()=>{const v=c.shape,x=d.size,w=v.slice(0,a),b=w.length,T=v.slice(s,v.length).slice(1),N=T.length,S=zF(0,b),U=zF(b+1,b+1+N),J=VF([w,[x],T]),ht=(0,Dr.X)(p,J),Tt=(0,Dr.X)(d,[x]),Pt=VF([[b],S,U]),zt=(0,Vd.p)(ht,Pt);let Ot=(0,BF.p)(zt,Tt,c.shape[a]);const le=(0,Jh.LJ)(Pt);return Ot=(0,Vd.p)(Ot,le),Ot};if(1===o){const d=r.split(r.shape[0],0);return{x:()=>(0,Zb.k)(d.map((x,w)=>u(x,i.slice(w,1),t.slice(w,1))())).reshape(r.shape),indices:()=>i}}return{x:u(r,i,t),indices:()=>i}}};function zF(t,n){const e=[];for(let r=t;r<n;++r)e.push(r);return e}function VF(t){const n=[];for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r)n.push(t[e][r]);return n}const wnt={kernelName:cn.Acj,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>(0,Na.P)(e),b:()=>(0,Na.P)(r)}}},bnt={kernelName:cn.iJz,gradFunc:t=>({x:()=>(0,_i.p)(t,"float32")})},Int={kernelName:cn.avt,gradFunc:t=>({x:()=>(0,Na.P)(t)})},Snt={kernelName:cn.iWB,gradFunc:t=>({x:()=>(0,Na.P)(t)})},Dnt={kernelName:cn.r7n,gradFunc:t=>({x:()=>(0,Na.P)(t)})};var Sp=y(4803);const Tnt={kernelName:cn.J$2,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{alpha:i}=e,s=(0,Sp.p)(r,0);return{x:()=>(0,Qh.a)(s,t,(0,Jn.d)(t,i))}}},Nnt={kernelName:cn.kU,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ua.h)(t,(0,bc.I)(e,1))}}},Ant={kernelName:cn.ZbH,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ua.h)(t,(0,_i.p)(e,"float32"))}}},Mnt={kernelName:cn.qCd,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{axis:i}=e;return{logits:()=>{const o=(0,Rg.Q)(r);return(0,Bl.l)(t,(0,Jn.d)((0,Ko.S)(t,i,!0),o))}}}},Ont=(0,Ip.op)({localResponseNormalizationBackprop_:function Pnt(t,n,e,r=5,i=1,s=1,o=.5){return Ic.BV.runKernel(cn.Hhh,{x:t,y:n,dy:e},{depthRadius:r,bias:i,alpha:s,beta:o})}}),Rnt={kernelName:cn.eZ0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,i]=n,{depthRadius:s,bias:o,alpha:a,beta:u}=e;return{x:()=>Ont(r,i,t,s,o,a,u)}}};var UF=y(4456);function WF(t,n,e,r){return n.rank<e.rank&&(n=(0,Dr.X)(n,Jh.rv(n.shape,r))),t.rank<e.rank&&(t=(0,Dr.X)(t,Jh.rv(t.shape,r))),{x:()=>(0,Jn.d)(t,(0,_i.p)((0,UF.D)(e,n),t.dtype))}}const GF={kernelName:cn.YoZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{reductionIndices:i}=r,s=n[0],u=WF(t,n[1],s,Os.EC(i,s.shape));return{x:()=>u.x()}}};var HF=y(2761);const Lnt={kernelName:cn.BMI,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>(0,Jn.d)(t,(0,_i.p)((0,I_.b)(e,r),"float32")),b:()=>(0,Jn.d)(t,(0,_i.p)((0,HF.d)(e,r),"float32"))}}},Fnt=(0,Ip.op)({maxPool3dGrad_:function knt(t,n,e,r,i,s,o){const a=(0,qc._1)(t,"dy","maxPool3dGrad"),u=(0,qc._1)(n,"input","maxPool3dGrad"),c=(0,qc._1)(e,"output","maxPool3dGrad");let d=a,p=u,v=c,x=!1;4===u.rank&&(x=!0,d=(0,Dr.X)(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=(0,Dr.X)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),v=(0,Dr.X)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Os.hu(5===d.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),Os.hu(5===p.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),Os.hu(5===v.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${v.rank}.`),(0,qh.m)("maxPool3dGrad",s,o);const T=Ic.BV.runKernel(cn.OU7,{dy:d,input:p,output:v},{filterSize:r,strides:i,pad:s,dimRoundingMode:o});return x?(0,Dr.X)(T,[T.shape[1],T.shape[2],T.shape[3],T.shape[4]]):T}}),$nt={kernelName:cn.OAf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,i]=n,{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=e;return{x:()=>Fnt(t,r,i,s,o,a,u)}}},znt=(0,Ip.op)({maxPoolGrad_:function Bnt(t,n,e,r,i,s,o){const a=(0,qc._1)(t,"dy","maxPoolGrad"),u=(0,qc._1)(n,"input","maxPoolGrad"),c=(0,qc._1)(e,"output","maxPoolGrad");return Os.hu(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),Os.hu(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),Os.hu(4===u.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),qh.m("maxPoolGrad",s,o),Ic.BV.runKernel(cn.OV7,{dy:a,input:u,output:c},{filterSize:r,strides:i,pad:s,dimRoundingMode:o})}}),Vnt={kernelName:cn.mTV,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,i]=n,{filterSize:s,strides:o,pad:a}=e;return{x:()=>znt(t,r,i,s,o,a)}}};var Yb=y(4968);const Unt={kernelName:cn.q2K,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:i}=e,s=Os.EC(i,r.shape),a=(0,Jh.kz)(r.shape,s)[1],u=Os.NA(a);return{x:()=>{const d=r.shape.slice();s.forEach(x=>{d[x]=1});const p=(0,Dr.X)(t,d);return(0,Ua.h)((0,Jn.d)(p,(0,Yb.i)(r.shape,"float32")),u)}}}},Wnt={kernelName:cn.c17,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{axis:i}=r,[s,o]=n,u=WF(t,o,s,Os.EC(i,s.shape));return{x:()=>u.x()}}},Gnt={kernelName:cn.q8u,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>(0,Jn.d)(t,(0,_i.p)((0,S_.z)(e,r),"float32")),b:()=>(0,Jn.d)(t,(0,_i.p)((0,Sp.p)(e,r),"float32"))}}};var Ud=y(8317);const Hnt={kernelName:cn.jQs,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:i}=e,s=i.map(o=>o[0]);return{x:()=>(0,Ud.t)(t,s,r.shape)}}};var jF=y(8208);const jnt={kernelName:cn.Vbg,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,Fo.assertAndGetBroadcastShape)(e.shape,r.shape);return{a:()=>{const a=(0,Fo.getReductionAxes)(e.shape,i);return a.length>0?(0,Dr.X)((0,Ko.S)(t,a),e.shape):t},b:()=>{const a=(0,Jn.d)(t,(0,uc.W)((0,jF.G)((0,Ua.h)(e,r)))),u=(0,Fo.getReductionAxes)(r.shape,i);return u.length>0?(0,Dr.X)((0,Ko.S)(a,u),r.shape):a}}}},Knt={kernelName:cn.wYn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,Fo.assertAndGetBroadcastShape)(e.shape,r.shape);return{a:()=>{const a=(0,Jn.d)(t,(0,_i.p)(r,"float32")),u=(0,Fo.getReductionAxes)(e.shape,i);return u.length>0?(0,Dr.X)((0,Ko.S)(a,u),e.shape):a},b:()=>{const a=(0,Jn.d)(t,(0,_i.p)(e,"float32")),u=(0,Fo.getReductionAxes)(r.shape,i);return u.length>0?(0,Dr.X)((0,Ko.S)(a,u),r.shape):a}}}},Xnt={kernelName:cn.kuV,gradFunc:t=>({x:()=>(0,uc.W)(t)})};var Znt=y(6467);const Ynt={kernelName:cn.we_,inputsToSave:["indices"],gradFunc:(t,n)=>{const e=n[0];return{indices:()=>(0,Znt.l)(e.shape,"float32")}}},qnt={kernelName:cn.qWM,gradFunc:t=>({x:()=>(0,Na.P)(t)})};var KF=y(2219);const Qnt={kernelName:cn.QiL,saveAllInputs:!0,gradFunc:(t,n,e)=>{const{axis:r}=e;return(0,KF.H)(t,r).map(s=>()=>s)}},XF={kernelName:cn.lyA,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:i}=e,s=i.map(o=>o[0]);return{x:()=>(0,Ud.t)(t,s,r.shape)}}};var ZF=y(5919),qb=y(2962);const Jnt={kernelName:cn.pe_,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,n)=>{const[e,r,i]=n,s=e,o=r,a=Fo.assertAndGetBroadcastShape(s.shape,o.shape);return{a:()=>{const d=(0,_i.p)(o,"float32");let p=(0,Jn.d)(t,(0,Jn.d)(d,(0,qb.s)(s,(0,Bl.l)(d,(0,ju.i)(1)))));const v=Fo.getReductionAxes(s.shape,a);return v.length>0&&(p=(0,Ko.S)(p,v)),(0,Dr.X)(p,s.shape)},b:()=>{const d=(0,Sp.p)(s,0),p=(0,Qh.a)(d,(0,ZF.c)(s),(0,Na.P)(s));let v=(0,Jn.d)(t,(0,Jn.d)(i,p));const x=Fo.getReductionAxes(o.shape,a);return x.length>0&&(v=(0,Ko.S)(v,x)),(0,Dr.X)(v,o.shape)}}}},trt={kernelName:cn.o0g,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,Sp.p)(e,0);return{x:()=>(0,Qh.a)(i,t,(0,Jn.d)(t,r)),alpha:()=>{let s=(0,Qh.a)(i,(0,Na.P)(t),(0,Jn.d)(t,e));const o=(0,Fo.getReductionAxes)(r.shape,t.shape);return o.length>0&&(s=(0,Ko.S)(s,o)),(0,Dr.X)(s,r.shape)}}}};var Qb=y(9267);const rrt={kernelName:cn.DlI,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:i}=e;let s=[];return s=null==i?r.shape.map((o,a)=>a):"number"==typeof i?[i]:i,{x:()=>function nrt(t,n,e){const r=t.shape.length,i=r-e.length,s=Jh.Q3(e,r);let o=t;null!=s&&(o=(0,Vd.p)(t,s));const a=o.shape.slice(),c=a.splice(r-e.length,e.length).reduce((v,x)=>v*x,1);a.push(c);let p=function ert(t,n,e){const r=t.shape.slice();r[e]=1;const i=(0,Dr.X)(n,r),s=(0,Qb.$)(t,e,!0,!1),o=(0,Qb.$)(t,e,!0,!0),a=(0,Jn.d)(s,o);return(0,Jn.d)(i,a)}(o.reshape(a),n,i);if(p=p.reshape(o.shape),null!=s){const v=Jh.LJ(s);p=(0,Vd.p)(p,v)}return p}(r,t,s)}}},irt={kernelName:cn.oHH,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=Fo.assertAndGetBroadcastShape(e.shape,r.shape);return{a:()=>{const a=(0,Ua.h)(t,(0,_i.p)(r,"float32")),u=Fo.getReductionAxes(e.shape,i);return u.length>0?(0,Dr.X)((0,Ko.S)(a,u),e.shape):a},b:()=>{let a=(0,Jn.d)(t,(0,_i.p)(e,"float32"));const u=Fo.getReductionAxes(r.shape,i);u.length>0&&(a=(0,Dr.X)((0,Ko.S)(a,u),r.shape));const c=(0,Ou.h)(r);return(0,uc.W)((0,Ua.h)(a,(0,_i.p)(c,"float32")))}}}},srt={kernelName:cn.$HU,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ua.h)(t,(0,uc.W)((0,Ou.h)(e)))}}},ort={kernelName:cn.SbG,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=(0,Jn.d)((0,S_.z)(e,6),(0,b_.N)(e));return{x:()=>(0,Jn.d)(t,(0,_i.p)(r,"float32"))}}},art={kernelName:cn.qkr,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,_i.p)((0,b_.N)(e),"float32"))}}},urt={kernelName:cn.HZH,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Dr.X)(t,e.shape)}}},lrt={kernelName:cn._Yw,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,i={dy:t,images:r};return{images:()=>Ic.BV.runKernel(cn.zbQ,i,e)}}},crt={kernelName:cn.dpD,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,i={dy:t,images:r};return{images:()=>Ic.BV.runKernel(cn.Hmb,i,e)}}};var YF=y(6825);const hrt={kernelName:cn.mKl,gradFunc:(t,n,e)=>{const{dims:r}=e,i=(0,Os.EC)(r,t.shape);return{x:()=>(0,YF.G)(t,i)}}},drt={kernelName:cn.e07,gradFunc:t=>({x:()=>(0,Na.P)(t)})},frt={kernelName:cn.bV0,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,uc.W)((0,Ua.h)(t,(0,Jn.d)((0,qb.s)(e,1.5),2)))}}};var qF=y(6399);const prt={kernelName:cn.PhF,inputsToSave:["condition"],gradFunc:(t,n)=>{const[e]=n;return{condition:()=>(0,_i.p)((0,Na.P)(e),"float32"),t:()=>(0,Jn.d)(t,(0,_i.p)(e,t.dtype)),e:()=>(0,Jn.d)(t,(0,_i.p)((0,qF.h)(e),t.dtype))}}};var QF=y(2152);const mrt={kernelName:cn.oFR,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=(0,Sp.p)(e,(0,ju.i)(0)),i=(0,ju.i)(QF.y),s=(0,ju.i)(QF.$),o=(0,Jn.d)(t,s),a=(0,Jn.d)((0,Jn.d)(t,i),(0,Rg.Q)((0,_i.p)(e,"float32")));return(0,Qh.a)(r,o,a)}}}},grt={kernelName:cn.a5O,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,Jn.d)(e,(0,Bl.l)((0,ju.i)(1),e)))}}},yrt={kernelName:cn.i5y,gradFunc:t=>({x:()=>(0,Na.P)(t)})};var Jb=y(9018);const vrt={kernelName:cn.RQH,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,Jb.m)((0,_i.p)(e,"float32")),t)}}};var JF=y(3237);const _rt={kernelName:cn.wYB,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,JF.f)((0,_i.p)(e,"float32")),t)}}};var t$=y(404),xrt=y(2320);const Ert={kernelName:cn.p2w,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{begin:i,size:s}=e,o=r.shape,[a,u]=(0,xrt.parseSliceParams)(r,i,s),c=[];for(let d=0;d<t.rank;d++)c.push([a[d],o[d]-a[d]-u[d]]);return{x:()=>(0,t$.v)(t,c)}}},Crt={kernelName:cn.Gcp,outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{dim:i}=e,o=(0,Jn.d)(t,r);return{logits:()=>(0,Bl.l)(o,(0,Jn.d)((0,Ko.S)(o,[i],!0),r))}}};var e$=y(6139);const wrt={kernelName:cn.MRv,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,e$.X)(e))}}};var n$=y(2782);const r$={kernelName:cn.TQc,gradFunc:(t,n,e)=>{const{blockShape:r,paddings:i}=e;return{x:()=>(0,n$.E)(t,r,i)}}};var i$=y(4111);const s$={kernelName:cn.L8s,gradFunc:(t,n,e)=>{const{axis:r}=e;return{x:()=>(0,i$.z)(t,r)}}},brt={kernelName:cn.FKq,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ua.h)(t,(0,Jn.d)((0,bp._)((0,_i.p)(e,"float32")),2))}}},Irt={kernelName:cn.bK0,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,Jn.d)((0,_i.p)(e,"float32"),2))}}},Srt={kernelName:cn._tC,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,ju.i)(2);return{a:()=>(0,Jn.d)(t,(0,Jn.d)(i,(0,Bl.l)(e,r))),b:()=>(0,Jn.d)(t,(0,Jn.d)(i,(0,Bl.l)(r,e)))}}},Drt={kernelName:cn.h8e,gradFunc:t=>({x:()=>(0,Na.P)(t)})},Trt={kernelName:cn.Tr8,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=Fo.assertAndGetBroadcastShape(e.shape,r.shape);return{a:()=>{let a=t;const u=Fo.getReductionAxes(e.shape,i);return u.length>0&&(a=(0,Ko.S)(a,u)),(0,Dr.X)(a,e.shape)},b:()=>{let a=t;const u=Fo.getReductionAxes(r.shape,i);return u.length>0&&(a=(0,Ko.S)(a,u)),(0,Dr.X)((0,uc.W)(a),r.shape)}}}},Nrt={kernelName:cn.GBy,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,i=r.shape.slice(),{axis:s}=e;(0,Os.EC)(s,r.shape).forEach(c=>{i[c]=1});const a=(0,Dr.X)(t,i),u=(0,Jn.d)(a,(0,Yb.i)(r.shape,"float32"));return{x:()=>u}}},Art={kernelName:cn.sEM,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ua.h)(t,(0,Ou.h)((0,Jb.m)(e)))}}},Mrt={kernelName:cn.MIZ,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,Bl.l)((0,ju.i)(1),(0,Ou.h)(e)),t)}}},Prt={kernelName:cn.n9L,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{reps:i}=e;return{x:()=>{let o=(0,Na.P)(r);if(1===r.rank)for(let a=0;a<i[0];++a)o=(0,bc.I)(o,(0,Ud.t)(t,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)o=(0,bc.I)(o,(0,Ud.t)(t,[a*r.shape[0],u*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)for(let c=0;c<i[2];++c)o=(0,bc.I)(o,(0,Ud.t)(t,[a*r.shape[0],u*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)for(let c=0;c<i[2];++c)for(let d=0;d<i[3];++d)o=(0,bc.I)(o,(0,Ud.t)(t,[a*r.shape[0],u*r.shape[1],c*r.shape[2],d*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return o}}}},Ort={kernelName:cn.G3Y,gradFunc:(t,n,e)=>{const r=e,{perm:i}=r,s=Jh.LJ(i);return{x:()=>(0,Vd.p)(t,s)}}},Rrt={kernelName:cn.ToN,gradFunc:(t,n,e)=>{const r=e,{axis:i}=r;return{value:()=>(0,Zb.k)(t,i)}}};var o$=y(7228),a$=y(6117),u$=y(765);const Lrt={kernelName:cn.Qvg,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>function krt(t,n){const e=(0,u$.g)(n,(0,Na.P)(n)),r=(0,a$.I)(t,e);let i=(0,I_.b)(n,(0,ju.i)(0,"int32"));const s=r.rank-i.rank;for(let a=0;a<s;++a)i=(0,o$.d)(i,a+1);i=(0,Xb.H)(i,(0,Yb.i)(r.shape,"bool"));const o=(0,Na.P)(r);return(0,Qh.a)(i,r,o)}(t,e)}}},Frt={kernelName:cn.RuY,gradFunc:t=>({x:()=>(0,Na.P)(t)})};var $rt=y(8987);const Brt=[NF,Net,Aet,Met,Pet,Oet,Ret,Let,ket,Fet,$et,Bet,Uet,Het,jet,Ket,Xet,Zet,Yet,qet,Qet,Jet,nnt,ent,ont,ant,unt,lnt,dnt,fnt,irt,pnt,mnt,gnt,ynt,vnt,xnt,_nt,Ent,Cnt,wnt,bnt,Int,Snt,Dnt,Tnt,Nnt,Ant,Mnt,Rnt,GF,GF,Lnt,$nt,Vnt,Unt,Wnt,Gnt,Hnt,jnt,Knt,Xnt,Ynt,qnt,Qnt,XF,XF,Jnt,trt,rrt,srt,ort,art,urt,lrt,crt,hrt,drt,frt,prt,mrt,grt,yrt,vrt,_rt,Ert,Crt,wrt,r$,r$,s$,s$,brt,Srt,Irt,Drt,Trt,Nrt,Art,Mrt,Prt,Ort,Rrt,Lrt,Frt];for(const t of Brt)(0,$rt.Li)(t);var zrt=y(6989),Ze=y(4945);(0,Ze.t3)().prototype.abs=function(){return this.throwIfDisposed(),(0,zrt.W)(this)};var Vrt=y(1184);(0,Ze.t3)().prototype.acos=function(){return this.throwIfDisposed(),(0,Vrt.K)(this)};var Urt=y(5622);(0,Ze.t3)().prototype.acosh=function(){return this.throwIfDisposed(),(0,Urt._)(this)},(0,Ze.t3)().prototype.add=function(t){return this.throwIfDisposed(),(0,bc.I)(this,t)};var Wrt=y(1862);(0,Ze.t3)().prototype.all=function(t,n){return this.throwIfDisposed(),(0,Wrt.$)(this,t,n)};var Grt=y(876);(0,Ze.t3)().prototype.any=function(t,n){return this.throwIfDisposed(),(0,Grt.Y)(this,t,n)};var Hrt=y(5784);(0,Ze.t3)().prototype.argMax=function(t){return this.throwIfDisposed(),(0,Hrt.N)(this,t)};var jrt=y(8340);(0,Ze.t3)().prototype.argMin=function(t){return this.throwIfDisposed(),(0,jrt.v)(this,t)},(0,Ze.t3)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,Os.hu)(1===this.size,()=>"The array must have only 1 element."),(0,Dr.X)(this,[])},(0,Ze.t3)().prototype.asType=function(t){return this.throwIfDisposed(),(0,_i.p)(this,t)},(0,Ze.t3)().prototype.as1D=function(){return this.throwIfDisposed(),(0,Dr.X)(this,[this.size])},(0,Ze.t3)().prototype.as2D=function(t,n){return this.throwIfDisposed(),(0,Dr.X)(this,[t,n])},(0,Ze.t3)().prototype.as3D=function(t,n,e){return this.throwIfDisposed(),(0,Dr.X)(this,[t,n,e])},(0,Ze.t3)().prototype.as4D=function(t,n,e,r){return this.throwIfDisposed(),(0,Dr.X)(this,[t,n,e,r])},(0,Ze.t3)().prototype.as5D=function(t,n,e,r,i){return this.throwIfDisposed(),(0,Dr.X)(this,[t,n,e,r,i])};var Krt=y(586);(0,Ze.t3)().prototype.asin=function(){return this.throwIfDisposed(),(0,Krt.Z)(this)};var Xrt=y(8355);(0,Ze.t3)().prototype.asinh=function(){return this.throwIfDisposed(),(0,Xrt.V)(this)};var Zrt=y(7881);(0,Ze.t3)().prototype.atan=function(){return this.throwIfDisposed(),(0,Zrt.z)(this)};var Yrt=y(5825);(0,Ze.t3)().prototype.atan2=function(t){return this.throwIfDisposed(),(0,Yrt.f)(this,t)};var qrt=y(7932);(0,Ze.t3)().prototype.atanh=function(){return this.throwIfDisposed(),(0,qrt.C)(this)};var Qrt=y(6903);(0,Ze.t3)().prototype.avgPool=function(t,n,e,r){return this.throwIfDisposed(),(0,Qrt.w)(this,t,n,e,r)},(0,Ze.t3)().prototype.batchToSpaceND=function(t,n){return this.throwIfDisposed(),(0,n$.E)(this,t,n)};var Jrt=y(5307);(0,Ze.t3)().prototype.batchNorm=function(t,n,e,r,i){return this.throwIfDisposed(),(0,Jrt.t)(this,t,n,e,r,i)};var tit=y(983);(0,Ze.t3)().prototype.broadcastTo=function(t){return this.throwIfDisposed(),(0,tit.U)(this,t)},(0,Ze.t3)().prototype.cast=function(t){return this.throwIfDisposed(),(0,_i.p)(this,t)};var eit=y(9723);(0,Ze.t3)().prototype.ceil=function(){return this.throwIfDisposed(),(0,eit.m)(this)};var nit=y(6672);(0,Ze.t3)().prototype.clipByValue=function(t,n){return this.throwIfDisposed(),(0,nit.i)(this,t,n)},(0,Ze.t3)().prototype.concat=function(t,n){return this.throwIfDisposed(),t instanceof Ze.es&&(t=[t]),(0,i$.z)([this,...t],n)};var rit=y(8577);(0,Ze.t3)().prototype.conv1d=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,rit.P)(this,t,n,e,r,i,s)};var iit=y(8554);(0,Ze.t3)().prototype.conv2dTranspose=function(t,n,e,r,i){return this.throwIfDisposed(),(0,iit.b)(this,t,n,e,r,i)},(0,Ze.t3)().prototype.conv2d=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,OF.T)(this,t,n,e,r,i,s)},(0,Ze.t3)().prototype.cos=function(){return this.throwIfDisposed(),(0,Jb.m)(this)},(0,Ze.t3)().prototype.cosh=function(){return this.throwIfDisposed(),(0,JF.f)(this)},(0,Ze.t3)().prototype.cumprod=function(t,n,e){return this.throwIfDisposed(),(0,Qb.$)(this,t,n,e)},(0,Ze.t3)().prototype.cumsum=function(t,n,e){return this.throwIfDisposed(),(0,kF.z)(this,t,n,e)};var sit=y(3961);(0,Ze.t3)().prototype.depthToSpace=function(t,n){return this.throwIfDisposed(),(0,sit.n)(this,t,n)};var oit=y(1172);(0,Ze.t3)().prototype.depthwiseConv2d=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,oit.B)(this,t,n,e,r,i,s)};var ait=y(2395);(0,Ze.t3)().prototype.dilation2d=function(t,n,e,r,i){return this.throwIfDisposed(),(0,ait.W)(this,t,n,e,r,i)};var uit=y(4373);(0,Ze.t3)().prototype.divNoNan=function(t){return this.throwIfDisposed(),(0,uit.N)(this,t)},(0,Ze.t3)().prototype.div=function(t){return this.throwIfDisposed(),(0,Ua.h)(this,t)};var lit=y(5106);(0,Ze.t3)().prototype.dot=function(t){return this.throwIfDisposed(),(0,lit.A)(this,t)};var cit=y(9529);(0,Ze.t3)().prototype.elu=function(){return this.throwIfDisposed(),(0,cit.p)(this)},(0,Ze.t3)().prototype.equal=function(t){return this.throwIfDisposed(),(0,UF.D)(this,t)};var hit=y(4634);(0,Ze.t3)().prototype.erf=function(){return this.throwIfDisposed(),(0,hit.q)(this)};var dit=y(4279);(0,Ze.t3)().prototype.euclideanNorm=function(t,n){return this.throwIfDisposed(),(0,dit.d)(this,t,n)},(0,Ze.t3)().prototype.exp=function(){return this.throwIfDisposed(),(0,Rg.Q)(this)},(0,Ze.t3)().prototype.expandDims=function(t){return this.throwIfDisposed(),(0,o$.d)(this,t)};var fit=y(5748);(0,Ze.t3)().prototype.expm1=function(){return this.throwIfDisposed(),(0,fit.t)(this)};var pit=y(9738);(0,Ze.t3)().prototype.fft=function(){return this.throwIfDisposed(),(0,pit.k)(this)},(0,Ze.t3)().prototype.flatten=function(){return this.throwIfDisposed(),(0,Dr.X)(this,[this.size])},(0,Ze.t3)().prototype.floor=function(){return this.throwIfDisposed(),(0,jF.G)(this)};var mit=y(1030);(0,Ze.t3)().prototype.floorDiv=function(t){return this.throwIfDisposed(),(0,mit.q)(this,t)},(0,Ze.t3)().prototype.gather=function(t,n,e){return this.throwIfDisposed(),(0,a$.I)(this,t,n,e)},(0,Ze.t3)().prototype.greaterEqual=function(t){return this.throwIfDisposed(),(0,I_.b)(this,t)},(0,Ze.t3)().prototype.greater=function(t){return this.throwIfDisposed(),(0,Sp.p)(this,t)};var git=y(527);(0,Ze.t3)().prototype.ifft=function(){return this.throwIfDisposed(),(0,git.S)(this)};var yit=y(6065);(0,Ze.t3)().prototype.irfft=function(){return this.throwIfDisposed(),(0,yit.w)(this)};var vit=y(8821);(0,Ze.t3)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,vit.x)(this)};var _it=y(8381);(0,Ze.t3)().prototype.isInf=function(){return this.throwIfDisposed(),(0,_it.U)(this)};var xit=y(6483);(0,Ze.t3)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,xit.i)(this)};var Eit=y(9424);(0,Ze.t3)().prototype.leakyRelu=function(t){return this.throwIfDisposed(),(0,Eit.h)(this,t)},(0,Ze.t3)().prototype.lessEqual=function(t){return this.throwIfDisposed(),(0,S_.z)(this,t)},(0,Ze.t3)().prototype.less=function(t){return this.throwIfDisposed(),(0,HF.d)(this,t)};var Cit=y(1523);(0,Ze.t3)().prototype.localResponseNormalization=function(t,n,e,r){return this.throwIfDisposed(),(0,Cit.G)(this,t,n,e,r)};var wit=y(4034);(0,Ze.t3)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,wit.e)(this)};var bit=y(6455);(0,Ze.t3)().prototype.logSoftmax=function(t){return this.throwIfDisposed(),(0,bit.C)(this,t)};var Iit=y(6735);(0,Ze.t3)().prototype.logSumExp=function(t,n){return this.throwIfDisposed(),(0,Iit.l)(this,t,n)},(0,Ze.t3)().prototype.log=function(){return this.throwIfDisposed(),(0,ZF.c)(this)};var Sit=y(4088);(0,Ze.t3)().prototype.log1p=function(){return this.throwIfDisposed(),(0,Sit.K)(this)},(0,Ze.t3)().prototype.logicalAnd=function(t){return this.throwIfDisposed(),(0,Xb.H)(this,t)},(0,Ze.t3)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,qF.h)(this)};var Dit=y(2693);(0,Ze.t3)().prototype.logicalOr=function(t){return this.throwIfDisposed(),(0,Dit.K)(this,t)};var Tit=y(4574);(0,Ze.t3)().prototype.logicalXor=function(t){return this.throwIfDisposed(),(0,Tit.e)(this,t)},(0,Ze.t3)().prototype.matMul=function(t,n,e){return this.throwIfDisposed(),(0,Sh.O)(this,t,n,e)};var Nit=y(2444);(0,Ze.t3)().prototype.maxPool=function(t,n,e,r){return this.throwIfDisposed(),(0,Nit._)(this,t,n,e,r)};var Ait=y(3043);(0,Ze.t3)().prototype.max=function(t,n){return this.throwIfDisposed(),(0,Ait.F)(this,t,n)},(0,Ze.t3)().prototype.maximum=function(t){return this.throwIfDisposed(),(0,u$.g)(this,t)};var Mit=y(9357);(0,Ze.t3)().prototype.mean=function(t,n){return this.throwIfDisposed(),(0,Mit.J)(this,t,n)};var Pit=y(9602);(0,Ze.t3)().prototype.min=function(t,n){return this.throwIfDisposed(),(0,Pit.V)(this,t,n)};var Oit=y(2684);(0,Ze.t3)().prototype.minimum=function(t){return this.throwIfDisposed(),(0,Oit.L)(this,t)};var Rit=y(4639);(0,Ze.t3)().prototype.mirrorPad=function(t,n){return this.throwIfDisposed(),(0,Rit.V)(this,t,n)};var Lit=y(1612);(0,Ze.t3)().prototype.mod=function(t){return this.throwIfDisposed(),(0,Lit.w)(this,t)},(0,Ze.t3)().prototype.mul=function(t){return this.throwIfDisposed(),(0,Jn.d)(this,t)},(0,Ze.t3)().prototype.neg=function(){return this.throwIfDisposed(),(0,uc.W)(this)};var kit=y(3717);(0,Ze.t3)().prototype.norm=function(t,n,e){return this.throwIfDisposed(),(0,kit.K)(this,t,n,e)};var Fit=y(4015);(0,Ze.t3)().prototype.notEqual=function(t){return this.throwIfDisposed(),(0,Fit.Q)(this,t)};var $it=y(5618);(0,Ze.t3)().prototype.oneHot=function(t,n=1,e=0){return this.throwIfDisposed(),(0,$it.l)(this,t,n,e)};var Bit=y(5034);(0,Ze.t3)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,Bit.J)(this)},(0,Ze.t3)().prototype.pad=function(t,n){return this.throwIfDisposed(),(0,t$.v)(this,t,n)};var zit=y(1640);(0,Ze.t3)().prototype.pool=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,zit.d)(this,t,n,e,r,i,s)},(0,Ze.t3)().prototype.pow=function(t){return this.throwIfDisposed(),(0,qb.s)(this,t)};var Vit=y(1584);(0,Ze.t3)().prototype.prelu=function(t){return this.throwIfDisposed(),(0,Vit.A)(this,t)};var Uit=y(794);(0,Ze.t3)().prototype.prod=function(t,n){return this.throwIfDisposed(),(0,Uit.W)(this,t,n)};var Wit=y(4831);(0,Ze.t3)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,Wit.M)(this)};var Git=y(8586);(0,Ze.t3)().prototype.relu=function(){return this.throwIfDisposed(),(0,Git.U)(this)};var Hit=y(4917);(0,Ze.t3)().prototype.relu6=function(){return this.throwIfDisposed(),(0,Hit.b)(this)},(0,Ze.t3)().prototype.reshapeAs=function(t){return this.throwIfDisposed(),(0,Dr.X)(this,t.shape)},(0,Ze.t3)().prototype.reshape=function(t){return this.throwIfDisposed(),(0,Dr.X)(this,t)};var jit=y(1265);(0,Ze.t3)().prototype.resizeBilinear=function(t,n,e){return this.throwIfDisposed(),(0,jit.I)(this,t,n,e)};var Kit=y(7373);(0,Ze.t3)().prototype.resizeNearestNeighbor=function(t,n,e){return this.throwIfDisposed(),(0,Kit.j)(this,t,n,e)},(0,Ze.t3)().prototype.reverse=function(t){return this.throwIfDisposed(),(0,YF.G)(this,t)};var Xit=y(1638);(0,Ze.t3)().prototype.rfft=function(){return this.throwIfDisposed(),(0,Xit.Q)(this)};var Zit=y(1974);(0,Ze.t3)().prototype.round=function(){return this.throwIfDisposed(),(0,Zit.N)(this)},(0,Ze.t3)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,FF.b)(this)};var Yit=y(9614);(0,Ze.t3)().prototype.selu=function(){return this.throwIfDisposed(),(0,Yit.U)(this)};var qit=y(6762);(0,Ze.t3)().prototype.separableConv2d=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,qit.U)(this,t,n,e,r,i,s)},(0,Ze.t3)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,e$.X)(this)};var Qit=y(4058);(0,Ze.t3)().prototype.sign=function(){return this.throwIfDisposed(),(0,Qit.X)(this)},(0,Ze.t3)().prototype.sin=function(){return this.throwIfDisposed(),(0,RF.O)(this)},(0,Ze.t3)().prototype.sinh=function(){return this.throwIfDisposed(),(0,LF.R)(this)},(0,Ze.t3)().prototype.slice=function(t,n){return this.throwIfDisposed(),(0,Ud.t)(this,t,n)};var Jit=y(8683);(0,Ze.t3)().prototype.softmax=function(t){return this.throwIfDisposed(),(0,Jit.X)(this,t)};var tst=y(4487);(0,Ze.t3)().prototype.softplus=function(){return this.throwIfDisposed(),(0,tst.W)(this)},(0,Ze.t3)().prototype.spaceToBatchND=function(t,n){return this.throwIfDisposed(),(0,AF.f)(this,t,n)},(0,Ze.t3)().prototype.split=function(t,n){return this.throwIfDisposed(),(0,MF.V)(this,t,n)},(0,Ze.t3)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,bp._)(this)},(0,Ze.t3)().prototype.square=function(){return this.throwIfDisposed(),(0,Ou.h)(this)};var est=y(9539);(0,Ze.t3)().prototype.squaredDifference=function(t){return this.throwIfDisposed(),(0,est.$)(this,t)};var nst=y(2494);(0,Ze.t3)().prototype.squeeze=function(t){return this.throwIfDisposed(),(0,nst.L)(this,t)},(0,Ze.t3)().prototype.stack=function(t,n){this.throwIfDisposed();const e=t instanceof Ze.es?[this,t]:[this,...t];return(0,Zb.k)(e,n)},(0,Ze.t3)().prototype.step=function(t){return this.throwIfDisposed(),(0,b_.N)(this,t)};var rst=y(5367);(0,Ze.t3)().prototype.stridedSlice=function(t,n,e,r,i,s,o,a){return this.throwIfDisposed(),(0,rst.N)(this,t,n,e,r,i,s,o,a)},(0,Ze.t3)().prototype.sub=function(t){return this.throwIfDisposed(),(0,Bl.l)(this,t)},(0,Ze.t3)().prototype.sum=function(t,n){return this.throwIfDisposed(),(0,Ko.S)(this,t,n)};var ist=y(2500);(0,Ze.t3)().prototype.tan=function(){return this.throwIfDisposed(),(0,ist.O)(this)};var sst=y(5987);(0,Ze.t3)().prototype.tanh=function(){return this.throwIfDisposed(),(0,sst.A)(this)},(0,Ze.t3)().prototype.tile=function(t){return this.throwIfDisposed(),(0,$F.G)(this,t)},(0,Ze.t3)().prototype.toBool=function(){return this.throwIfDisposed(),(0,_i.p)(this,"bool")},(0,Ze.t3)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,_i.p)(this,"float32")},(0,Ze.t3)().prototype.toInt=function(){return this.throwIfDisposed(),(0,_i.p)(this,"int32")};var ost=y(4927);(0,Ze.t3)().prototype.topk=function(t,n){return this.throwIfDisposed(),(0,ost.h)(this,t,n)},(0,Ze.t3)().prototype.transpose=function(t){return this.throwIfDisposed(),(0,Vd.p)(this,t)};var ast=y(8130);(0,Ze.t3)().prototype.unique=function(t){return this.throwIfDisposed(),(0,ast.T)(this,t)},(0,Ze.t3)().prototype.unsortedSegmentSum=function(t,n){return this.throwIfDisposed(),(0,BF.p)(this,t,n)},(0,Ze.t3)().prototype.unstack=function(t){return this.throwIfDisposed(),(0,KF.H)(this,t)},(0,Ze.t3)().prototype.where=function(t,n){return this.throwIfDisposed(),(0,Qh.a)(t,this,n)},(0,Ze.t3)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,Na.P)(this)};class Qc extends Error{constructor(n){super(n),Object.setPrototypeOf(this,Qc.prototype)}}class lc extends Error{constructor(n){super(n),Object.setPrototypeOf(this,lc.prototype)}}class we extends Error{constructor(n){super(n),Object.setPrototypeOf(this,we.prototype)}}class ci extends Error{constructor(n){super(n),Object.setPrototypeOf(this,ci.prototype)}}class tI extends Error{constructor(n){super(n),Object.setPrototypeOf(this,tI.prototype)}}class c${constructor(n){this.maxEntries=n||100,this.cache=new Map}get(n){let e;return this.cache.has(n)&&(e=this.cache.get(n),this.cache.delete(n),this.cache.set(n,e)),e}put(n,e){if(this.cache.has(n))this.cache.delete(n);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(n,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(n){if(n<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${n}.`);if(this.maxEntries>n)for(let e=0;e<this.maxEntries-n;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=n}}function Wd(t,n){if(Array.isArray(t)){let e=[];for(let r=0;r<n;r++)e=e.concat(t);return e}{const e=new Array(n);return e.fill(t),e}}function zl(t,n){if(!t)throw new tI(n)}function h$(t,n){let e=0;for(const r of t)r===n&&e++;return e}function hl(t){return 1===t.length?t[0]:t}function Gs(t){return Array.isArray(t)?t:[t]}function Dh(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Gd(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(n,e)=>e.toUpperCase())}let cc={};function eI(t){if(null==t)return null;const n={};return n.className=t.getClassName(),n.config=t.getConfig(),n}function nI(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(n=>nI(n));else{const n=Object.keys(t);for(const e of n){const r=t[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?nI(r):t[e]=r.value)}}}function Lg(t,n={},e={},r="object",i=!1){if("string"==typeof t){let o;if(t in e)o=e[t];else if(t in cc)o=cc[t];else if(o=n[t],null==o)throw new we(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const s=t;if(null==s.className||null==s.config)throw new we(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const o=s.className;let a,u;if(o in e?[a,u]=e[o]:o in cc?[a,u]=cc.className:o in n&&([a,u]=n[o]),null==a)throw new we(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const c={};for(const x of Object.keys(cc))c[x]=cc[x];for(const x of Object.keys(e))c[x]=e[x];s.config.customObjects=c;const p=Object.assign({},cc);for(const x of Object.keys(e))cc[x]=e[x];nI(s.config);const v=u(a,s.config,e,i);return cc=Object.assign({},p),v}{const c=Object.assign({},cc);for(const p of Object.keys(e))cc[p]=e[p];const d=new a(s.config);return cc=Object.assign({},c),d}}}function D_(t,n){return-1*function ust(t,n){return t<n?-1:t>n?1:0}(t,n)}function td(t){if(null==t)return t;const n=[];for(const e of t)-1===n.indexOf(e)&&n.push(e);return n}function lst(t){if(null==t)throw new we(`Invalid value in obj: ${JSON.stringify(t)}`);for(const n in t)if(t.hasOwnProperty(n))return!1;return!0}function Hd(t,n,e){if(null!=e&&t.indexOf(e)<0)throw new we(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}function rI(t,n,e=0,r=1/0){return zl(e>=0),zl(r>=e),Array.isArray(t)&&t.length>=e&&t.length<=r&&t.every(i=>typeof i===n)}function du(t,n){Array.isArray(t)?(g.util.assert(t.length>0,()=>`${n} is unexpectedly an empty array.`),t.forEach((e,r)=>du(e,`element ${r+1} of ${n}`))):g.util.assert(Number.isInteger(t)&&t>0,()=>`Expected ${n} to be a positive integer, but got ${d$(t)}.`)}function d$(t){return null===t?"null":Array.isArray(t)?"["+t.map(n=>d$(n)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function f$(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let hst=0;function p$(){return hst++}const T_={};function N_(t=""){return t in T_||(T_[t]=0),T_[t]+=1,t+T_[t].toString()}const dst=["channelsFirst","channelsLast"],fst=["nearest","bilinear"],pst=["valid","same","causal"],mst=["max","avg"],gst=["sum","mul","concat","ave"],Dp=new Map;function Aa(t){Hd(dst,"DataFormat",t)}function Vl(t){Hd(pst,"PaddingMode",t)}function m$(t){Hd(mst,"PoolMode",t)}const kg=[];function jd(t,n){kg.push(t);try{const e=n();return kg.pop(),e}catch(e){throw kg.pop(),e}}function y$(t){if(!_$(t))throw new Error("Not a valid tensor name: '"+t+"'");return function vst(){return 0===kg.length?"":kg.join("/")+"/"}()+t}function v$(t){if(!_$(t))throw new Error("Not a valid tensor name: '"+t+"'");Dp.has(t)||Dp.set(t,0);const n=Dp.get(t);if(Dp.set(t,Dp.get(t)+1),n>0){const e=`${t}_${n}`;return Dp.set(e,1),e}return t}const _st=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function _$(t){return!!t.match(_st)}function xst(t){return t===parseInt(t.toString(),10)}function ed(t,n,e){null==n&&(n=0),null==e&&(e=t.length);let r=1;for(let i=n;i<e;++i)r*=t[i];return r}function Tp(t){if(0===t.length)return Number.NaN;let n=Number.POSITIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e];r<n&&(n=r)}return n}function nd(t){if(0===t.length)return Number.NaN;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e];r>n&&(n=r)}return n}function Sc(t,n){if(n<t)throw new we(`end (${n}) < begin (${t}) is forbidden.`);const e=[];for(let r=t;r<n;++r)e.push(r);return e}let A_;function qa(){return null==A_&&(A_=(0,g.backend)().epsilon()),A_}function Jc(t,n){return g.cast(t,n)}function Fg(t,n=-1){const e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),g.reshape(t,e)}function Kd(t,n,e){return(0,g.tidy)(()=>{switch(t.rank){case 1:return g.slice1d(t,n,e);case 2:return g.slice2d(t,[n,0],[e,t.shape[1]]);case 3:return g.slice3d(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return g.slice4d(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return g.slice(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return g.slice(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new we(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function iI(t,n,e){return(0,g.tidy)(()=>{switch(t.rank){case 1:return g.slice1d(t,n,e);case 2:return g.slice2d(t,[0,n],[t.shape[0],e]);case 3:return g.slice3d(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return g.slice4d(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new we(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function M_(t,n,e,r){return(0,g.tidy)(()=>{switch(t.rank){case 1:return g.slice1d(t,n,e);case 2:switch(r){case 1:return Kd(t,n,e);case 2:return iI(t,n,e);default:throw new we(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Kd(t,n,e);case 2:return g.slice3d(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return iI(t,n,e);default:throw new we(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Kd(t,n,e);case 2:return g.slice4d(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return g.slice4d(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return iI(t,n,e);default:throw new we(`The axis is not within the rank of the tensor ${r}`)}default:throw new we(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function sI(t,n=-1){let e;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),g.concat(t,n)}function E$(t,n){switch(t.rank){case 1:return g.concat1d([t,n]);case 2:return g.concat2d([t,n],0);case 3:return g.concat3d([t,n],0);case 4:return g.concat4d([t,n],0);default:throw new we(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function oI(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new we(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return g.tile(t,n)}function P_(t,n=0,e=1,r,i){return g.randomNormal(t,n,e,r,i)}function th(t,n,e,r){if(t.rank<2||n.rank<2)throw new ci(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3&&t.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new ci(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${n.shape}`);if(2===t.rank&&2===n.rank)return g.fused.matMul({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?aI(t.rank,r,"channelsLast"):null,activation:e});{const i=t.shape.slice(),s=i.pop();t=g.reshape(t,[-1,s]);const o=n.shape.slice(),a=o.pop(),u=o.pop(),c=[...o,a],d=Array.from({length:n.rank},(w,b)=>0===b?n.rank-2:b<=n.rank-2?b-1:b);n=g.reshape(g.transpose(n,d),[u,-1]);const p=[...i,...c];return g.reshape(g.fused.matMul({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?aI(t.rank,r,"channelsLast"):null,activation:e}),p)}}function C$(t,n,e){return(0,g.tidy)(()=>(n=Array.isArray(n)?(0,g.tensor1d)(n,"int32"):g.cast(n,"int32"),g.gather(t,n,e)))}function $g(t){return g.mul(t,t)}function aI(t,n,e){const r=n.shape;if(1!==n.rank&&n.rank!==t)throw new we(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===e)return g.reshape(n,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return g.reshape(n,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===e)return g.reshape(n,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return g.reshape(n,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===e)return g.reshape(n,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return g.reshape(n,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return n;throw new we(`Unsupported input rank by biasAdd: ${n.rank}`)}function Tc(t,n,e){return(0,g.tidy)(()=>(null==e&&(e="channelsLast"),Aa(e),g.add(t,aI(t.rank,n,e))))}function w$(t,n,e,r){return(0,g.tidy)(()=>g.dropout(t,n,e,r))}function Bg(t,n,e=!1){return e?t():n()}const Nst=["fanIn","fanOut","fanAvg"],Ast=["normal","uniform","truncatedNormal"];class hc extends g.serialization.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}g.serialization.registerClass((()=>{class t extends hc{apply(e,r){return(0,g.zeros)(e,r)}}return t.className="Zeros",t})());let b$=(()=>{class t extends hc{apply(e,r){return(0,g.ones)(e,r)}}return t.className="Ones",t})();g.serialization.registerClass(b$),g.serialization.registerClass((()=>{class t extends hc{constructor(e){if(super(),"object"!=typeof e)throw new we(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new we(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return(0,g.tidy)(()=>(0,g.mul)((0,g.scalar)(this.value),(0,g.ones)(e,r)))}getConfig(){return{value:this.value}}}return t.className="Constant",t})()),g.serialization.registerClass((()=>{class t extends hc{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return(0,g.randomUniform)(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return t.className="RandomUniform",t})()),g.serialization.registerClass((()=>{class t extends hc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ci(`randomNormal does not support dType ${r}.`);return P_(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="RandomNormal",t})()),g.serialization.registerClass((()=>{class t extends hc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ci(`truncatedNormal does not support dType ${r}.`);return(0,g.truncatedNormal)(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="TruncatedNormal",t})()),g.serialization.registerClass((()=>{class t extends hc{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return(0,g.tidy)(()=>{if(2!==e.length||e[0]!==e[1])throw new we("Identity matrix initializer can only be used for 2D square matrices.");return(0,g.mul)(this.gain,(0,g.eye)(e[0]))})}getConfig(){return{gain:this.gain}}}return t.className="Identity",t})());let Ul=(()=>{class t extends hc{constructor(e){if(super(),e.scale<0)throw new we(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function Mst(t){Hd(Nst,"FanMode",t)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function Pst(t){Hd(Ast,"Distribution",t)}(this.distribution),this.seed=e.seed}apply(e,r){const i=function Bst(t,n="channelsLast"){let e,r;if(Aa(n),2===t.length)e=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===n){const i=ed(t,2);e=t[1]*i,r=t[0]*i}else if("channelsLast"===n){const i=ed(t,0,t.length-2);e=t[t.length-2]*i,r=t[t.length-1]*i}}else{const i=ed(t);e=Math.sqrt(i),r=Math.sqrt(i)}return[e,r]}(e),s=i[0],o=i[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(s+o)/2),"normal"===this.distribution){const u=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ci(`${this.getClassName()} does not support dType ${r}.`);return(0,g.truncatedNormal)(e,0,u,r,this.seed)}{const u=Math.sqrt(3*a);return(0,g.randomUniform)(e,-u,u,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return t.className="VarianceScaling",t})();g.serialization.registerClass(Ul);let I$=(()=>{class t extends Ul{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Ul.className}}return t.className="GlorotUniform",t})();g.serialization.registerClass(I$);let S$=(()=>{class t extends Ul{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Ul.className}}return t.className="GlorotNormal",t})();g.serialization.registerClass(S$);let D$=(()=>{class t extends Ul{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Ul.className}}return t.className="HeNormal",t})();g.serialization.registerClass(D$);let T$=(()=>{class t extends Ul{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Ul.className}}return t.className="HeUniform",t})();g.serialization.registerClass(T$);let N$=(()=>{class t extends Ul{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Ul.className}}return t.className="LeCunNormal",t})();g.serialization.registerClass(N$);let A$=(()=>{class t extends Ul{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Ul.className}}return t.className="LeCunUniform",t})();g.serialization.registerClass(A$);let zst=(()=>{class t extends hc{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return(0,g.tidy)(()=>{if(e.length<2)throw new ci("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const i=g.util.sizeFromShape(e.slice(0,-1)),s=e[e.length-1],o=i*s;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const u=P_([Math.max(s,i),Math.min(s,i)],0,1,r,this.seed),c=g.linalg.qr(u,!1);let d=c[0];const v=c[1].flatten().stridedSlice([0],[Math.min(s,i)*Math.min(s,i)],[Math.min(s,i)+1]);return d=(0,g.mul)(d,v.sign()),i<s&&(d=d.transpose()),(0,g.mul)((0,g.scalar)(this.gain),d.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return t.className="Orthogonal",t})();g.serialization.registerClass(zst);const M$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function P$(t,n={}){return Lg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"initializer")}function aa(t){return eI(t)}function Xo(t){if("string"==typeof t){const n=t in M$?M$[t]:t;if("GlorotNormal"===n)return new S$;if("GlorotUniform"===n)return new I$;if("HeNormal"===n)return new D$;if("HeUniform"===n)return new T$;if("LeCunNormal"===n)return new N$;if("LeCunUniform"===n)return new A$;{const e={};return e.className=n,e.config={},P$(e)}}return t instanceof hc?t:P$(t)}function uI(t){return Array.isArray(t)&&Array.isArray(t[0])}function O_(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function Fr(t){let n;if(Array.isArray(t)){if(1!==t.length)throw new we(`Expected Tensor length to be 1; got ${t.length}`);n=t[0]}else n=t;return n}function xs(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new we(`Expected exactly 1 Shape; got ${t.length}`)}return t}function R_(t){let n=0;for(const e of t)n+=0===e.shape.length?1:e.shape.reduce((r,i)=>r*i);return n}const O$="Variable";class eh{constructor(n,e="float32",r=O$,i=!0,s=null){this.dtype=e??"float32",this.shape=n.shape,this.id=p$(),this.originalName=y$(r=r??O$),this.name=v$(this.originalName),this.trainable_=i,this.constraint=s,this.val=g.variable(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),function Vst(t,n){if(t.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}(this.val,n),this.val.id!==n.id&&(this.val.assign(n),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}}function lI(t){return t.map(n=>n.read())}function cI(t){t.forEach(n=>{n[0].write(n[1])})}class Qa{constructor(n){this.dtype=n.dtype,this.shape=n.shape,this.ndim=null!=n.shape?n.shape.length:n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}}class nh{constructor(n,e,r,i,s,o,a){this.dtype=n,this.shape=e,this.sourceLayer=r,this.inputs=i,this.callArgs=s,this.outputTensorIndex=a,this.id=p$(),null!=o&&(this.originalName=y$(o),this.name=v$(this.originalName)),this.rank=e.length}}let Ust=0;class L_{constructor(n,e){this.callArgs=e,this.id=Ust++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(const r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){const n=[];for(const e of this.inboundLayers)n.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Wst=0;class xi extends g.serialization.Serializable{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Wst++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=n.name;if(!e){const r=this.getClassName();e=Dh(r)+"_"+N_(r)}if(this.name=e,this.trainable_=null==n.trainable||n.trainable,null!=n.inputShape||null!=n.batchInputShape){let r;if(null!=n.batchInputShape)r=n.batchInputShape;else if(null!=n.inputShape){let s=null;null!=n.batchSize&&(s=n.batchSize),r=[s].concat(n.inputShape)}this.batchInputShape=r;let i=n.dtype;null==i&&(i=n.inputDType),null==i&&(i="float32"),this.dtype=i}this.initialWeights=null!=n.weights?n.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,e){return n.name+"_ib-"+e.toString()}getNodeAtIndex(n,e){if(0===this.inboundNodes.length)throw new lc(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=n)throw new we(`Asked to get ${e} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return hl(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return hl(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Qc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Qc(`Layer ${this.name} is not connected, no input to return.`);return hl(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Qc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Qc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return hl(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(e=>e.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){const e=Gs(n);if(null==this.inputSpec||0===this.inputSpec.length)return;const r=Gs(this.inputSpec);if(e.length!==r.length)throw new we(`Layer ${this.name} expects ${r.length} inputs, but it received ${e.length} input tensors. Input received: ${n}`);for(let i=0;i<e.length;i++){const s=e[i],o=r[i];if(null==o)continue;const a=s.rank;if(null!=o.ndim&&a!==o.ndim)throw new we(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(null!=o.maxNDim&&a>o.maxNDim)throw new we(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(null!=o.minNDim&&a<o.minNDim)throw new we(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(null!=o.dtype&&s.dtype!==o.dtype)throw new we(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const u=s.shape;for(const c in o.axes){const d=Number(c),p=o.axes[c];if(null!=p&&-1===[p,null].indexOf(d>=0?u[d]:u[u.length+d]))throw new we(`Input ${i} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${u}.`)}}if(null!=o.shape)for(let u=0;u<o.shape.length;++u){const c=o.shape[u],d=s.shape[u];if(null!=c&&null!=d&&c!==d)throw new we(`Input ${i} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(n,e){return n}invokeCallHook(n,e){null!=this._callHook&&this._callHook(n,e)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,e){e=e||{},this.assertNotDisposed();const r=Gs(n),i=function jst(t){let n=!0;for(const e of Gs(t))if(!(e instanceof nh)){n=!1;break}return n}(n),s=function Kst(t){let n=!0;for(const e of Gs(t))if(e instanceof nh){n=!1;break}return n}(n);if(i===s)throw new we("Arguments to apply() must be all SymbolicTensors or all Tensors");return jd(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);const o=[];for(const a of Gs(n))o.push(a.shape);this.build(hl(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(n),s){let o=this.call(n,e);this.supportsMasking&&this.setMaskMetadata(n,o);const a=Gs(o),u=[];for(let c of a)-1!==r.indexOf(c)&&(c=c.clone()),u.push(c);if(o=hl(u),null!=this.activityRegularizer)throw new ci("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function Gst(t){t=Gs(t);const n=[];for(const e of t)n.push(e.shape);return hl(n)}(n),a=this.computeOutputShape(o);let u;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(n)?o[0]:o),u=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((d,p)=>new nh(c,d,this,Gs(n),e,this.name,p)):new nh(c,a,this,Gs(n),e,this.name),this.addInboundNode(n,u,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new ci("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(n){if(null!=this.batchInputShape)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,i)=>{null!=r&&null!=n[i]&&n[i]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Qc(`The layer ${this.name} has never been called and thus has no defined output shape.`);const n=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===n.indexOf(r)&&n.push(r)}if(1===n.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Qc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new lc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return R_(this.weights)}build(n){this.built=!0}getWeights(n=!1){return lI(n?this.trainableWeights:this.weights)}setWeights(n){(0,g.tidy)(()=>{const e=this.weights;if(e.length!==n.length)throw new we(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${e.length} weights. Provided weights: ${n}...`);if(0===e.length)return;const r=[],i=lI(e);for(let s=0;s<i.length;++s){const o=i[s],a=e[s],u=n[s];if(!g.util.arraysEqual(o.shape,u.shape))throw new we(`Layer weight shape ${o.shape} not compatible with provided weight shape ${u.shape}`);r.push([a,u])}cI(r)})}addWeight(n,e,r,i,s,o,a,u){if(-1!==this._addedWeightNames.indexOf(n))throw new we(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(i=null!=u?u():Xo("zeros"));const c=i.apply(e,r),d=new eh(c,r,n,o,a);return c.dispose(),null!=s&&this.addLoss(()=>s.apply(d.read())),null==o&&(o=!0),o?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){null==n||Array.isArray(n)&&0===n.length||(n=Gs(n),null!=this._losses&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}setMaskMetadata(n,e,r){if(!this.supportsMasking)return;const i=this.computeMask(n,r),s=Gs(e),o=Gs(i);if(s.length!==o.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let a=0;a<s.length;a++)s[a].kerasMask=o[a]}addInboundNode(n,e,r,i,s,o,a=null){const u=Gs(n);e=Gs(e),r=Gs(r),i=Gs(i),s=O_(s),o=O_(o);const c=[],d=[],p=[];for(const v of u)c.push(v.sourceLayer),d.push(v.nodeIndex),p.push(v.tensorIndex);new L_({outboundLayer:this,inboundLayers:c,nodeIndices:d,tensorIndices:p,inputTensors:u,outputTensors:e,inputMasks:r,outputMasks:i,inputShapes:s,outputShapes:o},a);for(let v=0;v<e.length;v++)e[v].sourceLayer=this,e[v].nodeIndex=this.inboundNodes.length-1,e[v].tensorIndex=v}getConfig(){const n={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(n.batchInputShape=this.batchInputShape),null!=this.dtype&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return 0==--this._refCount&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}}function R$(t,n,e){if((null==n||null!=e&&e>0)&&(n=t.sourceLayer,e=t.nodeIndex),0===n.inboundNodes.length)return[t];{const r=n.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const i=[];for(let s=0;s<r.inboundLayers.length;s++){const c=R$(r.inputTensors[s],r.inboundLayers[s],r.nodeIndices[s]);for(const d of c)-1===i.indexOf(d)&&i.push(d)}return i}}}let k_=(()=>{class t extends xi{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:N_("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new we("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new we("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new we("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const i=e.dtype||"float32";this.batchInputShape=r,this.dtype=i,this.inputSpec=[{shape:r}];const s=new nh(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new L_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new we(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return t.className="InputLayer",t})();g.serialization.registerClass(k_);class rd{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof rd)for(const e in n.id2Value)this.id2Value[e]=n.id2Value[e],e in n.id2Mask&&(this.id2Mask[e]=n.id2Mask[e]);else{if(null==n)return;for(const e of n)this.add(e.key,e.value)}}add(n,e,r){if(null!=this.id2Value[n.id])throw new we(`Duplicate key: name=${n.name}, id=${n.id}`);return this.id2Value[n.id]=function Zst(t,n){if(null==t.dtype||t.dtype===n.dtype)return n;try{return(0,g.cast)(n,t.dtype)}catch{throw new we(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(n,e),this.name2Id[n.name]=n.id,null!=r&&(this.id2Mask[n.id]=r),this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return null!=this.id2Value[n.id]}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof nh){if(null==this.id2Value[n.id])throw new we(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}{const e=this.name2Id[n];if(null==e)throw new we(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[e]}}getMask(n){if(n instanceof nh){if(null==this.id2Value[n.id])throw new we(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}{const e=this.name2Id[n];if(null==e)throw new we(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&(0,g.dispose)(this.id2Mask)}}const F_=new c$,$_=new c$;function zg(t,n,e,r){const i=null!=e&&e.training,s=Array.isArray(t),o=s?t:[t],a=o.map(w=>w.name),u=[],c=n.names();for(const w of a)-1!==c.indexOf(w)?u.push(n.getValue(w)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const d=a.join(",")+"|"+n.names().sort().join(",");let v,p=F_.get(d);if(null==p){const w=function qst(t,n){g.util.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===t.length){const i=L$(t[0],n);e=i.sorted,r=i.recipientMap}else{const i=new Set;for(const s of t){const{sorted:o,recipientMap:a}=L$(s,n);for(const u of o)i.has(u.name)||(e.push(u),i.add(u.name));for(const u in a)null==r[u]&&(r[u]=new Set),a[u].forEach(c=>r[u].add(c))}}return{sorted:e,recipientCounts:Qst(r)}}(o,n);p=w.sorted,v=w.recipientCounts,F_.put(d,p),$_.put(d,v)}v={},i||Object.assign(v,$_.get(d));const x=new rd(n);for(let w=0;w<p.length;++w){if(null!=r){const Ot=(0,g.memory)().numTensors;Ot>r.maxNumTensors&&(r.maxNumTensors=Ot),Ot<r.minNumTensors&&(r.minNumTensors=Ot)}const b=p[w],T=b.sourceLayer;if(T instanceof k_)continue;const N=[],S=[],U=[];let J=!1;for(const Ot of b.inputs){const le=x.getValue(Ot),ge=x.getMask(Ot);N.push(le),S.push(ge),null!=ge&&(J=!0),i||(v[Ot.name]--,0===v[Ot.name]&&!n.hasKey(Ot)&&-1===a.indexOf(Ot.name)&&!le.isDisposed&&!0!==Ot.sourceLayer.stateful&&U.push(le))}J&&((e=e||{}).mask=S[0]);const ht=Gs(T.apply(N,e));let Tt=null;T.supportsMasking&&(Tt=T.computeMask(N,S));const Pt=Jst(b),zt=Array.isArray(Pt)?Pt:[Pt];for(let Ot=0;Ot<zt.length;++Ot){x.hasKey(zt[Ot])||x.add(zt[Ot],ht[Ot],Array.isArray(Tt)?Tt[0]:Tt);const le=a.indexOf(zt[Ot].name);-1!==le&&(u[le]=ht[Ot])}i||(0,g.dispose)(U)}return x.disposeMasks(),s?u:u[0]}function Qst(t){const n={};for(const e in t)n[e]=t[e].size;return n}function L$(t,n){const e=new Set,r=[],i={};for(const a of n.names())e.add(a);const s=[],o=[];for(s.push(t);s.length>0;){const a=s[s.length-1];if(e.has(a.name)){s.pop();continue}const u=o[o.length-1]===s.length-1;if(0===a.inputs.length||u)s.pop(),r.push(a),e.add(a.name),u&&o.pop();else{o.push(s.length-1);for(const c of a.inputs)null==i[c.name]&&(i[c.name]=new Set),i[c.name].add(a.name),!e.has(c.name)&&s.push(c)}}return{sorted:r,recipientMap:i}}function Jst(t){let n;if(1===t.sourceLayer.inboundNodes.length)n=t.sourceLayer.output;else{let e=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(const i of t.sourceLayer.inboundNodes[r].outputTensors)if(i.id===t.id){e=r;break}n=t.sourceLayer.getOutputAt(e)}return n}function hI(t,n){return(0,g.tidy)(()=>g.sqrt(g.sum(g.mul(t,t),n,!0)))}(0,g.env)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function Yst(t){F_?.setMaxEntries(t),$_?.setMaxEntries(t)});class Vg extends g.serialization.Serializable{getConfig(){return{}}}let tot=(()=>{class t extends Vg{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,g.tidy)(()=>{const r=hI(e,this.axis),i=g.clipByValue(r,0,this.maxValue);return g.mul(e,g.div(i,g.add(qa(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return t.className="MaxNorm",t})();g.serialization.registerClass(tot);let eot=(()=>{class t extends Vg{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,g.tidy)(()=>g.div(e,g.add(qa(),hI(e,this.axis))))}getConfig(){return{axis:this.axis}}}return t.className="UnitNorm",t})();g.serialization.registerClass(eot);let not=(()=>{class t extends Vg{apply(e){return g.relu(e)}}return t.className="NonNeg",t})();g.serialization.registerClass(not);let rot=(()=>{class t extends Vg{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,g.tidy)(()=>{const r=hI(e,this.axis),i=g.add(g.mul(this.rate,g.clipByValue(r,this.minValue,this.maxValue)),g.mul(1-this.rate,r));return g.mul(e,g.div(i,g.add(qa(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return t.className="MinMaxNorm",t})();g.serialization.registerClass(rot);const k$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ja(t){return eI(t)}function F$(t,n={}){return Lg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"constraint")}function tu(t){return null==t?null:"string"==typeof t?F$({className:t in k$?k$[t]:t,config:{}}):t instanceof Vg?t:F$(t)}function id(t){return dI.apply(this,arguments)}function dI(){return(dI=(0,Mr.Z)(function*(t){if(null==t)return;const n=[],e=[],r=[];for(const i in t){const s=t[i];if("number"!=typeof s){const o=s;n.push(o.data()),e.push(i),r.push(o)}}if(n.length>0){const i=yield Promise.all(n);for(let s=0;s<i.length;++s)t[e[s]]=i[s][0];(0,g.dispose)(r)}})).apply(this,arguments)}function $$(t){if(null!=t)for(const n in t){const e=t[n];"number"!=typeof e&&e.dispose()}}class Np{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,e){return(0,Mr.Z)(function*(){})()}onEpochEnd(n,e){return(0,Mr.Z)(function*(){})()}onBatchBegin(n,e){return(0,Mr.Z)(function*(){})()}onBatchEnd(n,e){return(0,Mr.Z)(function*(){})()}onTrainBegin(n){return(0,Mr.Z)(function*(){})()}onTrainEnd(n){return(0,Mr.Z)(function*(){})()}setModel(n){}}class oot{constructor(n,e=10){null==n&&(n=[]),this.callbacks=n,this.queueLength=e}append(n){this.callbacks.push(n)}setParams(n){for(const e of this.callbacks)e.setParams(n)}setModel(n){for(const e of this.callbacks)e.setModel(n)}onEpochBegin(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onEpochBegin(n,e)})()}onEpochEnd(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onEpochEnd(n,e)})()}onBatchBegin(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onBatchBegin(n,e)})()}onBatchEnd(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onBatchEnd(n,e)})()}onTrainBegin(n){var e=this;return(0,Mr.Z)(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainBegin(n)})()}onTrainEnd(n){var e=this;return(0,Mr.Z)(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainEnd(n)})()}}class aot extends Np{constructor(){super()}onEpochBegin(n){var e=this;return(0,Mr.Z)(function*(){e.seen=0,e.totals={}})()}onBatchEnd(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});const i=null==e.size?0:e.size;r.seen+=i;for(const s in e){const o=e[s];if("number"==typeof o)r.totals.hasOwnProperty(s)||(r.totals[s]=0),r.totals[s]=r.totals[s]+o*i;else{let a;s in r.totals?a=r.totals[s]:r.totals[s]=0;const u=(0,g.tidy)(()=>(0,g.add)(r.totals[s],(0,g.mul)(o,i)));r.totals[s]=u,a?.dispose()}}})()}onEpochEnd(n,e){var r=this;return(0,Mr.Z)(function*(){if(null!=e)for(const i of r.params.metrics)null!=r.totals[i]&&("number"==typeof r.totals[i]?e[i]=r.totals[i]/r.seen:(0,g.tidy)(()=>{const s=(0,g.mul)((0,g.div)(1,r.seen),r.totals[i]);e[i]=s,r.totals[i].dispose(),(0,g.keep)(e[i])}))})()}}class uot extends Np{onTrainBegin(n){var e=this;return(0,Mr.Z)(function*(){e.epoch=[],e.history={}})()}onEpochEnd(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={}),r.epoch.push(n);for(const i in e)null==r.history[i]&&(r.history[i]=[]),r.history[i].push(e[i])})()}syncData(){var n=this;return(0,Mr.Z)(function*(){const e=[],r=[],i=[];for(const o in n.history){const a=n.history[o];for(let u=0;u<a.length;++u)"number"!=typeof a[u]&&(e.push(a[u].data()),r.push(o),i.push(u))}const s=yield Promise.all(e);for(let o=0;o<s.length;++o)n.history[r[o]][i[o]].dispose(),n.history[r[o]][i[o]]=s[o][0]})()}}class lot extends Np{constructor(n,e){if(super(),this.currentEpoch=0,this.nowFunc=n.nowFunc,this.nextFrameFunc=n.nextFrameFunc||g.nextFrame,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");g.util.isNumber(this.yieldEvery)&&(this.maybeWait=function cst(t,n,e){let i,r=null!=e?e():g.util.now();return(...o)=>{const a=null!=e?e():g.util.now();return a-r<n||(r=a,i=t(...o)),i}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,e,r){var i=this;return(0,Mr.Z)(function*(){const s=[];null!=i.yield&&(yield id(r),s.push(i.yield(n,e,r))),s.push(i.nextFrameFunc()),yield Promise.all(s)})()}onEpochBegin(n,e){var r=this;return(0,Mr.Z)(function*(){r.currentEpoch=n,null!=r.epochBegin&&(yield id(e),yield r.epochBegin(n,e))})()}onEpochEnd(n,e){var r=this;return(0,Mr.Z)(function*(){const i=[];null!=r.epochEnd&&(yield id(e),i.push(r.epochEnd(n,e))),"epoch"===r.yieldEvery&&i.push(r.nextFrameFunc()),yield Promise.all(i)})()}onBatchBegin(n,e){var r=this;return(0,Mr.Z)(function*(){null!=r.batchBegin&&(yield id(e),yield r.batchBegin(n,e))})()}onBatchEnd(n,e){var r=this;return(0,Mr.Z)(function*(){const i=[];null!=r.batchEnd&&(yield id(e),i.push(r.batchEnd(n,e))),"batch"===r.yieldEvery?i.push(r.nextFrameFunc()):g.util.isNumber(r.yieldEvery)&&i.push(r.maybeWait(r.currentEpoch,n,e)),yield Promise.all(i)})()}onTrainBegin(n){var e=this;return(0,Mr.Z)(function*(){null!=e.trainBegin&&(yield id(n),yield e.trainBegin(n))})()}onTrainEnd(n){var e=this;return(0,Mr.Z)(function*(){null!=e.trainEnd&&(yield id(n),yield e.trainEnd(n))})()}}function B$(t,n){return null==t&&(t={}),t instanceof Np?[t]:Array.isArray(t)&&t[0]instanceof Np?t:Gs(t).map(r=>new lot(r,n))}let cot=(()=>{class t{constructor(){}static registerCallbackConstructor(e,r){g.util.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),t.checkForDuplicate(r),null==t.constructors[e]&&(t.constructors[e]=[]),t.constructors[e].push(r)}static checkForDuplicate(e){for(const r in t.constructors)t.constructors[+r].forEach(s=>{if(s===e)throw new we("Duplicate callback constructor.")})}static clear(){t.constructors={}}static createCallbacks(e){const r=[];for(const i in t.constructors){const s=+i;e>=s&&r.push(...t.constructors[s])}return r.map(i=>new i)}}return t.constructors={},t})();function z$(t,n,e,r,i,s,o,a,u){const c=new uot,d=[new aot,...cot.createCallbacks(n)];null!=t&&d.push(...t),d.push(c);const p=new oot(d);return p.setParams({epochs:e,initialEpoch:r,samples:i,steps:s,batchSize:o,verbose:n,doValidation:a,metrics:u}),{callbackList:p,history:c}}function Th(t,n={},e=!1){return Lg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"layer",e)}function B_(t,n){return(0,g.tidy)(()=>{"float32"!==t.dtype&&(t=g.cast(t,"float32"));const e=g.sum($g(t),n,!0),r=g.fill(e.shape,qa()),i=g.sqrt(g.maximum(e,r));return g.div(t,i)})}function z_(t,n){return(0,g.tidy)(()=>g.mean($g(g.sub(n,t)),-1))}function fI(t,n){return(0,g.tidy)(()=>g.mean(g.abs(g.sub(n,t)),-1))}function pI(t,n){return(0,g.tidy)(()=>{const e=g.sub(t,n),r=g.clipByValue(g.abs(t),qa(),Number.MAX_VALUE),i=g.abs(g.div(e,r));return g.mul(100,g.mean(i,-1))})}function Ug(t,n,e=!1){return(0,g.tidy)(()=>{if(e)n=g.softmax(n);else{const r=g.sum(n,n.shape.length-1,!0);n=g.div(n,r)}return n=g.clipByValue(n,qa(),1-qa()),g.neg(g.sum(g.mul(g.cast(t,"float32"),g.log(n)),n.shape.length-1))})}function V_(t,n,e=!1){return(0,g.tidy)(()=>{const r=g.cast(g.floor(function bst(t){const n=[ed(t.shape)];return g.reshape(t,n)}(t)),"int32"),i=(n=g.clipByValue(n,qa(),1-qa())).shape;return Ug(g.reshape(g.oneHot(r,i[i.length-1]),i),n,e)})}function U_(t,n){return(0,g.tidy)(()=>{let e;return e=g.clipByValue(n,qa(),1-qa()),e=g.log(g.div(e,g.sub(1,e))),g.mean(function got(t,n){if(!g.util.arraysEqual(t.shape,n.shape))throw new we(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`);return(0,g.tidy)(()=>{const e=g.relu(n),r=g.neg(g.abs(n));return g.add(g.sub(e,g.mul(n,t)),g.log1p(g.exp(r)))})}(t,e),-1)})}function V$(t,n){return(0,g.tidy)(()=>{const e=B_(t,-1),r=B_(n,-1),i=g.mul(e,r);return g.neg(g.sum(i,-1))})}const W_={meanSquaredError:z_,meanAbsoluteError:fI,meanAbsolutePercentageError:pI,meanSquaredLogarithmicError:function hot(t,n){return(0,g.tidy)(()=>{const e=g.clipByValue(n,qa(),Number.MAX_VALUE),r=g.log(g.add(1,e)),i=g.clipByValue(t,qa(),Number.MAX_VALUE),s=g.log(g.add(1,i));return g.mean($g(g.sub(r,s)),-1)})},squaredHinge:function dot(t,n){return(0,g.tidy)(()=>{const e=g.maximum(0,g.sub(1,g.mul(t,n)));return g.mean($g(e),-1)})},hinge:function fot(t,n){return(0,g.tidy)(()=>{const e=g.maximum(0,g.sub(1,g.mul(t,n)));return g.mean(e,-1)})},categoricalHinge:function pot(t,n){return(0,g.tidy)(()=>{const e=g.sum(g.mul(t,n),-1),r=g.max(g.mul(g.sub(1,t),n),-1);return g.maximum(0,g.add(1,g.sub(r,e)))})},logcosh:function mot(t,n){return(0,g.tidy)(()=>{const e=Math.log(2),r=g.sub(n,t),i=g.sub(g.add(r,g.softplus(g.mul(-2,r))),e);return g.mean(i,-1)})},categoricalCrossentropy:Ug,sparseCategoricalCrossentropy:V_,binaryCrossentropy:U_,kullbackLeiblerDivergence:function yot(t,n){return(0,g.tidy)(()=>{const e=g.clipByValue(t,qa(),1),r=g.clipByValue(n,qa(),1);return g.sum(g.mul(t,g.log(g.div(e,r))),-1)})},poisson:function vot(t,n){return(0,g.tidy)(()=>{const e=g.log(g.add(qa(),n));return g.mean(g.sub(n,g.mul(t,e)),-1)})},cosineProximity:V$};function mI(t){if("string"==typeof t){if(t in W_)return W_[t];let n=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new we(n)}return t}function U$(t,n){return(0,g.tidy)(()=>{const e=g.mul(.5,g.onesLike(n)),r=Jc(g.greater(n,e),t.dtype);return g.mean(g.equal(t,r),-1)})}function W$(t,n){return(0,g.tidy)(()=>Jc(g.equal(g.argMax(t,-1),g.argMax(n,-1)),"float32"))}function Cot(t,n){return U_(t,n)}function wot(t,n){return t.rank===n.rank&&(t=g.squeeze(t,[t.rank-1])),(n=g.argMax(n,-1)).dtype!==t.dtype&&(n=g.cast(n,t.dtype)),g.cast(g.equal(t,n),"float32")}const H$=Ug,j$=V_,G_={binaryAccuracy:U$,categoricalAccuracy:W$,precision:function Eot(t,n){return(0,g.tidy)(()=>{const e=function G$(t,n){return(0,g.tidy)(()=>g.cast(g.sum(g.logicalAnd(g.equal(t,1),g.equal(n,1))),"float32"))}(t,n),r=function xot(t,n){return(0,g.tidy)(()=>g.cast(g.sum(g.logicalAnd(g.equal(t,0),g.equal(n,1))),"float32"))}(t,n),i=g.add(e,r);return g.cast(g.where(g.greater(i,0),g.div(e,i),0),"float32")})},categoricalCrossentropy:H$,sparseCategoricalCrossentropy:j$,mse:z_,MSE:z_,mae:fI,MAE:fI,mape:pI,MAPE:pI,cosine:V$};function Pot(t){if("string"==typeof t&&t in G_)return G_[t];if("string"!=typeof t&&null!=t)return t;throw new we(`Unknown metric ${t}`)}function H_(t){if(zl(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let n;for(const e of Object.keys(W_))if(W_[e]===t){n=e;break}if(void 0!==n)return n;for(const e of Object.keys(G_))if(G_[e]===t){n=e;break}return void 0!==n?n:t.name}}function X$(t,n,e=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!gI(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(t);r.length>1048576&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function gI(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const n=Object.keys(t);for(const e of n)if("string"!=typeof e||!gI(t[e]))return!1;return!0}if(Array.isArray(t)){for(const n of t)if(!gI(n))return!1;return!0}return!1}{const n=typeof t;return"string"===n||"number"===n||"boolean"===n}}function j_(t,n,e=console.log){let r="";for(let i=0;i<t.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r+=t[i],r=r.slice(0,n[i]),r+=" ".repeat(n[i]-r.length);e(r)}function Fot(t,n,e){let r,i;try{i=t.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}j_([`${t.name} (${t.getClassName()})`,i,r,t.countParams().toString()],n,e)}function $ot(t,n,e,r){let i,s;try{s=t.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{s="multiple"}try{i=JSON.stringify(t.outputShape)}catch{i="multiple"}const o=[];for(const p of t.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(p)))for(let v=0;v<p.inboundLayers.length;++v)o.push(`${p.inboundLayers[v].name}[${p.nodeIndices[v]}][${p.tensorIndices[v]}]`);const a=t.name,u=t.getClassName(),c=0===o.length?"":o[0];j_([`${a} (${u})`,s,i,t.countParams().toString(),c],n,r);for(let p=1;p<o.length;++p)j_(["","","","",o[p]],n,r)}function Z$(t,n,e){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===n&&"string"==typeof e}function yI(t,n){if(null===t)return null;if("string"==typeof t)return Gd(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let i=0;i<r;++i){const s=t[i];Z$(n,i,s)?e.push(s):e.push(yI(s,n))}return e}{const e={};for(const r of Object.keys(t)){const i=t[r];if("name"===r&&"string"==typeof i)e[r]=i;else{const s=Gd(r);e[s]=yI(i,s)}}return e}}function vI(t,n){if(null==t)return null;if("string"==typeof t)return Dh(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let i=0;i<r;++i){const s=t[i];Z$(n,i,s)?e.push(s):e.push(vI(s,n))}return e}{const e={};for(const r of Object.keys(t)){const i=t[r];e[Dh(r)]="name"!==r&&"className"!==r||"string"!=typeof i?vI(i,r):i}return e}}class Nc extends xi{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,null==this.name){const S=this.getClassName().toLowerCase();this.name=N_(S)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(n.inputs)?n.inputs.slice():[n.inputs],this.outputs=Array.isArray(n.outputs)?n.outputs.slice():[n.outputs],td(this.inputs).length!==this.inputs.length)throw new we(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(S=>S.name)}`);td(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(S=>S.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const S of this.outputs){const J=S.nodeIndex,ht=S.tensorIndex;this.outputLayers.push(S.sourceLayer),this.outputLayersNodeIndices.push(J),this.outputLayersTensorIndices.push(ht)}for(const S of this.inputs){const U=S.sourceLayer,J=S.nodeIndex,ht=S.tensorIndex;zl(0===J,"input layer has >1 nodes"),zl(0===ht,"input layer has >1 tensors"),this.inputLayers.push(U),this.inputLayersNodeIndices.push(J),this.inputLayersTensorIndices.push(ht)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let S=0;S<this.inputLayers.length;S++){const U=this.inputLayers[S];if(!(U instanceof k_))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${S} (0-based) originates from layer type ${U.getClassName()}.`);this.inputNames.push(U.name),this.feedInputShapes.push(U.batchInputShape),this.feedInputNames.push(U.name)}for(const S of this.outputLayers)this.outputNames.push(S.name);this.internalInputShapes=this.inputs.map(S=>S.shape),this.internalOutputShapes=this.outputs.map(S=>S.shape);const e={},r={},i={},s={},o={},a=[],u=(S,U,J,ht,Tt,Pt)=>{(null==ht||null==Tt||null==Pt)&&(ht=S.sourceLayer,Tt=S.nodeIndex,Pt=S.tensorIndex);const zt=ht.inboundNodes[Tt];if(-1!==J.indexOf(zt))throw new lc(`The tensor ${S.name} at layer "${ht.name}" is part of a cycle.`);if(-1!==U.indexOf(zt))return;this.containerNodes.add(Nc.nodeKey(ht,Tt)),ht.id in o||(o[ht.id]=Object.keys(o).length),-1===J.indexOf(zt)&&J.push(zt);const Ot=zt.inboundLayers.length;for(let le=0;le<Ot;le++)u(zt.inputTensors[le],U,J,zt.inboundLayers[le],zt.nodeIndices[le],zt.tensorIndices[le]);for(U.push(zt);J.indexOf(zt)>=0;)J.splice(J.indexOf(zt),1);a.push(zt)},c=[],d=[];for(const S of this.outputs)u(S,c,d);const p=a.slice().reverse();for(const S of p){r[S.id]=S,S.id in e||(e[S.id]=0);let U=e[S.id];U=Math.max(U,null==i[S.outboundLayer.id]?0:i[S.outboundLayer.id]),i[S.outboundLayer.id]=U,s[S.outboundLayer.id]=S.outboundLayer,e[S.id]=U;for(let ht=0;ht<S.inboundLayers.length;ht++){const zt=S.inboundLayers[ht].inboundNodes[S.nodeIndices[ht]];e[zt.id]=Math.max(U+1,null==e[zt.id]?0:e[zt.id]),r[zt.id]=zt}}const v={};for(const S in e){const U=e[S];U in v||(v[U]=[]),v[U].push(r[S])}const x={};for(const S in i){const U=i[S];U in x||(x[U]=[]),x[U].push(s[S])}let w=Object.keys(x).map(S=>parseInt(S,10)).sort(D_);this.layers=[];for(const S of w){const U=x[S];U.sort((J,ht)=>{const Tt=o[J.id],Pt=o[ht.id];return Tt<Pt?-1:Tt>Pt?1:0});for(const J of U)J instanceof Nc&&this.internalContainerRefs.push(J),this.layers.push(J)}this.layersByDepth=x,w=Object.keys(v).map(S=>parseInt(S,10)).sort(D_);const b=this.inputs.slice(),T=[];for(const S of w)for(const U of v[S]){const J=U.outboundLayer;if(null!=J){for(const ht of U.inputTensors)if(-1===b.indexOf(ht))throw new lc(`Graph disconnected: cannot obtain value for tensor ${ht} at layer "${J.name}". The following previous layers were accessed without issue: ${T}`);for(const ht of U.outputTensors)b.push(ht);T.push(J.name)}}this.nodesByDepth=v;const N=this.layers.map(S=>S.name);for(const S of N){const U=N.filter(J=>J===S).length;if(1!==U)throw new lc(`The name "${S}" is used ${U} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(N))}this.outboundNodes=[],this.inboundNodes=[],new L_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(S=>null),outputMasks:this.outputs.map(S=>null),inputShapes:this.inputs.map(S=>S.shape),outputShapes:this.outputs.map(S=>S.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const n={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)n.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)n.numDisposedVariables+=e.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new we("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(const e of this.layers)n=n.concat(e.trainableWeights);return n}get nonTrainableWeights(){const n=[];for(const e of this.layers)n.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,e=!0){const r={};let i=0;const s=(t=>{const n=Object.keys(t);if(0===n.length)return!1;const e=n[0].split("/");return!isNaN(parseInt(e[e.length-1],10))})(n);s&&this.parseWeights(n);for(const a of this.layers)for(const[u,c]of a.weights.entries()){const d=s?`${c.name.split("/").slice(0,-1).join("/")+"/"}${u}`:c.originalName;if(null!=r[d])throw new we(`Duplicate weight name: ${d}`);r[d]=c,i++}const o=[];for(const a in n){let u=a;if(null==r[a]){const c=a.split("/");u=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(null!=r[u])o.push([r[u],n[a]]);else if(e)throw new we(`Provided weight data has no target variable: ${a}`);delete r[u]}if(e){const a=[];for(const u in r)a.push(u);if(a.length>0)throw new we(`${a.length} of ${i} weights are not set: ${a}`)}cI(o)}parseWeights(n){for(const e in Object.keys(n)){const r=e.split("/"),i=["vars","layer_checkpoint_dependencies"],s=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!i.includes(o)).join("/");s!==e&&(n[s]=n[e],delete n[e])}}updatedConfig(){const n=this.getConfig(),e={};return e.className=this.getClassName(),e.config=n,e.kerasVersion="tfjs-layers 4.17.0",e.backend="TensorFlow.js",e}toJSON(n,e=!0){const r=vI(this.updatedConfig());return e?JSON.stringify(r):r}call(n,e){return(0,g.tidy)(()=>{n=Gs(n);const r=new rd;for(let i=0;i<this.inputs.length;++i)r.add(this.inputs[i],n[i]);return zg(this.outputs,r,e)})}computeMask(n,e){return(0,g.tidy)(()=>{let r;return n=Gs(n),r=null==e?Wd(null,n.length):Gs(e),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){const e=O_(n);if(e.length!==this.inputLayers.length)throw new we(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(D_);if(i.length>1)for(const a of i){const u=this.nodesByDepth[a];for(const c of u){const d=c.outboundLayer;if(-1!==this.inputLayers.map(b=>b.id).indexOf(d.id))continue;const p=[];for(let b=0;b<c.inboundLayers.length;b++)p.push(r[`${c.inboundLayers[b].name}_${c.nodeIndices[b]}_${c.tensorIndices[b]}`]);const x=O_(d.computeOutputShape(hl(p))),w=d.inboundNodes.indexOf(c);for(let b=0;b<x.length;b++)r[`${d.name}_${w}_${b}`]=x[b]}}const s=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const u=o[a];zl(u in r),s.push(r[u])}return hl(s)}runInternalGraph(n,e){null==e&&(e=Wd(null,n.length));const r={};for(let u=0;u<this.inputs.length;++u)r[this.inputs[u].id]=[n[u],e[u]];const i=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(D_);for(const u of i){const c=this.nodesByDepth[u];for(const d of c){const p=d.outboundLayer,v=d.inputTensors,x=d.outputTensors,w=new Array;for(const b of v)b.id in r&&w.push(r[b.id]);if(w.length===v.length){let T,N,S,U,b={};if(null!=d.callArgs&&(b=d.callArgs),1===w.length){const[J,ht]=w[0];null==b.mask&&(b.mask=ht),S=Gs(p.call(J,b)),U=Gs(p.computeMask(J,ht)),T=[J],N=[ht]}else T=w.map(J=>J[0]),N=w.map(J=>J[1]),null==b.mask&&(b.mask=N),S=Gs(p.call(T,b)),U=Gs(p.computeMask(T,N));if(p.activityRegularizer)throw new ci("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let J=0;J<x.length;++J)r[x[J].id]=[S[J],U[J]]}}}const s=[],o=[],a=[];for(const u of this.outputs){zl(u.id in r,`Could not compute output ${u.name} : ${u.id}`);const[c,d]=r[u.id];a.push(c.shape),s.push(c),o.push(d)}return[s,o,a]}buildNodeConversionMap(n){const e={};let r;for(const i of this.layers){r=i instanceof Nc?1:0;for(let s=0;s<i.inboundNodes.length;s++){const o=Nc.nodeKey(i,s);this.containerNodes.has(o)&&(e[o]=r,r+=1)}}return e}getLayer(n,e){if(null!=e)return this.findLayer(e);if(null==n)throw new we("Provide either a layer name or layer index");if("number"==typeof n)return this.findLayer(n);for(const r of this.layers)if(r.name===n)return r;throw new we(`No such layer: ${n}`)}findLayer(n){if(this.layers.length<=n)throw new we(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}calculateLosses(){return(0,g.tidy)(()=>{const n=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const i=Nc.nodeKey(e,r);this.containerNodes.has(i)&&n.push(...e.calculateLosses())}return n})}getConfig(){const n={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),u=o.getConfig(),c=[];for(let p=0;p<o.inboundNodes.length;p++){const v=o.inboundNodes[p],x=Nc.nodeKey(o,p);let w={};if(this.containerNodes.has(x)){if(v.callArgs)try{JSON.stringify(v.callArgs),w=v.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${v.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),w={}}if(v.inboundLayers.length>0){const b=[];for(let T=0;T<v.inboundLayers.length;T++){const N=v.inboundLayers[T],U=v.tensorIndices[T];let ht=e[Nc.nodeKey(N,v.nodeIndices[T])];null==ht&&(ht=0),b.push([N.name,ht,U,w])}c.push(b)}}}const d={};d.name=o.name,d.className=a,d.config=u,d.inboundNodes=c,r.push(d)}n.layers=r;const i=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],c=Nc.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let d=e[c];null==d&&(d=0),i.push([a.name,d,this.inputLayersTensorIndices[o]])}n.inputLayers=i;const s=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],c=Nc.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let d=e[c];null==d&&(d=0),s.push([a.name,d,this.outputLayersTensorIndices[o]])}return n.outputLayers=s,n}static fromConfig(n,e,r={},i=!1){const s={},o={};function a(T,N){T.name in o?o[T.name].push(N):o[T.name]=[N]}function u(T,N){const S=[];let U;for(const J of N){const ht=J[0],Tt=J[1],Pt=J[2];if(U=null==J[3]?{}:J[3],!(ht in s))return void a(T,N);const zt=s[ht];if(zt.inboundNodes.length<=Tt)return void a(T,N);S.push(zt.inboundNodes[Tt].outputTensors[Pt])}S.length>0&&T.apply(hl(S),U)}function c(T){const N=T.name,S=Th(T,null!=e.customObjects?e.customObjects:{});S.setFastWeightInitDuringBuild(i),s[N]=S,T.inboundNodes.forEach(J=>{if(!(J instanceof Array))throw new we(`Corrupted configuration, expected array for nodeData: ${J}`);a(S,J)})}const d=e.name,p=e.layers;for(const T of p)c(T);for(;!lst(o);)for(const T of p){const N=s[T.name];if(N.name in o){const S=o[N.name];delete o[N.name];for(const U of S)u(N,U)}}const v=[],x=[],w=e.inputLayers;for(const T of w){const N=T[0],S=T[1],U=T[2];zl(N in s),v.push(s[N].inboundNodes[S].outputTensors[U])}const b=e.outputLayers;for(const T of b){const N=T[0],S=T[1],U=T[2];zl(N in s),x.push(s[N].inboundNodes[S].outputTensors[U])}return new n({inputs:v,outputs:x,name:d})}get stateful(){if(this._stateful)throw new we("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const n of this.layers)if(n.stateful)return!0;return!1}resetStates(){(0,g.tidy)(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}}function q$(t,n){return function Y$(t,n,e){const r=n.length;if(null==t||Array.isArray(t)&&0===t.length)return n.map(i=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&n[0]in t?[t[n[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${e} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const i=[];return n.forEach(s=>{i.push(s in t?t[s]:null)}),i}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${n} keys. Provided ${e} not understood: ${JSON.stringify(t)}`)}(t,n,"classWeight")}function Q$(t,n,e,r){return xI.apply(this,arguments)}function xI(){return(xI=(0,Mr.Z)(function*(t,n,e,r){if(null!=n||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const i=(0,g.tidy)(()=>{if(1===t.shape.length)return(0,g.clone)(t);if(2===t.shape.length){if(t.shape[1]>1)return(0,g.argMax)(t,1);if(1===t.shape[1])return(0,g.reshape)(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield i.data());(0,g.dispose)(i);const o=[];return s.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),(0,g.tensor1d)(o,"float32")}return null})).apply(this,arguments)}function zot(t,n){return(0,g.mul)(t,n)}function J$(t,n){let e,r;e=n.xs,r=n.ys,g.util.assert(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);const s=tB("input",t.inputNames,e),o=tB("output",t.outputNames,r),a=s[0].shape[0];g.util.assert(s.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),g.util.assert(o.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let u=0;u<s.length;u++)g.util.assert(s[u].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[u]} has ${s[u].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let u=0;u<o.length;u++)g.util.assert(o[u].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[u]} has ${o[u].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:s,ys:o}}function tB(t,n,e){if(e instanceof g.Tensor)return[e];if(Array.isArray(e))return g.util.assert(e.length===n.length,()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`),e;{const r=[];for(const i of n){if(null==e[i])throw new we(`The feature data generated by the dataset lacks the required ${t} key '${i}'.`);r.push(e[i])}return r}}function EI(){return(EI=(0,Mr.Z)(function*(t,n,e){const r=null!=e.batchesPerEpoch;if(g.util.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),g.util.assert(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),g.util.assert(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),g.util.assert(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),g.util.assert(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const i=null!=e.validationData;let s,o;if(i)if(eB(e.validationData))g.util.assert(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const T=function Uot(t){if(3===t.length)throw new ci("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(e.validationData);s=T.xs,o=T.ys}const a=t.makeTrainFunction(),u=t.getDedupedMetricsNames();let c;c=i?u.slice().concat(u.map(T=>"val_"+T)):u.slice();const d=B$(e.callbacks,e.yieldEvery),p=null==e.verbose?1:e.verbose,{callbackList:v,history:x}=z$(d,p,e.epochs,null,null,function Got(t,n){let e=null;return null!=n.batchesPerEpoch?e=n.batchesPerEpoch:Number.isFinite(t.size)&&(e=t.size),e}(n,e),null,i,c);v.setModel(t),t.history=x,yield v.onTrainBegin(),t.stopTraining_=!1;let w=null==e.initialEpoch?0:e.initialEpoch,b=yield n.iterator();for(;w<e.epochs;){const T={};yield v.onEpochBegin(w);let N=0,S=0;for(r||(b=yield n.iterator());!r||N<e.batchesPerEpoch;){const U=yield b.next();if(r&&U.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${N} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=U.value){const{xs:J,ys:ht}=J$(t,U.value),Tt={};Tt.batch=S,Tt.size=J[0].shape[0],yield v.onBatchBegin(S,Tt);const Pt=[];if(null!=e.classWeight){const le=q$(e.classWeight,t.outputNames);for(let ge=0;ge<le.length;++ge)Pt.push(yield Q$(ht[ge],null,le[ge]))}const zt=J.concat(ht).concat(Pt),Ot=a(zt);g.dispose(zt);for(let le=0;le<u.length;++le){const Ae=Ot[le];Tt[u[le]]=Ae,g.keep(Ae)}yield v.onBatchEnd(S,Tt),$$(Tt),S++,N++}if(r?N>=e.batchesPerEpoch:U.done){if(i){let J;J=eB(e.validationData)?Gs(yield t.evaluateDataset(e.validationData,{batches:e.validationBatches})):Gs(t.evaluate(s,o,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let ht=0;ht<t.metricsNames.length;++ht)T[`val_${t.metricsNames[ht]}`]=J[ht]}break}if(t.stopTraining_)break}if(yield v.onEpochEnd(w,T),w++,t.stopTraining_)break}return yield v.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})).apply(this,arguments)}function eB(t){return"function"==typeof t.iterator}function CI(){return(CI=(0,Mr.Z)(function*(t,n,e){const r=null!=(e=e||{}).batches,i=t.testFunction;let s=[];if(e.verbose>0)throw new ci("Verbose mode is not implemented yet.");g.util.assert(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=function Hot(t){return"function"==typeof t.next}(n)?n:yield n.iterator();let a=0,u=0;for(;!r||u<e.batches;){const c=yield o.next();if(s=g.tidy(()=>{if(c.value){const{xs:d,ys:p}=J$(t,c.value),v=d.concat(p),x=g.tidy(()=>i(v));if(g.dispose(v),0===u)for(let b=0;b<x.length;++b)s.push((0,g.scalar)(0));const w=v[0].shape[0];for(let b=0;b<x.length;++b){const T=x[b],N=s[b];s[b]=g.tidy(()=>g.add(s[b],g.mul(w,T))),u>0&&g.dispose(N)}g.dispose(x),a+=w,++u}return s}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<s.length;++c){const d=s[c];s[c]=g.div(s[c],a),g.dispose(d)}return hl(s)})).apply(this,arguments)}function wI(t){g.util.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Wg(t,n,e){return null==t?[null]:Array.isArray(t)?t.map(r=>Kd(r,n,e-n)):Kd(t,n,e-n)}function bI(t,n){return g.tidy(()=>null==t?null:Array.isArray(t)?t.map(e=>bI(e,n)):C$(t,"int32"===n.dtype?n:g.cast(n,"int32")))}function II(t,n){const e=[];let r=0,i=null;for(;r<t;)i=r+n,i>=t&&(i=t),e.push([r,i]),r=i;return e}function nB(t){const n=[];t instanceof g.Tensor&&(t=[t]);for(let e=0;e<t.length;++e){const r=t[e];if(1===r.rank)n.push(Fg(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function Ac(t,n){if(null==t)return;const e=[];if(n instanceof g.Tensor)e.push(n.id);else if(Array.isArray(n))n.forEach(i=>e.push(i.id));else if(null!=n)for(const i in n)e.push(n[i].id);const r=[];if(t instanceof g.Tensor)-1===e.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(i=>{-1===e.indexOf(i.id)&&r.push(i)});else if(null!=t)for(const i in t){const s=t[i];-1===e.indexOf(s.id)&&r.push(s)}r.forEach(i=>{i.isDisposed||i.dispose()})}function SI(t){return Array.isArray(t)}function rB(t){return!function Kot(t){return t instanceof g.Tensor}(t)&&!SI(t)}function iB(t,n,e,r=!0,i=""){if(null==n||0===n.length){if(null!=t){let o=!1;if(SI(t)&&t.length>0)o=!0;else if(rB(t)){for(const a in t)if(t.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new we(`Error when checking model ${i} expected no data, but got ${t}`)}return[]}if(null==t)return n.map(o=>null);let s;if(rB(t)){s=[];for(const o of n){if(null==t[o])throw new we(`No data provided for "${o}". Need data for each key in: ${n}`);s.push(t[o])}}else if(SI(t)){if(t.length!==n.length)throw new we(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(n.length>1)throw new we(`The model ${i} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=nB(s),null!=e)for(let o=0;o<n.length;++o){if(null==e[o])continue;const a=s[o];if(a.shape.length!==e[o].length)throw new we(`Error when checking ${i}: expected ${n[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[o].length;++u){if(0===u&&!r)continue;const d=e[o][u];if(null!=d&&d>=0&&a.shape[u]!==d)throw new we(`${i} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function sB(t,n,e,r=!0,i=""){let s;if(Array.isArray(t)){if(t.length!==n.length)throw new we(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(n.length>1)throw new we(`The model expects ${n.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(null!=e)for(let o=0;o<n.length;++o){if(null==e[o])continue;const a=s[o];if(a.shape.length!==e[o].length)throw new we(`Error when checking ${i}: expected ${n[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[o].length;++u){if(0===u&&!r)continue;const d=e[o][u];if(null!=d&&d!==a.shape[u])throw new we(`Error when checking ${i}: expected ${n[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Ap=(()=>{class t extends Nc{constructor(e){super(e),this.isTraining=!1}summary(e,r,i=console.log){if(!this.built)throw new we("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Rot(t,n,e,r=console.log){const i=function kot(t){let n=!0;const e=[],r=[];for(const i in t.nodesByDepth)e.push(t.nodesByDepth[i]);for(const i of e){if(i.length>1||1===i.length&&i[0].inboundLayers.length>1){n=!1;break}r.push(...i)}if(n)for(const i of t.layers){let s=!1;for(const o of i.inboundNodes)if(-1!==r.indexOf(o)){if(s){n=!1;break}s=!0}if(!n)break}return n}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(i?(n=n||90,e=e||[.32,.61,.89,1]):(n=n||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(d=>Math.floor(n*d))),!i){s.push("Receives inputs"),o=[];for(const d in t.nodesByDepth)o.push(...t.nodesByDepth[d])}r("_".repeat(n)),j_(s,e,r),r("=".repeat(n));const a=t.layers;for(let d=0;d<a.length;++d)i?Fot(a[d],e,r):$ot(a[d],e,o,r),r((d===a.length-1?"=":"_").repeat(n));t.checkTrainableWeightsConsistency();const u=function Lot(t){let n;return n=R_(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),n}(t),c=R_(t.nonTrainableWeights);r(`Total params: ${u+c}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${c}`),r("_".repeat(n))}(this,e,r,i)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Oot(t){const n={Adagrad:()=>g.train.adagrad(.01),Adadelta:()=>g.train.adadelta(1,.95,qa()),Adam:()=>g.train.adam(.001,.9,.999,qa()),Adamax:()=>g.train.adamax(.002,.9,.999,qa(),0),RMSProp:()=>g.train.rmsprop(.001,.9,0,qa()),SGD:()=>g.train.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new we(`Unknown Optimizer ${t}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof g.Optimizer))throw new we("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new we(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(u=>mI(u))}else{const a=mI(e.loss);this.outputs.forEach(u=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new we(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(mI(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const u=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(u),this.feedLossFns.push(this.lossFunctions[a])}const i=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],jd("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===i.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const s=function Yot(t,n){if(null==t||Array.isArray(t)&&0===t.length)return n.map(r=>[]);let e;if("string"==typeof t||"function"==typeof t)e=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);e=t}if(Array.isArray(e))return n.map(r=>e);{const r=[];for(const i of n){let s=e.hasOwnProperty(i)?e[i]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}(e.metrics,this.outputNames),o=(a,u,c)=>{this.outputNames.length>1&&(u=this.outputNames[a]+"_"+u),this.metricsNames.push(u),this.metricsTensors.push([c,a])};jd("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===i.indexOf(a)&&(d=>{let v,x,w;for(const b of d){if("string"==typeof b&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(b)){const N=this.internalOutputShapes[a];let S;1===N[N.length-1]||this.lossFunctions[a]===U_?-1!==["accuracy","acc"].indexOf(b)?x=U$:-1!==["crossentropy","ce"].indexOf(b)&&(x=Cot):this.lossFunctions[a]===V_?-1!==["accuracy","acc"].indexOf(b)?x=wot:-1!==["crossentropy","ce"].indexOf(b)&&(x=j$):-1!==["accuracy","acc"].indexOf(b)?x=W$:-1!==["crossentropy","ce"].indexOf(b)&&(x=H$),-1!==["accuracy","acc"].indexOf(b)?S="acc":-1!==["crossentropy","ce"].indexOf(b)&&(S="ce"),w=x,v=""+S}else w=Pot(b),v=""+H_(b);let T;jd(v,()=>{T=w}),o(a,v,T)}})(s[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,i={}){const s=null==i.batchSize?32:i.batchSize;wI(s);const a=this.standardizeUserDataXY(e,r,!0,s);try{const u=a[0].concat(a[1]);return this.makeTestFunction(),hl(this.testLoop(this.testFunction,u,s,i.verbose,i.steps))}finally{Ac(a[0],e),Ac(a[1],r)}}evaluateDataset(e,r){var i=this;return(0,Mr.Z)(function*(){return i.makeTestFunction(),function jot(t,n,e){return CI.apply(this,arguments)}(i,e,r)})()}checkNumSamples(e,r,i,s="steps"){let o;if(null!=i){if(o=null,null!=r)throw new we(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new we(`Either the input data should have a defined shape, or ${s} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new we("`outputs` is an empty Array, which is not allowed.");const i=Array.isArray(r),o=this.retrieveSymbolicTensors(i?r:[r]),a=new rd;if(e instanceof g.Tensor&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new we(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const d=e[c.name];if(null==d)throw new we(`No value is provided for the model's input ${c.name}`);a.add(c,d)}const u=zg(o,a);return i?u:u[0]}retrieveSymbolicTensors(e){const r=Wd(null,e.length);let i=e.length;for(const s of this.layers){const o=Array.isArray(s.output)?s.output:[s.output],a=o.map(u=>u.name);for(let u=0;u<e.length;++u){const c=a.indexOf(e[u]);if(-1!==c&&(r[u]=o[c],i--),0===i)break}if(0===i)break}if(i>0){const s=[];throw r.forEach((o,a)=>{null==o&&s.push(e[a])}),new we(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return r}predictLoop(e,r=32,i=!1){return g.tidy(()=>{const s=this.checkNumSamples(e);if(i)throw new ci("Verbose predictLoop() is not implemented yet.");const o=II(s,r),a=this.outputs.map(u=>[]);for(let u=0;u<o.length;++u)g.tidy(()=>{const v=Wg(e,o[u][0],o[u][1]),x=[];if(Array.isArray(v))for(let b=0;b<v.length;++b)x.push({key:this.inputs[b],value:v[b]});else x.push({key:this.inputs[0],value:v});const w=new rd(x);return zg(this.outputs,w)}).forEach((d,p)=>a[p].push(d));return hl(a.map(u=>g.concat(u,0)))})}predict(e,r={}){const i=nB(e);sB(i,this.inputNames,this.feedInputShapes,!1);try{const s=null==r.batchSize?32:r.batchSize;return wI(s),this.predictLoop(i,s)}finally{Ac(i,e)}}predictOnBatch(e){sB(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,i=!0,s){if(null==this.optimizer_)throw new lc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const u=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===V_?u.slice(0,u.length-1).concat([1]):u)}if(function Xot(t,n,e){const r=td(t.map(s=>s.shape[0]));r.sort();const i=td(n.map(s=>s.shape[0]));if(i.sort(),r.length>1)throw new we(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(i.length>1)throw new we(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(r.length>0&&i.length>0&&!g.util.arraysEqual(r,i))throw new we(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}(e=iB(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=iB(r,this.feedOutputNames,o,!1,"target")),function Zot(t,n,e){const r=[z_,U_,Ug];for(let i=0;i<t.length;++i){const s=t[i],o=n[i],a=e[i];if(null!=o){if(o===Ug&&1===s.shape[s.shape.length-1])throw new we(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const u=s.shape.slice(1),c=a.slice(1);for(let d=0;d<u.length;++d){const v=c[d];if(null!=v&&u[d]!==v)throw new we(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&e[0].shape[0]%s!=0)throw new we(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,i,s,o=!0,a){var u=this;return(0,Mr.Z)(function*(){const[c,d]=u.standardizeUserDataXY(e,r,o,a);if(null!=i)throw new Error("sample weight is not supported yet.");let p=null;if(null!=s){const v=q$(s,u.outputNames);p=[];for(let x=0;x<v.length;++x)p.push(yield Q$(d[x],null,v[x]))}return[c,d,p]})()}testLoop(e,r,i,s=0,o){return g.tidy(()=>{const a=this.checkNumSamples(r,i,o,"steps"),u=[];if(s>0)throw new ci("Verbose mode is not implemented yet.");if(null!=o)throw new ci("steps mode in testLoop() is not implemented yet");{const c=II(a,i),d=(0,g.tensor1d)(Sc(0,a));for(let p=0;p<c.length;++p){const v=c[p][0],x=c[p][1],w=Kd(d,v,x-v),b=bI(r,w),T=e(b);if(0===p)for(let N=0;N<T.length;++N)u.push((0,g.scalar)(0));for(let N=0;N<T.length;++N)u[N]=g.add(u[N],g.mul(x-v,T[N]))}for(let p=0;p<u.length;++p)u[p]=g.div(u[p],a)}return u})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let i=0;i<e.length;++i){const s=e[i];let o=s;h$(e,s)>1&&(o+=`_${h$(e.slice(0,i),s)}`),r.push(o)}return r}makeTrainFunction(){return e=>{const r=[],i=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],c=this.collectedTrainableWeights.map(v=>v.read());return[this.optimizer_.minimize(()=>{const v=[];for(let T=0;T<this.inputs.length;++T)v.push({key:this.inputs[T],value:i[T]});const x=new rd(v),w=zg(this.outputs,x,{training:!0});let b;for(let T=0;T<this.lossFunctions.length;++T){let S=(0,this.lossFunctions[T])(s[T],w[T]);null!=o[T]&&(S=zot(S,o[T]));const U=g.mean(S);r.push(U),b=0===T?S:g.add(b,S)}for(let T=0;T<this.metricsTensors.length;++T){let N;if(this.outputs.length>1&&T<this.outputs.length)N=r[T];else{const U=this.metricsTensors[T][1];N=g.mean((0,this.metricsTensors[T][0])(s[U],w[U]))}g.keep(N),a.push(N)}return b=g.mean(b),this.calculateLosses().forEach(T=>{b=g.add(b,T)}),b},!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>g.tidy(()=>{const r=[];let i;const s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let d=0;d<this.inputs.length;++d)a.push({key:this.inputs[d],value:s[d]});const u=new rd(a),c=zg(this.outputs,u);for(let d=0;d<this.lossFunctions.length;++d){const v=g.mean((0,this.lossFunctions[d])(o[d],c[d]));i=0===d?v:g.add(i,v),r.push(i)}for(let d=0;d<this.metricsTensors.length;++d){const v=this.metricsTensors[d][1],x=g.mean((0,this.metricsTensors[d][0])(o[v],c[v]));r.push(x)}return r})}fit(e,r,i={}){var s=this;return(0,Mr.Z)(function*(){if(s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,u,c,d,p,v,x,w;s.isTraining=!0;try{const b=null==i.batchSize?32:i.batchSize;wI(b);const T=!1,N=yield s.standardizeUserData(e,r,i.sampleWeight,i.classWeight,T,b);o=N[0],a=N[1],w=N[2];let U,S=!1;if(null!=i.validationData&&i.validationData.length>0){if(S=!0,2!==i.validationData.length)throw 3===i.validationData.length?new ci("validationData including sample weights is not supported yet."):new we(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${i.validationData} is invalid.`);d=i.validationData[0],p=i.validationData[1];const ge=!0,Ae=yield s.standardizeUserData(d,p,null,null,ge,b);v=Ae[0],x=Ae[1],U=v.concat(x)}else if(null!=i.validationSplit&&i.validationSplit>0&&i.validationSplit<1){S=!0;const ge=Math.floor(o[0].shape[0]*(1-i.validationSplit)),Ae=o[0].shape[0];v=Wg(o,ge,Ae),u=o,o=Wg(o,0,ge),x=Wg(a,ge,Ae),c=a,a=Wg(a,0,ge),U=v.concat(x)}else null!=i.validationSteps&&(S=!0);const J=o.concat(a).concat(w);s.checkTrainableWeightsConsistency();const ht=s.makeTrainFunction(),Tt=s.getDedupedMetricsNames();let Pt,zt;S?(s.makeTestFunction(),Pt=s.testFunction,zt=Tt.slice().concat(Tt.map(ge=>"val_"+ge))):(Pt=null,U=[],zt=Tt.slice());const Ot=B$(i.callbacks,i.yieldEvery);return yield s.fitLoop(ht,J,Tt,b,i.epochs,i.verbose,Ot,Pt,U,i.shuffle,zt,i.initialEpoch,null,null)}finally{s.isTraining=!1,Ac(o,e),Ac(a,r),Ac(u,e),Ac(c,r),Ac(v,d),Ac(x,p),null!=w&&g.dispose(w)}})()}fitLoop(e,r,i,s,o,a,u,c,d,p,v,x,w,b){var T=this;return(0,Mr.Z)(function*(){null==s&&(s=32),null==o&&(o=1),null==p&&(p=!0),null==x&&(x=0);let N=!1;if(null!=c&&null!=d&&(N=!0),null!=b&&(N=!0,null==w))throw new we("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const S=T.checkNumSamples(r,s,w,"steps_per_epoch");let U;null!=S&&(U=Sc(0,S)),null==a&&(a=1);const{callbackList:J,history:ht}=z$(u,a,o,x,S,w,s,N,v);J.setModel(T),T.history=ht,yield J.onTrainBegin(),T.stopTraining_=!1;for(let Tt=x;Tt<o;++Tt){yield J.onEpochBegin(Tt);const Pt={};if(null!=w)throw new ci("stepsPerEpoch mode is not implemented yet.");{if("batch"===p)throw new ci("batch shuffling is not implemneted yet");p&&g.util.shuffle(U);const zt=(0,g.tensor1d)(U),Ot=II(S,s);for(let le=0;le<Ot.length;++le){const ge={};if(yield J.onBatchBegin(le,ge),g.tidy(()=>{const Ae=Ot[le][0],Re=Ot[le][1],ve=Kd(zt,Ae,Re-Ae);ge.batch=le,ge.size=Re-Ae;const Ne=bI(r,ve),Se=e(Ne);for(let Ke=0;Ke<i.length;++Ke){const Be=Se[Ke];ge[i[Ke]]=Be,g.keep(Be)}if(le===Ot.length-1&&N){const Ke=T.testLoop(c,d,s);for(let Le=0;Le<i.length;++Le){const Be=i[Le],on=Ke[Le];g.keep(on),Pt["val_"+Be]=on}}}),yield J.onBatchEnd(le,ge),$$(ge),T.stopTraining_)break}zt.dispose()}if(yield J.onEpochEnd(Tt,Pt),T.stopTraining_)break}return yield J.onTrainEnd(),yield T.history.syncData(),T.history})()}fitDataset(e,r){var i=this;return(0,Mr.Z)(function*(){return function Wot(t,n,e){return EI.apply(this,arguments)}(i,e,r)})()}trainOnBatch(e,r){var i=this;return(0,Mr.Z)(function*(){const s=yield i.standardizeUserData(e,r),o=s[0],a=s[1],c=i.makeTrainFunction()(o.concat(a)),d=[];for(const p of c){const v=yield p.data();d.push(v[0])}return g.dispose(c),Ac(s[0],e),Ac(s[1],r),hl(d)})()}getNamedWeights(e){const r=[],i=null!=e&&e.trainableOnly,s=i?this.trainableWeights:this.weights,o=this.getWeights(i);for(let a=0;a<s.length;++a)i&&!s[a].trainable||r.push({name:s[a].originalName,tensor:o[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=g.memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-g.memory().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Dh(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Dh(r))}else{const r=Object.keys(this.loss);e={};const i=this.loss;for(const s of r){if("string"!=typeof i[s])throw new Error("Serialization of non-string loss is not supported.");e[s]=Dh(i[s])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Dh(H_(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Dh(H_(e)));{const e={};for(const r in this.metrics)e[r]=Dh(H_(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const i=Th(yI(e.optimizer_config));let s,o;if("string"==typeof e.loss)s=Gd(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(a=>Gd(a));else if(null!=e.loss){s={};for(const a in e.loss)s[a]=Gd(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>Gd(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=Gd(e.metrics[a])}this.compile({loss:s,metrics:o,optimizer:i})}save(e,r){var i=this;return(0,Mr.Z)(function*(){if("string"==typeof e){const p=g.io.getSaveHandlers(e);if(0===p.length)throw new we(`Cannot find any save handlers for URL '${e}'`);if(p.length>1)throw new we(`Found more than one (${p.length}) save handlers for URL '${e}'`);e=p[0]}if(null==e.save)throw new we("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=yield g.io.encodeWeights(i.getNamedWeights(r)),c={modelTopology:i.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.17.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=i.optimizer){c.trainingConfig=i.getTrainingConfig();const p="optimizer",{data:v,specs:x}=yield g.io.encodeWeights(yield i.optimizer.getWeights(),p);s.specs.push(...x),s.data=g.io.concatenateArrayBuffers([s.data,v])}return null!=i.userDefinedMetadata&&(X$(i.userDefinedMetadata,i.name,!0),c.userDefinedMetadata=i.userDefinedMetadata),c.weightData=s.data,c.weightSpecs=s.specs,e.save(c)})()}setUserDefinedMetadata(e){X$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return t.className="Model",t})();g.serialization.registerClass(Ap),g.serialization.registerClass((()=>{class t extends Ap{}return t.className="Functional",t})());let eat=(()=>{class t extends Ap{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:N_("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(i=>i<0))throw new we(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof t||e instanceof Ap;let i;if(r){if(i=e,1!==i.outputs.length)throw new we("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==i.inputs.length)throw new we("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new we("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=function Xst(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new we("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=t.batchShape;null!=t.shape&&null==n&&(n=[null].concat(t.shape));let e=t.dtype;return null==e&&(e="float32"),new k_({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(r)this.outputs=i.outputs,this.inputs=i.inputs;else{if(1!==e.inboundNodes.length)throw new we(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new we("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=R$(this.outputs[0])}this.inboundNodes=[],new L_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Wd(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(xs(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ap({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,i=console.log){this.built||this.build(),super.summary(e,r,i)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,i={}){if(!this.built)throw new lc("The model needs to be compiled before being used.");return this.model.evaluate(e,r,i)}evaluateDataset(e,r){var i=this;return(0,Mr.Z)(function*(){if(!i.built)throw new lc("The model needs to be compiled before being used.");return i.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,i={}){var s=this;return(0,Mr.Z)(function*(){if(!s.built)throw new lc("The model needs to be compiled before being used.");return s.model.fit(e,r,i)})()}fitDataset(e,r){var i=this;return(0,Mr.Z)(function*(){if(!i.built)throw new lc("The model needs to be compiled before being used.");return i.model.fitDataset(e,r)})()}trainOnBatch(e,r){var i=this;return(0,Mr.Z)(function*(){return i.model.trainOnBatch(e,r)})()}static fromConfig(e,r,i={},s=!1){let o,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new we("Legacy serialization format not supported yet.");o=r}else g.util.assert(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=r.layers,delete r.layers,a=r;const u=new e(a);if(!(u instanceof t))throw new ci(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(const c of o){const p=Th(c,void 0,s);s&&p.setFastWeightInitDuringBuild(!0),u.add(p)}return u}set stopTraining(e){if(null==this.model)throw new we("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new we("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const i={};i.className=r.getClassName(),i.config=r.getConfig(),e.push(i)}return{name:this.name,layers:e}}}return t.className="Sequential",t})();g.serialization.registerClass(eat);class dl extends g.serialization.Serializable{getConfig(){return{}}}let nat=(()=>{class t extends dl{apply(e,r=1){return function Sst(t,n=1){if(1!==n)throw new ci(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return g.elu(t)}(e,r)}}return t.className="elu",t})();g.serialization.registerClass(nat);let rat=(()=>{class t extends dl{apply(e){return g.selu(e)}}return t.className="selu",t})();g.serialization.registerClass(rat);let iat=(()=>{class t extends dl{apply(e){return g.relu(e)}}return t.className="relu",t})();g.serialization.registerClass(iat);let sat=(()=>{class t extends dl{apply(e){return(0,g.tidy)(()=>g.minimum(6,g.relu(e)))}}return t.className="relu6",t})();g.serialization.registerClass(sat),g.serialization.registerClass((()=>{class t extends dl{apply(e){return e}}return t.className="linear",t})());let aat=(()=>{class t extends dl{apply(e){return g.sigmoid(e)}}return t.className="sigmoid",t})();g.serialization.registerClass(aat);let uat=(()=>{class t extends dl{apply(e){return function Tst(t){return(0,g.tidy)(()=>{const n=g.add(.5,g.mul(.2,t));return g.clipByValue(n,0,1)})}(e)}}return t.className="hardSigmoid",t})();g.serialization.registerClass(uat);let lat=(()=>{class t extends dl{apply(e){return g.softplus(e)}}return t.className="softplus",t})();g.serialization.registerClass(lat);let cat=(()=>{class t extends dl{apply(e){return function Dst(t){return(0,g.tidy)(()=>g.div(t,g.add(g.abs(t),1)))}(e)}}return t.className="softsign",t})();g.serialization.registerClass(cat);let hat=(()=>{class t extends dl{apply(e){return g.tanh(e)}}return t.className="tanh",t})();g.serialization.registerClass(hat);let oB=(()=>{class t extends dl{apply(e,r=-1){return g.softmax(e,r)}}return t.className="softmax",t})();g.serialization.registerClass(oB);let dat=(()=>{class t extends dl{apply(e,r=-1){return g.logSoftmax(e,r)}}return t.className="logSoftmax",t})();g.serialization.registerClass(dat);let fat=(()=>{class t extends dl{apply(e,r=1){return(0,g.tidy)(()=>g.mul(g.sigmoid(g.mul(e,r)),e))}}return t.className="swish",t})();g.serialization.registerClass(fat);let pat=(()=>{class t extends dl{apply(e){return(0,g.tidy)(()=>g.mul(e,g.tanh(g.softplus(e))))}}return t.className="mish",t})();function sd(t){return t.getClassName()}function AI(t,n={}){return Lg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"activation")}function od(t){if(null==t){return AI({className:"linear",config:{}})}if("string"==typeof t){const n={};return n.className=t,n.config={},AI(n)}return t instanceof dl?t:AI(t)}g.serialization.registerClass(pat);class aB extends g.serialization.Serializable{}let PI=(()=>{class t extends aB{constructor(e){super(),function MI(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return(0,g.tidy)(()=>{let r=(0,g.zeros)([1]);return this.hasL1&&(r=(0,g.add)(r,(0,g.sum)(g.mul(this.l1,(0,g.abs)(e))))),this.hasL2&&(r=(0,g.add)(r,(0,g.sum)(g.mul(this.l2,$g(e))))),g.reshape(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return t.className="L1L2",t})();g.serialization.registerClass(PI);const uB={l1l2:"L1L2"};function xo(t){return eI(t)}function lB(t,n={}){return Lg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"regularizer")}function Zo(t){return null==t?null:"string"==typeof t?lB({className:t in uB?uB[t]:t,config:{}}):t instanceof aB?t:lB(t)}function Mp(t,n,e){if("number"==typeof t)return Wd(t,n);if(t.length!==n)throw new we(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${t.length} elements.`);for(let r=0;r<n;++r){const i=t[r];if(!xst(i))throw new we(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`)}return t}function Mc(t,n,e,r,i=1){if(null==t)return t;let o;return o="same"===e?t:t-(n+(n-1)*(i-1))+1,Math.floor((o+r-1)/r)}function rh(t,n,e,r){if(null==t)return null;if("valid"===r)t=t*n+nd([e-n,0]);else{if("same"!==r)throw new we(`Unsupport padding mode: ${r}.`);t*=n}return t}function OI(t,n){return(0,g.tidy)(()=>(Aa(n),"channelsFirst"===n?g.transpose(t,[0,2,3,1]):t))}function cB(t,n){return(0,g.tidy)(()=>(Aa(n),"channelsFirst"===n?g.transpose(t,[0,2,3,4,1]):t))}function RI(t,n,e,r=[1,1],i="valid",s,o,a=null){return(0,g.tidy)(()=>{if(null==s&&(s="channelsLast"),Aa(s),3!==t.rank&&4!==t.rank)throw new we(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==n.rank&&4!==n.rank)throw new we(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let u=OI(t,s);if("causal"===i)throw new ci("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=g.fused.conv2d({x:u,filter:n,strides:r,pad:"same"===i?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===s&&(u=g.transpose(u,[0,3,1,2])),u})}g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=Fr(e);let i=(0,g.relu)(e);return null!=this.maxValue&&(i=(0,g.clipByValue)(i,0,this.maxValue)),i}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ReLU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const i=Fr(e);return(0,g.leakyRelu)(i,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LeakyReLU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Xo(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Zo(e.alphaRegularizer),this.alphaConstraint=tu(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new we(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=xs(e)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)r[s-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const i={};if(null!=this.sharedAxes)for(let s=1;s<e.length;++s)i[s]=e[s];this.inputSpec=[new Qa({ndim:e.length,axes:i})],this.built=!0}call(e,r){return e=Fr(e),(0,g.prelu)(e,this.alpha.read())}getConfig(){const e={alphaInitializer:aa(this.alphaInitializer),alphaRegularizer:xo(this.alphaRegularizer),alphaConstraint:Ja(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return t.className="PReLU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new ci(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const i=Fr(e);return(0,g.elu)(i)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ELU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const i=Fr(e);return(0,g.mul)(i,(0,g.cast)((0,g.greater)(i,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ThresholdedReLU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new oB).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){return(0,g.tidy)(()=>{let i=Fr(e);const s=r.mask;if(null!=s){const o=(0,g.mul)((0,g.sub)((0,g.ones)(i.shape),(0,g.cast)(s,i.dtype)),(0,g.scalar)(-1e9));i=(0,g.add)(i,o)}return this.axis instanceof Array?this.axis.length>1?(0,g.exp)((0,g.sub)(i,(0,g.logSumExp)(i,this.axis,!0))):this.softmax(i,this.axis[0]):this.softmax(i,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Softmax",t})());class K_ extends xi{constructor(n,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",K_.verifyArgs(e),this.rank=n,du(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new ci(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Mp(e.kernelSize,n,"kernelSize"),this.strides=Mp(null==e.strides?1:e.strides,n,"strides"),this.padding=null==e.padding?"valid":e.padding,Vl(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Aa(this.dataFormat),this.activation=od(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=Xo(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=tu(e.biasConstraint),this.biasRegularizer=Zo(e.biasRegularizer),this.activityRegularizer=Zo(e.activityRegularizer),this.dilationRate=Mp(null==e.dilationRate?1:e.dilationRate,n,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new we(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new we(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new we(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(n){if(zl("kernelSize"in n,"required key 'kernelSize' not in config"),"number"!=typeof n.kernelSize&&!rI(n.kernelSize,"number",1,3))throw new we(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){const n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:sd(this.activation),useBias:this.useBias,biasInitializer:aa(this.biasInitializer),biasRegularizer:xo(this.biasRegularizer),activityRegularizer:xo(this.activityRegularizer),biasConstraint:Ja(this.biasConstraint)},e=super.getConfig();return Object.assign(n,e),n}}class Pp extends K_{constructor(n,e){super(n,e),this.kernel=null,Pp.verifyArgs(e),this.filters=e.filters,du(this.filters,"filters"),this.kernelInitializer=Xo(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=tu(e.kernelConstraint),this.kernelRegularizer=Zo(e.kernelRegularizer)}build(n){n=xs(n);const e="channelsFirst"===this.dataFormat?1:n.length-1;if(null==n[e])throw new we(`The channel dimension of the input should be defined. Found ${n[e]}`);const r=n[e],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(n,e){return(0,g.tidy)(()=>{let r;n=Fr(n);const i=null==this.bias?null:this.bias.read(),s=f$(this.activation.getClassName());if(null!=s&&2===this.rank)r=RI(n,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)r=function hB(t,n,e,r=1,i="valid",s,o=1){return(0,g.tidy)(()=>{if(null==s&&(s="channelsLast"),Aa(s),3!==t.shape.length)throw new we(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==n.shape.length)throw new we(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new we(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===s&&(t=g.transpose(t,[0,2,1])),"causal"===i)throw new ci("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=g.conv1d(t,n,r,"same"===i?"same":"valid","NWC",o);return null!=e&&(a=Tc(a,e)),a})}(n,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=RI(n,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new ci("convolutions greater than 3D are not implemented yet.");r=function dB(t,n,e,r=[1,1,1],i="valid",s,o){return(0,g.tidy)(()=>{if(null==s&&(s="channelsLast"),Aa(s),4!==t.rank&&5!==t.rank)throw new we(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==n.rank&&5!==n.rank)throw new we(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=cB(t,s);if("causal"===i)throw new ci("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=g.conv3d(a,n,r,"same"===i?"same":"valid","NDHWC",o),null!=e&&(a=Tc(a,e)),"channelsFirst"===s&&(a=g.transpose(a,[0,4,1,2,3])),a})}(n,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=xs(n);const e=[],r="channelsLast"===this.dataFormat?n.slice(1,n.length-1):n.slice(2);for(let s=0;s<r.length;++s){const o=Mc(r[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);e.push(o)}let i=[n[0]];return"channelsLast"===this.dataFormat?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const n={filters:this.filters,kernelInitializer:aa(this.kernelInitializer),kernelRegularizer:xo(this.kernelRegularizer),kernelConstraint:Ja(this.kernelConstraint)},e=super.getConfig();return Object.assign(n,e),n}static verifyArgs(n){if(!("filters"in n)||"number"!=typeof n.filters||n.filters<1)throw new we(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}}let fB=(()=>{class t extends Pp{constructor(e){super(2,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!rI(e.kernelSize,"number",1,2))throw new we(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv2D",t})();g.serialization.registerClass(fB);let pB=(()=>{class t extends Pp{constructor(e){super(3,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new we(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv3D",t})();g.serialization.registerClass(pB);let Eat=(()=>{class t extends fB{constructor(e){if(super(e),this.inputSpec=[new Qa({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new we(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=xs(e)).length)throw new we("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new we("The channel dimension of the inputs should be defined. Found `None`.");const i=e[r],s=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qa({ndim:4,axes:{[r]:i}})],this.built=!0}call(e,r){return g.tidy(()=>{let i=Fr(e);if(4!==i.shape.length)throw new we(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const s=i.shape;let a,u;"channelsFirst"===this.dataFormat?(a=2,u=3):(a=1,u=2);const d=s[u],v=this.kernelSize[1],w=this.strides[1],N=[s[0],rh(s[a],this.strides[0],this.kernelSize[0],this.padding),rh(d,w,v,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=g.transpose(i,[0,2,3,1]));let S=g.conv2dTranspose(i,this.kernel.read(),N,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(S=g.transpose(S,[0,3,1,2])),null!=this.bias&&(S=Tc(S,this.bias.read(),this.dataFormat)),null!=this.activation&&(S=this.activation.apply(S)),S})}computeOutputShape(e){const r=(e=xs(e)).slice();let i,s,o;"channelsFirst"===this.dataFormat?(i=1,s=2,o=3):(i=3,s=1,o=2);const a=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1];return r[i]=this.filters,r[s]=rh(r[s],c,a,this.padding),r[o]=rh(r[o],d,u,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv2DTranspose",t})();g.serialization.registerClass(Eat);let Cat=(()=>{class t extends pB{constructor(e){if(super(e),this.inputSpec=[new Qa({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new we(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=xs(e)).length)throw new we("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new we("The channel dimension of the inputs should be defined. Found `None`.");const i=e[r],s=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qa({ndim:5,axes:{[r]:i}})],this.built=!0}call(e,r){return g.tidy(()=>{let i=Fr(e);if(5!==i.shape.length)throw new we(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const s=i.shape;let a,u,c;"channelsFirst"===this.dataFormat?(c=2,a=3,u=4):(c=1,a=2,u=3);const p=s[a],v=s[u],w=this.kernelSize[1],b=this.kernelSize[2],N=this.strides[1],S=this.strides[2],Tt=[s[0],rh(s[c],this.strides[0],this.kernelSize[0],this.padding),rh(p,N,w,this.padding),rh(v,S,b,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=g.transpose(i,[0,2,3,4,1]));let Pt=g.conv3dTranspose(i,this.kernel.read(),Tt,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(Pt=g.transpose(Pt,[0,4,1,2,3])),null!==this.bias&&(Pt=Tc(Pt,this.bias.read(),this.dataFormat)),null!==this.activation&&(Pt=this.activation.apply(Pt)),Pt})}computeOutputShape(e){const r=(e=xs(e)).slice();let i,s,o,a;"channelsFirst"===this.dataFormat?(i=1,s=2,o=3,a=4):(i=4,s=1,o=2,a=3);const u=this.kernelSize[0],c=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],v=this.strides[1],x=this.strides[2];return r[i]=this.filters,r[s]=rh(r[s],p,u,this.padding),r[o]=rh(r[o],v,c,this.padding),r[a]=rh(r[a],x,d,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv3DTranspose",t})();g.serialization.registerClass(Cat);let wat=(()=>{class t extends Pp{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new we("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new we("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new we(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=Xo(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Zo(r.depthwiseRegularizer),this.depthwiseConstraint=tu(r.depthwiseConstraint),this.pointwiseInitializer=Xo(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Zo(r.pointwiseRegularizer),this.pointwiseConstraint=tu(r.pointwiseConstraint)}build(e){if((e=xs(e)).length<this.rank+2)throw new we(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new we(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const i=e[r],s=this.kernelSize.concat([i,this.depthMultiplier]),o=[];for(let u=0;u<this.rank;++u)o.push(1);o.push(i*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new Qa({ndim:this.rank+2,axes:{[r]:i}})],this.built=!0}call(e,r){return(0,g.tidy)(()=>{let i;if(e=Fr(e),1===this.rank)throw new ci("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=g.transpose(e,[0,2,3,1])),i=g.separableConv2d(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(i=Tc(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),"channelsFirst"===this.dataFormat&&(i=g.transpose(i,[0,3,1,2])),i})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=aa(this.depthwiseInitializer),e.pointwiseInitializer=aa(this.pointwiseInitializer),e.depthwiseRegularizer=xo(this.depthwiseRegularizer),e.pointwiseRegularizer=xo(this.pointwiseRegularizer),e.depthwiseConstraint=Ja(this.depthwiseConstraint),e.pointwiseConstraint=Ja(this.pointwiseConstraint),e}}return t.className="SeparableConv",t})();g.serialization.registerClass((()=>{class t extends wat{constructor(e){super(2,e)}}return t.className="SeparableConv2D",t})()),g.serialization.registerClass((()=>{class t extends Pp{constructor(e){super(1,e),t.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!rI(e.kernelSize,"number",1,1))throw new we(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv1D",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return(0,g.tidy)(()=>{if(e=Fr(e),"channelsLast"===this.dataFormat){const i=M_(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return M_(i,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const i=M_(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return M_(i,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Cropping2D",t})());let Dat=(()=>{class t extends xi{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Aa(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function yst(t){Hd(fst,"InterpolationFormat",t)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return g.tidy(()=>{let i=Fr(e);const s=i.shape;if("channelsFirst"===this.dataFormat){i=g.transpose(i,[0,2,3,1]);const o=this.size[0]*s[2],a=this.size[1]*s[3],u="nearest"===this.interpolation?g.image.resizeNearestNeighbor(i,[o,a]):g.image.resizeBilinear(i,[o,a]);return g.transpose(u,[0,3,1,2])}{const o=this.size[0]*s[1],a=this.size[1]*s[2];return"nearest"===this.interpolation?g.image.resizeNearestNeighbor(i,[o,a]):g.image.resizeBilinear(i,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return t.className="UpSampling2D",t})();g.serialization.registerClass(Dat);let Nat=(()=>{class t extends K_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Xo(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=tu(e.depthwiseConstraint),this.depthwiseRegularizer=Zo(e.depthwiseRegularizer)}build(e){if((e=xs(e)).length<4)throw new we(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new we(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const i=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return(0,g.tidy)(()=>{let i=function Tat(t,n,e=[1,1],r="valid",i,s){return(0,g.tidy)(()=>{null==i&&(i="channelsLast"),Aa(i);let o=OI(t,i);if(4!==t.rank)throw new we(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==n.rank)throw new we(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return o=g.depthwiseConv2d(o,n,e,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===i&&(o=g.transpose(o,[0,3,1,2])),o})}(e=Fr(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(i=Tc(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),i})}computeOutputShape(e){e=xs(e);const i="channelsFirst"===this.dataFormat?e[3]:e[2],s="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=Mc("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=Mc(i,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],s,o,a]:[e[0],o,a,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=aa(this.depthwiseInitializer),e.depthwiseRegularizer=xo(this.depthwiseRegularizer),e.depthwiseConstraint=Ja(this.depthwiseRegularizer),e}}return t.className="DepthwiseConv2D",t})();function mB(t,n,e,r){if(Array.isArray(t)){if(null!=n||null!=e)throw new we("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(n=t.slice(1,t.length)),t=t[0]}function i(s){return null==s||Array.isArray(s)?s:[s]}return{inputs:t,initialState:n=i(n),constants:e=i(e)}}function gB(t,n,e,r=!1,i,s,o=!1,a=!1){return g.tidy(()=>{const u=n.shape.length;if(u<3)throw new we(`Input should be at least 3D, but is ${u}D.`);const c=[1,0].concat(Sc(2,u));if(n=g.transpose(n,c),null!=s)throw new ci("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=g.cast(g.cast(i,"bool"),"float32")).rank===u-1&&(i=g.expandDims(i,-1)),i=g.transpose(i,c)),r&&(n=g.reverse(n,0),null!=i&&(i=g.reverse(i,0)));const d=[];let p,v=e;const x=n.shape[0],w=g.unstack(n);let b,T;null!=i&&(b=g.unstack(i));for(let N=0;N<x;++N){const S=w[N],U=g.tidy(()=>t(S,v));if(null==i)p=U[0],v=U[1];else{const J=g.tidy(()=>{const ht=b[N],Tt=g.sub(g.onesLike(ht),ht);return{output:g.add(g.mul(U[0],ht),g.mul(v[0],Tt)),newStates:v.map((Ot,le)=>g.add(g.mul(U[1][le],ht),g.mul(Ot,Tt)))}});p=J.output,v=J.newStates}a&&d.push(p)}return a&&(T=g.stack(d,1)),[p,T,v]})}g.serialization.registerClass(Nat);let Gg=(()=>{class t extends xi{constructor(e){let r;if(super(e),null==e.cell)throw new we("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new _B({cells:e.cell}):e.cell,null==r.stateSize)throw new we("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Qa({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?Sc(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){uI(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const i=r[0];let s;if(s=this.returnSequences?[e[0],e[1],i]:[e[0],i],this.returnState){const o=[];for(const a of r)o.push([e[0],a]);return[s].concat(o)}return s}computeMask(e,r){return g.tidy(()=>{Array.isArray(r)&&(r=r[0]);const i=this.returnSequences?r:null;if(this.returnState){const s=this.states.map(o=>null);return[i].concat(s)}return i})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let i=0;i<e;++i)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new ci("Constants support is not implemented in RNN yet.");uI(e)&&(e=e[0]);const i=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Qa({shape:[i,null,...s]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!g.util.arraysEqual(this.stateSpec.map(u=>u.shape[u.shape.length-1]),a))throw new we(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(u=>new Qa({shape:[null,u]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){(0,g.tidy)(()=>{if(!this.stateful)throw new Qc("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(null==i)throw new we("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>g.zeros([i,s])):[g.zeros([i,this.cell.stateSize])];else if(null==e)g.dispose(this.states_),null!=this.keptStates&&(g.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>g.zeros([i,s])):this.states_[0]=g.zeros([i,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new we(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):g.dispose(this.states_);for(let s=0;s<this.states_.length;++s){const o=e[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,u=[i,a];if(!g.util.arraysEqual(o.shape,u))throw new we(`State ${s} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${o.shape}`);this.states_[s]=o}}this.states_=this.states_.map(s=>g.keep(s.clone()))})}apply(e,r){let i=null==r?null:r.initialState,s=null==r?null:r.constants;null==r&&(r={});const o=mB(e,i,s,this.numConstants);e=o.inputs,i=o.initialState,s=o.constants;let a=[],u=[];if(null!=i){r.initialState=i,a=a.concat(i),this.stateSpec=[];for(const d of i)this.stateSpec.push(new Qa({shape:d.shape}));u=u.concat(this.stateSpec)}if(null!=s&&(r.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof nh){const d=[e].concat(a),p=this.inputSpec.concat(u),v=this.inputSpec;this.inputSpec=p;const x=super.apply(d,r);return this.inputSpec=v,x}return super.apply(e,r)}call(e,r){return(0,g.tidy)(()=>{const i=null==r?null:r.mask,s=null==r?null:r.training;let o=null==r?null:r.initialState;e=Fr(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new we(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const u={training:s},d=gB((b,T)=>{const N=this.cell.call([b].concat(T),u);return[N[0],N.slice(1)]},e,o,this.goBackwards,i,null,this.unroll,this.returnSequences),p=d[0],v=d[1],x=d[2];this.stateful&&this.resetStates(x,s);const w=this.returnSequences?v:p;return this.returnState?[w].concat(x):w})}getInitialState(e){return(0,g.tidy)(()=>{let r=g.zeros(e.shape);return r=g.sum(r,[1,2]),r=Fg(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>i>1?oI(r,[1,i]):r):this.cell.stateSize>1?[oI(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===t.className&&(r.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),e),r)}static fromConfig(e,r,i={}){const o=Th(r.cell,i);return new e(Object.assign(r,{cell:o}))}}return t.className="RNN",t})();g.serialization.registerClass(Gg);class X_ extends xi{}let yB=(()=>{class t extends X_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,du(this.units,"units"),this.activation=od(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Xo(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xo(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xo(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Zo(e.kernelRegularizer),this.recurrentRegularizer=Zo(e.recurrentRegularizer),this.biasRegularizer=Zo(e.biasRegularizer),this.kernelConstraint=tu(e.kernelConstraint),this.recurrentConstraint=tu(e.recurrentConstraint),this.biasConstraint=tu(e.biasConstraint),this.dropout=Tp([1,nd([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Tp([1,nd([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=xs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return(0,g.tidy)(()=>{if(2!==e.length)throw new we(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let i=e[1];e=e[0];const s=null!=r.training&&r.training;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ad({ones:()=>g.onesLike(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ad({ones:()=>g.onesLike(i),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,u=this.recurrentDropoutMask;o=th(null!=a?g.mul(e,a):e,this.kernel.read()),null!=this.bias&&(o=Tc(o,this.bias.read())),null!=u&&(i=g.mul(i,u));let c=g.add(o,th(i,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:sd(this.activation),useBias:this.useBias,kernelInitializer:aa(this.kernelInitializer),recurrentInitializer:aa(this.recurrentInitializer),biasInitializer:aa(this.biasInitializer),kernelRegularizer:xo(this.kernelRegularizer),recurrentRegularizer:xo(this.recurrentRegularizer),biasRegularizer:xo(this.biasRegularizer),activityRegularizer:xo(this.activityRegularizer),kernelConstraint:Ja(this.kernelConstraint),recurrentConstraint:Ja(this.recurrentConstraint),biasConstraint:Ja(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return t.className="SimpleRNNCell",t})();g.serialization.registerClass(yB);let Aat=(()=>{class t extends Gg{constructor(e){e.cell=new yB(e),super(e)}call(e,r){return(0,g.tidy)(()=>(null!=this.cell.dropoutMask&&(g.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(g.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return t.className="SimpleRNN",t})();g.serialization.registerClass(Aat);let vB=(()=>{class t extends X_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new we("GRUCell does not support reset_after parameter set to true.");this.units=e.units,du(this.units,"units"),this.activation=od(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=od(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Xo(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xo(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xo(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Zo(e.kernelRegularizer),this.recurrentRegularizer=Zo(e.recurrentRegularizer),this.biasRegularizer=Zo(e.biasRegularizer),this.kernelConstraint=tu(e.kernelConstraint),this.recurrentConstraint=tu(e.recurrentConstraint),this.biasConstraint=tu(e.biasConstraint),this.dropout=Tp([1,nd([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Tp([1,nd([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=xs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return(0,g.tidy)(()=>{if(2!==e.length)throw new we(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const i=null!=r.training&&r.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ad({ones:()=>g.onesLike(e),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ad({ones:()=>g.onesLike(s),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let u,c,d;0<this.dropout&&this.dropout<1&&(e=g.mul(e,this.dropoutMask[0]));let p=th(e,this.kernel.read());this.useBias&&(p=Tc(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=g.mul(s,a[0]));const v=this.recurrentKernel.read(),[x,w]=g.split(v,[2*this.units,this.units],v.rank-1),b=th(s,x),[T,N,S]=g.split(p,3,p.rank-1),[U,J]=g.split(b,2,b.rank-1);u=this.recurrentActivation.apply(g.add(T,U)),c=this.recurrentActivation.apply(g.add(N,J));const ht=th(g.mul(c,s),w);d=this.activation.apply(g.add(S,ht));const Tt=g.add(g.mul(u,s),g.mul(g.add(1,g.neg(u)),d));return[Tt,Tt]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:sd(this.activation),recurrentActivation:sd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:aa(this.kernelInitializer),recurrentInitializer:aa(this.recurrentInitializer),biasInitializer:aa(this.biasInitializer),kernelRegularizer:xo(this.kernelRegularizer),recurrentRegularizer:xo(this.recurrentRegularizer),biasRegularizer:xo(this.biasRegularizer),activityRegularizer:xo(this.activityRegularizer),kernelConstraint:Ja(this.kernelConstraint),recurrentConstraint:Ja(this.recurrentConstraint),biasConstraint:Ja(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return t.className="GRUCell",t})();g.serialization.registerClass(vB);let Mat=(()=>{class t extends Gg{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new vB(e),super(e)}call(e,r){return(0,g.tidy)(()=>(null!=this.cell.dropoutMask&&(g.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(g.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="GRU",t})();g.serialization.registerClass(Mat);let LI=(()=>{class t extends X_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,du(this.units,"units"),this.activation=od(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=od(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Xo(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xo(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xo(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Zo(e.kernelRegularizer),this.recurrentRegularizer=Zo(e.recurrentRegularizer),this.biasRegularizer=Zo(e.biasRegularizer),this.kernelConstraint=tu(e.kernelConstraint),this.recurrentConstraint=tu(e.recurrentConstraint),this.biasConstraint=tu(e.biasConstraint),this.dropout=Tp([1,nd([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Tp([1,nd([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let s;if(e=xs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;s=new((r=class extends hc{apply(c,d){const p=o.apply([a]),v=(new b$).apply([a]),x=o.apply([2*a]);return E$(E$(p,v),x)}}).className="CustomInit",r)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return(0,g.tidy)(()=>{const i=null!=r.training&&r.training;if(3!==e.length)throw new we(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ad({ones:()=>g.onesLike(e),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ad({ones:()=>g.onesLike(s),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const u=this.recurrentDropoutMask;let c,d,p,v;0<this.dropout&&this.dropout<1&&(e=g.mul(e,this.dropoutMask[0]));let x=th(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=g.mul(s,u[0])),x=g.add(x,th(s,this.recurrentKernel.read())),this.useBias&&(x=Tc(x,this.bias.read()));const[w,b,T,N]=g.split(x,4,x.rank-1);c=this.recurrentActivation.apply(w),d=this.recurrentActivation.apply(b),p=g.add(g.mul(d,o),g.mul(c,this.activation.apply(T))),v=this.recurrentActivation.apply(N);const S=g.mul(v,this.activation.apply(p));return[S,S,p]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:sd(this.activation),recurrentActivation:sd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:aa(this.kernelInitializer),recurrentInitializer:aa(this.recurrentInitializer),biasInitializer:aa(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:xo(this.kernelRegularizer),recurrentRegularizer:xo(this.recurrentRegularizer),biasRegularizer:xo(this.biasRegularizer),activityRegularizer:xo(this.activityRegularizer),kernelConstraint:Ja(this.kernelConstraint),recurrentConstraint:Ja(this.recurrentConstraint),biasConstraint:Ja(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return t.className="LSTMCell",t})();g.serialization.registerClass(LI);let Pat=(()=>{class t extends Gg{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new LI(e),super(e)}call(e,r){return(0,g.tidy)(()=>(null!=this.cell.dropoutMask&&(g.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(g.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="LSTM",t})();g.serialization.registerClass(Pat);let _B=(()=>{class t extends X_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return(0,g.tidy)(()=>{let i=e.slice(1);const s=[];for(const u of this.cells.slice().reverse())Array.isArray(u.stateSize)?s.push(i.splice(0,u.stateSize.length)):s.push(i.splice(0,1));s.reverse();const o=[];let a;for(let u=0;u<this.cells.length;++u){const c=this.cells[u];i=s[u],a=0===u?[e[0]].concat(i):[a[0]].concat(i),a=c.call(a,r),o.push(a.slice(1))}i=[];for(const u of o.slice().reverse())i.push(...u);return[a[0]].concat(i)})}build(e){let r;uI(e)&&(e=e[0]),this.cells.forEach((i,s)=>{jd(`RNNCell_${s}`,()=>{i.build(e),r=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),s={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),s)}static fromConfig(e,r,i={}){const s=[];for(const o of r.cells)s.push(Th(o,i));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const i of this.cells)r.push(...i.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return lI(e)}setWeights(e){const r=[];for(const i of this.cells){const o=e.splice(i.weights.length);for(let a=0;a<i.weights.length;++a)r.push([i.weights[a],o[a]])}cI(r)}}return t.className="StackedRNNCells",t})();function ad(t){const{ones:n,rate:e,training:r=!1,count:i=1,dropoutFunc:s}=t,o=()=>null!=s?s(n(),e):w$(n(),e),a=()=>Bg(o,n,r);return!i||i<=1?g.keep(a().clone()):Array(i).fill(void 0).map(a).map(c=>g.keep(c.clone()))}g.serialization.registerClass(_B);let Rat=(()=>{class t extends Gg{constructor(e){if(e.unroll)throw new ci("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ci("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Qa({ndim:5})]}call(e,r){return g.tidy(()=>{if(null!=this.cell.dropoutMask&&(g.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(g.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new we("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return g.tidy(()=>{const{stateSize:r}=this.cell,s=this.computeSingleOutputShape(e.shape),o=[s[0],...s.slice(2)],a=g.zeros(o);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){g.tidy(()=>{if(!this.stateful)throw new Qc("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape,s=this.computeSingleOutputShape(i),o=[s[0],...s.slice(2)];if(null==i[0])throw new we("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>g.zeros(o)):[g.zeros(o)];else if(null==e)g.dispose(this.states_),null!=this.keptStates&&(g.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>g.zeros(o)):this.states_[0]=g.zeros(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new we(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):g.dispose(this.states_);for(let u=0;u<this.states_.length;++u){const c=e[u],d=o;if(!g.util.arraysEqual(c.shape,d))throw new we(`State ${u} is incompatible with layer ${this.name}: expected shape=${d}, received shape=${c.shape}`);this.states_[u]=c}}this.states_=this.states_.map(u=>g.keep(u.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:i,kernelSize:s,padding:o,strides:a,dilationRate:u}=this.cell,c="channelsFirst"===r,p=e[c?4:3],v=Mc(e[c?3:2],s[0],o,a[0],u[0]),x=Mc(p,s[1],o,a[1],u[1]);return[...e.slice(0,2),...c?[i,v,x]:[v,x,i]]}}return t.className="ConvRNN2D",t})(),xB=(()=>{class t extends LI{constructor(e){const{filters:r,kernelSize:i,strides:s,padding:o,dataFormat:a,dilationRate:u}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,du(this.filters,"filters"),this.kernelSize=Mp(i,2,"kernelSize"),this.kernelSize.forEach(c=>du(c,"kernelSize")),this.strides=Mp(s||1,2,"strides"),this.strides.forEach(c=>du(c,"strides")),this.padding=o||"valid",Vl(this.padding),this.dataFormat=a||"channelsLast",Aa(this.dataFormat),this.dilationRate=Mp(u||1,2,"dilationRate"),this.dilationRate.forEach(c=>du(c,"dilationRate"))}build(e){var r;e=xs(e);const i="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[i])throw new we(`The channel dimension of the input should be defined. Found ${e[i]}`);const a=this.kernelSize.concat([e[i],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const u=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",u,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const d=this.biasInitializer,p=this.filters;c=new((r=class extends hc{apply(x,w){return sI([d.apply([p]),g.ones([p]),d.apply([2*p])])}}).className="CustomInit",r)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return g.tidy(()=>{if(3!==e.length)throw new we(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const i=r.training||!1,s=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ad({ones:()=>g.onesLike(s),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,d=(rn,pn,Qe)=>pn&&pn[Qe]?g.mul(pn[Qe],rn):rn;let p=d(s,c,0),v=d(s,c,1),x=d(s,c,2),w=d(s,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ad({ones:()=>g.onesLike(o),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let T=d(o,b,0),N=d(o,b,1),S=d(o,b,2),U=d(o,b,3);const[ht,Tt,Pt,zt]=g.split(this.kernel.read(),4,3),[Ot,le,ge,Ae]=this.useBias?g.split(this.bias.read(),4):[null,null,null,null];p=this.inputConv(p,ht,Ot,this.padding),v=this.inputConv(v,Tt,le,this.padding),x=this.inputConv(x,Pt,ge,this.padding),w=this.inputConv(w,zt,Ae,this.padding);const[Re,ve,Ne,Se]=g.split(this.recurrentKernel.read(),4,3);T=this.recurrentConv(T,Re),N=this.recurrentConv(N,ve),S=this.recurrentConv(S,Ne),U=this.recurrentConv(U,Se);const Ke=this.recurrentActivation.apply(g.add(p,T)),Le=this.recurrentActivation.apply(g.add(v,N)),Be=g.add(g.mul(Le,a),g.mul(Ke,this.activation.apply(g.add(x,S)))),on=g.mul(this.recurrentActivation.apply(g.add(w,U)),this.activation.apply(Be));return[on,on,Be]})}getConfig(){const i=function(t,n){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(t);i<r.length;i++)n.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(e[r[i]]=t[r[i]])}return e}(super.getConfig(),["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},i),s)}inputConv(e,r,i,s){const o=g.conv2d(e,r,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return i?Tc(o,i,this.dataFormat):o}recurrentConv(e,r){return g.conv2d(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return t.className="ConvLSTM2DCell",t})();g.serialization.registerClass(xB),g.serialization.registerClass((()=>{class t extends Rat{constructor(e){const r=new xB(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return t.className="ConvLSTM2D",t})());let EB=(()=>{class t extends xi{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,i=[];for(let s=0;s<this.noiseShape.length;++s)i.push(null==this.noiseShape[s]?r[s]:this.noiseShape[s]);return i}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e);if(0<this.rate&&this.rate<1){const s=null!=r.training&&r.training,o=this.getNoiseShape(i);return Bg(()=>w$(i,this.rate,o,this.seed),()=>i,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return t.className="Dropout",t})();g.serialization.registerClass(EB),g.serialization.registerClass((()=>{class t extends EB{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return t.className="SpatialDropout1D",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,du(this.units,"units"),this.activation=od(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Xo(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Xo(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=tu(e.kernelConstraint),this.biasConstraint=tu(e.biasConstraint),this.kernelRegularizer=Zo(e.kernelRegularizer),this.biasRegularizer=Zo(e.biasRegularizer),this.activityRegularizer=Zo(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=xs(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=xs(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e),s=f$(this.activation.getClassName());let o;return null!=s?o=th(i,this.kernel.read(),s,this.bias?this.bias.read():null):(o=th(i,this.kernel.read()),null!=this.bias&&(o=Tc(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:sd(this.activation),useBias:this.useBias,kernelInitializer:aa(this.kernelInitializer),biasInitializer:aa(this.biasInitializer),kernelRegularizer:xo(this.kernelRegularizer),biasRegularizer:xo(this.biasRegularizer),activityRegularizer:xo(this.activityRegularizer),kernelConstraint:Ja(this.kernelConstraint),biasConstraint:Ja(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dense",t})());let $at=(()=>{class t extends xi{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=xs(e);for(const r of e.slice(1))if(null==r)throw new we(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ed(e,1)]}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);let i=Fr(e);if("channelsFirst"===this.dataFormat&&i.rank>1){const s=[0];for(let o=2;o<i.rank;++o)s.push(o);s.push(1),i=(0,g.transpose)(i,s)}return function Ist(t){if(t.rank<=1)throw new we(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const n=[t.shape[0],ed(t.shape,1)];return g.reshape(t,n)}(i)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return t.className="Flatten",t})();g.serialization.registerClass($at),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.supportsMasking=!0,this.activation=od(e.activation)}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e);return this.activation.apply(i)})}getConfig(){const e={activation:sd(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Activation",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return(0,g.tidy)(()=>function wst(t,n){return(0,g.tidy)(()=>{if(2!==t.shape.length)throw new we(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return oI(Fg(t,1),[1,n,1])})}(e=Fr(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return t.className="RepeatVector",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const i="Total size of new array must be unchanged.",s=r.slice();let o=1,a=null;for(let c=0;c<s.length;++c){const d=s[c];if(this.isUnknown(d)){if(null!==a)throw new we("Can only specifiy one unknown dimension.");a=c}else o*=d}const u=ed(e);if(null!==a){if(0===o||u%o!=0)throw new we(i);s[a]=u/o}else if(u!==o)throw new we(i);return s}computeOutputShape(e){let r=!1;for(let i=0;i<e.length;++i)if(this.isUnknown(e[i])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e),s=i.shape,o=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return(0,g.reshape)(i,o)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Reshape",t})());let Uat=(()=>{class t extends xi{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=Sc(1,e.dims.length+1);if(!g.util.arraysEqual(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Qa({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=xs(e)).slice();return this.dims.forEach((i,s)=>{r[s+1]=e[i]}),r}call(e,r){return(0,g.transpose)(Fr(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Permute",t})();g.serialization.registerClass(Uat),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const i=Fr(e);return(0,g.any)((0,g.notEqual)(i,this.maskValue),-1)}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e),a=(0,g.any)((0,g.notEqual)(i,this.maskValue),-1,!0);return(0,g.mul)(i,(0,g.cast)(a,i.dtype))})}}return t.className="Masking",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(Gs(e.inputLength))}this.inputDim=e.inputDim,du(this.inputDim,"inputDim"),this.outputDim=e.outputDim,du(this.outputDim,"outputDim"),this.embeddingsInitializer=Xo(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Zo(e.embeddingsRegularizer),this.activityRegularizer=Zo(e.activityRegularizer),this.embeddingsConstraint=tu(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return(0,g.tidy)(()=>this.maskZero?(e=Fr(e),(0,g.notEqual)(e,(0,g.zerosLike)(e))):null)}computeOutputShape(e){if(e=xs(e),null==this.inputLength)return[...e,this.outputDim];const r=Gs(this.inputLength);if(r.length!==e.length-1)throw new we(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let i=0;for(let s=0;s<r.length;++s){const o=r[s],a=e[s+1];if(null!=o&&null!=a&&o!==a)throw new we(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(r[i]=a),i++}}return[e[0],...r,this.outputDim]}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);let i=Fr(e);"int32"!==i.dtype&&(i=Jc(i,"int32"));const s=C$(this.embeddings.read(),(0,g.reshape)(i,[i.size]));return(0,g.reshape)(s,xs(this.computeOutputShape(i.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:aa(this.embeddingsInitializer),embeddingsRegularizer:xo(this.embeddingsRegularizer),activityRegularizer:xo(this.activityRegularizer),embeddingsConstraint:Ja(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Embedding",t})());class Xd extends xi{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new ci}computeElementwiseOpOutputShape(n,e){if(null==n||null==e)return null;if(n.length<e.length)return this.computeElementwiseOpOutputShape(e,n);if(0===e.length)return n;const r=n.slice(0,n.length-e.length);for(let i=0;i<e.length;++i){const s=n[n.length-e.length+i],o=e[i];if(null==s||null==o||s<0||o<0)r.push(null);else if(1===s)r.push(o);else if(1===o)r.push(s);else{if(s!==o)throw new we("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(e));r.push(s)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[xs(n)]),n.length<2)throw new we(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let e=[];for(const s of n)null!=s&&null!==s[0]&&e.push(s[0]);if(e=td(e),e.length>1)throw new we(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=null==n[0]?null:n[0].slice(1);for(let s=1;s<n.length;++s){const o=null==n[s]?null:n[s].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const i=n.map(s=>s.length);this.reshapeRequired=-1!==n.indexOf(null)||1!==td(i).length}call(n,e){return(0,g.tidy)(()=>{if(this.reshapeRequired){const r=[],i=n.map(s=>s.rank);if(-1===i.indexOf(null)){const s=nd(i);for(let o of n){const a=o.rank;for(let u=0;u<s-a;++u)o=Fg(o,1);r.push(o)}return this.mergeFunction(r)}{let s=!1;for(const u of n){const c=u.rank;if(null==c){const d=u.shape,p=d[0],v=d.slice(1).concat([p]);let x=g.reshape(u,[p].concat(ed(d.slice(1))));x=g.transpose(x,[1,0]),x=g.reshape(x,v),r.push(x),s=!0}else if(c>1){const d=Sc(1,c).concat([0]);r.push(g.transpose(u,d)),s=!0}else r.push(u)}let o=this.mergeFunction(r);const a=o.rank;if(s)if(null==a){const u=o.shape,d=u[u.length-1],p=[d].concat(u.slice(0,u.length-1));o=g.reshape(g.transpose(g.reshape(o,[-1,d]),[1,0]),p)}else if(a>1){const u=[a-1].concat(Sc(0,a-1));o=g.transpose(o,u)}return o}}return this.mergeFunction(n)})}computeOutputShape(n){let e;e=null==n[0]?null:n[0].slice(1);for(let i=1;i<n.length;++i){const s=null==n[i]?null:n[i].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let r=[];for(const i of n)null!=i&&null!==i[0]&&r.push(i[0]);return r=td(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(n,e){return g.tidy(()=>{if(null==e)return null;if(!Array.isArray(e))throw new we("`mask` should be an Array");if(!Array.isArray(n))throw new we("`inputs` should be an Array");if(e.length!==n.length)throw new we(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${e.length})`);if(e.every(i=>null==i))return null;let r=(e=e.map(i=>null==i?i:g.expandDims(i,0)))[0];for(let i=1;i<e.length-1;++i)r=g.logicalAnd(r,e[i]);return r})}}let kI=(()=>{class t extends Xd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=g.add(r,e[i]);return r})}}return t.className="Add",t})();g.serialization.registerClass(kI);let FI=(()=>{class t extends Xd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=g.mul(r,e[i]);return r})}}return t.className="Multiply",t})();g.serialization.registerClass(FI);let $I=(()=>{class t extends Xd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=g.add(r,e[i]);return g.mul(1/e.length,r)})}}return t.className="Average",t})();g.serialization.registerClass($I);let BI=(()=>{class t extends Xd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0];for(let i=1;i<e.length;++i)r=g.maximum(r,e[i]);return r})}}return t.className="Maximum",t})();g.serialization.registerClass(BI);let zI=(()=>{class t extends Xd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0];for(let i=1;i<e.length;++i)r=g.minimum(r,e[i]);return r})}}return t.className="Minimum",t})();g.serialization.registerClass(zI);let VI=(()=>{class t extends Xd{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new we("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const s of e)if(null!=s){r=!1;break}if(r)return;const i=[];for(let s=0;s<e.length;++s){const o=e[s].slice();o.splice(this.axis,1);let a=!1;for(const u of i)if(g.util.arraysEqual(u,o)){a=!0;break}a||i.push(o)}if(i.length>1)throw new we("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return(0,g.tidy)(()=>sI(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new we("A `Concatenate` layer should be called on a list of inputs.");const r=e,i=r[0].slice(),s=this.axis<0?i.length+this.axis:this.axis;for(const o of r.slice(1)){if(null==i[s]||null==o[s]){i[s]=null;break}i[s]+=o[s]}return i}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new we("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new we("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new we(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return g.tidy(()=>{let i=!0;if(r.forEach(a=>{null==a||(i=!1)}),i)return null;const s=[];for(let a=0;a<e.length;++a)s.push(null==r[a]?g.cast(g.onesLike(e[a]),"bool"):r[a].rank<e[a].rank?g.expandDims(r[a],-1):r[a]);const o=g.concat(s,this.axis);return g.all(o,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Concatenate",t})();function Hg(t,n){for(;t<0;)t+=n;return t}g.serialization.registerClass(VI);let jat=(()=>{class t extends Xd{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){g.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],i=e[1];if(r.length>3||i.length>3)throw new ci("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(r,i);if(r[s[0]]!==i[s[1]])throw new we(`Dimension incompatibility: ${r[s[0]]} !== ${i[s[1]]}`)}mergeFunction(e){if(2!==e.length)throw new we(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let s,r=e[0],i=e[1];return s=Array.isArray(this.axes)?this.axes.map((o,a)=>Hg(o,e[a].shape.length)):[Hg(this.axes,r.shape.length),Hg(this.axes,i.shape.length)],this.normalize&&(r=B_(r,s[0]),i=B_(i,s[1])),function Hat(t,n,e){if(t.shape.length>3||n.shape.length>3)throw new ci("batchDot is not implemented for tensors of 4D or higher rank yet");if(g.util.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),g.util.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===t.dtype||"complex64"===n.dtype)throw new ci("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,i=n.shape.length;null==e&&(e=[r-1,i-2]);const s=e;return g.tidy(()=>{let o,a;if(r>i){o=r-i;const u=[];for(let c=0;c<o;++c)u.push(1);n=g.reshape(n,n.shape.concat(u))}else if(i>r){o=i-r;const u=[];for(let c=0;c<o;++c)u.push(1);t=g.reshape(t,t.shape.concat(u))}else o=0;if(a=2===t.shape.length&&2===n.shape.length?s[0]===s[1]?g.sum(g.mul(t,n),s[0]):g.sum(g.mul(g.transpose(t,[1,0]),n),s[1]):g.matMul(t,n,s[0]!==t.shape.length-1,s[1]===n.shape.length-1),o>0){let u;u=r>i?r+i-3:r-1;const c=[];for(let d=u;d<u+o;++d)c.push(d);a=g.squeeze(a,c)}return 1===a.shape.length&&(a=g.expandDims(a,1)),a})}(r,i,s)}interpretAxes(e,r){let i;return i=Array.isArray(this.axes)?this.axes:[Hg(this.axes,e.length),Hg(this.axes,r.length)],i}computeOutputShape(e){g.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),i=e[1].slice();if(r.length>3||i.length>3)throw new ci("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(r,i);r.splice(s[0],1),i.splice(s[1],1),i.splice(0,1);const o=r.concat(i);return 1===o.length&&o.push(1),o}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dot",t})();function jg(t,n,e,r,i,s=.001){let o;if(2===t.rank)o=g.batchNorm2d(t,n,e,r,i,s);else if(3===t.rank)o=g.batchNorm3d(t,n,e,r,i,s);else{if(4!==t.rank)throw new ci(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=g.batchNorm4d(t,n,e,r,i,s)}return o}g.serialization.registerClass(jat),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e);return Bg(()=>(0,g.add)(P_(i.shape,0,this.stddev),i),()=>i,r.training||!1)})}}return t.className="GaussianNoise",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e);return this.rate>0&&this.rate<1?Bg(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return(0,g.mul)(i,P_(i.shape,1,o))},()=>i,r.training||!1):i})}}return t.className="GaussianDropout",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Fr(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return(0,g.tidy)(()=>{if(this.rate<1&&this.rate>0){const i=this._getNoiseShape(e);return Bg(()=>{const o=Fr(e),c=-1.7580993408473766;let d=(0,g.greaterEqual)((0,g.randomUniform)(i),this.rate);d=Jc(d,"float32");const p=((1-this.rate)*(1+this.rate*c**2))**-.5,v=-p*c*this.rate,x=(0,g.add)((0,g.mul)(o,d),(0,g.mul)((0,g.add)(d,-1),c));return(0,g.add)((0,g.mul)(x,p),v)},()=>Fr(e),r.training||!1)}return e})}}return t.className="AlphaDropout",t})());let Jat=(()=>{class t extends xi{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Xo(e.betaInitializer||"zeros"),this.gammaInitializer=Xo(e.gammaInitializer||"ones"),this.movingMeanInitializer=Xo(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Xo(e.movingVarianceInitializer||"ones"),this.betaConstraint=tu(e.betaConstraint),this.gammaConstraint=tu(e.gammaConstraint),this.betaRegularizer=Zo(e.betaRegularizer),this.gammaRegularizer=Zo(e.gammaRegularizer)}build(e){e=xs(e);const r=this.axis>=0?this.axis:this.axis+e.length,i=e[r];if(null==i)throw new we(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Qa({ndim:e.length,axes:{[r]:i}})];const s=[i];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return(0,g.tidy)(()=>{const i=null!=r.training&&r.training,s=Fr(e),o=s.shape,a=o.length,u=Sc(0,a),c=this.axis>=0?this.axis:this.axis+a;u.splice(c,1);const d=Wd(1,a);d[c]=o[c];const p=u.slice();p.sort();const v=!g.util.arraysEqual(p,Sc(0,a).slice(0,a-1));if(!i)return(()=>{if(v){const U=(0,g.reshape)(this.movingMean.read(),d),J=(0,g.reshape)(this.movingVariance.read(),d),ht=this.center?(0,g.reshape)(this.beta.read(),d):null,Tt=this.scale?(0,g.reshape)(this.gamma.read(),d):null;return jg(s,U,J,ht,Tt,this.epsilon)}return jg(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[w,b,T]=function Qat(t,n,e,r,i=.001){return g.util.arraysEqual(r.slice().sort(),Sc(0,t.rank-1))?function Yat(t,n,e,r,i=.001){return(0,g.tidy)(()=>{const s=g.moments(t,r),o=s.mean,a=s.variance;return[jg(t,o,a,e,n,i),o,a]})}(t,n,e,r,i):function qat(t,n,e,r,i=.001){return(0,g.tidy)(()=>{const s=g.moments(t,r),o=s.mean,a=s.variance,u=[];for(const w of Sc(0,t.rank))-1!==r.indexOf(w)?u.push(1):u.push(t.shape[w]);const c=(0,g.reshape)(o,u),d=(0,g.reshape)(a,u),p=null==n?null:(0,g.reshape)(n,u),v=null==e?null:(0,g.reshape)(e,u);return[jg(t,c,d,v,p,i),o,a]})}(t,n,e,r,i)}(s,this.gamma.read(),this.beta.read(),u,this.epsilon),N=(U,J,ht)=>{g.tidy(()=>{const Tt=1-ht,Pt=U.read(),zt=g.mul(g.sub(Pt,J),Tt);U.write(g.sub(Pt,zt))})};return(()=>{N(this.movingMean,b,this.momentum),N(this.movingVariance,T,this.momentum)})(),w})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:aa(this.betaInitializer),gammaInitializer:aa(this.gammaInitializer),movingMeanInitializer:aa(this.movingMeanInitializer),movingVarianceInitializer:aa(this.movingVarianceInitializer),betaRegularizer:xo(this.betaRegularizer),gammaRegularizer:xo(this.gammaRegularizer),betaConstraint:Ja(this.betaConstraint),gammaConstraint:Ja(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BatchNormalization",t})();g.serialization.registerClass(Jat);let tut=(()=>{class t extends xi{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Xo(e.betaInitializer||"zeros"),this.gammaInitializer=Xo(e.gammaInitializer||"ones"),this.betaRegularizer=Zo(e.betaRegularizer),this.gammaRegularizer=Zo(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=xs(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=r);for(const o of this.axis)if(o<0||o>=r)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==td(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const i=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",i,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",i,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const i=Fr(e),s=i.shape,o=s.length;return(0,g.tidy)(()=>{let{mean:u,variance:c}=(0,g.moments)(i,this.axis,!0);const d=Wd(1,o);for(const T of this.axis)d[T]=s[T];const p=T=>null!=T&&T.shape.length!==o?g.reshape(T,d):T;let v=this.scale?p(this.gamma.read()):null,x=this.center?p(this.beta.read()):null;const w=[],b=[];for(let T=0;T<o;++T)-1!==this.axis.indexOf(T)?(w.push(s[T]),b.push(1)):(w.push(1),b.push(s[T]));return u=g.tile(u,w),c=g.tile(c,w),null!=v&&(v=g.tile(v,b)),null!=x&&(x=g.tile(x,b)),jg(i,u,c,x,v,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:aa(this.betaInitializer),gammaInitializer:aa(this.gammaInitializer),betaRegularizer:xo(this.betaRegularizer),gammaRegularizer:xo(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LayerNormalization",t})();g.serialization.registerClass(tut);let nut=(()=>{class t extends xi{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new we(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,i;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],i=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new we(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new we(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);i=e.padding[1]}this.padding=[r,i]}this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(e){let r,i;return e=xs(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,i=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,i]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,i=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,i,e[3]])}call(e,r){return(0,g.tidy)(()=>function eut(t,n,e){return(0,g.tidy)(()=>{if(4!==t.rank)throw new we(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new we("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new we(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],g.pad(t,r)})}(Fr(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ZeroPadding2D",t})();function Z_(t,n,e,r,i,s){return(0,g.tidy)(()=>{let o;Aa(i),m$(s),Vl(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),t=OI(t,i);const a="same"===r?"same":"valid";return o="max"===s?g.maxPool(t,n,e,a):g.avgPool(t,n,e,a),"channelsFirst"===i&&(o=g.transpose(o,[0,3,1,2])),o})}function CB(t,n,e,r,i,s){return(0,g.tidy)(()=>{let o;Aa(i),m$(s),Vl(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),t=cB(t,i);const a="same"===r?"same":"valid";return o="max"===s?g.maxPool3d(t,n,e,a):g.avgPool3d(t,n,e,a),"channelsFirst"===i&&(o=g.transpose(o,[0,4,1,2,3])),o})}g.serialization.registerClass(nut);class wB extends xi{constructor(n){if(null==n.poolSize&&(n.poolSize=2),super(n),"number"==typeof n.poolSize)this.poolSize=[n.poolSize];else{if(!Array.isArray(n.poolSize)||1!==n.poolSize.length||"number"!=typeof n.poolSize[0])throw new we(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);this.poolSize=n.poolSize}if(du(this.poolSize,"poolSize"),null==n.strides)this.strides=this.poolSize;else if("number"==typeof n.strides)this.strides=[n.strides];else{if(!Array.isArray(n.strides)||1!==n.strides.length||"number"!=typeof n.strides[0])throw new we(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);this.strides=n.strides}du(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,Vl(this.padding),this.inputSpec=[new Qa({ndim:3})]}computeOutputShape(n){const e=Mc((n=xs(n))[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],e,n[2]]}call(n,e){return(0,g.tidy)(()=>{this.invokeCallHook(n,e),n=Fg(Fr(n),2);const r=this.poolingFunction(Fr(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return g.squeeze(r,[2])})}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(n,e),n}}g.serialization.registerClass((()=>{class t extends wB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Aa(o),Vl(s),Z_(e,r,i,s,o,"max")}}return t.className="MaxPooling1D",t})()),g.serialization.registerClass((()=>{class t extends wB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Aa(o),Vl(s),Z_(e,r,i,s,o,"avg")}}return t.className="AveragePooling1D",t})());class bB extends xi{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(2!==n.strides.length)throw new we(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];du(this.poolSize,"poolSize"),du(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Aa(this.dataFormat),Vl(this.padding),this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(n){n=xs(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2];return e=Mc(e,this.poolSize[0],this.padding,this.strides[0]),r=Mc(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r]:[n[0],e,r,n[3]]}call(n,e){return(0,g.tidy)(()=>(this.invokeCallHook(n,e),this.poolingFunction(Fr(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}g.serialization.registerClass((()=>{class t extends bB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Aa(o),Vl(s),Z_(e,r,i,s,o,"max")}}return t.className="MaxPooling2D",t})()),g.serialization.registerClass((()=>{class t extends bB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Aa(o),Vl(s),Z_(e,r,i,s,o,"avg")}}return t.className="AveragePooling2D",t})());class IB extends xi{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(3!==n.strides.length)throw new we(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];du(this.poolSize,"poolSize"),du(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Aa(this.dataFormat),Vl(this.padding),this.inputSpec=[new Qa({ndim:5})]}computeOutputShape(n){n=xs(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2],i="channelsFirst"===this.dataFormat?n[4]:n[3];return e=Mc(e,this.poolSize[0],this.padding,this.strides[0]),r=Mc(r,this.poolSize[1],this.padding,this.strides[1]),i=Mc(i,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r,i]:[n[0],e,r,i,n[4]]}call(n,e){return(0,g.tidy)(()=>(this.invokeCallHook(n,e),this.poolingFunction(Fr(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}g.serialization.registerClass((()=>{class t extends IB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Aa(o),Vl(s),CB(e,r,i,s,o,"max")}}return t.className="MaxPooling3D",t})()),g.serialization.registerClass((()=>{class t extends IB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Aa(o),Vl(s),CB(e,r,i,s,o,"avg")}}return t.className="AveragePooling3D",t})());class SB extends xi{constructor(n){super(n),this.inputSpec=[new Qa({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,e){throw new ci}}let lut=(()=>{class t extends SB{constructor(e){super(e||{})}call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);return g.mean(i,1)})}}return t.className="GlobalAveragePooling1D",t})();g.serialization.registerClass(lut);let hut=(()=>{class t extends SB{constructor(e){super(e||{})}call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);return g.max(i,1)})}}return t.className="GlobalMaxPooling1D",t})();g.serialization.registerClass(hut);class DB extends xi{constructor(n){super(n),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Aa(this.dataFormat),this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(n){return"channelsLast"===this.dataFormat?[n[0],n[3]]:[n[0],n[1]]}call(n,e){throw new ci}getConfig(){const n={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}let dut=(()=>{class t extends DB{call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);return g.mean(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalAveragePooling2D",t})();g.serialization.registerClass(dut);let fut=(()=>{class t extends DB{call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);return g.max(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalMaxPooling2D",t})();g.serialization.registerClass(fut);class TB extends xi{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(n){null!=this.layer&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){const n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(n,e),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,e,r={}){const s=Th(e.layer,r);delete e.layer;const o={layer:s};return Object.assign(o,e),new n(o)}}g.serialization.registerClass((()=>{class t extends TB{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=xs(e)).length<3)throw new we(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=xs(e))[0]].concat(e.slice(2)),i=this.layer.computeOutputShape(r);return[i[0],e[1]].concat(i.slice(1))}call(e,r){return(0,g.tidy)(()=>gB((a,u)=>[Fr(this.layer.call(a,r)),[]],e=Fr(e),[],!1,null,null,!1,!0)[1])}}return t.className="TimeDistributed",t})());let yut=(()=>{class t extends TB{constructor(e){super(e);const r=e.layer.getConfig(),i={};i.className=e.layer.getClassName(),i.config=r,this.forwardLayer=Th(i),r.goBackwards=!0!==r.goBackwards;const s={};if(s.className=e.layer.getClassName(),s.config=r,this.backwardLayer=Th(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function mut(t){Hd(gst,"BidirectionalMergeMode",t)}(this.mergeMode),e.weights)throw new ci("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const i=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,i)),this.backwardLayer.setWeights(e.slice(i))}computeOutputShape(e){let i,s,o,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(o=r.slice(1)),i=r[0],"concat"===this.mergeMode?(i[i.length-1]*=2,s=[i]):s=null==this.mergeMode?[i,i.slice()]:[i],this.returnState?null==this.mergeMode?s.concat(o).concat(o.slice()):[i].concat(o).concat(o.slice()):hl(s)}apply(e,r){let i=null==r?null:r.initialState,s=null==r?null:r.constants;null==r&&(r={});const o=mB(e,i,s,this.numConstants);if(e=o.inputs,i=o.initialState,s=o.constants,Array.isArray(e)&&(i=e.slice(1),e=e[0]),(null==i||0===i.length)&&null==s)return super.apply(e,r);const a=[],u=[];if(null!=i){const d=i.length;if(d%2>0)throw new we("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=i,a.push(...i);const p=i.map(v=>new Qa({shape:v.shape}));this.forwardLayer.stateSpec=p.slice(0,d/2),this.backwardLayer.stateSpec=p.slice(d/2),u.push(...p)}if(null!=s)throw new ci("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof nh;for(const d of a)if(d instanceof nh!==c)throw new we("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const d=[e].concat(a),p=this.inputSpec.concat(u),v=this.inputSpec;this.inputSpec=p;const x=super.apply(d,r);return this.inputSpec=v,x}return super.apply(e,r)}call(e,r){return(0,g.tidy)(()=>{const i=r.initialState;let s,o,a,u;if(null==i)s=this.forwardLayer.call(e,r),o=this.backwardLayer.call(e,r);else{const c=i.slice(0,i.length/2),d=i.slice(i.length/2);s=this.forwardLayer.call(e,Object.assign(r,{initialState:c})),o=this.backwardLayer.call(e,Object.assign(r,{initialState:d}))}return this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(o.slice(1))),s=s[0],o=o[0]),this.returnSequences&&(o=g.reverse(o,1)),"concat"===this.mergeMode?u=sI([s,o]):"sum"===this.mergeMode?u=g.add(s,o):"ave"===this.mergeMode?u=g.mul(.5,g.add(s,o)):"mul"===this.mergeMode?u=g.mul(s,o):null==this.mergeMode&&(u=[s,o]),this.returnState?null==this.mergeMode?u.concat(a):[u].concat(a):u})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){jd(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),jd(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let i;if(Array.isArray(r)&&(r=r[0]),i=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(i)?i.concat(o).concat(o):[i].concat(o).concat(o)}return i}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const i=Th(r.layer);if(delete r.layer,null!=r.numConstants)throw new ci("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=r;return s.layer=i,new e(s)}}return t.className="Bidirectional",t})();g.serialization.registerClass(yut),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return(0,g.tidy)(()=>("float32"!==(e=Fr(e)).dtype&&(e=Jc(e,"float32")),(0,g.add)((0,g.mul)(e,this.scale),this.offset)))}}return t.className="Rescaling",t})());const{resizeBilinear:_ut,cropAndResize:xut}=g.image;g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,i,s,o,a,u,c){return(0,g.tidy)(()=>{let d,p=!1;const T=[r/a,i/u,(s+r)/a,(o+i)/u],N=[];3===e.rank?(p=!0,d=(0,g.stack)([e])):d=e;for(let Tt=0;Tt<d.shape[0];Tt++)N.push(T);const S=(0,g.tensor)(N,[N.length,4]),U=(0,g.range)(0,N.length,1,"int32"),ht=xut(d,S,U,[s,o],"nearest");return Jc(p?Fr((0,g.unstack)(ht)):ht,c)})}upsize(e,r,i,s){return(0,g.tidy)(()=>Jc(_ut(e,[r,i]),s))}call(e,r){return(0,g.tidy)(()=>{const i=Fr(e),s=i.dtype,o=i.shape,a=o[o.length-3],u=o[o.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let d=0;return u!==this.width&&(d=Math.floor((u-this.width)/2),0===d&&(d=1)),c>=0&&d>=0?this.centerCrop(i,c,d,this.height,this.width,a,u,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const i=(e=xs(e)).length-2;return e[e.length-3]=this.height,e[i]=this.width,e}}return t.className="CenterCrop",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=xs(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return(0,g.tidy)(()=>{let i;if("int32"!==(e=Fr(e)).dtype&&(e=Jc(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new we(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);i=Fr(r.countWeights)}const s=(0,g.max)(e),o=(0,g.min)(e),a=(0,g.greater)(this.numTokens,s).bufferSync().get(0),u=(0,g.greaterEqual)(o,0).bufferSync().get(0);if(!a||!u)throw new we(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function Cut(t,n,e,r){let i=Fr(t);if("int32"!==i.dtype&&(i=Jc(i,"int32")),"int"===n)return i;const s=i.shape;if(0===i.rank&&(i=(0,g.expandDims)(i,-1)),"oneHot"===n&&1!==i.shape[i.shape.length-1]&&(i=(0,g.expandDims)(i,-1)),i.rank>2)throw new we(`When outputMode is not int, maximum output rank is 2 Received outputMode ${n} and input shape ${s} which would result in output rank ${i.rank}.`);const o=["multiHot","oneHot"].includes(n);let u;if(u=(0,g.denseBincount)(i,typeof r<"u"&&"count"===n?r:[],e,o),"tfIdf"!==n)return u;if(r)return(0,g.mul)(u,r);throw new we("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,i)})}}return t.className="CategoryEncoding",t})());const NB=new Set(["bilinear","nearest"]);let Iut=(()=>{class t extends xi{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!NB.has(e.interpolation))throw new we(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){return e=xs(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return(0,g.tidy)(()=>{const i=[this.height,this.width];if("bilinear"===this.interpolation)return g.image.resizeBilinear(e,i,!this.cropToAspectRatio);if("nearest"===this.interpolation)return g.image.resizeNearestNeighbor(e,i,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...NB]} are supported`)})}}return t.className="Resizing",t})();g.serialization.registerClass(Iut);let Sut=(()=>{class t{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return t.className="RandomSeed",t})(),Dut=(()=>{class t extends xi{constructor(e){super(e),this.randomGenerator=new Sut(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BaseRandomLayer",t})();const AB=new Set(["bilinear","nearest"]);let Nut=(()=>{class t extends Dut{constructor(e){super(e);const{factor:r,interpolation:i="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new we(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new we(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new we(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(i){if(!AB.has(i))throw new we(`Invalid interpolation parameter: ${i} is not implemented`);this.interpolation=i}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=xs(e),[this.imgHeight,-1,e[2]]}call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);this.imgHeight=i.shape[i.shape.length-3];const s=i.shape[i.shape.length-2];this.widthFactor=(0,g.randomUniform)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*s;o=Math.round(o);const a=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return g.image.resizeBilinear(e,a);case"nearest":return g.image.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...AB]} are supported`)}})}}return t.className="RandomWidth",t})();g.serialization.registerClass(Nut),y(7926);var Rut=y(9128);function ar(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&g.util.assert("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const alt=g.kernel_impls.whereImpl;let ult=(()=>{class t extends g.KernelBackend{nextDataId(){return t.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new g.DataStorage(this,(0,g.engine)())}write(e,r,i){this.firstUse&&(this.firstUse=!1,(0,g.env)().get("IS_NODE")&&g.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:i,refCount:1}),s}makeTensorInfo(e,r,i){let s;if("string"===r&&null!=i&&i.length>0&&g.util.isString(i[0])){const o=i.map(a=>g.util.encodeString(a));s=this.write(o,e,r)}else s=this.write(i,e,r);return{dataId:s,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,i,s,o){this.data.set(e,{values:r,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return(0,Mr.Z)(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:i}=this.data.get(e);if("complex64"===r){const s=this.readSync(i.real.dataId),o=this.readSync(i.imag.dataId);return g.backend_util.mergeRealAndImagArrays(s,o)}return g.util.convertBackendValuesAndArrayBuffer(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const i=r.map(s=>g.util.decodeString(s));return(0,g.buffer)(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,g.buffer)(e.shape,e.dtype,r)}makeOutput(e,r,i){return(0,g.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(r,i,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:i}=this.data.get(e);null!=i&&(this.disposeData(i.real.dataId,!0),this.disposeData(i.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return(0,Mr.Z)(function*(){const r=g.util.now();return e(),{kernelMs:g.util.now()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ar([e],"where");const r=this.readSync(e.dataId);return alt(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();function ih(t){return(n,e,r)=>{const i=g.util.getArrayFromDType(e,n.length);for(let s=0;s<n.length;++s)i[s]=t(n[s],r);return i}}function Js(t,n,e){return ud(t,ih(n),e)}function ud(t,n,e){return({inputs:r,attrs:i,backend:s})=>{const{x:o}=r;ar(o,t);const a=s,u=a.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=g.backend_util.fromUint8ToStringArray(u)}else c=u;const d=e||o.dtype,p=n(c,d,i);return a.makeTensorInfo(o.shape,d,p)}}(0,g.registerBackend)("cpu",()=>new ult,1);const HB=Js(g.Elu,t=>t>=0?t:Math.exp(t)-1),clt={kernelName:g.Elu,backendName:"cpu",kernelFunc:HB};function sh(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const hlt={kernelName:g.Identity,backendName:"cpu",kernelFunc:sh};function jB(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{alpha:s}=r;ar([i],"leakyRelu");const o=g.util.sizeFromShape(i.shape),a=e.data.get(i.dataId).values,u=g.util.getTypedArrayFromDType("float32",o);for(let c=0;c<a.length;c++)u[c]=a[c]<0?s*a[c]:a[c];return e.makeTensorInfo(i.shape,"float32",u)}const dlt={kernelName:g.LeakyRelu,backendName:"cpu",kernelFunc:jB};function Ma(t){return(n,e,r,i,s)=>{const o=g.backend_util.assertAndGetBroadcastShape(n,e),a=o.length,u=g.util.computeStrides(o),c=g.util.sizeFromShape(o),d=g.util.getTypedArrayFromDType(s,c),p=n.length,v=e.length,x=g.util.computeStrides(n),w=g.util.computeStrides(e),b=g.backend_util.getBroadcastDims(n,o),T=g.backend_util.getBroadcastDims(e,o);if(b.length+T.length===0)for(let N=0;N<d.length;++N)d[N]=t(r[N%r.length],i[N%i.length]);else for(let N=0;N<d.length;++N){const S=g.util.indexToLoc(N,a,u),U=S.slice(-p);b.forEach(Pt=>U[Pt]=0);const J=g.util.locToIndex(U,p,x),ht=S.slice(-v);T.forEach(Pt=>ht[Pt]=0);const Tt=g.util.locToIndex(ht,v,w);d[N]=t(r[J],i[Tt])}return[d,o]}}const flt=Ma((t,n)=>t<0?n*t:t);function KB(t){const{inputs:n,backend:e}=t,{x:r,alpha:i}=n;ar([r,i],"prelu");const s=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,[a,u]=flt(r.shape,i.shape,s,o,"float32");return e.makeTensorInfo(u,"float32",a)}const plt={kernelName:g.Prelu,backendName:"cpu",kernelFunc:KB},XB=Js(g.Relu,t=>Math.max(0,t)),mlt={kernelName:g.Relu,backendName:"cpu",kernelFunc:XB},ZB=Js(g.Relu6,t=>Math.min(Math.max(0,t),6)),glt={kernelName:g.Relu6,backendName:"cpu",kernelFunc:ZB},ylt=ih(t=>1/(1+Math.exp(-t))),YB=Js(g.Sigmoid,t=>1/(1+Math.exp(-t))),vlt={kernelName:g.Sigmoid,backendName:"cpu",kernelFunc:YB};function t1(t,n,e,r,i){if("linear"===e)return sh({inputs:{x:n},backend:t});if("relu"===e)return XB({inputs:{x:n},backend:t});if("elu"===e)return HB({inputs:{x:n},backend:t});if("relu6"===e)return ZB({inputs:{x:n},backend:t});if("prelu"===e)return KB({inputs:{x:n,alpha:r},backend:t});if("leakyrelu"===e)return jB({inputs:{x:n},backend:t,attrs:{alpha:i}});if("sigmoid"===e)return YB({inputs:{x:n},backend:t});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function wl(t){const{inputs:n,backend:e}=t,{real:r,imag:i}=n,s=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",s),imag:e.makeTensorInfo(i.shape,"float32",o)},a}const _lt={kernelName:g.Complex,backendName:"cpu",kernelFunc:wl};function e1(t,n,e="float32"){if("complex64"===e)return wl({inputs:{real:e1(t,n,"float32"),imag:e1(t,n,"float32")},backend:t});const r=g.util.makeZerosTypedArray(g.util.sizeFromShape(n),e);return t.makeTensorInfo(n,e,r)}function Zd(t){const{inputs:n,backend:e}=t,{input:r}=n,i=e.data.get(r.dataId).complexTensorInfos.real,s=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,s)}const xlt={kernelName:g.Real,backendName:"cpu",kernelFunc:Zd};function qB(t,n,e,r){if("int32"===r)return[n,"int32",Int32Array.from(t)];if("bool"===r){const i=g.util.toTypedArray([0],e),[s,o]=Ma((a,u)=>a!==u?1:0)(n,[],t,i,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function ld(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===i.dtype)return sh({inputs:{x:i},backend:e});const d=e1(e,i.shape,i.dtype),p=ld({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),v=wl({inputs:{real:p,imag:d},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),v}if("complex64"===i.dtype){const d=Zd({inputs:{input:i},backend:e}),p=ld({inputs:{x:d},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(d),p}if(!g.util.hasEncodingLoss(i.dtype,s)){const d=sh({inputs:{x:i},backend:e});return{dataId:d.dataId,shape:d.shape,dtype:s}}const o=e.data.get(i.dataId).values,[a,u,c]=qB(o,i.shape,i.dtype,s);return e.makeTensorInfo(a,u,c)}const Elt={kernelName:g.Cast,backendName:"cpu",kernelFunc:ld};function eu(t,n,e,r){return null==e?({inputs:i,backend:s})=>{const{a:o,b:a}=i,u=s;ar([o,a],t);const c=u.data.get(o.dataId).values,d=u.data.get(a.dataId).values,p="string"===o.dtype?g.backend_util.fromUint8ToStringArray(c):c,v="string"===o.dtype?g.backend_util.fromUint8ToStringArray(d):d,x=r||o.dtype,[w,b]=n(o.shape,a.shape,p,v,x);return u.makeTensorInfo(b,x,w)}:({inputs:i,backend:s})=>{const{a:o,b:a}=i,u=s;if("complex64"===o.dtype||"complex64"===a.dtype){const c=ld({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),d=u.data.get(c.dataId),v=d.complexTensorInfos.imag,x=u.data.get(d.complexTensorInfos.real.dataId).values,w=u.data.get(v.dataId).values,b=ld({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),T=u.data.get(b.dataId),S=T.complexTensorInfos.imag,U=u.data.get(T.complexTensorInfos.real.dataId).values,J=u.data.get(S.dataId).values,[ht,Tt,Pt]=e(o.shape,a.shape,x,w,U,J),zt=u.makeTensorInfo(Pt,"float32",ht),Ot=u.makeTensorInfo(Pt,"float32",Tt),le=wl({inputs:{real:zt,imag:Ot},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(b),u.disposeIntermediateTensorInfo(zt),u.disposeIntermediateTensorInfo(Ot),le}{const c=u.data.get(o.dataId).values,d=u.data.get(a.dataId).values,p=r||o.dtype,[v,x]=n(o.shape,a.shape,c,d,p);return u.makeTensorInfo(x,p,v)}}}function XI(t){return(n,e,r,i,s,o)=>{const a=g.backend_util.assertAndGetBroadcastShape(n,e),u=g.util.sizeFromShape(a),c=a.length,d=g.util.computeStrides(a),p=g.util.getTypedArrayFromDType("float32",u),v=g.util.getTypedArrayFromDType("float32",u),x=g.backend_util.getBroadcastDims(n,a),w=g.backend_util.getBroadcastDims(e,a),b=g.backend_util.mergeRealAndImagArrays(r,i),T=g.backend_util.mergeRealAndImagArrays(s,o),N=n.length,S=g.util.computeStrides(n),U=e.length,J=g.util.computeStrides(e);if(x.length+w.length===0)for(let ht=0;ht<p.length;ht++){const Tt=ht%b.length,Pt=ht%T.length,zt=t(b[2*Tt],b[2*Tt+1],T[2*Pt],T[2*Pt+1]);p[ht]=zt.real,v[ht]=zt.imag}else for(let ht=0;ht<p.length;ht++){const Tt=g.util.indexToLoc(ht,c,d),Pt=Tt.slice(-N);x.forEach(Ae=>Pt[Ae]=0);const zt=g.util.locToIndex(Pt,N,S),Ot=Tt.slice(-U);w.forEach(Ae=>Ot[Ae]=0);const le=g.util.locToIndex(Ot,U,J),ge=t(b[2*zt],b[2*zt+1],T[2*le],T[2*le+1]);p[ht]=ge.real,v[ht]=ge.imag}return[p,v,a]}}const QB=Ma((t,n)=>t+n),Clt=XI((t,n,e,r)=>({real:t+e,imag:n+r})),Rp=eu(g.Add,QB,Clt),wlt={kernelName:g.Add,backendName:"cpu",kernelFunc:Rp};function Ao(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{shape:s}=r,o=g.util.sizeFromShape(i.shape),a=g.util.inferFromImplicitShape(s,o),u=g.util.sizeFromShape(a);g.util.assert(o===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(i.dataId);const c=e.data.get(i.dataId);if(null!=c.complexTensorInfos){const p=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,p.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const blt={kernelName:g.Reshape,backendName:"cpu",kernelFunc:Ao};function JB(t){const{inputs:n,backend:e,attrs:r}=t,{a:i,b:s}=n,{transposeA:o,transposeB:a}=r;ar([i,s],"matMul");const u=i.shape.length,c=s.shape.length,d=o?i.shape[u-2]:i.shape[u-1],p=a?s.shape[c-1]:s.shape[c-2],v=o?i.shape[u-1]:i.shape[u-2],x=a?s.shape[c-2]:s.shape[c-1],w=i.shape.slice(0,-2),b=s.shape.slice(0,-2),T=g.util.sizeFromShape(w),N=g.util.sizeFromShape(b),U=g.broadcast_util.assertAndGetBroadcastShape(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([v,x]);g.util.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${o} and transposeB=${a} must match.`);const ht=a?[N,x,p]:[N,p,x],Tt=Ao({inputs:{x:i},backend:e,attrs:{shape:o?[T,d,v]:[T,v,d]}}),Pt=Ao({inputs:{x:s},backend:e,attrs:{shape:ht}}),zt=o?Tt.shape[1]:Tt.shape[2],Ot=o?Tt.shape[2]:Tt.shape[1],le=a?Pt.shape[1]:Pt.shape[2],ge=Math.max(T,N),Ae=e.data.get(Tt.dataId).values,Re=e.data.get(Pt.dataId).values,ve=g.util.computeStrides(Tt.shape),Ne=g.util.computeStrides(Pt.shape),[Se,Ke,Le]=o?[ve[0],1,ve[1]]:[ve[0],ve[1],1],[Be,on,rn]=a?[1,Ne[1],Ne[0]]:[Ne[1],1,Ne[0]],pn=Ot*le,Qe=(0,g.buffer)([ge,Ot,le],Tt.dtype),gn=Qe.values,dn=e.blockSize;for(let kn=0;kn<ge;kn++){const ir=kn%T,Cr=kn%N;for(let yr=0;yr<Ot;yr+=dn){const Hr=Math.min(yr+dn,Ot);for(let Qr=0;Qr<le;Qr+=dn){const Rs=Math.min(Qr+dn,le);for(let uo=0;uo<zt;uo+=dn){const Yo=Math.min(uo+dn,zt);for(let lo=yr;lo<Hr;lo++)for(let co=Qr;co<Rs;co++){let ua=0;for(let qo=uo;qo<Yo;qo++)ua+=Ae[ir*Se+lo*Ke+qo*Le]*Re[qo*Be+co*on+Cr*rn];gn[kn*pn+(lo*le+co)]+=ua}}}}}return e.disposeIntermediateTensorInfo(Tt),e.disposeIntermediateTensorInfo(Pt),e.makeTensorInfo(U,Qe.dtype,Qe.values)}const Ilt={kernelName:g.BatchMatMul,backendName:"cpu",kernelFunc:JB},Dlt={kernelName:g._FusedMatMul,backendName:"cpu",kernelFunc:function Slt(t){const{inputs:n,backend:e,attrs:r}=t,{a:i,b:s,bias:o,preluActivationWeights:a}=n,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=r;let v,x,w;const b=[];v=JB({inputs:{a:i,b:s},attrs:{transposeA:u,transposeB:c},backend:e}),o&&(x=Rp({inputs:{a:v,b:o},backend:e}),b.push(v),v=x),d&&(w=t1(e,v,d,a,p),b.push(v),v=w);for(const N of b)e.disposeIntermediateTensorInfo(N);return v}};function t3(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}const Nlt={kernelName:g.Abs,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend;ar(n,"abs");let r=new Float32Array(g.util.sizeFromShape(n.shape));return r=t3(e.data.get(n.dataId).values),e.makeOutput(r,n.shape,n.dtype)}},Alt=Js(g.Acos,t=>Math.acos(t)),Mlt={kernelName:g.Acos,backendName:"cpu",kernelFunc:Alt},Plt=Js(g.Acosh,t=>Math.acosh(t)),Olt={kernelName:g.Acosh,backendName:"cpu",kernelFunc:Plt},Llt={kernelName:g.AddN,backendName:"cpu",kernelFunc:function Rlt(t){const{inputs:n,backend:e}=t,r=n;ar(n,"addN");const i=r.map(a=>e.data.get(a.dataId).values),s=(0,g.buffer)(r[0].shape,r[0].dtype),o=s.values;for(let a=0;a<r.length;a++){const u=i[a];for(let c=0;c<o.length;c++)o[c]+=u[c]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}};function ZI(t,n,e,r,i){const s=n.length,o=g.util.sizeFromShape(n),a=g.util.computeStrides(n),u=g.util.computeStrides(i),c=g.util.getTypedArrayFromDType(e,g.util.sizeFromShape(i));for(let d=0;d<o;++d){const p=g.util.indexToLoc(d,s,a),v=new Array(p.length);for(let w=0;w<v.length;w++)v[w]=p[r[w]];c[g.util.locToIndex(v,s,u)]=t[d]}return c}function fl(t){const{inputs:n,attrs:e,backend:r}=t,{x:i}=n,{perm:s}=e;ar(i,"transpose");const a=new Array(i.shape.length);for(let p=0;p<a.length;p++)a[p]=i.shape[s[p]];const c=ZI(r.data.get(i.dataId).values,i.shape,i.dtype,s,a);return{dataId:r.write(c,a,i.dtype),shape:a,dtype:i.dtype}}const klt={kernelName:g.Transpose,backendName:"cpu",kernelFunc:fl},$lt={kernelName:g.All,backendName:"cpu",kernelFunc:function Flt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;ar(i,"all");const a=g.util.parseAxisParam(s,i.shape);let u=a;const c=g.backend_util.getAxesPermutation(u,i.shape.length);let d=i;null!=c&&(d=fl({inputs:{x:i},backend:e,attrs:{perm:c}}),u=g.backend_util.getInnerMostAxes(u.length,i.shape.length)),g.backend_util.assertAxesAreInnerMostDims("all",u,d.shape.length);const[p,v]=g.backend_util.computeOutAndReduceShapes(d.shape,u),x=g.util.sizeFromShape(v),w=g.util.makeZerosTypedArray(g.util.sizeFromShape(p),d.dtype),b=e.data.get(d.dataId).values;for(let N=0;N<w.length;++N){const S=N*x;let U=b[S];for(let J=0;J<x;++J)U=U&&b[S+J];w[N]=U}null!=c&&e.disposeIntermediateTensorInfo(d);const T=e.makeTensorInfo(p,d.dtype,w);if(o){const S=Ao({inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(p,a)}});return e.disposeIntermediateTensorInfo(T),S}return T}},zlt={kernelName:g.Any,backendName:"cpu",kernelFunc:function Blt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;ar(i,"any");const a=g.util.parseAxisParam(s,i.shape);let u=a;const c=g.backend_util.getAxesPermutation(u,i.shape.length);let d=i;null!=c&&(d=fl({inputs:{x:i},backend:e,attrs:{perm:c}}),u=g.backend_util.getInnerMostAxes(u.length,i.shape.length)),g.backend_util.assertAxesAreInnerMostDims("any",u,d.shape.length);const[p,v]=g.backend_util.computeOutAndReduceShapes(d.shape,u),x=g.util.sizeFromShape(v),w=g.util.makeZerosTypedArray(g.util.sizeFromShape(p),d.dtype),b=e.data.get(d.dataId).values;for(let N=0;N<w.length;++N){const S=N*x;let U=b[S];for(let J=0;J<x;++J)U=U||b[S+J];w[N]=U}null!=c&&e.disposeIntermediateTensorInfo(d);const T=e.makeTensorInfo(p,d.dtype,w);if(o){const S=Ao({inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(p,a)}});return e.disposeIntermediateTensorInfo(T),S}return T}},Ult={kernelName:g.ArgMax,backendName:"cpu",kernelFunc:function Vlt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s}=r;ar(i,"argMax");let o=g.util.parseAxisParam(s,i.shape);const a=g.backend_util.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=a&&(u=fl({inputs:{x:i},backend:e,attrs:{perm:a}}),c.push(u),o=g.backend_util.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],g.backend_util.assertAxesAreInnerMostDims("argMax",o,u.shape.length);const[d,p]=g.backend_util.computeOutAndReduceShapes(u.shape,o),v=g.util.sizeFromShape(d),x=g.util.makeZerosTypedArray(v,"int32"),w=g.util.sizeFromShape(p),b=e.data.get(u.dataId).values;for(let T=0;T<x.length;++T){const N=T*w;let S=b[N],U=0;for(let J=0;J<w;++J){const ht=b[N+J];ht>S&&(S=ht,U=J)}x[T]=U}return c.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(d,"int32",x)}},Glt={kernelName:g.ArgMin,backendName:"cpu",kernelFunc:function Wlt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s}=r;ar(i,"argMin");let o=g.util.parseAxisParam(s,i.shape);const a=g.backend_util.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=a&&(u=fl({inputs:{x:i},backend:e,attrs:{perm:a}}),c.push(u),o=g.backend_util.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],g.backend_util.assertAxesAreInnerMostDims("argMin",o,u.shape.length);const[d,p]=g.backend_util.computeOutAndReduceShapes(u.shape,o),v=g.util.sizeFromShape(d),x=g.util.makeZerosTypedArray(v,"int32"),w=g.util.sizeFromShape(p),b=e.data.get(u.dataId).values;for(let T=0;T<x.length;++T){const N=T*w;let S=b[N],U=0;for(let J=0;J<w;++J){const ht=b[N+J];ht<S&&(S=ht,U=J)}x[T]=U}return c.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(d,"int32",x)}},Hlt=Js(g.Asin,t=>Math.asin(t)),jlt={kernelName:g.Asin,backendName:"cpu",kernelFunc:Hlt},Klt=Js(g.Asinh,t=>Math.asinh(t)),Xlt={kernelName:g.Asinh,backendName:"cpu",kernelFunc:Klt},Zlt=Js(g.Atan,t=>Math.atan(t)),Ylt={kernelName:g.Atan,backendName:"cpu",kernelFunc:Zlt},qlt=Ma((t,n)=>Math.atan2(t,n)),Qlt=eu(g.Atan2,qlt),Jlt={kernelName:g.Atan2,backendName:"cpu",kernelFunc:Qlt},tct=Js(g.Atanh,t=>Math.atanh(t)),ect={kernelName:g.Atanh,backendName:"cpu",kernelFunc:tct};function YI(t,n,e,r,i,s){const o=i.strideHeight,a=i.strideWidth,u=i.dilationHeight,c=i.dilationWidth,d=i.effectiveFilterHeight,p=i.effectiveFilterWidth,v=i.padInfo.top,x=i.padInfo.left,w="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=(0,g.buffer)(i.outShape,e),T=b.values,N=i.outShape[1]*i.outShape[2]*i.outShape[3],S=i.outShape[2]*i.outShape[3],U=i.outShape[3];for(let J=0;J<i.batchSize;++J){const ht=J*N,Tt=J*r[0];for(let Pt=0;Pt<i.inChannels;++Pt)for(let zt=0;zt<i.outHeight;++zt){const Ot=zt*o-v,le=Math.max(0,Ot),ge=Math.min(i.inHeight,d+Ot),Ae=ht+zt*S;for(let Re=0;Re<i.outWidth;++Re){const ve=Re*a-x,Ne=Math.max(0,ve),Se=Math.min(i.inWidth,p+ve);let Ke=w,Le=0,Be=0;for(let rn=le;rn<ge;rn+=u){const pn=Tt+rn*r[1];for(let Qe=Ne;Qe<Se;Qe+=c){const dn=t[pn+Qe*r[2]+Pt];"max"===s&&dn>Ke?Ke=dn:"avg"===s&&(Le+=dn,Be++)}if(isNaN(Ke))break}T[Ae+Re*U+Pt]="avg"===s?Le/Be:Ke}}}return b}function e3(t,n,e,r,i=!1,s=!1){const o=(0,g.buffer)(r.outShape,"int32"),a=r.strideHeight,u=r.strideWidth,c=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterHeight,v=r.effectiveFilterWidth,x=r.padInfo.top,w=r.padInfo.left,b=(0,g.buffer)(n,e,t);for(let T=0;T<r.batchSize;++T)for(let N=0;N<r.inChannels;++N)for(let S=0;S<r.outHeight;++S){const U=S*a-x;let J=U;for(;J<0;)J+=c;const ht=Math.min(r.inHeight,p+U);for(let Tt=0;Tt<r.outWidth;++Tt){const Pt=Tt*u-w;let zt=Pt;for(;zt<0;)zt+=d;const Ot=Math.min(r.inWidth,v+Pt);let le=Number.NEGATIVE_INFINITY,ge=-1;for(let Ae=J;Ae<ht;Ae+=c){const Re=Ae-U;for(let ve=zt;ve<Ot;ve+=d){const Ne=ve-Pt,Se=b.get(T,Ae,ve,N);Se>le&&(le=Se,ge=i?s?((T*r.inHeight+Ae)*r.inWidth+ve)*r.inChannels+N:(Ae*r.inWidth+ve)*r.inChannels+N:Re*v+Ne)}}o.set(ge,T,S,Tt,N)}}return o}function n3(t,n,e,r,i,s){const o=i.strideDepth,a=i.strideHeight,u=i.strideWidth,c=i.dilationDepth,d=i.dilationHeight,p=i.dilationWidth,v=i.effectiveFilterDepth,x=i.effectiveFilterHeight,w=i.effectiveFilterWidth,b=i.padInfo.front,T=i.padInfo.top,N=i.padInfo.left,S="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,U=(0,g.buffer)(i.outShape,e),J=U.values,ht=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],Tt=i.outShape[2]*i.outShape[3]*i.outShape[4],Pt=i.outShape[3]*i.outShape[4],zt=i.outShape[4];for(let Ot=0;Ot<i.batchSize;++Ot){const le=Ot*ht,ge=Ot*r[0];for(let Ae=0;Ae<i.inChannels;++Ae)for(let Re=0;Re<i.outDepth;++Re){const ve=Re*o-b;let Ne=ve;for(;Ne<0;)Ne+=c;const Se=Math.min(i.inDepth,v+ve),Ke=le+Re*Tt;for(let Le=0;Le<i.outHeight;++Le){const Be=Le*a-T;let on=Be;for(;on<0;)on+=d;const rn=Math.min(i.inHeight,x+Be),pn=Ke+Le*Pt;for(let Qe=0;Qe<i.outWidth;++Qe){const gn=Qe*u-N;let dn=gn;for(;dn<0;)dn+=p;const kn=Math.min(i.inWidth,w+gn),ir=pn+Qe*zt;let Cr=S,yr=0,Hr=0;for(let Rs=Ne;Rs<Se;Rs+=c){const uo=ge+Rs*r[1];for(let Yo=on;Yo<rn;Yo+=d){const lo=uo+Yo*r[2];for(let co=dn;co<kn;co+=p){const qo=t[lo+co*r[3]+Ae];if("max"===s&&qo>Cr?Cr=qo:"avg"===s&&(yr+=qo,Hr++),isNaN(Cr))break}if(isNaN(Cr))break}if(isNaN(Cr))break}J[ir+Ae]="avg"===s?yr/Math.max(Hr,1):Cr}}}}return U}const ict={kernelName:g.AvgPool,backendName:"cpu",kernelFunc:function rct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;ar(i,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=g.backend_util.computePool2DInfo(i.shape,s,o,1,a,u);let p;if(1===d.filterWidth&&1===d.filterHeight&&g.util.arraysEqual(d.inShape,d.outShape))p=sh({inputs:{x:i},backend:e});else{const v=e.data.get(i.dataId).values,x=g.util.computeStrides(i.shape),w=YI(v,0,i.dtype,x,d,"avg");p=e.makeTensorInfo(d.outShape,i.dtype,w.values)}return p}},oct={kernelName:g.AvgPool3D,backendName:"cpu",kernelFunc:function sct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{filterSize:s,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r;ar(i,"avgPool3d");const d=g.backend_util.computePool3DInfo(i.shape,s,o,1,a,u,c),v=n3(e.data.get(i.dataId).values,0,i.dtype,g.util.computeStrides(i.shape),d,"avg");return e.makeTensorInfo(v.shape,"float32",v.values)}},uct={kernelName:g.AvgPool3DGrad,backendName:"cpu",kernelFunc:function act(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,{filterSize:o,strides:a,pad:u,dimRoundingMode:c}=r;ar([i,s],"avgPool3DGrad");const d=g.backend_util.computePool3DInfo(s.shape,o,a,1,u,c),p=d.strideDepth,v=d.strideHeight,x=d.strideWidth,w=d.filterDepth,b=d.filterHeight,T=d.filterWidth,N=d.dilationDepth,S=d.dilationHeight,U=d.dilationWidth,J=d.effectiveFilterDepth,ht=d.effectiveFilterHeight,Tt=d.effectiveFilterWidth,Pt=J-1-d.padInfo.front,zt=Tt-1-d.padInfo.left,Ot=ht-1-d.padInfo.top,le=(0,g.buffer)(s.shape,"float32"),ge=1/(w*b*T),Ae=e.bufferSync(i);for(let Re=0;Re<d.batchSize;++Re)for(let ve=0;ve<d.inChannels;++ve)for(let Ne=0;Ne<d.inDepth;++Ne)for(let Se=0;Se<d.inHeight;++Se)for(let Ke=0;Ke<d.inWidth;++Ke){const Le=Ne-Pt,Be=Se-Ot,on=Ke-zt;let rn=0;for(let pn=0;pn<J;pn+=N){const Qe=(Le+pn)/p;if(!(Qe<0||Qe>=d.outDepth||Math.floor(Qe)!==Qe))for(let gn=0;gn<ht;gn+=S){const dn=(Be+gn)/v;if(!(dn<0||dn>=d.outHeight||Math.floor(dn)!==dn))for(let kn=0;kn<Tt;kn+=U){const ir=(on+kn)/x;ir<0||ir>=d.outWidth||Math.floor(ir)!==ir||(rn+=Ae.get(Re,Qe,dn,ir,ve))}}}le.set(rn*ge,Re,Ne,Se,Ke,ve)}return e.makeTensorInfo(le.shape,le.dtype,le.values)}},cct={kernelName:g.AvgPoolGrad,backendName:"cpu",kernelFunc:function lct(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,o=s;ar([i,s],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,d=g.backend_util.computePool2DInfo(o.shape,a,u,1,c),p=d.strideHeight,v=d.strideWidth,x=d.filterHeight,w=d.filterWidth,b=d.dilationHeight,T=d.dilationWidth,N=d.effectiveFilterHeight,S=d.effectiveFilterWidth,U=S-1-d.padInfo.left,J=N-1-d.padInfo.top,ht=(0,g.buffer)(o.shape,"float32"),Tt=1/(x*w),Pt=e.data.get(i.dataId).values,zt=(0,g.buffer)(i.shape,"float32",Pt);for(let Ot=0;Ot<d.batchSize;++Ot)for(let le=0;le<d.inChannels;++le)for(let ge=0;ge<d.inHeight;++ge)for(let Ae=0;Ae<d.inWidth;++Ae){const Re=ge-J,ve=Ae-U;let Ne=0;for(let Se=0;Se<N;Se+=b){const Ke=(Re+Se)/p;if(!(Ke<0||Ke>=d.outHeight||Math.floor(Ke)!==Ke))for(let Le=0;Le<S;Le+=T){const Be=(ve+Le)/v;Be<0||Be>=d.outWidth||Math.floor(Be)!==Be||(Ne+=zt.get(Ot,Ke,Be,le))}}ht.set(Ne*Tt,Ot,ge,Ae,le)}return e.makeTensorInfo(ht.shape,ht.dtype,ht.values)}},dct={kernelName:g.FusedBatchNorm,backendName:"cpu",kernelFunc:function hct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,scale:s,offset:o,mean:a,variance:u}=n;g.util.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),g.util.assert(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),g.util.assert(null==s||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ar([i,a,u,s,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const d=e.data.get(i.dataId).values,p=e.data.get(a.dataId).values,v=e.data.get(u.dataId).values,x=s?e.data.get(s.dataId).values:new Float32Array([1]),w=o?e.data.get(o.dataId).values:new Float32Array([0]),b=new Float32Array(d.length),T=w.length,N=x.length,S=v.length,U=p.length;let J=0,ht=0,Tt=0,Pt=0;for(let zt=0;zt<d.length;++zt)b[zt]=w[J++]+(d[zt]-p[ht++])*x[Tt++]/Math.sqrt(v[Pt++]+c),J>=T&&(J=0),ht>=U&&(ht=0),Tt>=N&&(Tt=0),Pt>=S&&(Pt=0);return e.makeTensorInfo(i.shape,i.dtype,b)}};function r3(t,n,e,r,i){const s=g.slice_util.isSliceContinous(r,n,e),o=g.util.sizeFromShape(e),a=g.util.computeStrides(r);if(s){const p=g.slice_util.computeFlatOffset(n,a);return"string"===i?t.slice(p,p+o):t.subarray(p,p+o)}const u="string"===i?g.backend_util.fromUint8ToStringArray(t):t,c=(0,g.buffer)(r,i,u),d=(0,g.buffer)(e,i);for(let p=0;p<d.size;++p){const v=d.indexToLoc(p),x=v.map((w,b)=>w+n[b]);d.set(c.get(...x),...v)}return"string"===i?g.backend_util.fromStringArrayToUint8(d.values):d.values}function Yd(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{begin:s,size:o}=r;ar(i,"slice");const[a,u]=g.slice_util.parseSliceParams(i,s,o);g.slice_util.assertParamsValid(i,a,u);const d=r3(e.data.get(i.dataId).values,a,u,i.shape,i.dtype);return e.makeTensorInfo(u,i.dtype,d)}const fct={kernelName:g.Slice,backendName:"cpu",kernelFunc:Yd},mct={kernelName:g.BatchToSpaceND,backendName:"cpu",kernelFunc:function pct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockShape:s,crops:o}=r;ar([i],"batchToSpaceND");const a=s.reduce((N,S)=>N*S),u=g.backend_util.getReshaped(i.shape,s,a),c=g.backend_util.getPermuted(u.length,s.length),d=g.backend_util.getReshapedPermuted(i.shape,s,a),p=g.backend_util.getSliceBeginCoords(o,s.length),v=g.backend_util.getSliceSize(d,o,s.length),x=Ao({inputs:{x:i},backend:e,attrs:{shape:u}}),w=fl({inputs:{x},backend:e,attrs:{perm:c}}),b=Ao({inputs:{x:w},backend:e,attrs:{shape:d}}),T=Yd({inputs:{x:b},backend:e,attrs:{begin:p,size:v}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(b),T}};function qI(t,n,e,r,i){const s=g.util.sizeFromShape(r),o=g.util.makeZerosTypedArray(i,e);for(let a=0;a<t.length;a++){const u=t[a];if(u<0)throw new Error("Input x must be non-negative!");u>=i||(o[u]+=s>0?n[a]:1)}return o}function i3(t,n,e,r=!1){const i=t.shape[0],s=t.shape[1],o=(0,g.buffer)([i,e],n.dtype);for(let a=0;a<i;a++)for(let u=0;u<s;u++){const c=t.get(a,u);if(c<0)throw new Error("Input x must be non-negative!");c>=e||o.set(r?1:n.size>0?o.get(a,c)+n.get(a,u):o.get(a,c)+1,a,c)}return o}const yct={kernelName:g.Bincount,backendName:"cpu",kernelFunc:function gct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,weights:s}=n,{size:o}=r,c=qI(e.data.get(i.dataId).values,e.data.get(s.dataId).values,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,c)}},s3=Ma((t,n)=>t&n),vct=eu(g.BitwiseAnd,s3),_ct={kernelName:g.BitwiseAnd,backendName:"cpu",kernelFunc:vct},Ect={kernelName:g.BroadcastArgs,backendName:"cpu",kernelFunc:function xct(t){const{inputs:n,backend:e}=t,{s0:r,s1:i}=n,s=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,a=g.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},o3=ih(t=>Math.ceil(t)),Cct=ud(g.Ceil,o3),wct={kernelName:g.Ceil,backendName:"cpu",kernelFunc:Cct},bct=Js(g.ClipByValue,(t,n)=>t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t),Ict={kernelName:g.ClipByValue,backendName:"cpu",kernelFunc:bct},Dct={kernelName:g.ComplexAbs,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend,r=new Float32Array(g.util.sizeFromShape(n.shape)),i=e.data.get(n.dataId),o=i.complexTensorInfos.imag,a=e.data.get(i.complexTensorInfos.real.dataId).values,u=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],u[c]);return e.makeOutput(r,n.shape,"float32")}};function a3(t,n,e,r){const i=g.util.getArrayFromDType(e,g.util.sizeFromShape(n));if(r&&"string"!==e){let s=0;t.forEach(o=>{const a=g.util.sizeFromShape(o.shape);i.set(o.vals,s),s+=a})}else{let s=0;t.forEach(o=>{const a="string"===e?g.backend_util.fromUint8ToStringArray(o.vals):o.vals;let u=0;for(let c=0;c<o.shape[0];++c){const d=c*n[1]+s;for(let p=0;p<o.shape[1];++p)i[d+p]=a[u++]}s+=o.shape[1]})}return i}function Lp(t){const{inputs:n,backend:e}=t,{input:r}=n,i=e.data.get(r.dataId).complexTensorInfos.imag,s=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,s)}const Tct={kernelName:g.Imag,backendName:"cpu",kernelFunc:Lp};function kp(t){const{inputs:n,backend:e,attrs:r}=t,{axis:i}=r,s=g.util.parseAxisParam(i,n[0].shape)[0],o=n.map(b=>b.shape);g.backend_util.assertParamsConsistent(o,s);let a=g.backend_util.computeOutShape(n.map(b=>b.shape),s);if(0===g.util.sizeFromShape(a))return e.makeTensorInfo(a,n[0].dtype,[]);const u=n.filter(b=>g.util.sizeFromShape(b.shape)>0);if(1===u.length)return sh({inputs:{x:u[0]},backend:e});if("complex64"===u[0].dtype){const b=u.map(J=>Zd({inputs:{input:J},backend:e})),T=u.map(J=>Lp({inputs:{input:J},backend:e})),N=kp({inputs:b,backend:e,attrs:{axis:s}}),S=kp({inputs:T,backend:e,attrs:{axis:s}}),U=wl({inputs:{real:N,imag:S},backend:e});return b.forEach(J=>e.disposeIntermediateTensorInfo(J)),T.forEach(J=>e.disposeIntermediateTensorInfo(J)),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(S),U}const c=u.map(b=>{const N=[-1,g.util.sizeFromShape(b.shape.slice(s))];return Ao({inputs:{x:b},backend:e,attrs:{shape:N}})}),d=c.map(b=>({vals:e.data.get(b.dataId).values,shape:b.shape}));a=g.backend_util.computeOutShape(c.map(b=>b.shape),1);const v=a3(d,a,n[0].dtype,1===c[0].shape[0]),x=g.backend_util.computeOutShape(u.map(b=>b.shape),s),w=e.makeTensorInfo(x,n[0].dtype,v);return c.forEach(b=>e.disposeIntermediateTensorInfo(b)),w}const Nct={kernelName:g.Concat,backendName:"cpu",kernelFunc:kp};function u3(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dataFormat:u,dilations:c,dimRoundingMode:d}=r;ar([i,s],"conv2d");const p=g.backend_util.convertConv2DDataFormat(u),v=g.backend_util.computeConv2DInfo(i.shape,s.shape,o,c,a,d,!1,p),x=v.filterHeight,w=v.filterWidth,b=v.dilationHeight,T=v.dilationWidth,N=v.padInfo.left,S=v.padInfo.top,U="channelsLast"===v.dataFormat,J=new g.TensorBuffer(v.outShape,i.dtype),ht=g.util.computeStrides(i.shape),Tt=g.util.computeStrides(s.shape),Pt=ht[0],zt=U?ht[1]:ht[2],Ot=U?ht[2]:1,le=U?1:ht[1],ge=J.strides[0],Ae=U?J.strides[1]:J.strides[2],Re=U?J.strides[2]:1,ve=U?1:J.strides[1],Ne=e.data.get(i.dataId).values,Se=e.data.get(s.dataId).values,Ke=J.values;for(let Le=0;Le<v.batchSize;++Le){const Be=Le*Pt,on=Le*ge;for(let rn=0;rn<v.outHeight;++rn){const pn=on+rn*Ae,Qe=rn*v.strideHeight-S;for(let gn=0;gn<x;++gn){const dn=Qe+gn*b;if(dn<0||dn>=v.inHeight)continue;const kn=gn*Tt[0],ir=Be+dn*zt;for(let Cr=0;Cr<v.outWidth;++Cr){const yr=pn+Cr*Re,Hr=Cr*v.strideWidth-N;for(let Qr=0;Qr<w;++Qr){const Rs=Hr+Qr*T;if(Rs<0||Rs>=v.inWidth)continue;const Yo=ir+Rs*Ot;let lo=kn+Qr*Tt[1];for(let co=0;co<v.inChannels;++co){const ua=Ne[Yo+co*le];for(let qo=0;qo<v.outChannels;++qo)Ke[yr+qo*ve]+=ua*Se[lo+qo];lo+=v.outChannels}}}}}}return e.makeTensorInfo(J.shape,J.dtype,Ke)}const Act={kernelName:g.Conv2D,backendName:"cpu",kernelFunc:u3},Pct={kernelName:g.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function Mct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:d}=r;ar([i,s],"conv2dBackpropFilter");const p=g.backend_util.convertConv2DDataFormat(u),v=g.backend_util.computeConv2DInfo(i.shape,d,o,1,a,c,!1,p),{strideHeight:x,strideWidth:w,filterHeight:b,filterWidth:T}=v,N="channelsLast"===v.dataFormat,S=new g.TensorBuffer(v.filterShape,"float32"),U=v.padInfo.left,J=v.padInfo.top,ht=e.data.get(i.dataId).values,Tt=e.data.get(s.dataId).values,Pt=new g.TensorBuffer(i.shape,i.dtype,ht),zt=new g.TensorBuffer(s.shape,s.dtype,Tt);for(let Ot=0;Ot<b;++Ot){const le=Math.max(0,Math.ceil((J-Ot)/x)),ge=Math.min(v.outHeight,(v.inHeight+J-Ot)/x);for(let Ae=0;Ae<T;++Ae){const Re=Math.max(0,Math.ceil((U-Ae)/w)),ve=Math.min(v.outWidth,(v.inWidth+U-Ae)/w);for(let Ne=0;Ne<v.inChannels;++Ne)for(let Se=0;Se<v.outChannels;++Se){let Ke=0;for(let Le=0;Le<v.batchSize;++Le)for(let Be=le;Be<ge;++Be){const on=Ot+Be*x-J;for(let rn=Re;rn<ve;++rn){const pn=Ae+rn*w-U;Ke+=N?Pt.get(Le,on,pn,Ne)*zt.get(Le,Be,rn,Se):Pt.get(Le,Ne,on,pn)*zt.get(Le,Se,Be,rn)}}S.set(Ke,Ot,Ae,Ne,Se)}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}},Rct={kernelName:g.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function Oct(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{inputShape:o,strides:a,pad:u,dataFormat:c,dimRoundingMode:d}=r;ar([i,s],"conv2dBackpropInput");const p=g.util.computeStrides(s.shape),v=g.util.computeStrides(i.shape);let x=g.backend_util.convertConv2DDataFormat(c);const w=g.backend_util.computeConv2DInfo(o,s.shape,a,1,u,d,!1,x),b=new g.TensorBuffer(w.inShape,"float32"),T=b.values,N=e.data.get(i.dataId).values,S=e.data.get(s.dataId).values,[U,J,ht]=p,{batchSize:Tt,filterHeight:Pt,filterWidth:zt,inChannels:Ot,inHeight:le,inWidth:ge,outChannels:Ae,outHeight:Re,outWidth:ve,strideHeight:Ne,strideWidth:Se}=w;x=w.dataFormat;const Ke=Pt-1-w.padInfo.top,Le=zt-1-w.padInfo.left,Be="channelsLast"===x,on=b.strides[0],rn=Be?b.strides[1]:b.strides[2],pn=Be?b.strides[2]:1,Qe=Be?1:b.strides[1],gn=v[0],dn=Be?v[1]:v[2],kn=Be?v[2]:1,ir=Be?1:v[1];for(let Cr=0;Cr<Tt;++Cr)for(let yr=0;yr<Ot;++yr)for(let Hr=0;Hr<le;++Hr){const Qr=Hr-Ke,Rs=Math.max(0,Math.ceil(Qr/Ne)),uo=Math.min(Re,(Pt+Qr)/Ne);for(let Yo=0;Yo<ge;++Yo){const lo=Yo-Le,co=Math.max(0,Math.ceil(lo/Se)),ua=Math.min(ve,(zt+lo)/Se);let qo=0;for(let wu=Rs;wu<uo;++wu){const pd=wu*Ne-Qr;for(let Gl=co;Gl<ua;++Gl){const Oc=gn*Cr+dn*wu+kn*Gl,Mh=U*(Pt-1-pd)+J*(zt-1-(Gl*Se-lo))+ht*yr;for(let md=0;md<Ae;++md)qo+=N[Oc+ir*md]*S[Mh+md]}}T[on*Cr+rn*Hr+pn*Yo+Qe*yr]=qo}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},kct={kernelName:g.Conv3D,backendName:"cpu",kernelFunc:function Lct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u}=r;ar([i,s],"conv3d");const c=g.backend_util.computeConv3DInfo(i.shape,s.shape,o,u,a),{filterDepth:d,filterHeight:p,filterWidth:v,dilationDepth:x,dilationHeight:w,dilationWidth:b,padInfo:T}=c,N=T.front,S=T.left,U=T.top,J=new g.TensorBuffer(c.outShape,i.dtype),ht=e.data.get(i.dataId).values,Tt=e.data.get(s.dataId).values,Pt=J.values,zt=g.util.computeStrides(i.shape),Ot=g.util.computeStrides(s.shape);for(let le=0;le<c.batchSize;++le){const ge=le*zt[0],Ae=le*J.strides[0];for(let Re=0;Re<c.outDepth;++Re){const ve=Ae+Re*J.strides[1],Ne=Re*c.strideDepth-N;for(let Se=0;Se<d;++Se){const Ke=Ne+Se*x;if(Ke<0||Ke>=c.inDepth)continue;const Le=Se*Ot[0],Be=ge+Ke*zt[1];for(let on=0;on<c.outHeight;++on){const rn=ve+on*J.strides[2],pn=on*c.strideHeight-U;for(let Qe=0;Qe<p;++Qe){const gn=pn+Qe*w;if(gn<0||gn>=c.inHeight)continue;const dn=Le+Qe*Ot[1],kn=Be+gn*zt[2];for(let ir=0;ir<c.outWidth;++ir){const Cr=rn+ir*c.outChannels,yr=ir*c.strideWidth-S;for(let Hr=0;Hr<v;++Hr){const Qr=yr+Hr*b;if(Qr<0||Qr>=c.inWidth)continue;const uo=kn+Qr*c.inChannels;let Yo=dn+Hr*Ot[2];for(let lo=0;lo<c.inChannels;++lo){const co=ht[uo+lo];for(let ua=0;ua<c.outChannels;++ua)Pt[Cr+ua]+=co*Tt[Yo+ua];Yo+=c.outChannels}}}}}}}}return e.makeTensorInfo(J.shape,J.dtype,J.values)}},$ct={kernelName:g.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function Fct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,pad:a,filterShape:u}=r;ar([i,s],"conv3dBackpropFilterV2");const c=g.util.computeStrides(i.shape),d=g.util.computeStrides(s.shape),p=g.backend_util.computeConv3DInfo(i.shape,u,o,1,a),v=p.strideDepth,x=p.strideHeight,w=p.strideWidth,b=p.filterDepth,T=p.filterHeight,N=p.filterWidth,S=new g.TensorBuffer(p.filterShape,"float32"),U=S.values,[J,ht,Tt,Pt]=S.strides,zt=e.data.get(s.dataId).values,[Ot,le,ge,Ae]=d,Re=e.data.get(i.dataId).values,[ve,Ne,Se,Ke]=c,Le=p.padInfo.front,Be=p.padInfo.left,on=p.padInfo.top;for(let rn=0;rn<b;++rn){const pn=Math.max(0,Math.ceil((Le-rn)/v)),Qe=Math.min(p.outDepth,(p.inDepth+Le-rn)/v),gn=rn*J;for(let dn=0;dn<T;++dn){const kn=Math.max(0,Math.ceil((on-dn)/x)),ir=Math.min(p.outHeight,(p.inHeight+on-dn)/x),Cr=dn*ht+gn;for(let yr=0;yr<N;++yr){const Hr=Math.max(0,Math.ceil((Be-yr)/w)),Qr=Math.min(p.outWidth,(p.inWidth+Be-yr)/w),Rs=yr*Tt+Cr;for(let uo=0;uo<p.inChannels;++uo){const Yo=uo*Pt+Rs;for(let lo=0;lo<p.outChannels;++lo){let co=0;for(let ua=0;ua<p.batchSize;++ua){const qo=ua*ve,Ah=ua*Ot;for(let wu=pn;wu<Qe;++wu){const Gl=(rn+wu*v-Le)*Ne+qo,af=wu*le+Ah;for(let Oc=kn;Oc<ir;++Oc){const md=(dn+Oc*x-on)*Se+Gl,gd=Oc*ge+af;for(let yd=Hr;yd<Qr;++yd)co+=Re[(yr+yd*w-Be)*Ke+md+uo]*zt[yd*Ae+gd+lo]}}}U[Yo+lo]=co}}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}},zct={kernelName:g.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function Bct(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{pad:o,strides:a,inputShape:u}=r;ar([i],"conv3dBackpropInputV2");const c=g.util.computeStrides(i.shape),d=g.util.computeStrides(s.shape),p=g.backend_util.computeConv3DInfo(u,s.shape,a,1,o),v=new g.TensorBuffer(p.inShape,"float32"),x=v.values,[w,b,T,N]=v.strides,S=e.data.get(i.dataId).values,[U,J,ht,Tt]=c,Pt=e.data.get(s.dataId).values,[zt,Ot,le,ge]=d,{batchSize:Ae,filterDepth:Re,filterHeight:ve,filterWidth:Ne,inChannels:Se,inDepth:Ke,inHeight:Le,inWidth:Be,outChannels:on,outDepth:rn,outHeight:pn,outWidth:Qe,strideDepth:gn,strideHeight:dn,strideWidth:kn}=p,ir=Re-1-p.padInfo.front,Cr=ve-1-p.padInfo.top,yr=Ne-1-p.padInfo.left;for(let Hr=0;Hr<Ae;++Hr)for(let Qr=0;Qr<Se;++Qr)for(let Rs=0;Rs<Ke;++Rs){const uo=Rs-ir,Yo=Math.max(0,Math.ceil(uo/gn)),lo=Math.min(rn,(Re+uo)/gn);for(let co=0;co<Le;++co){const ua=co-Cr,qo=Math.max(0,Math.ceil(ua/dn)),Ah=Math.min(pn,(ve+ua)/dn);for(let wu=0;wu<Be;++wu){const pd=wu-yr,Gl=Math.max(0,Math.ceil(pd/kn)),af=Math.min(Qe,(Ne+pd)/kn);let Oc=0;for(let Mh=Yo;Mh<lo;++Mh){const md=Mh*gn-uo;for(let gd=qo;gd<Ah;++gd){const yd=gd*dn-ua;for(let sy=Gl;sy<af;++sy){const wS=U*Hr+J*Mh+ht*gd+Tt*sy,Ybt=zt*(Re-1-md)+Ot*(ve-1-yd)+le*(Ne-1-(sy*kn-pd))+ge*Qr;for(let T1=0;T1<on;++T1)Oc+=S[wS+T1]*Pt[Ybt+T1]}}}x[w*Hr+b*Rs+T*co+N*wu+Qr]=Oc}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},Vct=Js(g.Cos,t=>Math.cos(t)),Uct={kernelName:g.Cos,backendName:"cpu",kernelFunc:Vct},Wct=Js(g.Cosh,t=>Math.cosh(t)),Gct={kernelName:g.Cosh,backendName:"cpu",kernelFunc:Wct},jct={kernelName:g.CropAndResize,backendName:"cpu",kernelFunc:function Hct(t){const{inputs:n,backend:e,attrs:r}=t,{image:i,boxes:s,boxInd:o}=n,{cropSize:a,method:u,extrapolationValue:c}=r,[d,p,v,x]=i.shape,w=s.shape[0],[b,T]=a,N=(0,g.buffer)([w,b,T,x],"float32"),S=e.data.get(s.dataId).values,U=e.data.get(o.dataId).values,J=e.data.get(i.dataId).values,ht=g.util.computeStrides(i.shape),Tt=g.util.computeStrides(N.shape);for(let Pt=0;Pt<w;Pt++){const zt=4*Pt,Ot=S[zt],le=S[zt+1],ge=S[zt+2],Ae=S[zt+3],Re=U[Pt];if(Re>=d)continue;const ve=b>1?(ge-Ot)*(p-1)/(b-1):0,Ne=T>1?(Ae-le)*(v-1)/(T-1):0;for(let Se=0;Se<b;Se++){const Ke=b>1?Ot*(p-1)+Se*ve:.5*(Ot+ge)*(p-1);if(Ke<0||Ke>p-1)for(let Le=0;Le<T;Le++)for(let Be=0;Be<x;Be++)N.values[Be+Le*Tt[2]+Se*Tt[1]+Pt*Tt[0]]=c;else if("bilinear"===u){const Le=Math.floor(Ke),Be=Math.ceil(Ke),on=Ke-Le;for(let rn=0;rn<T;rn++){const pn=T>1?le*(v-1)+rn*Ne:.5*(le+Ae)*(v-1);if(pn<0||pn>v-1){for(let kn=0;kn<x;kn++)N.values[kn+rn*Tt[2]+Se*Tt[1]+Pt*Tt[0]]=c;continue}const Qe=Math.floor(pn),gn=Math.ceil(pn),dn=pn-Qe;for(let kn=0;kn<x;kn++){let ir=kn+Qe*ht[2]+Le*ht[1]+Re*ht[0];const Cr=J[ir];ir=kn+gn*ht[2]+Le*ht[1]+Re*ht[0];const yr=J[ir];ir=kn+Qe*ht[2]+Be*ht[1]+Re*ht[0];const Hr=J[ir];ir=kn+gn*ht[2]+Be*ht[1]+Re*ht[0];const Qr=J[ir],Rs=Cr+(yr-Cr)*dn;ir=kn+rn*Tt[2]+Se*Tt[1]+Pt*Tt[0],N.values[ir]=Rs+(Hr+(Qr-Hr)*dn-Rs)*on}}}else for(let Le=0;Le<T;++Le){const Be=T>1?le*(v-1)+Le*Ne:.5*(le+Ae)*(v-1);if(Be<0||Be>v-1){for(let pn=0;pn<x;pn++)N.values[pn+Le*Tt[2]+Se*Tt[1]+Pt*Tt[0]]=c;continue}const on=Math.round(Be),rn=Math.round(Ke);for(let pn=0;pn<x;pn++)N.values[pn+Le*Tt[2]+Se*Tt[1]+Pt*Tt[0]]=J[pn+on*ht[2]+rn*ht[1]+Re*ht[0]]}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},Xct={kernelName:g.Cumprod,backendName:"cpu",kernelFunc:function Kct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,exclusive:o,reverse:a}=r;ar(i,"cumprod");const u=g.backend_util.getAxesPermutation([s],i.shape.length);let c=i;null!=u&&(c=fl({inputs:{x:i},backend:e,attrs:{perm:u}}));const d=g.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const p=(0,g.upcastType)(c.dtype,"int32"),v=g.util.makeOnesTypedArray(g.util.sizeFromShape(c.shape),p),x=e.data.get(c.dataId).values,w=c.shape[c.shape.length-1],b=a?(N,S)=>N+w-S-1:(N,S)=>N+S;for(let N=0;N<x.length;N+=w)for(let S=0;S<w;S++){const U=b(N,S);if(0===S)v[U]=o?1:x[U];else{const J=b(N,S-1);v[U]=o?x[J]*v[J]:x[U]*v[J]}}const T=e.makeTensorInfo(c.shape,p,v);if(null!=u){const S=fl({inputs:{x:T},backend:e,attrs:{perm:g.backend_util.getUndoAxesPermutation(u)}});return e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(c),S}return T}},Yct={kernelName:g.Cumsum,backendName:"cpu",kernelFunc:function Zct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,exclusive:o,reverse:a}=r;ar(i,"cumsum");const u=g.backend_util.getAxesPermutation([s],i.shape.length);let c=i;null!=u&&(c=fl({inputs:{x:i},backend:e,attrs:{perm:u}}));const d=g.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const p=(0,g.upcastType)(c.dtype,"int32"),v=g.util.makeZerosTypedArray(g.util.sizeFromShape(c.shape),p),x=e.data.get(c.dataId).values,w=c.shape[c.shape.length-1],b=a?(N,S)=>N+w-S-1:(N,S)=>N+S;for(let N=0;N<x.length;N+=w)for(let S=0;S<w;S++){const U=b(N,S);if(0===S)v[U]=o?0:x[U];else{const J=b(N,S-1);v[U]=o?x[J]+v[J]:x[U]+v[J]}}const T=e.makeTensorInfo(c.shape,p,v);if(null!=u){const S=fl({inputs:{x:T},backend:e,attrs:{perm:g.backend_util.getUndoAxesPermutation(u)}});return e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(c),S}return T}},Qct={kernelName:g.DenseBincount,backendName:"cpu",kernelFunc:function qct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,weights:s}=n,{size:o,binaryOutput:a}=r;if(1===i.shape.length){const d=qI(e.data.get(i.dataId).values,e.data.get(s.dataId).values,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,d)}if(2===i.shape.length){const d=i3(e.bufferSync(i),e.bufferSync(s),o,a);return e.makeTensorInfo(d.shape,s.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}},tht={kernelName:g.DepthToSpace,backendName:"cpu",kernelFunc:function Jct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockSize:s,dataFormat:o}=r;g.util.assert("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=i.shape[0],u=i.shape[1],c=i.shape[2],d=i.shape[3],p=u*s,v=c*s,x=d/(s*s),w=e.data.get(i.dataId).values,b=new Float32Array(a*p*v*x);let T=0;for(let N=0;N<a;++N)for(let S=0;S<p;++S){const U=Math.floor(S/s),J=S%s;for(let ht=0;ht<v;++ht){const Tt=Math.floor(ht/s),zt=(J*s+ht%s)*x;for(let Ot=0;Ot<x;++Ot)b[T++]=w[Ot+zt+d*(Tt+c*(U+u*N))]}}return e.makeTensorInfo([a,p,v,x],i.dtype,b)}};function l3(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u,dimRoundingMode:c}=r;ar([i,s],"depthwiseConv2DNative");const d=g.util.computeStrides(i.shape),p=g.util.computeStrides(s.shape);let v=u;null==v&&(v=[1,1]),g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,v),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${v}'`);const x=g.backend_util.computeConv2DInfo(i.shape,s.shape,o,v,a,c,!0),{filterHeight:w,filterWidth:b,dilationHeight:T,dilationWidth:N,padInfo:S}=x,U=S.left,J=S.top,ht=x.outChannels/x.inChannels,Tt=new g.TensorBuffer(x.outShape,i.dtype),Pt=e.data.get(i.dataId).values,zt=e.data.get(s.dataId).values,Ot=Tt.values;for(let le=0;le<x.batchSize;++le){const ge=le*d[0],Ae=le*Tt.strides[0];for(let Re=0;Re<x.outHeight;++Re){const ve=Ae+Re*Tt.strides[1],Ne=Re*x.strideHeight-J;for(let Se=0;Se<w;++Se){const Ke=Ne+Se*T;if(Ke<0||Ke>=x.inHeight)continue;const Le=Se*p[0],Be=ge+Ke*d[1];for(let on=0;on<x.outWidth;++on){const rn=ve+on*Tt.strides[2],pn=on*x.strideWidth-U;for(let Qe=0;Qe<b;++Qe){const gn=pn+Qe*N;if(gn<0||gn>=x.inWidth)continue;const kn=Be+gn*x.inChannels;let ir=rn,Cr=Le+Qe*p[1];for(let yr=0;yr<x.inChannels;++yr){const Hr=Pt[kn+yr];for(let Qr=0;Qr<ht;++Qr)Ot[ir+Qr]+=Hr*zt[Cr+Qr];ir+=ht,Cr+=ht}}}}}}return e.makeTensorInfo(Tt.shape,Tt.dtype,Tt.values)}const eht={kernelName:g.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:l3},rht={kernelName:g.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function nht(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,dilations:a,pad:u,dimRoundingMode:c,filterShape:d}=r;ar([i,s],"depthwiseConv2dNativeBackpropFilter");const p=g.backend_util.computeConv2DInfo(i.shape,d,o,a,u,c,!0),{strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:b}=p,T=new g.TensorBuffer(p.filterShape,"float32"),N=p.padInfo.left,S=p.padInfo.top,U=p.outChannels/p.inChannels,J=e.data.get(i.dataId).values,ht=new g.TensorBuffer(i.shape,i.dtype,J),Tt=e.data.get(s.dataId).values,Pt=new g.TensorBuffer(s.shape,s.dtype,Tt);for(let zt=0;zt<w;++zt){const Ot=Math.max(0,Math.ceil((S-zt)/v)),le=Math.min(p.outHeight,(p.inHeight+S-zt)/v);for(let ge=0;ge<b;++ge){const Ae=Math.max(0,Math.ceil((N-ge)/x)),Re=Math.min(p.outWidth,(p.inWidth+N-ge)/x);for(let ve=0;ve<p.outChannels;++ve){const Ne=Math.trunc(ve/U),Se=ve%U;let Ke=0;for(let Le=0;Le<p.batchSize;++Le)for(let Be=Ot;Be<le;++Be){const on=zt+Be*v-S;for(let rn=Ae;rn<Re;++rn)Ke+=ht.get(Le,on,ge+rn*x-N,Ne)*Pt.get(Le,Be,rn,ve)}T.set(Ke,zt,ge,Ne,Se)}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},sht={kernelName:g.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function iht(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{strides:o,dilations:a,pad:u,dimRoundingMode:c,inputShape:d}=r;ar([i,s],"depthwiseConv2DNativeBackpropInput");const p=g.util.computeStrides(i.shape),v=g.util.computeStrides(s.shape),x=g.backend_util.computeConv2DInfo(d,s.shape,o,a,u,c,!0),w=new g.TensorBuffer(x.inShape,"float32"),b=w.values,[T,N,S]=w.strides,U=e.data.get(i.dataId).values,[J,ht,Tt]=p,Pt=e.data.get(s.dataId).values,[zt,Ot,le]=v,{batchSize:ge,filterHeight:Ae,filterWidth:Re,inChannels:ve,inHeight:Ne,inWidth:Se,outChannels:Ke,outHeight:Le,outWidth:Be,strideHeight:on,strideWidth:rn}=x,pn=Ae-1-x.padInfo.top,Qe=Re-1-x.padInfo.left,gn=Ke/ve;for(let dn=0;dn<ge;++dn)for(let kn=0;kn<ve;++kn)for(let ir=0;ir<Ne;++ir){const Cr=ir-pn,yr=Math.max(0,Math.ceil(Cr/on)),Hr=Math.min(Le,(Ae+Cr)/on);for(let Qr=0;Qr<Se;++Qr){const Rs=Qr-Qe,uo=Math.max(0,Math.ceil(Rs/rn)),Yo=Math.min(Be,(Re+Rs)/rn);let lo=0;for(let co=yr;co<Hr;++co){const ua=co*on-Cr;for(let qo=uo;qo<Yo;++qo){const wu=J*dn+ht*co+Tt*qo,pd=zt*(Ae-1-ua)+Ot*(Re-1-(qo*rn-Rs))+le*kn;for(let Gl=0;Gl<gn;++Gl)lo+=U[wu+(kn*gn+Gl)]*Pt[pd+Gl]}}b[T*dn+N*ir+S*Qr+kn]=lo}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},aht={kernelName:g.Diag,backendName:"cpu",kernelFunc:function oht(t){const{inputs:n,backend:e}=t,{x:r}=n,i=g.util.sizeFromShape(r.shape),s=e.data.get(r.dataId).values,o=(0,g.buffer)([i,i],r.dtype),a=o.values;for(let c=0;c<s.length;c++)a[c*i+c]=s[c];const u=[...r.shape,...r.shape];return e.makeTensorInfo(u,o.dtype,o.values)}},uht={kernelName:g.Dilation2D,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:i}=t,{strides:s,pad:o,dilations:a}=e,u=n,c=u.data.get(r.dataId).values,d=r.shape.length,p=u.data.get(i.dataId).values,v=i.shape.length,{batchSize:x,inHeight:w,inWidth:b,inChannels:T,outHeight:N,outWidth:S,padInfo:U,strideHeight:J,strideWidth:ht,filterHeight:Tt,filterWidth:Pt,dilationHeight:zt,dilationWidth:Ot,outShape:le}=g.backend_util.computeDilation2DInfo(r.shape,i.shape,s,o,"NHWC",a),ge=g.util.sizeFromShape(le),Ae=le.length,Re=g.util.getArrayFromDType(r.dtype,ge);for(let Ne=0;Ne<x;++Ne)for(let Se=0;Se<N;++Se){const Ke=Se*J-U.top;for(let Le=0;Le<S;++Le){const Be=Le*ht-U.left;for(let on=0;on<T;++on){let rn=Number.MIN_SAFE_INTEGER;for(let Qe=0;Qe<Tt;++Qe){const gn=Ke+Qe*zt;if(gn>=0&&gn<w)for(let dn=0;dn<Pt;++dn){const kn=Be+dn*Ot;if(kn>=0&&kn<b){const ir=g.util.locToIndex([Ne,gn,kn,on],d,g.util.computeStrides(r.shape)),Cr=g.util.locToIndex([Qe,dn,on],v,g.util.computeStrides(i.shape)),yr=c[ir]+p[Cr];yr>rn&&(rn=yr)}}}Re[g.util.locToIndex([Ne,Se,Le,on],Ae,g.util.computeStrides(le))]=rn}}}return{dataId:u.write(g.util.toTypedArray(Re,r.dtype),le,r.dtype),shape:le,dtype:r.dtype}}},lht={kernelName:g.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:i,dy:s}=t,{strides:o,pad:a,dilations:u}=e,c=n,d=g.util.toNestedArray(r.shape,c.data.get(r.dataId).values),p=g.util.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:v,inHeight:x,inWidth:w,inChannels:b,outHeight:T,outWidth:N,padInfo:S,strideHeight:U,strideWidth:J,filterHeight:ht,filterWidth:Tt,dilationHeight:Pt,dilationWidth:zt,outShape:Ot}=g.backend_util.computeDilation2DInfo(r.shape,i.shape,o,a,"NHWC",u);g.util.assert(s.rank===Ot.length,()=>`Error in ${g.Dilation2DBackpropFilter}, dy must have the same rank as output ${Ot.length}, but got ${s.rank}`);const le=g.util.toNestedArray(Ot,c.data.get(s.dataId).values),ge=g.util.makeZerosNestedTypedArray(i.shape,i.dtype);for(let Re=0;Re<v;++Re)for(let ve=0;ve<T;++ve){const Ne=ve*U-S.top;for(let Se=0;Se<N;++Se){const Ke=Se*J-S.left;for(let Le=0;Le<b;++Le){let Be=Number.MIN_SAFE_INTEGER,on=0,rn=0;for(let pn=0;pn<ht;++pn){const Qe=Ne+pn*Pt;if(Qe>=0&&Qe<x)for(let gn=0;gn<Tt;++gn){const dn=Ke+gn*zt;if(dn>=0&&dn<w){const kn=d[Re][Qe][dn][Le]+p[pn][gn][Le];kn>Be&&(Be=kn,on=pn,rn=gn)}}}ge[on][rn][Le]+=le[Re][ve][Se][Le]}}}return{dataId:c.write(g.util.toTypedArray(ge,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},cht={kernelName:g.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:i,dy:s}=t,{strides:o,pad:a,dilations:u}=e,c=n,d=g.util.toNestedArray(r.shape,c.data.get(r.dataId).values),p=g.util.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:v,inHeight:x,inWidth:w,inChannels:b,outHeight:T,outWidth:N,padInfo:S,strideHeight:U,strideWidth:J,filterHeight:ht,filterWidth:Tt,dilationHeight:Pt,dilationWidth:zt,outShape:Ot}=g.backend_util.computeDilation2DInfo(r.shape,i.shape,o,a,"NHWC",u);g.util.assert(s.rank===Ot.length,()=>`Error in ${g.Dilation2DBackpropInput}, dy must have the same rank as output ${Ot.length}, but got ${s.rank}`);const le=g.util.toNestedArray(Ot,c.data.get(s.dataId).values),ge=g.util.makeZerosNestedTypedArray(r.shape,r.dtype);for(let Re=0;Re<v;++Re)for(let ve=0;ve<T;++ve){const Ne=ve*U-S.top;for(let Se=0;Se<N;++Se){const Ke=Se*J-S.left;for(let Le=0;Le<b;++Le){let Be=Number.MIN_SAFE_INTEGER,on=Ne<0?0:Ne,rn=Ke<0?0:Ke;for(let pn=0;pn<ht;++pn){const Qe=Ne+pn*Pt;if(Qe>=0&&Qe<x)for(let gn=0;gn<Tt;++gn){const dn=Ke+gn*zt;if(dn>=0&&dn<w){const kn=d[Re][Qe][dn][Le]+p[pn][gn][Le];kn>Be&&(Be=kn,on=Qe,rn=dn)}}}ge[Re][on][rn][Le]+=le[Re][ve][Se][Le]}}}return{dataId:c.write(g.util.toTypedArray(ge,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},dht={kernelName:g.Draw,backendName:"cpu",kernelFunc:function hht(t){const{inputs:n,backend:e,attrs:r}=t,{image:i}=n,{canvas:s,options:o}=r,{contextOptions:a,imageOptions:u}=o||{},c=u?.alpha||1,d=a?.contextType||"2d";if("2d"!==d)throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const p=s.getContext(d,a?.contextAttributes||{});if(null==p)throw new Error(`Could not get the context with ${d} type.`);const[v,x]=i.shape.slice(0,2),w=2===i.shape.length?1:i.shape[2],b=e.data.get(i.dataId).values,T="float32"===i.dtype?255:1,N=new Uint8ClampedArray(x*v*4);for(let U=0;U<v*x;++U){const J=[0,0,0,255*c];for(let Tt=0;Tt<w;Tt++){const Pt=b[U*w+Tt];if("float32"===i.dtype){if(Pt<0||Pt>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Pt}.`)}else if("int32"===i.dtype&&(Pt<0||Pt>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Pt}.`);1===w?(J[0]=Pt*T,J[1]=Pt*T,J[2]=Pt*T):J[Tt]=Pt*T}const ht=4*U;N[ht+0]=Math.round(J[0]),N[ht+1]=Math.round(J[1]),N[ht+2]=Math.round(J[2]),N[ht+3]=Math.round(J[3])}s.width=x,s.height=v;const S=new ImageData(N,x,v);return p.putImageData(S,0,0),i}},QI=Ma((t,n)=>t*n),fht=XI((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),n1=eu(g.Multiply,QI,fht),pht={kernelName:g.Multiply,backendName:"cpu",kernelFunc:n1};function Xg(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;let a;ar(i,"sum"),a="bool"===i.dtype?ld({inputs:{x:i},backend:e,attrs:{dtype:"int32"}}):sh({inputs:{x:i},backend:e});const u=a.shape.length,c=g.util.parseAxisParam(s,a.shape),d=g.backend_util.getAxesPermutation(c,u);let p=c,v=a;null!=d&&(v=fl({inputs:{x:a},backend:e,attrs:{perm:d}}),p=g.backend_util.getInnerMostAxes(p.length,u)),g.backend_util.assertAxesAreInnerMostDims("sum",p,v.shape.length);const[x,w]=g.backend_util.computeOutAndReduceShapes(v.shape,p);let T=e1(e,x,g.backend_util.upcastType(v.dtype,"int32"));const N=g.util.sizeFromShape(w),S=e.data.get(T.dataId).values,U=e.data.get(v.dataId).values;for(let J=0;J<S.length;++J){const ht=J*N;let Tt=0;for(let Pt=0;Pt<N;++Pt)Tt+=U[ht+Pt];S[J]=Tt}if(o){const ht=T;T=Ao({inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(T.shape,c)}}),e.disposeIntermediateTensorInfo(ht)}return e.disposeIntermediateTensorInfo(a),null!=d&&e.disposeIntermediateTensorInfo(v),T}const mht={kernelName:g.Sum,backendName:"cpu",kernelFunc:Xg},yht={kernelName:g.Einsum,backendName:"cpu",kernelFunc:function ght(t){const{inputs:n,backend:e,attrs:r}=t,{equation:i}=r,s=n,{allDims:o,summedDims:a,idDims:u}=g.backend_util.decodeEinsumEquation(i,s.length);g.backend_util.checkEinsumDimSizes(o.length,u,s);const{path:c,steps:d}=g.backend_util.getEinsumComputePath(a,u),p=d.length;let v=null,x=o.length;const w=[];for(let b=0;b<p;++b){for(const T of d[b]){const{permutationIndices:N,expandDims:S}=g.backend_util.getEinsumPermutation(x,u[T]);let U;g.backend_util.isIdentityPermutation(N)?U=s[T]:(U=fl({inputs:{x:s[T]},backend:e,attrs:{perm:N}}),w.push(U));const J=U.shape.slice();for(let ht=0;ht<S.length;++ht)J.splice(S[ht],0,1);g.util.arraysEqual(U.shape,J)||(U=Ao({inputs:{x:U},backend:e,attrs:{shape:J}}),w.push(U)),null===v?v=U:(v=n1({inputs:{a:U,b:v},backend:e}),w.push(v))}b<p-1&&(c[b]>=0&&(v=Xg({inputs:{x:v},backend:e,attrs:{axis:c[b]-(o.length-x),keepDims:!1}}),w.push(v)),x--)}for(const b of w)b!==v&&e.disposeIntermediateTensorInfo(b);return v}},_ht={kernelName:g.EluGrad,backendName:"cpu",kernelFunc:function vht(t){const{inputs:n,backend:e}=t,{dy:r,y:i}=n;ar([r,i],"eluGrad");const s=new Float32Array(g.util.sizeFromShape(i.shape)),o=e.data.get(i.dataId).values,a=e.data.get(r.dataId).values;for(let u=0;u<o.length;++u){const c=o[u];s[u]=c>=0?a[u]:a[u]*(c+1)}return e.makeTensorInfo(i.shape,"float32",s)}},c3=Ma((t,n)=>t===n?1:0),h3=eu(g.Equal,c3,null,"bool"),xht={kernelName:g.Equal,backendName:"cpu",kernelFunc:h3},Eht=g.backend_util.ERF_P,Cht=g.backend_util.ERF_A1,wht=g.backend_util.ERF_A2,bht=g.backend_util.ERF_A3,Iht=g.backend_util.ERF_A4,Sht=g.backend_util.ERF_A5,Dht=Js(g.Erf,t=>{const n=Math.sign(t),e=Math.abs(t),r=1/(1+Eht*e);return n*(1-((((Sht*r+Iht)*r+bht)*r+wht)*r+Cht)*r*Math.exp(-e*e))}),Tht={kernelName:g.Erf,backendName:"cpu",kernelFunc:Dht},d3=ih(t=>Math.exp(t)),f3=ud(g.Exp,d3,"float32"),Nht={kernelName:g.Exp,backendName:"cpu",kernelFunc:f3};function r1(t){const{inputs:n,backend:e,attrs:r}=t,{input:i}=n,{dim:s}=r,o=i.shape.length,a=i.shape.slice();let u=s;return s<0&&(g.util.assert(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+s+1),a.splice(u,0,1),Ao({inputs:{x:i},backend:e,attrs:{shape:a}})}const Aht={kernelName:g.ExpandDims,backendName:"cpu",kernelFunc:r1},p3=ih(t=>Math.expm1(t)),Mht=ud(g.Expm1,p3),Pht={kernelName:g.Expm1,backendName:"cpu",kernelFunc:Mht},Oht=Ma((t,n)=>t/n),JI=eu(g.RealDiv,Oht),tS={kernelName:g.RealDiv,backendName:"cpu",kernelFunc:JI},m3=Ma((t,n)=>t-n),Rht=XI((t,n,e,r)=>({real:t-e,imag:n-r})),eS=eu(g.Sub,m3,Rht),Lht={kernelName:g.Sub,backendName:"cpu",kernelFunc:eS};function g3(t,n,e){const r=t.shape,i=r[0],s=r[1],o=e.data.get(t.dataId),a=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[i,s],d=g.util.sizeFromShape(c),p=g.util.getTypedArrayFromDType("float32",d),v=g.util.getTypedArrayFromDType("float32",d);for(let T=0;T<i;T++){const N=Yd({inputs:{x:a},backend:e,attrs:{begin:[T,0],size:[1,s]}}),S=Yd({inputs:{x:u},backend:e,attrs:{begin:[T,0],size:[1,s]}}),U=wl({inputs:{real:N,imag:S},backend:e}),{real:J,imag:ht}=kht(U,n,e),Tt=g.backend_util.mergeRealAndImagArrays(J,ht);for(let Pt=0;Pt<s;Pt++){const zt=g.backend_util.getComplexWithIndex(Tt,Pt);p[T*s+Pt]=zt.real,v[T*s+Pt]=zt.imag}e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(U)}const x=e.makeTensorInfo(c,"float32",p),w=e.makeTensorInfo(c,"float32",v),b=wl({inputs:{real:x,imag:w},backend:e});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),b}function kht(t,n,e){const r=g.util.sizeFromShape(t.shape),i=e.data.get(t.dataId),s=e.data.get(i.complexTensorInfos.real.dataId).values,o=e.data.get(i.complexTensorInfos.imag.dataId).values;if(function Fht(t){return 0==(t&t-1)}(r)){const a=nS(s,o,r,n,e),u=[t.shape[0],t.shape[1]];if(n){const c=e.makeTensorInfo(u,"float32",a.real),d=e.makeTensorInfo(u,"float32",a.imag),p=e.makeTensorInfo([],"float32",g.util.createScalarValue(r,"float32")),v=sh({inputs:{x:p},backend:e}),x=tS.kernelFunc({inputs:{a:c,b:p},backend:e}),w=tS.kernelFunc({inputs:{a:d,b:v},backend:e}),b=e.data.get(x.dataId).values,T=e.data.get(w.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),{real:b,imag:T}}return a}{const u=function $ht(t,n,e){const r=new Float32Array(2*n);for(let i=0;i<n;i++){let s=0,o=0;for(let a=0;a<n;a++){const u=g.backend_util.exponent(i*a,n,e),c=g.backend_util.getComplexWithIndex(t,a);s+=c.real*u.real-c.imag*u.imag,o+=c.real*u.imag+c.imag*u.real}e&&(s/=n,o/=n),g.backend_util.assignToTypedArray(r,s,o,i)}return r}(g.backend_util.mergeRealAndImagArrays(s,o),r,n);return g.backend_util.splitRealAndImagArrays(u)}}function nS(t,n,e,r,i){if(1===e)return{real:t,imag:n};const s=g.backend_util.mergeRealAndImagArrays(t,n),o=e/2,a=g.backend_util.complexWithEvenIndex(s),u=a.real,c=a.imag,d=[u.length],p=i.makeTensorInfo(d,"float32",u),v=i.makeTensorInfo(d,"float32",c),x=wl({inputs:{real:p,imag:v},backend:i}),w=g.backend_util.complexWithOddIndex(s),b=w.real,T=w.imag,N=[b.length],S=i.makeTensorInfo(N,"float32",b),U=i.makeTensorInfo(N,"float32",T),J=wl({inputs:{real:S,imag:U},backend:i}),ht=nS(u,c,o,r,i),Tt=ht.real,Pt=ht.imag,zt=[Tt.length],Ot=i.makeTensorInfo(zt,"float32",Tt),le=i.makeTensorInfo(zt,"float32",Pt),ge=wl({inputs:{real:Ot,imag:le},backend:i}),Ae=nS(b,T,o,r,i),Re=Ae.real,ve=Ae.imag,Ne=[Re.length],Se=i.makeTensorInfo(Ne,"float32",Re),Ke=i.makeTensorInfo(Ne,"float32",ve),Le=wl({inputs:{real:Se,imag:Ke},backend:i}),Be=g.backend_util.exponents(e,r),on=[Be.real.length],rn=i.makeTensorInfo(on,"float32",Be.real),pn=i.makeTensorInfo(on,"float32",Be.imag),Qe=wl({inputs:{real:rn,imag:pn},backend:i}),gn=n1({inputs:{a:Qe,b:Le},backend:i}),dn=Rp({inputs:{a:ge,b:gn},backend:i}),kn=eS({inputs:{a:ge,b:gn},backend:i}),ir=Zd({inputs:{input:dn},backend:i}),Cr=Zd({inputs:{input:kn},backend:i}),yr=Lp({inputs:{input:dn},backend:i}),Hr=Lp({inputs:{input:kn},backend:i}),Qr=kp({inputs:[ir,Cr],backend:i,attrs:{axis:0}}),Rs=kp({inputs:[yr,Hr],backend:i,attrs:{axis:0}}),uo=i.data.get(Qr.dataId).values,Yo=i.data.get(Rs.dataId).values;return i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(J),i.disposeIntermediateTensorInfo(Ot),i.disposeIntermediateTensorInfo(le),i.disposeIntermediateTensorInfo(ge),i.disposeIntermediateTensorInfo(Se),i.disposeIntermediateTensorInfo(Ke),i.disposeIntermediateTensorInfo(Le),i.disposeIntermediateTensorInfo(rn),i.disposeIntermediateTensorInfo(pn),i.disposeIntermediateTensorInfo(Qe),i.disposeIntermediateTensorInfo(gn),i.disposeIntermediateTensorInfo(dn),i.disposeIntermediateTensorInfo(kn),i.disposeIntermediateTensorInfo(ir),i.disposeIntermediateTensorInfo(yr),i.disposeIntermediateTensorInfo(Cr),i.disposeIntermediateTensorInfo(Hr),i.disposeIntermediateTensorInfo(Qr),i.disposeIntermediateTensorInfo(Rs),{real:uo,imag:Yo}}const zht={kernelName:g.FFT,backendName:"cpu",kernelFunc:function Bht(t){const{inputs:n,backend:e}=t,{input:r}=n,i=g.util.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=Ao({inputs:{x:r},backend:e,attrs:{shape:[i/s,s]}}),u=g3(a,!1,e),c=Ao({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),c}};function rS(t){const{backend:n,attrs:e}=t,{shape:r,value:i,dtype:s}=e,o=s||g.util.inferDtype(i),a=g.util.getArrayFromDType(o,g.util.sizeFromShape(r));return function Uht(t,n,e){t.fill(n)}(a,i),n.makeTensorInfo(r,o,a)}const Vht={kernelName:g.Fill,backendName:"cpu",kernelFunc:rS},Wht={kernelName:g.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:r}=t,i=e,s=g.util.getTypedArrayFromDType(r.dtype,g.util.sizeFromShape(r.shape)),[o,a,u,c]=r.shape,d=i.data.get(r.dataId).values;for(let v=0;v<o;v++){const x=v*u*a*c;for(let w=0;w<a;w++){const b=w*(u*c);for(let T=0;T<u;T++){const N=T*c;for(let S=0;S<c;S++){const U=Math.round(u-T-1),J=x+b+N+S;let ht=d[J];U>=0&&U<u&&(ht=d[x+b+U*c+S]),s[J]=ht}}}}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},y3=ih(t=>Math.floor(t)),Ght=ud(g.Floor,y3),Hht={kernelName:g.Floor,backendName:"cpu",kernelFunc:Ght},jht=Ma((t,n)=>Math.floor(t/n)),Kht=eu(g.FloorDiv,jht,null,"int32"),Xht={kernelName:g.FloorDiv,backendName:"cpu",kernelFunc:Kht},Yht={kernelName:g.FusedConv2D,backendName:"cpu",kernelFunc:function Zht(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v,activation:x,leakyreluAlpha:w}=r;let b=u3({inputs:{x:i,filter:s},backend:e,attrs:{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v}});if(o){const T=b;if("NCHW"===d&&1===o.shape.length&&1!==o.shape[0]){const N=Ao({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});b=Rp({inputs:{a:b,b:N},backend:e}),e.disposeIntermediateTensorInfo(N)}else b=Rp({inputs:{a:b,b:o},backend:e});e.disposeIntermediateTensorInfo(T)}if(x){const T=b;if("NCHW"===d&&"prelu"===x&&1===a.shape.length&&1!==a.shape[0]){const N=Ao({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});b=t1(e,b,x,N,w),e.disposeIntermediateTensorInfo(N)}else b=t1(e,b,x,a,w);e.disposeIntermediateTensorInfo(T)}return b}},Qht={kernelName:g.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function qht(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v,activation:x,leakyreluAlpha:w}=r;let b=l3({inputs:{x:i,filter:s},backend:e,attrs:{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v}});if(o){const T=b;b=Rp({inputs:{a:b,b:o},backend:e}),e.disposeIntermediateTensorInfo(T)}if(x){const T=b;b=t1(e,b,x,a,w),e.disposeIntermediateTensorInfo(T)}return b}};function v3(t,n,e,r,i,s,o,a,u){const c=(0,g.buffer)([r,s],e);for(let d=0;d<r;d++){const p=[];let v=0;for(let x=0;x<i;x++){const w=t[d*i+x];v+=w*o[x],p.push(w)}if(v<0||v>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let x=0;x<s;x++)c.values[d*s+x]=n.get(...n.indexToLoc(v*s+x))}return c}const tdt={kernelName:g.GatherNd,backendName:"cpu",kernelFunc:function Jht(t){const{inputs:n,backend:e}=t,{params:r,indices:i}=n,s=g.util.sizeFromShape(r.shape),o=i.shape,a=o[o.length-1],[u,c,d,p]=g.backend_util.prepareAndValidate(r,i);if(0===c)return e.makeTensorInfo(u,r.dtype,[]);const w=v3(e.data.get(i.dataId).values,e.bufferSync(r),r.dtype,c,a,d,p,r.shape,s);return e.makeTensorInfo(u,r.dtype,w.values)}};function _3(t,n,e){const r=(0,g.buffer)(e,t.dtype);for(let i=0;i<r.size;++i){const o=r.indexToLoc(i).slice(),c=n.locToIndex([o[0],o[2]]);o[2]=n.values[c];const d=t.locToIndex(o);0<=d&&d<t.values.length&&(r.values[i]=t.values[d])}return r}const ndt={kernelName:g.GatherV2,backendName:"cpu",kernelFunc:function edt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,indices:s}=n,{axis:o,batchDims:a}=r;ar([i,s],"gatherV2");const u=g.util.parseAxisParam(o,i.shape)[0],c=e.data.get(s.dataId).values,d=i.shape[u];for(let J=0;J<c.length;++J){const ht=c[J];g.util.assert(ht<=d-1&&ht>=0,()=>`GatherV2: the index value ${ht} is not in [0, ${d-1}]`)}let p=a;null==a&&(p=0);const v=g.util.sizeFromShape(s.shape),x=g.backend_util.segment_util.collectGatherOpShapeInfo(i,s,u,p),w=Ao({inputs:{x:i},backend:e,attrs:{shape:[x.batchSize,x.outerSize,x.dimSize,x.sliceSize]}}),b=Ao({inputs:{x:s},backend:e,attrs:{shape:[x.batchSize,v/x.batchSize]}}),T=[x.batchSize,x.outerSize,v/x.batchSize,x.sliceSize],N=e.bufferSync(b),U=_3(e.bufferSync(w),N,T);return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(b),e.makeTensorInfo(x.outputShape,U.dtype,U.values)}},x3=Ma((t,n)=>t>n?1:0),rdt=eu(g.Greater,x3,null,"bool"),idt={kernelName:g.Greater,backendName:"cpu",kernelFunc:rdt},E3=Ma((t,n)=>t>=n?1:0),sdt=eu(g.GreaterEqual,E3,null,"bool"),odt={kernelName:g.GreaterEqual,backendName:"cpu",kernelFunc:sdt},udt={kernelName:g.IFFT,backendName:"cpu",kernelFunc:function adt(t){const{inputs:n,backend:e}=t,{input:r}=n,i=g.util.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=Ao({inputs:{x:r},backend:e,attrs:{shape:[i/s,s]}}),u=g3(a,!0,e),c=Ao({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),c}},ldt=Js(g.IsFinite,t=>Number.isFinite(t)?1:0,"bool"),cdt={kernelName:g.IsFinite,backendName:"cpu",kernelFunc:ldt},hdt=Js(g.IsInf,t=>Math.abs(t)===1/0?1:0,"bool"),ddt={kernelName:g.IsInf,backendName:"cpu",kernelFunc:hdt},fdt=Js(g.IsNan,t=>Number.isNaN(t)?1:0,"bool"),pdt={kernelName:g.IsNan,backendName:"cpu",kernelFunc:fdt},C3=Ma((t,n)=>t<n?1:0),mdt=eu(g.Less,C3,null,"bool"),gdt={kernelName:g.Less,backendName:"cpu",kernelFunc:mdt},w3=Ma((t,n)=>t<=n?1:0),ydt=eu(g.LessEqual,w3,null,"bool"),vdt={kernelName:g.LessEqual,backendName:"cpu",kernelFunc:ydt};function b3(t,n,e){const r=(n-t)/(e-1),i=g.util.makeZerosTypedArray(e,"float32");i[0]=t;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}const xdt={kernelName:g.LinSpace,backendName:"cpu",kernelFunc:function _dt(t){const{backend:n,attrs:e}=t,{start:r,stop:i,num:s}=e,o=b3(r,i,s);return n.makeTensorInfo([o.length],"float32",o)}},I3=ih(t=>Math.log(t)),Edt=ud(g.Log,I3),Cdt={kernelName:g.Log,backendName:"cpu",kernelFunc:Edt},wdt=Js(g.Log1p,t=>Math.log1p(t)),bdt={kernelName:g.Log1p,backendName:"cpu",kernelFunc:wdt},Idt=Ma((t,n)=>t&&n),Sdt=eu(g.LogicalAnd,Idt,null,"bool"),Ddt={kernelName:g.LogicalAnd,backendName:"cpu",kernelFunc:Sdt},Tdt=Js(g.LogicalNot,t=>t?0:1,"bool"),Ndt={kernelName:g.LogicalNot,backendName:"cpu",kernelFunc:Tdt},Adt=Ma((t,n)=>t||n),Mdt=eu(g.LogicalOr,Adt,null,"bool"),Pdt={kernelName:g.LogicalOr,backendName:"cpu",kernelFunc:Mdt},Rdt={kernelName:g.LRN,backendName:"cpu",kernelFunc:function Odt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{depthRadius:s,bias:o,alpha:a,beta:u}=r;ar(i,"LRN");const c=i.shape[3],d=c-1,p=e.data.get(i.dataId).values,v=g.util.sizeFromShape(i.shape),x=new Float32Array(v);function w(b){const T=b%c;let N=b-T+Math.max(0,T-s);const S=b-T+Math.min(T+s,d);let U=0;for(;N<=S;N++){const J=p[N];U+=J*J}return U}for(let b=0;b<v;b++){const T=w(b),N=p[b]*Math.pow(o+a*T,-u);x[b]=N}return e.makeTensorInfo(i.shape,i.dtype,x)}},kdt={kernelName:g.LRNGrad,backendName:"cpu",kernelFunc:function Ldt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,y:s,dy:o}=n,{depthRadius:a,bias:u,alpha:c,beta:d}=r;ar(o,"LRNGrad");const p=g.util.sizeFromShape(o.shape),v=o.shape[3],x=e.data.get(o.dataId).values,w=e.data.get(i.dataId).values,b=e.data.get(s.dataId).values,T=new Float32Array(p),N=p;for(let S=0;S<N;S++){const U=S%v,J=S-U+Math.max(0,U-a),ht=S-U+Math.min(v,U+a+1);let Tt=0;for(let Pt=J;Pt<ht;Pt++)Tt+=Math.pow(w[Pt],2);Tt=c*Tt+u;for(let Pt=J;Pt<ht;Pt++){let zt=-2*c*d*w[Pt]*b[S]/Tt;S===Pt&&(zt+=Math.pow(Tt,-d)),zt*=x[S],T[Pt]+=zt}}return e.makeTensorInfo(o.shape,i.dtype,T)}};function S3(t,n,e,r){const i=g.util.getTypedArrayFromDType(r,g.util.sizeFromShape(e));for(let s=0;s<i.length;++s){const o=s*n;let a=t[o];for(let u=0;u<n;++u){const c=t[o+u];(Number.isNaN(c)||c>a)&&(a=c)}i[s]=a}return i}function D3(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{reductionIndices:s,keepDims:o}=r,a=e;let u=i.shape;const c=u.length,d=g.util.parseAxisParam(s,u);let p=d;const v=g.backend_util.getAxesPermutation(p,c);let x=a.data.get(i.dataId).values;if(null!=v){const J=new Array(c);for(let ht=0;ht<J.length;ht++)J[ht]=u[v[ht]];x=ZI(x,u,i.dtype,v,J),p=g.backend_util.getInnerMostAxes(p.length,c),u=J}ar(i,"max"),g.backend_util.assertAxesAreInnerMostDims("max",p,c);const[w,b]=g.backend_util.computeOutAndReduceShapes(u,p),N=S3(x,g.util.sizeFromShape(b),w,i.dtype),S=a.write(N,w,i.dtype);let U=w;return o&&(U=g.backend_util.expandShapeToKeepDim(w,d)),{dataId:S,shape:U,dtype:i.dtype}}const Fdt={kernelName:g.Max,backendName:"cpu",kernelFunc:D3},T3=Ma((t,n)=>Math.max(t,n)),$dt=eu(g.Maximum,T3),Bdt={kernelName:g.Maximum,backendName:"cpu",kernelFunc:$dt},Vdt={kernelName:g.MaxPool,backendName:"cpu",kernelFunc:function zdt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;ar(i,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=g.backend_util.computePool2DInfo(i.shape,s,o,1,a,u);let p;if(1===d.filterWidth&&1===d.filterHeight&&g.util.arraysEqual(d.inShape,d.outShape))p=sh({inputs:{x:i},backend:e});else{const v=e.data.get(i.dataId).values,x=g.util.computeStrides(i.shape),w=YI(v,0,i.dtype,x,d,"max");p=e.makeTensorInfo(d.outShape,i.dtype,w.values)}return p}},Wdt={kernelName:g.MaxPool3D,backendName:"cpu",kernelFunc:function Udt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{filterSize:s,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r;ar(i,"maxPool3d");const d=g.backend_util.computePool3DInfo(i.shape,s,o,1,a,u,c),v=n3(e.data.get(i.dataId).values,0,i.dtype,g.util.computeStrides(i.shape),d,"max");return e.makeTensorInfo(v.shape,"float32",v.values)}},Hdt={kernelName:g.MaxPool3DGrad,backendName:"cpu",kernelFunc:function Gdt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,{filterSize:o,strides:a,pad:u,dimRoundingMode:c}=r;ar([i,s],"maxPool3DGrad");const d=g.backend_util.computePool3DInfo(s.shape,o,a,1,u,c),v=function nct(t,n){const e=(0,g.buffer)(n.outShape,"int32"),r=n.strideDepth,i=n.strideHeight,s=n.strideWidth,o=n.dilationDepth,a=n.dilationHeight,u=n.dilationWidth,c=n.effectiveFilterDepth,d=n.effectiveFilterHeight,p=n.effectiveFilterWidth,v=n.padInfo.front,x=n.padInfo.top,w=n.padInfo.left;for(let b=0;b<n.batchSize;++b)for(let T=0;T<n.inChannels;++T)for(let N=0;N<n.outDepth;++N){const S=N*r-v;let U=S;for(;U<0;)U+=o;const J=Math.min(n.inDepth,c+S);for(let ht=0;ht<n.outHeight;++ht){const Tt=ht*i-x;let Pt=Tt;for(;Pt<0;)Pt+=a;const zt=Math.min(n.inHeight,d+Tt);for(let Ot=0;Ot<n.outWidth;++Ot){const le=Ot*s-w;let ge=le;for(;ge<0;)ge+=u;const Ae=Math.min(n.inWidth,p+le);let Re=Number.NEGATIVE_INFINITY,ve=-1;for(let Ne=U;Ne<J;Ne+=o){const Se=Ne-S;for(let Ke=Pt;Ke<zt;Ke+=a){const Le=Ke-Tt;for(let Be=ge;Be<Ae;Be+=u){const on=Be-le,rn=t.get(b,Ne,Ke,Be,T);rn>=Re&&(Re=rn,ve=Se*d*p+Le*d+on)}}}e.set(ve,b,N,ht,Ot,T)}}}return e}(e.bufferSync(s),d),x=d.strideDepth,w=d.strideHeight,b=d.strideWidth,T=d.dilationDepth,N=d.dilationHeight,S=d.dilationWidth,U=d.effectiveFilterDepth,J=d.effectiveFilterHeight,ht=d.effectiveFilterWidth,Tt=U-1-d.padInfo.front,Pt=ht-1-d.padInfo.left,zt=J-1-d.padInfo.top,Ot=(0,g.buffer)(s.shape,"float32"),le=e.bufferSync(i);for(let ge=0;ge<d.batchSize;++ge)for(let Ae=0;Ae<d.inChannels;++Ae)for(let Re=0;Re<d.inDepth;++Re)for(let ve=0;ve<d.inHeight;++ve)for(let Ne=0;Ne<d.inWidth;++Ne){const Se=Re-Tt,Ke=ve-zt,Le=Ne-Pt;let Be=0;for(let on=0;on<U;on+=T){const rn=(Se+on)/x;if(!(rn<0||rn>=d.outDepth||Math.floor(rn)!==rn))for(let pn=0;pn<J;pn+=N){const Qe=(Ke+pn)/w;if(!(Qe<0||Qe>=d.outHeight||Math.floor(Qe)!==Qe))for(let gn=0;gn<ht;gn+=S){const dn=(Le+gn)/b;if(dn<0||dn>=d.outWidth||Math.floor(dn)!==dn)continue;const Cr=U*J*ht-1-v.get(ge,rn,Qe,dn,Ae)===on*J*ht+pn*ht+gn?1:0;0!==Cr&&(Be+=le.get(ge,rn,Qe,dn,Ae)*Cr)}}}Ot.set(Be,ge,Re,ve,Ne,Ae)}return e.makeTensorInfo(Ot.shape,Ot.dtype,Ot.values)}},Kdt={kernelName:g.MaxPoolGrad,backendName:"cpu",kernelFunc:function jdt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s,output:o}=n,a=s;ar([s,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=r,v=g.backend_util.computePool2DInfo(a.shape,u,c,1,d,p),x=e.data.get(a.dataId).values,w=(0,g.buffer)(v.outShape,a.dtype,e3(x,a.shape,a.dtype,v).values),b=v.strideHeight,T=v.strideWidth,N=v.dilationHeight,S=v.dilationWidth,U=v.effectiveFilterHeight,J=v.effectiveFilterWidth,ht=J-1-v.padInfo.left,Tt=U-1-v.padInfo.top,Pt=(0,g.buffer)(a.shape,"float32"),zt=e.data.get(i.dataId).values,Ot=(0,g.buffer)(i.shape,"float32",zt);for(let le=0;le<v.batchSize;++le)for(let ge=0;ge<v.inChannels;++ge)for(let Ae=0;Ae<v.inHeight;++Ae)for(let Re=0;Re<v.inWidth;++Re){const ve=Ae-Tt,Ne=Re-ht;let Se=0;for(let Ke=0;Ke<U;Ke+=N){const Le=(ve+Ke)/b;if(!(Le<0||Le>=v.outHeight||Math.floor(Le)!==Le))for(let Be=0;Be<J;Be+=S){const on=(Ne+Be)/T;if(on<0||on>=v.outWidth||Math.floor(on)!==on)continue;const Qe=U*J-1-w.get(le,Le,on,ge)===Ke*J+Be?1:0;0!==Qe&&(Se+=Ot.get(le,Le,on,ge)*Qe)}}Pt.set(Se,le,Ae,Re,ge)}return e.makeTensorInfo(Pt.shape,Pt.dtype,Pt.values)}},Zdt={kernelName:g.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:a}=n,u=e;ar(r,"MaxPoolWithArgmax");const c=u.data.get(r.dataId).values,d=g.backend_util.computePool2DInfo(r.shape,i,s,[1,1],o),[p,v]=function Xdt(t,n,e,r,i){const o=YI(t,0,e,g.util.computeStrides(n),i,"max"),a=e3(t,n,e,i,!0,r);return[o.values,a.values]}(c,r.shape,r.dtype,a,d),x=u.write(p,d.outShape,r.dtype),w=u.write(v,d.outShape,r.dtype);return[{dataId:x,shape:d.outShape,dtype:r.dtype},{dataId:w,shape:d.outShape,dtype:"int32"}]}},qdt={kernelName:g.Mean,backendName:"cpu",kernelFunc:function Ydt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=g.util.parseAxisParam(s,i.shape),c=g.backend_util.computeOutAndReduceShapes(i.shape,a)[1],d=g.util.sizeFromShape(c),p=[],v=e.makeTensorInfo([],"float32",new Float32Array([d]));p.push(v);const x=ld({inputs:{x:i},backend:e,attrs:{dtype:"float32"}});p.push(x);const w=JI({inputs:{a:x,b:v},backend:e});p.push(w);const b=Xg({inputs:{x:w},backend:e,attrs:{axis:s,keepDims:o}});return p.forEach(T=>e.disposeIntermediateTensorInfo(T)),b}},Jdt={kernelName:g.Min,backendName:"cpu",kernelFunc:function Qdt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;ar(i,"min");const a=g.util.parseAxisParam(s,i.shape);let u=a;const c=g.backend_util.getAxesPermutation(u,i.shape.length);let d=i;null!=c&&(d=fl({inputs:{x:i},backend:e,attrs:{perm:c}}),u=g.backend_util.getInnerMostAxes(u.length,i.shape.length)),g.backend_util.assertAxesAreInnerMostDims("min",u,d.shape.length);const[p,v]=g.backend_util.computeOutAndReduceShapes(d.shape,u),x=g.util.sizeFromShape(v),w=g.util.makeZerosTypedArray(g.util.sizeFromShape(p),d.dtype),b=e.data.get(d.dataId).values;for(let N=0;N<w.length;++N){const S=N*x;let U=b[S];for(let J=0;J<x;++J){const ht=b[S+J];(Number.isNaN(ht)||ht<U)&&(U=ht)}w[N]=U}null!=c&&e.disposeIntermediateTensorInfo(d);const T=e.makeTensorInfo(p,d.dtype,w);if(o){const S=Ao({inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(p,a)}});return e.disposeIntermediateTensorInfo(T),S}return T}},N3=Ma((t,n)=>Math.min(t,n)),tft=eu(g.Minimum,N3),eft={kernelName:g.Minimum,backendName:"cpu",kernelFunc:tft},rft={kernelName:g.MirrorPad,backendName:"cpu",kernelFunc:function nft(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{paddings:s,mode:o}=r;ar(i,"mirrorPad");const a=s.map((U,J)=>U[0]+i.shape[J]+U[1]),u=s.map(U=>U[0]),c=s.map((U,J)=>U[0]+i.shape[J]),d="reflect"===o?0:1,p=e.data.get(i.dataId).values,v=i.shape.length,x=g.util.computeStrides(i.shape),w=g.util.sizeFromShape(a),b=a.length,T=g.util.computeStrides(a),N=g.util.getTypedArrayFromDType(i.dtype,w);for(let U=0;U<w;U++){let J=g.util.indexToLoc(U,b,T);for(let Tt=0;Tt<b;Tt++)J[Tt]<u[Tt]?J[Tt]=2*u[Tt]-J[Tt]-d:J[Tt]>=c[Tt]&&(J[Tt]=2*(c[Tt]-1)-J[Tt]+d);J=J.map((Tt,Pt)=>Tt-u[Pt]);const ht=g.util.locToIndex(J,v,x);N[U]=p[ht]}return{dataId:e.write(N,a,i.dtype),shape:a,dtype:i.dtype}}},ift=Ma((t,n)=>{const e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),sft=eu(g.Mod,ift),oft={kernelName:g.Mod,backendName:"cpu",kernelFunc:sft};function A3(t){const{inputs:n,backend:e,attrs:r}=t,{logits:i}=n,{dim:s}=r,o=i.shape.length;let a=s;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const u=g.util.parseAxisParam([a],i.shape),c=D3({inputs:{x:i},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),d=g.backend_util.expandShapeToKeepDim(c.shape,u),p=Ao({inputs:{x:c},backend:e,attrs:{shape:d}}),v=eS({inputs:{a:i,b:p},backend:e}),x=f3({inputs:{x:v},backend:e}),w=Xg({inputs:{x},backend:e,attrs:{axis:u,keepDims:!1}}),b=Ao({inputs:{x:w},backend:e,attrs:{shape:d}}),T=JI({inputs:{a:x,b},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(b),T}const aft={kernelName:g.Softmax,backendName:"cpu",kernelFunc:A3},lft={kernelName:g.Multinomial,backendName:"cpu",kernelFunc:function uft(t){const{inputs:n,backend:e,attrs:r}=t,{logits:i}=n,{numSamples:s,seed:o,normalized:a}=r;ar(i,"multinomial");const u=a?i:A3({inputs:{logits:i},backend:e,attrs:{dim:-1}}),c=u.shape[0],d=u.shape[1],p=e.data.get(u.dataId).values,v=[c,s],x=g.util.makeZerosTypedArray(g.util.sizeFromShape(v),"int32");for(let w=0;w<c;++w){const b=w*d,T=new Float32Array(d-1);T[0]=p[b];for(let U=1;U<T.length;++U)T[U]=T[U-1]+p[b+U];const N=Rut.alea(o.toString()),S=w*s;for(let U=0;U<s;++U){const J=N();x[S+U]=T.length;for(let ht=0;ht<T.length;ht++)if(J<T[ht]){x[S+U]=ht;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(v,"int32",x)}};function M3(t,n,e){const r=g.util.createScalarValue(-1,e);return QI([],n,r,t,e)}const hft={kernelName:g.Neg,backendName:"cpu",kernelFunc:function cft(t){const{inputs:n,backend:e}=t,{x:r}=n;ar(r,"neg");const i=e.data.get(r.dataId).values,[s,o]=M3(i,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,s)}},dft=g.kernel_impls.nonMaxSuppressionV3Impl,pft={kernelName:g.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function fft(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=r;ar(i,"NonMaxSuppression");const c=e.data.get(i.dataId).values,d=e.data.get(s.dataId).values,{selectedIndices:p}=dft(c,d,o,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}},mft=g.kernel_impls.nonMaxSuppressionV4Impl,yft={kernelName:g.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function gft(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r;ar(i,"NonMaxSuppressionPadded");const d=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:v,validOutputs:x}=mft(d,p,o,a,u,c);return[e.makeTensorInfo([v.length],"int32",new Int32Array(v)),e.makeTensorInfo([],"int32",new Int32Array([x]))]}},vft=g.kernel_impls.nonMaxSuppressionV5Impl,xft={kernelName:g.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function _ft(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r;ar(i,"NonMaxSuppressionWithScore");const d=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,v=o,x=a,w=u,b=c,{selectedIndices:T,selectedScores:N}=vft(d,p,v,x,w,b);return[e.makeTensorInfo([T.length],"int32",new Int32Array(T)),e.makeTensorInfo([N.length],"float32",new Float32Array(N))]}},P3=Ma((t,n)=>t!==n?1:0),Eft=eu(g.NotEqual,P3,null,"bool"),Cft={kernelName:g.NotEqual,backendName:"cpu",kernelFunc:Eft},bft={kernelName:g.OneHot,backendName:"cpu",kernelFunc:function wft(t){const{inputs:n,backend:e,attrs:r}=t,{indices:i}=n,{dtype:s,depth:o,onValue:a,offValue:u}=r;ar(i,"oneHot");const c=g.util.sizeFromShape(i.shape),d=new Float32Array(c*o);d.fill(u);const p=e.data.get(i.dataId).values;for(let v=0;v<c;++v)p[v]>=0&&p[v]<o&&(d[v*o+p[v]]=a);return e.makeTensorInfo([...i.shape,o],s,d)}};function i1(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const i=Zd({inputs:{input:r},backend:e}),s=i1({inputs:{x:i},backend:e}),o=Lp({inputs:{input:r},backend:e}),a=i1({inputs:{x:o},backend:e}),u=wl({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return rS({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Ift={kernelName:g.ZerosLike,backendName:"cpu",kernelFunc:i1},Sft={kernelName:g.OnesLike,backendName:"cpu",kernelFunc:function O3(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const i=Zd({inputs:{input:r},backend:e}),s=O3({inputs:{x:i},backend:e}),o=Lp({inputs:{input:r},backend:e}),a=i1({inputs:{x:o},backend:e}),u=wl({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return rS({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function R3(t){const{inputs:n,backend:e,attrs:r}=t,{axis:i}=r;if(1===n.length)return r1({inputs:{input:n[0]},backend:e,attrs:{dim:i}});const s=n[0].shape,o=n[0].dtype;n.forEach(d=>{g.util.assertShapesMatch(s,d.shape,"All tensors passed to stack must have matching shapes"),g.util.assert(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=kp({inputs:n.map(d=>{const p=r1({inputs:{input:d},backend:e,attrs:{dim:i}});return a.push(p),p}),backend:e,attrs:{axis:i}});return a.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}const Dft={kernelName:g.Pack,backendName:"cpu",kernelFunc:R3},L3={kernelName:g.PadV2,backendName:"cpu",kernelFunc:function Tft(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{paddings:s,constantValue:o}=r;ar(i,"pad");const a=s.map((S,U)=>S[0]+i.shape[U]+S[1]),u=s.map(S=>S[0]),c=e.data.get(i.dataId).values,d=g.util.sizeFromShape(i.shape),p=i.shape.length,v=g.util.computeStrides(i.shape),x=g.util.sizeFromShape(a),w=a.length,b=g.util.computeStrides(a),T=g.util.getTypedArrayFromDType(i.dtype,x);0!==o&&T.fill(o);for(let S=0;S<d;S++){const J=g.util.indexToLoc(S,p,v).map((Tt,Pt)=>Tt+u[Pt]);T[g.util.locToIndex(J,w,b)]=c[S]}return{dataId:e.write(T,a,i.dtype),shape:a,dtype:i.dtype}}},Nft=Ma((t,n)=>Math.pow(t,n)),Aft=eu(g.Pow,Nft),Mft={kernelName:g.Pow,backendName:"cpu",kernelFunc:Aft};function k3(t,n,e,r){const[i,s]=g.backend_util.computeOutAndReduceShapes(t,r),o=(0,g.upcastType)(n,"int32"),a=g.util.makeZerosTypedArray(g.util.sizeFromShape(i),o),u=g.util.sizeFromShape(s);for(let c=0;c<a.length;++c){const d=c*u;let p=1;for(let v=0;v<u;++v)p*=e[d+v];a[c]=p}return{outVals:a,outShape:i,outDtype:o}}const Oft={kernelName:g.Prod,backendName:"cpu",kernelFunc:function Pft(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;ar(i,"prod");const a=i.shape.length,u=g.util.parseAxisParam(s,i.shape),c=g.backend_util.getAxesPermutation(u,a);let d=u,p=i;const v=[];null!=c&&(p=fl({inputs:{x:i},backend:e,attrs:{perm:c}}),v.push(p),d=g.backend_util.getInnerMostAxes(d.length,a));const x=e.data.get(p.dataId).values,{outVals:w,outShape:b,outDtype:T}=k3(p.shape,p.dtype,x,d);let N=b;return o&&(N=g.backend_util.expandShapeToKeepDim(b,u)),v.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(N,T,w)}};function F3(t,n){const e=t.slice(0,n);for(;e.length<n;)e.push(1);for(let r=n;r<t.length;r++)e[n-1]*=t[r];return e}function $3(t,n,e,r,i,s,o,a){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw new Error("Split tensors must not be scalars");if(function Rft(t,n,e){t.forEach((r,i)=>{if(r<0||r>=e){const s=g.util.indexToLoc(i,n.length,g.util.computeStrides(n)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${e})`)}})}(s,o,n[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:d,valueSlices:p,numValues:v}=function kft(t,n,e,r){const i=[];let s=0;const a=new Array(n.length-1+e.length).fill(null).map(()=>[0]);!function Lft(t,n){for(let e=0;e<t.length;++e){const r=t[e],i=e===t.length-1?n:t[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let u=1;for(let c=0;c<n.length-1;++c){u*=n[c];const d=n[c+1];for(let p=1;p<u+1;++p)a[c].push(p*d)}for(let c=0;c<t.length;++c){let d=t[c],p=t[c]+1;for(let v=0;v<e.length;++v){const x=e[v],w=v+n.length-1;if(w>=0){const b=a[w],T=b[b.length-1]-x[d];for(let N=d;N<p;++N)a[w].push(x[N+1]+T)}d=x[d],p=x[p]}p!==d&&(i.push([d,p]),s+=p-d)}return{outSplits:a,valueSlices:i,numValues:s}}(s,o,t,c),x=function Fft(t){const n=[];for(let e=0;e<t.length;++e){const i=g.util.getArrayFromDType("int32",t[e].length);n.push(i),t[e].forEach((s,o)=>i[o]=s)}return n}(d),w=function Bft(t,n,e,r,i){const s=n.slice();s[0]=i;const o=g.util.getArrayFromDType(e,g.util.sizeFromShape(s)),a=t.length;return function $ft(t,n,e,r,i,s){const o=F3(n,2)[1],a=F3(s,2)[1];let u=0;for(const c of e)for(let d=c[0];d<c[1];++d){for(let p=0;p<r;++p)i[u*a+p]=t[d*o+p];++u}}(t,n,r,0===a?0:a/n[0],o,s),[o,s]}(e,r,i,p,v);return[x,w[0],w[1]]}const Vft={kernelName:g.RaggedGather,backendName:"cpu",kernelFunc:function zft(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:o}=n,u=i.map(N=>e.data.get(N.dataId).values),c=i.map(N=>N.shape),d=e.data.get(s.dataId).values,p=e.data.get(o.dataId).values,[v,x,w]=$3(u,c,d,s.shape,s.dtype,p,o.shape),b=v.map(N=>e.makeTensorInfo([N.length],"int32",N)),T=e.makeTensorInfo(w,s.dtype,x);return b.concat([T])}},B3=2147483647;function z3(t,n,e,r,i,s,o){if(n.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===n.length,u=0===i.length,c=0===o.length,d=[];a||d.push(n[0]),u||d.push(i[0]),c||d.push(o[0]);for(let T=1;T<d.length;++T)if(d[T]!==d[T-1])throw new Error("starts, limits, and deltas must have the same shape");const p=0===d.length?1:d[0],v=g.util.getArrayFromDType("int32",p+1);v[0]=0;for(let T=0;T<p;++T){const N=a?t[0]:t[T],S=u?r[0]:r[T],U=c?s[0]:s[T];if(0===U)throw new Error("Requires delta != 0");let J;if(U>0&&S<N||U<0&&S>N)J=0;else if(J=Math.ceil(Math.abs((S-N)/U)),J>B3)throw new Error(`Requires ((limit - start) / delta) <= ${B3}`);v[T+1]=v[T]+J}const w=g.util.getArrayFromDType(e,v[p]);let b=0;for(let T=0;T<p;++T){const N=v[T+1]-v[T];let S=a?t[0]:t[T];const U=c?s[0]:s[T];for(let J=0;J<N;++J)w[b++]=S,S+=U}return[v,w]}const Wft={kernelName:g.RaggedRange,backendName:"cpu",kernelFunc:function Uft(t){const{inputs:n,backend:e}=t,{starts:r,limits:i,deltas:s}=n,o=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(s.dataId).values,[c,d]=z3(o,r.shape,r.dtype,a,i.shape,u,s.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([d.length],r.dtype,d)]}};var dc=g.backend_util.RowPartitionType;class s1{constructor(n,e,r,i,s,o,a,u,c,d){this.shape=n,this.shapeShape=e,this.values=r,this.valuesShape=i,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=g.backend_util.getRowPartitionTypesHelper(d),this.raggedRank=g.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===dc.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===dc.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){const e=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case dc.VALUE_ROWIDS:return s1.getMaxWidthValueRowID(e);case dc.ROW_SPLITS:return s1.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${dc[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){const e=n.length;if(0===e||1===e)return 0;let r=0;for(let i=0;i<e-1;++i){const s=n[i+1]-n[i];s>r&&(r=s)}return r}static getMaxWidthValueRowID(n){const e=n.length;if(0===e)return 0;let r=0,i=n[0],s=0;for(let o=1;o<e;++o){const a=n[o];a!==i&&(i=a,s=Math.max(o-r,s),r=o)}return Math.max(e-r,s)}tensorShapeFromTensor(n,e,r=!0){if(0===e.length){if(-1===n[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return U3(n,r)}calculateOutputSize(n){const e=this.valuesShape;g.backend_util.validateDefaultValueShape(this.defaultValueShape,e);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=g.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,i,e);o[0]<0&&(o[0]=n);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(n,e,r){const i=Math.min(n,r),s=[];let o=0;for(let a=0;a<i;++a,o+=e)s.push(o);for(let a=i;a<n;++a)s.push(-1);return g.util.assert(s.length===n,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(n,e,r,i){const s=n.length,o=[];for(let a=0;a<s-1;++a){const u=n[a+1]-n[a];let c=Math.min(i,u),d=e[a];-1===d&&(c=0);for(let p=0;p<c;++p)o.push(d),d+=r;for(let p=0;p<u-c;++p)o.push(-1)}if(s>0&&o.length!==n[s-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(n,e,r,i){const s=n.length,o=[];if(0===s)return[];let a=0,u=n[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let c=e[u];o.push(c);for(let d=1;d<s;++d){const p=n[d];if(p===u)c>=0&&(++a,a<i?c+=r:c=-1);else{if(a=0,u=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);c=e[p]}o.push(c)}if(o.length!==n.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(n,e,r,i){const s=this.getRowPartitionTensor(n),o=this.getRowPartitionTypeByDimension(n);switch(o){case dc.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,r,i);case dc.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,r,i);default:throw new Error(`Unsupported partition type: ${dc[o]}`)}}getFirstDimensionSize(){const n=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case dc.FIRST_DIM_SIZE:return n[0];case dc.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case dc.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${dc[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let u=i.length-2;u>=0;--u)i[u]=i[u+1]*r[u+1];const s=U3(r,!1),o=g.util.getArrayFromDType(this.valuesDType,g.util.sizeFromShape(s));if(i[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(e,i[0],r[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,i[c],r[c]);this.setOutput(this.raggedRank,u,o,s)}return[s,o]}setOutput(n,e,r,i){if(0===r.length)return;const s=this.values,o=r;let a=i.slice();a=a.slice(n+1);const u=g.util.sizeFromShape(a),c=e.length;let d=this.defaultValue;if(d.length!==u&&1!==d.length){const w=this.defaultValueShape;(0,g.tidy)(()=>{const b=(0,g.reshape)(d,w);d=(0,g.broadcastTo)(b,a).dataSync()})}let p=0,v=0,x=0;for(let w=0;w<=c;++w){let b=w<c?e[w]:-1;if(b!==x){if(v<x){const T=s.subarray(p*u);V3(o.subarray(v*u),T,(x-v)*u)}if(w>=c&&(b=Math.floor(r.length/u)),b>x)if(1===this.defaultValue.length)o.subarray(x*u,b*u).fill(this.defaultValue[0]),x=b;else for(;b>x;)V3(o.slice(x*u),d,u),++x;b<0?(p=w+1,v=x):(p=w,v=x,x=v+1)}else++x}}}function V3(t,n,e){for(let r=0;r<e;r++)t[r]=n[r]}function U3(t,n){const e=[];for(let r of t){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function W3(t,n,e,r,i,s,o,a,u,c){return new s1(t,n,e,r,i,s,o,a,u,c).compute()}const Hft={kernelName:g.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function Gft(t){const{inputs:n,backend:e,attrs:r}=t,{shape:i,values:s,defaultValue:o,rowPartitionTensors:a}=n,{rowPartitionTypes:u}=r,c=e.data.get(i.dataId).values,d=e.data.get(s.dataId).values,p=e.data.get(o.dataId).values,v=a.map(T=>e.data.get(T.dataId).values),x=a.map(T=>T.shape),[w,b]=W3(c,i.shape,d,s.shape,s.dtype,p,o.shape,v,x,u);return e.makeTensorInfo(w,s.dtype,b)}};function G3(t,n,e,r){if(t===n||t<n&&e<0||n<t&&e>1)return g.util.makeZerosTypedArray(0,r);const a=Math.abs(Math.ceil((n-t)/e)),u=g.util.makeZerosTypedArray(a,r);n<t&&1===e&&(e=-1),u[0]=t;for(let c=1;c<u.length;c++)u[c]=u[c-1]+e;return u}const Kft={kernelName:g.Range,backendName:"cpu",kernelFunc:function jft(t){const{backend:n,attrs:e}=t,{start:r,stop:i,dtype:s,step:o}=e,a=G3(r,i,o,s);return n.makeTensorInfo([a.length],s,a)}},Xft=Js(g.Reciprocal,t=>1/t),Zft={kernelName:g.Reciprocal,backendName:"cpu",kernelFunc:Xft},qft={kernelName:g.ResizeBilinear,backendName:"cpu",kernelFunc:function Yft(t){const{inputs:n,backend:e,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:o,size:a}=r;ar(i,"resizeBilinear");const u=g.util.computeStrides(i.shape),[c,d]=a,[p,v,x,w]=i.shape,b=e.data.get(i.dataId).values,T=new Float32Array(g.util.sizeFromShape([p,c,d,w])),N=[s&&c>1?v-1:v,s&&d>1?x-1:x],S=[s&&c>1?c-1:c,s&&d>1?d-1:d];let U=0;const J=N[0]/S[0],ht=N[1]/S[1];for(let Tt=0;Tt<p;Tt++)for(let Pt=0;Pt<c;Pt++){let zt;zt=o?J*(Pt+.5)-.5:J*Pt;const Ot=Math.max(0,Math.floor(zt)),le=zt-Ot,ge=Math.min(v-1,Math.ceil(zt)),Ae=Tt*u[0]+Ot*u[1],Re=Tt*u[0]+ge*u[1];for(let ve=0;ve<d;ve++){let Ne;Ne=o?ht*(ve+.5)-.5:ht*ve;const Se=Math.max(0,Math.floor(Ne)),Ke=Ne-Se,Le=Math.min(x-1,Math.ceil(Ne)),Be=Ae+Se*u[2],on=Re+Se*u[2],rn=Ae+Le*u[2],pn=Re+Le*u[2];for(let Qe=0;Qe<w;Qe++){const gn=b[Be+Qe],dn=b[on+Qe],Cr=gn+(b[rn+Qe]-gn)*Ke;T[U++]=Cr+(dn+(b[pn+Qe]-dn)*Ke-Cr)*le}}}return e.makeTensorInfo([p,c,d,w],"float32",T)}},Jft={kernelName:g.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function Qft(t){const{inputs:n,backend:e,attrs:r}=t,{images:i,dy:s}=n,{alignCorners:o}=r;ar([s,i],"resizeBilinearGrad");const a=g.util.computeStrides(i.shape),[u,c,d,p]=i.shape,[,v,x]=s.shape,w=new Float32Array(u*c*d*p),b=[o&&v>1?c-1:c,o&&x>1?d-1:d],T=[o&&v>1?v-1:v,o&&x>1?x-1:x],N=b[0]/T[0],S=b[1]/T[1],U=e.data.get(s.dataId).values;let J=0;for(let ht=0;ht<u;ht++){const Tt=ht*a[0];for(let Pt=0;Pt<v;Pt++){const zt=Pt*N,Ot=Math.floor(zt),le=Math.min(Math.ceil(zt),c-1),ge=Tt+Ot*a[1],Ae=Tt+le*a[1],Re=zt-Ot,ve=1-Re;for(let Ne=0;Ne<x;Ne++){const Se=Ne*S,Ke=Math.floor(Se),Le=Math.min(Math.ceil(Se),d-1),Be=Se-Ke,on=1-Be,rn=ge+Ke*a[2],pn=ge+Le*a[2],Qe=Ae+Ke*a[2],gn=Ae+Le*a[2],dn=ve*on,kn=ve*Be,ir=Re*on,Cr=Re*Be;for(let yr=0;yr<p;yr++){const Hr=U[J++];w[rn+yr]+=Hr*dn,w[pn+yr]+=Hr*kn,w[Qe+yr]+=Hr*ir,w[gn+yr]+=Hr*Cr}}}}return e.makeTensorInfo([u,d,c,p],"float32",w)}},ept={kernelName:g.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function tpt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:o,size:a}=r;ar(i,"resizeNearestNeighbor");const u=g.util.computeStrides(i.shape),[c,d]=a,[p,v,x,w]=i.shape,b=e.data.get(i.dataId).values,T=new Float32Array(p*c*d*w),N=[s&&c>1?v-1:v,s&&d>1?x-1:x],S=[s&&c>1?c-1:c,s&&d>1?d-1:d],U=N[0]/S[0],J=N[1]/S[1];let ht=0;for(let Tt=0;Tt<p;Tt++){const Pt=Tt*u[0];for(let zt=0;zt<c;zt++){const Ot=o?U*(zt+.5):U*zt;let le=Math.min(v-1,s?Math.round(Ot):Math.floor(Ot));o&&(le=Math.max(0,le));const ge=Pt+le*u[1];for(let Ae=0;Ae<d;Ae++){const Re=o?J*(Ae+.5):J*Ae;let ve=Math.min(x-1,s?Math.round(Re):Math.floor(Re));o&&(ve=Math.max(0,ve));const Ne=ge+ve*u[2];for(let Se=0;Se<w;Se++)T[ht++]=b[Ne+Se]}}}return e.makeTensorInfo([p,c,d,w],i.dtype,T)}},rpt={kernelName:g.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function npt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i,dy:s}=n,{alignCorners:o}=r;ar([s,i],"resizeNearestNeighborGrad");const a=g.util.computeStrides(i.shape),u=g.util.computeStrides(s.shape),[c,d,p,v]=i.shape,[,x,w]=s.shape,b=new Float32Array(c*d*p*v),T=e.data.get(s.dataId).values,N=[o&&x>1?d-1:d,o&&w>1?p-1:p],S=[o&&x>1?x-1:x,o&&w>1?w-1:w],U=N[0]/S[0],J=N[1]/S[1],ht=1/U,Tt=1/J,Pt=2*Math.ceil(ht)+2,zt=2*Math.ceil(Tt)+2;for(let Ot=0;Ot<c;Ot++){const le=Ot*a[0];for(let ge=0;ge<d;ge++){const Ae=le+ge*a[1],Re=Math.floor(ge*ht),ve=Math.floor(Re-Pt/2);for(let Ne=0;Ne<p;Ne++){const Se=Ae+Ne*a[2],Ke=Math.floor(Ne*Tt),Le=Math.floor(Ke-zt/2);for(let Be=0;Be<v;Be++){let on=0;for(let rn=0;rn<Pt;rn++){const pn=rn+ve;if(pn<0||pn>=x)continue;const Qe=le+pn*u[1],gn=pn*U;if(ge===Math.min(d-1,o?Math.round(gn):Math.floor(gn)))for(let kn=0;kn<zt;kn++){const ir=kn+Le;if(ir<0||ir>=w)continue;const Cr=Qe+ir*u[2],yr=ir*J;Ne===Math.min(p-1,o?Math.round(yr):Math.floor(yr))&&(on+=T[Cr+Be])}}b[Se+Be]=on}}}}return e.makeTensorInfo(i.shape,i.dtype,b)}},spt={kernelName:g.Reverse,backendName:"cpu",kernelFunc:function ipt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{dims:s}=r;ar(i,"reverse");const o=i.shape.length,a=g.util.parseAxisParam(s,i.shape);if(0===o)return sh({inputs:{x:i},backend:e});const u=new g.TensorBuffer(i.shape,i.dtype),c=e.bufferSync(i);for(let d=0;d<u.size;d++){const p=u.indexToLoc(d),v=p.slice();a.forEach(x=>v[x]=i.shape[x]-1-v[x]),u.set(c.get(...v),...p)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}},opt={kernelName:g.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:i,fillValue:s,center:o}=n,a=e,u=g.util.getTypedArrayFromDType(r.dtype,g.util.sizeFromShape(r.shape)),[c,d,p,v]=r.shape,[x,w]=g.backend_util.getImageCenter(o,d,p),T=Math.sin(i),N=Math.cos(i),S=a.data.get(r.dataId).values;for(let J=0;J<c;J++){const ht=J*p*d*v;for(let Tt=0;Tt<d;Tt++){const Pt=Tt*(p*v);for(let zt=0;zt<p;zt++){const Ot=zt*v;for(let le=0;le<v;le++){const ge=[c,Tt,zt,le],Ae=ge[2],Re=ge[1];let ve=(Ae-x)*N-(Re-w)*T,Ne=(Ae-x)*T+(Re-w)*N;ve=Math.round(ve+x),Ne=Math.round(Ne+w);let Se=s;"number"!=typeof s&&(Se=3===le?255:s[le]),ve>=0&&ve<p&&Ne>=0&&Ne<d&&(Se=S[ht+Ne*(p*v)+ve*v+le]),u[ht+Pt+Ot+le]=Se}}}}return{dataId:a.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},apt=Js(g.Round,t=>{const n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2==0?n:n+1}),upt={kernelName:g.Round,backendName:"cpu",kernelFunc:apt},H3=ih(t=>1/Math.sqrt(t)),lpt=ud(g.Rsqrt,H3),cpt={kernelName:g.Rsqrt,backendName:"cpu",kernelFunc:lpt};function qd(t,n,e,r,i,s,o,a,u,c){const d=[r/i,i],p=t.values,v=n.values;if(0===r)return(0,g.buffer)(e,n.dtype);const x=u instanceof g.TensorBuffer?u:(0,g.buffer)(d,n.dtype);"string"==typeof u||"number"==typeof u?x.values.fill(u):"boolean"==typeof u&&x.values.fill(+u);for(let w=0;w<s;w++){const b=[];let T=0;for(let N=0;N<o;N++){const S=p[w*o+N];b.push(S),T+=S*a[N]}if(T<0||T>=r/i)throw new Error(`Invalid indices: ${b} does not index into ${e}`);for(let N=0;N<i;N++)c?x.values[T*i+N]+=v[w*i+N]:x.values[T*i+N]=0===n.rank?v[0]:v[w*i+N]}return x}const dpt={kernelName:g.ScatterNd,backendName:"cpu",kernelFunc:function hpt(t){const{inputs:n,backend:e,attrs:r}=t,{indices:i,updates:s}=n,{shape:o}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=g.backend_util.calculateShapes(s,i,o),b=qd(e.bufferSync(i),e.bufferSync(s),o,p,c,u,a,d,0,!0);return e.makeTensorInfo(o,b.dtype,b.values)}};function fpt(t,n){let e=0,r=t.length,i=0;for(;e<r;)i=Math.floor((e+r)/2),t[i]<n?e=i+1:r=i;return r}function ppt(t,n){let e=0,r=t.length,i=0;for(;e<r;)i=Math.floor((e+r)/2),t[i]<=n?e=i+1:r=i;return r}const ypt={kernelName:g.SearchSorted,backendName:"cpu",kernelFunc:function gpt(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:i,values:s}=n,{side:o}=r,c=function mpt(t,n,e,r,i,s){const o=g.util.getArrayFromDType("int32",e*i);for(let a=0;a<e;++a){const u=t.slice(a*r,(a+1)*r),c=a*i;for(let d=0;d<i;++d)o[c+d]="left"===s?fpt(u,n[d+c]):ppt(u,n[d+c])}return o}(e.data.get(i.dataId).values,e.data.get(s.dataId).values,i.shape[0],i.shape[1],s.shape[1],o);return e.makeTensorInfo(s.shape,"int32",c)}},_pt={kernelName:g.Select,backendName:"cpu",kernelFunc:function vpt(t){const{inputs:n,backend:e}=t,{condition:r,t:i,e:s}=n;ar([r,i,s],"select");const o=r.shape.length,a=e.data.get(r.dataId).values,u=e.data.get(i.dataId).values,c=e.data.get(s.dataId).values,d=(0,g.upcastType)(i.dtype,s.dtype),p=g.util.makeZerosTypedArray(g.util.sizeFromShape(i.shape),d);let v=0;const x=0===o||o>1||1===i.shape.length?1:g.util.sizeFromShape(i.shape.slice(1));for(let w=0;w<a.length;w++)for(let b=0;b<x;b++)p[v++]=1===a[w]?u[w]:c[w];return e.makeTensorInfo(i.shape,d,p)}},xpt=g.backend_util.SELU_SCALEALPHA,Ept=g.backend_util.SELU_SCALE,Cpt=Js(g.Selu,t=>t>=0?Ept*t:xpt*(Math.exp(t)-1)),wpt={kernelName:g.Selu,backendName:"cpu",kernelFunc:Cpt},bpt=Js(g.Sign,t=>t<0?-1:t>0?1:0),Ipt={kernelName:g.Sign,backendName:"cpu",kernelFunc:bpt},Spt=Js(g.Sin,t=>Math.sin(t)),Dpt={kernelName:g.Sin,backendName:"cpu",kernelFunc:Spt},Tpt=Js(g.Sinh,t=>Math.sinh(t)),Npt={kernelName:g.Sinh,backendName:"cpu",kernelFunc:Tpt},j3=Math.log(1.1920928955078125e-7)+2,Apt=Js(g.Softplus,t=>{const n=t>-j3,e=t<j3,r=Math.exp(t);let i;return i=e?r:n?t:Math.log(1+r),i}),Mpt={kernelName:g.Softplus,backendName:"cpu",kernelFunc:Apt},Opt={kernelName:g.SpaceToBatchND,backendName:"cpu",kernelFunc:function Ppt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockShape:s,paddings:o}=r;ar([i],"spaceToBatchND");const a=g.util.sizeFromShape(s),u=[[0,0]];u.push(...o);for(let Tt=1+s.length;Tt<i.shape.length;++Tt)u.push([0,0]);const c=L3.kernelFunc({inputs:{x:i},backend:e,attrs:{paddings:u,constantValue:0}}),d=g.backend_util.getReshaped(c.shape,s,a,!1),p=g.backend_util.getPermuted(d.length,s.length,!1),v=g.backend_util.getReshapedPermuted(c.shape,s,a,!1),b=Ao({inputs:{x:c},backend:e,attrs:{shape:d}}),S=fl({inputs:{x:b},backend:e,attrs:{perm:p}}),ht=Ao({inputs:{x:S},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(S),ht}};function K3(t,n,e,r,i,s,o){const a=n[0],u=s[0],c=new Array(u),d=new Array(a),p=n[1];if(0===u){if(0!==a)throw new Error(g.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));return[g.util.getArrayFromDType(e,0),[0,p],g.util.getArrayFromDType(i,0),c,d]}let v=!0,x=0;const w=new Array(u).fill(0);for(let T=0;T<a;++T){const N=t[T*p];if(N<0)throw new Error(g.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(T,N));if(N>=u)throw new Error(g.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T,N,u));++w[N],v=v&&N>=x,x=N}let b=!0;for(let T=0;T<u;++T){const N=0===w[T];c[T]=N,b=b&&!N,w[T]=Math.max(w[T],1),T>0&&(w[T]+=w[T-1])}if(b&&v){const T=t,N=r;for(let S=0;S<a;++S)d[S]=S;return[T,[a,p],N,c,d]}{const T=w[u-1],N=g.util.getArrayFromDType(e,T*p),S=g.util.getArrayFromDType(i,T),U=new Array(u).fill(0);for(let J=0;J<a;++J){const ht=t[J*p],Pt=(0===ht?0:w[ht-1])+U[ht];U[ht]++;for(let zt=0;zt<p;++zt)N[Pt*p+zt]=t[J*p+zt];S[Pt]=r[J],d[J]=Pt}for(let J=0;J<u;++J)if(0===U[J]){const Tt=0===J?0:w[J-1];N[Tt*p+0]=J;for(let Pt=1;Pt<p;++Pt)N[Tt*p+Pt]=0;S[Tt]=o}return[N,[T,p],S,c,d]}}const Lpt={kernelName:g.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function Rpt(t){const{inputs:n,backend:e}=t,{indices:r,values:i,denseShape:s,defaultValue:o}=n;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n        ${i.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(r.dataId).values,u=e.data.get(i.dataId).values,c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values[0],[p,v,x,w,b]=K3(a,r.shape,r.dtype,u,i.dtype,c,d);return[e.makeTensorInfo(v,r.dtype,p),e.makeTensorInfo([v[0]],i.dtype,x),e.makeTensorInfo([w.length],"bool",new Uint8Array(w.map(T=>Number(T)))),e.makeTensorInfo([b.length],r.dtype,new Int32Array(b))]}};function X3(t,n,e,r,i){const s=g.util.sizeFromShape(r),o=n[0],a=i.length,u=[];let c=1,d=-1;for(let T=0;T<a;++T){const N=i[T];if(-1===N){if(-1!==d)throw new Error(g.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,T));d=T,u.push(1)}else{if(N<0)throw new Error(g.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(T,N));c*=N,u.push(N)}}if(-1!==d){if(c<=0)throw new Error(g.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const T=Math.trunc(s/c);if(c*T!==s)throw new Error(g.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(r,u));u[d]=T}if(g.util.sizeFromShape(u)!==s)throw new Error(g.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(r,u));const v=r.length,x=[];if(v>0){x[v-1]=1;for(let T=v-2;T>=0;--T)x[T]=x[T+1]*r[T+1]}const w=[];if(a>0){w[a-1]=1;for(let T=a-2;T>=0;--T)w[T]=w[T+1]*u[T+1]}const b=g.util.getArrayFromDType(e,o*a);for(let T=0;T<o;++T){let N=0;for(let S=0;S<v;++S)N+=t[T*v+S]*x[S];for(let S=0;S<a;++S)b[T*a+S]=Math.trunc(N/w[S]),N%=w[S]}return[b,[o,a],u]}const Fpt={kernelName:g.SparseReshape,backendName:"cpu",kernelFunc:function kpt(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:i,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(e.data.get(i.dataId).values),a=e.data.get(r.dataId).values,u=Array.from(e.data.get(s.dataId).values),[c,d,p]=X3(a,r.shape,r.dtype,o,u);return[e.makeTensorInfo(d,r.dtype,c),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}};function iS(t,n,e,r,i,s=!1,o=0){const a=r.length,u=[n[0],t.length/n[0]],c=u[1],p=a>0?i[a-1]+1:0;if(p<0)throw new Error(g.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const v=n.slice();v[0]=p;const x=v.reduce((U,J)=>U*J,1),w=g.util.getArrayFromDType(e,x);if(0===a)return p>0&&w.fill(o),[w,v];if(p<=0)throw new Error(g.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let b=0,T=1,N=0,S=i[b];for(;;){let U=0;if(T<a){if(U=i[T],S===U){++T;continue}if(S>=U)throw new Error(g.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(S<0||S>=p)throw new Error(g.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(S,p));S>N&&w.fill(o,N*c,S*c);for(let J=b;J<T;++J){const ht=r[J];if(ht<0||ht>=u[0])throw new Error(g.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(J,r[J],u[0]));for(let Tt=0;Tt<c;Tt++)w[S*c+Tt]+=t[ht*c+Tt]}if(s)for(let J=0;J<c;J++)w[S*c+J]/=T-b;if(b=T,++T,N=S+1,S=U,T>a)break}return N<p&&w.fill(o,N*c,p*c),[w,v]}const Bpt={kernelName:g.SparseSegmentMean,backendName:"cpu",kernelFunc:function $pt(t){const{inputs:n,backend:e}=t,{data:r,indices:i,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(s.dataId).values,[c,d]=iS(o,r.shape,r.dtype,a,u,!0);return e.makeTensorInfo(d,r.dtype,c)}},Vpt={kernelName:g.SparseSegmentSum,backendName:"cpu",kernelFunc:function zpt(t){const{inputs:n,backend:e}=t,{data:r,indices:i,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(s.dataId).values,[c,d]=iS(o,r.shape,r.dtype,a,u);return e.makeTensorInfo(d,r.dtype,c)}},Wpt={kernelName:g.SparseToDense,backendName:"cpu",kernelFunc:function Upt(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:o}=n,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:v}=g.backend_util.calculateShapes(s,i,a),x=!1,w=e.bufferSync(i);let b;switch(s.dtype){case"bool":b=qd(w,e.bufferSync(s),a,v,d,c,u,p,!!e.data.get(o.dataId).values[0],x);break;case"float32":case"int32":b=qd(w,e.bufferSync(s),a,v,d,c,u,p,e.data.get(o.dataId).values[0],x);break;case"string":b=qd(w,e.bufferSync(s),a,v,d,c,u,p,g.util.decodeString(e.data.get(o.dataId).values[0]),x);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,b.dtype,b.values)}},Hpt={kernelName:g.SplitV,backendName:"cpu",kernelFunc:function Gpt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{numOrSizeSplits:s,axis:o}=r,a=g.util.parseAxisParam(o,i.shape)[0],u=g.backend_util.prepareSplitSize(i,s,a),c=new Array(i.shape.length).fill(0),d=i.shape.slice();return u.map(p=>{const v=[...d];v[a]=p;const x=Yd({inputs:{x:i},backend:e,attrs:{begin:c,size:v}});return c[a]+=p,x})}},jpt=ih(t=>Math.sqrt(t)),Kpt=Js(g.Sqrt,t=>Math.sqrt(t)),Xpt={kernelName:g.Sqrt,backendName:"cpu",kernelFunc:Kpt},Zpt={kernelName:g.Square,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t,r=n;ar(e,"square");const i=r.data.get(e.dataId).values,s=new Float32Array(i.length);for(let a=0;a<i.length;++a){const u=i[a];s[a]=u*u}return{dataId:r.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},Ypt=Ma((t,n)=>{const e=t-n;return e*e}),qpt=eu(g.SquaredDifference,Ypt),Qpt={kernelName:g.SquaredDifference,backendName:"cpu",kernelFunc:qpt},Z3=ih((t,n)=>{const{pattern:e,replaceGlobal:r,rewrite:i}=n;return t.replace(new RegExp(e,r?"g":""),i)}),Jpt=ud(g.StaticRegexReplace,Z3),tmt={kernelName:g.StaticRegexReplace,backendName:"cpu",kernelFunc:Jpt},emt=Js(g.Step,(t,n)=>{const e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),nmt={kernelName:g.Step,backendName:"cpu",kernelFunc:emt};function Y3(t,n,e,r){const i=(0,g.buffer)(t,n.dtype);for(let s=0;s<i.size;s++){const o=i.indexToLoc(s),a=new Array(o.length);for(let u=0;u<a.length;u++)a[u]=o[u]*e[u]+r[u];i.set(n.get(...a),...o)}return i}const imt={kernelName:g.StridedSlice,backendName:"cpu",kernelFunc:function rmt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{begin:s,end:o,strides:a,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:v}=r;ar(i,"stridedSlice");const{finalShapeSparse:x,finalShape:w,isIdentity:b,sliceDim0:T,isSimpleSlice:N,begin:S,end:U,strides:J}=g.slice_util.sliceInfo(i.shape,s,o,a,u,c,d,p,v);let ht;if(b)ht=Ao({inputs:{x:i},backend:e,attrs:{shape:w}});else if(T||N){g.util.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const Tt=g.slice_util.computeOutShape(S,U,J),Pt=Yd({inputs:{x:i},backend:e,attrs:{begin:S,size:Tt}});ht=Ao({inputs:{x:Pt},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(Pt)}else{const Pt=Y3(x,e.bufferSync(i),J,S);ht=e.makeTensorInfo(w,Pt.dtype,Pt.values)}return ht}};class smt{constructor(n,e,r,i,s,o){this.separator=g.util.encodeString(n),this.nGramWidths=e,this.leftPad=g.util.encodeString(r),this.rightPad=g.util.encodeString(i),this.padWidth=s,this.preserveShort=o}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,e){const r=this.getPadWidth(e);return Math.max(0,n+2*r-e+1)}createNGrams(n,e,r,i,s,o){for(let a=0;a<s;++a){const u=this.getPadWidth(o),c=Math.max(0,u-a),d=Math.max(0,u-(s-(a+1))),p=o-(c+d),v=e+(c>0?0:a-u);let x=0;x+=c*this.leftPad.length;for(let S=0;S<p;++S)x+=n[v+S].length;x+=d*this.rightPad.length,x+=(c+d+p-1)*this.separator.length,r[i+a]=new Uint8Array(x);const b=r[i+a];let T=0;const N=S=>S.forEach(U=>b[T++]=U);for(let S=0;S<c;++S)N(this.leftPad),N(this.separator);for(let S=0;S<p-1;++S)N(n[v+S]),N(this.separator);if(p>0){N(n[v+p-1]);for(let S=0;S<d;++S)N(this.separator),N(this.rightPad)}else{for(let S=0;S<d-1;++S)N(this.rightPad),N(this.separator);N(this.rightPad)}}}compute(n,e){const r=n.length,i=e.length;if(i>0){let u=e[0];if(0!==u)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<i;++c){let d=e[c]>=u;if(d=d&&e[c]<=r,!d)throw new Error(`Invalid split value ${e[c]}, must be in [${u}, ${r}]`);u=e[c]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const s=i-1,o=g.util.getArrayFromDType("int32",i);if(0===r||0===i){const u=new Array(r);for(let c=0;c<=s;++c)o[c]=0;return[u,o]}o[0]=0;for(let u=1;u<=s;++u){const c=e[u]-e[u-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(c,p)}),this.preserveShort&&c>0&&0===d&&(d=1),o[u]=o[u-1]+d}const a=new Array(o[s]);for(let u=0;u<s;++u){const c=e[u];let d=o[u];if(this.nGramWidths.forEach(p=>{const x=this.getNumNGrams(e[u+1]-e[u],p);this.createNGrams(n,c,a,d,x,p),d+=x}),this.preserveShort&&d===o[u]){const p=e[u+1]-e[u];if(0===p)continue;this.createNGrams(n,c,a,d,1,p+2*this.padWidth)}}return[a,o]}}function q3(t,n,e,r,i,s,o,a){return new smt(e,r,i,s,o,a).compute(t,n)}const amt={kernelName:g.StringNGrams,backendName:"cpu",kernelFunc:function omt(t){const{inputs:n,backend:e,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:d,dataSplits:p}=n,v=e.data.get(d.dataId).values,x=e.data.get(p.dataId).values,[w,b]=q3(v,x,i,s,o,a,u,c);return[e.makeTensorInfo([w.length],"string",w),e.makeTensorInfo(p.shape,"int32",b)]}};function umt(t,n,e,r){if(!t.length)return;if(0===n.length){for(let s=0;s<t.length;++s)r.push(t.subarray(s,s+1));return}if(1===n.length){const s=n[0];let o=t.indexOf(s);for(;-1!==o;){const a=t.subarray(0,o);(!e||0!==a.length)&&r.push(a),o=(t=t.subarray(o+1)).indexOf(s)}return void((!e||0!==t.length)&&r.push(t))}let i=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==n.indexOf(t[s])){const o=t.subarray(i,s);(!e||0!==o.length)&&r.push(o),i=s+1}}function Q3(t,n,e){const r=t.length,i=[];let s=0,o=0;const a=new Array(r);for(let v=0;v<r;++v){const x=i.length;umt(t[v],n,e,i);const w=i.length-x;a[v]=w,s+=w,o=Math.max(o,w)}const u=g.util.getArrayFromDType("int32",2*s),c=new Array(s),d=[r,o];let p=0;for(let v=0;v<r;++v)for(let x=0;x<a[v];++x)u[2*p]=v,u[2*p+1]=x,c[p]=i[p],++p;return[u,c,d]}const cmt={kernelName:g.StringSplit,backendName:"cpu",kernelFunc:function lmt(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:o}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values[0],[c,d,p]=Q3(a,u,i),v=d.length;return[e.makeTensorInfo([v,2],"int32",c),e.makeTensorInfo([v],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}};function J3(t,n){const e=g.util.getArrayFromDType("int32",t.length);for(let r=0;r<t.length;++r)e[r]=g.util.fingerPrint64(t[r]).modulo(n).getLowBitsUnsigned();return e}const dmt={kernelName:g.StringToHashBucketFast,backendName:"cpu",kernelFunc:function hmt(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:i}=r,{input:s}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=J3(e.data.get(s.dataId).values,i);return e.makeTensorInfo(s.shape,"int32",a)}},fmt=Js(g.Tan,t=>Math.tan(t)),pmt={kernelName:g.Tan,backendName:"cpu",kernelFunc:fmt},mmt=Js(g.Tanh,t=>Math.tanh(t));function tz(t,n){const e=new Array(t.rank);for(let i=0;i<e.length;i++)e[i]=t.shape[i]*n[i];const r=(0,g.buffer)(e,t.dtype);for(let i=0;i<r.values.length;++i){const s=r.indexToLoc(i),o=new Array(t.rank);for(let u=0;u<o.length;u++)o[u]=s[u]%t.shape[u];const a=t.locToIndex(o);r.values[i]=t.values[a]}return r}const Zg=(t,n)=>{const e=n.value-t.value;return 0===e?t.index-n.index:e};function ez(t,n,e=0,r=t.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,u=n-e+1,c=Math.log(a),d=.5*Math.exp(2*c/3),p=.5*Math.sqrt(c*d*(a-d)/a)*Math.sign(u-a/2);ez(t,n,Math.max(e,Math.floor(n-u*d/a+p)),Math.min(r,Math.floor(n+(a-u)*d/a+p)))}const i=t[n];let s=e,o=r;for(g.util.swap(t,e,n),Zg(t[r],i)>0&&g.util.swap(t,e,r);s<o;){for(g.util.swap(t,s,o),s++,o--;Zg(t[s],i)<0;)s+=1;for(;Zg(t[o],i)>0;)o-=1}0===Zg(t[e],i)?g.util.swap(t,e,o):(o+=1,g.util.swap(t,o,r)),o<=n&&(e=o+1),n<=o&&(r=o-1)}}function nz(t,n,e,r,i){const s=n[n.length-1],[o,a]=[t.length/s,s],u=g.util.getTypedArrayFromDType(e,o*r),c=g.util.getTypedArrayFromDType("int32",o*r);for(let p=0;p<o;p++){const v=p*a,x=t.subarray(v,v+a);let w=new Array(x.length);x.forEach((S,U)=>w[U]={value:S,index:U}),r<w.length&&(ez(w,r),w=w.slice(0,r)),i&&w.sort(Zg);const b=p*r,T=u.subarray(b,b+r),N=c.subarray(b,b+r);for(let S=0;S<r;S++)T[S]=w[S].value,N[S]=w[S].index}const d=n.slice();return d[d.length-1]=r,[(0,g.buffer)(d,e,u),(0,g.buffer)(d,"int32",c)]}function rz(t,n,e){switch(e){case"reflect":return function Imt(t,n){let e=t;if(e<0)if(n<=1)e=0;else{const r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{const r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return g.util.clamp(0,e,n-1)}(t,n);case"wrap":return function Smt(t,n){let e=t;return e<0?n<=1?e=0:e+=n*(Math.trunc(-e/(n-1))+1):e>n-1&&(n<=1?e=0:e-=n*Math.trunc(e/(n-1))),g.util.clamp(0,e,n-1)}(t,n);case"nearest":return function Tmt(t,n){return g.util.clamp(0,t,n-1)}(t,n);default:return function Dmt(t,n){return t}(t)}}function Yg(t,n,e,r,i,s,o,a,u,c,d){return 0<=a&&a<n&&0<=u&&u<e?t[o*r+a*i+u*s+c]:d}function Nmt(t,n,e,r,i,s,o,a,u,c,d){return Yg(t,n,e,r,i,s,o,Math.round(a),Math.round(u),c,d)}function Amt(t,n,e,r,i,s,o,a,u,c,d){const p=Math.floor(a),v=Math.floor(u),x=p+1,w=v+1;return(x-a)*((w-u)*Yg(t,n,e,r,i,s,o,p,v,c,d)+(u-v)*Yg(t,n,e,r,i,s,o,p,w,c,d))+(a-p)*((w-u)*Yg(t,n,e,r,i,s,o,x,v,c,d)+(u-v)*Yg(t,n,e,r,i,s,o,x,w,c,d))}function iz(t,n,e,r){const i=g.util.parseAxisParam(n,e)[0],s=[1,e[0],1];for(let w=0;w<i;w++)s[0]*=e[w];s[1]=e[i];for(let w=i+1;w<e.length;w++)s[2]*=e[w];const o=new Map,a=new Int32Array(e[i]),u=new g.TensorBuffer(s,r,t),c=[],d=1===s[0]&&1===s[2];for(let w=0;w<e[i];w++){let b;if(d)b=t[w].toString();else{const N=[];for(let S=0;S<s[0];S++)for(let U=0;U<s[2];U++)N.push(u.get(S,w,U));b=N.join(",")}const T=o.get(b);if(null!=T)a[w]=T;else{const N=o.size;o.set(b,N),a[w]=N,c.push(w)}}const p=s.slice();p[1]=o.size;const v=new g.TensorBuffer(p,r);c.forEach((w,b)=>{for(let T=0;T<s[0];T++)for(let N=0;N<s[2];N++)v.set(u.get(T,w,N),T,b,N)});const x=e.slice();return x[i]=p[1],{outputValues:v.values,outputShape:x,indices:a}}const Fmt=[Dlt,Nlt,Mlt,Olt,wlt,Llt,$lt,zlt,Ult,Glt,jlt,Xlt,Ylt,Jlt,ect,ict,oct,uct,cct,Ilt,dct,mct,yct,_ct,Ect,Elt,wct,Ict,_lt,Dct,Nct,Act,Pct,Rct,kct,$ct,zct,Uct,Gct,jct,Xct,Yct,Qct,tht,eht,rht,sht,aht,uht,lht,cht,dht,yht,clt,_ht,xht,Tht,Nht,Aht,Pht,zht,Vht,Wht,Hht,Xht,Yht,Qht,tdt,ndt,idt,odt,hlt,udt,Tct,cdt,ddt,pdt,dlt,gdt,vdt,xdt,Cdt,bdt,Ddt,Ndt,Pdt,Rdt,kdt,Fdt,Bdt,Vdt,Wdt,Hdt,Kdt,Zdt,qdt,Jdt,eft,rft,oft,lft,pht,hft,pft,yft,xft,Cft,bft,Sft,Dft,L3,Mft,plt,Oft,Vft,Wft,Hft,Kft,xlt,tS,Zft,mlt,glt,blt,qft,Jft,ept,rpt,spt,opt,upt,cpt,dpt,ypt,_pt,wpt,vlt,Ipt,Dpt,Npt,fct,aft,Mpt,Opt,Lpt,Fpt,Bpt,Vpt,Wpt,Hpt,Xpt,Zpt,Qpt,tmt,nmt,imt,amt,cmt,dmt,Lht,mht,pmt,{kernelName:g.Tanh,backendName:"cpu",kernelFunc:mmt},{kernelName:g.TensorScatterUpdate,backendName:"cpu",kernelFunc:function ymt(t){const{inputs:n,backend:e}=t,{tensor:r,indices:i,updates:s}=n,{sliceRank:o,numUpdates:a,sliceSize:u,strides:c,outputSize:d}=g.backend_util.calculateShapes(s,i,r.shape),v=e.bufferSync(i),x=e.bufferSync(s),w=e.bufferSync(r),b=qd(v,x,r.shape,d,u,a,o,c,w,!1);return e.makeTensorInfo(r.shape,b.dtype,b.values)}},{kernelName:g.Tile,backendName:"cpu",kernelFunc:function _mt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{reps:s}=r;ar(i,"tile");const o=tz(e.bufferSync(i),s);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:g.TopK,backendName:"cpu",kernelFunc:function Emt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{k:s,sorted:o}=r;ar(i,"topk");const a=e.data.get(i.dataId).values,[u,c]=nz(a,i.shape,i.dtype,s,o);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:g.Transform,backendName:"cpu",kernelFunc:function wmt(t){const{inputs:n,attrs:e,backend:r}=t,{image:i,transforms:s}=n,{interpolation:o,fillMode:a,fillValue:u,outputShape:c}=e,[d,p,v,x]=i.shape,[w,b]=c??[p,v],T=[d,w,b,x],N=g.util.computeStrides(i.shape),S=N[0],U=N[1],J=N[2],ht=g.util.computeStrides(T),Tt=ht[0],Pt=ht[1],zt=ht[2],Ot=g.util.getTypedArrayFromDType(i.dtype,g.util.sizeFromShape(T));Ot.fill(u);const le=r.data.get(i.dataId).values,ge=r.data.get(s.dataId).values;for(let Re=0;Re<d;++Re){const ve=1===s.shape[0]?ge:ge.subarray(8*Re,8*Re+8);for(let Ne=0;Ne<w;++Ne)for(let Se=0;Se<b;++Se)for(let Ke=0;Ke<x;++Ke){let Le;const Be=ve[6]*Se+ve[7]*Ne+1;if(0===Be)continue;const rn=(ve[3]*Se+ve[4]*Ne+ve[5])/Be,pn=rz((ve[0]*Se+ve[1]*Ne+ve[2])/Be,v,a),Qe=rz(rn,p,a);switch(o){case"nearest":Le=Nmt(le,p,v,S,U,J,Re,Qe,pn,Ke,u);break;case"bilinear":Le=Amt(le,p,v,S,U,J,Re,Qe,pn,Ke,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}Ot[Re*Tt+Ne*Pt+Se*zt+Ke]=Le}return r.makeTensorInfo(T,i.dtype,Ot)}return{dataId:r.write(Ot,T,i.dtype),shape:i.shape,dtype:i.dtype}}},klt,{kernelName:g.Unique,backendName:"cpu",kernelFunc:function Mmt(t){const{inputs:n,attrs:e,backend:r}=t,{axis:i}=e,{x:s}=n;ar(s,"unique");const o=r.data.get(s.dataId).values,{outputValues:a,outputShape:u,indices:c}=iz(o,i,s.shape,s.dtype);return[r.makeTensorInfo(u,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},{kernelName:g.Unpack,backendName:"cpu",kernelFunc:function Omt(t){const{inputs:n,backend:e,attrs:r}=t,{value:i}=n;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i.shape.length,a=i.shape[s],u=new Array(o-1);let c=0;for(let x=0;x<o;x++)x!==s&&(u[c++]=i.shape[x]);const d=new Array(o).fill(0),p=i.shape.slice();p[s]=1;const v=new Array(a);for(let x=0;x<v.length;x++){d[s]=x;const w=Yd({inputs:{x:i},backend:e,attrs:{begin:d,size:p}});v[x]=Ao({inputs:{x:w},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(w)}return v}},{kernelName:g.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function Lmt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,segmentIds:s}=n,{numSegments:o}=r;ar(i,"unsortedSegmentSum");const c=[],d=[],p=i.shape.length-s.shape.length;let v=s;for(let w=0;w<p;++w){const b=r1({inputs:{input:v},backend:e,attrs:{dim:w+1}});v=b,d.push(b)}for(let w=0;w<o;++w){const b=g.util.createScalarValue(w,"int32"),T=e.makeTensorInfo([],"int32",b),N=h3({inputs:{a:T,b:v},backend:e}),S=ld({inputs:{x:N},backend:e,attrs:{dtype:"float32"}}),U=n1({inputs:{a:S,b:i},backend:e}),J=Xg({inputs:{x:U},backend:e,attrs:{axis:0,keepDims:!1}});c.push(J),d.push(T),d.push(N),d.push(S),d.push(U),d.push(J)}const x=R3({inputs:c,backend:e,attrs:{axis:0}});return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),x}},Ift];for(const t of Fmt)(0,g.registerKernel)(t);const cd={},o1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Pc(t,n){if(!(t in cd)||null!=n){const r=function zmt(t,n){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=n??function Bmt(t){if(!(0,g.env)().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===t)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete cd[t]},!1),(0,g.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(o1.failIfMajorPerformanceCaveat=!1),1===t?e.getContext("webgl",o1)||e.getContext("experimental-webgl",o1):e.getContext("webgl2",o1)}(t,n);if(null===r)return console.log("Could not get context for WebGL version",t),null;cd[t]=r}const e=cd[t];return null==e||e.isContextLost()?(delete cd[t],Pc(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),cd[t])}var a1=function(t){return t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",t}(a1||{}),fc=function(t){return t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD",t}(fc||{}),Ru=function(t){return t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",t}(Ru||{});function qg(t,n){return[n,t]}function u1(t){const n=g.util.sizeFromShape(t),e=Math.ceil(n/4);return g.util.sizeToSquarishShape(e)}function Fp(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function sS(t,n){const e=t;let r,i,s,o,a,u,c,d,p,v;return 2===(0,g.env)().getNumber("WEBGL_VERSION")?(r=e.R32F,i=e.R16F,s=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,d=1,p=e.HALF_FLOAT,v=e.FLOAT,u=e.RGBA8):(r=t.RGBA,i=t.RGBA,s=t.RGBA,o=e.RGBA,a=t.RGBA,c=4,d=4,p=null!=n?n.HALF_FLOAT_OES:null,v=t.FLOAT,u=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:v}}function Bn(t,n){const e=n();return(0,g.env)().getBool("DEBUG")&&function Wmt(t){const n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+function Kmt(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(t,n))}(t),e}function jmt(t){return!!((0,g.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function l1(t,n){return Nh(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}const Ymt=/ERROR: [0-9]+:([0-9]+):/g;function sz(t,n){const e=Ymt.exec(n);if(null==e)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(t);const r=+e[1],i=t.split("\n"),s=i.length.toString().length+2,o=i.map((p,v)=>g.util.rightPad((v+1).toString(),s)+p);let a=0;for(let p=0;p<o.length;p++)a=Math.max(o[p].length,a);const u=o.slice(0,r-1),c=o.slice(r-1,r),d=o.slice(r);console.log(u.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${g.util.rightPad(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function oS(t,n){if(Bn(t,()=>t.validateProgram(n)),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function oz(t,n,e,r,i,s,o){const a=t.getAttribLocation(n,e);return-1!==a&&(Bn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Bn(t,()=>t.vertexAttribPointer(a,i,t.FLOAT,!1,s,o)),Bn(t,()=>t.enableVertexAttribArray(a)),!0)}function agt(t,n,e,r){Bn(t,()=>function igt(t,n,e){(function uz(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(t,e),Bn(t,()=>t.activeTexture(t.TEXTURE0+e)),Bn(t,()=>t.bindTexture(t.TEXTURE_2D,n))}(t,n,r)),Bn(t,()=>t.uniform1i(e,r))}function aS(t,n,e){Bn(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Bn(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function az(t,n){Bn(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Bn(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function c1(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function ugt(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(t,n))}function Nh(t,n,e){const r=Bn(t,()=>n());if(null==r)throw new Error(e);return r}function $p(t,n=2){return g.util.sizeFromShape(t.slice(0,t.length-n))}function Bp(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function h1(t){let n=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(n=[$p(t),...Bp(t)]),n}function d1(t){return t%2==0}function f1(t,n){if(t=t.slice(-2),n=n.slice(-2),g.util.arraysEqual(t,n)||!t.length||!n.length||0===t[0]||0===t[1]||0===n[0]||0===n[1])return!0;if(t.length!==n.length){const e=t[t.length-1],r=n[n.length-1];if(e===r||d1(e)&&d1(r)&&(1===t[0]||1===n[0]))return!0}return t[1]===n[1]&&d1(t[0])&&d1(n[0])}let p1,m1;function pc(t,n){return null!=t.getExtension(n)}function lz(t){try{if(null!=Pc(t))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function uS(t){const n=sS(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(s),o}function Qg(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&g.util.assert("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}const lr=(0,g.env)();function Ku(){let t,n,e,r,i,s,o,a,u,c;return 2===(0,g.env)().getNumber("WEBGL_VERSION")?(t="#version 300 es",n="in",e="out",r="in",i="texture",s="outputColor",o="out vec4 outputColor;",a=(0,g.env)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",n="attribute",e="varying",r="varying",i="texture2D",s="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:i,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:u,defineRound:c}}function Qd(t,n,e="index"){const r=g.util.computeStrides(n);return r.map((i,s)=>`int ${t[s]} = ${e} / ${i}; ${s===r.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * ${i}`:`index -= ${t[s]} * ${i}`};`).join("")}function g1(t,n,e="index"){const r=g.util.computeStrides(n);return r.map((i,s)=>`int ${t[s]} = ${e} / outShapeStrides[${s}]; ${s===r.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * outShapeStrides[${s}]`:`index -= ${t[s]} * outShapeStrides[${s}]`};`).join("")}function lS(t){const n=g.util.computeStrides(t).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}lr.registerFlag("HAS_WEBGL",()=>lr.getNumber("WEBGL_VERSION")>0),lr.registerFlag("WEBGL_VERSION",()=>lz(2)?2:lz(1)?1:0),lr.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),lr.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===lr.get("WEBGL_VERSION")),lr.registerFlag("WEBGL_CPU_FORWARD",()=>!0),lr.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),lr.registerFlag("WEBGL_PACK",()=>lr.getBool("HAS_WEBGL")),lr.registerFlag("WEBGL_PACK_NORMALIZATION",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_CLIP",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_REDUCE",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_LAZILY_UNPACK",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_CONV_IM2COL",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function cgt(t){if(null==p1){const n=Pc(t);p1=n.getParameter(n.MAX_TEXTURE_SIZE)}return p1}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function hgt(t){if(null==m1){const n=Pc(t);m1=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,m1)}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=lr.getNumber("WEBGL_VERSION");return 0===t?0:function dgt(t){if(0===t)return 0;let n;const e=Pc(t);return n=pc(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:pc(e,"EXT_disjoint_timer_query")?1:0,n}(t)}),lr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>lr.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!g.device_util.isMobile()),lr.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function fgt(t){if(0===t)return!1;const n=Pc(t);if(1===t){if(!pc(n,"OES_texture_float"))return!1}else if(!pc(n,"EXT_color_buffer_float"))return!1;return uS(n)}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!lr.getBool("WEBGL_FORCE_F16_TEXTURES")&&lr.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),lr.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function pgt(t){if(0===t)return!1;const n=Pc(t);if(1!==t){if(pc(n,"EXT_color_buffer_float"))return uS(n);const r="EXT_color_buffer_half_float";if(pc(n,r)){const i=n.getExtension(r);return function mgt(t,n){const e=sS(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),a}(n,i)}return!1}return!(!pc(n,"OES_texture_float")||!pc(n,"WEBGL_color_buffer_float"))&&uS(n)}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function ggt(t){return 2===t&&null!=Pc(t).fenceSync}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>lr.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),lr.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if("number"!=typeof t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),lr.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>g.device_util.isMobile()?1:-1,t=>{if("number"!=typeof t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}),lr.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),lr.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),lr.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),lr.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),lr.registerFlag("WEBGL_EXP_CONV",()=>!1),lr.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>lr.getBool("IS_TEST")),lr.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),lr.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),lr.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),lr.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const cz="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:hz}=g.backend_util;function _gt(t,n,e){const r=[];if(t.forEach(x=>{const w=g.util.sizeFromShape(x.shapeInfo.logicalShape);if(x.shapeInfo.isUniform?r.push(`uniform float ${x.name}${w>1?`[${w}]`:""};`):(r.push(`uniform sampler2D ${x.name};`),r.push(`uniform int offset${x.name};`)),e.enableShapeUniforms){const{uniformShape:b}=hS(e.packedInputs,x.shapeInfo.logicalShape,x.shapeInfo.texShape);switch(b.length){case 1:r.push(`uniform int ${x.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${x.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${x.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${x.name}Shape;`)}r.push(`uniform ivec2 ${x.name}TexShape;`)}}),e.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(x=>{r.push(`uniform ${x.type} ${x.name}${x.arrayIndex?`[${x.arrayIndex}]`:""};`)});const i=r.join("\n"),s=t.map(x=>function xgt(t,n,e=!1,r){let i="";i+=e?dz(t,r):zp(t,r);return t.shapeInfo.logicalShape.length<=n.logicalShape.length&&(i+=e?function Jgt(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),i="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,o=n.logicalShape.length,a=hz(t.shapeInfo.logicalShape,n.logicalShape),u=ao(o),c=o-s;let d;const p=["x","y","z","w","u","v"];d=0===s?"":o<2&&a.length>=1?"coords = 0;":a.map(S=>`coords.${p[S+c]} = 0;`).join("\n");let v="";v=o<2&&s>0?"coords":t.shapeInfo.logicalShape.map((S,U)=>`coords.${p[U+c]}`).join(", ");let x="return outputValue;";const b=1===g.util.sizeFromShape(t.shapeInfo.logicalShape),N=1===g.util.sizeFromShape(n.logicalShape);if(1!==s||b||N){if(b&&!N)x=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const S=s-2,U=s-1;a.indexOf(S)>-1&&a.indexOf(U)>-1?x="return vec4(outputValue.x);":a.indexOf(S)>-1?x="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(U)>-1&&(x="return vec4(outputValue.xx, outputValue.zz);")}}else x="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${r}(${v});\n      ${x}\n    }\n  `}(t,n):function tyt(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),i="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,u=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===u&&null==t.shapeInfo.flatOffset&&g.util.arraysEqual(t.shapeInfo.texShape,n.texShape))return`\n      float ${i}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=ao(u),d=hz(t.shapeInfo.logicalShape,n.logicalShape),p=u-a;let v;const x=["x","y","z","w","u","v"];v=0===a?"":u<2&&d.length>=1?"coords = 0;":d.map(b=>`coords.${x[b+p]} = 0;`).join("\n");let w="";return w=u<2&&a>0?"coords":t.shapeInfo.logicalShape.map((b,T)=>`coords.${x[T+p]}`).join(", "),`\n    float ${i}() {\n      ${c} coords = getOutputCoords();\n      ${v}\n      return get${r}(${w});\n    }\n  `}(t,n)),i}(x,n,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=n.texShape,a=Ku(),u=function wgt(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,d,p=function Sgt(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Dgt}\n    ${Tgt}\n    ${Ngt}\n  `}(a);return n.isPacked?(c=function Egt(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Mgt(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,e);case 2:return function Bgt(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(g.util.arraysEqual(t,n))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const i=Math.ceil(t[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function Ogt(t,n,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],i=Math.ceil(t[2]/2),s=i*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,n,e);default:return function Lgt(t,n,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],i=Math.ceil(t[t.length-1]/2),s=i*Math.ceil(t[t.length-2]/2);let o=s,a="",u="b, r, c";for(let c=2;c<t.length-1;c++)o*=t[t.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,u=`b${c}, `+u;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${t.length}(${u});\n    }\n  `}(t,n,e)}}(n.logicalShape,o,e.enableShapeUniforms),d=function Igt(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(a)):(c=function Cgt(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Pgt(t,n,e){return 1===n[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,e);case 2:return function zgt(t,n,e){return g.util.arraysEqual(t,n)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===t[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function Rgt(t,n,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${g1(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`;const r=Qd(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(t,n,e);case 4:return function kgt(t,n,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${g1(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Qd(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,n,e);case 5:return function Fgt(t,n){const e=Qd(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,n);case 6:return function $gt(t,n){const e=Qd(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(n.logicalShape,o,e.enableShapeUniforms),d=function bgt(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(p+=Agt),[p,u,d,i,c,s,e.userCode].join("\n")}function zp(t,n=!1){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function Ugt(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[i,s]=t.shapeInfo.texShape;if(1===i&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=Jd(e);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,u]=t.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${u}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 1:return function Ggt(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Vp(t)}\n      }\n    `;const i=t.shapeInfo.texShape,s=i[0],o=i[1];if(1===o&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Jd(e);return 1===o?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===s?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:n?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 2:return function jgt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(null!=s&&g.util.arraysEqual(e,s))return n?`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=g.util.squeezeShape(e);if(o.length<e.length){const x=["row","col"];return`\n      ${zp(Up(t,o),n)}\n      float ${i}(int row, int col) {\n        return ${i}(${Wp(x,a)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Vp(t)}\n      }\n    `;const c=s[0],d=s[1],p=Jd(r);return 1===d?n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${c}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(t,n);case 3:return function Xgt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[1]*e[2],o=e[2],{newShape:a,keptDims:u}=g.util.squeezeShape(e);if(a.length<e.length){const T=["row","col","depth"];return`\n        ${zp(Up(t,a),n)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${Wp(T,u)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${Vp(t)}\n      }\n    `;const d=t.shapeInfo.texShape,p=d[0],v=d[1],x=t.shapeInfo.flatOffset;if(v===s&&null==x)return n?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${v}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(v===o&&null==x)return n?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${v}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const w=Jd(r);return n?`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${w};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${w};\n        vec2 uv = uvFromFlat(${p}, ${v}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(t,n);case 4:return function Ygt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[3],o=e[2]*s,a=e[1]*o,{newShape:u,keptDims:c}=g.util.squeezeShape(e);if(u.length<e.length){const U=["row","col","depth","depth2"];return`\n      ${zp(Up(t,u),n)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${Wp(U,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${s}, 1)));\n        ${Vp(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,v=p[0],x=p[1],w=`int stride2 = ${r}Shape[3];`,b=`int stride1 = ${r}Shape[2] * stride2;`,T=`int stride0 = ${r}Shape[1] * stride1;`;if(x===a&&null==d)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${w}\n        ${b}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(x===s&&null==d)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const N=Jd(r);return n?`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${w}\n      ${b}\n      ${T}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${N});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${v}, ${x}, index + ${N});\n      return sampleTexture(${r}, uv);\n    }\n  `}(t,n);case 5:return function qgt(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=n[4],s=n[3]*i,o=n[2]*s,a=n[1]*o,{newShape:u,keptDims:c}=g.util.squeezeShape(n);if(u.length<n.length){const T=["row","col","depth","depth2","depth3"];return`\n      ${zp(Up(t,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Wp(T,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${s}, ${i})) +\n          depth3;\n        ${Vp(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,v=p[0],x=p[1];if(x===a&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${v}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(x===i&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${v}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${s} +\n          depth2 * ${i} + depth3 + ${Jd(e)};\n      vec2 uv = uvFromFlat(${v}, ${x}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 6:return function Qgt(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:i,keptDims:s}=g.util.squeezeShape(n);if(i.length<n.length){const N=["row","col","depth","depth2","depth3","depth4"];return`\n      ${zp(Up(t,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Wp(N,s)});\n      }\n    `}const o=n[5],a=n[4]*o,u=n[3]*a,c=n[2]*u,d=n[1]*c;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${u}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Vp(t)}\n      }\n    `;const p=t.shapeInfo.flatOffset,v=t.shapeInfo.texShape,x=v[0],w=v[1];if(w===d&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${u}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${w}.0, ${x}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(w===o&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${w}.0, ${x}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${u} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${Jd(e)};\n      vec2 uv = uvFromFlat(${x}, ${w}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function dz(t,n){switch(t.shapeInfo.logicalShape.length){case 0:return function Vgt(t){const n=t.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${Ku().texture2D}(${n}, halfCR);\n    }\n  `}(t);case 1:return function Wgt(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=t.shapeInfo.texShape,s=Ku();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(t,n);case 2:return function Hgt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=s[0],a=s[1],u=Ku();if(null!=s&&g.util.arraysEqual(e,s))return n?`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(n)return`\n    vec4 ${i}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(t,n);case 3:return function Kgt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===e[0]){const x=[1,2],b=["b","row","col"];return`\n        ${dz(Up(t,e.slice(1)),n)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${Wp(b,x)});\n        }\n      `}const a=Ku();if(n)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const u=o[0],c=o[1],d=Math.ceil(e[2]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${c}, ${d*Math.ceil(e[1]/2)}, ${d}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(t,n);default:return function Zgt(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=Ku();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${e}, uv);\n    }\n  `;const s=t.shapeInfo.logicalShape,o=s.length,a=t.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=u[0],d=u[1],p=Math.ceil(s[o-1]/2);let v=p*Math.ceil(s[o-2]/2),x="int b, int row, int col",w=`b * ${v} + (row / 2) * ${p} + (col / 2)`;for(let b=2;b<o-1;b++)x=`int b${b}, `+x,v*=s[o-b-1],w=`b${b} * ${v} + `+w;return`\n    vec4 ${r}(${x}) {\n      int index = ${w};\n      int texR = index / ${d};\n      int texC = index - texR * ${d};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(t,n)}}const Dgt="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Tgt="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ngt="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Agt="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Jd(t){return`offset${t}`}function Vp(t){const n=t.name,e=g.util.sizeFromShape(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function ao(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function hS(t,n,e){const{newShape:r,keptDims:i}=g.util.squeezeShape(n),s=n.length,o=t&&3===s&&1===n[0],a=o?n.slice(1):r,u=!t&&s>1&&!g.util.arraysEqual(n,e)&&r.length<s||o;return{useSqueezeShape:u,uniformShape:u?a:n,keptDims:i}}function Up(t,n){const e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function Wp(t,n){return n.map(e=>t[e]).join(", ")}function pz(t,n,e){const r=[],i=[];let s,o,a,u=null,c=null;c=t.getUniformLocation(e,"NAN",!1),1===(0,g.env)().getNumber("WEBGL_VERSION")&&(u=t.getUniformLocation(e,"INFINITY",!1));const d=!1;for(const p of n.variableNames){const v={name:p,uniform:t.getUniformLocation(e,p,d),offset:t.getUniformLocation(e,`offset${p}`,d)};n.enableShapeUniforms&&(v.shape=t.getUniformLocation(e,`${p}Shape`,d),v.texShape=t.getUniformLocation(e,`${p}TexShape`,d)),r.push(v)}if(n.enableShapeUniforms&&(s=t.getUniformLocation(e,"outShape",d),a=t.getUniformLocation(e,"outShapeStrides",d),o=t.getUniformLocation(e,"outTexShape",d)),n.customUniforms)for(const p of n.customUniforms)i.push(t.getUniformLocation(e,p.name,d));return{variablesLocations:r,customUniformLocations:i,infLoc:u,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:o}}function mz(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{const i=e.logicalShape,s=n[r],o=s.shape;if(!g.util.arraysEqual(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(e.isUniform&&s.isUniform)return;const a=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!g.util.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function Lu(t){return(0,g.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class iyt{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=a1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ku();this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?g1(["r","c","d"],n):Qd(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class syt{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=a1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ku();this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?g1(["r","c","d"],n):Qd(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class oyt{constructor(n){this.variableNames=["A"],this.outTexUsage=fc.DOWNLOAD;const e=Ku();this.outputShape=n,this.userCode=`\n      ${cz}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class ayt{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=fc.DOWNLOAD;const e=Ku();this.outputShape=n,this.userCode=`\n      ${cz}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const uyt={R:0,G:1,B:2,A:3};class gz{constructor(n,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Ku();this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++)o+=`\n          if(offset == ${a}) {\n            result = values[${uyt[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":lS(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${i.texture2D}(A, uv);\n          ${o}\n        }\n        ${i.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class lyt{constructor(n,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ku();this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length);let i="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const u=2*o+a;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${u}] = values[0];\n            } else if (offset == 1) {\n              result[${u}] = values[1];\n            } else if (offset == 2) {\n              result[${u}] = values[2];\n            } else {\n              result[${u}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":lS(n)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${i}\n\n          ${r.output} = ${s};\n        }\n    `}}function Jg(t,n,e,r,i,s){!function ngt(t,n){const e=(0,g.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0)throw new Error(`Requested texture size [${t}x${n}] is invalid.`);if(t>e||n>e)throw new Error(`Requested texture size [${t}x${n}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(n,e);const o=function egt(t){return Nh(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return Bn(t,()=>t.bindTexture(a,o)),Bn(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Bn(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Bn(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Bn(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),1===(0,g.env)().getNumber("WEBGL_VERSION")?Bn(t,()=>t.texImage2D(a,0,r,n,e,0,i,s,null)):Bn(t,()=>t.texStorage2D(a,1,r,n,e)),Bn(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:o,texShape:[e,n]}}function yz(t){return t.internalFormatFloat}function vz(t){return t.internalFormatHalfFloat}function _z(t){return t.downloadTextureFormat}function xz(t){return t.internalFormatPackedFloat}function Ez(t){return t.internalFormatPackedHalfFloat}class dS{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=(0,g.env)().getNumber("WEBGL_VERSION");if(null!=n?(this.gl=n,function $mt(t,n){cd[t]=n}(e,n)):this.gl=Pc(e),n=this.gl,2===(0,g.env)().getNumber("WEBGL_VERSION")){const s=n;this.createVertexArray=()=>Bn(s,()=>s.createVertexArray()),this.bindVertexArray=o=>Bn(s,()=>s.bindVertexArray(o)),this.deleteVertexArray=o=>Bn(s,()=>s.deleteVertexArray(o)),this.getVertexArray=()=>Bn(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(null!=n){const s=n.getExtension("OES_vertex_array_object");if(null==s)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Bn(n,()=>s.createVertexArrayOES()),this.bindVertexArray=o=>Bn(n,()=>s.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Bn(n,()=>s.deleteVertexArrayOES(o)),this.getVertexArray=()=>Bn(n,()=>n.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,g.env)().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=l1(this.gl,"OES_texture_float"),pc(this.gl,o))this.textureHalfFloatExtension=l1(this.gl,o);else if((0,g.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),pc(this.gl,i))this.colorBufferHalfFloatExtension=l1(this.gl,i);else if((0,g.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",pc(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!pc(this.gl,i))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(i)}this.vertexBuffer=function hyt(t){return function Jmt(t,n){const e=Nh(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Bn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),Bn(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function dyt(t){return function tgt(t,n){const e=Nh(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Bn(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),Bn(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function rgt(t){return Nh(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=sS(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,g.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;Bn(n,()=>n.finish()),Bn(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Bn(n,()=>n.deleteFramebuffer(this.framebuffer)),Bn(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),Bn(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),Bn(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),function fyt(t,n,e,r){const[i,s]=qg(n,e);return Jg(t,i,s,yz(r),r.textureFormatFloat,t.FLOAT)}(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),function pyt(t,n,e,r){const[i,s]=qg(n,e);return Jg(t,i,s,vz(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),function myt(t,n,e,r){const[i,s]=qg(n,e);return Jg(t,i,s,_z(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),function xyt(t,n,e){Bn(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?2===(0,g.env)().getNumber("WEBGL_VERSION")?Bn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)):Bn(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):2===(0,g.env)().getNumber("WEBGL_VERSION")?Bn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)):Bn(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),Bn(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,i){this.throwIfDisposed(),function _yt(t,n,e,r,i,s){let o,a,u;Bn(t,()=>t.bindTexture(t.TEXTURE_2D,n)),i instanceof Uint8Array?(o=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,u=t.RGBA):(o=new Float32Array(e*r*4),a=t.FLOAT,u=s.internalFormatPackedFloat),o.set(i),2===(0,g.env)().getNumber("WEBGL_VERSION")?Bn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,r,t.RGBA,a,o)):Bn(t,()=>t.texImage2D(t.TEXTURE_2D,0,u,e,r,0,t.RGBA,a,o)),Bn(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e,r,i,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),function yyt(t,n,e,r){const[i,s]=Fp(n,e);return Jg(t,i,s,Ez(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),function gyt(t,n,e,r){const[i,s]=Fp(n,e);return Jg(t,i,s,xz(r),t.RGBA,t.FLOAT)}(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(az(this.gl,this.framebuffer),this.outputTexture=null),Bn(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function wyt(t,n,e,r){const[i,s]=qg(n,e),a=new Uint8Array(function Vmt(t,n){return t*n}(n*e,4));return Bn(t,()=>t.readPixels(0,0,i,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,i,s,o){return function byt(t,n,e,r,i,s,o,a){const u=t,c=new Float32Array(function Umt(t,n){const[e,r]=Fp(t,n);return e*r*4}(s,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,n),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}(this.gl,n,0,0,0,s,o)}downloadFloat32MatrixFromBuffer(n,e){return function Cyt(t,n,e){const r=t,i=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);const i=function Eyt(t,n,e,r){const i=t.createBuffer();Bn(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,i));const a=16*n*e;return Bn(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Bn(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),Bn(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),i}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if((0,g.env)().getBool("WEBGL_FENCE_API_ENABLED")){const i=n,s=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const o=i.clientWaitSync(s,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},e=s}else(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function Iyt(t,n,e){const r=new Float32Array(n*e*4);return Bn(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}(this.gl,e,r))}createProgram(n){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function cyt(t){const n=Ku();return function Xmt(t,n){const e=Nh(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Bn(t,()=>t.shaderSource(e,n)),Bn(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(t,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function qmt(t){return Nh(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);Bn(e,()=>e.attachShader(r,this.vertexShader)),Bn(e,()=>e.attachShader(r,n)),function Qmt(t,n){if(Bn(t,()=>t.linkProgram(n)),!(0,g.env)().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(e,r);const i=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&oS(e,i),i}buildVao(n){this.setProgram(n),this.bindVertexArray(n.vao);const e=this.gl;Bn(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function vyt(t,n,e){Bn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),oz(t,n,"clipSpacePos",e,3,20,0)&&oz(t,n,"uv",e,2,20,12)}(e,n,this.vertexBuffer)}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&(Bn(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&this.debug&&oS(this.gl,this.program),Bn(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?function sgt(t,n,e){return Nh(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}(this.gl,n,e):function ogt(t,n,e){return t.getUniformLocation(n,e)}(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),Bn(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),agt(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();const[i,s]=Fp(e,r);this.setOutputMatrixTextureDriver(n,i,s)}setOutputMatrixWriteRegion(n,e,r,i){this.setOutputMatrixWriteRegionDriver(r,n,i,e)}setOutputPackedMatrixWriteRegion(n,e,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&oS(this.gl,this.program),c1(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Bn(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Bn(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=l1(this.gl,2===(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(i.TIME_ELAPSED_EXT,s),s}const n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var e=this;return(0,Mr.Z)(function*(){return yield g.util.repeatedTry(()=>e.disposed||e.isQueryAvailable(n,(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(n,(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(0===e)return!0;if(2===e){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),i=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){const n=function Syt(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in(0,g.env)().platform&&(r=(0,g.env)().platform.setTimeoutCustom.bind((0,g.env)().platform)),g.util.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),aS(this.gl,n,this.framebuffer),this.debug&&c1(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(aS(this.gl,this.outputTexture,this.framebuffer),this.debug&&c1(this.gl)):az(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();const i=this.gl;aS(i,n,this.framebuffer),this.debug&&c1(i),this.outputTexture=n,Bn(i,()=>i.viewport(0,0,e,r)),Bn(i,()=>i.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,i){this.throwIfDisposed(),Bn(this.gl,()=>this.gl.scissor(n,e,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:Dyt,bincountImpl:Cz,bincountReduceImpl:Tyt,bitwiseAndImpl:Nyt,castImpl:Ayt,ceilImpl:Myt,concatImpl:Pyt,equalImpl:Oyt,expImpl:Ryt,expm1Impl:Lyt,floorImpl:kyt,gatherNdImpl:Fyt,gatherV2Impl:$yt,greaterImpl:Byt,greaterEqualImpl:zyt,lessImpl:Vyt,lessEqualImpl:Uyt,linSpaceImpl:Wyt,logImpl:Gyt,maxImpl:Hyt,maximumImpl:jyt,minimumImpl:Kyt,multiplyImpl:Xyt,negImpl:Zyt,notEqualImpl:Yyt,prodImpl:qyt,raggedGatherImpl:Qyt,raggedRangeImpl:Jyt,raggedTensorToTensorImpl:t0t,rangeImpl:e0t,rsqrtImpl:n0t,scatterImpl:r0t,sigmoidImpl:i0t,simpleAbsImpl:wz,sliceImpl:s0t,sparseFillEmptyRowsImpl:o0t,sparseReshapeImpl:a0t,sparseSegmentReductionImpl:bz,sqrtImpl:u0t,staticRegexReplaceImpl:l0t,stridedSliceImpl:c0t,stringNGramsImpl:h0t,stringSplitImpl:d0t,stringToHashBucketFastImpl:f0t,subImpl:p0t,tileImpl:m0t,topKImpl:g0t,transposeImpl:fS,uniqueImpl:y0t}=$;function Iz(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function Xu(t,n){return 1===n?[t]:Iz(t,n)}class _0t{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=Lu(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Xu("rc",this.rank),r=ao(this.rank),i=this.getOutOfBoundsCondition(e),s=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${i}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(n){const e=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let s=`${0===r?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let o=2;o<this.rank;o++)s=`${n[n.length-1-o]},`+s;e.push(s)}return e}getOutOfBoundsCondition(n){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(n){if(1===this.rank)return"";const e=n.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(n){const e=this.getSourceCoordsArr(n);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class Sz{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length);let r="";for(let i=0;i<4;i++){let s="thisRC = rc;";i%2==1&&(s+="thisRC.z += 1;"),i>1&&(s+="thisRC.y += 1;"),r+=`\n        ${s}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}this.userCode=`\n      ${function x0t(t,n){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n?function vgt(t,n,e="index"){const i=function ygt(t,n){const e=t.length,r=t.map(s=>`${n}[${s}]`),i=new Array(e-1);i[e-2]=r[e-1];for(let s=e-3;s>=0;--s)i[s]=`(${i[s+1]} * ${r[s+1]})`;return i}(t.map((s,o)=>o),n);return i.map((s,o)=>`int ${t[o]} = ${e} / ${i[o]}; ${o===i.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${i[o]}`:`index -= ${t[o]} * ${i[o]}`};`).join("")}(["r","c","d"],"inputShape"):Qd(["r","c","d"],t)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":lS(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class E0t{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(n,e,r){const i=Tz(e,r),s=Nz(n,i,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=Dz(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const u=this.freeTextures[s].pop();return this.usedTextures[s].push(u),u}let a;return i===Ru.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):i===Ru.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):i===Ru.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):i===Ru.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):i===Ru.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(n,e,r,i){if(null==this.freeTextures)return;const s=Tz(r,i),o=Nz(e,s,i);o in this.freeTextures||(this.freeTextures[o]=[]);const a=Dz(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,i),u=(0,g.env)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],d=c&&c.indexOf(n);if(null==d||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Dz(t,n,e,r,i){const s=function w0t(t,n){switch(t){case Ru.PACKED_2X2_FLOAT32:return xz(n);case Ru.PACKED_2X2_FLOAT16:return Ez(n);case Ru.UNPACKED_FLOAT32:return yz(n);case Ru.UNPACKED_FLOAT16:return vz(n);case Ru.PACKED_4X1_UNSIGNED_BYTE:return _z(n);default:throw new Error(`Unknown physical texture type ${t}`)}}(n,r);let o;if(i){const[u,c]=Fp(t[0],t[1]);o=u*c}else{const[u,c]=qg(t[0],t[1]);o=u*c}const a=function C0t(t,n){if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===t.RGBA16F)return 8;if(n===t.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}(e,s);return o*a}function Tz(t,n){if(t===fc.UPLOAD)return Ru.PACKED_2X2_FLOAT32;if(t===fc.RENDER||null==t)return function b0t(t){return(0,g.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Ru.PACKED_2X2_FLOAT32:Ru.UNPACKED_FLOAT32:t?Ru.PACKED_2X2_FLOAT16:Ru.UNPACKED_FLOAT16}(n);if(t===fc.DOWNLOAD||t===fc.PIXELS)return Ru.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function Nz(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}class oh{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Wl="if (isnan(x)) return x;",I0t="return x;",Az="return abs(x);",S0t="return (x >= 0.0) ? x : (exp(x) - 1.0);",D0t=Wl+"\n  return (x < 0.0) ? 0.0 : x;\n",T0t=Wl+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",hd="return x;",N0t="return 1.0 / (1.0 + exp(-1.0 * x));",A0t="return x;",M0t="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",P0t="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",O0t="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",R0t="return 1.0 / (1.0 + exp(-1.0 * x));";class dd{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class L0t{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length);const e=n.length,r=Xu("rc",e),i=ao(e),s=function v0t(t,n){if(1===t)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}(e,r),o=r.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${i} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const k0t=g.kernel_impls.whereImpl,v1={},z0t=(0,g.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let W0t=(()=>{class t extends g.KernelBackend{nextDataId(){return t.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,g.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof dS)r=e;else{const i=Pc((0,g.env)().getNumber("WEBGL_VERSION"),e);r=new dS(i)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const i=Pc((0,g.env)().getNumber("WEBGL_VERSION"));r=new dS(i),this.binaryCache=function B0t(t){return t in v1||(v1[t]={}),v1[t]}((0,g.env)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new E0t(this.gpgpu),this.numMBBeforeWarning=function U0t(){return null==(0,g.env)().global.screen?1024:(0,g.env)().global.screen.height*(0,g.env)().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new g.DataStorage(this,(0,g.engine)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,i,s,o,a){const u=this.makeTensorInfo(r,i),c=this.texData.get(u.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[s,o]},c.texShape=[s,o];const d=h1(r),p=new gz(d,!1,a),v=this.runWebGLProgram(p,[u],i,[[s,o]]);return v.shape=r,c.texture=null,this.disposeIntermediateTensorInfo(u),v.dataId}write(e,r,i){if(((0,g.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,g.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===i&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:i,values:e,usage:fc.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,i,s,o){if((0,g.env)().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:i,dtype:s,values:r,usage:fc.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:i,dtype:s,complexTensorInfos:o,slice:a,shape:u,isPacked:c}=r;if(null!=a){let x;x=c?new dd(u,hd):new oh(u,hd);const w=this.runWebGLProgram(x,[{dataId:e,shape:u,dtype:s}],s),b=this.readSync(w.dataId);return this.disposeIntermediateTensorInfo(w),b}if(null!=i)return this.convertAndCacheOnCPU(e);if("string"===s)return i;const d=null!=this.activeTimers;let p,v;if(d&&(p=g.util.now()),"complex64"===s){const x=this.readSync(o.real.dataId),w=this.readSync(o.imag.dataId);v=g.backend_util.mergeRealAndImagArrays(x,w)}else v=this.getValuesFromTexture(e);return d&&(this.downloadWaitMs+=g.util.now()-p),this.convertAndCacheOnCPU(e,v)}read(e){var r=this;return(0,Mr.Z)(function*(){if(r.pendingRead.has(e)){const T=r.pendingRead.get(e);return new Promise(N=>T.push(N))}const i=r.texData.get(e),{values:s,shape:o,slice:a,dtype:u,complexTensorInfos:c,isPacked:d}=i;if(null!=a){let T;T=d?new dd(o,hd):new oh(o,hd);const N=r.runWebGLProgram(T,[{dataId:e,shape:o,dtype:u}],u),S=r.read(N.dataId);return r.disposeIntermediateTensorInfo(N),S}if(null!=s)return r.convertAndCacheOnCPU(e);if((0,g.env)().getBool("DEBUG")&&!(0,g.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,g.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let v,x,p=null;if("complex64"!==u&&(0,g.env)().get("WEBGL_BUFFER_SUPPORTED")){v=r.decode(e);const T=r.texData.get(v.dataId);p=r.gpgpu.createBufferFromTexture(T.texture.texture,...u1(o))}if(r.pendingRead.set(e,[]),"complex64"!==u&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===u){const T=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);x=g.backend_util.mergeRealAndImagArrays(T[0],T[1])}else if(null==p)x=r.getValuesFromTexture(e);else{const T=g.util.sizeFromShape(o);x=r.gpgpu.downloadFloat32MatrixFromBuffer(p,T)}if(null!=v&&r.disposeIntermediateTensorInfo(v),null!=p){const T=r.gpgpu.gl;Bn(T,()=>T.deleteBuffer(p))}const w=r.convertAndCacheOnCPU(e,x),b=r.pendingRead.get(e);return r.pendingRead.delete(e),b.forEach(T=>T(w)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&(0,g.engine)().removeDataId(e,r),r.pendingDeletes--),w})()}readToGPU(e,r={}){const i=this.texData.get(e),{values:s,shape:o,slice:a,dtype:u,isPacked:c,texture:d}=i;if("complex64"===u)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let w;w=c?new dd(o,hd):new oh(o,hd);const b=this.runWebGLProgram(w,[{dataId:e,shape:o,dtype:u}],u),T=this.readToGPU(b,r);return this.disposeIntermediateTensorInfo(b),T}if(null==d)throw null!=s?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const p=this.decode(e,r.customTexShape),v=(0,g.engine)().makeTensorFromTensorInfo(p),x=this.texData.get(p.dataId);return Object.assign({tensorRef:v},x.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const i=r.map(s=>g.util.decodeString(s));return(0,g.buffer)(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,g.buffer)(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const i=e[r];if(!jmt(i))throw(0,g.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${i} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${i} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:i,isPacked:s}=this.texData.get(e),o=g.util.sizeFromShape(r);if((0,g.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const x=this.decode(e),w=this.texData.get(x.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(w.texture.texture,...u1(r)).subarray(0,o);return this.disposeIntermediateTensorInfo(x),b}const a=(0,g.env)().getBool("WEBGL_PACK")&&!0===s,u=a?h1(r):r,c=a?new ayt(u):new oyt(u),d=this.runWebGLProgram(c,[{shape:u,dtype:i,dataId:e}],"float32"),p=this.texData.get(d.dataId),v=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(d),v}timerAvailable(){return(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const i=this.activeTimers,s=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=s,o=!0):this.activeTimers.push(s),this.activeTimers=s,e();const a=g.util.flatten(this.activeTimers.map(d=>d.query)).filter(d=>null!=d),u=g.util.flatten(this.activeTimers.map(d=>d.name)).filter(d=>null!=d);this.activeTimers=i,o&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(0,Mr.Z)(function*(){if((0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const d=yield Promise.all(a);c.kernelMs=g.util.sum(d),c.getExtraProfileInfo=()=>d.map((p,v)=>({name:u[v],ms:p})).map(p=>`${p.name}: ${p.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:g.util.now(),endMs:null}}endTimer(e){return(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=g.util.now(),e)}getQueryTime(e){var r=this;return(0,Mr.Z)(function*(){return(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:i}=this.texData.get(e);return null!=i&&(this.disposeData(i.real.dataId,r),this.disposeData(i.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:i,texShape:s,usage:o,isPacked:a,slice:u}=this.texData.get(e),c=u&&u.origDataId||e,d=this.dataRefCount.get(c);d>1?this.dataRefCount.set(c,d-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(s,i),this.textureManager.releaseTexture(r,s,o,a)));const p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=z0t){return(0,g.env)().getBool("WEBGL_CPU_FORWARD")&&e.every(i=>null==this.texData.get(i.dataId).texture&&g.util.sizeFromShape(i.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){g.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return k0t(e.shape,r)}packedUnaryOp(e,r,i){const s=new dd(e.shape,r),o=this.compileAndRun(s,[e],i);return(0,g.engine)().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const s=wz(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if((0,g.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Az,e.dtype);const r=new oh(e.shape,Az),i=this.compileAndRun(r,[e]);return(0,g.engine)().makeTensorFromTensorInfo(i)}makeTensorInfo(e,r,i){let s;if("string"===r&&null!=i&&i.length>0&&g.util.isString(i[0])){const o=i.map(a=>g.util.encodeString(a));s=this.write(o,e,r)}else s=this.write(i,e,r);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:r}}makeOutput(e,r,i){return(0,g.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,i),this)}unpackTensor(e){const r=new L0t(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new _0t(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const i=[$p(e.shape),...Bp(e.shape)],s={dtype:e.dtype,shape:i,dataId:e.dataId},o=[$p(r),...Bp(r)],a=new Sz(o,i),d=this.runWebGLProgram(a,[s],e.dtype,[i],!0);return{dataId:d.dataId,shape:r,dtype:d.dtype}}decode(e,r){const i=this.texData.get(e),{isPacked:s,shape:o,dtype:a}=i;if(null!=r){const x=g.util.sizeFromShape(o);g.util.assert(x<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const u=h1(o);let c;c=s?new syt(u):new iyt(u);const p=[r??u1(u)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(c,[{shape:u,dtype:a,dataId:e}],a,p,!0,r).dataId}}runWebGLProgram(e,r,i,s,o=!1,a){const u=this.makeTensorInfo(e.outputShape,i),c=this.texData.get(u.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===a1.DENSE){const S=a??u1(e.outputShape);c.texShape=S.map(U=>2*U)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===g.util.sizeFromShape(u.shape))return c.values=g.util.getTypedArrayFromDType(u.dtype,0),u;const d=[],p=r.map(S=>{if("complex64"===S.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let U=this.texData.get(S.dataId);if(null==U.texture){if(!e.packedInputs&&g.util.sizeFromShape(S.shape)<=(0,g.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:U.values};e.packedInputs&&(U.isPacked=!0,U.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!U.isPacked!=!!e.packedInputs)S=U.isPacked?this.unpackTensor(S):this.packTensor(S),d.push(S),U=this.texData.get(S.dataId);else if(U.isPacked&&!f1(U.shape,S.shape)){const J=S,ht=S.shape;S.shape=U.shape,S=this.packedReshape(S,ht),d.push(S),U=this.texData.get(S.dataId),J.shape=ht}return{shape:S.shape,texData:U,isUniform:!1}});this.uploadToGPU(u.dataId);const v={shape:u.shape,texData:c,isUniform:!1},x=function ryt(t,n,e){let r="";n.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!o.isUniform){const u=o.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:p}=hS(t.packedInputs,o.shape,u);let v="",x="",w="";if(1===d.length&&t.packedInputs){const ht=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];v=`${ht[0]>1}_${ht[1]>1}`}else if(2!==d.length||t.packedInputs){if(d.length>2&&!t.packedInputs){const ht=g.util.computeStrides(d);w=`${ht[0]===u[1]}_${ht[ht.length-1]===u[1]}`}}else x=`${d[0]>1}_${d[1]>1}`;const b=o.shape.length,T=2===d.length&&g.util.arraysEqual(o.shape,u),N=1===g.util.sizeFromShape(o.shape),S=g.backend_util.getBroadcastDims(o.shape,e.shape),U=!t.packedInputs&&b===e.shape.length&&g.util.arraysEqual(u,e.texData.texShape);r+=`${b}_${U}_${c?p:""}_${d.length}_${N}_${S}_${T}_${v}_${x}_${w}_${t.packedInputs||d.length>2?"":`${u[0]>1}_${u[1]>1}`}_${a}`}else r+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let s=t.constructor.name;return s+="_"+r+"_"+t.userCode+`${(0,g.env)().getNumber("WEBGL_VERSION")}`,s}(e,p,v),w=this.getAndSaveBinary(x,()=>function eyt(t,n,e,r){const i=e.map((d,p)=>{const v={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:!d.isUniform&&d.texData.isPacked,flatOffset:null};return null!=d.texData&&null!=d.texData.slice&&d.texData.slice.flatOffset>0&&(v.flatOffset=d.texData.slice.flatOffset),{name:n.variableNames[p],shapeInfo:v}}),s=i.map(d=>d.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=_gt(i,o,n),u=function Zmt(t,n){const e=Nh(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Bn(t,()=>t.shaderSource(e,n)),Bn(t,()=>t.compileShader(e)),(0,g.env)().get("ENGINE_COMPILE_ONLY"))return e;if(!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw sz(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(t.gl,a),c=t.createProgram(u);return(0,g.env)().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:n,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},pz(t,n,c)))}(this.gpgpu,e,p,v)),b=null!=this.activeTimers;let T;b&&(T=this.startTimer()),(0,g.env)().get("ENGINE_COMPILE_ONLY")||function nyt(t,n,e,r,i){n.program.enableShapeUniforms||(mz(n.inShapeInfos,e),mz([n.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):t.setOutputMatrixTexture(s.texture,o[0],o[1]),t.setProgram(n.webGLProgram),t.bindVertexArray(n.webGLProgram.vao),1===(0,g.env)().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&t.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&t.gl.uniform1f(n.nanLoc,NaN);for(let u=0;u<e.length;++u){const c=e[u],{uniform:d,offset:p,shape:v,texShape:x}=n.variablesLocations[u];if(v){const{uniformShape:w}=hS(n.program.packedInputs,c.shape,c.texData.texShape);switch(w.length){case 1:t.gl.uniform1iv(v,new Int32Array(w));break;case 2:t.gl.uniform2iv(v,new Int32Array(w));break;case 3:t.gl.uniform3iv(v,new Int32Array(w));break;case 4:t.gl.uniform4iv(v,new Int32Array(w))}}if(x&&t.gl.uniform2i(x,c.texData.texShape[0],c.texData.texShape[1]),null!=d){if(c.isUniform){if(g.util.sizeFromShape(c.shape)<2)t.gl.uniform1f(d,c.uniformValues[0]);else{let w=c.uniformValues;w instanceof Float32Array||(w=new Float32Array(w)),t.gl.uniform1fv(d,w)}continue}null!=c.texData.slice&&null!=p&&t.gl.uniform1i(p,c.texData.slice.flatOffset),t.setInputMatrixTexture(c.texData.texture.texture,d,u)}}const a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape))}if(n.outShapeStridesLocation){const u=g.util.computeStrides(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(u));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(u));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(u))}}if(n.outTexShapeLocation&&t.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&i)for(let u=0;u<n.program.customUniforms.length;++u){const c=n.program.customUniforms[u],d=n.customUniformLocations[u],p=i[u];if("float"===c.type)t.gl.uniform1fv(d,p);else if("vec2"===c.type)t.gl.uniform2fv(d,p);else if("vec3"===c.type)t.gl.uniform3fv(d,p);else if("vec4"===c.type)t.gl.uniform4fv(d,p);else if("int"===c.type)t.gl.uniform1iv(d,p);else if("ivec2"===c.type)t.gl.uniform2iv(d,p);else if("ivec3"===c.type)t.gl.uniform3iv(d,p);else{if("ivec4"!==c.type)throw Error(`uniform type ${c.type} is not supported yet.`);t.gl.uniform4iv(d,p)}}t.executeProgram()}(this.gpgpu,w,p,v,s),d.forEach(S=>this.disposeIntermediateTensorInfo(S)),b&&(T=this.endTimer(T),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(T)}));const N=(0,g.env)().getNumber("WEBGL_FLUSH_THRESHOLD");if(N>0){const S=g.util.now();S-this.lastGlFlushTime>N&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!(0,g.env)().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===o){const S=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),S}return u}compileAndRun(e,r,i,s,o=!1){return this.runWebGLProgram(e,r,i=i||r[0].dtype,s,o)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,g.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,g.tidy)(()=>{if(!(0,g.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,g.env)().getBool("DEBUG");(0,g.env)().set("DEBUG",!1);const r=this.abs((0,g.scalar)(1e-8)).dataSync()[0];if((0,g.env)().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:i,dtype:s,values:o,texture:a,usage:u,isPacked:c}=r;if(null!=a)return;const d=null!=this.activeTimers;let p;d&&(p=g.util.now());let v=r.texShape;if(null==v&&(v=function lgt(t,n=!1){let e=(0,g.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=(0,g.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&(0,g.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),n&&(e*=2,r*=2,1===(t=t.map((a,u)=>u>=t.length-2?g.util.nearestLargerEven(t[u]):t[u])).length&&(t=[2,t[0]])),2!==t.length&&(t=g.util.squeezeShape(t).newShape);let i=g.util.sizeFromShape(t),s=null;t.length<=1&&i<=e?s=[1,i]:2===t.length&&t[0]<=e&&t[1]<=e?s=t:3===t.length&&t[0]*t[1]<=e&&t[2]<=e?s=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=e&&t[1]*t[2]<=e?s=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=e&&t[3]<=e?s=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=e&&t[1]*t[2]*t[3]<=e&&(s=[t[0],t[1]*t[2]*t[3]]);const o=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(n?2:1)&&Math.min(...s)>0;if(null==s||o)if(n){const a=$p(t);let u=2,c=2;t.length&&([u,c]=Bp(t)),i=a*(u/2)*(c/2),s=g.util.sizeToSquarishShape(i).map(d=>2*d)}else s=g.util.sizeToSquarishShape(i);return s}(i,c),r.texShape=v),null!=o){const x=h1(i);let w,b=v[1],T=v[0];const N=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!N)&&([b,T]=Fp(v[0],v[1])),w=c?new lyt(x,N):new gz(x,N);const S=N?[T,b]:v,U=this.makeTensorInfo(S,s),J=this.texData.get(U.dataId);J.usage=N?fc.PIXELS:fc.UPLOAD,J.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(U.dataId),b,T,o);const Pt=this.runWebGLProgram(w,[U],s,[[T,b]],!0),zt=this.texData.get(Pt.dataId);r.texShape=zt.texShape,r.isPacked=zt.isPacked,r.usage=zt.usage,(0,g.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(Pt.dataId):(r.texture=zt.texture,r.values=null,this.texData.delete(Pt.dataId)),this.disposeIntermediateTensorInfo(U),d&&(this.uploadWaitMs+=g.util.now()-p)}else{const x=this.acquireTexture(v,u,s,c);r.texture=x}}convertAndCacheOnCPU(e,r){const i=this.texData.get(e),{dtype:s}=i;return null!=r&&(i.values=function G0t(t,n){if("float32"===n||"complex64"===n)return t;if("int32"===n||"bool"===n){const e="int32"===n?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}throw new Error(`Unknown dtype ${n}`)}(r,s)),i.values}acquireTexture(e,r,i,s){if(this.numBytesInGPU+=this.computeBytes(e,i),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,s)}computeBytes(e,r){return e[0]*e[1]*g.util.bytesPerElement(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return(0,Mr.Z)(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,i]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(i));return Promise.all(r)}for(const[,i]of Object.entries(e.binaryCache)){const s=new Promise(o=>{try{e.checkCompletion_(i),o(!0)}catch(a){throw a}});r.push(s)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return(0,Mr.Z)(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield(0,g.nextFrame)(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(sz(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:r,customUniformLocations:i,infLoc:s,nanLoc:o,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:c}=pz(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=i,e.infLoc=s,e.nanLoc=o,e.outShapeLocation=a,e.outShapeStridesLocation=u,e.outTexShapeLocation=c}}createTensorFromGPUData(e,r,i){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:a,channels:u}=e,c=(0,g.engine)().backend;if(!c.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const d=c.writeTexture(s,r,i,o,a,u);return(0,g.engine)().makeTensorFromDataId(d,r,i,c)}}return t.nextDataId=0,t})();g.device_util.isBrowser()&&(0,g.registerBackend)("webgl",()=>new W0t,2);const pS="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class ef{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=g.backend_util.assertAndGetBroadcastShape(e,r),this.enableShapeUniforms=Lu(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const nf="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Gp{constructor(n,e,r,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g.backend_util.assertAndGetBroadcastShape(e,r);const s=this.outputShape.length;this.enableShapeUniforms=Lu(s);let o="";if(i)if(0===s||1===g.util.sizeFromShape(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${ao(s)} coords = getOutputCoords();\n        `,1===s)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const u=Xu("coords",s);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${u[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${u[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${n}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function bl(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const K0t={kernelName:g.Identity,backendName:"webgl",kernelFunc:bl};function fd(t){const{inputs:n,backend:e}=t,{real:r,imag:i}=n,s=e.makeTensorInfo(r.shape,"complex64"),o=e.texData.get(s.dataId),a=bl({inputs:{x:r},backend:e}),u=bl({inputs:{x:i},backend:e});return o.complexTensorInfos={real:a,imag:u},s}const X0t={kernelName:g.Complex,backendName:"webgl",kernelFunc:fd},Mz="return (a < 0.) ? b * a : a;",Pz="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Y0t={kernelName:g.LeakyRelu,backendName:"webgl",kernelFunc:function Z0t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{alpha:s}=r,o=e.makeTensorInfo([],"float32",g.util.createScalarValue(s,"float32")),a=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gp(Pz,i.shape,o.shape):new ef(Mz,i.shape,o.shape),u=e.runWebGLProgram(a,[i,o],"float32");return e.disposeIntermediateTensorInfo(o),u}},Oz="return (a < 0.) ? b * a : a;",Rz="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Q0t={kernelName:g.Prelu,backendName:"webgl",kernelFunc:function q0t(t){const{inputs:n,backend:e}=t,{x:r,alpha:i}=n,s=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gp(Rz,r.shape,i.shape):new ef(Oz,r.shape,i.shape);return e.runWebGLProgram(s,[r,i],"float32")}},Hp="if (isnan(x)) return x;";function gs({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:i,backend:s})=>{const{x:o}=i,a=s,u=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const p=a.texData.get(o.dataId),v=e(p.values,u);return a.makeTensorInfo(o.shape,u,v)}let d;return d=(0,g.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new dd(o.shape,n):new oh(o.shape,t),a.runWebGLProgram(d,[o],u)}}function Cu({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:o,backend:a})=>{const{a:u,b:c}=o,d=a;if(r&&"complex64"===u.dtype){const w=d.texData.get(u.dataId),b=d.texData.get(c.dataId),[T,N]=[[w.complexTensorInfos.real,b.complexTensorInfos.real],[w.complexTensorInfos.imag,b.complexTensorInfos.imag]].map(U=>{const[J,ht]=U,Tt={dataId:J.dataId,dtype:J.dtype,shape:u.shape},Pt={dataId:ht.dataId,dtype:ht.dtype,shape:c.shape},zt=new ef(t,u.shape,c.shape);return d.runWebGLProgram(zt,[Tt,Pt],(0,g.upcastType)(J.dtype,ht.dtype))}),S=fd({inputs:{real:T,imag:N},backend:d});return d.disposeIntermediateTensorInfo(T),d.disposeIntermediateTensorInfo(N),S}const p=s||(0,g.upcastType)(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=i){const w=d.texData.get(u.dataId).values,b=d.texData.get(c.dataId).values,T="string"===u.dtype?g.backend_util.fromUint8ToStringArray(w):w,N="string"===u.dtype?g.backend_util.fromUint8ToStringArray(b):b,[S,U]=i(u.shape,c.shape,T,N,p),J=d.makeTensorInfo(U,p);return d.texData.get(J.dataId).values=S,J}let x;return x=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Gp(n,u.shape,c.shape,e):new ef(t,u.shape,c.shape),d.runWebGLProgram(x,[u,c],p)}}function ty(t,n=!1){if("linear"===t)return n?A0t:I0t;if("relu"===t)return n?P0t:D0t;if("elu"===t)return n?M0t:S0t;if("relu6"===t)return n?O0t:T0t;if("prelu"===t)return n?Rz:Oz;if("leakyrelu"===t)return n?Pz:Mz;if("sigmoid"===t)return n?R0t:N0t;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class Lz{constructor(n,e,r,i=!1,s=!1,o=!1,a=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Lu(this.outputShape.length);const p=Math.ceil((i?n[1]:n[2])/2),v=i?"i * 2, rc.y":"rc.y, i * 2",x=s?"rc.z, i * 2":"i * 2, rc.z",w=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],b=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let T="",N="";a&&(T=u?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,N="result = activation(result);");const S=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let U="rc.x",J="rc.x";n[0]<e[0]?U=`imod(rc.x, ${n[0]})`:e[0]<n[0]&&(J=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${T}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${p}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${U};\n        int batchB = ${J};\n        for (int i = 0; i < ${p}; i++) {\n          vec4 a = getMatrixA(batchA, ${v});\n          vec4 b = getMatrixB(batchB, ${x});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${w[0]} * ${b[0]});\n          result += (${w[1]} * ${b[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${S}\n\n        ${N}\n\n        setOutput(result);\n      }\n    `}}const kz={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Fz{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=g.backend_util.assertAndGetBroadcastShape(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${n}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const $z="return a * b;";function mS(t){const{inputs:n,backend:e}=t,{a:r,b:i}=n,s=g.backend_util.upcastType(r.dtype,i.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),u=e.texData.get(i.dataId),c=new Fz(kz.REAL,r.shape,i.shape),d=new Fz(kz.IMAG,r.shape,i.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:i.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:i.shape}],v=e.runWebGLProgram(c,p,"float32"),x=e.runWebGLProgram(d,p,"float32"),w=fd({inputs:{real:v,imag:x},backend:e});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),w}if(e.shouldExecuteOnCPU([r,i])){const a=e.texData.get(r.dataId),u=e.texData.get(i.dataId),[c,d]=Xyt(r.shape,i.shape,a.values,u.values,s),p=e.makeTensorInfo(d,s);return e.texData.get(p.dataId).values=c,p}let o;return o=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gp($z,r.shape,i.shape):new ef($z,r.shape,i.shape),e.runWebGLProgram(o,[r,i],s)}const J0t={kernelName:g.Multiply,backendName:"webgl",kernelFunc:mS};function Ln(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{shape:s}=r,o=e,a=g.util.sizeFromShape(i.shape),u=g.util.inferFromImplicitShape(s,a),c=g.util.sizeFromShape(u);g.util.assert(a===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(i.dataId);return!d.isPacked||f1(i.shape,u)||null!==d.texture&&f1(d.shape,u)?(o.incRef(i.dataId),{dataId:i.dataId,shape:u,dtype:i.dtype}):function tvt(t,n,e){const r=[$p(t.shape),...Bp(t.shape)],i={dtype:t.dtype,shape:r,dataId:t.dataId},s=[$p(n),...Bp(n)],o=new Sz(s,r),c=e.runWebGLProgram(o,[i],t.dtype,[r],!0);return{dataId:c.dataId,shape:n,dtype:c.dtype}}(i,u,o)}const evt={kernelName:g.Reshape,backendName:"webgl",kernelFunc:Ln};class Bz{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:o}=n;this.outputShape=[i,o];const a=4*Math.floor(r/4),u=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const p=1/e;c=`sumValue += dot(values * ${g.util.isInt(p)?p.toPrecision(2):p}, ones);`}let d="";s%r>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class nvt{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:o}=n;this.outputShape=[i,o];let a="0.0",u="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",u="min"):"max"===e&&(a="-1.0 / 1e-20",u="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const d=4*Math.floor(r/4),p=r%4;let v=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${u}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${u}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,x="vec4";"all"===e?(a="1.0",v="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",x="bvec4"):"any"===e&&(a="0.0",v="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",x="bvec4");let w="";s%r>0&&(w=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${w}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${v}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===p}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${v}\n        } else if (${2===p}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${v}\n        } else if (${3===p}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${v}\n        }\n        setOutput(${c});\n      }\n    `}}function rf(t,n,e,r){const i=function rvt(t){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const e=n.length?n[n.length-1].outSize:t[1],r=g.backend_util.computeOptimalWindowSize(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}(t.shape);let s=t;for(let o=0;o<i.length;o++){const{inSize:a,windowSize:u,outSize:c}=i[o];let d,p;d="mean"===e?0===o?new Bz({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c},a):new Bz({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c}):new nvt({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c},e),p=s,s=r.runWebGLProgram(d,[s],n),p.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(p)}return s}class ivt{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let o=0;o<r.length;o++)r[o]=n[e[o]];this.outputShape=r,this.rank=r.length;const i=ao(this.rank),s=function svt(t){const n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let i=0;i<t.length;i++)r[t[i]]=e[i];return r.join()}(e);this.userCode=`\n    void main() {\n      ${i} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class ovt{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(n.length);for(let d=0;d<r.length;d++)r[d]=n[e[d]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=ao(this.rank),s=Iz("rc",this.rank),o=new Array(this.rank);for(let d=0;d<e.length;d++)o[e[d]]=s[d];const a=`vec2(${o.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${u}) {\n        result[1] = ${c};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${u}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function _1(t,n,e){const r=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ovt(t.shape,n):new ivt(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function x1(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;return function avt(t,n,e,r){const s=t.shape.length,o=g.util.parseAxisParam(n,t.shape);let a=o;const u=g.backend_util.getAxesPermutation(a,s),c=null!=u;let d=t;c&&(d=_1(t,u,r),a=g.backend_util.getInnerMostAxes(a.length,s)),g.backend_util.assertAxesAreInnerMostDims("sum",a,s);const[p,v]=g.backend_util.computeOutAndReduceShapes(d.shape,a);let x=p;e&&(x=g.backend_util.expandShapeToKeepDim(p,o));const w=g.util.sizeFromShape(v),N=Ln({inputs:{x:d},attrs:{shape:[g.util.sizeFromShape(t.shape)/w,w]},backend:r}),U=rf(N,(0,g.sumOutType)(t.dtype),"sum",r),J=Ln({inputs:{x:U},attrs:{shape:x},backend:r});return r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(U),c&&r.disposeIntermediateTensorInfo(d),J}(i,s,o,e)}const uvt={kernelName:g.Sum,backendName:"webgl",kernelFunc:x1};function Zu(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{perm:s}=r,o=e,u=new Array(i.shape.length);for(let d=0;d<u.length;d++)u[d]=i.shape[s[d]];let c;if(o.shouldExecuteOnCPU([i])){const p=o.texData.get(i.dataId).values,v=fS(p,i.shape,i.dtype,s,u);c=o.makeTensorInfo(u,i.dtype),o.texData.get(c.dataId).values=v}else c=_1(i,s,o);return c}const lvt={kernelName:g.Transpose,backendName:"webgl",kernelFunc:Zu},zz=1e3;function E1({a:t,b:n,transposeA:e,transposeB:r,backend:i,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:u=null}){const c=t.shape.length,d=n.shape.length,p=e?t.shape[c-2]:t.shape[c-1],v=r?n.shape[d-1]:n.shape[d-2],x=e?t.shape[c-1]:t.shape[c-2],w=r?n.shape[d-2]:n.shape[d-1],b=t.shape.slice(0,-2),T=n.shape.slice(0,-2),N=g.util.sizeFromShape(b),S=g.util.sizeFromShape(T),J=g.broadcast_util.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([x,w]);g.util.assert(p===v,()=>`Error in matMul: inner shapes (${p}) and (${v}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);const ht=e?[N,p,x]:[N,x,p],Tt=r?[S,w,v]:[S,v,w],Pt=Ln({inputs:{x:t},backend:i,attrs:{shape:ht}}),zt=Ln({inputs:{x:n},backend:i,attrs:{shape:Tt}}),Ot=[Pt,zt],le=Math.max(N,S),ge=e?Pt.shape[1]:Pt.shape[2],Ae=null!=s,Re=null!=o,ve="leakyrelu"===u,Ne=null!=u?ty(u,!0):null;let Ke;if((1===x||1===w)&&ge>zz&&!1===(Ae||Re||ve||null!=Ne)){let Be=Pt,on=zt;e&&(Be=Zu({inputs:{x:Pt},backend:i,attrs:{perm:[0,2,1]}}),Ot.push(Be)),r&&(on=Zu({inputs:{x:zt},backend:i,attrs:{perm:[0,2,1]}}),Ot.push(on));const pn=1===w;let Qe=Be;1!==w&&(Qe=Ln({inputs:{x:Be},backend:i,attrs:{shape:[le,ge,1]}}),Ot.push(Qe));const gn=1===w?2:1;let dn=on;pn&&(dn=Ln({inputs:{x:on},backend:i,attrs:{shape:[le,1,ge]}}),Ot.push(dn));const kn=mS({inputs:{a:Qe,b:dn},backend:i});Ke=x1({inputs:{x:kn},backend:i,attrs:{axis:gn,keepDims:!0}}),Ot.push(kn)}else{const Be=(0,g.upcastType)(t.dtype,n.dtype),on=new Lz(ht,Tt,[le,x,w],e,r,Ae,Ne,Re,ve),rn=[Pt,zt];if(null!=s&&rn.push(s),Re&&rn.push(o),ve){const pn=i.makeTensorInfo([],"float32",g.util.createScalarValue(a,"float32"));rn.push(pn),Ot.push(pn)}Ke=i.runWebGLProgram(on,rn,Be)}const Le=Ln({inputs:{x:Ke},backend:i,attrs:{shape:J}});Ot.push(Ke);for(const Be of Ot)i.disposeIntermediateTensorInfo(Be);return Le}const hvt={kernelName:g._FusedMatMul,backendName:"webgl",kernelFunc:function cvt(t){const{inputs:n,backend:e,attrs:r}=t,{a:i,b:s,bias:o,preluActivationWeights:a}=n,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=r;return E1({a:i,b:s,transposeA:u,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:p,activation:d})}},Vz="return abs(x);",fvt={kernelName:g.Abs,backendName:"webgl",kernelFunc:function dvt(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const s=e.texData.get(r.dataId),o=wz(s.values);return e.makeTensorInfo(r.shape,r.dtype,o)}let i;return i=(0,g.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new dd(r.shape,Vz):new oh(r.shape,Vz),e.runWebGLProgram(i,[r],r.dtype)}},mvt=gs({opSnippet:Wl+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),gvt={kernelName:g.Acos,backendName:"webgl",kernelFunc:mvt},vvt=gs({opSnippet:Wl+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),_vt={kernelName:g.Acosh,backendName:"webgl",kernelFunc:vvt},Uz="return a + b;",xvt=Cu({opSnippet:Uz,packedOpSnippet:Uz,supportsComplex:!0,cpuKernelImpl:Dyt}),Evt={kernelName:g.Add,backendName:"webgl",kernelFunc:xvt};class Cvt{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${i};\n        setOutput(result);\n      }\n    `}}class wvt{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${i};\n        setOutput(result);\n      }\n    `}}const bvt={kernelName:g.AddN,backendName:"webgl",kernelFunc:function C1(t){const{inputs:n,backend:e}=t,r=n;if(1===r.length)return bl({inputs:{x:r[0]},backend:e});if(r.length>(0,g.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),c=C1({inputs:r.slice(0,u),backend:e}),d=C1({inputs:r.slice(u),backend:e});return C1({inputs:[c,d],backend:e})}const i=r.map(u=>u.dtype).reduce((u,c)=>(0,g.upcastType)(u,c)),s=r.map(u=>u.shape),a=(0,g.env)().getBool("WEBGL_PACK")?new wvt(r[0].shape,s):new Cvt(r[0].shape,s);return e.runWebGLProgram(a,r,i)}},Svt={kernelName:g.All,backendName:"webgl",kernelFunc:function Ivt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=i.shape.length,u=g.util.parseAxisParam(s,i.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a);let p=i;null!=d&&(p=Zu({inputs:{x:i},backend:e,attrs:{perm:d}}),c=g.backend_util.getInnerMostAxes(c.length,a)),g.backend_util.assertAxesAreInnerMostDims("all",c,a);const[v,x]=g.backend_util.computeOutAndReduceShapes(p.shape,c),b=Ln({inputs:{x:p},backend:e,attrs:{shape:[-1,g.util.sizeFromShape(x)]}}),T=rf(b,b.dtype,"all",e);let N;return N=Ln(o?{inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(v,u)}}:{inputs:{x:T},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(T),null!=d&&e.disposeIntermediateTensorInfo(p),N}},Tvt={kernelName:g.Any,backendName:"webgl",kernelFunc:function Dvt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=i.shape.length,u=g.util.parseAxisParam(s,i.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a);let p=i;null!=d&&(p=Zu({inputs:{x:i},backend:e,attrs:{perm:d}}),c=g.backend_util.getInnerMostAxes(c.length,a)),g.backend_util.assertAxesAreInnerMostDims("any",c,a);const[v,x]=g.backend_util.computeOutAndReduceShapes(p.shape,c),b=Ln({inputs:{x:p},backend:e,attrs:{shape:[-1,g.util.sizeFromShape(x)]}}),T=rf(b,b.dtype,"any",e);let N;return N=Ln(o?{inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(v,u)}}:{inputs:{x:T},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(T),null!=d&&e.disposeIntermediateTensorInfo(p),N}};class Nvt{constructor(n,e,r){this.variableNames=["A"];const{windowSize:i,batchSize:s,outSize:o}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Avt{constructor(n,e,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,g.util.assert(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(n[n.length-1]/e);this.outputShape=n.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,c=ao(u),d=Xu("coords",u);let p,v;if(1===o){v=u+1;const zt=ao(v);p=`\n        ${zt} sourceLocR = ${zt}(${d.join()}, 0);\n        ++${d[u-1]};\n        ${zt} sourceLocG = ${zt}(${d.join()}, 0);\n        ++${d[u-2]};\n        ${zt} sourceLocA = ${zt}(${d.join()}, 0);\n        --${d[u-1]};\n        ${zt} sourceLocB = ${zt}(${d.join()}, 0);\n        --${d[u-2]};`}else v=u,p=`\n        ${c} sourceLocR = coords;\n        ++${d[u-1]};\n        ${c} sourceLocG = coords;\n        ++${d[u-2]};\n        ${c} sourceLocA = coords;\n        --${d[u-1]};\n        ${c} sourceLocB = coords;\n        --${d[u-2]};`;const x=["x","y","z","w","u","v"].slice(0,v),w="."+x[v-1],b=x.map(zt=>"int "+zt),T=Xu("sourceLocR",v-1).concat("inIdx.r"),N=Xu("sourceLocG",v-1).concat("inIdx.g"),S=Xu("sourceLocB",v-1).concat("inIdx.b"),U=Xu("sourceLocA",v-1).concat("inIdx.a"),J="max"===r?"greaterThan":"lessThan",ht=i?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${T.join()}),\n                             getBestIndicesAChannel(${N.join()}),\n                             getBestIndicesAChannel(${S.join()}),\n                             getBestIndicesAChannel(${U.join()})));`,Tt=`vec4(\n            getAChannel(${T.join()}),\n            hasNextCol ? getAChannel(${N.join()}) : 0.,\n            hasNextRow ? getAChannel(${S.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${U.join()}) : 0.)`,Pt=i?"":`\n      float getBestIndicesAChannel(${b.join()}) {\n        return getChannel(getBestIndicesA(${x.join()}),\n                                          vec2(${x.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${b.join()}) {\n        return getChannel(getA(${x.join()}),\n                               vec2(${x.slice(-2).join()}));\n      }\n      ${Pt}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${d[u-1]} < ${a[u-1]-1};\n        bool hasNextRow = ${d[u-2]} < ${a[u-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${w}, sourceLocG${w},\n          sourceLocB${w}, sourceLocA${w}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${Tt};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${ht}\n          vec4 candidate = ${Tt};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${J}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Wz(t,n,e,r=null){let i=n.shape[0],s=n.shape[1];null!=r&&(i=r.shape[0],s=r.shape[1]);const o=g.backend_util.computeOptimalWindowSize(s),a={windowSize:o,inSize:s,batchSize:i,outSize:Math.ceil(s/o)},u=new Nvt(a,e,null==r),c=[n];null!=r&&c.push(r);const d=t.runWebGLProgram(u,c,"int32");if(1===d.shape[1])return d;const p=Wz(t,n,e,d);return t.disposeIntermediateTensorInfo(d),p}function Gz(t,n,e,r=null){const i=null!=r?r.shape:n.shape,o=g.backend_util.computeOptimalWindowSize(i[i.length-1]),a=new Avt(i,o,e,null==r),c=t.runWebGLProgram(a,null==r?[n]:[n,r],"int32");if(c.shape.length===n.shape.length){const d=Gz(t,n,e,c);return t.disposeIntermediateTensorInfo(c),d}return c}function Hz(t,n,e,r){const i=[e];if(g.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,n.shape.length),!(0,g.env)().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const s=[],o=t.texData.get(n.dataId);let u=n;null!==o&&o.isPacked&&(u=t.unpackTensor(n),s.push(u));const[c,d]=g.backend_util.computeOutAndReduceShapes(u.shape,i),p=g.util.sizeFromShape(d),v=Ln({inputs:{x:u},backend:t,attrs:{shape:[-1,p]}});s.push(v);const x=Wz(t,v,r);s.push(x);const w=Ln({inputs:{x},backend:t,attrs:{shape:c}});return s.forEach(b=>t.disposeIntermediateTensorInfo(b)),w}return Gz(t,n,r)}const Pvt={kernelName:g.ArgMax,backendName:"webgl",kernelFunc:function Mvt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s}=r;let o=g.util.parseAxisParam(s,i.shape);const a=g.backend_util.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=a&&(u=Zu({inputs:{x:i},backend:e,attrs:{perm:a}}),c.push(u),o=g.backend_util.getInnerMostAxes(o.length,u.shape.length)),g.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);const d=Hz(e,u,o[0],"max");return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}},Rvt={kernelName:g.ArgMin,backendName:"webgl",kernelFunc:function Ovt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s}=r;let o=g.util.parseAxisParam(s,i.shape);const a=g.backend_util.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=a&&(u=Zu({inputs:{x:i},backend:e,attrs:{perm:a}}),c.push(u),o=g.backend_util.getInnerMostAxes(o.length,u.shape.length)),g.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);const d=Hz(e,u,o[0],"min");return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}},kvt=gs({opSnippet:Wl+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Fvt={kernelName:g.Asin,backendName:"webgl",kernelFunc:kvt},Bvt=gs({opSnippet:Wl+"return log(x + sqrt(x * x + 1.0));"}),zvt={kernelName:g.Asinh,backendName:"webgl",kernelFunc:Bvt},Uvt=gs({opSnippet:Wl+"\n  return atan(x);\n"}),Wvt={kernelName:g.Atan,backendName:"webgl",kernelFunc:Uvt},jvt=Cu({opSnippet:pS+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nf+"\n  return result;\n"}),Kvt={kernelName:g.Atan2,backendName:"webgl",kernelFunc:jvt},Zvt=gs({opSnippet:Wl+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Yvt={kernelName:g.Atanh,backendName:"webgl",kernelFunc:Zvt};class ey{constructor(n,e,r,i=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=n.filterWidth,a=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,d=n.dilationWidth,p=n.effectiveFilterHeight,v=n.effectiveFilterWidth,x=n.padInfo.top,w=n.padInfo.left;this.outputShape=n.outShape;const b="avg"===e;let S="0.0";if(b||(S="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${u});\n        const ivec2 pads = ivec2(${x}, ${w});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${p};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v};\n                wC += ${d}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?s?`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`:`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`:`wR * ${v} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let J=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(J="avgValue / max(count, 1.0)");const ht=4*Math.floor(o/4),Tt=o%4,Pt=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${u});\n      const ivec2 pads = ivec2(${x}, ${w});\n      const float initializationValue = ${S};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${S});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${ht}; wC += 4) {\n            int xC = xCCorner + wC * ${d};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              getValue(batch, xR, xC + 2 * ${d}, d),\n              getValue(batch, xR, xC + 3 * ${d}, d)\n            );\n\n            ${Pt}\n          }\n\n          int xC = xCCorner + ${ht};\n          if (${1===Tt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${Pt}\n          } else if (${2===Tt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${Pt}\n          } else if (${3===Tt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              getValue(batch, xR, xC + 2 * ${d}, d),\n              initializationValue\n            );\n\n            ${Pt}\n          }\n        }\n        setOutput(${J});\n      }\n    `}}class gS{constructor(n,e,r,i=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=n.filterWidth,a=n.strideDepth,u=n.strideHeight,c=n.strideWidth,d=n.dilationDepth,p=n.dilationHeight,v=n.dilationWidth,x=n.effectiveFilterDepth,w=n.effectiveFilterHeight,b=n.effectiveFilterWidth,T=n.padInfo.front,N=n.padInfo.top,S=n.padInfo.left;this.outputShape=n.outShape;const U="avg"===e;let J="0.0";if(U||(J="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${u}, ${c});\n        const ivec3 pads = ivec3(${T}, ${N}, ${S});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${x};\n              wD += ${d}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${w};\n                wR += ${p}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${b};\n                  wC += ${v}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?s?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${w} * ${b} +\n                      wR * ${b} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let Tt=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(Tt="avgValue / max(count, 1.0)");const Pt=4*Math.floor(o/4),zt=o%4,Ot=`\n      if (${U}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${u}, ${c});\n      const ivec3 pads = ivec3(${T}, ${N}, ${S});\n      const float initializationValue = ${J};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${J});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${x};\n            wD += ${d}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${w};\n            wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${Pt}; wC += 4) {\n              int xC = xCCorner + wC * ${v};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${v}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${v}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${v}, ch)\n              );\n\n              ${Ot}\n            }\n\n            int xC = xCCorner + ${Pt};\n            if (${1===zt}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${Ot}\n            } else if (${2===zt}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${v}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${Ot}\n            } else if (${3===zt}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${v}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${v}, ch),\n                initializationValue\n              );\n\n              ${Ot}\n            }\n          }\n        }\n        setOutput(${Tt});\n      }\n    `}}const Qvt={kernelName:g.AvgPool,backendName:"webgl",kernelFunc:function qvt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;Qg(i,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=g.backend_util.computePool2DInfo(i.shape,s,o,1,a,u);if(1===d.filterWidth&&1===d.filterHeight&&g.util.arraysEqual(d.inShape,d.outShape))return bl({inputs:{x:i},backend:e});const p=new ey(d,"avg",!1);return e.runWebGLProgram(p,[i],"float32")}},t_t={kernelName:g.AvgPool3D,backendName:"webgl",kernelFunc:function Jvt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{filterSize:s,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r,p=g.backend_util.computePool3DInfo(i.shape,s,o,[1,1,1],a,u,c),v=new gS(p,"avg",!1);return e.runWebGLProgram(v,[i],"float32")}};class e_t{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const u=n.effectiveFilterHeight,c=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${u-1-n.padInfo.top}, ${c-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${u};\n            wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${n.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class n_t{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const p=n.effectiveFilterDepth,v=n.effectiveFilterHeight,x=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${p-1-n.padInfo.front}, ${v-1-n.padInfo.top}, ${x-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterDepth*n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${v};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${x};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const i_t={kernelName:g.AvgPool3DGrad,backendName:"webgl",kernelFunc:function r_t(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,o=s,{filterSize:a,strides:u,pad:c,dimRoundingMode:d}=r,v=g.backend_util.computePool3DInfo(o.shape,a,u,[1,1,1],c,d),x=new n_t(v);return e.runWebGLProgram(x,[i],o.dtype)}},o_t={kernelName:g.AvgPoolGrad,backendName:"webgl",kernelFunc:function s_t(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,o=s;Qg([i,s],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,d=g.backend_util.computePool2DInfo(o.shape,a,u,1,c),p=new e_t(d);return e.runWebGLProgram(p,[i],o.dtype)}},u_t={kernelName:g.BatchMatMul,backendName:"webgl",kernelFunc:function a_t(t){const{inputs:n,backend:e,attrs:r}=t,{a:i,b:s}=n,{transposeA:o,transposeB:a}=r;return E1({a:i,b:s,transposeA:o,transposeB:a,backend:e})}};class l_t{constructor(n,e,r,i,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],g.backend_util.assertAndGetBroadcastShape(n,e),g.backend_util.assertAndGetBroadcastShape(n,r);let a="0.0";null!=i&&(g.backend_util.assertAndGetBroadcastShape(n,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";null!=s&&(g.backend_util.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class c_t{constructor(n,e,r,i,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],g.backend_util.assertAndGetBroadcastShape(n,e),g.backend_util.assertAndGetBroadcastShape(n,r);let a="vec4(0.0)";null!=i&&(g.backend_util.assertAndGetBroadcastShape(n,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=s&&(g.backend_util.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const d_t={kernelName:g.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,mean:i,variance:s,offset:o,scale:a}=t;g.util.assert(i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),g.util.assert(null==o||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),g.util.assert(null==a||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;null==u&&(u=.001);const c=[r,i,s];let d=null;null!=o&&(d=o.shape,c.push(o));let p=null;null!=a&&(p=a.shape,c.push(a));const v=(0,g.env)().getBool("WEBGL_PACK_NORMALIZATION")?new c_t(r.shape,i.shape,s.shape,d,p,u):new l_t(r.shape,i.shape,s.shape,d,p,u);return n.runWebGLProgram(v,c,c[0].dtype)}};class f_t{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const e=ao(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function p_t(t){if(1===t)return"sourceLoc";if(t<=6)return yS.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let i;i=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${n.map((o,a)=>`sourceLoc.${yS[a]} = start[${a}] + coords.${yS[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${i}\n        setOutput(getSource(${r}));\n      }\n    `}}const yS=["x","y","z","w","u","v"];class m_t{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=ao(this.rank),r=Xu("coords",this.rank),i=Xu("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${s})`,a=`\n      result.x = ${o};\n      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${o};\n        --${i[this.rank-1]};\n      }\n    `,u=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${o};\n        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${n.map((d,p)=>`start[${p}]`).join()});`:n.map((d,p)=>`${i[p]} = ${r[p]} + start[${p}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${u}\n        setOutput(result);\n      }\n    `}}function jp(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{begin:s,size:o}=r,[a,u]=g.slice_util.parseSliceParams(i,s,o);if(g.slice_util.assertParamsValid(i,a,u),0===g.util.sizeFromShape(u))return e.makeTensorInfo(u,i.dtype,[]);if(e.shouldExecuteOnCPU([i])||"string"===i.dtype){const p=e.texData.get(i.dataId),v=s0t(p.values,a,u,i.shape,i.dtype);return e.makeTensorInfo(u,i.dtype,v)}const{isPacked:c}=e.texData.get(i.dataId),d=g.slice_util.isSliceContinous(i.shape,a,u);if(c||!d){const p=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new m_t(u):new f_t(u);return e.runWebGLProgram(p,[i],i.dtype,[a])}return e.uploadToGPU(i.dataId),function g_t(t,n,e,r){const i=r.texData.get(t.dataId),s=r.makeTensorInfo(e,t.dtype),o=r.texData.get(s.dataId);Object.assign(o,i),o.refCount=1,o.shape=e,o.dtype=t.dtype;let a=g.slice_util.computeFlatOffset(n,g.util.computeStrides(t.shape));i.slice&&(a+=i.slice.flatOffset),o.slice={flatOffset:a,origDataId:i.slice&&i.slice.origDataId||t.dataId};const u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),s}(i,a,u,e)}const y_t={kernelName:g.Slice,backendName:"webgl",kernelFunc:jp},__t={kernelName:g.BatchToSpaceND,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockShape:s,crops:o}=r;g.util.assert(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((S,U)=>S*U),u=g.backend_util.getReshaped(i.shape,s,a),c=g.backend_util.getPermuted(u.length,s.length),d=g.backend_util.getReshapedPermuted(i.shape,s,a),p=g.backend_util.getSliceBeginCoords(o,s.length),v=g.backend_util.getSliceSize(d,o,s.length),x=[],w=Ln({inputs:{x:i},backend:e,attrs:{shape:u}}),b=Zu({inputs:{x:w},backend:e,attrs:{perm:c}}),T=Ln({inputs:{x:b},backend:e,attrs:{shape:d}}),N=jp({inputs:{x:T},backend:e,attrs:{begin:p,size:v}});return x.push(w),x.push(b),x.push(T),x.forEach(S=>e.disposeIntermediateTensorInfo(S)),N}},E_t={kernelName:g.Bincount,backendName:"webgl",kernelFunc:function x_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,weights:s}=n,{size:o}=r,a=e.readSync(i.dataId),u=e.readSync(s.dataId),c=Cz(a,u,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,c)}},I_t={kernelName:g.BitwiseAnd,backendName:"webgl",kernelFunc:function b_t(t){const{inputs:n,backend:e}=t,{a:r,b:i}=n,s=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=(0,g.env)().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([r,i])||1===o){const u=e.texData.get(r.dataId).values,c=e.texData.get(i.dataId).values,[d,p]=Nyt(r.shape,i.shape,u,c,r.dtype),v=e.makeTensorInfo(p,r.dtype);return e.texData.get(v.dataId).values=d,v}let a;return a=s?new Gp("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,i.shape,!1):new ef("\n  return float(int(a.r) & int(b.r));\n",r.shape,i.shape),e.runWebGLProgram(a,[r,i],r.dtype)}},D_t={kernelName:g.BroadcastArgs,backendName:"webgl",kernelFunc:function S_t(t){const{inputs:n,backend:e}=t,{s0:r,s1:i}=n,s=e.readSync(r.dataId),o=e.readSync(i.dataId),a=g.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},jz=Cu({opSnippet:"return float(a != b);",cpuKernelImpl:Yyt,dtype:"bool"}),T_t={kernelName:g.NotEqual,backendName:"webgl",kernelFunc:jz};function ny(t){const{inputs:n,backend:e}=t,{input:r}=n;return bl({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const N_t={kernelName:g.Real,backendName:"webgl",kernelFunc:ny},P_t={kernelName:g.Cast,backendName:"webgl",kernelFunc:function vS(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===i.dtype)return bl({inputs:{x:i},backend:e});const o=g.zeros(i.shape),a=vS({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),u=fd({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),u}if("complex64"===i.dtype){const o=ny({inputs:{input:i},backend:e}),a=vS({inputs:{x:o},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(o),a}if(!g.util.hasEncodingLoss(i.dtype,s)){const o=bl({inputs:{x:i},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(e.shouldExecuteOnCPU([i])){const o=e.texData.get(i.dataId).values,[a,u,c]=Ayt(o,i.shape,i.dtype,s);return e.makeTensorInfo(a,u,c)}if("int32"===s)return function M_t(t,n){const e=new oh(t.shape,"return float(int(x));"),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,e);if("bool"===s){const o=e.makeTensorInfo([],"bool",g.util.getTypedArrayFromDType("bool",1)),u=jz({inputs:{a:i,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}},Kz="return ceil(x);",O_t=gs({opSnippet:Kz,packedOpSnippet:Kz,cpuKernelImpl:Myt}),R_t={kernelName:g.Ceil,backendName:"webgl",kernelFunc:O_t};class L_t{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class k_t{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const $_t={kernelName:g.ClipByValue,backendName:"webgl",kernelFunc:function F_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{clipValueMin:s,clipValueMax:o}=r;let a;return a=(0,g.env)().getBool("WEBGL_PACK_CLIP")?new k_t(i.shape):new L_t(i.shape),e.runWebGLProgram(a,[i],i.dtype,[[s],[o]])}};class B_t{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Xz(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}const V_t={kernelName:g.ComplexAbs,backendName:"webgl",kernelFunc:function z_t(t){const{inputs:n,backend:e}=t,{x:r}=n,i=e.texData.get(r.dataId),s=new B_t(r.shape),o=[Xz(r,i.complexTensorInfos.real),Xz(r,i.complexTensorInfos.imag)];return e.runWebGLProgram(s,o,o[0].dtype)}};class U_t{constructor(n){this.outputShape=[],this.outputShape=g.backend_util.computeOutShape(n,1),this.variableNames=n.map((o,a)=>`T${a}`);const e=new Array(n.length-1);e[0]=n[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+n[o][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)r.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class W_t{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=g.backend_util.computeOutShape(n,e);const r=this.outputShape,i=r.length,s=ao(i),o=Xu("coords",i),a=["x","y","z","w","u","v"].slice(0,i);this.variableNames=n.map((b,T)=>`T${T}`);const u=new Array(n.length-1);u[0]=n[0][e];for(let b=1;b<u.length;b++)u[b]=u[b-1]+n[b][e];const c=a[e],d=a.slice(-2),p=a.join();let v=`if (${c} < ${u[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${d.join()}));\n        }`;for(let b=1;b<u.length;b++){const T=u[b-1];v+=`\n        if (${c} < ${u[b]}  && ${c} >= ${u[b-1]}) {\n          return getChannel(\n            getT${b}(${w1(a,c,T)}),\n            vec2(${w1(d,c,T)}));\n        }`}const w=u[u.length-1];v+=`\n        return getChannel(\n          getT${u.length}(${w1(a,c,w)}),\n          vec2(${w1(d,c,w)}));`,this.userCode=`\n      float getValue(${a.map(b=>"int "+b)}) {\n        ${v}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[i-1]} = ${o[i-1]} + 1;\n        if (${o[i-1]} < ${r[i-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[i-2]} = ${o[i-2]} + 1;\n        if (${o[i-2]} < ${r[i-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[i-1]} = ${o[i-1]} - 1;\n        if (${o[i-2]} < ${r[i-2]} &&\n            ${o[i-1]} < ${r[i-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function w1(t,n,e){const r=t.indexOf(n);return t.map((s,o)=>o===r?`${s} - ${e}`:s).join()}function b1(t){const{inputs:n,backend:e}=t,{input:r}=n;return bl({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const G_t={kernelName:g.Imag,backendName:"webgl",kernelFunc:b1};function ry(t,n,e){const r=t[0].dtype;if("complex64"===r){const x=t.map(S=>ny({inputs:{input:S},backend:e})),w=t.map(S=>b1({inputs:{input:S},backend:e})),b=ry(x,n,e),T=ry(w,n,e),N=fd({inputs:{real:b,imag:T},backend:e});return x.forEach(S=>e.disposeIntermediateTensorInfo(S)),w.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(T),N}let i=e.shouldExecuteOnCPU(t);if("string"===r&&(i=!0),i){const x=t.map(J=>{const Tt=[-1,g.util.sizeFromShape(J.shape.slice(n))];return Ln({inputs:{x:J},backend:e,attrs:{shape:Tt}})}),w=x.map(J=>({vals:e.readSync(J.dataId),shape:J.shape})),b=g.backend_util.computeOutShape(x.map(J=>J.shape),1),N=Pyt(w,b,r,1===x[0].shape[0]),S=g.backend_util.computeOutShape(t.map(J=>J.shape),n),U=e.makeTensorInfo(S,r,N);return x.forEach(J=>e.disposeIntermediateTensorInfo(J)),U}const s=t.filter(x=>g.util.sizeFromShape(x.shape)>0),o=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const x=o?new oh(t[0].shape,hd):new dd(t[0].shape,hd);return e.runWebGLProgram(x,t,r)}const a=(0,g.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){const x=[];for(let b=0;b<s.length;b+=a){const T=s.slice(b,b+a);x.push(ry(T,n,e))}const w=ry(x,n,e);for(const b of x)e.disposeIntermediateTensorInfo(b);return w}if(o){const x=new W_t(s.map(w=>w.shape),n);return e.runWebGLProgram(x,s,r)}const{tensors2D:u,outShape:c}=function H_t(t,n,e){const r=g.backend_util.computeOutShape(t.map(s=>s.shape),n);return{tensors2D:t.map(s=>Ln({inputs:{x:s},attrs:{shape:[-1,g.util.sizeFromShape(s.shape.slice(n))]},backend:e})),outShape:r}}(s,n,e),d=new U_t(u.map(x=>x.shape)),p=e.runWebGLProgram(d,u,r);u.forEach(x=>e.disposeIntermediateTensorInfo(x));const v=Ln({inputs:{x:p},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(p),v}function Zz(t){const{inputs:n,backend:e,attrs:r}=t,{axis:i}=r,s=g.util.parseAxisParam(i,n[0].shape)[0],o=n.map(c=>c.shape);g.backend_util.assertParamsConsistent(o,s);const a=g.backend_util.computeOutShape(n.map(c=>c.shape),s);if(0===g.util.sizeFromShape(a))return e.makeTensorInfo(a,n[0].dtype,[]);const u=n.filter(c=>g.util.sizeFromShape(c.shape)>0);return 1===u.length?bl({inputs:{x:u[0]},backend:e}):ry(u,s,e)}const j_t={kernelName:g.Concat,backendName:"webgl",kernelFunc:Zz};class Yz{constructor(n,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const o=n.padInfo.top,a=n.padInfo.left,u=n.strideHeight,c=n.strideWidth,d=n.dilationHeight,p=n.dilationWidth,v=n.filterHeight,x=n.filterWidth,w=4*Math.floor(n.inChannels/4),b=n.inChannels%4,T="channelsLast"===n.dataFormat,N=T?1:2,S=T?2:3,U=T?3:1;let J="",ht="";r&&(J=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,ht="result = activation(result);");const Tt=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${J}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${U}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${N}], coords[${S}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${v}; wR++) {\n          int xR = xRCorner + wR * ${d};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${w}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${T}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===b}) {\n\n              if (${T}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${w}) *\n                    getW(wR, wC, ${w}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${w}, xR, xC) *\n                    getW(wR, wC, ${w}, d2);\n              }\n\n            } else if (${2===b}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${w}, d2),\n                getW(wR, wC, ${w} + 1, d2)\n              );\n\n              if (${T}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${w}),\n                  getX(batch, xR, xC, ${w} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${w}, xR, xC),\n                  getX(batch, ${w} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===b}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${w}, d2),\n                getW(wR, wC, ${w} + 1, d2),\n                getW(wR, wC, ${w} + 2, d2)\n              );\n\n              if (${T}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${w}),\n                  getX(batch, xR, xC, ${w} + 1),\n                  getX(batch, xR, xC, ${w} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${w}, xR, xC),\n                  getX(batch, ${w} + 1, xR, xC),\n                  getX(batch, ${w} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${Tt}\n        ${ht}\n        setOutput(result);\n      }\n    `}}class K_t{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const e=n.padInfo.front,r=n.padInfo.top,i=n.padInfo.left,s=n.strideDepth,o=n.strideHeight,a=n.strideWidth,u=n.dilationDepth,c=n.dilationHeight,d=n.dilationWidth,p=n.filterDepth,v=n.filterHeight,x=n.filterWidth,w=4*Math.floor(n.inChannels/4),b=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${i});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${p}; wF++) {\n          int xF = xFCorner + wF * ${u};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${v}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC++) {\n              int xC = xCCorner + wC * ${d};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${w}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===b}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${w}) *\n                  getW(wF, wR, wC, ${w}, d2);\n              } else if (${2===b}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${w}),\n                  getX(batch, xF, xR, xC, ${w} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${w}, d2),\n                  getW(wF, wR, wC, ${w} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===b}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${w}),\n                  getX(batch, xF, xR, xC, ${w} + 1),\n                  getX(batch, xF, xR, xC, ${w} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${w}, d2),\n                  getW(wF, wR, wC, ${w} + 1, d2),\n                  getW(wF, wR, wC, ${w} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qz{constructor(n,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Lu(this.outputShape.length);const o=n.padInfo.left,a=n.strideWidth,u=n.dilationWidth,c=n.filterHeight,d=n.filterWidth,p=d;let v="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let T=0;T<d;T++)v+=`\n           vec4 xTexelC${2*T};\n           int xTexelC${2*T}Ready;\n           vec4 xTexelC${2*T+1};\n           int xTexelC${2*T+1}Ready;\n           vec4 xC${T};`;v+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {\n       `;for(let T=0;T<d;T++)v+=`\n           xTexelC${2*T} = vec4(0.0);\n           xTexelC${2*T}Ready = 0;\n           xTexelC${2*T+1} = vec4(0.0);\n           xTexelC${2*T+1}Ready = 0;\n           xC${T} = vec4(0.0);`;v+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let T=0;T<(p+1)/2;T++){const N=2*T;if(v+=`\n           xC = xCCorner + ${N*u};\n           `,1===a){if(N<d&&(o%2==1?(v+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n               `,v+=1===u&&N>0?`\n                 xC${N} = vec4(xTexelC${N-2}.zw, xTexelC${N}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${N} = vec4(previous.zw, xTexelC${N}.xy);\n                   } else {\n                     xC${N} = vec4(0.0, 0.0, xTexelC${N}.xy);\n                   }\n                   `):v+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 xC${N} = xTexelC${N};\n                 `,N+1<d)){const S=o%2==0?g.util.nearestLargerEven(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(v+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${S};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                     xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${N+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${N+1}Ready = 1;\n                   }\n                   `,v+=u>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${N+1} = vec4(previous.zw, xTexelC${N+1}.xy);\n                     } else {\n                      xC${N+1} = vec4(0.0, 0.0, xTexelC${N+1}.xy);\n                     }\n                     `:`\n                     xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.xy);\n                     `):v+=1===S?`\n                     xC${N+1} = xTexelC${N};\n                     `:`\n                     xCOffset = xC + ${S};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                       xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${N+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${N+1}Ready = 1;\n                     }\n\n                     xC${N+1} = xTexelC${N+1};\n                     `}}else N<d&&(o%2==1?(v+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${N+1}Ready == 0) {\n                   xTexelC${N+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${N+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${N+1}Ready = 1;\n                 }\n\n                 xC${N} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);\n               `,N+1<d&&(v+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${N+1} = vec4(xTexelC${N+1}.xy, final.xy);\n                 `)):(v+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                   xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N+1}.zw = vec2(0.);\n                   }\n                   xTexelC${N+1}Ready = 1;\n                 }\n\n                 xC${N} = vec4(\n                   xTexelC${N}.xy, xTexelC${N+1}.xy);\n               `,N+1<d&&(v+=`\n                   xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);\n                 `)));N<d&&(v+=`\n             wTexel = getW(r, ${N}, d1, d2);\n             dotProd += xC${N}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${n.inChannels}) {\n               dotProd += xC${N}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,N+1<d&&(v+=`\n               wTexel = getW(r, ${N+1}, d1, d2);\n               dotProd += xC${N+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${n.inChannels}) {\n                 dotProd += xC${N+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}v+="\n     }\n   ",v+="\n     }\n   ",v+="\n     }\n   ";let x="",w="";r&&(x=i?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,w="result = activation(result);");const b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${x}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${v}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${b}\n         ${w}\n         setOutput(result);\n       }\n     `}}class X_t{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=Lu(this.outputShape.length);const{dataFormat:r}=e,i=Ku(),s="channelsLast"===r,o=s?1:2,a=s?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)c+=`\n          blockIndex = rc.z + ${p};\n          pos = rc.y + ${d};\n\n          ${u}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*d+p}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*d+p}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${i.output} = result;\n      }\n    `}}function I1(t,n){const e=t.length;return e>=3?n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]:!n&&1===e&&t[0]>1?[t[0],1]:null}function Qz({x:t,filter:n,convInfo:e,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const u=t.shape,c=r.texData.get(t.dataId),d=e.inChannels,p=u[0]*u[1]*u[2],v=e.outChannels,x="channelsLast"===e.dataFormat;let T;const N=[];if(null!=s){const J=I1(s.shape,x);null!=J&&(s=Ln({inputs:{x:s},backend:r,attrs:{shape:J}}),N.push(s))}if(null!=i){const J=I1(i.shape,x);null!=J&&(i=Ln({inputs:{x:i},backend:r,attrs:{shape:J}}),N.push(i))}if((1!==p&&1!==v||!(d>zz))&&c.isPacked&&x&&null!=c.texture&&u[2]%2!=0&&g.util.arraysEqual(c.shape.slice(-3),u.slice(-3))){const ht={dataId:t.dataId,shape:[1,u[0]*u[1]*(u[2]+1),e.inChannels],dtype:t.dtype},Tt=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,g.util.assert(f1(c.shape,ht.shape),()=>`packed reshape ${c.shape} to ${ht.shape} isn't free`);const Pt=Ln({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});N.push(Pt);const zt=E1({a:ht,b:Pt,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),Ot=r.texData.get(zt.dataId);g.util.assert(Ot.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=Tt,Ot.shape=e.outShape,T=bl({inputs:{x:zt},backend:r}),T.shape=e.outShape,N.push(zt)}else{const J=e.outHeight*e.outWidth,ht=Ln({inputs:{x:t},backend:r,attrs:{shape:x?[e.batchSize,J,e.inChannels]:[e.batchSize,e.inChannels,J]}}),Tt=Ln({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),Pt=E1({a:x?ht:Tt,b:x?Tt:ht,transposeA:!x,transposeB:!1,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o});T=Ln({inputs:{x:Pt},backend:r,attrs:{shape:e.outShape}}),N.push(ht),N.push(Tt),N.push(Pt)}for(const J of N)r.disposeIntermediateTensorInfo(J);return T}function Jz({x:t,filter:n,convInfo:e,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:p,outHeight:v,dataFormat:x}=e,w="channelsLast"===x,b=u*c*d,T=v*p,N=[e.batchSize,b,T],J=[];if(null!=s){const Le=I1(s.shape,w);null!=Le&&(s=Ln({inputs:{x:s},backend:r,attrs:{shape:Le}}),J.push(s))}if(null!=i){const Le=I1(i.shape,w);null!=Le&&(i=Ln({inputs:{x:i},backend:r,attrs:{shape:Le}}),J.push(i))}const ht=Ln({inputs:{x:n},backend:r,attrs:{shape:[1,b,g.util.sizeFromShape(n.shape)/b]}});J.push(ht);const Tt=new X_t(N,e),zt=r.runWebGLProgram(Tt,[t],"float32",[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),Ot=Ln({inputs:{x:zt},backend:r,attrs:{shape:N}});J.push(zt),J.push(Ot);const le=null!=i,ge=null!=s,Ae="leakyrelu"===a,Re=a?ty(a,!0):null,ve=new Lz(w?Ot.shape:ht.shape,w?ht.shape:Ot.shape,w?[e.batchSize,T,e.outChannels]:[e.batchSize,e.outChannels,T],!0,!1,le,Re,ge,Ae),Ne=w?[Ot,ht]:[ht,Ot];if(i&&Ne.push(i),ge&&Ne.push(s),Ae){const Le=r.makeTensorInfo([],"float32",g.util.createScalarValue(o,"float32"));Ne.push(Le),J.push(Le)}const Se=r.runWebGLProgram(ve,Ne,"float32"),Ke=Ln({inputs:{x:Se},backend:r,attrs:{shape:e.outShape}});J.push(Se);for(const Le of J)r.disposeIntermediateTensorInfo(Le);return Ke}const Y_t={kernelName:g.Conv2D,backendName:"webgl",kernelFunc:function Z_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dataFormat:u,dilations:c,dimRoundingMode:d}=r,p=g.backend_util.convertConv2DDataFormat(u),v=g.backend_util.computeConv2DInfo(i.shape,s.shape,o,c,a,d,!1,p);let x;if(1!==v.filterHeight||1!==v.filterWidth||1!==v.dilationHeight||1!==v.dilationWidth||1!==v.strideHeight||1!==v.strideWidth||"SAME"!==v.padInfo.type&&"VALID"!==v.padInfo.type)if(v.strideWidth<=2&&"channelsLast"===p&&(0,g.env)().getBool("WEBGL_EXP_CONV")){const b=new qz(v);x=e.runWebGLProgram(b,[i,s],"float32",[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]])}else if((0,g.env)().getBool("WEBGL_CONV_IM2COL"))x=Jz({x:i,filter:s,convInfo:v,backend:e});else{const b=new Yz(v);x=e.runWebGLProgram(b,[i,s],"float32")}else x=Qz({x:i,filter:s,convInfo:v,backend:e});const w=Ln({inputs:{x},backend:e,attrs:{shape:v.outShape}});return e.disposeIntermediateTensorInfo(x),w}};class q_t{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===n.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Q_t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,o="channelsLast"===n.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class J_t{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${n.strideDepth} - ${n.padInfo.front};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class t1t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterDepth,r=n.filterHeight,i=n.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-n.padInfo.front}, ${r-1-n.padInfo.top}, ${i-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${n.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${i}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${i} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const n1t={kernelName:g.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function e1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:d}=r,p=g.backend_util.convertConv2DDataFormat(u),v=g.backend_util.computeConv2DInfo(i.shape,d,o,1,a,c,!1,p),x=new q_t(v);return e.runWebGLProgram(x,[i,s],"float32")}};class r1t{constructor(n){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=n.inShape,this.enableShapeUniforms=Lu(this.outputShape.length);const e=n.filterHeight,r=n.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${n.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${n.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const s1t={kernelName:g.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function i1t(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{inputShape:o,strides:a,pad:u,dataFormat:c,dimRoundingMode:d}=r,p=g.backend_util.convertConv2DDataFormat(c),v=g.backend_util.computeConv2DInfo(o,s.shape,a,1,u,d,!1,p);if((0,g.env)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===p){const x=[[v.strideHeight,v.strideWidth]],w=new r1t(v);return e.runWebGLProgram(w,[i,s],"float32",x)}{const x=new Q_t(v);return e.runWebGLProgram(x,[i,s],"float32")}}},a1t={kernelName:g.Conv3D,backendName:"webgl",kernelFunc:function o1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u}=r,c=g.backend_util.computeConv3DInfo(i.shape,s.shape,o,u,a),d=new K_t(c);return e.runWebGLProgram(d,[i,s],"float32")}},l1t={kernelName:g.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function u1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,pad:a,filterShape:u}=r,c=g.backend_util.computeConv3DInfo(i.shape,u,o,1,a),d=new J_t(c);return e.runWebGLProgram(d,[i,s],"float32")}},h1t={kernelName:g.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function c1t(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{pad:o,strides:a,inputShape:u}=r,c=g.backend_util.computeConv3DInfo(u,s.shape,a,1,o),d=new t1t(c);return e.runWebGLProgram(d,[i,s],"float32")}},p1t=gs({opSnippet:Hp+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${nf}\n  return result;\n`}),m1t={kernelName:g.Cos,backendName:"webgl",kernelFunc:p1t},g1t=gs({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),y1t={kernelName:g.Cosh,backendName:"webgl",kernelFunc:g1t};class v1t{constructor(n,e,r,i,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,u,c]=n,[d]=e,[p,v]=r;this.outputShape=[d,p,v,c];const x="bilinear"===i?1:0,[w,b]=[a-1+".0",u-1+".0"],[T,N,S]=p>1?[""+(a-1)/(p-1),"(y2-y1) * height_ratio",`y1*${w} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${w}`],[U,J,ht]=v>1?[""+(u-1)/(v-1),"(x2-x1) * width_ratio",`x1*${b} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${b}`];this.userCode=`\n      const float height_ratio = float(${T});\n      const float width_ratio = float(${U});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${N};\n        float width_scale = ${J};\n\n        float in_y = ${S};\n        if( in_y < 0.0 || in_y > ${w} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${ht};\n        if( in_x < 0.0 || in_x > ${b} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${x} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const x1t={kernelName:g.CropAndResize,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{image:i,boxes:s,boxInd:o}=n,{cropSize:a,method:u,extrapolationValue:c}=r,d=new v1t(i.shape,s.shape,a,u,c);return e.runWebGLProgram(d,[i,s,o],"float32")}};var S1=function(t){return t.Prod="*",t.Sum="+",t}(S1||{});class tV{constructor(n,e,r,i){this.op=n,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=r?this.op===S1.Prod?"1.0":"0.0":`getX(${eV(s,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",d="";r?(c=i?"end != "+(u-1):"end != 0",d=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${u}`:"end >= pow2",d=i?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${ao(s)} coords = getOutputCoords();\n        int end = ${nV(s,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${d};\n          ${nV(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${eV(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function eV(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.x, ${n}.y`;if(3===t)return`${n}.x, ${n}.y, ${n}.z`;if(4===t)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function nV(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.y`;if(3===t)return`${n}.z`;if(4===t)return`${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function rV(t,n,e,r,i,s){const o=n.shape.length,a=g.backend_util.getAxesPermutation([r],o);let u=n;null!=a&&(u=Zu({inputs:{x:n},backend:e,attrs:{perm:a}}));const c=g.backend_util.getInnerMostAxes(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);const d=u.shape[c];let p=bl({inputs:{x:u},backend:e});for(let v=0;v<=Math.ceil(Math.log2(d))-1;v++){const x=new tV(t,u.shape,!1,s),b=p;p=e.runWebGLProgram(x,[p],p.dtype,[[v]]),e.disposeIntermediateTensorInfo(b)}if(i){const v=new tV(t,u.shape,i,s),x=p;p=e.runWebGLProgram(v,[p],p.dtype),e.disposeIntermediateTensorInfo(x)}if(null!=a){const x=Zu({inputs:{x:p},backend:e,attrs:{perm:g.backend_util.getUndoAxesPermutation(a)}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(u),x}return p}const C1t={kernelName:g.Cumprod,backendName:"webgl",kernelFunc:function E1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,exclusive:o,reverse:a}=r;return rV(S1.Prod,i,e,s,o,a)}},b1t={kernelName:g.Cumsum,backendName:"webgl",kernelFunc:function w1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,exclusive:o,reverse:a}=r;return rV(S1.Sum,i,e,s,o,a)}},S1t={kernelName:g.DenseBincount,backendName:"webgl",kernelFunc:function I1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,weights:s}=n,{size:o,binaryOutput:a}=r;if(1===i.shape.length){const u=e.readSync(i.dataId),c=e.readSync(s.dataId),d=Cz(u,c,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,d)}if(2===i.shape.length){const u=e.bufferSync(i),c=e.bufferSync(s),d=Tyt(u,c,o,a);return e.makeTensorInfo(d.shape,s.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}};class D1t{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const N1t={kernelName:g.DepthToSpace,backendName:"webgl",kernelFunc:function T1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockSize:s,dataFormat:o}=r,a=i.shape[0],p=("NHWC"===o?i.shape[1]:i.shape[2])*s,v=("NHWC"===o?i.shape[2]:i.shape[3])*s,x=("NHWC"===o?i.shape[3]:i.shape[1])/(s*s),b=new D1t("NHWC"===o?[a,p,v,x]:[a,x,p,v],s,o);return e.runWebGLProgram(b,[i],i.dtype)}};class iV{constructor(n,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Lu(this.outputShape.length);const o=n.filterHeight,a=n.filterWidth,u=n.outChannels/n.inChannels;let c="",d="";r&&(c=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,d="result = activation(result);");const p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${u};\n        int q = d2 - d1 * ${u};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${d}\n        setOutput(result);\n      }\n    `}}class sV{constructor(n,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Lu(this.outputShape.length);const o=n.outChannels/n.inChannels,a=n.padInfo.left,u=n.strideWidth,c=n.dilationWidth,d=n.filterHeight,p=n.filterWidth,v=p;let x="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let N=0;N<p;N++)x+=`\n          vec4 xTexelC${2*N};\n          int xTexelC${2*N}Ready;\n          vec4 xTexelC${2*N+1};\n          int xTexelC${2*N+1}Ready;\n          vec4 xC${N};`;x+=`\n    for (int r = 0; r < ${d}; r++) {\n      `;for(let N=0;N<p;N++)x+=`\n          xTexelC${2*N} = vec4(0.0);\n          xTexelC${2*N}Ready = 0;\n          xTexelC${2*N+1} = vec4(0.0);\n          xTexelC${2*N+1}Ready = 0;\n          xC${N} = vec4(0.0);`;x+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let N=0;N<(v+1)/2;N++){const S=2*N;if(x+=`\n          xC = xCCorner + ${S*c};\n          `,1===u){if(S<p&&(a%2==1?(x+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {\n                  xTexelC${S} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${S}.zw = vec2(0.0);\n                  }\n                  xTexelC${S}Ready = 1;\n                }\n              `,x+=1===c&&S>0?`\n                xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${S} = vec4(previous.zw, xTexelC${S}.xy);\n                  } else {\n                    xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);\n                  }\n                  `):x+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {\n                  xTexelC${S} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${S}.zw = vec2(0.0);\n                  }\n                  xTexelC${S}Ready = 1;\n                }\n\n                xC${S} = xTexelC${S};\n                `,S+1<p)){const U=a%2==0?g.util.nearestLargerEven(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(x+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${U};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {\n                    xTexelC${S+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${S+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${S+1}Ready = 1;\n                  }\n                  `,x+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);\n                    } else {\n                     xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);\n                    }\n                    `:`\n                    xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);\n                    `):x+=1===U?`\n                    xC${S+1} = xTexelC${S};\n                    `:`\n                    xCOffset = xC + ${U};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {\n                      xTexelC${S+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${S+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${S+1}Ready = 1;\n                    }\n\n                    xC${S+1} = xTexelC${S+1};\n                    `}}else S<p&&(a%2==1?(x+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {\n                  xTexelC${S} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${S}.zw = vec2(0.0);\n                  }\n                  xTexelC${S}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {\n                  xTexelC${S+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${S+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${S+1}Ready = 1;\n                }\n\n                xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);\n              `,S+1<p&&(x+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);\n                `)):(x+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {\n                  xTexelC${S} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${S}.zw = vec2(0.0);\n                  }\n                  xTexelC${S}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {\n                  xTexelC${S+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${S+1}.zw = vec2(0.);\n                  }\n                  xTexelC${S+1}Ready = 1;\n                }\n\n                xC${S} = vec4(\n                  xTexelC${S}.xy, xTexelC${S+1}.xy);\n              `,S+1<p&&(x+=`\n                  xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);\n                `)));S<p&&(x+=`\n            wTexel = getW(r, ${S}, d1, q);\n            dotProd += xC${S} * vec4(wTexel.xz, wTexel.xz);\n          `,S+1<p&&(x+=`\n              wTexel = getW(r, ${S+1}, d1, q);\n              dotProd += xC${S+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}x+="\n    }\n  ",x+="\n      }\n    ";let w="",b="";r&&(w=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,b="result = activation(result);");const T=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${w}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${x}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${T}\n        ${b}\n        setOutput(result);\n      }\n    `}}const M1t={kernelName:g.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function A1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u,dimRoundingMode:c}=r;let d=u;null==d&&(d=[1,1]),g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=g.backend_util.computeConv2DInfo(i.shape,s.shape,o,d,a,c,!0);let v;return v=(0,g.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new sV(p):new iV(p),e.runWebGLProgram(v,[i,s],"float32",[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]])}};class P1t{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${n.outChannels/n.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class O1t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,u=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${u}; dm++) {\n              int d2 = d1 * ${u} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const L1t={kernelName:g.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function R1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,dilations:a,pad:u,dimRoundingMode:c,filterShape:d}=r,p=g.backend_util.computeConv2DInfo(i.shape,d,o,a,u,c,!0),v=new P1t(p);return e.runWebGLProgram(v,[i,s],"float32")}},F1t={kernelName:g.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function k1t(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{strides:o,dilations:a,pad:u,dimRoundingMode:c,inputShape:d}=r,p=g.backend_util.computeConv2DInfo(d,s.shape,o,a,u,c,!0),v=new O1t(p);return e.runWebGLProgram(v,[i,s],"float32")}};class $1t{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const z1t={kernelName:g.Diag,backendName:"webgl",kernelFunc:function B1t(t){const{inputs:n,backend:e}=t,{x:r}=n,i=[...r.shape,...r.shape],s=g.util.sizeFromShape(r.shape),o=Ln({inputs:{x:r},backend:e,attrs:{shape:[s]}}),a=new $1t(s),u=e.runWebGLProgram(a,[o],o.dtype),c=Ln({inputs:{x:u},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(u),c}};class V1t{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:e,inWidth:r,padInfo:i,strideHeight:s,strideWidth:o,filterHeight:a,filterWidth:u,dilationHeight:c,dilationWidth:d}=n,{top:p,left:v}=i;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${p}, ${v});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${u}; w++) {\n              int wIn = wBeg + w * ${d};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const W1t={kernelName:g.Dilation2D,backendName:"webgl",kernelFunc:function U1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u}=r,c=g.backend_util.computeDilation2DInfo(i.shape,s.shape,o,a,"NHWC",u);let d;const p=new V1t(c);d=e.runWebGLProgram(p,[i,s],"float32");const v=Ln({inputs:{x:d},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(d),v}},H1t={kernelName:g.Einsum,backendName:"webgl",kernelFunc:function G1t(t){const{inputs:n,backend:e,attrs:r}=t,{equation:i}=r,s=n,{allDims:o,summedDims:a,idDims:u}=g.backend_util.decodeEinsumEquation(i,s.length);g.backend_util.checkEinsumDimSizes(o.length,u,s);const{path:c,steps:d}=g.backend_util.getEinsumComputePath(a,u),p=d.length;let v=null,x=o.length;const w=[];for(let b=0;b<p;++b){for(const T of d[b]){const{permutationIndices:N,expandDims:S}=g.backend_util.getEinsumPermutation(x,u[T]);let U;g.backend_util.isIdentityPermutation(N)?U=s[T]:(U=Zu({inputs:{x:s[T]},backend:e,attrs:{perm:N}}),w.push(U));const J=U.shape.slice();for(let ht=0;ht<S.length;++ht)J.splice(S[ht],0,1);g.util.arraysEqual(U.shape,J)||(U=Ln({inputs:{x:U},backend:e,attrs:{shape:J}}),w.push(U)),null===v?v=U:(v=mS({inputs:{a:U,b:v},backend:e}),w.push(v))}b<p-1&&(c[b]>=0&&(v=x1({inputs:{x:v},backend:e,attrs:{axis:c[b]-(o.length-x),keepDims:!1}}),w.push(v)),x--)}for(const b of w)b!==v&&e.disposeIntermediateTensorInfo(b);return v}},j1t=gs({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),K1t={kernelName:g.Elu,backendName:"webgl",kernelFunc:j1t},q1t={kernelName:g.EluGrad,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e}=t,{dy:r,y:i}=n,s=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gp("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,i.shape):new ef("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,i.shape);return e.runWebGLProgram(s,[r,i],r.dtype)}},Q1t=Cu({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Oyt}),J1t={kernelName:g.Equal,backendName:"webgl",kernelFunc:Q1t},ext=gs({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${g.backend_util.ERF_P};\n  float a1 = ${g.backend_util.ERF_A1};\n  float a2 = ${g.backend_util.ERF_A2};\n  float a3 = ${g.backend_util.ERF_A3};\n  float a4 = ${g.backend_util.ERF_A4};\n  float a5 = ${g.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),nxt={kernelName:g.Erf,backendName:"webgl",kernelFunc:ext},oV=gs({opSnippet:Hp+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ryt,dtype:"float32"}),ixt={kernelName:g.Exp,backendName:"webgl",kernelFunc:oV};function _S(t){const{inputs:n,attrs:e,backend:r}=t,{dim:i}=e,{input:s}=n,o=s.shape.length,a=s.shape.slice();let u=i;return i<0&&(g.util.assert(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+i+1),a.splice(u,0,1),Ln({inputs:{x:s},backend:r,attrs:{shape:a}})}const sxt={kernelName:g.ExpandDims,backendName:"webgl",kernelFunc:_S},aV="return exp(x) - 1.0;",oxt=gs({opSnippet:aV,packedOpSnippet:aV,cpuKernelImpl:Lyt}),axt={kernelName:g.Expm1,backendName:"webgl",kernelFunc:oxt};class uV{constructor(n,e,r){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${i}.0`:"1.0";let a;if("real"===n)a="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${i});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${i}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function lV(t,n,e){const r=e.texData.get(t.dataId),i=g.util.sizeFromShape(t.shape),s=t.shape[t.shape.length-1],a=Ln({inputs:{x:t},backend:e,attrs:{shape:[i/s,s]}}),u=a.shape,c=new uV("real",u,n),d=new uV("imag",u,n),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],v=e.runWebGLProgram(c,p,"float32"),x=e.runWebGLProgram(d,p,"float32"),w=fd({inputs:{real:v,imag:x},backend:e});e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x);const b=Ln({inputs:{x:w},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(w),b}const lxt={kernelName:g.FFT,backendName:"webgl",kernelFunc:function uxt(t){const{inputs:n,backend:e}=t,{input:r}=n;return lV(r,!1,e)}};class cxt{constructor(n,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function iy(t){const{backend:n,attrs:e}=t,{shape:r,value:i}=e;let{dtype:s}=e;if(s=s||g.util.inferDtype(i),"string"===s){const o=g.util.getArrayFromDType(s,g.util.sizeFromShape(r));return o.fill(i),n.makeTensorInfo(r,s,o)}{const o=new cxt(r,i);return n.runWebGLProgram(o,[],s,[[i]])}}const hxt={kernelName:g.Fill,backendName:"webgl",kernelFunc:iy};class dxt{constructor(n){this.variableNames=["Image"],this.outputShape=[];const e=n[2];this.outputShape=n,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const fxt={kernelName:g.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t,r=n,i=new dxt(e.shape);return r.runWebGLProgram(i,[e],e.dtype)}},cV="return floor(x);",pxt=gs({opSnippet:cV,packedOpSnippet:cV,cpuKernelImpl:kyt}),mxt={kernelName:g.Floor,backendName:"webgl",kernelFunc:pxt},gxt=Cu({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),yxt={kernelName:g.FloorDiv,backendName:"webgl",kernelFunc:gxt};class vxt{constructor(n){this.variableNames=["A"];const e=Ku(),[r,i]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class _xt{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Ku(),[r,i]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${i}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const xxt={kernelName:g.FromPixels,backendName:"webgl",kernelFunc:function Ext(t){const{inputs:n,backend:e,attrs:r}=t;let{pixels:i}=n;const{numChannels:s}=r,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[u,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],d=[c,u],p=[c,u,s];if(a||o){const b=(0,g.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Kp||b!==xS)&&(xS=b,Kp=document.createElement("canvas").getContext("2d",{willReadFrequently:xS})),Kp.canvas.width=u,Kp.canvas.height=c,Kp.drawImage(i,0,0,u,c),i=Kp.canvas}const v=e.makeTensorInfo(d,"int32");e.texData.get(v.dataId).usage=fc.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(v.dataId),i);const x=(0,g.env)().getBool("WEBGL_PACK")?new _xt(p):new vxt(p),w=e.runWebGLProgram(x,[v],"int32");return e.disposeData(v.dataId),w}};let Kp,xS=(0,g.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const wxt={kernelName:g.FusedConv2D,backendName:"webgl",kernelFunc:function Cxt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v,activation:x,leakyreluAlpha:w}=r,b=g.backend_util.convertConv2DDataFormat(d),T=g.backend_util.computeConv2DInfo(i.shape,s.shape,u,p,c,v,!1,b);let N;const S=[],U=null!=o,J=null!=a,ht="leakyrelu"===x,Tt=()=>{const zt=[i,s],Ot=(le,ge)=>{if("NCHW"===ge&&1===le.shape.length&&1!==le.shape[0]){const Ae=Ln({inputs:{x:le},backend:e,attrs:{shape:[le.shape[0],1,1]}});return S.push(Ae),Ae}return le};if(U&&zt.push(Ot(o,d)),J&&zt.push(Ot(a,d)),ht){const le=e.makeTensorInfo([],"float32",g.util.createScalarValue(w,"float32"));zt.push(le),S.push(le)}return zt};if(1!==T.filterHeight||1!==T.filterWidth||1!==T.dilationHeight||1!==T.dilationWidth||1!==T.strideHeight||1!==T.strideWidth||"SAME"!==T.padInfo.type&&"VALID"!==T.padInfo.type)if(T.strideWidth<=2&&"channelsLast"===b&&(0,g.env)().getBool("WEBGL_EXP_CONV")){const zt=x?ty(x,!0):null,Ot=new qz(T,U,zt,J,ht),le=[[T.padInfo.top,T.padInfo.left],[T.strideHeight,T.strideWidth],[T.dilationHeight,T.dilationWidth],[T.inHeight,T.inWidth]],ge=Tt();N=e.runWebGLProgram(Ot,ge,"float32",le)}else if((0,g.env)().getBool("WEBGL_CONV_IM2COL"))N=Jz({x:i,filter:s,convInfo:T,backend:e,bias:o,activation:x,preluActivationWeights:a,leakyreluAlpha:w});else{const zt=x?ty(x,!1):null,Ot=new Yz(T,U,zt,J,ht),le=Tt();N=e.runWebGLProgram(Ot,le,"float32")}else N=Qz({x:i,filter:s,convInfo:T,backend:e,bias:o,activation:x,preluActivationWeights:a,leakyreluAlpha:w});const Pt=Ln({inputs:{x:N},backend:e,attrs:{shape:T.outShape}});return S.push(N),S.forEach(zt=>e.disposeIntermediateTensorInfo(zt)),Pt}},Ixt={kernelName:g.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function bxt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=n,{strides:u,pad:c,dilations:d,dimRoundingMode:p,activation:v,leakyreluAlpha:x}=r,w=[];let b=d;null==b&&(b=[1,1]),g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(u,b),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${b}'`);const T=g.backend_util.computeConv2DInfo(i.shape,s.shape,u,b,c,p,!0),N=(0,g.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&T.strideWidth<=2&&T.outChannels/T.inChannels==1,S=v?ty(v,N):null,U=[i,s],J=null!=o,ht=null!=a,Tt="leakyrelu"===v;if(J&&U.push(o),ht&&U.push(a),Tt){const le=e.makeTensorInfo([],"float32",g.util.createScalarValue(x,"float32"));U.push(le),w.push(le)}let Pt;Pt=N?new sV(T,J,S,ht,Tt):new iV(T,J,S,ht,Tt);const Ot=e.runWebGLProgram(Pt,U,"float32",[[T.padInfo.top,T.padInfo.left],[T.strideHeight,T.strideWidth],[T.dilationHeight,T.dilationWidth],[T.inHeight,T.inWidth]]);return w.forEach(le=>e.disposeIntermediateTensorInfo(le)),Ot}};class Sxt{constructor(n,e,r,i){this.sliceDim=n,this.strides=e,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=r;const s=ao(r.length);let o="\n    int index;";for(let a=0;a<this.sliceDim;a++)o+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const Txt={kernelName:g.GatherNd,backendName:"webgl",kernelFunc:function Dxt(t){const{inputs:n,backend:e}=t,{params:r,indices:i}=n,s=i.shape,o=s[s.length-1],a=g.util.sizeFromShape(r.shape),[u,c,d,p]=g.backend_util.prepareAndValidate(r,i),v=Ln({inputs:{x:i},backend:e,attrs:{shape:[c,o]}}),x=Ln({inputs:{x:r},backend:e,attrs:{shape:[g.util.sizeFromShape(r.shape)/d,d]}});if(e.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const N=e.readSync(i.dataId),S=e.bufferSync(r),U=Fyt(N,S,r.dtype,c,o,d,p,r.shape,a);return e.makeTensorInfo(u,r.dtype,U.values)}const w=new Sxt(o,p,[c,d],r.shape),b=e.runWebGLProgram(w,[x,v],x.dtype),T=Ln({inputs:{x:b},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),T}};class Nxt{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=ao(this.rank),i=function Axt(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<t.length;i++)r.push(2===i?"index":`${e[i]}`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}}function hV(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,indices:s}=n,{axis:o,batchDims:a}=r,u=g.util.parseAxisParam(o,i.shape)[0];if((0,g.env)().get("DEBUG")){const S=e.readSync(s.dataId),U=i.shape[u];for(let J=0;J<S.length;++J){const ht=S[J];g.util.assert(ht<=U-1&&ht>=0,()=>`GatherV2: the index value ${ht} is not in [0, ${U-1}]`)}}const c=g.backend_util.segment_util.collectGatherOpShapeInfo(i,s,u,a),d=g.util.sizeFromShape(s.shape),p=[],v=Ln({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),x=Ln({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,d/c.batchSize]}});p.push(v),p.push(x);const w=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([i,s])||"string"===i.dtype){const S=e.bufferSync(x),U=e.bufferSync(v),J=$yt(U,S,w);return p.forEach(ht=>e.disposeIntermediateTensorInfo(ht)),e.makeTensorInfo(c.outputShape,J.dtype,J.values)}const b=new Nxt(v.shape,w),T=e.runWebGLProgram(b,[v,x],v.dtype);p.push(T);const N=Ln({inputs:{x:T},backend:e,attrs:{shape:c.outputShape}});return p.forEach(S=>e.disposeIntermediateTensorInfo(S)),N}const Mxt={kernelName:g.GatherV2,backendName:"webgl",kernelFunc:hV},Pxt=Cu({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Byt,dtype:"bool"}),Oxt={kernelName:g.Greater,backendName:"webgl",kernelFunc:Pxt},Rxt=Cu({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:zyt}),Lxt={kernelName:g.GreaterEqual,backendName:"webgl",kernelFunc:Rxt},Fxt={kernelName:g.IFFT,backendName:"webgl",kernelFunc:function kxt(t){const{inputs:n,backend:e}=t,{input:r}=n;return lV(r,!0,e)}},$xt=gs({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Bxt={kernelName:g.IsFinite,backendName:"webgl",kernelFunc:$xt},zxt=gs({opSnippet:"return float(isinf(x));",dtype:"bool"}),Vxt={kernelName:g.IsInf,backendName:"webgl",kernelFunc:zxt},Uxt=gs({opSnippet:"return float(isnan(x));",dtype:"bool"}),Wxt={kernelName:g.IsNan,backendName:"webgl",kernelFunc:Uxt},Gxt=Cu({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Vyt,dtype:"bool"}),Hxt={kernelName:g.Less,backendName:"webgl",kernelFunc:Gxt},jxt=Cu({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Uyt,dtype:"bool"}),Kxt={kernelName:g.LessEqual,backendName:"webgl",kernelFunc:jxt},Zxt={kernelName:g.LinSpace,backendName:"webgl",kernelFunc:function Xxt(t){const{backend:n,attrs:e}=t,{start:r,stop:i,num:s}=e,o=Wyt(r,i,s);return n.makeTensorInfo([o.length],"float32",o)}},qxt=gs({opSnippet:Hp+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Gyt}),Qxt={kernelName:g.Log,backendName:"webgl",kernelFunc:qxt},tEt=gs({opSnippet:Hp+"\n  return log(1.0 + x);\n"}),eEt={kernelName:g.Log1p,backendName:"webgl",kernelFunc:tEt},nEt=Cu({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),rEt={kernelName:g.LogicalAnd,backendName:"webgl",kernelFunc:nEt},iEt=gs({opSnippet:"return float(!(x >= 1.0));"}),sEt={kernelName:g.LogicalNot,backendName:"webgl",kernelFunc:iEt},oEt=Cu({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),aEt={kernelName:g.LogicalOr,backendName:"webgl",kernelFunc:oEt};class uEt{constructor(n,e,r,i,s){this.variableNames=["x"],this.outputShape=[];const o=e,a=n[3]-1;let u;this.outputShape=n;const c=`float(${r}) + float(${i}) * sum`;u=.5===s?`inversesqrt(${c})`:1===s?`1.0/(${c})`:`exp(log(${c}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${u};\n        setOutput(val);\n      }\n    `}}class lEt{constructor(n,e,r,i,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=n[3]-1;let u;this.outputShape=n;const c=`float(${r}) + float(${i}) * sum`;u=.5===s?`inversesqrt(${c})`:1===s?`1.0/(${c})`:`exp(log(${c}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${u};\n        setOutput(result);\n      }\n    `}}const hEt={kernelName:g.LRN,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{depthRadius:s,bias:o,alpha:a,beta:u}=r,c=(0,g.env)().getBool("WEBGL_PACK_NORMALIZATION")?new lEt(i.shape,s,o,a,u):new uEt(i.shape,s,o,a,u);return e.runWebGLProgram(c,[i],i.dtype)}};class dEt{constructor(n,e,r,i,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=i,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${i}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${i})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const pEt={kernelName:g.LRNGrad,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i,y:s,dy:o}=n,{depthRadius:a,bias:u,alpha:c,beta:d}=r,p=new dEt(i.shape,a,u,c,d);return e.runWebGLProgram(p,[i,s,o],i.dtype)}};function dV(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{reductionIndices:s,keepDims:o}=r,a=i.shape.length,u=g.util.parseAxisParam(s,i.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a),p=null!=d,v=e.shouldExecuteOnCPU([i]);let x=i;if(p){if(v){const U=e.texData.get(x.dataId).values,J=new Array(a);for(let Pt=0;Pt<J.length;Pt++)J[Pt]=i.shape[d[Pt]];const ht=fS(U,i.shape,i.dtype,d,J);x=e.makeTensorInfo(J,i.dtype),e.texData.get(x.dataId).values=ht}else x=_1(i,d,e);c=g.backend_util.getInnerMostAxes(c.length,a)}g.backend_util.assertAxesAreInnerMostDims("max",c,a);const[w,b]=g.backend_util.computeOutAndReduceShapes(x.shape,c);let N,T=w;if(o&&(T=g.backend_util.expandShapeToKeepDim(w,u)),v){const U=e.texData.get(x.dataId).values,J=Hyt(U,g.util.sizeFromShape(b),T,i.dtype);N=e.makeTensorInfo(T,i.dtype),e.texData.get(N.dataId).values=J}else N=function mEt(t,n,e,r){const i=g.util.sizeFromShape(n),a=Ln({inputs:{x:t},attrs:{shape:[g.util.sizeFromShape(t.shape)/i,i]},backend:r}),u=rf(a,t.dtype,"max",r),c=Ln({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}(x,b,T,e);return p&&e.disposeIntermediateTensorInfo(x),N}const gEt={kernelName:g.Max,backendName:"webgl",kernelFunc:dV},_Et=Cu({opSnippet:pS+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nf+"\n  return result;\n",cpuKernelImpl:jyt}),xEt={kernelName:g.Maximum,backendName:"webgl",kernelFunc:_Et},CEt={kernelName:g.MaxPool,backendName:"webgl",kernelFunc:function EEt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;Qg(i,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=g.backend_util.computePool2DInfo(i.shape,s,o,1,a,u);if(1===d.filterWidth&&1===d.filterHeight&&g.util.arraysEqual(d.inShape,d.outShape))return bl({inputs:{x:i},backend:e});const p=new ey(d,"max",!1);return e.runWebGLProgram(p,[i],i.dtype)}},bEt={kernelName:g.MaxPool3D,backendName:"webgl",kernelFunc:function wEt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{filterSize:s,strides:o,pad:a,dataFormat:u,dimRoundingMode:c}=r,p=g.backend_util.computePool3DInfo(i.shape,s,o,[1,1,1],a,c,u),v=new gS(p,"max",!1);return e.runWebGLProgram(v,[i],i.dtype)}};class IEt{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const s=n.effectiveFilterHeight,o=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${s-1-n.padInfo.top}, ${o-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${s*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SEt{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,d=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${u-1-n.padInfo.front}, ${c-1-n.padInfo.top}, ${d-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n           wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${u*c*d-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${d} +\n                  wR * ${d} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const TEt={kernelName:g.MaxPool3DGrad,backendName:"webgl",kernelFunc:function DEt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,o=s,{filterSize:a,strides:u,pad:c,dimRoundingMode:d}=r,v=g.backend_util.computePool3DInfo(o.shape,a,u,[1,1,1],c,d),x=new gS(v,"max",!0),w=e.runWebGLProgram(x,[o],o.dtype),b=new SEt(v),T=e.runWebGLProgram(b,[i,w],o.dtype);return e.disposeIntermediateTensorInfo(w),T}},AEt={kernelName:g.MaxPoolGrad,backendName:"webgl",kernelFunc:function NEt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s,output:o}=n,a=s;Qg([s,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=r,v=g.backend_util.computePool2DInfo(a.shape,u,c,1,d,p),w=new ey(v,"max",!0),b=e.runWebGLProgram(w,[a],a.dtype),T=new IEt(v),N=e.runWebGLProgram(T,[i,b],a.dtype);return e.disposeIntermediateTensorInfo(b),N}},PEt={kernelName:g.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:a}=n,u=e;g.util.assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);const d=g.backend_util.computePool2DInfo(r.shape,i,s,c,o),[p,v]=function MEt(t,n,e,r){let i=new ey(e,"max",!1);const s=r.runWebGLProgram(i,[t],"float32");return i=new ey(e,"max",!0,!0,n),[s,r.runWebGLProgram(i,[t],"float32")]}(r,a,d,u);return[p,v]}},REt={kernelName:g.Mean,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{keepDims:i,axis:s}=n,o=e,a=r.shape.length,u=g.util.parseAxisParam(s,r.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a),p=null!=d,v=o.shouldExecuteOnCPU([r]),x=[];let w=r;if(p){if(v){const J=o.texData.get(w.dataId).values,ht=new Array(a);for(let zt=0;zt<ht.length;zt++)ht[zt]=r.shape[d[zt]];const Tt=fS(J,r.shape,r.dtype,d,ht);w=o.makeTensorInfo(ht,r.dtype),o.texData.get(w.dataId).values=Tt}else w=_1(r,d,o);x.push(w),c=g.backend_util.getInnerMostAxes(c.length,a)}g.backend_util.assertAxesAreInnerMostDims("sum",c,a);const[b,T]=g.backend_util.computeOutAndReduceShapes(w.shape,c);let N=b;i&&(N=g.backend_util.expandShapeToKeepDim(b,u));const S=function OEt(t,n,e,r){const i=g.util.sizeFromShape(n),a=Ln({inputs:{x:t},attrs:{shape:[g.util.sizeFromShape(t.shape)/i,i]},backend:r}),u=rf(a,"float32","mean",r),c=Ln({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}(w,T,N,o);for(const U of x)o.disposeIntermediateTensorInfo(U);return S}},kEt={kernelName:g.Min,backendName:"webgl",kernelFunc:function LEt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=i.shape.length,u=g.util.parseAxisParam(s,i.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a);let p=i;null!=d&&(p=Zu({inputs:{x:i},backend:e,attrs:{perm:d}}),c=g.backend_util.getInnerMostAxes(c.length,i.shape.length)),g.backend_util.assertAxesAreInnerMostDims("min",c,a);const[v,x]=g.backend_util.computeOutAndReduceShapes(p.shape,c),b=Ln({inputs:{x:p},backend:e,attrs:{shape:[-1,g.util.sizeFromShape(x)]}}),T=rf(b,b.dtype,"min",e);let N;return N=Ln(o?{inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(v,u)}}:{inputs:{x:T},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(T),null!=d&&e.disposeIntermediateTensorInfo(p),N}},BEt=Cu({opSnippet:pS+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nf+"\n  return result;\n",cpuKernelImpl:Kyt}),zEt={kernelName:g.Minimum,backendName:"webgl",kernelFunc:BEt};class VEt{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((d,p)=>d[0]+n[p]+d[1]);const i=n.length,s=ao(i),o=e.map(d=>d[0]).join(","),a=e.map((d,p)=>d[0]+n[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c="reflect"===r?0:1;this.userCode=1!==i?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${i}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${u}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class UEt{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((w,b)=>w[0]+n[b]+w[1]);const i=n.length,s=ao(i),o=e.map(w=>w[0]).join(","),a=e.map((w,b)=>w[0]+n[b]).join(","),u=Xu("rc",i),c=Xu("source",i),d=`${u[i-1]} < ${this.outputShape[i-1]}`,p=1===i?"source":`vec2(${c.slice(-2).join()})`,v="reflect"===r?0:1;let x="";if(1===i){const w=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${v};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${v};\n        }\n        source -= start;\n      `;x=`\n        ${s} rc = outputLoc;\n        ${w}\n        result[0] = getChannel(getX(${c.join()}), ${p});\n        ${u[i-1]} += 1;\n        if(${d}) {\n          ${w}\n          result[1] = getChannel(getX(${c.join()}), ${p});\n        }\n      `}else{const w=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${v}) +\n                gte * ((end - 1) * 2 - source + ${v});\n        source -= start;\n      `;x=`\n        ${s} rc = outputLoc;\n        ${w}\n        result[0] = getChannel(getX(${c.join()}), ${p});\n        ${u[i-1]} += 1;\n        if(${d}) {\n          ${w}\n          result[1] = getChannel(getX(${c.join()}), ${p});\n        }\n        rc = outputLoc;\n        ${u[i-2]} += 1;\n        if(${u[i-2]} < ${this.outputShape[i-2]}) {\n          ${w}\n          result[2] = getChannel(getX(${c.join()}), ${p});\n          ${u[i-1]} += 1;\n          if(${d}) {\n            ${w}\n            result[3] = getChannel(getX(${c.join()}), ${p});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${x}\n        setOutput(result);\n      }\n    `}}const GEt={kernelName:g.MirrorPad,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r}=t,{paddings:i,mode:s}=e,o=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UEt(r.shape,i,s):new VEt(r.shape,i,s);return n.runWebGLProgram(o,[r],r.dtype)}},KEt=Cu({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+nf+"\n  return result;\n"}),XEt={kernelName:g.Mod,backendName:"webgl",kernelFunc:KEt};class ZEt{constructor(n,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const fV=Cu({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),YEt={kernelName:g.RealDiv,backendName:"webgl",kernelFunc:fV},pV="return a - b;",mV=Cu({opSnippet:pV,packedOpSnippet:pV,supportsComplex:!0,cpuKernelImpl:p0t}),qEt={kernelName:g.Sub,backendName:"webgl",kernelFunc:mV};function gV(t){const{inputs:n,backend:e,attrs:r}=t,{logits:i}=n,{dim:s}=r,o=g.util.parseAxisParam([s],i.shape),a=dV({inputs:{x:i},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),u=g.backend_util.expandShapeToKeepDim(a.shape,o),c=Ln({inputs:{x:a},backend:e,attrs:{shape:u}}),d=mV({inputs:{a:i,b:c},backend:e}),p=oV({inputs:{x:d},backend:e}),v=x1({inputs:{x:p},backend:e,attrs:{axis:o,keepDims:!1}}),x=Ln({inputs:{x:v},backend:e,attrs:{shape:u}}),w=fV({inputs:{a:p,b:x},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),w}const QEt={kernelName:g.Softmax,backendName:"webgl",kernelFunc:gV},tCt={kernelName:g.Multinomial,backendName:"webgl",kernelFunc:function JEt(t){const{inputs:n,backend:e,attrs:r}=t,{logits:i}=n,{numSamples:s,seed:o,normalized:a}=r,u=a?i:gV({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),p=new ZEt(u.shape[0],u.shape[1],s),x=e.runWebGLProgram(p,[u],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(u),x}},eCt=Wl+"\n  return -x;\n",iCt={kernelName:g.Neg,backendName:"webgl",kernelFunc:function rCt(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){const s=e.texData.get(r.dataId),[o,a]=Zyt(s.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,o)}let i;return i=(0,g.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new dd(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new oh(r.shape,eCt),e.runWebGLProgram(i,[r],r.dtype)}},sCt=g.kernel_impls.nonMaxSuppressionV3Impl,aCt={kernelName:g.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function oCt(t){g.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=r,c=e.readSync(i.dataId),d=e.readSync(s.dataId),{selectedIndices:p}=sCt(c,d,o,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}},uCt=g.kernel_impls.nonMaxSuppressionV4Impl,cCt={kernelName:g.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function lCt(t){g.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r,d=e.readSync(i.dataId),p=e.readSync(s.dataId),{selectedIndices:v,validOutputs:x}=uCt(d,p,o,a,u,c);return[e.makeTensorInfo([v.length],"int32",new Int32Array(v)),e.makeTensorInfo([],"int32",new Int32Array([x]))]}},hCt=g.kernel_impls.nonMaxSuppressionV5Impl,fCt={kernelName:g.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function dCt(t){g.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r,d=e.readSync(i.dataId),p=e.readSync(s.dataId),v=o,x=a,w=u,b=c,{selectedIndices:T,selectedScores:N}=hCt(d,p,v,x,w,b);return[e.makeTensorInfo([T.length],"int32",new Int32Array(T)),e.makeTensorInfo([N.length],"float32",new Float32Array(N))]}};class pCt{constructor(n,e,r,i){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${i}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const gCt={kernelName:g.OneHot,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{indices:i}=n,{dtype:s,depth:o,onValue:a,offValue:u}=r,c=g.util.sizeFromShape(i.shape),d=new pCt(c,o,a,u),p=Ln({inputs:{x:i},backend:e,attrs:{shape:[c]}}),v=e.runWebGLProgram(d,[p],s);e.disposeIntermediateTensorInfo(p);const w=Ln({inputs:{x:v},backend:e,attrs:{shape:[...i.shape,o]}});return e.disposeIntermediateTensorInfo(v),w}};function D1(t){const{inputs:n,backend:e}=t,{x:r}=n;if("complex64"===r.dtype){const i=ny({inputs:{input:r},backend:e}),s=D1({inputs:{x:i},backend:e}),o=b1({inputs:{input:r},backend:e}),a=D1({inputs:{x:o},backend:e}),u=fd({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return iy({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const yCt={kernelName:g.ZerosLike,backendName:"webgl",kernelFunc:D1},vCt={kernelName:g.OnesLike,backendName:"webgl",kernelFunc:function yV(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const i=ny({inputs:{input:r},backend:e}),s=yV({inputs:{x:i},backend:e}),o=b1({inputs:{input:r},backend:e}),a=D1({inputs:{x:o},backend:e}),u=fd({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return iy({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},xCt={kernelName:g.Pack,backendName:"webgl",kernelFunc:function _Ct(t){const{inputs:n,backend:e,attrs:r}=t,{axis:i}=r;if(1===n.length)return _S({inputs:{input:n[0]},backend:e,attrs:{dim:i}});const s=n[0].shape,o=n[0].dtype;n.forEach(d=>{g.util.assertShapesMatch(s,d.shape,"All tensors passed to stack must have matching shapes"),g.util.assert(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Zz({inputs:n.map(d=>{const p=_S({inputs:{input:d},backend:e,attrs:{dim:i}});return a.push(p),p}),backend:e,attrs:{axis:i}});return a.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}};class ECt{constructor(n,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,d)=>c[0]+n[d]+c[1]);const i=n.length,s=ao(i),o=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+n[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);this.userCode=1!==i?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${u}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class CCt{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((b,T)=>b[0]+n[T]+b[1]);const i=n.length,s=ao(i),o=e.map(b=>b[0]).join(","),a=e.map((b,T)=>b[0]+n[T]).join(","),u=Xu("rc",i),c=Xu("source",i),d=`${u[i-1]} < ${this.outputShape[i-1]}`,p=1===i?"source":`vec2(${c.slice(-2).join()})`,v=[`${s} rc = outputLoc;`,`${u[i-1]} += 1;\n       if(${d}) {\n      `,1===i?"":`}\n       rc = outputLoc;\n       ${u[i-2]} += 1;\n       if(${u[i-2]} < ${this.outputShape[i-2]}) {`,1===i?"":`  ${u[i-1]} += 1;\n         if(${d}) {`],x=1===i?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let w="";for(let b=0,T=1===i?2:4;b<T;b++)w+=`\n        ${v[b]}\n        if (${x}) {\n          result[${b}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${b}] = getChannel(getX(${c.join()}), ${p});\n        }\n      `;w+=1===i?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${w}\n        setOutput(result);\n      }\n    `}}const vV=t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{paddings:s,constantValue:o}=r;if(0===g.util.sizeFromShape(i.shape))return iy({backend:e,attrs:{shape:s.map((d,p)=>d[0]+i.shape[p]+d[1]),value:o,dtype:i.dtype}});const a=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CCt(i.shape,s,o):new ECt(i.shape,s,o);return e.runWebGLProgram(a,[i],i.dtype,[[o]])},wCt={kernelName:g.PadV2,backendName:"webgl",kernelFunc:vV},SCt=Cu({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+nf+"\n  return result;\n"}),DCt={kernelName:g.Pow,backendName:"webgl",kernelFunc:SCt},NCt={kernelName:g.Prod,backendName:"webgl",kernelFunc:function TCt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=i.shape.length,u=[],c=g.util.parseAxisParam(s,i.shape);let d=c;const p=g.backend_util.getAxesPermutation(d,a);let x,v=i;if(null!=p&&(v=Zu({inputs:{x:i},backend:e,attrs:{perm:p}}),d=g.backend_util.getInnerMostAxes(d.length,a),u.push(v)),g.backend_util.assertAxesAreInnerMostDims("prod",d,a),e.shouldExecuteOnCPU([v])){const w=e.texData.get(v.dataId).values,{outVals:b,outShape:T,outDtype:N}=qyt(v.shape,v.dtype,w,d);x=e.makeTensorInfo(T,N,b)}else{const[w,b]=g.backend_util.computeOutAndReduceShapes(v.shape,d),T=g.util.sizeFromShape(b),N=Ln({inputs:{x:v},backend:e,attrs:{shape:[-1,T]}}),U=rf(N,(0,g.sumOutType)(i.dtype),"prod",e);x=Ln({inputs:{x:U},backend:e,attrs:{shape:w}}),u.push(N),u.push(U)}if(o){u.push(x);const w=g.backend_util.expandShapeToKeepDim(x.shape,c);x=Ln({inputs:{x},backend:e,attrs:{shape:w}})}return u.forEach(w=>e.disposeIntermediateTensorInfo(w)),x}},MCt={kernelName:g.RaggedGather,backendName:"webgl",kernelFunc:function ACt(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:o}=n,{outputRaggedRank:a}=r,u=i.map(N=>e.readSync(N.dataId)),c=i.map(N=>N.shape),d=e.readSync(s.dataId),p=e.readSync(o.dataId),[v,x,w]=Qyt(u,c,d,s.shape,s.dtype,p,o.shape,a),b=v.map(N=>e.makeTensorInfo([N.length],"int32",N)),T=e.makeTensorInfo(w,s.dtype,x);return b.concat([T])}},OCt={kernelName:g.RaggedRange,backendName:"webgl",kernelFunc:function PCt(t){const{inputs:n,backend:e}=t,{starts:r,limits:i,deltas:s}=n,o=e.readSync(r.dataId),a=e.readSync(i.dataId),u=e.readSync(s.dataId),[c,d]=Jyt(o,r.shape,r.dtype,a,i.shape,u,s.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([d.length],r.dtype,d)]}},LCt={kernelName:g.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function RCt(t){const{inputs:n,backend:e,attrs:r}=t,{shape:i,values:s,defaultValue:o,rowPartitionTensors:a}=n,{rowPartitionTypes:u}=r,c=e.readSync(i.dataId),d=e.readSync(s.dataId),p=e.readSync(o.dataId),v=a.map(T=>e.readSync(T.dataId)),x=a.map(T=>T.shape),[w,b]=t0t(c,i.shape,d,s.shape,s.dtype,p,o.shape,v,x,u);return e.makeTensorInfo(w,s.dtype,b)}},_V=t=>{const{backend:n,attrs:e}=t,{start:r,stop:i,step:s,dtype:o}=e,a=e0t(r,i,s,o);return n.makeTensorInfo([a.length],o,a)},kCt={kernelName:g.Range,backendName:"webgl",kernelFunc:_V},FCt=gs({opSnippet:"return 1.0 / x;"}),$Ct={kernelName:g.Reciprocal,backendName:"webgl",kernelFunc:FCt},zCt=gs({opSnippet:Wl+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),VCt={kernelName:g.Relu,backendName:"webgl",kernelFunc:zCt},WCt=gs({opSnippet:Wl+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),GCt={kernelName:g.Relu6,backendName:"webgl",kernelFunc:WCt};class HCt{constructor(n,e,r,i,s){this.variableNames=["A"],this.outputShape=[];const[o,a,u,c]=n;this.outputShape=[o,e,r,c];const d=[i&&e>1?a-1:a,i&&r>1?u-1:u],p=[i&&e>1?e-1:e,i&&r>1?r-1:r];let v;v=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${v};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class jCt{constructor(n,e,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,u,c]=n;this.outputShape=[o,e,r,c];const d=[i&&e>1?a-1:a,i&&r>1?u-1:u],p=[i&&e>1?e-1:e,i&&r>1?r-1:r];let v;v=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]},\n          ${d[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${v};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const XCt={kernelName:g.ResizeBilinear,backendName:"webgl",kernelFunc:function KCt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:o,size:a}=r,[u,c]=a,d=(0,g.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new jCt(i.shape,u,c,s,o):new HCt(i.shape,u,c,s,o);return e.runWebGLProgram(d,[i],"float32")}};class ZCt{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,s]=e,[,o,a]=n,u=[r&&o>1?i-1:i,r&&a>1?s-1:s],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],d=u[0]/c[0],p=u[1]/c[1],v=1/d,x=1/p,w=2*Math.ceil(v)+2,b=2*Math.ceil(x)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${d});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${v});\n        const float invWidthScale = float(${x});\n\n        const int winHeight = int(${w});\n        const int winWidth = int(${b});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const qCt={kernelName:g.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function YCt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i,dy:s}=n,{alignCorners:o}=r,a=new ZCt(s.shape,i.shape,o);return e.runWebGLProgram(a,[s],s.dtype)}};class QCt{constructor(n,e,r,i,s){this.variableNames=["A"],this.outputShape=[];const[o,a,u,c]=n;this.outputShape=[o,e,r,c];const d=[i&&e>1?a-1:a,i&&r>1?u-1:u],p=[i&&e>1?e-1:e,i&&r>1?r-1:r];let x;x=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${x};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class JCt{constructor(n,e,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,u,c]=n;this.outputShape=[o,e,r,c];const d=[i&&e>1?a-1:a,i&&r>1?u-1:u],p=[i&&e>1?e-1:e,i&&r>1?r-1:r];let x;x=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]},\n          ${d[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${x};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const ewt={kernelName:g.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function twt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:o,size:a}=r,[u,c]=a,d=(0,g.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new JCt(i.shape,u,c,s,o):new QCt(i.shape,u,c,s,o);return e.runWebGLProgram(d,[i],i.dtype)}};class nwt{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,s]=e,[,o,a]=n,u=[r&&o>1?i-1:i,r&&a>1?s-1:s],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],d=u[0]/c[0],p=u[1]/c[1],v=1/d,x=1/p,w=2*Math.ceil(v)+2,b=2*Math.ceil(x)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${d});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${v});\n        const float invWidthScale = float(${x});\n\n        const int winHeight = int(${w});\n        const int winWidth = int(${b});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${u[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${u[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const iwt={kernelName:g.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function rwt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i,dy:s}=n,{alignCorners:o}=r,a=new nwt(s.shape,i.shape,o);return e.runWebGLProgram(a,[s],s.dtype)}};class swt{constructor(n,e){this.variableNames=["x"];const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const s=n.map((a,u)=>(a=>-1!==e.indexOf(a)&&1!==n[a]?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`)(u)).join(","),o=ao(r);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class owt{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;const i=Xu("rc",r),s=`${i[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${i[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ao(r);function v(w){const b=n.map((S,U)=>function x(w,b){return-1!==e.indexOf(w)&&1!==n[w]?`${n[w]} - ${b[w]} - 1`:`${b[w]}`}(U,w));return`getChannel(getX(${b.join(",")}), vec2(${b.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function u(w){return v(w)}(i.slice())};\n          if(${s}){\n            result.g = ${function c(w){return w[r-1]="("+w[r-1]+" + 1)",v(w)}(i.slice())};\n          }\n          if(${o}) {\n            result.b = ${function d(w){return w[r-2]="("+w[r-2]+" + 1)",v(w)}(i.slice())};\n            if(${s}) {\n              result.a = ${function p(w){return w[r-1]="("+w[r-1]+" + 1)",w[r-2]="("+w[r-2]+" + 1)",v(w)}(i.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const uwt={kernelName:g.Reverse,backendName:"webgl",kernelFunc:function awt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{dims:s}=r,o=i.shape.length,a=g.util.parseAxisParam(s,i.shape);if(0===o)return bl({inputs:{x:i},backend:e});const u=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new owt(i.shape,a):new swt(i.shape,a);return e.runWebGLProgram(u,[i],i.dtype)}};class lwt{constructor(n,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=n[1],i=n[2];this.outputShape=n;let s="";s="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const cwt={kernelName:g.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:i,fillValue:s,center:o}=n,a=e,u=new lwt(r.shape,s),[c,d]=g.backend_util.getImageCenter(o,r.shape[1],r.shape[2]),p=[[c,d,Math.sin(i),Math.cos(i)]];return a.runWebGLProgram(u,[r],r.dtype,p)}},hwt=gs({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),dwt={kernelName:g.Round,backendName:"webgl",kernelFunc:hwt},fwt=gs({opSnippet:"return inversesqrt(x);",cpuKernelImpl:n0t}),pwt={kernelName:g.Rsqrt,backendName:"webgl",kernelFunc:fwt};class ES{constructor(n,e,r,i,s,o,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=ao(s.length),d=ao(o.length);let p="";1===r?p="i":2===r&&(p="i, j");let x="";1===i?x="i":2===i&&(x="i, coords[1]");let b="";u&&(b="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${s});\n\n        void main() {\n          ${d} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${p}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${x});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${b}), sum, float(found)));\n        }\n      `}}class mwt{constructor(n,e,r,i,s,o,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=ao(s.length),d=ao(o.length);let p="";1===r?p="i":2===r&&(p="i, j");let x="";1===i?x="i":2===i&&(x="i, coords[1]");let b="";u&&(b="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${s});\n\n        void main() {\n          ${d} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${n}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${p}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${x});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${b}), sum, found));\n        }\n      `}}const ywt={kernelName:g.ScatterNd,backendName:"webgl",kernelFunc:function gwt(t){const{inputs:n,backend:e,attrs:r}=t,{indices:i,updates:s}=n,{shape:o}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=g.backend_util.calculateShapes(s,i,o),v=[p/c,c];if(0===p)return e.makeTensorInfo(o,i.dtype);const x=Ln({inputs:{x:i},backend:e,attrs:{shape:[u,a]}}),w=Ln({inputs:{x:s},backend:e,attrs:{shape:[u,c]}}),b=e.makeTensorInfo([],"float32",new Float32Array([0]));let T;T=(0,g.env)().getBool("WEBGL_PACK")?new mwt(u,a,x.shape.length,w.shape.length,d,v):new ES(u,a,x.shape.length,w.shape.length,d,v);const N=e.runWebGLProgram(T,[w,x,b],w.dtype),S=Ln({inputs:{x:N},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(b),S}};class vwt{constructor(n,e,r,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===(0,g.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===i?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const xwt={kernelName:g.SearchSorted,backendName:"webgl",kernelFunc:function _wt(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:i,values:s}=n,{side:o}=r,a=new vwt(i.shape[0],i.shape[1],s.shape[1],o);return e.runWebGLProgram(a,[i,s],"int32",[[i.shape[1]]])}};class Ewt{constructor(n,e,r){let i,s;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)s="resRC",i="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let d=0;d<e.length;d++)c.push(`${a[d]}`),d<n&&u.push(`${a[d]}`);i=u.join(),s=c.join()}const o=ao(r);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${i});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const wwt={kernelName:g.Select,backendName:"webgl",kernelFunc:function Cwt(t){const{inputs:n,backend:e}=t,{condition:r,t:i,e:s}=n,o=new Ewt(r.shape.length,i.shape,i.shape.length);return e.runWebGLProgram(o,[r,i,s],(0,g.upcastType)(i.dtype,s.dtype))}},Iwt=gs({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${g.backend_util.SELU_SCALEALPHA};\n  float scale = ${g.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Swt={kernelName:g.Selu,backendName:"webgl",kernelFunc:Iwt},Twt=gs({opSnippet:Hp+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:i0t}),Nwt={kernelName:g.Sigmoid,backendName:"webgl",kernelFunc:Twt},Awt=gs({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Mwt={kernelName:g.Sign,backendName:"webgl",kernelFunc:Awt},Rwt=gs({opSnippet:Hp+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${nf}\n  return result;\n`}),Lwt={kernelName:g.Sin,backendName:"webgl",kernelFunc:Rwt},kwt=gs({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Fwt={kernelName:g.Sinh,backendName:"webgl",kernelFunc:kwt},$wt=gs({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Bwt={kernelName:g.Softplus,backendName:"webgl",kernelFunc:$wt},Vwt={kernelName:g.SpaceToBatchND,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockShape:s,paddings:o}=r;g.util.assert(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((N,S)=>N*S),u=[[0,0]];u.push(...o);for(let N=1+s.length;N<i.shape.length;++N)u.push([0,0]);const c=[],d=vV({inputs:{x:i},backend:e,attrs:{paddings:u,constantValue:0}}),p=g.backend_util.getReshaped(d.shape,s,a,!1),v=g.backend_util.getPermuted(p.length,s.length,!1),x=g.backend_util.getReshapedPermuted(d.shape,s,a,!1),w=Ln({inputs:{x:d},backend:e,attrs:{shape:p}}),b=Zu({inputs:{x:w},backend:e,attrs:{perm:v}}),T=Ln({inputs:{x:b},backend:e,attrs:{shape:x}});return c.push(d),c.push(w),c.push(b),c.forEach(N=>e.disposeIntermediateTensorInfo(N)),T}},Wwt={kernelName:g.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function Uwt(t){const{inputs:n,backend:e}=t,{indices:r,values:i,denseShape:s,defaultValue:o}=n;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n         ${i.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(r.dataId),u=e.readSync(i.dataId),c=e.readSync(s.dataId),d=e.readSync(o.dataId)[0],[p,v,x,w,b]=o0t(a,r.shape,r.dtype,u,i.dtype,c,d);return[e.makeTensorInfo(v,r.dtype,p),e.makeTensorInfo([v[0]],i.dtype,x),e.makeTensorInfo([w.length],"bool",new Uint8Array(w.map(T=>Number(T)))),e.makeTensorInfo([b.length],r.dtype,new Int32Array(b))]}},Hwt={kernelName:g.SparseReshape,backendName:"webgl",kernelFunc:function Gwt(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:i,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(e.readSync(i.dataId)),a=e.readSync(r.dataId),u=Array.from(e.readSync(s.dataId)),[c,d,p]=a0t(a,r.shape,r.dtype,o,u);return[e.makeTensorInfo(d,r.dtype,c),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}},Kwt={kernelName:g.SparseSegmentMean,backendName:"webgl",kernelFunc:function jwt(t){const{inputs:n,backend:e}=t,{data:r,indices:i,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const o=e.readSync(r.dataId),a=e.readSync(i.dataId),u=e.readSync(s.dataId),[c,d]=bz(o,r.shape,r.dtype,a,u,!0);return e.makeTensorInfo(d,r.dtype,c)}},Zwt={kernelName:g.SparseSegmentSum,backendName:"webgl",kernelFunc:function Xwt(t){const{inputs:n,backend:e}=t,{data:r,indices:i,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const o=e.readSync(r.dataId),a=e.readSync(i.dataId),u=e.readSync(s.dataId),[c,d]=bz(o,r.shape,r.dtype,a,u);return e.makeTensorInfo(d,r.dtype,c)}},qwt={kernelName:g.SparseToDense,backendName:"webgl",kernelFunc:function Ywt(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:o}=n,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:v}=g.backend_util.calculateShapes(s,i,a);if("string"===s.dtype){const N=e.bufferSync(i),S=e.bufferSync(s),U=g.util.decodeString(e.readSync(o.dataId)[0]),J=r0t(N,S,a,v,d,c,u,p,U,!1);return e.makeTensorInfo(a,J.dtype,J.values)}const w=new ES(c,u,i.shape.length,s.shape.length,p,[v,1],!1),b=e.runWebGLProgram(w,[s,i,o],s.dtype),T=Ln({inputs:{x:b},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(b),T}},Jwt={kernelName:g.SplitV,backendName:"webgl",kernelFunc:function Qwt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{numOrSizeSplits:s,axis:o}=r,a=g.util.parseAxisParam(o,i.shape)[0],u=g.backend_util.prepareSplitSize(i,s,a),d=new Array(i.shape.length).fill(0),p=i.shape.slice();return u.map(v=>{const x=[...p];x[a]=v;const w=jp({inputs:{x:i},backend:e,attrs:{begin:d,size:x}});return d[a]+=v,w})}},xV="return sqrt(x);",tbt=gs({opSnippet:xV,packedOpSnippet:xV,cpuKernelImpl:u0t}),ebt={kernelName:g.Sqrt,backendName:"webgl",kernelFunc:tbt},nbt=gs({opSnippet:"return x * x;"}),rbt={kernelName:g.Square,backendName:"webgl",kernelFunc:nbt},EV="return (a - b) * (a - b);",ibt=Cu({opSnippet:EV,packedOpSnippet:EV}),sbt={kernelName:g.SquaredDifference,backendName:"webgl",kernelFunc:ibt},abt={kernelName:g.StaticRegexReplace,backendName:"webgl",kernelFunc:function obt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;if("string"!==i.dtype)throw new Error("Input must be of datatype string");const s=e.readSync(i.dataId),o=g.backend_util.fromUint8ToStringArray(s),a=l0t(o,"string",r);return e.makeTensorInfo(i.shape,"string",a)}},lbt={kernelName:g.Step,backendName:"webgl",kernelFunc:function ubt({inputs:t,attrs:n,backend:e}){const{x:r}=t,s=new oh(r.shape,Wl+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `);return e.runWebGLProgram(s,[r],r.dtype)}};class cbt{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;const i=r.length,s=ao(r.length),o=ao(r.length);let a="";if(1===i)a="coords * strides + begin";else{let u=0;a=r.map((c,d)=>(u++,1===r.length?`coords * strides[${d}] + begin[${d}]`:`coords[${u-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${n});\n      ${s} strides = ${s}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const dbt={kernelName:g.StridedSlice,backendName:"webgl",kernelFunc:function hbt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{begin:s,end:o,strides:a,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:v}=r,{finalShapeSparse:x,finalShape:w,isIdentity:b,sliceDim0:T,isSimpleSlice:N,begin:S,end:U,strides:J}=g.slice_util.sliceInfo(i.shape,s,o,a,u,c,d,p,v);let ht;if(b)ht=Ln({inputs:{x:i},backend:e,attrs:{shape:w}});else if(T||N){g.util.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const Pt=g.slice_util.computeOutShape(S,U,J),zt=jp({inputs:{x:i},backend:e,attrs:{begin:S,size:Pt}});ht=Ln({inputs:{x:zt},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(zt)}else if(e.shouldExecuteOnCPU([i])){const zt=e.readSync(i.dataId),Ot=(0,g.buffer)(i.shape,i.dtype,zt),le=c0t(x,Ot,J,S);ht=e.makeTensorInfo(w,i.dtype,le.values)}else{const zt=new cbt(S,J,x);ht=e.runWebGLProgram(zt,[i],i.dtype)}const Tt=Ln({inputs:{x:ht},backend:e,attrs:{shape:w}});return e.disposeIntermediateTensorInfo(ht),Tt}},pbt={kernelName:g.StringNGrams,backendName:"webgl",kernelFunc:function fbt(t){const{inputs:n,backend:e,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:d,dataSplits:p}=n,v=e.readSync(d.dataId),x=e.readSync(p.dataId),[w,b]=h0t(v,x,i,s,o,a,u,c);return[e.makeTensorInfo([w.length],"string",w),e.makeTensorInfo(p.shape,"int32",b)]}},gbt={kernelName:g.StringSplit,backendName:"webgl",kernelFunc:function mbt(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:o}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(s.dataId),u=e.readSync(o.dataId)[0],[c,d,p]=d0t(a,u,i),v=d.length;return[e.makeTensorInfo([v,2],"int32",c),e.makeTensorInfo([v],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}},vbt={kernelName:g.StringToHashBucketFast,backendName:"webgl",kernelFunc:function ybt(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:i}=r,{input:s}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(s.dataId),a=f0t(o,i);return e.makeTensorInfo(s.shape,"int32",a)}},_bt=gs({opSnippet:"return tan(x);"}),xbt={kernelName:g.Tan,backendName:"webgl",kernelFunc:_bt},Ebt=gs({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Cbt={kernelName:g.Tanh,backendName:"webgl",kernelFunc:Ebt},bbt={kernelName:g.TensorScatterUpdate,backendName:"webgl",kernelFunc:function wbt(t){const{inputs:n,backend:e}=t,{tensor:i,indices:s,updates:o}=n,{sliceRank:a,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=g.backend_util.calculateShapes(o,s,i.shape),v=[p/c,c];if(0===p)return e.makeTensorInfo(i.shape,s.dtype);const x=Ln({inputs:{x:s},backend:e,attrs:{shape:[u,a]}}),w=Ln({inputs:{x:o},backend:e,attrs:{shape:[u,c]}}),b=Ln({inputs:{x:i},backend:e,attrs:{shape:v}}),T=new ES(u,a,x.shape.length,w.shape.length,d,v,!1,!0),N=e.runWebGLProgram(T,[w,x,b],b.dtype),S=Ln({inputs:{x:N},backend:e,attrs:{shape:i.shape}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(N),S}};class Ibt{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let o=0;o<r.length;o++)r[o]=n[o]*e[o];this.outputShape=r,this.rank=r.length;const i=ao(this.rank),s=function Sbt(t){const n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${t[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<t.length;i++)r.push(`imod(${e[i]}, ${t[i]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function CV(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{reps:s}=r;if("string"===i.dtype||i.shape.length>5){const u=e.readSync(i.dataId),c="string"===i.dtype?u.map(v=>g.util.decodeString(v)):u,d=(0,g.buffer)(i.shape,i.dtype,c),p=m0t(d,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}const o=new Ibt(i.shape,s);return e.runWebGLProgram(o,[i],i.dtype)}const Dbt={kernelName:g.Tile,backendName:"webgl",kernelFunc:CV};class Tbt{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Nbt{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function sf(t,n){null!==n&&t.disposeIntermediateTensorInfo(n)}function wV(t){let n=1;for(;n<t;)n*=2;return n}const Mbt={kernelName:g.TopK,backendName:"webgl",kernelFunc:function Abt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{k:s,sorted:o}=r,a=(0,g.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=(0,g.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,d=c[c.length-1];if(e.shouldExecuteOnCPU([i])||d<a||s>u){const le=e.readSync(i.dataId),[ge,Ae]=g0t(le,c,i.dtype,s,o);return[e.makeTensorInfo(ge.shape,ge.dtype,ge.values),e.makeTensorInfo(Ae.shape,Ae.dtype,Ae.values)]}if(0===s)return c[c.length-1]=0,[e.makeTensorInfo(c,i.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===d)return[i,iy({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const p=e.texData.get(i.dataId),v=null!==p&&p.isPacked,x=v?e.unpackTensor(i):i,b=g.util.sizeFromShape(c)/d,T=Ln({inputs:{x},attrs:{shape:[b,d]},backend:e});v&&sf(e,x);const N=wV(s),S=wV(d);let U=null;const J=()=>null===U?[T,T]:[T,U],ht=(le,ge,Ae)=>{const Re=J(),ve=new Tbt(Ae),Ke=U;U=e.runWebGLProgram(ve,Re,"int32",[[d],[null===U?1:0],[Number.NEGATIVE_INFINITY],[le],[ge]]),sf(e,Ke)};for(let le=1;le<N;le*=2){const ge=2*le;for(let Ae=le;Ae>=1;Ae/=2)ht(ge,Ae,[b,S])}for(let le=S;le>N;le/=2){const ge=J(),Ae=new Nbt([b,le/2]),Ne=U;U=e.runWebGLProgram(Ae,ge,"int32",[[d],[null===U?1:0],[N]]),sf(e,Ne);const Se=N/2,Ke=2*Se;for(let Le=Se;Le>=1;Le/=2)ht(Ke,Le,U.shape)}let Tt=U;U=jp({inputs:{x:U},backend:e,attrs:{begin:0,size:[b,s]}}),sf(e,Tt);let Pt=hV({inputs:{x:T,indices:U},backend:e,attrs:{axis:1,batchDims:1}});sf(e,T);const zt=c.slice(0,-1);zt.push(s),Tt=U,U=Ln({inputs:{x:U},attrs:{shape:zt},backend:e}),sf(e,Tt);const Ot=Pt;return Pt=Ln({inputs:{x:Pt},attrs:{shape:zt},backend:e}),sf(e,Ot),[Pt,U]}};class Pbt{constructor(n,e,r,i,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===r?1:2;let u;switch(i){case"constant":default:u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${u} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Rbt={kernelName:g.Transform,backendName:"webgl",kernelFunc:function Obt(t){const{inputs:n,backend:e,attrs:r}=t,{image:i,transforms:s}=n,{interpolation:o,fillMode:a,fillValue:u,outputShape:c}=r,[d,p,v,x]=i.shape,[w,b]=c??[p,v],N=new Pbt(p,v,o,a,u,[d,w,b,x]);return e.runWebGLProgram(N,[i,s],"float32")}},kbt={kernelName:g.Unique,backendName:"webgl",kernelFunc:function Lbt(t){const{inputs:n,attrs:e,backend:r}=t,{axis:i}=e,{x:s}=n;Qg(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:a,outputShape:u,indices:c}=y0t(o,i,s.shape,s.dtype);return[r.makeTensorInfo(u,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},$bt={kernelName:g.Unpack,backendName:"webgl",kernelFunc:function Fbt(t){const{inputs:n,backend:e,attrs:r}=t,{value:i}=n;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i,a=o.shape.length,u=i.shape[s],c=new Array(a-1);let d=0;for(let b=0;b<a;b++)b!==s&&(c[d++]=o.shape[b]);const p=[],v=new Array(a).fill(0),x=o.shape.slice();x[s]=1;const w=new Array(u);for(let b=0;b<w.length;b++){v[s]=b;const T=jp({inputs:{x:o},backend:e,attrs:{begin:v,size:x}}),N=Ln({inputs:{x:T},backend:e,attrs:{shape:c}});w[b]=N,p.push(T)}return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),w}};class Bbt{constructor(n,e){this.variableNames=["x","segmentIds"];const r=n.windowSize,i=n.batchSize,s=n.inSize,o=n.numSegments,a=o*Math.ceil(s/r);this.outputShape=[i,a];const d=4*Math.floor(r/4),p=r%4,v="\n        sumValue += dot(values, segFilter);\n    ";let x="";s%r>0&&(x=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let w="";s%r>0&&(w=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${x}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${w}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${v}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${v}\n        } else if (${2===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${v}\n        } else if (${3===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${v}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Ubt=[hvt,fvt,gvt,_vt,Evt,bvt,Svt,Tvt,Pvt,Rvt,Fvt,zvt,Wvt,Kvt,Yvt,Qvt,t_t,i_t,o_t,u_t,d_t,__t,E_t,I_t,D_t,P_t,R_t,$_t,X0t,V_t,j_t,Y_t,n1t,s1t,a1t,l1t,h1t,m1t,y1t,x1t,C1t,b1t,S1t,N1t,M1t,L1t,F1t,z1t,W1t,H1t,K1t,q1t,J1t,nxt,ixt,sxt,axt,lxt,hxt,fxt,mxt,yxt,xxt,wxt,Ixt,Txt,Mxt,Oxt,Lxt,K0t,Fxt,G_t,Bxt,Vxt,Wxt,Y0t,Hxt,Kxt,Zxt,Qxt,eEt,rEt,sEt,aEt,hEt,pEt,gEt,xEt,CEt,bEt,TEt,AEt,PEt,REt,kEt,zEt,GEt,XEt,tCt,J0t,iCt,aCt,cCt,fCt,T_t,gCt,vCt,xCt,wCt,DCt,Q0t,NCt,MCt,OCt,LCt,kCt,N_t,YEt,$Ct,VCt,GCt,evt,XCt,qCt,ewt,iwt,uwt,cwt,dwt,pwt,ywt,xwt,wwt,Swt,Nwt,Mwt,Lwt,Fwt,y_t,QEt,Bwt,Vwt,Wwt,Hwt,Kwt,Zwt,qwt,Jwt,ebt,rbt,sbt,abt,lbt,dbt,pbt,gbt,vbt,qEt,uvt,xbt,Cbt,bbt,Dbt,Mbt,Rbt,lvt,kbt,$bt,{kernelName:g.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function zbt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,segmentIds:s}=n,{numSegments:o}=r,a=i.shape.length,u=[];let c=0;const d=g.backend_util.getAxesPermutation([c],a);let p=i;null!=d&&(p=Zu({inputs:{x:i},backend:e,attrs:{perm:d}}),u.push(p),c=g.backend_util.getInnerMostAxes(1,a)[0]);const v=g.backend_util.segment_util.computeOutShape(p.shape,c,o),x=g.util.sizeFromShape([p.shape[c]]),w=Ln({inputs:{x:p},backend:e,attrs:{shape:[-1,x]}});u.push(w);const b=(0,g.sumOutType)(i.dtype),T=(J,ht,Tt,Pt,zt)=>{const Ot=J.shape[0],le=J.shape[1],ge=g.backend_util.segment_util.segOpComputeOptimalWindowSize(le,zt),Re=new Bbt({windowSize:ge,inSize:le,batchSize:Ot,numSegments:zt},ht),ve=e.compileAndRun(Re,[J,Tt],Pt);if(u.push(ve),ve.shape[1]===zt)return ve;const Ne=_V({backend:e,attrs:{start:0,stop:zt,step:1,dtype:"float32"}}),Se=CV({inputs:{x:Ne},backend:e,attrs:{reps:[le/ge]}});return u.push(Ne),u.push(Se),T(ve,ht,Se,Pt,zt)},S=Ln({inputs:{x:T(w,"unsortedSegmentSum",s,b,o)},backend:e,attrs:{shape:v}});let U=S;if(null!=d){u.push(S);const J=g.backend_util.getUndoAxesPermutation(d);U=Zu({inputs:{x:U},backend:e,attrs:{perm:J}})}return u.forEach(J=>e.disposeIntermediateTensorInfo(J)),U}},yCt];for(const t of Ubt)(0,g.registerKernel)(t);var Gbt=y(2155);const Hbt=["video"],jbt=["canvas"];let Kbt=(()=>{class t{ngOnInit(){var e=this;return(0,Mr.Z)(function*(){yield g.setBackend("webgl");const r=yield Gbt.load();console.log("COCO-SSD model loaded:",r);const i=e.videoElement.nativeElement,s=e.canvas.nativeElement;try{const o=yield navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});i.srcObject=o,i.onloadedmetadata=()=>{s.width=i.videoWidth,s.height=i.videoHeight,e.detectObjects(i,r,s)}}catch(o){console.error("Erro ao acessar a c\xe2mera:",o)}})()}detectObjects(e,r,i){var s=this;return(0,Mr.Z)(function*(){const o=i.getContext("2d");o.clearRect(0,0,i.width,i.height);const a=yield r.detect(e);a.length>0?a.forEach(u=>{o.beginPath(),o.lineWidth=1,o.strokeStyle="white",o.fillStyle="rgba(0, 255, 0, 0.25)",o.rect(u.bbox[0],u.bbox[1],u.bbox[2],u.bbox[3]),o.stroke(),o.fill();const w=`${u.class} - ${Math.round(100*u.score)}%`,b=u.bbox[2];o.font="16px Arial",o.fillStyle="black",o.fillRect(u.bbox[0],u.bbox[1]-20,b,20),o.fillStyle="white",o.fillText(w,u.bbox[0],u.bbox[1]>10?u.bbox[1]-5:10)}):console.log("Nenhum objeto detectado."),requestAnimationFrame(()=>s.detectObjects(e,r,i))})()}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275cmp=ha({type:t,selectors:[["app-tf-ml"]],viewQuery:function(r,i){if(1&r&&(GE(Hbt,5),GE(jbt,5)),2&r){let s;R0(s=L0())&&(i.videoElement=s.first),R0(s=L0())&&(i.canvas=s.first)}},decls:5,vars:0,consts:[[1,"video-container"],["autoplay",""],["video",""],["canvas",""]],template:function(r,i){1&r&&(Xa(0,"div",0),_u(1,"video",1,2)(3,"canvas",null,3),Za())},styles:[".video-container[_ngcontent-%COMP%]{position:relative}video[_ngcontent-%COMP%]{width:20rem;height:auto}canvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:20rem;height:auto}"]})}return t})(),Xbt=(()=>{class t{constructor(e){this.geolocationService=e,this.coordinatesArray=[],this.coordinatesArrayAreaToExplore=[],this.displacementLimit=10,this.speedLimit=5,this.accelerationLimit=20,this.timeInterval=500,this.lastPosition=null,this.lastSpeed=0,this.lastTimestamp=0,this.totalDistance=0,this.pontos=0,this.mensagem="2-Inicio"}ngOnInit(){this.geolocationService.startBackgroundGeolocation().subscribe(e=>{this.mensagem="funcionando em segundo plano",console.log("funcionando em segundo plano")},e=>{this.mensagem="erro n\xe3o funciona",console.log("erro n\xe3o funciona",e)}),this.createMap()}createMap(){this.map=El.map("map").setView([0,0],1);const e=El.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png",{maxZoom:19,minZoom:0,attribution:'&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'});this.polyline=El.polyline([],{color:"#C4EEF2",weight:7,opacity:1}).addTo(this.map),this.polylineBorder=El.polyline([],{color:"#025159",weight:4}).addTo(this.map),this.heatMap=El.heatLayer([],{radius:16}),e.addTo(this.map),this.polyline.addTo(this.map),this.polylineBorder.addTo(this.map),this.heatMap.addTo(this.map),this.geoJsonDrawLimit(),setTimeout(()=>{this.zoneToExplore()},3e3)}startTracking(){let e=!1;navigator.geolocation?this.watchId=navigator.geolocation.watchPosition(i=>{this.updateCoordinates(i),e||(this.updateCurrentViewPoint([i.coords.latitude,i.coords.longitude]),e=!0)},i=>i,{enableHighAccuracy:!0,timeout:100,maximumAge:0}):alert("Navegador n\xe3o suportado")}updateCurrentViewPoint(e){this.map.flyTo(e,19,{duration:2,easeLinearity:.25,animate:!0})}stopTracking(){navigator.geolocation.clearWatch(this.watchId),this.pointIcon&&this.map.removeLayer(this.pointIcon),this.pointIcon=El.icon({iconUrl:"assets/icons/finish.png",iconSize:[32,32]}),El.marker(this.coordinatesArray[this.coordinatesArray.length-1],{icon:this.pointIcon}).addTo(this.map).bindPopup("Chegada")}updateCoordinates(e){const r=e.coords.latitude,i=e.coords.longitude,s=e.timestamp;if(this.checkIsInsideAreaToExplore(r,i),this.lastPosition&&this.lastTimestamp){this.pontos++;const o=this.calculateDistanceHaversinesFormula(r,i,this.lastPosition.coords.latitude,this.lastPosition.coords.longitude),a=s-this.lastTimestamp;o<=this.displacementLimit&&o/a*1e3<=this.speedLimit&&a>=this.timeInterval?(this.addPathLine(r,i),this.totalDistance=this.calculateTotalDistanceLeafletMethod(this.polyline),this.calculeExploredArea()):console.log("Ponto descartado devido a filtros.")}else this.addPathLine(r,i);this.lastPosition=e,this.lastSpeed=this.speed,this.lastTimestamp=s}addPathLine(e,r){this.polyline.addLatLng([e,r]),this.polylineBorder.addLatLng([e,r]),this.heatMap.addLatLng([e,r,2]),this.coordinatesArray.push([e,r,2]),this.createIcons()}createIcons(){const e=El.icon({iconUrl:"assets/icons/start.png",iconSize:[32,32]});El.marker(this.coordinatesArray[0],{icon:e}).addTo(this.map).bindPopup("Inicio"),this.pointIcon&&this.map.removeLayer(this.pointIcon);const r=El.icon({iconUrl:"assets/icons/point.png",iconSize:[32,32]});this.pointIcon=El.marker(this.coordinatesArray[this.coordinatesArray.length-1],{icon:r}).addTo(this.map).bindPopup("Ponto")}calculateDistanceHaversinesFormula(e,r,i,s){const a=e*Math.PI/180,u=i*Math.PI/180,c=(i-e)*Math.PI/180,d=(s-r)*Math.PI/180,p=Math.sin(c/2)*Math.sin(c/2)+Math.cos(a)*Math.cos(u)*Math.sin(d/2)*Math.sin(d/2);return 2*Math.atan2(Math.sqrt(p),Math.sqrt(1-p))*6371e3}calculateTotalDistanceLeafletMethod(e){let r=0;const i=e.getLatLngs();for(let s=0;s<i.length-1;s++)r+=i[s].distanceTo(i[s+1]);return r/1e3}zoneToExplore(){El.circle([-23.217103741057613,-45.90646211989807],{color:"#FA7F08",fillColor:"#F24405",fillOpacity:.3,weight:1,radius:50}).addTo(this.map).bindPopup("Zona de trabalho = 100 metros de di\xe2metro")}geoJsonDrawLimit(){const e=El.geoJSON(this.geoJson(),{style:{fillColor:"rgba(255, 0, 0, 0.5)",fillOpacity:0,color:"#8C034E",weight:2,opacity:.8}}).addTo(this.map);this.map.fitBounds(e.getBounds());const r=ww(this.geoJson());El.popup().setLatLng(e.getBounds().getCenter()).setContent("\xc1rea: "+r.toFixed(2)+" m<sup>2</sup>").openOn(this.map)}calculeExploredArea(){if(this.coordinatesArrayAreaToExplore.length<3)return;const e=ww(this.geoJson()),o=ww(function ZJ(t,n,e){var r=(e=e||{}).units||"kilometers",i=e.steps||8;if(!t)throw new Error("geojson is required");if("object"!=typeof e)throw new Error("options must be an object");if("number"!=typeof i)throw new Error("steps must be an number");if(void 0===n)throw new Error("radius is required");if(i<=0)throw new Error("steps must be greater than 0");var s=[];switch(t.type){case"GeometryCollection":return wv(t,function(o){var a=h_(o,n,r,i);a&&s.push(a)}),hp(s);case"FeatureCollection":return pw(t,function(o){var a=h_(o,n,r,i);a&&pw(a,function(u){u&&s.push(u)})}),hp(s)}return h_(t,n,r,i)}(Cv(this.coordinatesArrayAreaToExplore.map(a=>[a[1],a[0]])),.002,{units:"kilometers"}));return this.totalAreaExplored=o/e*100,this.totalAreaExplored.toFixed(2)+"%"}checkIsInsideAreaToExplore(e,r){yw(cp([r,e]),ug(this.geoJson().features[0].geometry.coordinates))&&this.coordinatesArrayAreaToExplore.push([e,r])}ngOnDestroy(){this.map&&this.map.remove()}geoJson(){return{type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:{coordinates:[[[-45.89634664432393,-23.23426051912533],[-45.89726763410698,-23.23440391159032],[-45.89725845480686,-23.235070262785584],[-45.89632522595693,-23.2350280887581],[-45.89634664432393,-23.23426051912533]]],type:"Polygon"}}]}}static#t=this.\u0275fac=function(r){return new(r||t)(xn(Ik))};static#e=this.\u0275cmp=ha({type:t,selectors:[["app-root"]],decls:43,vars:10,consts:[[1,"container"],[1,"map-container"],["id","map",1,"map"],[3,"click"],["for","fname"],["type","number",3,"ngModel","ngModelChange"],["target","_blank","href","https://icons8.com"]],template:function(r,i){1&r&&(Xa(0,"div",0)(1,"div",1),_u(2,"div",2),Za(),Xa(3,"button",3),xu("click",function(){return i.startTracking()}),tc(4,"Iniciar"),Za(),Xa(5,"button",3),xu("click",function(){return i.stopTracking()}),tc(6,"Finalizar"),Za(),_u(7,"br"),Xa(8,"label",4),tc(9,"Limite de deslocamento m\xe1ximo em metros:"),Za(),_u(10,"br"),Xa(11,"input",5),xu("ngModelChange",function(o){return i.displacementLimit=o}),Za(),_u(12,"br"),Xa(13,"label",4),tc(14,"Limite de velocidade m\xe1xima em metros por segundo"),Za(),_u(15,"br"),Xa(16,"input",5),xu("ngModelChange",function(o){return i.speedLimit=o}),Za(),_u(17,"br"),Xa(18,"label",4),tc(19,"Limite de acelera\xe7\xe3o m\xe1xima em metros por segundo ao quadrado"),Za(),_u(20,"br"),Xa(21,"input",5),xu("ngModelChange",function(o){return i.accelerationLimit=o}),Za(),_u(22,"br"),Xa(23,"label",4),tc(24,"Intervalo de tempo entre leituras de GPS em milissegundos"),Za(),_u(25,"br"),Xa(26,"input",5),xu("ngModelChange",function(o){return i.timeInterval=o}),Za(),Xa(27,"div"),_u(28,"br"),Xa(29,"span"),tc(30),Za(),_u(31,"br"),Xa(32,"span"),tc(33),function pM(t,n){const e=kr();let r;const i=t+Lr;e.firstCreatePass?(r=function cH(t,n){if(n)for(let e=n.length-1;e>=0;e--){const r=n[e];if(t===r.name)return r}}(n,e.pipeRegistry),e.data[i]=r,r.onDestroy&&(e.destroyHooks??=[]).push(i,r.onDestroy)):r=e.data[i];const s=r.factory||(r.factory=ah(r.type)),a=vs(xn);try{const u=Py(!1),c=s();return Py(u),function zG(t,n,e,r){e>=t.data.length&&(t.data[e]=null,t.blueprint[e]=null),n[e]=r}(e,qe(),i,c),c}finally{vs(a)}}(34,"number"),Za(),_u(35,"br"),Xa(36,"span"),tc(37),Za(),_u(38,"br"),tc(39," icon by "),Xa(40,"a",6),tc(41,"Icons8"),Za()(),_u(42,"app-tf-ml"),Za()),2&r&&(Fh(11),Hf("ngModel",i.displacementLimit),Fh(5),Hf("ngModel",i.speedLimit),Fh(5),Hf("ngModel",i.accelerationLimit),Fh(5),Hf("ngModel",i.timeInterval),Fh(4),SE(i.mensagem),Fh(3),Am("distancia Total = ",mM(34,7,i.totalDistance,"1.3-3")," Km"),Fh(4),Am("total da \xe1rea explorada = ",i.calculeExploredArea(),""))},dependencies:[f_,Vb,qk,zb,Kbt,XP],styles:[".container[_ngcontent-%COMP%]{width:500px;height:500px}.map[_ngcontent-%COMP%]{height:100%;width:100%}.map-container[_ngcontent-%COMP%]{border:1px solid #6665ff;height:400px}"]})}return t})(),Zbt=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t,bootstrap:[Xbt]});static#n=this.\u0275inj=$n({providers:[bk,Ik],imports:[P9,vZ,Tet]})}return t})();A9().bootstrapModule(Zbt).catch(t=>console.error(t))},2155:function(Lt,ut,y){var $=y(7156).default;!function(V,H,q){"use strict";const Y={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class R{constructor(k,A){this.modelPath=A||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(k)}/model.json`}getPrefix(k){return"lite_mobilenet_v2"===k?`ssd${k}`:`ssd_${k}`}load(){var k=this;return $(function*(){k.model=yield H.loadGraphModel(k.modelPath);const A=q.zeros([1,300,300,3],"int32"),X=yield k.model.executeAsync(A);yield Promise.all(X.map(Z=>Z.data())),X.map(Z=>Z.dispose()),A.dispose()})()}infer(k,A,X){var Z=this;return $(function*(){const G=q.tidy(()=>(k instanceof q.Tensor||(k=q.browser.fromPixels(k)),q.expandDims(k))),it=G.shape[1],bt=G.shape[2],K=yield Z.model.executeAsync(G),st=K[0].dataSync(),et=K[1].dataSync();G.dispose(),q.dispose(K);const[dt,lt]=Z.calculateMaxScores(st,K[0].shape[1],K[0].shape[2]),St=q.getBackend();"webgl"===q.getBackend()&&q.setBackend("cpu");const Q=q.tidy(()=>{const pt=q.tensor2d(et,[K[1].shape[1],K[1].shape[3]]);return q.image.nonMaxSuppression(pt,dt,A,X,X)}),ft=Q.dataSync();return Q.dispose(),St!==q.getBackend()&&q.setBackend(St),Z.buildDetectedObjects(bt,it,et,dt,ft,lt)})()}buildDetectedObjects(k,A,X,Z,G,it){const bt=G.length,K=[];for(let st=0;st<bt;st++){const et=[];for(let ft=0;ft<4;ft++)et[ft]=X[4*G[st]+ft];const dt=et[0]*A,lt=et[1]*k,St=et[2]*A,Q=et[3]*k;et[0]=lt,et[1]=dt,et[2]=Q-lt,et[3]=St-dt,K.push({bbox:et,class:Y[it[G[st]]+1].displayName,score:Z[G[st]]})}return K}calculateMaxScores(k,A,X){const Z=[],G=[];for(let it=0;it<A;it++){let bt=Number.MIN_VALUE,K=-1;for(let st=0;st<X;st++)k[it*X+st]>bt&&(bt=k[it*X+st],K=st);Z[it]=bt,G[it]=K}return[Z,G]}detect(k,A=20,X=.5){var Z=this;return $(function*(){return Z.infer(k,A,X)})()}dispose(){null!=this.model&&this.model.dispose()}}V.ObjectDetection=R,V.load=$(function*(W={}){if(null==q)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const k=W.base||"lite_mobilenet_v2",A=W.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(k))throw new Error(`ObjectDetection constructed with invalid base model ${k}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const X=new R(k,A);return yield X.load(),X}),V.version="2.2.3",Object.defineProperty(V,"__esModule",{value:!0})}(ut,y(7926),y(6300))},7926:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{GraphModel:()=>os,deregisterOp:()=>Gt,loadGraphModel:()=>Iu,loadGraphModelSync:()=>Or,registerOp:()=>at,version_converter:()=>_e});var $={};y.r($),y.d($,{json:()=>ee});var V={};y.r(V),y.d(V,{json:()=>jt});var H={};y.r(H),y.d(H,{json:()=>se});var q={};y.r(q),y.d(q,{json:()=>be});var Y={};y.r(Y),y.d(Y,{json:()=>Me});var R={};y.r(R),y.d(R,{json:()=>Xe});var W={};y.r(W),y.d(W,{json:()=>Ue});var k={};y.r(k),y.d(k,{json:()=>De});var A={};y.r(A),y.d(A,{json:()=>Tn});var X={};y.r(X),y.d(X,{json:()=>On});var Z={};y.r(Z),y.d(Z,{json:()=>ne});var G={};y.r(G),y.d(G,{json:()=>pe});var it={};y.r(it),y.d(it,{json:()=>Ie});var bt={};y.r(bt),y.d(bt,{json:()=>Je});var K={};y.r(K),y.d(K,{json:()=>Gn});var st={};y.r(st),y.d(st,{json:()=>Er});var et={};y.r(et),y.d(et,{json:()=>Nn});var dt={};y.r(dt),y.d(dt,{json:()=>Yn});var lt={};y.r(lt),y.d(lt,{json:()=>hi});var St={};y.r(St),y.d(St,{OP_SCOPE_SUFFIX:()=>Xt.zvA,abs:()=>Xt.WnP,acos:()=>Xt.Khb,acosh:()=>Xt.__u,add:()=>Xt.IHx,addN:()=>Xt.QBD,all:()=>Xt.$6P,any:()=>Xt.YjB,argMax:()=>Xt.NqF,argMin:()=>Xt.vHJ,asin:()=>Xt.ZRM,asinh:()=>Xt.VfV,atan:()=>Xt.z4N,atan2:()=>Xt.fvJ,atanh:()=>Xt.C80,avgPool:()=>Xt.wS1,avgPool3d:()=>Xt.uR5,basicLSTMCell:()=>Xt.zEQ,batchNorm:()=>Xt.tgs,batchNorm2d:()=>Xt.Dxk,batchNorm3d:()=>Xt.JY5,batchNorm4d:()=>Xt.p3b,batchToSpaceND:()=>Xt.E4h,bincount:()=>Xt.yE8,bitwiseAnd:()=>Xt.ycw,booleanMaskAsync:()=>Xt.anm,broadcastArgs:()=>Xt.XsQ,broadcastTo:()=>Xt.UFq,buffer:()=>Xt.f3b,cast:()=>Xt.pju,ceil:()=>Xt.mDi,clipByValue:()=>Xt.iUl,clone:()=>Xt.d9v,complex:()=>Xt.PYB,concat:()=>Xt.zoF,concat1d:()=>Xt.gME,concat2d:()=>Xt.Izb,concat3d:()=>Xt.MNy,concat4d:()=>Xt.ZaL,conv1d:()=>Xt.PAt,conv2d:()=>Xt.Tek,conv2dTranspose:()=>Xt.bc,conv3d:()=>Xt.pdZ,conv3dTranspose:()=>Xt.$QV,cos:()=>Xt.mCk,cosh:()=>Xt.f9Y,cosineWindow:()=>Xt.mew,cumprod:()=>Xt.$Gn,cumsum:()=>Xt.zbp,denseBincount:()=>Xt.ppE,depthToSpace:()=>Xt.nTT,depthwiseConv2d:()=>Xt.B10,diag:()=>Xt.Ka3,dilation2d:()=>Xt.WmZ,div:()=>Xt.hiC,divNoNan:()=>Xt.NTj,dot:()=>Xt.AKD,dropout:()=>Xt.rvX,einsum:()=>Xt.WYO,elu:()=>Xt.pyx,enclosingPowerOfTwo:()=>Xt.GRh,ensureShape:()=>Xt.EDe,equal:()=>Xt.DgJ,erf:()=>Xt.qNN,euclideanNorm:()=>Xt.d2q,exp:()=>Xt.Qqt,expandDims:()=>Xt.dt4,expm1:()=>Xt.t$B,eye:()=>Xt.iyy,fft:()=>Xt.kp_,fill:()=>Xt.hlL,floor:()=>Xt.GWj,floorDiv:()=>Xt.qPi,fused:()=>Xt.imm,gather:()=>Xt.Iqj,gatherND:()=>Xt.dbB,greater:()=>Xt.pjt,greaterEqual:()=>Xt.brS,ifft:()=>Xt.Sxn,imag:()=>Xt.asL,image:()=>Xt.BHj,inTopKAsync:()=>Xt.V3u,irfft:()=>Xt.wx0,isFinite:()=>Xt.xVT,isInf:()=>Xt.UWc,isNaN:()=>Xt.i2d,leakyRelu:()=>Xt.hi7,less:()=>Xt.d9m,lessEqual:()=>Xt.zN1,linalg:()=>Xt.$r2,linspace:()=>Xt.SX3,localResponseNormalization:()=>Xt.G9k,log:()=>Xt.cM7,log1p:()=>Xt.Krr,logSigmoid:()=>Xt.e_t,logSoftmax:()=>Xt.CmS,logSumExp:()=>Xt.l_t,logicalAnd:()=>Xt.HvI,logicalNot:()=>Xt.hJK,logicalOr:()=>Xt.K5V,logicalXor:()=>Xt.egP,losses:()=>Xt.MB5,lowerBound:()=>Xt.eab,matMul:()=>Xt.OI3,max:()=>Xt.Fp7,maxPool:()=>Xt._sB,maxPool3d:()=>Xt.YQQ,maxPoolWithArgmax:()=>Xt.Ip$,maximum:()=>Xt.gWQ,mean:()=>Xt.J69,meshgrid:()=>Xt.ry_,min:()=>Xt.VV$,minimum:()=>Xt.LTh,mirrorPad:()=>Xt.VdP,mod:()=>Xt.wQq,moments:()=>Xt.Gi7,movingAverage:()=>Xt.p_,mul:()=>Xt.dC7,multiRNNCell:()=>Xt.rq4,multinomial:()=>Xt.SJ_,neg:()=>Xt.W76,norm:()=>Xt.KOy,notEqual:()=>Xt.Quu,oneHot:()=>Xt.lfX,ones:()=>Xt.iUs,onesLike:()=>Xt.JpU,op:()=>Xt.op,outerProduct:()=>Xt.N2O,pad:()=>Xt.vku,pad1d:()=>Xt.pNR,pad2d:()=>Xt.koy,pad3d:()=>Xt.t1L,pad4d:()=>Xt.lGY,pool:()=>Xt.d_R,pow:()=>Xt.sQ3,prelu:()=>Xt.AL3,print:()=>Xt.S0v,prod:()=>Xt.WVs,raggedGather:()=>Xt.$gW,raggedRange:()=>Xt.VT$,raggedTensorToTensor:()=>Xt.N89,rand:()=>Xt.TN_,randomGamma:()=>Xt.wzB,randomNormal:()=>Xt.nGf,randomStandardNormal:()=>Xt.ruB,randomUniform:()=>Xt.LGj,randomUniformInt:()=>Xt.pe5,range:()=>Xt.w6H,real:()=>Xt.kwC,reciprocal:()=>Xt.M25,relu:()=>Xt.UYe,relu6:()=>Xt.btT,reshape:()=>Xt.XLQ,reverse:()=>Xt.GYS,reverse1d:()=>Xt.SDf,reverse2d:()=>Xt.diP,reverse3d:()=>Xt.sx7,reverse4d:()=>Xt.mG2,rfft:()=>Xt.QEs,round:()=>Xt.NMM,rsqrt:()=>Xt.bp0,scalar:()=>Xt.iD$,scatterND:()=>Xt.snQ,searchSorted:()=>Xt.zcT,selu:()=>Xt.U8D,separableConv2d:()=>Xt.U_I,setdiff1dAsync:()=>Xt.ODp,sigmoid:()=>Xt.XD2,sign:()=>Xt.Xxe,signal:()=>Xt.tdS,sin:()=>Xt.O$l,sinh:()=>Xt.R_K,slice:()=>Xt.tPi,slice1d:()=>Xt.jZU,slice2d:()=>Xt.SmN,slice3d:()=>Xt.CnO,slice4d:()=>Xt.p0P,softmax:()=>Xt.XAC,softplus:()=>Xt.Wvh,spaceToBatchND:()=>Xt.fBT,sparse:()=>Xt.rVs,sparseToDense:()=>Xt.ers,spectral:()=>Xt.uN7,split:()=>Xt.Vl2,sqrt:()=>Xt._b3,square:()=>Xt.h62,squaredDifference:()=>Xt.$i,squeeze:()=>Xt.L9e,stack:()=>Xt.knu,step:()=>Xt.Nbs,stridedSlice:()=>Xt.NXj,string:()=>Xt.Z_8,sub:()=>Xt.luU,sum:()=>Xt.Smz,tan:()=>Xt.ORZ,tanh:()=>Xt.AEp,tensor:()=>Xt.XeE,tensor1d:()=>Xt.RRF,tensor2d:()=>Xt.odF,tensor3d:()=>Xt.wOQ,tensor4d:()=>Xt.yXz,tensor5d:()=>Xt.Bfx,tensor6d:()=>Xt.xZs,tensorScatterUpdate:()=>Xt.Pg0,tile:()=>Xt.Gg6,topk:()=>Xt.hg7,transpose:()=>Xt.p4s,truncatedNormal:()=>Xt.Xu6,unique:()=>Xt.Two,unsortedSegmentSum:()=>Xt.pUJ,unstack:()=>Xt.HHK,upperBound:()=>Xt.GaM,variable:()=>Xt.VD$,where:()=>Xt.arb,whereAsync:()=>Xt.itS,zeros:()=>Xt.lls,zerosLike:()=>Xt.P84});var Q=y(6300);(0,Q.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,z=>{z&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var ot,pt=y(5861),B=function(z){return z[z.DT_INVALID=0]="DT_INVALID",z[z.DT_FLOAT=1]="DT_FLOAT",z[z.DT_DOUBLE=2]="DT_DOUBLE",z[z.DT_INT32=3]="DT_INT32",z[z.DT_UINT8=4]="DT_UINT8",z[z.DT_INT16=5]="DT_INT16",z[z.DT_INT8=6]="DT_INT8",z[z.DT_STRING=7]="DT_STRING",z[z.DT_COMPLEX64=8]="DT_COMPLEX64",z[z.DT_INT64=9]="DT_INT64",z[z.DT_BOOL=10]="DT_BOOL",z[z.DT_QINT8=11]="DT_QINT8",z[z.DT_QUINT8=12]="DT_QUINT8",z[z.DT_QINT32=13]="DT_QINT32",z[z.DT_BFLOAT16=14]="DT_BFLOAT16",z[z.DT_QINT16=15]="DT_QINT16",z[z.DT_QUINT16=16]="DT_QUINT16",z[z.DT_UINT16=17]="DT_UINT16",z[z.DT_COMPLEX128=18]="DT_COMPLEX128",z[z.DT_HALF=19]="DT_HALF",z[z.DT_RESOURCE=20]="DT_RESOURCE",z[z.DT_VARIANT=21]="DT_VARIANT",z[z.DT_UINT32=22]="DT_UINT32",z[z.DT_UINT64=23]="DT_UINT64",z[z.DT_FLOAT_REF=101]="DT_FLOAT_REF",z[z.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",z[z.DT_INT32_REF=103]="DT_INT32_REF",z[z.DT_UINT8_REF=104]="DT_UINT8_REF",z[z.DT_INT16_REF=105]="DT_INT16_REF",z[z.DT_INT8_REF=106]="DT_INT8_REF",z[z.DT_STRING_REF=107]="DT_STRING_REF",z[z.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",z[z.DT_INT64_REF=109]="DT_INT64_REF",z[z.DT_BOOL_REF=110]="DT_BOOL_REF",z[z.DT_QINT8_REF=111]="DT_QINT8_REF",z[z.DT_QUINT8_REF=112]="DT_QUINT8_REF",z[z.DT_QINT32_REF=113]="DT_QINT32_REF",z[z.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",z[z.DT_QINT16_REF=115]="DT_QINT16_REF",z[z.DT_QUINT16_REF=116]="DT_QUINT16_REF",z[z.DT_UINT16_REF=117]="DT_UINT16_REF",z[z.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",z[z.DT_HALF_REF=119]="DT_HALF_REF",z[z.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",z[z.DT_VARIANT_REF=121]="DT_VARIANT_REF",z[z.DT_UINT32_REF=122]="DT_UINT32_REF",z[z.DT_UINT64_REF=123]="DT_UINT64_REF",z}(B||{});!function(z){let I;var M;(M=I=z.CheckpointFormatVersion||(z.CheckpointFormatVersion={}))[M.LEGACY=0]="LEGACY",M[M.V1=1]="V1",M[M.V2=2]="V2"}(ot||(ot={}));const P={};function at(z,I){P[z]={tfOpName:z,category:"custom",inputs:[],attrs:[],customExecutor:I}}function nt(z){return P[z]}function Gt(z){delete P[z]}function O(z,I,M,tt,wt){const At=I.inputParams[z];if(At&&void 0!==At.inputIndexStart){const kt=At.inputIndexStart,ae=0===At.inputIndexEnd?void 0:void 0===At.inputIndexEnd?kt+1:At.inputIndexEnd,nn=kt<0?I.inputNames.length+kt:kt;if("tensor"===At.type)return Ct(I.inputNames[nn],M,tt,wt);if("tensors"===At.type){const Cn=I.inputs.slice(kt,ae);return I.inputNames.slice(kt,ae).filter((Vn,vr)=>{var wn;return"NoOp"!==(null===(wn=Cn[vr])||void 0===wn?void 0:wn.op)}).map(Vn=>Ct(Vn,M,tt,wt))}const Ye=Ct(I.inputNames[nn],M,tt,wt),$e=Ye.dataSync();return"number"===At.type?$e[0]:Q.util.toNestedArray(Ye.shape,$e)}const Yt=I.attrParams[z];return Yt&&Yt.value}function Ct(z,I,M,tt){const[wt,At]=Mt(z,M);if(null!=tt){const kt=tt.getHashTableHandleByName(wt);if(null!=kt)return kt}const Yt=M.currentContextIds.find(kt=>!!I[xt(wt,kt)]);return void 0!==Yt?I[xt(wt,Yt)][At]:void 0}function yt(z,I,M){return I[xt(z,M.currentContextId)]}function vt(z,I){const[M,tt,wt]=Mt(z,I);return[xt(M,I&&I.currentContextId),tt,wt]}function xt(z,I){return I?`${z}-${I}`:z}function Mt(z,I){if(""===z)return["",0,void 0];const M=null!=I&&null!=I.parseNodeNameCache;if(M){const At=I.parseNodeNameCache.get(z);if(null!=At)return At}const tt=z.split(":");let wt;if(1===tt.length)wt=[z,0,void 0];else{const Yt=3===tt.length?tt[1]:void 0;wt=[tt[0],Number(tt[tt.length-1]),Yt]}return M&&I.parseNodeNameCache.set(z,wt),wt}function re(z,I,M){let tt=O("pad",z,I,M);if("explicit"===tt){tt=O("explicitPaddings",z,I,M);const wt=[[0,0],[0,0],[0,0],[0,0]];for(let At=0;At<4;At++)wt[At][0]=tt[2*At],wt[At][1]=tt[2*At+1];return wt}return tt}function Bt(z){return z.kept?z:(0,Q.clone)(z)}const ee=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],se=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],be=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Me=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Xe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],De=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Tn=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],On=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],ne=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],pe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Ie=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Je=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Gn=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Er=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Nn=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Yn=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],hi=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class di{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const M=[].concat(...[$,V,H,q,Y,R,W,k,A,X,Z,G,it,bt,K,st,et,dt,lt].map(tt=>tt.json));this.opMappers=M.reduce((tt,wt)=>(tt[wt.tfOpName]=wt,tt),{})}transformGraph(I,M={}){const wt=[],At=[],Yt=[],kt=I.node.reduce((vr,wn)=>(vr[wn.name]=this.mapNode(wn),wn.op.startsWith("Placeholder")?wt.push(vr[wn.name]):"Const"===wn.op?At.push(vr[wn.name]):(null==wn.input||0===wn.input.length)&&Yt.push(vr[wn.name]),vr),{});let ae=[];const nn=[];let Ye={},$e={};null!=M&&(Ye=this.mapSignatureEntries(M.inputs),$e=this.mapSignatureEntries(M.outputs));const Cn=Object.keys(kt);Cn.forEach(vr=>{const wn=kt[vr];wn.inputNames.forEach((_r,ni)=>{const[Zs,,Xr]=vt(_r),tn=kt[Zs];if(null!=tn.outputs){const Su=tn.outputs.indexOf(Xr);-1!==Su&&(wn.inputNames[ni]=`${Zs}:${Su}`)}wn.inputs.push(tn),tn.children.push(wn)})}),0===Object.keys($e).length?Cn.forEach(vr=>{const wn=kt[vr];0===wn.children.length&&nn.push(wn)}):Object.keys($e).forEach(vr=>{const[wn]=vt(vr),_r=kt[wn];null!=_r&&(_r.signatureKey=$e[vr],nn.push(_r))}),Object.keys(Ye).length>0?Object.keys(Ye).forEach(vr=>{const[wn]=vt(vr),_r=kt[wn];_r&&(_r.signatureKey=Ye[vr],ae.push(_r))}):ae=wt;let $n={};null!=I.library&&null!=I.library.function&&($n=I.library.function.reduce((vr,wn)=>(vr[wn.signature.name]=this.mapFunction(wn),vr),{}));const Vn={nodes:kt,inputs:ae,outputs:nn,weights:At,placeholders:wt,signature:M,functions:$n};return Yt.length>0&&(Vn.initNodes=Yt),Vn}mapSignatureEntries(I){return Object.keys(I||{}).reduce((M,tt)=>(M[I[tt].name]=tt,M),{})}mapNode(I){const M=nt(I.op)||this.opMappers[I.op]||{};null==I.attr&&(I.attr={});const tt={name:I.name,op:I.op,category:M.category,inputNames:(I.input||[]).map(wt=>wt.startsWith("^")?wt.slice(1):wt),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:I.attr,outputs:M.outputs};return null!=M.inputs&&(tt.inputParams=M.inputs.reduce((wt,At)=>(wt[At.name]={type:At.type,inputIndexStart:At.start,inputIndexEnd:At.end},wt),{})),null!=M.attrs&&(tt.attrParams=M.attrs.reduce((wt,At)=>{const Yt=At.type;let kt;switch(At.type){case"string":kt=yn(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=yn(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"string[]":kt=ie(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=ie(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"number":kt=Eo(I.attr,At.tfName,At.defaultValue||0),void 0===kt&&At.tfDeprecatedName&&(kt=Eo(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"number[]":kt=oe(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=oe(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"bool":kt=Qo(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Qo(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"bool[]":kt=Oe(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Oe(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"shape":kt=te(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=te(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"shape[]":kt=ze(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=ze(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"dtype":kt=Ce(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Ce(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"dtype[]":kt=Et(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Et(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"func":kt=Hs(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Hs(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${At.type} for op: ${I.op}`)}return wt[At.name]={value:kt,type:Yt},wt},{})),tt}mapFunction(I){const M=I.nodeDef,wt=[];let At={};null!=M&&(At=M.reduce(($e,Cn)=>($e[Cn.name]=this.mapNode(Cn),"Const"===Cn.op&&wt.push($e[Cn.name]),$e),{}));const Yt=[],kt=[];I.signature.inputArg.forEach($e=>{const[Cn]=vt($e.name),$n={name:Cn,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Hn($e.type),type:"dtype"}},children:[]};$n.signatureKey=$e.name,Yt.push($n),At[Cn]=$n}),Object.keys(At).forEach($e=>{const Cn=At[$e];Cn.inputNames.forEach(($n,Vn)=>{const[vr,,wn]=vt($n),_r=At[vr];if(null!=_r.outputs){const ni=_r.outputs.indexOf(wn);-1!==ni&&(Cn.inputNames[Vn]=`${vr}:${ni}`)}Cn.inputs.push(_r),_r.children.push(Cn)})});const nn=I.ret;I.signature.outputArg.forEach($e=>{const[Cn,$n]=vt(nn[$e.name]),Vn=At[Cn];null!=Vn&&(Vn.defaultOutput=$n,kt.push(Vn))});const Ye=this.mapArgsToSignature(I);return{nodes:At,inputs:Yt,outputs:kt,weights:wt,placeholders:[],signature:Ye}}mapArgsToSignature(I){return{methodName:I.signature.name,inputs:I.signature.inputArg.reduce((M,tt)=>(M[tt.name]=this.mapArgToTensorInfo(tt),M),{}),outputs:I.signature.outputArg.reduce((M,tt)=>(M[tt.name]=this.mapArgToTensorInfo(tt,I.ret),M),{})}}mapArgToTensorInfo(I,M){let tt=I.name;return null!=M&&(tt=M[tt]),{name:tt,dtype:I.type}}}function ii(z,I){const M=Array.isArray(z)?String.fromCharCode.apply(null,z):function to(z){const I=(0,Q.env)().global;if(typeof I.atob<"u")return I.atob(z);if(typeof Buffer<"u")return new Buffer(z,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(z);return I?M:M.toLowerCase()}function yn(z,I,M,tt=!1){const wt=z[I];return null!=wt?ii(wt.s,tt):M}function Qo(z,I,M){const tt=z[I];return tt?tt.b:M}function Eo(z,I,M){const tt=z[I]||{},wt=null!=tt.i?tt.i:null!=tt.f?tt.f:M;return"number"==typeof wt?wt:parseInt(wt,10)}function Hn(z){switch("string"==typeof z&&(z=B[z]),z){case B.DT_FLOAT:case B.DT_HALF:return"float32";case B.DT_INT32:case B.DT_INT64:case B.DT_INT8:case B.DT_UINT8:return"int32";case B.DT_BOOL:return"bool";case B.DT_DOUBLE:return"float32";case B.DT_STRING:return"string";case B.DT_COMPLEX64:case B.DT_COMPLEX128:return"complex64";default:return null}}function Hs(z,I,M){const tt=z[I];return tt&&tt.func?tt.func.name:M}function Ce(z,I,M){const tt=z[I];return tt&&tt.type?Hn(tt.type):M}function Et(z,I,M){const tt=z[I];return tt&&tt.list&&tt.list.type?tt.list.type.map(wt=>Hn(wt)):M}function Rt(z){if(!z.unknownRank)return null!=z.dim?z.dim.map(I=>"number"==typeof I.size?I.size:parseInt(I.size,10)):[]}function te(z,I,M){const tt=z[I];return tt&&tt.shape?Rt(tt.shape):M}function oe(z,I,M){const tt=z[I];return tt?((tt.list.f&&tt.list.f.length?tt.list.f:tt.list.i)||[]).map(wt=>"number"==typeof wt?wt:parseInt(wt,10)):M}function ie(z,I,M,tt=!1){const wt=z[I];return wt&&wt.list&&wt.list.s?wt.list.s.map(At=>ii(At,tt)):M}function ze(z,I,M){const tt=z[I];return tt&&tt.list&&tt.list.shape?tt.list.shape.map(wt=>Rt(wt)):M}function Oe(z,I,M){const tt=z[I];return tt&&tt.list&&tt.list.b?tt.list.b:M}class je{constructor(I,M,tt){this.node=I,this.tensorMap=M,this.context=tt,this.inputs=[],this.attrs={},this.inputs=I.inputNames.map(wt=>this.getInput(wt)),null!=I.rawAttrs&&(this.attrs=Object.keys(I.rawAttrs).reduce((wt,At)=>(wt[At]=this.getAttr(At),wt),{}))}getInput(I){return Ct(I,this.tensorMap,this.context)}getAttr(I,M){const tt=this.node.rawAttrs[I];if(null!=tt.tensor)return Ct(I,this.tensorMap,this.context);if(null!=tt.i||null!=tt.f)return Eo(this.node.rawAttrs,I,M);if(null!=tt.s)return yn(this.node.rawAttrs,I,M);if(null!=tt.b)return Qo(this.node.rawAttrs,I,M);if(null!=tt.shape)return te(this.node.rawAttrs,I,M);if(null!=tt.type)return Ce(this.node.rawAttrs,I,M);if(null!=tt.list){if(null!=tt.list.i||null!=tt.list.f)return oe(this.node.rawAttrs,I,M);if(null!=tt.list.s)return ie(this.node.rawAttrs,I,M);if(null!=tt.list.shape)return ze(this.node.rawAttrs,I,M);if(null!=tt.list.b)return Oe(this.node.rawAttrs,I,M);if(null!=tt.list.type)return Et(this.node.rawAttrs,I,M)}return M}}var Xt=y(3667);function un(z,I,M=""){if("number"!=typeof z&&"number"!=typeof I){Q.util.assert(z.length===I.length,()=>M+` Shapes ${z} and ${I} must match`);for(let tt=0;tt<z.length;tt++){const wt=z[tt],At=I[tt];Q.util.assert(wt<0||At<0||wt===At,()=>M+` Shapes ${z} and ${I} must match`)}}}function tr(z){return!("number"==typeof z||z.some(I=>I<0))}function dr(z,I,M){let tt=zn(z,M);const wt=!tr(tt);if(wt&&0===I.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${tt}`);if(wt&&I.forEach(At=>{tt=zn(At.shape,tt)}),!tr(tt))throw new Error(`Non-fully-defined elementShape: ${tt}`);return tt}function zn(z,I){if("number"==typeof z)return I;if("number"==typeof I)return z;if(z.length!==I.length)throw new Error(`Incompatible ranks during merge: ${z} vs. ${I}`);const M=[];for(let tt=0;tt<z.length;++tt){const wt=z[tt],At=I[tt];if(wt>=0&&At>=0&&wt!==At)throw new Error(`Incompatible shape during merge: ${z} vs. ${I}`);M[tt]=wt>=0?wt:At}return M}class vn{constructor(I,M,tt,wt,At,Yt,kt){this.name=I,this.dtype=M,this.maxSize=tt,this.elementShape=wt,this.identicalElementShapes=At,this.dynamicSize=Yt,this.clearAfterRead=kt,this.tensors=[],this.closed_=!1,this.idTensor=(0,Q.scalar)(0),(0,Q.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(I){this.tensors.forEach(M=>{(null==I||!I.has(M.tensor.id))&&M.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(I){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(I<0||I>=this.size())throw new Error(`Tried to read from index ${I}, but array size is: ${this.size()}`);const M=this.tensors[I];if(M.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${I} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(M.cleared=!0),M.read=!0,M.tensor}readMany(I){return I.map(M=>this.read(M))}write(I,M){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(I<0||!this.dynamicSize&&I>=this.maxSize)throw new Error(`Tried to write to index ${I}, but array is not resizeable and size is: ${this.maxSize}`);const tt=this.tensors[I]||{};if(M.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${I},\n          because the value dtype is ${M.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=M.shape),un(this.elementShape,M.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${I}.`),tt.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${I}, because it has already been read.`);if(tt.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${I}, because it has already been written.`);tt.tensor=M,(0,Q.keep)(M),tt.written=!0,this.tensors[I]=tt}writeMany(I,M){if(I.length!==M.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${I.length} is not the same as tensors size: ${M.length}.`);I.forEach((tt,wt)=>this.write(tt,M[wt]))}gather(I,M){if(M&&M!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${M}`);if(I)I=I.slice(0,this.size());else{I=[];for(let wt=0;wt<this.size();wt++)I.push(wt)}if(0===I.length)return(0,Q.tensor)([],[0].concat(this.elementShape));const tt=this.readMany(I);return un(this.elementShape,tt[0].shape,"TensorArray shape mismatch: "),(0,Q.stack)(tt,0)}concat(I){if(I&&I!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${I}`);if(0===this.size())return(0,Q.tensor)([],[0].concat(this.elementShape));const M=[];for(let wt=0;wt<this.size();wt++)M.push(wt);const tt=this.readMany(M);return un(this.elementShape,tt[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tt[0].shape})`),(0,Q.concat)(tt,0)}scatter(I,M){if(M.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${M.dtype}`);if(I.length!==M.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${I.length} vs. ${M.shape[0]}`);const tt=Math.max(...I);if(!this.dynamicSize&&tt>=this.maxSize)throw new Error(`Max index must be < array size (${tt}  vs. ${this.maxSize})`);this.writeMany(I,(0,Q.unstack)(M,0))}split(I,M){if(M.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${M.dtype}`);let tt=0;const wt=I.map(ae=>(tt+=ae,tt));if(tt!==M.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${tt}, and tensor's shape is: ${M.shape}`);if(!this.dynamicSize&&I.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${I.length}), and the TensorArray is not marked as dynamically resizeable`);const At=0===tt?0:M.size/tt,Yt=[];(0,Q.tidy)(()=>{M=(0,Q.reshape)(M,[1,tt,At]);for(let ae=0;ae<I.length;++ae)Yt[ae]=(0,Q.reshape)((0,Q.slice)(M,[0,0===ae?0:wt[ae-1],0],[1,I[ae],At]),this.elementShape);return Yt});const kt=[];for(let ae=0;ae<I.length;ae++)kt[ae]=ae;this.writeMany(kt,Yt)}}class sr{get id(){return this.idTensor.id}constructor(I,M,tt,wt=-1){this.tensors=I,this.elementShape=M,this.elementDtype=tt,I?.forEach(At=>{if(tt!==At.dtype)throw new Error(`Invalid data types; op elements ${tt}, but list elements ${At.dtype}`);un(M,At.shape,"TensorList shape mismatch: "),(0,Q.keep)(At)}),this.idTensor=(0,Q.scalar)(0),this.maxNumElements=wt,(0,Q.keep)(this.idTensor)}copy(){return new sr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(I){this.tensors.forEach(M=>{(null==I||!I.has(M.id))&&M.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(I,M,tt=-1){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);if(-1!==tt&&this.tensors.length!==tt)throw new Error(`Operation expected a list with ${tt} elements but got a list with ${this.tensors.length} elements.`);un(I,this.elementShape,"TensorList shape mismatch: ");const wt=dr(this.elementShape,this.tensors,I);return(0,Q.tidy)(()=>{const At=this.tensors.map(Yt=>(0,Q.reshape)(Yt,wt));return(0,Q.stack)(At,0)})}popBack(I,M){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const tt=dr(this.elementShape,this.tensors,I),wt=this.tensors.pop();return wt.kept=!1,un(wt.shape,I,"TensorList shape mismatch: "),(0,Q.reshape)(wt,tt)}pushBack(I){if(I.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${I.dtype}, but list elements ${this.elementDtype}`);if(un(I.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,Q.keep)(I),this.tensors.push(I)}resize(I){if(I<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${I}`);if(-1!==this.maxNumElements&&I>this.maxNumElements)throw new Error(`TensorListResize input size ${I} is greater maxNumElement ${this.maxNumElements}.`);const M=new sr([],this.elementShape,this.elementDtype,this.maxNumElements);M.tensors.length=I;for(let tt=0;tt<Math.min(this.tensors.length,I);++tt)M.tensors[tt]=this.tensors[tt];return M}getItem(I,M,tt){if(tt!==this.elementDtype)throw new Error(`Invalid data types; op elements ${tt}, but list elements ${this.elementDtype}`);if(I<0||I>this.tensors.length)throw new Error(`Trying to access element ${I} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[I])throw new Error(`element at index ${I} is null.`);un(this.tensors[I].shape,M,"TensorList shape mismatch: ");const wt=dr(this.elementShape,this.tensors,M);return(0,Q.reshape)(this.tensors[I],wt)}setItem(I,M){if(M.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M.dtype}, but list elements ${this.elementDtype}`);if(I<0||-1!==this.maxNumElements&&I>=this.maxNumElements)throw new Error(`Trying to set element ${I} in a list with max ${this.maxNumElements} elements.`);un(this.elementShape,M.shape,"TensorList shape mismatch: "),(0,Q.keep)(M),null!=this.tensors[I]&&(this.tensors[I].kept=!1),this.tensors[I]=M}gather(I,M,tt){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);un(this.elementShape,tt,"TensorList shape mismatch: "),I=I.slice(0,this.size());const wt=dr(this.elementShape,this.tensors,tt);return 0===I.length?(0,Q.tensor)([],[0].concat(wt)):(0,Q.tidy)(()=>{const At=I.map(Yt=>(0,Q.reshape)(this.tensors[Yt],wt));return(0,Q.stack)(At,0)})}concat(I,M){if(I&&I!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${I}`);un(this.elementShape,M,"TensorList shape mismatch: ");const tt=dr(this.elementShape,this.tensors,M);return 0===this.size()?(0,Q.tensor)([],[0].concat(tt)):(0,Q.tidy)(()=>{const wt=this.tensors.map(At=>(0,Q.reshape)(At,tt));return(0,Q.concat)(wt,0)})}}const si=function(){var z=(0,pt.Z)(function*(I,M,tt){switch(I.op){case"If":case"StatelessIf":{const wt=O("thenBranch",I,M,tt),At=O("elseBranch",I,M,tt),Yt=O("cond",I,M,tt),kt=O("args",I,M,tt);return(yield Yt.data())[0]?tt.functionMap[wt].executeFunctionAsync(kt,tt.tensorArrayMap,tt.tensorListMap):tt.functionMap[At].executeFunctionAsync(kt,tt.tensorArrayMap,tt.tensorListMap)}case"While":case"StatelessWhile":{const wt=O("body",I,M,tt),At=O("cond",I,M,tt),Yt=O("args",I,M,tt),kt=yield tt.functionMap[At].executeFunctionAsync(Yt,tt.tensorArrayMap,tt.tensorListMap),ae=Yt.map($e=>$e.id);let nn=yield kt[0].data();kt.forEach($e=>{!$e.kept&&-1===ae.indexOf($e.id)&&$e.dispose()});let Ye=Yt;for(;nn[0];){const $e=Ye;Ye=yield tt.functionMap[wt].executeFunctionAsync(Ye,tt.tensorArrayMap,tt.tensorListMap);const Cn=Ye.map(Vn=>Vn.id);$e.forEach(Vn=>{!Vn.kept&&-1===ae.indexOf(Vn.id)&&-1===Cn.indexOf(Vn.id)&&Vn.dispose()});const $n=yield tt.functionMap[At].executeFunctionAsync(Ye,tt.tensorArrayMap,tt.tensorListMap);nn=yield $n[0].data(),$n.forEach(Vn=>{!Vn.kept&&-1===ae.indexOf(Vn.id)&&-1===Cn.indexOf(Vn.id)&&Vn.dispose()})}return Ye}case"LoopCond":return[Bt(O("pred",I,M,tt))];case"Switch":{const wt=O("pred",I,M,tt);let At=O("data",I,M,tt);return At.kept||(At=Bt(At)),(yield wt.data())[0]?[void 0,At]:[At,void 0]}case"Merge":{const wt=I.inputNames.find(At=>void 0!==Ct(At,M,tt));return wt?[Bt(Ct(wt,M,tt))]:void 0}case"Enter":{const wt=O("frameName",I,M,tt),At=O("tensor",I,M,tt);return tt.enterFrame(wt),[Bt(At)]}case"Exit":{const wt=O("tensor",I,M,tt);return tt.exitFrame(),[Bt(wt)]}case"NextIteration":{const wt=O("tensor",I,M,tt);return tt.nextIteration(),[Bt(wt)]}case"TensorArrayV3":{const wt=O("size",I,M,tt),At=O("dtype",I,M,tt),Yt=O("elementShape",I,M,tt),kt=O("dynamicSize",I,M,tt),ae=O("clearAfterRead",I,M,tt),nn=O("identicalElementShapes",I,M,tt),Ye=O("name",I,M,tt),$e=new vn(Ye,At,wt,Yt,nn,kt,ae);return tt.addTensorArray($e),[$e.idTensor,(0,Q.scalar)(1)]}case"TensorArrayWriteV3":{const wt=O("tensorArrayId",I,M,tt),At=O("index",I,M,tt),Yt=O("tensor",I,M,tt),kt=tt.getTensorArray(wt.id);return kt.write(At,Yt),[kt.idTensor]}case"TensorArrayReadV3":{const wt=O("tensorArrayId",I,M,tt),At=O("index",I,M,tt);return[tt.getTensorArray(wt.id).read(At)]}case"TensorArrayGatherV3":{const wt=O("tensorArrayId",I,M,tt),At=O("indices",I,M,tt),Yt=O("dtype",I,M,tt);return[tt.getTensorArray(wt.id).gather(At,Yt)]}case"TensorArrayScatterV3":{const wt=O("tensorArrayId",I,M,tt),At=O("indices",I,M,tt),Yt=O("tensor",I,M,tt),kt=tt.getTensorArray(wt.id);return kt.scatter(At,Yt),[kt.idTensor]}case"TensorArrayConcatV3":{const wt=O("tensorArrayId",I,M,tt),At=tt.getTensorArray(wt.id),Yt=O("dtype",I,M,tt);return[At.concat(Yt)]}case"TensorArraySplitV3":{const wt=O("tensorArrayId",I,M,tt),At=O("tensor",I,M,tt),Yt=O("lengths",I,M,tt),kt=tt.getTensorArray(wt.id);return kt.split(Yt,At),[kt.idTensor]}case"TensorArraySizeV3":{const wt=O("tensorArrayId",I,M,tt),At=tt.getTensorArray(wt.id);return[(0,Q.scalar)(At.size(),"int32")]}case"TensorArrayCloseV3":{const wt=O("tensorArrayId",I,M,tt),At=tt.getTensorArray(wt.id);return At.clearAndClose(),[At.idTensor]}case"TensorListSetItem":{const wt=O("tensorListId",I,M,tt),At=O("index",I,M,tt),Yt=O("tensor",I,M,tt),kt=tt.getTensorList(wt.id);return kt.setItem(At,Yt),[kt.idTensor]}case"TensorListGetItem":{const wt=O("tensorListId",I,M,tt),At=O("index",I,M,tt),Yt=O("elementShape",I,M,tt),kt=O("elementDType",I,M,tt);return[tt.getTensorList(wt.id).getItem(At,Yt,kt)]}case"TensorListScatterV2":case"TensorListScatter":{const wt=O("indices",I,M,tt),ae=function wr(z,I,M,tt){if(I.length!==z.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${I.length} vs. ${z.shape[0]}`);const wt=Math.max(...I);if(null!=tt&&-1!==tt&&wt>=tt)throw new Error(`Max index must be < array size (${wt}  vs. ${tt})`);const At=new sr([],M,z.dtype,tt),Yt=(0,Q.unstack)(z,0);return I.forEach((kt,ae)=>{At.setItem(kt,Yt[ae])}),At}(O("tensor",I,M,tt),wt,O("elementShape",I,M,tt),O("numElements",I,M,tt));return tt.addTensorList(ae),[ae.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const wt=O("elementShape",I,M,tt),At=O("elementDType",I,M,tt);let Yt;Yt="TensorListReserve"===I.op?"numElements":"maxNumElements";const kt=O(Yt,I,M,tt),nn=function Qn(z,I,M,tt){return new sr([],z,I,tt)}(wt,At,0,"TensorListReserve"===I.op?-1:kt);return tt.addTensorList(nn),[nn.idTensor]}case"TensorListGather":{const wt=O("tensorListId",I,M,tt),At=O("indices",I,M,tt),Yt=O("elementShape",I,M,tt),kt=O("elementDType",I,M,tt);return[tt.getTensorList(wt.id).gather(At,kt,Yt)]}case"TensorListStack":{const wt=O("tensorListId",I,M,tt),At=O("elementShape",I,M,tt),Yt=O("elementDType",I,M,tt),kt=O("numElements",I,M,tt);return[tt.getTensorList(wt.id).stack(At,Yt,kt)]}case"TensorListFromTensor":{const kt=function Jr(z,I,M){const tt=z.dtype;if(z.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${z.shape}`);if(z.dtype!==M)throw new Error(`Invalid data types; op elements ${z.dtype}, but list elements ${M}`);un(z.shape.slice(1),I,"TensorList shape mismatch: ");const At=(0,Q.unstack)(z);return new sr(At,I,tt)}(O("tensor",I,M,tt),O("elementShape",I,M,tt),O("elementDType",I,M,tt));return tt.addTensorList(kt),[kt.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const wt=O("tensorListId",I,M,tt),At=tt.getTensorList(wt.id),Yt=O("dtype",I,M,tt),kt=O("elementShape",I,M,tt);return[At.concat(Yt,kt)]}case"TensorListPushBack":{const wt=O("tensorListId",I,M,tt),At=O("tensor",I,M,tt),Yt=tt.getTensorList(wt.id);return Yt.pushBack(At),[Yt.idTensor]}case"TensorListPopBack":{const wt=O("tensorListId",I,M,tt),At=O("elementShape",I,M,tt),Yt=O("elementDType",I,M,tt);return[tt.getTensorList(wt.id).popBack(At,Yt)]}case"TensorListSplit":{const wt=O("tensor",I,M,tt),At=O("elementShape",I,M,tt),kt=function Dn(z,I,M){let tt=0;const wt=I.map(Ye=>(tt+=Ye,tt));if(tt!==z.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${tt}, and tensor's shape is: ${z.shape}`);const Yt=zn(z.shape.slice(1),M),kt=0===tt?0:z.size/tt,ae=(0,Q.tidy)(()=>{const Ye=[];z=(0,Q.reshape)(z,[1,tt,kt]);for(let $e=0;$e<I.length;++$e)Ye[$e]=(0,Q.reshape)((0,Q.slice)(z,[0,0===$e?0:wt[$e-1],0],[1,I[$e],kt]),Yt);return z.dispose(),Ye}),nn=new sr([],M,z.dtype,I.length);for(let Ye=0;Ye<ae.length;Ye++)nn.setItem(Ye,ae[Ye]);return nn}(wt,O("lengths",I,M,tt),At);return tt.addTensorList(kt),[kt.idTensor]}case"TensorListLength":{const wt=O("tensorListId",I,M,tt),At=tt.getTensorList(wt.id);return[(0,Q.scalar)(At.size(),"int32")]}case"TensorListResize":{const wt=O("tensorListId",I,M,tt),At=O("size",I,M,tt),kt=tt.getTensorList(wt.id).resize(At);return tt.addTensorList(kt),[kt.idTensor]}default:throw TypeError(`Node type ${I.op} is not implemented`)}});return function(M,tt,wt){return z.apply(this,arguments)}}();function er(z,I,M){const[tt,wt]=O("fusedOps",z,I,M),At="biasadd"===tt,Yt=!At,kt="prelu"===wt,ae="fusedbatchnorm"===tt,nn=O("numArgs",z,I,M);if(At){if(kt&&2!==nn)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!kt&&At&&1!==nn)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(ae)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const Ye=O("strides",z,I,M),$e=re(z,I,M),Cn=O("dataFormat",z,I,M).toUpperCase(),$n=O("dilations",z,I,M);let[Vn,vr]=O("args",z,I,M);return Yt&&(vr=Vn,Vn=void 0),{stride:Ye,pad:$e,dataFormat:Cn,dilations:$n,biasArg:Vn,preluArg:vr,activationFunc:wt,leakyreluAlpha:O("leakyreluAlpha",z,I,M)}}function js(z,I,M){return{boxes:O("boxes",z,I,M),scores:O("scores",z,I,M),maxOutputSize:O("maxOutputSize",z,I,M),iouThreshold:O("iouThreshold",z,I,M),scoreThreshold:O("scoreThreshold",z,I,M),softNmsSigma:O("softNmsSigma",z,I,M)}}const ho=function(){var z=(0,pt.Z)(function*(I,M,tt,wt,At=St){switch(I.op){case"NonMaxSuppressionV5":{const{boxes:Yt,scores:kt,maxOutputSize:ae,iouThreshold:nn,scoreThreshold:Ye,softNmsSigma:$e}=js(I,M,tt),Cn=yield At.image.nonMaxSuppressionWithScoreAsync(Yt,kt,ae,nn,Ye,$e);return[Cn.selectedIndices,Cn.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:Yt,scores:kt,maxOutputSize:ae,iouThreshold:nn,scoreThreshold:Ye}=js(I,M,tt),$e=O("padToMaxOutputSize",I,M,tt),Cn=yield At.image.nonMaxSuppressionPaddedAsync(Yt,kt,ae,nn,Ye,$e);return[Cn.selectedIndices,Cn.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:Yt,scores:kt,maxOutputSize:ae,iouThreshold:nn,scoreThreshold:Ye}=js(I,M,tt);return[yield At.image.nonMaxSuppressionAsync(Yt,kt,ae,nn,Ye)]}case"Where":{const Yt=At.cast(O("condition",I,M,tt),"bool"),kt=[yield At.whereAsync(Yt)];return Yt.dispose(),kt}case"ListDiff":return At.setdiff1dAsync(O("x",I,M,tt),O("y",I,M,tt));default:throw TypeError(`Node type ${I.op} is not implemented`)}});return function(M,tt,wt,At){return z.apply(this,arguments)}}();var Co=y(8661);class Ls{get id(){return this.handle.id}constructor(I,M){this.keyDType=I,this.valueDType=M,this.handle=(0,Q.scalar)(0),this.tensorMap=new Map,(0,Q.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach(I=>I.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Co.i(this.size(),"int32")}import(I,M){var tt=this;return(0,pt.Z)(function*(){tt.checkKeyAndValueTensor(I,M);const wt=yield I.data();return tt.tensorMap.forEach(At=>At.dispose()),tt.tensorMap.clear(),(0,Q.tidy)(()=>{const At=(0,Q.unstack)(M),Yt=wt.length,kt=At.length;Q.util.assert(Yt===kt,()=>`The number of elements doesn't match, keys has ${Yt} elements, the values has ${kt} elements.`);for(let ae=0;ae<Yt;ae++){const nn=wt[ae],Ye=At[ae];(0,Q.keep)(Ye),tt.tensorMap.set(nn,Ye)}return tt.handle})})()}find(I,M){var tt=this;return(0,pt.Z)(function*(){tt.checkKeyAndValueTensor(I,M);const wt=yield I.data();return(0,Q.tidy)(()=>{const At=[];for(let Yt=0;Yt<wt.length;Yt++){const ae=tt.findWithDefault(wt[Yt],M);At.push(ae)}return(0,Q.stack)(At)})})()}findWithDefault(I,M){return this.tensorMap.get(I)??M}checkKeyAndValueTensor(I,M){if(I.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${I.dtype}`);if(M.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${M.dtype}`)}}const Pa=function(){var z=(0,pt.Z)(function*(I,M,tt,wt){switch(I.op){case"HashTable":case"HashTableV2":{const At=wt.getHashTableHandleByName(I.name);if(null!=At)return[At];{const Yt=O("keyDType",I,M,tt),kt=O("valueDType",I,M,tt),ae=new Ls(Yt,kt);return wt.addHashTable(I.name,ae),[ae.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const At=O("tableHandle",I,M,tt,wt),Yt=O("keys",I,M,tt),kt=O("values",I,M,tt);return[yield wt.getHashTableById(At.id).import(Yt,kt)]}case"LookupTableFind":case"LookupTableFindV2":{const At=O("tableHandle",I,M,tt,wt),Yt=O("keys",I,M,tt),kt=O("defaultValue",I,M,tt);return[yield wt.getHashTableById(At.id).find(Yt,kt)]}case"LookupTableSize":case"LookupTableSizeV2":{const At=O("tableHandle",I,M,tt,wt);return[wt.getHashTableById(At.id).tensorSize()]}default:throw TypeError(`Node type ${I.op} is not implemented`)}});return function(M,tt,wt,At){return z.apply(this,arguments)}}();function Cs(z,I,M,tt,wt=Q.tidy){const At=((Yt,kt,ae)=>{switch(Yt.category){case"arithmetic":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"BiasAdd":case"AddV2":case"Add":return[tt.add(O("a",z,I,M),O("b",z,I,M))];case"AddN":return[tt.addN(O("tensors",z,I,M))];case"FloorMod":case"Mod":return[tt.mod(O("a",z,I,M),O("b",z,I,M))];case"Mul":return[tt.mul(O("a",z,I,M),O("b",z,I,M))];case"RealDiv":case"Div":return[tt.div(O("a",z,I,M),O("b",z,I,M))];case"DivNoNan":return[tt.divNoNan(O("a",z,I,M),O("b",z,I,M))];case"FloorDiv":return[tt.floorDiv(O("a",z,I,M),O("b",z,I,M))];case"Sub":return[tt.sub(O("a",z,I,M),O("b",z,I,M))];case"Minimum":return[tt.minimum(O("a",z,I,M),O("b",z,I,M))];case"Maximum":return[tt.maximum(O("a",z,I,M),O("b",z,I,M))];case"Pow":return[tt.pow(O("a",z,I,M),O("b",z,I,M))];case"SquaredDifference":return[tt.squaredDifference(O("a",z,I,M),O("b",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"basic_math":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Abs":case"ComplexAbs":return[tt.abs(O("x",z,I,M))];case"Acos":return[tt.acos(O("x",z,I,M))];case"Acosh":return[tt.acosh(O("x",z,I,M))];case"Asin":return[tt.asin(O("x",z,I,M))];case"Asinh":return[tt.asinh(O("x",z,I,M))];case"Atan":return[tt.atan(O("x",z,I,M))];case"Atan2":return[tt.atan2(O("x",z,I,M),O("y",z,I,M))];case"Atanh":return[tt.atanh(O("x",z,I,M))];case"Ceil":return[tt.ceil(O("x",z,I,M))];case"Complex":return[tt.complex(O("real",z,I,M),O("imag",z,I,M))];case"Cos":return[tt.cos(O("x",z,I,M))];case"Cosh":return[tt.cosh(O("x",z,I,M))];case"Elu":return[tt.elu(O("x",z,I,M))];case"Erf":return[tt.erf(O("x",z,I,M))];case"Exp":return[tt.exp(O("x",z,I,M))];case"Expm1":return[tt.expm1(O("x",z,I,M))];case"Floor":return[tt.floor(O("x",z,I,M))];case"Log":return[tt.log(O("x",z,I,M))];case"Log1p":return[tt.log1p(O("x",z,I,M))];case"Imag":return[tt.imag(O("x",z,I,M))];case"Neg":return[tt.neg(O("x",z,I,M))];case"Reciprocal":return[tt.reciprocal(O("x",z,I,M))];case"Real":return[tt.real(O("x",z,I,M))];case"Relu":return[tt.relu(O("x",z,I,M))];case"Round":return[tt.round(O("x",z,I,M))];case"Selu":return[tt.selu(O("x",z,I,M))];case"Sigmoid":return[tt.sigmoid(O("x",z,I,M))];case"Sin":return[tt.sin(O("x",z,I,M))];case"Sign":return[tt.sign(O("x",z,I,M))];case"Sinh":return[tt.sinh(O("x",z,I,M))];case"Softplus":return[tt.softplus(O("x",z,I,M))];case"Sqrt":return[tt.sqrt(O("x",z,I,M))];case"Square":return[tt.square(O("x",z,I,M))];case"Tanh":return[tt.tanh(O("x",z,I,M))];case"Tan":return[tt.tan(O("x",z,I,M))];case"ClipByValue":return[tt.clipByValue(O("x",z,I,M),O("clipValueMin",z,I,M),O("clipValueMax",z,I,M))];case"Relu6":return[tt.relu6(O("x",z,I,M))];case"Rsqrt":return[tt.rsqrt(Ct(z.inputNames[0],I,M))];case"LeakyRelu":return[tt.leakyRelu(O("x",z,I,M),O("alpha",z,I,M))];case"Prelu":return[tt.prelu(O("x",z,I,M),O("alpha",z,I,M))];case"IsNan":return[tt.isNaN(Ct(z.inputNames[0],I,M))];case"IsInf":return[tt.isInf(Ct(z.inputNames[0],I,M))];case"IsFinite":return[tt.isFinite(Ct(z.inputNames[0],I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"control":return si(Yt,kt,ae);case"convolution":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Conv1D":{const wt=O("stride",z,I,M),At=O("pad",z,I,M),Yt=O("dataFormat",z,I,M).toUpperCase(),kt=O("dilation",z,I,M);return[tt.conv1d(O("x",z,I,M),O("filter",z,I,M),wt,At,Yt,kt)]}case"Conv2D":{const wt=O("strides",z,I,M),At=re(z,I,M),Yt=O("dataFormat",z,I,M).toUpperCase(),kt=O("dilations",z,I,M);return[tt.conv2d(O("x",z,I,M),O("filter",z,I,M),[wt[1],wt[2]],At,Yt,[kt[1],kt[2]])]}case"_FusedConv2D":{const{stride:wt,pad:At,dataFormat:Yt,dilations:kt,biasArg:ae,preluArg:nn,activationFunc:Ye,leakyreluAlpha:$e}=er(z,I,M);return[tt.fused.conv2d({x:O("x",z,I,M),filter:O("filter",z,I,M),strides:[wt[1],wt[2]],pad:At,dataFormat:Yt,dilations:[kt[1],kt[2]],bias:ae,activation:Ye,preluActivationWeights:nn,leakyreluAlpha:$e})]}case"FusedDepthwiseConv2dNative":{const{stride:wt,pad:At,dataFormat:Yt,dilations:kt,biasArg:ae,preluArg:nn,activationFunc:Ye,leakyreluAlpha:$e}=er(z,I,M);return[tt.fused.depthwiseConv2d({x:O("x",z,I,M),filter:O("filter",z,I,M),strides:[wt[1],wt[2]],pad:At,dataFormat:Yt,dilations:[kt[1],kt[2]],bias:ae,activation:Ye,preluActivationWeights:nn,leakyreluAlpha:$e})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const wt=O("outputShape",z,I,M),At=O("strides",z,I,M),Yt=re(z,I,M);return[tt.conv2dTranspose(O("x",z,I,M),O("filter",z,I,M),wt,[At[1],At[2]],Yt)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const wt=O("strides",z,I,M),At=re(z,I,M),Yt=O("dilations",z,I,M),kt=O("dataFormat",z,I,M).toUpperCase();return[tt.depthwiseConv2d(O("input",z,I,M),O("filter",z,I,M),[wt[1],wt[2]],At,kt,[Yt[1],Yt[2]])]}case"Conv3D":{const wt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("dataFormat",z,I,M).toUpperCase(),kt=O("dilations",z,I,M);return[tt.conv3d(O("x",z,I,M),O("filter",z,I,M),[wt[1],wt[2],wt[3]],At,Yt,[kt[1],kt[2],kt[3]])]}case"AvgPool":{const wt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M);return[tt.avgPool(O("x",z,I,M),[Yt[1],Yt[2]],[wt[1],wt[2]],At)]}case"MaxPool":{const wt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M);return[tt.maxPool(O("x",z,I,M),[Yt[1],Yt[2]],[wt[1],wt[2]],At)]}case"MaxPoolWithArgmax":{const wt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M),kt=O("includeBatchInIndex",z,I,M),{result:ae,indexes:nn}=tt.maxPoolWithArgmax(O("x",z,I,M),[Yt[1],Yt[2]],[wt[1],wt[2]],At,kt);return[ae,nn]}case"AvgPool3D":{const wt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M);return[tt.avgPool3d(O("x",z,I,M),[Yt[1],Yt[2],Yt[3]],[wt[1],wt[2],wt[3]],At)]}case"MaxPool3D":{const wt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M);return[tt.maxPool3d(O("x",z,I,M),[Yt[1],Yt[2],Yt[3]],[wt[1],wt[2],wt[3]],At)]}case"Dilation2D":{const wt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("dilations",z,I,M),kt=wt[1],ae=wt[2],nn=Yt[1],Ye=Yt[2];return[tt.dilation2d(O("x",z,I,M),O("filter",z,I,M),[kt,ae],At,[nn,Ye],"NHWC")]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"creation":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Fill":{const wt=O("shape",z,I,M),At=O("dtype",z,I,M),Yt=O("value",z,I,M);return[tt.fill(wt,Yt,At)]}case"LinSpace":{const wt=O("start",z,I,M),At=O("stop",z,I,M),Yt=O("num",z,I,M);return[tt.linspace(wt,At,Yt)]}case"Multinomial":{const wt=O("logits",z,I,M),At=O("numSamples",z,I,M),Yt=O("seed",z,I,M);return[tt.multinomial(wt,At,Yt)]}case"OneHot":{const wt=O("indices",z,I,M),At=O("depth",z,I,M),Yt=O("onValue",z,I,M),kt=O("offValue",z,I,M),ae=O("dtype",z,I,M);return[tt.oneHot(wt,At,Yt,kt,ae)]}case"Ones":return[tt.ones(O("shape",z,I,M),O("dtype",z,I,M))];case"OnesLike":return[tt.onesLike(O("x",z,I,M))];case"RandomStandardNormal":return[tt.randomStandardNormal(O("shape",z,I,M),O("dtype",z,I,M),O("seed",z,I,M))];case"RandomUniform":return[tt.randomUniform(O("shape",z,I,M),O("minval",z,I,M),O("maxval",z,I,M),O("dtype",z,I,M))];case"RandomUniformInt":return[tt.randomUniformInt(O("shape",z,I,M),O("minval",z,I,M),O("maxval",z,I,M),O("seed",z,I,M))];case"Range":{const wt=O("start",z,I,M),At=O("stop",z,I,M),Yt=O("step",z,I,M);return[tt.range(wt,At,Yt,O("dtype",z,I,M))]}case"TruncatedNormal":{const wt=O("shape",z,I,M),At=O("mean",z,I,M),Yt=O("stdDev",z,I,M),kt=O("seed",z,I,M);return[tt.truncatedNormal(wt,At,Yt,O("dtype",z,I,M),kt)]}case"Zeros":return[tt.zeros(O("shape",z,I,M),O("dtype",z,I,M))];case"ZerosLike":return[tt.zerosLike(O("x",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"dynamic":return ho(Yt,kt,ae);case"evaluation":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"LowerBound":{const wt=O("sortedSequence",z,I,M),At=O("values",z,I,M);return[tt.lowerBound(wt,At)]}case"TopKV2":{const wt=O("x",z,I,M),At=O("k",z,I,M),Yt=O("sorted",z,I,M),kt=tt.topk(wt,At,Yt);return[kt.values,kt.indices]}case"UpperBound":{const wt=O("sortedSequence",z,I,M),At=O("values",z,I,M);return[tt.upperBound(wt,At)]}case"Unique":{const wt=O("x",z,I,M),At=tt.unique(wt);return[At.values,At.indices]}case"UniqueV2":{const wt=O("x",z,I,M),At=O("axis",z,I,M),Yt=tt.unique(wt,At);return[Yt.values,Yt.indices]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"image":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"ResizeBilinear":{const wt=O("images",z,I,M),At=O("size",z,I,M),Yt=O("alignCorners",z,I,M),kt=O("halfPixelCenters",z,I,M);return[tt.image.resizeBilinear(wt,[At[0],At[1]],Yt,kt)]}case"ResizeNearestNeighbor":{const wt=O("images",z,I,M),At=O("size",z,I,M),Yt=O("alignCorners",z,I,M),kt=O("halfPixelCenters",z,I,M);return[tt.image.resizeNearestNeighbor(wt,[At[0],At[1]],Yt,kt)]}case"CropAndResize":{const wt=O("image",z,I,M),At=O("boxes",z,I,M),Yt=O("boxInd",z,I,M),kt=O("cropSize",z,I,M),ae=O("method",z,I,M),nn=O("extrapolationValue",z,I,M);return[tt.image.cropAndResize(wt,At,Yt,kt,ae,nn)]}case"ImageProjectiveTransformV3":{const wt=O("images",z,I,M),At=O("transforms",z,I,M),Yt=O("outputShape",z,I,M),kt=O("fillValue",z,I,M),ae=O("interpolation",z,I,M),nn=O("fillMode",z,I,M);return[tt.image.transform(wt,At,ae.toLowerCase(),nn.toLowerCase(),kt,Yt)]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"graph":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Const":return I[z.name];case"PlaceholderWithDefault":const wt=O("default",z,I,M);return[Ct(z.name,I,M)||wt];case"Placeholder":return[Ct(z.name,I,M)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Bt(O("x",z,I,M))];case"IdentityN":return O("x",z,I,M).map(Ye=>Bt(Ye));case"Shape":return[tt.tensor1d(O("x",z,I,M).shape,"int32")];case"ShapeN":return O("x",z,I,M).map(Ye=>tt.tensor1d(Ye.shape));case"Size":return[tt.scalar(O("x",z,I,M).size,"int32")];case"Rank":return[tt.scalar(O("x",z,I,M).rank,"int32")];case"NoOp":return[tt.scalar(1)];case"Print":const Yt=O("x",z,I,M),kt=O("data",z,I,M),ae=O("message",z,I,M),nn=O("summarize",z,I,M);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(ae);for(let Ye=0;Ye<kt.length;Ye++)console.log(Array.prototype.slice.call(kt[Ye].dataSync()).slice(0,nn));return[Yt];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"logical":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Equal":return[tt.equal(O("a",z,I,M),O("b",z,I,M))];case"NotEqual":return[tt.notEqual(O("a",z,I,M),O("b",z,I,M))];case"Greater":return[tt.greater(O("a",z,I,M),O("b",z,I,M))];case"GreaterEqual":return[tt.greaterEqual(O("a",z,I,M),O("b",z,I,M))];case"Less":return[tt.less(O("a",z,I,M),O("b",z,I,M))];case"LessEqual":return[tt.lessEqual(O("a",z,I,M),O("b",z,I,M))];case"LogicalAnd":return[tt.logicalAnd(O("a",z,I,M),O("b",z,I,M))];case"LogicalNot":return[tt.logicalNot(O("a",z,I,M))];case"LogicalOr":return[tt.logicalOr(O("a",z,I,M),O("b",z,I,M))];case"Select":case"SelectV2":return[tt.where(O("condition",z,I,M),O("a",z,I,M),O("b",z,I,M))];case"BitwiseAnd":return[tt.bitwiseAnd(O("a",z,I,M),O("b",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"matrices":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[tt.matMul(O("a",z,I,M),O("b",z,I,M),O("transposeA",z,I,M),O("transposeB",z,I,M))];case"Einsum":return[tt.einsum(O("equation",z,I,M),...O("tensors",z,I,M))];case"Transpose":return[tt.transpose(O("x",z,I,M),O("perm",z,I,M))];case"_FusedMatMul":const[wt,At]=O("fusedOps",z,I,M),Yt="biasadd"===wt,kt="prelu"===At,ae=O("numArgs",z,I,M),nn=O("leakyreluAlpha",z,I,M);if(Yt){if(kt&&2!==ae)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!kt&&1!==ae)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[Ye,$e]=O("args",z,I,M);return[tt.fused.matMul({a:O("a",z,I,M),b:O("b",z,I,M),transposeA:O("transposeA",z,I,M),transposeB:O("transposeB",z,I,M),bias:Ye,activation:At,preluActivationWeights:$e,leakyreluAlpha:nn})];case"MatrixBandPart":return[tt.linalg.bandPart(O("a",z,I,M),O("numLower",z,I,M),O("numUpper",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"normalization":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"EuclideanNorm":return[tt.euclideanNorm(O("x",z,I,M),O("axis",z,I,M),O("keepDims",z,I,M))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[tt.batchNorm(O("x",z,I,M),O("mean",z,I,M),O("variance",z,I,M),O("offset",z,I,M),O("scale",z,I,M),O("epsilon",z,I,M))];case"LRN":return[tt.localResponseNormalization(O("x",z,I,M),O("radius",z,I,M),O("bias",z,I,M),O("alpha",z,I,M),O("beta",z,I,M))];case"Softmax":return[tt.softmax(O("x",z,I,M))];case"LogSoftmax":return[tt.logSoftmax(O("x",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"ragged":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"RaggedGather":{const{outputNestedSplits:wt,outputDenseValues:At}=tt.raggedGather(O("paramsNestedSplits",z,I,M),O("paramsDenseValues",z,I,M),O("indices",z,I,M),O("outputRaggedRank",z,I,M));return wt.concat(At)}case"RaggedRange":{const{rtNestedSplits:wt,rtDenseValues:At}=tt.raggedRange(O("starts",z,I,M),O("limits",z,I,M),O("splits",z,I,M));return[wt,At]}case"RaggedTensorToTensor":return[tt.raggedTensorToTensor(O("shape",z,I,M),O("values",z,I,M),O("defaultValue",z,I,M),O("rowPartitionTensors",z,I,M),O("rowPartitionTypes",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"reduction":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Max":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.max(O("x",z,I,M),kt,ae)]}case"Mean":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.mean(O("x",z,I,M),kt,ae)]}case"Min":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.min(O("x",z,I,M),kt,ae)]}case"Sum":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.sum(O("x",z,I,M),kt,ae)]}case"All":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.all(O("x",z,I,M),kt,ae)]}case"Any":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.any(O("x",z,I,M),kt,ae)]}case"ArgMax":{const kt=O("axis",z,I,M);return[tt.argMax(O("x",z,I,M),kt)]}case"ArgMin":{const kt=O("axis",z,I,M);return[tt.argMin(O("x",z,I,M),kt)]}case"Prod":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.prod(O("x",z,I,M),kt,ae)]}case"Cumprod":{const kt=O("axis",z,I,M),ae=O("exclusive",z,I,M),nn=O("reverse",z,I,M);return[tt.cumprod(O("x",z,I,M),kt,ae,nn)]}case"Cumsum":{const kt=O("axis",z,I,M),ae=O("exclusive",z,I,M),nn=O("reverse",z,I,M);return[tt.cumsum(O("x",z,I,M),kt,ae,nn)]}case"Bincount":const wt=O("x",z,I,M),At=O("weights",z,I,M),Yt=O("size",z,I,M);return[tt.bincount(wt,At,Yt)];case"DenseBincount":{const kt=O("x",z,I,M),ae=O("weights",z,I,M),nn=O("size",z,I,M),Ye=O("binaryOutput",z,I,M);return[tt.denseBincount(kt,ae,nn,Ye)]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"slice_join":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"ConcatV2":case"Concat":{const wt=O("n",z,I,M),At=O("axis",z,I,M);let Yt=O("tensors",z,I,M);return Yt=Yt.slice(0,wt),[tt.concat(Yt,At)]}case"Gather":{const wt=O("x",z,I,M),At=O("indices",z,I,M);return[tt.gather(wt,tt.cast(At,"int32"),0)]}case"GatherV2":{const wt=O("axis",z,I,M),At=O("batchDims",z,I,M),Yt=O("x",z,I,M),kt=O("indices",z,I,M);return[tt.gather(Yt,tt.cast(kt,"int32"),wt,At)]}case"Reverse":{const wt=O("dims",z,I,M),At=[];for(let kt=0;kt<wt.length;kt++)wt[kt]&&At.push(kt);const Yt=O("x",z,I,M);return[tt.reverse(Yt,At)]}case"ReverseV2":{const wt=O("axis",z,I,M),At=O("x",z,I,M);return[tt.reverse(At,wt)]}case"Slice":{const wt=O("begin",z,I,M),At=O("size",z,I,M);return[tt.slice(O("x",z,I,M),wt,At)]}case"StridedSlice":{const wt=O("begin",z,I,M),At=O("end",z,I,M),Yt=O("strides",z,I,M),kt=O("beginMask",z,I,M),ae=O("endMask",z,I,M),nn=O("ellipsisMask",z,I,M),Ye=O("newAxisMask",z,I,M),$e=O("shrinkAxisMask",z,I,M),Cn=O("x",z,I,M);return[tt.stridedSlice(Cn,wt,At,Yt,kt,ae,nn,Ye,$e)]}case"Pack":return(0,Q.tidy)(()=>{const wt=O("axis",z,I,M),At=O("tensors",z,I,M),Yt=At[0].shape,kt=tt.squeeze(At[0]).shape,ae=At.map(nn=>{const Ye=Q.util.arraysEqual(nn.shape,Yt);if(!Ye&&!Q.util.arraysEqual(tt.squeeze(nn).shape,kt))throw new Error("the input tensors shape does not match");return Ye?nn:tt.reshape(nn,Yt)});return[tt.stack(ae,wt)]});case"Unpack":{const wt=O("axis",z,I,M),At=O("tensor",z,I,M);return tt.unstack(At,wt)}case"Tile":{const wt=O("reps",z,I,M);return[tt.tile(O("x",z,I,M),wt)]}case"Split":case"SplitV":{const wt=O("axis",z,I,M),At=O("numOrSizeSplits",z,I,M),Yt=O("x",z,I,M);return tt.split(Yt,At,wt)}case"ScatterNd":{const wt=O("indices",z,I,M),At=O("values",z,I,M),Yt=O("shape",z,I,M);return[tt.scatterND(wt,At,Yt)]}case"GatherNd":{const wt=O("x",z,I,M),At=O("indices",z,I,M);return[tt.gatherND(wt,At)]}case"SparseToDense":{const wt=O("sparseIndices",z,I,M),At=O("outputShape",z,I,M),Yt=O("sparseValues",z,I,M),kt=O("defaultValue",z,I,M);return[tt.sparseToDense(wt,Yt,At,Yt.dtype===kt.dtype?kt:tt.cast(kt,Yt.dtype))]}case"TensorScatterUpdate":{const wt=O("indices",z,I,M),At=O("values",z,I,M),Yt=O("tensor",z,I,M);return[tt.tensorScatterUpdate(Yt,wt,At)]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"sparse":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"SparseFillEmptyRows":{const{outputIndices:wt,outputValues:At,emptyRowIndicator:Yt,reverseIndexMap:kt}=tt.sparse.sparseFillEmptyRows(O("indices",z,I,M),O("values",z,I,M),O("denseShape",z,I,M),O("defaultValue",z,I,M));return[wt,At,Yt,kt]}case"SparseReshape":{const{outputIndices:wt,outputShape:At}=tt.sparse.sparseReshape(O("inputIndices",z,I,M),O("inputShape",z,I,M),O("newShape",z,I,M));return[wt,At]}case"SparseSegmentMean":return[tt.sparse.sparseSegmentMean(O("data",z,I,M),O("indices",z,I,M),O("segmentIds",z,I,M))];case"SparseSegmentSum":return[tt.sparse.sparseSegmentSum(O("data",z,I,M),O("indices",z,I,M),O("segmentIds",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"spectral":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"FFT":return[tt.fft(O("x",z,I,M))];case"IFFT":return[tt.ifft(O("x",z,I,M))];case"RFFT":return[tt.rfft(O("x",z,I,M))];case"IRFFT":return[tt.irfft(O("x",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"string":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"StaticRegexReplace":return[tt.string.staticRegexReplace(O("input",z,I,M),O("pattern",z,I,M),O("rewrite",z,I,M),O("replaceGlobal",z,I,M))];case"StringNGrams":{const{nGrams:wt,nGramsSplits:At}=tt.string.stringNGrams(O("data",z,I,M),O("dataSplits",z,I,M),O("separator",z,I,M),O("nGramWidths",z,I,M),O("leftPad",z,I,M),O("rightPad",z,I,M),O("padWidth",z,I,M),O("preserveShortSequences",z,I,M));return[wt,At]}case"StringSplit":{const{indices:wt,values:At,shape:Yt}=tt.string.stringSplit(O("input",z,I,M),O("delimiter",z,I,M),O("skipEmpty",z,I,M));return[wt,At,Yt]}case"StringToHashBucketFast":return[tt.string.stringToHashBucketFast(O("input",z,I,M),O("numBuckets",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"transformation":return wt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Cast":return[tt.cast(O("x",z,I,M),O("dtype",z,I,M))];case"ExpandDims":{const wt=O("axis",z,I,M);return[tt.expandDims(O("x",z,I,M),wt)]}case"Squeeze":{const wt=O("axis",z,I,M);return[tt.squeeze(O("x",z,I,M),wt)]}case"Reshape":return[tt.reshape(O("x",z,I,M),O("shape",z,I,M))];case"EnsureShape":return[tt.ensureShape(O("x",z,I,M),O("shape",z,I,M))];case"MirrorPad":return[tt.mirrorPad(O("x",z,I,M),O("padding",z,I,M),O("mode",z,I,M))];case"PadV2":case"Pad":return[tt.pad(O("x",z,I,M),O("padding",z,I,M),O("constantValue",z,I,M))];case"SpaceToBatchND":{const wt=O("blockShape",z,I,M),At=O("paddings",z,I,M);return[tt.spaceToBatchND(O("x",z,I,M),wt,At)]}case"BatchToSpaceND":{const wt=O("blockShape",z,I,M),At=O("crops",z,I,M);return[tt.batchToSpaceND(O("x",z,I,M),wt,At)]}case"DepthToSpace":{const wt=O("blockSize",z,I,M),At=O("dataFormat",z,I,M).toUpperCase();return[tt.depthToSpace(O("x",z,I,M),wt,At)]}case"BroadcastTo":return[tt.broadcastTo(O("x",z,I,M),O("shape",z,I,M))];case"BroadcastArgs":return[tt.broadcastArgs(O("s0",z,I,M),O("s1",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"hash_table":return Pa(Yt,kt,ae,tt);case"custom":const nn=nt(Yt.op);if(nn&&nn.customExecutor)return nn.customExecutor(new je(Yt,kt,ae));throw TypeError(`Custom op ${Yt.op} is not registered.`);default:throw TypeError(`Unknown op '${Yt.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(z,I,M);return Q.util.isPromise(At)?At.then(Yt=>[].concat(Yt)):[].concat(At)}class Yi{constructor(I={},M={},tt={},wt={},At){this.weightMap=I,this.tensorArrayMap=M,this.tensorListMap=tt,this.functionMap=wt,this.parseNodeNameCache=At,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(I,M){return{id:I,frameName:M,iterationId:0}}set currentContext(I){this.contexts!==I&&(this.contexts=I,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const I=[];for(let M=0;M<this.contexts.length-1;M++){const tt=this.contexts.slice(0,this.contexts.length-M);I.push(this.contextIdforContexts(tt))}I.push(""),this._currentContextIds=I}contextIdforContexts(I){return I?I.map(M=>0===M.id&&0===M.iterationId?"":`${M.frameName}-${M.iterationId}`).join("/"):""}enterFrame(I){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,I)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const I=Object.assign({},this.contexts[this.contexts.length-1]);I.iterationId+=1,I.id=this.lastId,this.contexts.splice(-1,1,I),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(I){return this.weightMap[I]}addTensorArray(I){this.tensorArrayMap[I.id]=I}getTensorArray(I){return this.tensorArrayMap[I]}addTensorList(I){this.tensorListMap[I.id]=I}getTensorList(I){return this.tensorListMap[I]}dispose(I){for(const M in this.tensorArrayMap)this.tensorArrayMap[M].clearAndClose(I);for(const M in this.tensorListMap)this.tensorListMap[M].clearAndClose(I)}}function La(z,I,M,tt){const wt=new Set,At=[];let Yt=null,kt=null;const ae=new Set,nn=new Set(Object.keys(z).map(Cn=>Mt(Cn)[0]));tt=tt||[];const Ye=new Set(tt.map(Cn=>Mt(Cn.name)[0])),$e=[...I];for(;$e.length>0;){const Cn=$e.pop();if((Kr(Cn)||mr(Cn)||ai(Cn))&&null==Yt&&(Yt=Cn,kt=Yt.children.map($n=>$n.name).filter($n=>wt.has($n))),wt.add(Cn.name),null==M[Cn.name]&&!nn.has(Cn.name)&&!Ye.has(Cn.name)){if(0===Cn.inputs.length){At.push(Cn.name);continue}Cn.inputs.forEach($n=>{ae.has($n.name)||(ae.add($n.name),$e.push($n))})}}return{inputs:z,outputs:I,usedNodes:wt,missingInputs:At,dynamicNode:Yt,syncInputs:kt}}class Fn extends Error{constructor(I){super(`NodesExecutionOrderError: ${I}`)}}const ks=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Ur=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),We=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Kr(z){return ks.has(z.op)}function mr(z){return Ur.has(z.op)}function ai(z){return We.has(z.op)}class Kn{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(I){const M=Object.keys(I).map(tt=>I[tt].map(wt=>wt.id));this._weightIds=[].concat(...M),this._weightMap=I}set resourceManager(I){this._resourceManager=I}get inputs(){return this._inputs.map(I=>({name:I.name,shape:I.attrParams.shape?I.attrParams.shape.value:void 0,dtype:I.attrParams.dtype?I.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(I=>({name:I.name,shape:I.attrParams.shape?I.attrParams.shape.value:void 0,dtype:I.attrParams.dtype?I.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(I=>I.signatureKey||I.name)}get outputNodes(){return this._outputs.map(I=>{const M=I.signatureKey||I.name;return I.defaultOutput?`${M}:${I.defaultOutput}`:M})}get functions(){return Object.keys(this._functions).reduce((I,M)=>(I[M]=this._functions[M].signature,I),{})}constructor(I,M){this.graph=I,this.parent=M,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=I.outputs,this._inputs=I.inputs,this._initNodes=I.initNodes,this._signature=I.signature,this._functions=I.functions,null!=I.functions&&Object.keys(I.functions).forEach(tt=>{this._functionExecutorMap[tt]=new Kn(I.functions[tt],this)})}getCompilationKey(I,M){const tt=I.map(At=>At.name).sort(),wt=M.map(At=>At.name).sort();return tt.join(this.SEPARATOR)+"--"+wt.join(this.SEPARATOR)}compile(I,M){const tt=La(I,M,this.weightMap,this._initNodes),{missingInputs:wt,dynamicNode:At,syncInputs:Yt}=tt;if(null!=At)throw new Error(`This execution contains the node '${At.name}', which has the dynamic op '${At.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${Yt}]`);if(wt.length>0){const nn=M.map($e=>$e.name),Ye=Object.keys(I);throw new Error(`Cannot compute the outputs [${nn}] from the provided inputs [${Ye}]. Missing the following inputs: [${wt}]`)}const kt=function an(z,I){const{usedNodes:M,inputs:tt}=I,Yt=wn=>M.has("string"==typeof wn?wn:wn.name);function kt(wn){return[...new Map(wn.map(_r=>[_r.name,_r])).values()]}const ae=kt([...Object.keys(tt).map(wn=>Mt(wn)[0]).map(wn=>z.nodes[wn]),...z.weights,...z.initNodes||[]]).filter(Yt),nn=kt([...ae,...Object.values(z.nodes)]).filter(Yt),Ye=new Map(nn.map(wn=>[wn.name,wn])),$e={};for(const wn of nn){$e[wn.name]=$e[wn.name]||0;for(const _r of wn.children)Yt(_r)||($e[_r.name]=Number.POSITIVE_INFINITY),$e[_r.name]=($e[_r.name]||0)+1}const Cn=Object.entries($e).filter(([,wn])=>0===wn).map(([wn])=>wn),$n=[...Cn];for(;Cn.length>0;){const wn=Cn.pop(),_r=Ye.get(wn);for(const ni of _r.children.filter(Yt))0==--$e[ni.name]&&($n.push(ni.name),Cn.push(ni.name))}const vr=function ei(z,I){const M=new Map(z.map(Yt=>[Yt.name,Yt])),tt=I.map(Yt=>Yt.name),wt=new Set(tt);for(;tt.length>0;){const Yt=tt.pop(),kt=M.get(Yt);for(const ae of kt.children)!M.has(ae.name)||wt.has(ae.name)||(wt.add(ae.name),tt.push(ae.name))}return z.filter(Yt=>wt.has(Yt.name))}($n.map(wn=>Ye.get(wn)),ae);return function Ds(z,I){const M=new Map(z.map((kt,ae)=>[kt.name,ae])),tt=new Set(I.map(kt=>kt.name)),wt=kt=>tt.has("string"==typeof kt?kt:kt.name),At=new Set(z.map(kt=>kt.name)),Yt=kt=>At.has("string"==typeof kt?kt:kt.name);for(const kt of z){for(const ae of kt.children.filter(Yt)){if(!M.has(ae.name))throw new Fn(`Child ${ae.name} of node ${kt.name} is unreachable.`);if(M.get(kt.name)>M.get(ae.name))throw new Fn(`Node ${kt.name} is scheduled to run after its child ${ae.name}.`)}if(!wt(kt))for(const ae of kt.inputs){if(!M.has(ae.name))throw new Fn(`Input ${ae.name} of node ${kt.name} is unreachable.`);if(M.get(ae.name)>M.get(kt.name))throw new Fn(`Node ${kt.name} is scheduled to run before its input ${ae.name}.`)}}}(vr,ae),vr}(this.graph,tt),ae=function Io(z){const I=new Map(z.map((kt,ae)=>[kt.name,ae])),M=Number.MAX_SAFE_INTEGER,tt=z.map((kt,ae)=>Kr(kt)?M:ae),wt=kt=>tt[I.get(kt.name)]??-1,At=z.map((kt,ae)=>kt.children.map(wt).reduce((nn,Ye)=>Math.max(nn,Ye),tt[ae])),Yt=new Map;for(let kt=0;kt<z.length;++kt){const ae=At[kt];if(ae===M)continue;const nn=z[kt],Ye=z[ae];Yt.has(Ye.name)||Yt.set(Ye.name,[]),Yt.get(Ye.name).push(nn)}return Yt}(kt);return{orderedNodes:kt,nodeLiveUntilMap:ae}}cloneAndKeepTensor(I){if(null==I)return null;const M=I.clone();return(0,Q.keep)(M),M}cloneTensorList(I){return I?I.map(tt=>this.cloneAndKeepTensor(tt)):null}cloneTensorMap(I){return Object.fromEntries(Object.entries(I).map(([M,tt])=>[M,this.cloneTensorList(tt)]))}execute(I,M){this.disposeIntermediateTensors(),I=this.mapInputs(I);const tt=Object.keys(I).sort();this.checkInputs(I),this.checkInputShapeAndType(I),M=this.mapOutputs(M),this.checkOutputs(M);const wt=tt.map(Cn=>this.graph.nodes[Mt(Cn)[0]]),At=M.map(Cn=>Mt(Cn)[0]),Yt=new Set(At);let kt=At.map(Cn=>this.graph.nodes[Cn]);0===kt.length&&(kt=this._outputs);const ae=this.getCompilationKey(wt,kt);let nn=this.compiledMap.get(ae);null==nn&&(nn=this.compile(I,kt),this.compiledMap.set(ae,nn));try{this.keepIntermediateTensors=(0,Q.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(Cn){this.keepIntermediateTensors=!1,console.warn(Cn.message)}const Ye={},$e={};return(0,Q.tidy)(()=>{const Cn=new Yi(this.weightMap,Ye,$e,this.functionExecutorMap,this.parseNodeNameCache),$n=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(I).forEach(_r=>{const[ni,Zs]=Mt(_r,Cn),Xr=[];Xr[Zs]=I[_r],$n[ni]=Xr,this.keepIntermediateTensors&&(this.clonedTensorsMap[ni]=this.cloneTensorList(Xr))});const Vn=this.getFrozenTensorIds($n),{orderedNodes:vr,nodeLiveUntilMap:wn}=nn;for(const _r of vr){if($n[_r.name])continue;const ni=Cs(_r,$n,Cn,this._resourceManager);if(Q.util.isPromise(ni))throw new Error(`The execution of the op '${_r.op}' returned a promise. Please use model.executeAsync() instead.`);$n[_r.name]=ni,this.keepIntermediateTensors&&(this.clonedTensorsMap[_r.name]=this.cloneTensorList(ni)),this.checkTensorForDisposalWithNodeLiveUntilInfo(_r,$n,Cn,Vn,Yt,wn.get(_r.name))}return null==this.parent&&Cn.dispose(Vn),M.map(_r=>Ct(_r,$n,Cn))})}getFrozenTensorIds(I){const M=[].concat.apply([],Object.keys(I).map(tt=>I[tt]).map(tt=>tt.map(wt=>wt.id)));return new Set(M)}checkTensorForDisposal(I,M,tt,wt,At,Yt,kt){if(!Kr(M)&&!Yt.has(I)){for(const ae of tt[I])null!=ae&&(kt[ae.id]=(kt[ae.id]||0)+M.children.length);for(const ae of M.inputs){if(Kr(ae))continue;const nn=yt(ae.name,tt,wt);if(null!=nn)for(const Ye of nn){if(!Ye||Ye.kept||At.has(Ye.id))continue;const $e=kt[Ye.id];1===$e?(Ye.dispose(),delete kt[Ye.id]):null!=$e&&kt[Ye.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(I,M,tt,wt,At,Yt){function kt(ae){return Kr(ae)||At.has(ae.name)}if(!Kr(I)&&null!=Yt)for(const ae of Yt){if(kt(ae))continue;const nn=yt(ae.name,M,tt);for(const Ye of nn)!Ye||Ye.kept||wt.has(Ye.id)||Ye.dispose()}}executeAsync(I,M){var tt=this;return(0,pt.Z)(function*(){return tt._executeAsync(I,M)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(I=>{for(const M of I)M&&!M.isDisposed&&M.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(I,M,tt=!1,wt={},At={}){var Yt=this;return(0,pt.Z)(function*(){Yt.disposeIntermediateTensors(),tt||(I=Yt.mapInputs(I),Yt.checkInputs(I),Yt.checkInputShapeAndType(I),M=Yt.mapOutputs(M),Yt.checkOutputs(M));try{Yt.keepIntermediateTensors=(0,Q.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch($n){Yt.keepIntermediateTensors=!1,console.warn($n.message)}const kt=new Yi(Yt.weightMap,wt,At,Yt.functionExecutorMap,Yt.parseNodeNameCache);Yt.keepIntermediateTensors&&(Yt.clonedTensorsMap=Yt.cloneTensorMap(Yt.weightMap));const ae=yield Yt.executeWithControlFlow(I,kt,M,tt),nn=M.map($n=>Ct($n,ae,kt)),Ye=nn.map($n=>$n.id),$e=Object.keys(I).map($n=>I[$n].id),Cn=new Set([...Ye,...$e,...Yt.weightIds]);return Object.values(ae).forEach($n=>{$n.forEach(Vn=>{Vn&&!Vn.isDisposed&&!Cn.has(Vn.id)&&Vn.dispose()})}),null==Yt.parent&&kt.dispose(Cn),nn})()}executeFunctionAsync(I,M,tt){var wt=this;return(0,pt.Z)(function*(){const At=I.reduce((Yt,kt,ae)=>(Yt[wt.inputs[ae].name]=kt,Yt),{});return wt._executeAsync(At,wt.outputNodes,!0,M,tt)})()}executeWithControlFlow(I,M,tt,wt){var At=this;return(0,pt.Z)(function*(){const Yt=Object.keys(I),kt=Yt.map(tn=>At.graph.nodes[Mt(tn)[0]]),ae=tt.map(tn=>Mt(tn)[0]),nn=new Set(ae);let Ye=ae.map(tn=>At.graph.nodes[tn]);0===Ye.length&&(Ye=At._outputs);const{usedNodes:$e,missingInputs:Cn,dynamicNode:$n,syncInputs:Vn}=La(I,Ye,At.weightMap,At._initNodes),vr=[...kt,...At.graph.weights,...At._initNodes||[]].map(tn=>({node:tn,contexts:M.currentContext})),wn=Object.assign({},At.weightMap);Object.keys(I).forEach(tn=>{const[Su,xr]=Mt(tn),qi=[];qi[xr]=I[tn],wn[Su]=qi});const _r={},ni=At.getFrozenTensorIds(wn),Zs={};for(;vr.length>0;){const tn=At.processStack(kt,vr,M,wn,Zs,ni,nn,_r,$e);yield Promise.all(tn)}null==$n&&!wt&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const Xr=Ye.filter(tn=>!Kr(tn)&&!Ct(tn.name,wn,M)).map(tn=>tn.name);if(Xr.length>0){let tn="";throw null!=$n&&(tn=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${Vn}]`),new Error(`Cannot compute the outputs [${Xr}] from the provided inputs [${Yt}]. Consider providing the following inputs: [${Cn}]. ${tn}`)}return wn})()}processStack(I,M,tt,wt,At,Yt,kt,ae,nn){const Ye=[];for(;M.length>0;){const $e=M.pop();tt.currentContext=$e.contexts;let Cn="";if("Enter"===$e.node.op&&O("isConstant",$e.node,wt,tt)&&([Cn]=vt($e.node.name,tt)),null==wt[$e.node.name]){const $n=Cs($e.node,wt,tt,this._resourceManager);Cn||([Cn]=vt($e.node.name,tt));const Vn=tt.currentContext;Q.util.isPromise($n)?Ye.push($n.then(vr=>(wt[Cn]=vr,this.keepIntermediateTensors&&(this.clonedTensorsMap[Cn]=this.cloneTensorList(vr)),tt.currentContext=Vn,this.checkTensorForDisposal(Cn,$e.node,wt,tt,Yt,kt,ae),this.processChildNodes($e.node,M,tt,wt,At,nn),vr))):(wt[Cn]=$n,this.keepIntermediateTensors&&(this.clonedTensorsMap[Cn]=this.cloneTensorList($n)),this.checkTensorForDisposal(Cn,$e.node,wt,tt,Yt,kt,ae),this.processChildNodes($e.node,M,tt,wt,At,nn))}else this.processChildNodes($e.node,M,tt,wt,At,nn)}return Ye}processChildNodes(I,M,tt,wt,At,Yt){I.children.forEach(kt=>{const[ae]=vt(kt.name,tt);At[ae]||!Yt.has(kt.name)||("Merge"===kt.op?kt.inputNames.some(nn=>!!Ct(nn,wt,tt))&&(At[ae]=!0,M.push({contexts:tt.currentContext,node:kt})):kt.inputNames.every(nn=>!!Ct(nn,wt,tt))&&(At[ae]=!0,M.push({contexts:tt.currentContext,node:kt})))})}dispose(){Object.keys(this.weightMap).forEach(I=>this.weightMap[I].forEach(M=>M.dispose()))}checkInputShapeAndType(I){Object.keys(I).forEach(M=>{const tt=I[M],[wt]=Mt(M),At=this.graph.nodes[wt];if(At.attrParams.shape&&At.attrParams.shape.value){const Yt=At.attrParams.shape.value,kt=Yt.length===tt.shape.length&&tt.shape.every((ae,nn)=>-1===Yt[nn]||Yt[nn]===ae);Q.util.assert(kt,()=>`The shape of dict['${At.name}'] provided in model.execute(dict) must be [${Yt}], but was [${tt.shape}]`)}At.attrParams.dtype&&At.attrParams.dtype.value&&Q.util.assert(tt.dtype===At.attrParams.dtype.value,()=>`The dtype of dict['${At.name}'] provided in model.execute(dict) must be ${At.attrParams.dtype.value}, but was ${tt.dtype}`)})}mapInputs(I){var M,tt;const wt={};for(const At in I){const Yt=null===(tt=null===(M=this._signature)||void 0===M?void 0:M.inputs)||void 0===tt?void 0:tt[At];null!=Yt?wt[Yt.name]=I[At]:wt[At]=I[At]}return wt}checkInputs(I){const M=Object.keys(I).filter(tt=>{const[wt]=Mt(tt);return null==this.graph.nodes[wt]});if(M.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${M}] that are not part of graph`)}mapOutputs(I){return I.map(M=>{var tt,wt;const At=null===(wt=null===(tt=this._signature)||void 0===tt?void 0:tt.outputs)||void 0===wt?void 0:wt[M];return null!=At?At.name:M},{})}checkOutputs(I){I.forEach(M=>{const[tt]=Mt(M);if(!this.graph.nodes[tt])throw new Error(`The output '${M}' is not found in the graph`)})}}class Pr{constructor(I={},M={}){this.hashTableNameToHandle=I,this.hashTableMap=M}addHashTable(I,M){this.hashTableNameToHandle[I]=M.handle,this.hashTableMap[M.id]=M}getHashTableHandleByName(I){return this.hashTableNameToHandle[I]}getHashTableById(I){return this.hashTableMap[I]}dispose(){for(const I in this.hashTableMap)this.hashTableMap[I].clearAndClose(),delete this.hashTableMap[I];for(const I in this.hashTableNameToHandle)this.hashTableNameToHandle[I].dispose(),delete this.hashTableNameToHandle[I]}}var br=y(8339);const Wr="?tfjs-format=file",Ts="model.json";class os{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(I,M={},tt=Q.io){this.modelUrl=I,this.loadOptions=M,this.version="n/a",this.io=tt,null==M&&(this.loadOptions={}),this.resourceManager=new Pr}findIOHandler(){const I=this.modelUrl;if(null!=I.load)this.handler=I;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(I,this.loadOptions);else{const M=this.io.getLoadHandlers(I,this.loadOptions);if(0===M.length)M.push(this.io.browserHTTPRequest(I,this.loadOptions));else if(M.length>1)throw new Error(`Found more than one (${M.length}) load handlers for URL '${[I]}'`);this.handler=M[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const I=this.handler.load();return Q.util.isPromise(I)?I.then(M=>null==M.getWeightStream?this.loadSync(M):this.loadStreaming(M)):this.loadSync(I)}loadSync(I){const M=this.io.decodeWeights(I.weightData,I.weightSpecs);return this.loadWithWeightMap(I,M)}loadStreaming(I){var M=this;return(0,pt.Z)(function*(){if(null==I.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const tt=yield(0,br.r)(I.getWeightStream(),I.weightSpecs);return M.loadWithWeightMap(I,tt)})()}loadWithWeightMap(I,M){this.artifacts=I;const tt=this.artifacts.modelTopology;let wt=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const At=this.artifacts.userDefinedMetadata;null!=At.signature&&(wt=At.signature),null!=At.structuredOutputKeys&&(this.structuredOutputKeys=At.structuredOutputKeys)}if(this.signature=wt,this.version=`${tt.versions.producer}.${tt.versions.minConsumer}`,this.executor=new Kn(di.Instance.transformGraph(tt,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(M),this.executor.resourceManager=this.resourceManager,null!=I.modelInitializer&&null!=I.modelInitializer.node){const At=di.Instance.transformGraph(I.modelInitializer);this.initializer=new Kn(At),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=I.initializerSignature}return!0}save(I,M){var tt=this;return(0,pt.Z)(function*(){if("string"==typeof I){const wt=tt.io.getSaveHandlers(I);if(0===wt.length)throw new Error(`Cannot find any save handlers for URL '${I}'`);if(wt.length>1)throw new Error(`Found more than one (${wt.length}) save handlers for URL '${I}'`);I=wt[0]}if(null==I.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return I.save(tt.artifacts)})()}addStructuredOutputNames(I){if(this.structuredOutputKeys){const tt={};return(I instanceof Q.Tensor?[I]:I).forEach((wt,At)=>tt[this.structuredOutputKeys[At]]=wt),tt}return I}predict(I,M){const tt=this.execute(I,this.outputNodes);return this.addStructuredOutputNames(tt)}predictAsync(I,M){var tt=this;return(0,pt.Z)(function*(){const wt=yield tt.executeAsync(I,tt.outputNodes);return tt.addStructuredOutputNames(wt)})()}normalizeInputs(I){var M;if(!(I instanceof Q.Tensor||Array.isArray(I))){const At=null===(M=this.signature)||void 0===M?void 0:M.inputs;if(null!=At)for(const Yt in At){const kt=At[Yt];null!=kt.resourceId&&(I[Yt]=this.resourceIdToCapturedInput[kt.resourceId])}return I}I=Array.isArray(I)?I:[I];const tt=Object.keys(this.resourceIdToCapturedInput).length;if(I.length+tt!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-tt} non-resource placeholders, while there are ${I.length} input tensors provided.`);let wt=0;return this.inputNodes.reduce((At,Yt)=>{var kt,ae,nn;const Ye=null===(nn=null===(ae=null===(kt=this.signature)||void 0===kt?void 0:kt.inputs)||void 0===ae?void 0:ae[Yt])||void 0===nn?void 0:nn.resourceId;return At[Yt]=null!=Ye?this.resourceIdToCapturedInput[Ye]:I[wt++],At},{})}normalizeOutputs(I){return I=I||this.outputNodes,Array.isArray(I)?I:[I]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var I=this;return(0,pt.Z)(function*(){return null==I.initializer?[]:I.initializer.executeAsync({},null==I.initializerSignature?[]:Object.keys(I.initializerSignature.outputs))})()}setResourceIdToCapturedInput(I){if(this.resourceIdToCapturedInput={},this.initializerSignature){const M=this.initializerSignature.outputs,tt=Object.keys(M);for(let wt=0;wt<tt.length;wt++)this.resourceIdToCapturedInput[M[tt[wt]].resourceId]=I[wt]}}execute(I,M){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),I=this.normalizeInputs(I),M=this.normalizeOutputs(M);const tt=this.executor.execute(I,M);return tt.length>1?tt:tt[0]}executeAsync(I,M){var tt=this;return(0,pt.Z)(function*(){null==tt.resourceIdToCapturedInput&&tt.setResourceIdToCapturedInput(yield tt.executeInitializerGraphAsync()),I=tt.normalizeInputs(I),M=tt.normalizeOutputs(M);const wt=yield tt.executor.executeAsync(I,M);return wt.length>1?wt:wt[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(I){return Object.keys(I).reduce((M,tt)=>(M[tt]=[I[tt]],M),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,Q.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function Iu(z){return $o.apply(this,arguments)}function $o(){return($o=(0,pt.Z)(function*(z,I={},M=Q.io){if(null==z)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==I&&(I={}),I.fromTFHub&&"string"==typeof z&&(z=function as(z){return z.endsWith("/")||(z+="/"),`${z}${Ts}${Wr}`}(z));const tt=new os(z,I,M);return yield tt.load(),tt})).apply(this,arguments)}function Or(z){if(null==z)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let I;if(z instanceof Array){const[tt,wt]=z;if(!tt)throw new Error("modelJSON must be the first element of the array");if(!(wt&&wt instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in tt))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in tt))throw new Error("Model JSON is missing 'weightsManifest'");const At=Q.io.getWeightSpecs(tt.weightsManifest),Yt=Q.io.getModelArtifactsForJSONSync(tt,At,wt);I=Q.io.fromMemorySync(Yt)}else if("load"in z)I=z;else{if(!("modelTopology"in z&&"weightSpecs"in z&&"weightData"in z))throw new Error("Unknown model format");I=Q.io.fromMemorySync(z)}const M=new os(I);return M.load(),M}const _e="4.17.0"},7173:(Lt,ut,y)=>{"use strict";y.d(ut,{JL:()=>H,Zu:()=>q});class H{constructor(W,k){this.backend=W,this.dataMover=k,this.data=new WeakMap,this.dataIdsCount=0}get(W){return this.data.has(W)||this.dataMover.moveData(this.backend,W),this.data.get(W)}set(W,k){this.dataIdsCount++,this.data.set(W,k)}has(W){return this.data.has(W)}delete(W){return this.dataIdsCount--,this.data.delete(W)}numDataIds(){return this.dataIdsCount}}class q{refCount(W){return Y("refCount")}incRef(W){return Y("incRef")}timerAvailable(){return!0}time(W){return Y("time")}read(W){return Y("read")}readSync(W){return Y("readSync")}readToGPU(W,k){return Y("readToGPU")}numDataIds(){return Y("numDataIds")}disposeData(W,k){return Y("disposeData")}write(W,k,A){return Y("write")}move(W,k,A,X,Z){return Y("move")}createTensorFromGPUData(W,k,A){return Y("createTensorFromGPUData")}memory(){return Y("memory")}floatPrecision(){return Y("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Y("dispose")}}function Y(R){throw new Error(`'${R}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},5672:(Lt,ut,y)=>{"use strict";function $(G,it,bt){const K=function V(G,it,bt){return function q(G,it,bt){let K=0,st=G.length,et=0,dt=!1;for(;K<st;){et=K+(st-K>>>1);const lt=bt(it,G[et]);lt>0?K=et+1:(st=et,dt=!lt)}return dt?K:-K-1}(G,it,bt||H)}(G,it,bt);G.splice(K<0?-(K+1):K,0,it)}function H(G,it){return G>it?1:G<it?-1:0}function Y(G,it,bt,K,st){return k(G,it,bt,K,st,0)}function R(G,it,bt,K,st,et){return k(G,it,bt,K,st,0,!1,et,!0)}function W(G,it,bt,K,st,et){return k(G,it,bt,K,st,et,!0)}function k(G,it,bt,K,st,et,dt=!1,lt=!1,St=!1){const Q=[];for(let nt=0;nt<it.length;nt++)it[nt]>st&&Q.push({score:it[nt],boxIndex:nt,suppressBeginIndex:0});Q.sort(Z);const ft=et>0?-.5/et:0,pt=[],B=[];for(;pt.length<bt&&Q.length>0;){const nt=Q.pop(),{score:Gt,boxIndex:O,suppressBeginIndex:Ct}=nt;if(Gt<st)break;let yt=!1;for(let vt=pt.length-1;vt>=Ct;--vt){const xt=A(G,O,pt[vt]);if(xt>=K){yt=!0;break}if(nt.score=nt.score*X(K,ft,xt),nt.score<=st)break}nt.suppressBeginIndex=pt.length,yt||(nt.score===Gt?(pt.push(O),B.push(nt.score)):nt.score>st&&$(Q,nt,Z))}const ot=pt.length,P=bt-ot;lt&&P>0&&(pt.push(...new Array(P).fill(0)),B.push(...new Array(P).fill(0)));const at={selectedIndices:pt};return dt&&(at.selectedScores=B),St&&(at.validOutputs=ot),at}function A(G,it,bt){const K=G.subarray(4*it,4*it+4),st=G.subarray(4*bt,4*bt+4),et=Math.min(K[0],K[2]),dt=Math.min(K[1],K[3]),lt=Math.max(K[0],K[2]),St=Math.max(K[1],K[3]),Q=Math.min(st[0],st[2]),ft=Math.min(st[1],st[3]),pt=Math.max(st[0],st[2]),B=Math.max(st[1],st[3]),ot=(lt-et)*(St-dt),P=(pt-Q)*(B-ft);if(ot<=0||P<=0)return 0;const at=Math.max(et,Q),nt=Math.max(dt,ft),Gt=Math.min(lt,pt),O=Math.min(St,B),Ct=Math.max(Gt-at,0)*Math.max(O-nt,0);return Ct/(ot+P-Ct)}function X(G,it,bt){const K=Math.exp(it*bt*bt);return bt<=G?K:0}function Z(G,it){return G.score-it.score||G.score===it.score&&it.boxIndex-G.boxIndex}y.d(ut,{GP:()=>Y,qP:()=>R,pA:()=>W})},7349:(Lt,ut,y)=>{"use strict";y.d(ut,{Z:()=>V});var $=y(582);function V(H,q){const Y=[];for(let k=0;k<q.length;k++)q[k]&&Y.push(k);const R=(0,$.f)(H,"int32"),W=(0,$.f)([Y.length,H.length],"int32");for(let k=0;k<Y.length;k++){const A=R.indexToLoc(Y[k]);W.values.set(A,k*H.length)}return W.toTensor()}},687:(Lt,ut,y)=>{"use strict";y.d(ut,{BV:()=>ft,wv:()=>Q});var $=y(5861),V=y(7173),H=y(5527),q=y(2918),Y=y(4251),R=y(8987),W=y(2932),k=y(1153),A=y(5359);class X{constructor(ot,P){this.backendTimer=ot,this.logger=P,null==P&&(this.logger=new G)}profileKernel(ot,P,at){let nt;const Gt=()=>{nt=at()};let O;const Ct=k.now();if(this.backendTimer.timerAvailable())O=this.backendTimer.time(Gt);else{Gt();for(const vt of nt)vt.dataSync();O=Promise.resolve({kernelMs:k.now()-Ct})}if((0,H.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let vt=0;vt<nt.length;vt++){const xt=nt[vt];xt.data().then(Mt=>{Z(Mt,xt.dtype,ot)})}return{kernelName:ot,outputs:nt,inputs:P,timeMs:O.then(vt=>vt.kernelMs),extraInfo:O.then(vt=>null!=vt.getExtraProfileInfo?vt.getExtraProfileInfo():"")}}logKernelProfile(ot){const{kernelName:P,outputs:at,timeMs:nt,inputs:Gt,extraInfo:O}=ot;at.forEach(Ct=>{Promise.all([Ct.data(),nt,O]).then(yt=>{this.logger.logKernelProfile(P,Ct,yt[0],yt[1],Gt,yt[2])})})}}function Z(B,ot,P){if("float32"!==ot)return!1;for(let at=0;at<B.length;at++){const nt=B[at];if(isNaN(nt)||!isFinite(nt))return console.warn(`Found ${nt} in the result of '${P}'`),!0}return!1}class G{logKernelProfile(ot,P,at,nt,Gt,O){const Ct="number"==typeof nt?A.oj(`${nt}ms`,9):nt.error,yt=A.oj(ot,25),vt=P.rank,xt=P.size,Mt=A.oj(P.shape.toString(),14);let It="";for(const re in Gt){const Bt=Gt[re];if(null!=Bt){const ee=Bt.shape||P.shape,jt=ee.length;It+=`${re}: ${jt}D ${jt>0?ee:""} `}}console.log(`%c${yt}\t%c${Ct}\t%c${vt}D ${Mt}\t%c${xt}\t%c${It}\t%c${O}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var K=y(4945),st=y(7664);function et(B){return null!=B.kernelName}class dt{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(ot=>ot.name)))}}}dispose(){for(const ot in this.registeredVariables)this.registeredVariables[ot].dispose()}}let lt=(()=>{class B{constructor(P){this.ENV=P,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new dt}ready(){var P=this;return(0,$.Z)(function*(){if(null!=P.pendingBackendInit)return P.pendingBackendInit.then(()=>{});if(null!=P.backendInstance)return;const at=P.getSortedBackends();for(let nt=0;nt<at.length;nt++){const Gt=at[nt];if(yield P.initializeBackend(Gt).success)return void(yield P.setBackend(Gt))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:P,asyncInit:at}=this.initializeBackendsAndReturnBest();if(at)throw new Error(`The highest priority backend '${P}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(P)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(P){if(!(P in this.registry)){if(!(P in this.registryFactory))return null;{const{asyncInit:at}=this.initializeBackend(P);if(at)return null}}return this.registry[P]}findBackendFactory(P){return P in this.registryFactory?this.registryFactory[P].factory:null}registerBackend(P,at,nt=1){return P in this.registryFactory?(W.Z(`${P} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[P]={factory:at,priority:nt},!0)}setBackend(P){var at=this;return(0,$.Z)(function*(){if(null==at.registryFactory[P])throw new Error(`Backend name '${P}' not found in registry`);if(at.backendName=P,null==at.registry[P]){at.backendInstance=null;const{success:nt,asyncInit:Gt}=at.initializeBackend(P);if(!(Gt?yield nt:nt))return!1}return at.backendInstance=at.registry[P],at.setupRegisteredKernels(),at.profiler=new X(at.backendInstance),!0})()}setupRegisteredKernels(){(0,R.tr)(this.backendName).forEach(at=>{null!=at.setupFunc&&at.setupFunc(this.backendInstance)})}disposeRegisteredKernels(P){(0,R.tr)(P).forEach(nt=>{null!=nt.disposeFunc&&nt.disposeFunc(this.registry[P])})}initializeBackend(P){const at=this.registryFactory[P];if(null==at)throw new Error(`Cannot initialize backend ${P}, no registration found.`);try{const nt=at.factory();if(!nt||nt instanceof V.Zu||"function"!=typeof nt.then)return this.registry[P]=nt,{success:!0,asyncInit:!1};{const Gt=++this.pendingBackendInitId,O=nt.then(Ct=>!(Gt<this.pendingBackendInitId||(this.registry[P]=Ct,this.pendingBackendInit=null,0))).catch(Ct=>(Gt<this.pendingBackendInitId||(this.pendingBackendInit=null,W.Z(`Initialization of backend ${P} failed`),W.Z(Ct.stack||Ct.message)),!1));return this.pendingBackendInit=O,{success:O,asyncInit:!0}}}catch(nt){return W.Z(`Initialization of backend ${P} failed`),W.Z(nt.stack||nt.message),{success:!1,asyncInit:!1}}}removeBackend(P){if(!(P in this.registryFactory))throw new Error(`${P} backend not found in registry`);this.backendName===P&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,P in this.registry&&(this.disposeRegisteredKernels(P),this.registry[P].dispose(),delete this.registry[P]),delete this.registryFactory[P],this.backendName===P&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((P,at)=>this.registryFactory[at].priority-this.registryFactory[P].priority)}initializeBackendsAndReturnBest(){const P=this.getSortedBackends();for(let at=0;at<P.length;at++){const nt=P[at],{success:Gt,asyncInit:O}=this.initializeBackend(nt);if(O||Gt)return{name:nt,asyncInit:O}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(P,at){const nt=this.state.tensorInfo.get(at),Gt=nt.backend,O=this.readSync(at),Ct=Gt.refCount(at);Gt.disposeData(at,!0),nt.backend=P,P.move(at,O,nt.shape,nt.dtype,Ct),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(P,at){let Gt,nt=null;if(null==at){if("function"!=typeof P)throw new Error("Please provide a function to tidy()");at=P}else{if("string"!=typeof P&&!(P instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof at)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");nt=P}return this.scopedRun(()=>this.startScope(nt),()=>this.endScope(Gt),()=>(Gt=at(),Gt instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Gt))}scopedRun(P,at,nt){P();try{const Gt=nt();return at(),Gt}catch(Gt){throw at(),Gt}}nextTensorId(){return B.nextTensorId++}nextVariableId(){return B.nextVariableId++}clone(P){const at=ft.runKernel(Y.iJz,{x:P});return this.addTapeNode(this.state.activeScope.name,{x:P},[at],Ct=>({x:()=>ft.runKernel(Y.RFZ,{x:Ct},{dtype:"float32"})}),[],{}),at}runKernel(P,at,nt){if(null==(0,R.pI)(P,this.backendName))throw new Error(`Kernel '${P}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:P,inputs:at,attrs:nt})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(P,at,nt){const Gt=this.backend.numDataIds();let O=0;nt.forEach(vt=>{O+="complex64"===vt.dtype?3:1});const yt=Gt-at-O-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(yt>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${yt} data ids) after running '${P}'`)}runKernelFunc(P){let at,nt=[];const Gt=this.isTapeOn(),O=this.state.numBytes,Ct=this.state.numTensors;let yt,vt;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const xt=et(P)?P.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(et(P)){const{kernelName:ee,inputs:jt,attrs:se}=P,be=(0,R.pI)(ee,this.backendName);A.hu(null!=be,()=>`Cannot find registered kernel '${ee}' for backend '${this.backendName}'`),yt=()=>{const Me=this.backend.numDataIds();vt=be.kernelFunc({inputs:jt,attrs:se,backend:this.backend});const Xe=Array.isArray(vt)?vt:[vt];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(ee,Me,Xe);const Ue=Xe.map(De=>null!=De.rank?De:this.makeTensorFromTensorInfo(De));if(Gt){const De=this.getTensorsForGradient(ee,jt,Ue);nt=this.saveTensorsForBackwardMode(De)}return Ue}}else{const{forwardFunc:ee}=P,jt=se=>{Gt&&(nt=se.map(be=>this.keep(this.clone(be))))};yt=()=>{const se=this.backend.numDataIds();vt=this.tidy(()=>ee(this.backend,jt));const be=Array.isArray(vt)?vt:[vt];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(xt,se,be),be}}const{inputs:Mt,attrs:It}=P,re=et(P)?null:P.backwardsFunc;let Bt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(Bt=this.profiler.profileKernel(xt,Mt,()=>yt()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Bt),at=Bt.outputs):at=yt()}),Gt&&this.addTapeNode(xt,Mt,at,re,nt,It),this.state.profiling&&this.state.activeProfile.kernels.push({name:xt,bytesAdded:this.state.numBytes-O,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-Ct,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Mt).map(ee=>null!=Mt[ee]?Mt[ee].shape:null),outputShapes:at.map(ee=>ee.shape),kernelTimeMs:Bt.timeMs,extraInfo:Bt.extraInfo}),Array.isArray(vt)?at:at[0]}saveTensorsForBackwardMode(P){return P.map(nt=>this.keep(this.clone(nt)))}getTensorsForGradient(P,at,nt){const Gt=(0,R.uk)(P);if(null!=Gt){const O=Gt.inputsToSave||[],Ct=Gt.outputsToSave||[];let yt;Gt.saveAllInputs?(A.hu(Array.isArray(at),()=>"saveAllInputs is true, expected inputs to be an array."),yt=Object.keys(at).map(xt=>at[xt])):yt=O.map(xt=>at[xt]);const vt=nt.filter((xt,Mt)=>Ct[Mt]);return yt.concat(vt)}return[]}makeTensor(P,at,nt,Gt){if(null==P)throw new Error("Values passed to engine.makeTensor() are null");Gt=Gt||this.backend;let O=P;"string"===(nt=nt||"float32")&&A.HD(P[0])&&(O=P.map(vt=>k.encodeString(vt)));const Ct=Gt.write(O,at,nt),yt=new K.es(at,nt,Ct,this.nextTensorId());if(this.trackTensor(yt,Gt),"string"===nt){const vt=this.state.tensorInfo.get(Ct),xt=(0,A.Ub)(O);this.state.numBytes+=xt-vt.bytes,vt.bytes=xt}return yt}makeTensorFromDataId(P,at,nt,Gt){return this.makeTensorFromTensorInfo({dataId:P,shape:at,dtype:nt=nt||"float32"},Gt)}makeTensorFromTensorInfo(P,at){const{dataId:nt,shape:Gt,dtype:O}=P,Ct=new K.es(Gt,O,nt,this.nextTensorId());return this.trackTensor(Ct,at),Ct}makeVariable(P,at=!0,nt,Gt){nt=nt||this.nextVariableId().toString(),null!=Gt&&Gt!==P.dtype&&(P=P.cast(Gt));const O=new K._w(P,at,nt,this.nextTensorId());if(null!=this.state.registeredVariables[O.name])throw new Error(`Variable with name ${O.name} was already registered`);return this.state.registeredVariables[O.name]=O,this.incRef(O,this.backend),O}trackTensor(P,at){this.state.numTensors++,"string"===P.dtype&&this.state.numStringTensors++;let nt=0;"complex64"!==P.dtype&&"string"!==P.dtype&&(nt=P.size*A.bT(P.dtype)),this.state.numBytes+=nt,this.state.tensorInfo.has(P.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(P.dataId,{backend:at||this.backend,dtype:P.dtype,shape:P.shape,bytes:nt})),P instanceof K._w||this.track(P)}incRef(P,at){this.trackTensor(P,at),this.backend.incRef(P.dataId)}removeDataId(P,at){this.state.tensorInfo.has(P)&&this.state.tensorInfo.get(P).backend===at&&(this.state.tensorInfo.delete(P),this.state.numDataBuffers--)}disposeTensor(P){if(!this.state.tensorInfo.has(P.dataId))return;const at=this.state.tensorInfo.get(P.dataId);if(this.state.numTensors--,"string"===P.dtype&&(this.state.numStringTensors--,this.state.numBytes-=at.bytes),"complex64"!==P.dtype&&"string"!==P.dtype){const nt=P.size*A.bT(P.dtype);this.state.numBytes-=nt}at.backend.disposeData(P.dataId)&&this.removeDataId(P.dataId,at.backend)}disposeVariables(){for(const P in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[P])}disposeVariable(P){this.disposeTensor(P),null!=this.state.registeredVariables[P.name]&&delete this.state.registeredVariables[P.name]}memory(){const P=this.backend.memory();return P.numTensors=this.state.numTensors,P.numDataBuffers=this.state.numDataBuffers,P.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(P.unreliable=!0,null==P.reasons&&(P.reasons=[]),P.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),P}profile(P){var at=this;return(0,$.Z)(function*(){at.state.profiling=!0;const nt=at.state.numBytes,Gt=at.state.numTensors;at.state.activeProfile.kernels=[],at.state.activeProfile.result=yield P(),at.state.profiling=!1,at.state.activeProfile.peakBytes=Math.max(...at.state.activeProfile.kernels.map(O=>O.totalBytesSnapshot)),at.state.activeProfile.newBytes=at.state.numBytes-nt,at.state.activeProfile.newTensors=at.state.numTensors-Gt;for(const O of at.state.activeProfile.kernels)O.kernelTimeMs=yield O.kernelTimeMs,O.extraInfo=yield O.extraInfo;return at.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(P,at,nt,Gt,O,Ct){const yt={id:this.state.nextTapeNodeId++,kernelName:P,inputs:at,outputs:nt,saved:O},vt=(0,R.uk)(P);null!=vt&&(Gt=vt.gradFunc),null!=Gt&&(yt.gradient=xt=>(xt=xt.map((Mt,It)=>{if(null==Mt){const re=nt[It],Bt=A.wT(re.size,re.dtype);return this.makeTensor(Bt,re.shape,re.dtype)}return Mt}),Gt(xt.length>1?xt:xt[0],O,Ct))),this.state.activeTape.push(yt)}keep(P){return P.kept=!0,P}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(P){const at={track:[],name:"unnamed scope",id:this.state.nextScopeId++};P&&(at.name=P),this.state.scopeStack.push(at),this.state.activeScope=at}endScope(P){const at=(0,st.getTensorsInContainer)(P),nt=new Set(at.map(O=>O.id));for(let O=0;O<this.state.activeScope.track.length;O++){const Ct=this.state.activeScope.track[O];!Ct.kept&&!nt.has(Ct.id)&&Ct.dispose()}const Gt=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],at.forEach(O=>{!O.kept&&O.scopeId===Gt.id&&this.track(O)})}gradients(P,at,nt,Gt=!1){if(A.hu(at.length>0,()=>"gradients() received an empty list of xs."),null!=nt&&"float32"!==nt.dtype)throw new Error(`dy must have 'float32' dtype, but has '${nt.dtype}'`);const O=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",P));A.hu(O instanceof K.es,()=>"The result y returned by f() must be a tensor.");const Ct=function it(B,ot,P){const at={},nt={};for(let yt=0;yt<ot.length;yt++)at[ot[yt].id]=!0;for(let yt=0;yt<B.length;yt++){const vt=B[yt],xt=vt.inputs;for(const Mt in xt){const It=xt[Mt];let re=!1;for(let Bt=0;Bt<ot.length;Bt++)if(at[It.id]){vt.outputs.forEach(ee=>at[ee.id]=!0),re=!0,nt[vt.id]=!0;break}if(re)break}}const Gt={};Gt[P.id]=!0;const O={};for(let yt=B.length-1;yt>=0;yt--){const vt=B[yt],xt=vt.inputs;for(let Mt=0;Mt<vt.outputs.length;Mt++)if(Gt[vt.outputs[Mt].id]){for(const It in xt)Gt[xt[It].id]=!0,O[vt.id]=!0;break}}const Ct=[];for(let yt=0;yt<B.length;yt++){const vt=B[yt];if(nt[vt.id]&&O[vt.id]){const xt={};for(const It in vt.inputs){const re=vt.inputs[It];at[re.id]&&(xt[It]=re)}const Mt=Object.assign({},vt);Mt.inputs=xt,Mt.outputs=vt.outputs,Ct.push(Mt)}}return Ct}(this.state.activeTape,at,O);if(!Gt&&0===Ct.length&&at.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const yt={};yt[O.id]=nt??function St(B){const ot=(0,A.p8)((0,A.NA)(B),"float32");return ft.makeTensor(ot,B,"float32")}(O.shape),function bt(B,ot,P,at){for(let nt=ot.length-1;nt>=0;nt--){const Gt=ot[nt],O=[];if(Gt.outputs.forEach(yt=>{const vt=B[yt.id];O.push(null!=vt?vt:null)}),null==Gt.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${Gt.kernelName}.`);const Ct=Gt.gradient(O);for(const yt in Gt.inputs){if(!(yt in Ct))throw new Error(`Cannot backprop through input ${yt}. Available gradients found: ${Object.keys(Ct)}.`);const vt=P(()=>Ct[yt]());if("float32"!==vt.dtype)throw new Error(`Error in gradient for op ${Gt.kernelName}. The gradient of input ${yt} must have 'float32' dtype, but has '${vt.dtype}'`);const xt=Gt.inputs[yt];if(!A.cO(vt.shape,xt.shape))throw new Error(`Error in gradient for op ${Gt.kernelName}. The gradient of input '${yt}' has shape '${vt.shape}', which does not match the shape of the input '${xt.shape}'`);if(null==B[xt.id])B[xt.id]=vt;else{const Mt=B[xt.id];B[xt.id]=at(Mt,vt),Mt.dispose()}}}}(yt,Ct,xt=>this.tidy(xt),pt);const vt=at.map(xt=>yt[xt.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(xt=>{for(const Mt of xt.saved)Mt.dispose()}),this.state.activeTape=null),{value:O,grads:vt}})}customGrad(P){return A.hu(A.mf(P),()=>"The f passed in customGrad(f) must be a function."),(...at)=>{let nt;A.hu(at.every(yt=>yt instanceof K.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const Gt={};return at.forEach((yt,vt)=>{Gt[vt]=yt}),this.runKernelFunc({forwardFunc:(yt,vt)=>(nt=P(...at,vt),A.hu(nt.value instanceof K.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A.hu(A.mf(nt.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),nt.value),backwardsFunc:(yt,vt)=>{const xt=nt.gradFunc(yt,vt),Mt=Array.isArray(xt)?xt:[xt];A.hu(Mt.length===at.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A.hu(Mt.every(re=>re instanceof K.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const It={};return Mt.forEach((re,Bt)=>{It[Bt]=()=>re}),It},inputs:Gt})}}readSync(P){return this.state.tensorInfo.get(P).backend.readSync(P)}read(P){return this.state.tensorInfo.get(P).backend.read(P)}readToGPU(P,at){return this.state.tensorInfo.get(P).backend.readToGPU(P,at)}time(P){var at=this;return(0,$.Z)(function*(){const nt=(0,k.now)(),Gt=yield at.backend.time(P);return Gt.wallMs=(0,k.now)()-nt,Gt})()}track(P){return null!=this.state.activeScope&&(P.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(P)),P}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new dt;for(const P in this.registry)this.disposeRegisteredKernels(P),this.registry[P].dispose(),delete this.registry[P];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return B.nextTensorId=0,B.nextVariableId=0,B})();function Q(){const B=(0,q.D)();if(null==B._tfengine){const ot=new H.qA(B);B._tfengine=new lt(ot)}return(0,H.iG)(B._tfengine.ENV),(0,K.Vi)(()=>B._tfengine),B._tfengine}const ft=Q();function pt(B,ot){return ft.runKernel(Y.mm_,{a:B,b:ot})}},5527:(Lt,ut,y)=>{"use strict";y.d(ut,{OB:()=>k,Vi:()=>A,iG:()=>X,qA:()=>q});var $=y(5861),V=y(5359);const H="tfjsflags";class q{constructor(G){this.global=G,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Y,this.populateURLFlags()}setPlatform(G,it){null!=this.platform&&(k().getBool("IS_TEST")||k().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${G}.`)),this.platformName=G,this.platform=it}registerFlag(G,it,bt){if(this.flagRegistry[G]={evaluationFn:it,setHook:bt},null!=this.urlFlags[G]){const K=this.urlFlags[G];k().getBool("IS_TEST")||k().getBool("PROD")||console.warn(`Setting feature override from URL ${G}: ${K}.`),this.set(G,K)}}getAsync(G){var it=this;return(0,$.Z)(function*(){return G in it.flags||(it.flags[G]=yield it.evaluateFlag(G)),it.flags[G]})()}get(G){if(G in this.flags)return this.flags[G];const it=this.evaluateFlag(G);if((0,V.tI)(it))throw new Error(`Flag ${G} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[G]=it,this.flags[G]}getNumber(G){return this.get(G)}getBool(G){return this.get(G)}getString(G){return this.get(G)}getFlags(){return this.flags}get features(){return this.flags}set(G,it){if(null==this.flagRegistry[G])throw new Error(`Cannot set flag ${G} as it has not been registered.`);this.flags[G]=it,null!=this.flagRegistry[G].setHook&&this.flagRegistry[G].setHook(it)}evaluateFlag(G){if(null==this.flagRegistry[G])throw new Error(`Cannot evaluate flag '${G}': no evaluation function found.`);return this.flagRegistry[G].evaluationFn()}setFlags(G){this.flags=Object.assign({},G)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const G=this.getQueryParams(this.global.location.search);H in G&&G[H].split(",").forEach(bt=>{const[K,st]=bt.split(":");this.urlFlags[K]=function W(Z,G){const it=G.toLowerCase();return"true"===it||"false"===it?"true"===it:""+ +it===it?+it:G}(0,st)})}}function Y(Z){const G={};return Z.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(it,...bt)=>(function R(Z,G,it){Z[decodeURIComponent(G)]=decodeURIComponent(it||"")}(G,bt[0],bt[1]),bt.join("="))),G}function k(){return A}let A=null;function X(Z){A=Z}},2918:(Lt,ut,y)=>{"use strict";let $;function V(){if(null==$){let Y;if(typeof window<"u")Y=window;else if(typeof global<"u")Y=global;else if(typeof process<"u")Y=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");Y=self}$=Y}return $}function q(Y,R){const W=function H(){const Y=V();return null==Y._tfGlobals&&(Y._tfGlobals=new Map),Y._tfGlobals}();if(W.has(Y))return W.get(Y);{const k=R();return W.set(Y,k),W.get(Y)}}y.d(ut,{D:()=>V,R:()=>q})},2773:(Lt,ut,y)=>{"use strict";y.d(ut,{B9:()=>bt,CQ:()=>et,Cd:()=>dt,Cn:()=>K,G4:()=>Y,MX:()=>k,N5:()=>G,N8:()=>A,N_:()=>lt,R:()=>R,SR:()=>X,VY:()=>ot,XV:()=>st,cF:()=>W,cj:()=>St,jq:()=>pt,lu:()=>it,sq:()=>Z,x3:()=>Q,y3:()=>B,ze:()=>ft});var $=y(687),V=y(5527),H=y(4945),q=y(7664);function Y(){(0,V.OB)().set("PROD",!0)}function R(){(0,V.OB)().set("DEBUG",!0)}function W(){(0,V.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function k(P){(0,V.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(P+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function A(){$.BV.disposeVariables()}function X(){return $.BV}function Z(){return $.BV.memory()}function G(P){return $.BV.profile(P)}function it(P,at){return $.BV.tidy(P,at)}function bt(P){(0,q.getTensorsInContainer)(P).forEach(nt=>nt.dispose())}function K(P){return $.BV.keep(P)}function st(P){return $.BV.time(P)}function et(P){return $.BV.setBackend(P)}function dt(){return $.BV.ready()}function lt(){return $.BV.backendName}function St(P){$.BV.removeBackend(P)}function Q(P){return $.BV.findBackend(P)}function ft(P){return $.BV.findBackendFactory(P)}function pt(P,at,nt=1){return $.BV.registerBackend(P,at,nt)}function B(){return $.BV.backend}function ot(P,at){(0,V.OB)().setPlatform(P,at)}(0,H.FZ)(k)},3537:(Lt,ut,y)=>{"use strict";y.d(ut,{UQ:()=>Y,cb:()=>X,fN:()=>k,h7:()=>W,pn:()=>A,ti:()=>R});var $=y(687),V=y(4945),H=y(1257),q=y(5359);function Y(G){return q.hu(q.mf(G),()=>"The f passed in grad(f) must be a function"),(it,bt)=>{const K=(0,H._1)(it,"x","tf.grad","string_or_numeric"),st=null!=bt?(0,H._1)(bt,"dy","tf.grad"):null;return $.BV.tidy(()=>{const{value:et,grads:dt}=$.BV.gradients(()=>G(K),[K],st);return null!=st&&q.k5(et.shape,st.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Z(dt),dt[0]})}}function R(G){return q.hu(q.mf(G),()=>"The f passed in grads(f) must be a function"),(it,bt)=>{q.hu(Array.isArray(it),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const K=(0,H.sI)(it,"args","tf.grads","string_or_numeric"),st=null!=bt?(0,H._1)(bt,"dy","tf.grads"):null;return $.BV.tidy(()=>{const{value:et,grads:dt}=$.BV.gradients(()=>G(...K),K,st);return null!=st&&q.k5(et.shape,st.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Z(dt),dt})}}function W(G){return q.hu(q.mf(G),()=>"The f passed in valueAndGrad(f) must be a function"),(it,bt)=>{q.hu(it instanceof V.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),q.hu(null==bt||bt instanceof V.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:K,value:st}=$.BV.gradients(()=>G(it),[it],bt);return Z(K),{grad:K[0],value:st}}}function k(G){return q.hu(q.mf(G),()=>"The f passed in valueAndGrads(f) must be a function"),(it,bt)=>{q.hu(Array.isArray(it)&&it.every(st=>st instanceof V.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),q.hu(null==bt||bt instanceof V.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const K=$.BV.gradients(()=>G(...it),it,bt);return null!=bt&&q.k5(K.value.shape,bt.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Z(K.grads),K}}function A(G,it){q.hu(q.mf(G),()=>"The f passed in variableGrads(f) must be a function"),q.hu(null==it||Array.isArray(it)&&it.every(Q=>Q instanceof V._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const bt=null!=it;if(!bt){it=[];for(const Q in $.BV.registeredVariables)it.push($.BV.registeredVariables[Q])}const K=bt?it.filter(Q=>!Q.trainable):null,st=it.length;it=it.filter(Q=>Q.trainable),q.hu(it.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${st} variables is trainable.`);const{value:dt,grads:lt}=$.BV.gradients(G,it,null,!0);q.hu(lt.some(Q=>null!=Q),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),q.hu(0===dt.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${dt.rank} tensor`);const St={};return it.forEach((Q,ft)=>{null!=lt[ft]&&(St[Q.name]=lt[ft])}),K?.forEach(Q=>St[Q.name]=null),{value:dt,grads:St}}function X(G){return $.BV.customGrad(G)}function Z(G){if(G.filter(bt=>null==bt).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},6300:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{Abs:()=>_e.SYM,Acos:()=>_e.VGw,Acosh:()=>_e.SpW,AdadeltaOptimizer:()=>Ks,AdagradOptimizer:()=>ti,AdamOptimizer:()=>Ls,AdamaxOptimizer:()=>Oa,Add:()=>_e.mm_,AddN:()=>_e.Xze,All:()=>_e.oT6,Any:()=>_e.IKK,ArgMax:()=>_e.sJF,ArgMin:()=>_e.aJk,Asin:()=>_e.M2y,Asinh:()=>_e.qw7,Atan:()=>_e.jMg,Atan2:()=>_e.QCc,Atanh:()=>_e.Oyi,AvgPool:()=>_e.JhU,AvgPool3D:()=>_e._k9,AvgPool3DGrad:()=>_e.IMb,AvgPoolGrad:()=>_e.ROF,BatchMatMul:()=>_e.XLW,BatchToSpaceND:()=>_e.zws,Bincount:()=>_e.zvY,BitwiseAnd:()=>_e.hCO,BroadcastArgs:()=>_e.eEB,BroadcastTo:()=>_e.Ly9,Cast:()=>_e.RFZ,Ceil:()=>_e.gJX,ClipByValue:()=>_e.xnO,Complex:()=>_e.Zz9,ComplexAbs:()=>_e.yj2,Concat:()=>_e.Eh3,Conv2D:()=>_e.mhS,Conv2DBackpropFilter:()=>_e.wUP,Conv2DBackpropInput:()=>_e.wm,Conv3D:()=>_e.x12,Conv3DBackpropFilterV2:()=>_e.o2y,Conv3DBackpropInputV2:()=>_e.ik2,Cos:()=>_e.mc4,Cosh:()=>_e.TR1,CropAndResize:()=>_e.VcC,Cumprod:()=>_e.Byc,Cumsum:()=>_e.iHb,DataStorage:()=>fs.JL,DenseBincount:()=>_e.QRR,DepthToSpace:()=>_e.T0n,DepthwiseConv2dNative:()=>_e.cie,DepthwiseConv2dNativeBackpropFilter:()=>_e.sL$,DepthwiseConv2dNativeBackpropInput:()=>_e.y7R,Diag:()=>_e.$w,Dilation2D:()=>_e.p4S,Dilation2DBackpropFilter:()=>_e.Vn9,Dilation2DBackpropInput:()=>_e.ekb,Draw:()=>_e.hGc,ENV:()=>et.Vi,Einsum:()=>_e.$g6,Elu:()=>_e.SX0,EluGrad:()=>_e.HEU,Environment:()=>et.qA,Equal:()=>_e.hdR,Erf:()=>_e.Omj,Exp:()=>_e.NEP,ExpandDims:()=>_e.YFo,Expm1:()=>_e.Y0y,FFT:()=>_e.vwp,Fill:()=>_e.deh,FlipLeftRight:()=>_e.Uyb,Floor:()=>_e.OR,FloorDiv:()=>_e.jeX,FromPixels:()=>_e.eBW,FusedBatchNorm:()=>_e.sHE,FusedConv2D:()=>_e._V0,FusedDepthwiseConv2D:()=>_e.luS,GatherNd:()=>_e.q1x,GatherV2:()=>_e.qi_,Greater:()=>_e.iZT,GreaterEqual:()=>_e.Acj,IFFT:()=>_e.Qg5,Identity:()=>_e.iJz,Imag:()=>_e.J_u,IsFinite:()=>_e.avt,IsInf:()=>_e.iWB,IsNan:()=>_e.r7n,KernelBackend:()=>fs.Zu,LRN:()=>_e.eZ0,LRNGrad:()=>_e.Hhh,LeakyRelu:()=>_e.J$2,Less:()=>_e.vtC,LessEqual:()=>_e.CAk,LinSpace:()=>_e.e7N,Log:()=>_e.ZbH,Log1p:()=>_e.kU,LogSoftmax:()=>_e.qCd,LogicalAnd:()=>_e.PYm,LogicalNot:()=>_e.VfG,LogicalOr:()=>_e.MZg,LogicalXor:()=>_e.w6g,LowerBound:()=>_e.qIC,MatrixBandPart:()=>_e.J7O,Max:()=>_e.YoZ,MaxPool:()=>_e.mTV,MaxPool3D:()=>_e.OAf,MaxPool3DGrad:()=>_e.OU7,MaxPoolGrad:()=>_e.OV7,MaxPoolWithArgmax:()=>_e.vFR,Maximum:()=>_e.BMI,Mean:()=>_e.q2K,Min:()=>_e.c17,Minimum:()=>_e.q8u,MirrorPad:()=>_e.jQs,Mod:()=>_e.Vbg,MomentumOptimizer:()=>wo,Multinomial:()=>_e.NZg,Multiply:()=>_e.wYn,Neg:()=>_e.kuV,NonMaxSuppressionV3:()=>_e.uv1,NonMaxSuppressionV4:()=>_e.cye,NonMaxSuppressionV5:()=>_e.W0H,NotEqual:()=>_e.yQU,OP_SCOPE_SUFFIX:()=>he.zvA,OneHot:()=>_e.we_,OnesLike:()=>_e.qWM,Optimizer:()=>Es,OptimizerConstructors:()=>Gr,Pack:()=>_e.QiL,PadV2:()=>_e.lyA,Pool:()=>_e.Kgp,Pow:()=>_e.pe_,Prelu:()=>_e.o0g,Prod:()=>_e.DlI,RMSPropOptimizer:()=>ys,RaggedGather:()=>_e.dDz,RaggedRange:()=>_e.CQl,RaggedTensorToTensor:()=>_e.BiW,Range:()=>_e.e6w,Rank:()=>qu.yw,Real:()=>_e.xJR,RealDiv:()=>_e.oHH,Reciprocal:()=>_e.$HU,Reduction:()=>zo.I,Relu:()=>_e.qkr,Relu6:()=>_e.SbG,Reshape:()=>_e.HZH,ResizeBilinear:()=>_e._Yw,ResizeBilinearGrad:()=>_e.zbQ,ResizeNearestNeighbor:()=>_e.dpD,ResizeNearestNeighborGrad:()=>_e.Hmb,Reverse:()=>_e.mKl,RotateWithOffset:()=>_e.b9H,Round:()=>_e.e07,Rsqrt:()=>_e.bV0,SGDOptimizer:()=>eo,ScatterNd:()=>_e.xQA,SearchSorted:()=>_e.nr8,Select:()=>_e.PhF,Selu:()=>_e.oFR,Sigmoid:()=>_e.a5O,Sign:()=>_e.i5y,Sin:()=>_e.RQH,Sinh:()=>_e.wYB,Slice:()=>_e.p2w,Softmax:()=>_e.Gcp,Softplus:()=>_e.MRv,SpaceToBatchND:()=>_e.TQc,SparseFillEmptyRows:()=>_e.O3z,SparseReshape:()=>_e.nhH,SparseSegmentMean:()=>_e.w3H,SparseSegmentSum:()=>_e.ZjV,SparseToDense:()=>_e.D2d,SplitV:()=>_e.L8s,Sqrt:()=>_e.FKq,Square:()=>_e.bK0,SquaredDifference:()=>_e._tC,StaticRegexReplace:()=>_e.e0R,Step:()=>_e.h8e,StridedSlice:()=>_e.jQk,StringNGrams:()=>_e._JP,StringSplit:()=>_e.s1s,StringToHashBucketFast:()=>_e.XkS,Sub:()=>_e.Tr8,Sum:()=>_e.GBy,Tan:()=>_e.sEM,Tanh:()=>_e.MIZ,Tensor:()=>dr.es,TensorBuffer:()=>dr.YD,TensorScatterUpdate:()=>_e.SIB,Tile:()=>_e.n9L,TopK:()=>_e.cWu,Transform:()=>_e.wx7,Transpose:()=>_e.G3Y,Unique:()=>_e.kpP,Unpack:()=>_e.ToN,UnsortedSegmentSum:()=>_e.Qvg,UpperBound:()=>_e.XDQ,Variable:()=>dr._w,ZerosLike:()=>_e.RuY,_FusedMatMul:()=>_e.usg,abs:()=>he.WnP,acos:()=>he.Khb,acosh:()=>he.__u,add:()=>he.IHx,addN:()=>he.QBD,all:()=>he.$6P,any:()=>he.YjB,argMax:()=>he.NqF,argMin:()=>he.vHJ,asin:()=>he.ZRM,asinh:()=>he.VfV,atan:()=>he.z4N,atan2:()=>he.fvJ,atanh:()=>he.C80,avgPool:()=>he.wS1,avgPool3d:()=>he.uR5,backend:()=>vn.y3,backend_util:()=>A,basicLSTMCell:()=>he.zEQ,batchNorm:()=>he.tgs,batchNorm2d:()=>he.Dxk,batchNorm3d:()=>he.JY5,batchNorm4d:()=>he.p3b,batchToSpaceND:()=>he.E4h,bincount:()=>he.yE8,bitwiseAnd:()=>he.ycw,booleanMaskAsync:()=>he.anm,broadcastArgs:()=>he.XsQ,broadcastTo:()=>he.UFq,broadcast_util:()=>as,browser:()=>Y,buffer:()=>he.f3b,cast:()=>he.pju,ceil:()=>he.mDi,clipByValue:()=>he.iUl,clone:()=>he.d9v,complex:()=>he.PYB,concat:()=>he.zoF,concat1d:()=>he.gME,concat2d:()=>he.Izb,concat3d:()=>he.MNy,concat4d:()=>he.ZaL,conv1d:()=>he.PAt,conv2d:()=>he.Tek,conv2dTranspose:()=>he.bc,conv3d:()=>he.pdZ,conv3dTranspose:()=>he.$QV,copyRegisteredKernels:()=>z.T3,cos:()=>he.mCk,cosh:()=>he.f9Y,cosineWindow:()=>he.mew,cumprod:()=>he.$Gn,cumsum:()=>he.zbp,customGrad:()=>Rr.cb,denseBincount:()=>he.ppE,deprecationWarn:()=>vn.MX,depthToSpace:()=>he.nTT,depthwiseConv2d:()=>he.B10,device_util:()=>$,diag:()=>he.Ka3,dilation2d:()=>he.WmZ,disableDeprecationWarnings:()=>vn.cF,dispose:()=>vn.B9,disposeVariables:()=>vn.N8,div:()=>he.hiC,divNoNan:()=>he.NTj,dot:()=>he.AKD,dropout:()=>he.rvX,einsum:()=>he.WYO,elu:()=>he.pyx,enableDebugMode:()=>vn.R,enableProdMode:()=>vn.G4,enclosingPowerOfTwo:()=>he.GRh,engine:()=>vn.SR,ensureShape:()=>he.EDe,env:()=>et.OB,equal:()=>he.DgJ,erf:()=>he.qNN,euclideanNorm:()=>he.d2q,exp:()=>he.Qqt,expandDims:()=>he.dt4,expm1:()=>he.t$B,eye:()=>he.iyy,fft:()=>he.kp_,fill:()=>he.hlL,findBackend:()=>vn.x3,findBackendFactory:()=>vn.ze,floor:()=>he.GWj,floorDiv:()=>he.qPi,fused:()=>he.imm,gather:()=>he.Iqj,gatherND:()=>he.dbB,gather_util:()=>R,getBackend:()=>vn.N_,getGradient:()=>z.uk,getKernel:()=>z.pI,getKernelsForBackend:()=>z.tr,grad:()=>Rr.UQ,grads:()=>Rr.ti,greater:()=>he.pjt,greaterEqual:()=>he.brS,ifft:()=>he.Sxn,imag:()=>he.asL,image:()=>he.BHj,inTopKAsync:()=>he.V3u,io:()=>H,irfft:()=>he.wx0,isFinite:()=>he.xVT,isInf:()=>he.UWc,isNaN:()=>he.i2d,keep:()=>vn.Cn,kernel_impls:()=>X,leakyRelu:()=>he.hi7,less:()=>he.d9m,lessEqual:()=>he.zN1,linalg:()=>he.$r2,linspace:()=>he.SX3,localResponseNormalization:()=>he.G9k,log:()=>he.cM7,log1p:()=>he.Krr,logSigmoid:()=>he.e_t,logSoftmax:()=>he.CmS,logSumExp:()=>he.l_t,logicalAnd:()=>he.HvI,logicalNot:()=>he.hJK,logicalOr:()=>he.K5V,logicalXor:()=>he.egP,losses:()=>he.MB5,lowerBound:()=>he.eab,matMul:()=>he.OI3,math:()=>q,max:()=>he.Fp7,maxPool:()=>he._sB,maxPool3d:()=>he.YQQ,maxPoolWithArgmax:()=>he.Ip$,maximum:()=>he.gWQ,mean:()=>he.J69,memory:()=>vn.sq,meshgrid:()=>he.ry_,min:()=>he.VV$,minimum:()=>he.LTh,mirrorPad:()=>he.VdP,mod:()=>he.wQq,moments:()=>he.Gi7,movingAverage:()=>he.p_,mul:()=>he.dC7,multiRNNCell:()=>he.rq4,multinomial:()=>he.SJ_,neg:()=>he.W76,nextFrame:()=>Br,norm:()=>he.KOy,notEqual:()=>he.Quu,oneHot:()=>he.lfX,ones:()=>he.iUs,onesLike:()=>he.JpU,op:()=>he.op,outerProduct:()=>he.N2O,pad:()=>he.vku,pad1d:()=>he.pNR,pad2d:()=>he.koy,pad3d:()=>he.t1L,pad4d:()=>he.lGY,pool:()=>he.d_R,pow:()=>he.sQ3,prelu:()=>he.AL3,print:()=>he.S0v,prod:()=>he.WVs,profile:()=>vn.N5,raggedGather:()=>he.$gW,raggedRange:()=>he.VT$,raggedTensorToTensor:()=>he.N89,rand:()=>he.TN_,randomGamma:()=>he.wzB,randomNormal:()=>he.nGf,randomStandardNormal:()=>he.ruB,randomUniform:()=>he.LGj,randomUniformInt:()=>he.pe5,range:()=>he.w6H,ready:()=>vn.Cd,real:()=>he.kwC,reciprocal:()=>he.M25,registerBackend:()=>vn.jq,registerGradient:()=>z.Li,registerKernel:()=>z.wC,relu:()=>he.UYe,relu6:()=>he.btT,removeBackend:()=>vn.cj,reshape:()=>he.XLQ,reverse:()=>he.GYS,reverse1d:()=>he.SDf,reverse2d:()=>he.diP,reverse3d:()=>he.sx7,reverse4d:()=>he.mG2,rfft:()=>he.QEs,round:()=>he.NMM,rsqrt:()=>he.bp0,scalar:()=>he.iD$,scatterND:()=>he.snQ,scatter_util:()=>ni,searchSorted:()=>he.zcT,selu:()=>he.U8D,separableConv2d:()=>he.U_I,serialization:()=>V,setBackend:()=>vn.CQ,setPlatform:()=>vn.VY,setdiff1dAsync:()=>he.ODp,sigmoid:()=>he.XD2,sign:()=>he.Xxe,signal:()=>he.tdS,sin:()=>he.O$l,sinh:()=>he.R_K,slice:()=>he.tPi,slice1d:()=>he.jZU,slice2d:()=>he.SmN,slice3d:()=>he.CnO,slice4d:()=>he.p0P,slice_util:()=>Zs,softmax:()=>he.XAC,softplus:()=>he.Wvh,spaceToBatchND:()=>he.fBT,sparse:()=>he.rVs,sparseToDense:()=>he.ers,spectral:()=>he.uN7,split:()=>he.Vl2,sqrt:()=>he._b3,square:()=>he.h62,squaredDifference:()=>he.$i,squeeze:()=>he.L9e,stack:()=>he.knu,step:()=>he.Nbs,stridedSlice:()=>he.NXj,string:()=>he.Z_8,sub:()=>he.luU,sum:()=>he.Smz,sumOutType:()=>qu.z4,tan:()=>he.ORZ,tanh:()=>he.AEp,tensor:()=>he.XeE,tensor1d:()=>he.RRF,tensor2d:()=>he.odF,tensor3d:()=>he.wOQ,tensor4d:()=>he.yXz,tensor5d:()=>he.Bfx,tensor6d:()=>he.xZs,tensorScatterUpdate:()=>he.Pg0,tensor_util:()=>Xr,test_util:()=>W,tidy:()=>vn.lu,tile:()=>he.Gg6,time:()=>vn.XV,topk:()=>he.hg7,train:()=>jl,transpose:()=>he.p4s,truncatedNormal:()=>he.Xu6,unique:()=>he.Two,unregisterGradient:()=>z.bt,unregisterKernel:()=>z.nE,unsortedSegmentSum:()=>he.pUJ,unstack:()=>he.HHK,upcastType:()=>qu.x8,upperBound:()=>he.GaM,util:()=>tn,valueAndGrad:()=>Rr.h7,valueAndGrads:()=>Rr.fN,variable:()=>he.VD$,variableGrads:()=>Rr.pn,version_core:()=>mu,where:()=>he.arb,whereAsync:()=>he.itS,zeros:()=>he.lls,zerosLike:()=>he.P84});var $={};y.r($),y.d($,{isBrowser:()=>st,isMobile:()=>K,mockIsMobile:()=>bt});var V={};y.r(V),y.d(V,{Serializable:()=>oi,SerializationMap:()=>zr,getRegisteredName:()=>ho,registerClass:()=>js});var H={};y.r(H),y.d(H,{CompositeArrayBuffer:()=>P.w,browserFiles:()=>jr,browserHTTPRequest:()=>ks,concatenateArrayBuffers:()=>St.JY,copyModel:()=>Ce,decodeWeights:()=>St.dI,decodeWeightsStream:()=>St.r,encodeWeights:()=>St.yz,fromMemory:()=>mr,fromMemorySync:()=>ai,getLoadHandlers:()=>ot,getModelArtifactsForJSON:()=>St.jN,getModelArtifactsForJSONSync:()=>St.ji,getModelArtifactsInfoForJSON:()=>St.Q,getSaveHandlers:()=>B,getWeightSpecs:()=>St.hu,http:()=>Io,isHTTPScheme:()=>Fn,listModels:()=>Qo,loadWeights:()=>ya,moveModel:()=>Rt,registerLoadRouter:()=>pt,registerSaveRouter:()=>ft,removeModel:()=>Hn,weightsLoaderFactory:()=>Cs,withSaveHandler:()=>Kn,withSaveHandlerSync:()=>Pr});var q={};y.r(q),y.d(q,{confusionMatrix:()=>Or});var Y={};y.r(Y),y.d(Y,{draw:()=>vr,fromPixels:()=>wn,fromPixelsAsync:()=>nn,toPixels:()=>$n});var R={};y.r(R),y.d(R,{prepareAndValidate:()=>_r});var W={};y.r(W),y.d(W,{TEST_EPSILON_FLOAT16:()=>xr,createVideoElement:()=>Bo,encodeStrings:()=>pu,expectArrayBuffersEqual:()=>In,expectArraysClose:()=>qi,expectArraysEqual:()=>Rc,expectNumbersClose:()=>us,expectPromiseToFail:()=>ku,expectValuesInRange:()=>nu,play:()=>Hl,testEpsilon:()=>fo});var k={};y.r(k),y.d(k,{collectGatherOpShapeInfo:()=>vu,computeOutShape:()=>da,segOpComputeOptimalWindowSize:()=>Yr});var A={};y.r(A),y.d(A,{ERF_A1:()=>Uo,ERF_A2:()=>Ea,ERF_A3:()=>mi,ERF_A4:()=>yi,ERF_A5:()=>ka,ERF_P:()=>$s,PARALLELIZE_THRESHOLD:()=>Wn,RowPartitionType:()=>va,SELU_SCALE:()=>Ys.$,SELU_SCALEALPHA:()=>Ys.y,applyActivation:()=>Fs.QH,assertAndGetBroadcastShape:()=>as.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>es.lB,assertParamsConsistent:()=>ru,assignToTypedArray:()=>Tu,axesAreInnerMostDims:()=>es.YB,calculateShapes:()=>ni.calculateShapes,checkEinsumDimSizes:()=>ea,checkPadOnDimRoundingMode:()=>ls.m,combineLocations:()=>es.Vh,combineRaggedTensorToTensorShapes:()=>Vo,complexWithEvenIndex:()=>ta,complexWithOddIndex:()=>Wo,computeConv2DInfo:()=>ls.Ix,computeConv3DInfo:()=>ls.jw,computeDefaultPad:()=>ls.aO,computeDilation2DInfo:()=>ls.Rf,computeOptimalWindowSize:()=>Mo,computeOutAndReduceShapes:()=>es.kz,computeOutShape:()=>iu,computePool2DInfo:()=>ls.Xw,computePool3DInfo:()=>ls.pl,convertConv2DDataFormat:()=>ls.sl,decodeEinsumEquation:()=>wa,eitherStridesOrDilationsAreOne:()=>ls.jT,expandShapeToKeepDim:()=>es.rv,exponent:()=>Go,exponents:()=>Bs,fromStringArrayToUint8:()=>ws,fromUint8ToStringArray:()=>or,getAxesPermutation:()=>es.Q3,getBroadcastDims:()=>as.getBroadcastDims,getComplexWithIndex:()=>Ns,getEinsumComputePath:()=>go,getEinsumPermutation:()=>qs,getFusedBiasGradient:()=>Fs.pf,getFusedDyActivation:()=>Fs.Fr,getImageCenter:()=>Mn,getInnerMostAxes:()=>es.sY,getPermuted:()=>xa,getRaggedRank:()=>po,getReductionAxes:()=>as.getReductionAxes,getReshaped:()=>la,getReshapedPermuted:()=>cs,getRowPartitionTypesHelper:()=>_a,getSliceBeginCoords:()=>mo,getSliceSize:()=>su,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>hs,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Do,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>ca,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Au,getSparseReshapeInputOutputMismatchErrorMessage:()=>ds,getSparseReshapeInputOutputMultipleErrorMessage:()=>Ho,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>ns,getSparseReshapeNegativeOutputDimErrorMessage:()=>Il,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Ka,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>ha,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>no,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Kl,getUndoAxesPermutation:()=>es.LJ,isIdentityPermutation:()=>Fa,log:()=>Du.c,mergeRealAndImagArrays:()=>Ha,prepareAndValidate:()=>_r,prepareSplitSize:()=>So,segment_util:()=>k,shouldFuse:()=>Fs.uy,slice_util:()=>Zs,splitRealAndImagArrays:()=>pl,stridesOrDilationsArePositive:()=>ls.U3,tupleValuesAreOne:()=>ls.I0,upcastType:()=>qu.x8,validateDefaultValueShape:()=>Jo,validateInput:()=>ni.validateInput,validateUpdateShape:()=>ni.validateUpdateShape,warn:()=>Du.Z});var X={};y.r(X),y.d(X,{nonMaxSuppressionV3Impl:()=>Tr.GP,nonMaxSuppressionV4Impl:()=>Tr.qP,nonMaxSuppressionV5Impl:()=>Tr.pA,whereImpl:()=>ri.Z});var Z=y(687);let it;function bt(gt){it=gt}function K(gt){if(void 0!==it)return it;if(gt||function G(){return typeof navigator<"u"&&null!=navigator}()){if(gt||(gt=navigator),"ReactNative"===gt.product)return!0;const ct=gt.userAgent||gt.vendor||(typeof window<"u"?window.opera:"");return ct?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(ct)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(ct.substr(0,4)):gt.userAgentData&&gt.userAgentData.mobile}return!1}function st(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}var et=y(5527);const dt=(0,et.OB)();dt.registerFlag("DEBUG",()=>!1,gt=>{gt&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),dt.registerFlag("IS_BROWSER",()=>st()),dt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),dt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),dt.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),dt.registerFlag("PROD",()=>!1),dt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>dt.getBool("DEBUG")),dt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),dt.registerFlag("IS_TEST",()=>!1),dt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>dt.getBool("DEBUG")),dt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),dt.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),dt.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var lt=y(5861),St=y(8339);class Q{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Q.instance&&(Q.instance=new Q),Q.instance}static registerSaveRouter(ct){Q.getInstance().saveRouters.push(ct)}static registerLoadRouter(ct){Q.getInstance().loadRouters.push(ct)}static getSaveHandlers(ct){return Q.getHandlers(ct,"save")}static getLoadHandlers(ct,_t){return Q.getHandlers(ct,"load",_t)}static getHandlers(ct,_t,Nt){const Kt=[];return("load"===_t?Q.getInstance().loadRouters:Q.getInstance().saveRouters).forEach(Ee=>{const Te=Ee(ct,Nt);null!==Te&&Kt.push(Te)}),Kt}}const ft=gt=>Q.registerSaveRouter(gt),pt=gt=>Q.registerLoadRouter(gt),B=gt=>Q.getSaveHandlers(gt),ot=(gt,ct)=>Q.getLoadHandlers(gt,ct);var P=y(7864);const at="tensorflowjs",Gt="models_store",O="model_info_store";function vt(){if(!(0,et.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const gt=typeof window>"u"?self:window,ct=gt.indexedDB||gt.mozIndexedDB||gt.webkitIndexedDB||gt.msIndexedDB||gt.shimIndexedDB;if(null==ct)throw new Error("The current browser does not appear to support IndexedDB.");return ct}function xt(gt){const ct=gt.result;ct.createObjectStore(Gt,{keyPath:"modelPath"}),ct.createObjectStore(O,{keyPath:"modelPath"})}let Mt=(()=>{class gt{constructor(_t){if(this.indexedDB=vt(),null==_t||!_t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=_t}save(_t){var Nt=this;return(0,lt.Z)(function*(){if(_t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return Nt.databaseAction(Nt.modelPath,_t)})()}load(){var _t=this;return(0,lt.Z)(function*(){return _t.databaseAction(_t.modelPath)})()}databaseAction(_t,Nt){return new Promise((Kt,de)=>{const Ee=this.indexedDB.open(at,1);Ee.onupgradeneeded=()=>xt(Ee),Ee.onsuccess=()=>{const Te=Ee.result;if(null==Nt){const xe=Te.transaction(Gt,"readonly"),fn=xe.objectStore(Gt).get(this.modelPath);fn.onsuccess=()=>{if(null==fn.result)return Te.close(),de(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));Kt(fn.result.modelArtifacts)},fn.onerror=f=>(Te.close(),de(fn.error)),xe.oncomplete=()=>Te.close()}else{Nt.weightData=P.w.join(Nt.weightData);const xe=(0,St.Q)(Nt),Pe=Te.transaction(O,"readwrite");let f,E,fn=Pe.objectStore(O);try{f=fn.put({modelPath:this.modelPath,modelArtifactsInfo:xe})}catch(D){return de(D)}f.onsuccess=()=>{E=Te.transaction(Gt,"readwrite");const D=E.objectStore(Gt);let j;try{j=D.put({modelPath:this.modelPath,modelArtifacts:Nt,modelArtifactsInfo:xe})}catch(mt){return de(mt)}j.onsuccess=()=>Kt({modelArtifactsInfo:xe}),j.onerror=mt=>{fn=Pe.objectStore(O);const Ft=fn.delete(this.modelPath);Ft.onsuccess=()=>(Te.close(),de(j.error)),Ft.onerror=ce=>(Te.close(),de(j.error))}},f.onerror=D=>(Te.close(),de(f.error)),Pe.oncomplete=()=>{null==E?Te.close():E.oncomplete=()=>Te.close()}}},Ee.onerror=Te=>de(Ee.error)})}}return gt.URL_SCHEME="indexeddb://",gt})();const It=gt=>(0,et.OB)().getBool("IS_BROWSER")&&!Array.isArray(gt)&&gt.startsWith(Mt.URL_SCHEME)?function re(gt){return new Mt(gt)}(gt.slice(Mt.URL_SCHEME.length)):null;Q.registerSaveRouter(It),Q.registerLoadRouter(It);class ee{constructor(){this.indexedDB=vt()}listModels(){var ct=this;return(0,lt.Z)(function*(){return new Promise((_t,Nt)=>{const Kt=ct.indexedDB.open(at,1);Kt.onupgradeneeded=()=>xt(Kt),Kt.onsuccess=()=>{const de=Kt.result,Ee=de.transaction(O,"readonly"),xe=Ee.objectStore(O).getAll();xe.onsuccess=()=>{const Pe={};for(const fn of xe.result)Pe[fn.modelPath]=fn.modelArtifactsInfo;_t(Pe)},xe.onerror=Pe=>(de.close(),Nt(xe.error)),Ee.oncomplete=()=>de.close()},Kt.onerror=de=>Nt(Kt.error)})})()}removeModel(ct){var _t=this;return(0,lt.Z)(function*(){return ct=function Bt(gt){return gt.startsWith(Mt.URL_SCHEME)?gt.slice(Mt.URL_SCHEME.length):gt}(ct),new Promise((Nt,Kt)=>{const de=_t.indexedDB.open(at,1);de.onupgradeneeded=()=>xt(de),de.onsuccess=()=>{const Ee=de.result,Te=Ee.transaction(O,"readwrite"),xe=Te.objectStore(O),Pe=xe.get(ct);let fn;Pe.onsuccess=()=>{if(null==Pe.result)return Ee.close(),Kt(new Error(`Cannot find model with path '${ct}' in IndexedDB.`));{const f=xe.delete(ct),E=()=>{fn=Ee.transaction(Gt,"readwrite");const j=fn.objectStore(Gt).delete(ct);j.onsuccess=()=>Nt(Pe.result.modelArtifactsInfo),j.onerror=mt=>Kt(Pe.error)};f.onsuccess=E,f.onerror=D=>(E(),Ee.close(),Kt(Pe.error))}},Pe.onerror=f=>(Ee.close(),Kt(Pe.error)),Te.oncomplete=()=>{null==fn?Ee.close():fn.oncomplete=()=>Ee.close()}},de.onerror=Ee=>Kt(de.error)})})()}}var jt=y(5359);const se="/",be="tensorflowjs_models",Me="info",Xe="model_topology",Ue="weight_specs",De="weight_data",Tn="model_metadata";function ne(gt){return{info:[be,gt,Me].join(se),topology:[be,gt,Xe].join(se),weightSpecs:[be,gt,Ue].join(se),weightData:[be,gt,De].join(se),modelMetadata:[be,gt,Tn].join(se)}}function pe(gt){for(const ct of Object.values(gt))window.localStorage.removeItem(ct)}function Ie(gt){const ct=gt.split(se);if(ct.length<3)throw new Error(`Invalid key format: ${gt}`);return ct.slice(1,ct.length-1).join(se)}let Gn=(()=>{class gt{constructor(_t){if(!(0,et.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==_t||!_t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=_t,this.keys=ne(this.modelPath)}save(_t){var Nt=this;return(0,lt.Z)(function*(){if(_t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const Kt=JSON.stringify(_t.modelTopology),de=JSON.stringify(_t.weightSpecs),Ee=(0,St.Q)(_t),Te=P.w.join(_t.weightData);try{return Nt.LS.setItem(Nt.keys.info,JSON.stringify(Ee)),Nt.LS.setItem(Nt.keys.topology,Kt),Nt.LS.setItem(Nt.keys.weightSpecs,de),Nt.LS.setItem(Nt.keys.weightData,(0,St._n)(Te)),Nt.LS.setItem(Nt.keys.modelMetadata,JSON.stringify({format:_t.format,generatedBy:_t.generatedBy,convertedBy:_t.convertedBy,signature:null!=_t.signature?_t.signature:void 0,userDefinedMetadata:null!=_t.userDefinedMetadata?_t.userDefinedMetadata:void 0,modelInitializer:null!=_t.modelInitializer?_t.modelInitializer:void 0,initializerSignature:null!=_t.initializerSignature?_t.initializerSignature:void 0,trainingConfig:null!=_t.trainingConfig?_t.trainingConfig:void 0})),{modelArtifactsInfo:Ee}}catch{throw pe(Nt.keys),new Error(`Failed to save model '${Nt.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${Ee.modelTopologyBytes}, weightSpecsBytes=${Ee.weightSpecsBytes}, weightDataBytes=${Ee.weightDataBytes}.`)}}})()}load(){var _t=this;return(0,lt.Z)(function*(){const Nt=JSON.parse(_t.LS.getItem(_t.keys.info));if(null==Nt)throw new Error(`In local storage, there is no model with name '${_t.modelPath}'`);if("JSON"!==Nt.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const Kt={},de=JSON.parse(_t.LS.getItem(_t.keys.topology));if(null==de)throw new Error(`In local storage, the topology of model '${_t.modelPath}' is missing.`);Kt.modelTopology=de;const Ee=JSON.parse(_t.LS.getItem(_t.keys.weightSpecs));if(null==Ee)throw new Error(`In local storage, the weight specs of model '${_t.modelPath}' are missing.`);Kt.weightSpecs=Ee;const Te=_t.LS.getItem(_t.keys.modelMetadata);if(null!=Te){const Pe=JSON.parse(Te);Kt.format=Pe.format,Kt.generatedBy=Pe.generatedBy,Kt.convertedBy=Pe.convertedBy,null!=Pe.signature&&(Kt.signature=Pe.signature),null!=Pe.userDefinedMetadata&&(Kt.userDefinedMetadata=Pe.userDefinedMetadata),null!=Pe.modelInitializer&&(Kt.modelInitializer=Pe.modelInitializer),null!=Pe.initializerSignature&&(Kt.initializerSignature=Pe.initializerSignature),null!=Pe.trainingConfig&&(Kt.trainingConfig=Pe.trainingConfig)}const xe=_t.LS.getItem(_t.keys.weightData);if(null==xe)throw new Error(`In local storage, the binary weight values of model '${_t.modelPath}' are missing.`);return Kt.weightData=(0,St.n7)(xe),Kt})()}}return gt.URL_SCHEME="localstorage://",gt})();const Er=gt=>(0,et.OB)().getBool("IS_BROWSER")&&!Array.isArray(gt)&&gt.startsWith(Gn.URL_SCHEME)?function Nn(gt){return new Gn(gt)}(gt.slice(Gn.URL_SCHEME.length)):null;Q.registerSaveRouter(Er),Q.registerLoadRouter(Er);class Yn{constructor(){(0,jt.hu)((0,et.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,jt.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var ct=this;return(0,lt.Z)(function*(){const _t={},Nt=be+se,Kt=se+Me;for(let de=0;de<ct.LS.length;++de){const Ee=ct.LS.key(de);Ee.startsWith(Nt)&&Ee.endsWith(Kt)&&(_t[Ie(Ee)]=JSON.parse(ct.LS.getItem(Ee)))}return _t})()}removeModel(ct){var _t=this;return(0,lt.Z)(function*(){const Nt=ne(ct=function Je(gt){return gt.startsWith(Gn.URL_SCHEME)?gt.slice(Gn.URL_SCHEME.length):gt}(ct));if(null==_t.LS.getItem(Nt.info))throw new Error(`Cannot find model at path '${ct}'`);const Kt=JSON.parse(_t.LS.getItem(Nt.info));return pe(Nt),Kt})()}}const hi="://";class di{constructor(){this.managers={}}static getInstance(){return null==di.instance&&(di.instance=new di),di.instance}static registerManager(ct,_t){(0,jt.hu)(null!=ct,()=>"scheme must not be undefined or null."),ct.endsWith(hi)&&(ct=ct.slice(0,ct.indexOf(hi))),(0,jt.hu)(ct.length>0,()=>"scheme must not be an empty string.");const Nt=di.getInstance();(0,jt.hu)(null==Nt.managers[ct],()=>`A model store manager is already registered for scheme '${ct}'.`),Nt.managers[ct]=_t}static getManager(ct){const _t=di.getInstance().managers[ct];if(null==_t)throw new Error(`Cannot find model manager for scheme '${ct}'`);return _t}static getSchemes(){return Object.keys(di.getInstance().managers)}}function to(gt){if(-1===gt.indexOf(hi))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${di.getSchemes().join(",")}`);return{scheme:gt.split(hi)[0],path:gt.split(hi)[1]}}function ii(gt,ct){return yn.apply(this,arguments)}function yn(){return(yn=(0,lt.Z)(function*(gt,ct,_t=!1){(0,jt.hu)(gt!==ct,()=>`Old path and new path are the same: '${gt}'`);const Nt=Q.getLoadHandlers(gt);(0,jt.hu)(Nt.length>0,()=>`Copying failed because no load handler is found for source URL ${gt}.`),(0,jt.hu)(Nt.length<2,()=>`Copying failed because more than one (${Nt.length}) load handlers for source URL ${gt}.`);const Kt=Nt[0],de=Q.getSaveHandlers(ct);(0,jt.hu)(de.length>0,()=>`Copying failed because no save handler is found for destination URL ${ct}.`),(0,jt.hu)(de.length<2,()=>`Copying failed because more than one (${Nt.length}) save handlers for destination URL ${ct}.`);const Ee=de[0],Te=to(gt).scheme,xe=to(gt).path,Pe=Te===to(gt).scheme,fn=yield Kt.load();_t&&Pe&&(yield di.getManager(Te).removeModel(xe));const f=yield Ee.save(fn);return _t&&!Pe&&(yield di.getManager(Te).removeModel(xe)),f.modelArtifactsInfo})).apply(this,arguments)}function Qo(){return Eo.apply(this,arguments)}function Eo(){return(Eo=(0,lt.Z)(function*(){const gt=di.getSchemes(),ct={};for(const _t of gt){const Nt=yield di.getManager(_t).listModels();for(const Kt in Nt)ct[_t+hi+Kt]=Nt[Kt]}return ct})).apply(this,arguments)}function Hn(gt){return Hs.apply(this,arguments)}function Hs(){return(Hs=(0,lt.Z)(function*(gt){const ct=to(gt);return di.getManager(ct.scheme).removeModel(ct.path)})).apply(this,arguments)}function Ce(gt,ct){return Et.apply(this,arguments)}function Et(){return(Et=(0,lt.Z)(function*(gt,ct){return ii(gt,ct,!1)})).apply(this,arguments)}function Rt(gt,ct){return te.apply(this,arguments)}function te(){return(te=(0,lt.Z)(function*(gt,ct){return ii(gt,ct,!0)})).apply(this,arguments)}var oe=y(4705);class ie{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(ct,_t){return fetch(ct,_t)}now(){return performance.now()}encode(ct,_t){if("utf-8"!==_t&&"utf8"!==_t)throw new Error(`Browser's encoder only supports utf-8, but got ${_t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(ct)}decode(ct,_t){return new TextDecoder(_t).decode(ct)}setTimeoutCustom(ct,_t){typeof window>"u"||!(0,et.OB)().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(ct,_t):(this.functionRefs.push(ct),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},_t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",Nt=>{Nt.source===window&&Nt.data.name===this.messageName&&(Nt.stopPropagation(),(0,this.functionRefs[Nt.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(ct){return(0,oe.j)(ct)}}if((0,et.OB)().get("IS_BROWSER")){(0,et.OB)().setPlatform("browser",new ie);try{di.registerManager(Gn.URL_SCHEME,new Yn)}catch{}try{di.registerManager(Mt.URL_SCHEME,new ee)}catch{}}let Oe;(0,et.OB)().get("IS_NODE")&&!(0,et.OB)().get("IS_BROWSER")&&(0,et.OB)().setPlatform("node",new class ue{constructor(){this.util=y(8628),this.textEncoder=new this.util.TextEncoder}fetch(ct,_t){return null!=(0,et.OB)().global.fetch?(0,et.OB)().global.fetch(ct,_t):(null==Oe&&(Oe=y(5410)),Oe(ct,_t))}now(){const ct=process.hrtime();return 1e3*ct[0]+ct[1]/1e6}encode(ct,_t){if("utf-8"!==_t&&"utf8"!==_t)throw new Error(`Node built-in encoder only supports utf-8, but got ${_t}`);return this.textEncoder.encode(ct)}decode(ct,_t){return 0===ct.length?"":new this.util.TextDecoder(_t).decode(ct)}isTypedArray(ct){return this.util.types.isFloat32Array(ct)||this.util.types.isInt32Array(ct)||this.util.types.isUint8Array(ct)||this.util.types.isUint8ClampedArray(ct)}});var en=y(582),mn=y(3062),un=y(7315),tr=y(3006),dr=y(4945);(0,Z.wv)(),(0,dr.Vp)({buffer:en.f,cast:mn.p,clone:un.d,print:tr.S});var vn=y(2773),sr=y(7066),Jr=y(3530),Qn=y(8737),wr=y(930),Dn=y(7527),si=y(3143),Rr=y(3537),er=y(8661);const Zi=new Map,fi=new Map;class oi{getClassName(){return this.constructor.className}static fromConfig(ct,_t){return new ct(_t)}}class zr{constructor(){this.classNameMap={}}static getMap(){return null==zr.instance&&(zr.instance=new zr),zr.instance}static register(ct){zr.getMap().classNameMap[ct.className]=[ct,ct.fromConfig]}}function js(gt,ct,_t){(0,jt.hu)(null!=gt.className,()=>"Class being registered does not have the static className property defined."),(0,jt.hu)("string"==typeof gt.className,()=>"className is required to be a string, but got type "+typeof gt.className),(0,jt.hu)(gt.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof ct>"u"&&(ct="Custom"),typeof _t>"u"&&(_t=gt.className);const Kt=ct+">"+_t;return zr.register(gt),Zi.set(Kt,gt),fi.set(gt,Kt),gt}function ho(gt){return fi.has(gt)?fi.get(gt):gt.className}class Es extends oi{minimize(ct,_t=!1,Nt){const{value:Kt,grads:de}=this.computeGradients(ct,Nt);if(null!=Nt){const Ee=Nt.map(Te=>({name:Te.name,tensor:de[Te.name]}));this.applyGradients(Ee)}else this.applyGradients(de);return(0,vn.B9)(de),_t?Kt:(Kt.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(ct,_t){return(0,Rr.pn)(ct,_t)}dispose(){null!=this.iterations_&&(0,vn.B9)(this.iterations_)}saveIterations(){var ct=this;return(0,lt.Z)(function*(){return null==ct.iterations_&&(ct.iterations_=0),{name:"iter",tensor:(0,er.i)(ct.iterations_,"int32")}})()}getWeights(){return(0,lt.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${_t.getClassName()}`)})()}extractIterations(ct){var _t=this;return(0,lt.Z)(function*(){return _t.iterations_=(yield ct[0].tensor.data())[0],ct.slice(1)})()}}Object.defineProperty(Es,Symbol.hasInstance,{value:gt=>null!=gt.minimize&&null!=gt.computeGradients&&null!=gt.applyGradients});class Ks extends Es{static get className(){return"Adadelta"}constructor(ct,_t,Nt=null){super(),this.learningRate=ct,this.rho=_t,this.epsilon=Nt,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==Nt&&(this.epsilon=Z.BV.backend.epsilon())}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Z.BV.registeredVariables[Nt];null==this.accumulatedGrads[Kt]&&(this.accumulatedGrads[Kt]={originalName:`${Nt}/accum_grad`,variable:(0,vn.lu)(()=>(0,si.P)(de).variable(!1))}),null==this.accumulatedUpdates[Kt]&&(this.accumulatedUpdates[Kt]={originalName:`${Nt}/accum_var`,variable:(0,vn.lu)(()=>(0,si.P)(de).variable(!1))});const Te=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];if(null==Te)return;const xe=this.accumulatedGrads[Kt].variable,Pe=this.accumulatedUpdates[Kt].variable;(0,vn.lu)(()=>{const fn=(0,sr.I)((0,Qn.d)(xe,this.rho),(0,Qn.d)((0,Dn.h)(Te),1-this.rho)),f=(0,Qn.d)((0,Jr.h)((0,wr._)((0,sr.I)(Pe,this.epsilon)),(0,wr._)((0,sr.I)(xe,this.epsilon))),Te),E=(0,sr.I)((0,Qn.d)(Pe,this.rho),(0,Qn.d)((0,Dn.h)(f),1-this.rho));xe.assign(fn),Pe.assign(E);const D=(0,sr.I)((0,Qn.d)(f,-this.learningRate),de);de.assign(D)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,vn.B9)(this.accumulatedGrads.map(ct=>ct.variable)),(0,vn.B9)(this.accumulatedUpdates.map(ct=>ct.variable)))}getWeights(){var ct=this;return(0,lt.Z)(function*(){const _t=[...ct.accumulatedGrads,...ct.accumulatedUpdates];return[yield ct.saveIterations()].concat(_t.map(Nt=>({name:Nt.originalName,tensor:Nt.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){const Nt=(ct=yield _t.extractIterations(ct)).length/2;_t.accumulatedGrads=ct.slice(0,Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})),_t.accumulatedUpdates=ct.slice(Nt,2*Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.rho,_t.epsilon)}}var Ss=y(2787);class ti extends Es{static get className(){return"Adagrad"}constructor(ct,_t=.1){super(),this.learningRate=ct,this.initialAccumulatorValue=_t,this.accumulatedGrads=[]}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Z.BV.registeredVariables[Nt];null==this.accumulatedGrads[Kt]&&(this.accumulatedGrads[Kt]={originalName:`${Nt}/accumulator`,variable:(0,vn.lu)(()=>(0,Ss.h)(de.shape,this.initialAccumulatorValue).variable(!1))});const Ee=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];if(null==Ee)return;const Te=this.accumulatedGrads[Kt].variable;(0,vn.lu)(()=>{const xe=(0,sr.I)(Te,(0,Dn.h)(Ee));Te.assign(xe);const Pe=(0,sr.I)((0,Qn.d)((0,Jr.h)(Ee,(0,wr._)((0,sr.I)(xe,Z.BV.backend.epsilon()))),-this.learningRate),de);de.assign(Pe)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,vn.B9)(this.accumulatedGrads.map(ct=>ct.variable))}getWeights(){var ct=this;return(0,lt.Z)(function*(){return[yield ct.saveIterations()].concat(ct.accumulatedGrads.map(_t=>({name:_t.originalName,tensor:_t.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){ct=yield _t.extractIterations(ct),_t.accumulatedGrads=ct.map(Kt=>({originalName:Kt.name,variable:Kt.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.initialAccumulatorValue)}}var Vr=y(2962),Co=y(1191);class Ls extends Es{static get className(){return"Adam"}constructor(ct,_t,Nt,Kt=null){super(),this.learningRate=ct,this.beta1=_t,this.beta2=Nt,this.epsilon=Kt,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,vn.lu)(()=>{this.accBeta1=(0,er.i)(_t).variable(),this.accBeta2=(0,er.i)(Nt).variable()}),null==Kt&&(this.epsilon=Z.BV.backend.epsilon())}applyGradients(ct){const _t=Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct);(0,vn.lu)(()=>{const Nt=(0,Co.l)(1,this.accBeta1),Kt=(0,Co.l)(1,this.accBeta2);_t.forEach((de,Ee)=>{const Te=Z.BV.registeredVariables[de];null==this.accumulatedFirstMoment[Ee]&&(this.accumulatedFirstMoment[Ee]={originalName:`${de}/m`,variable:(0,vn.lu)(()=>(0,si.P)(Te).variable(!1))}),null==this.accumulatedSecondMoment[Ee]&&(this.accumulatedSecondMoment[Ee]={originalName:`${de}/v`,variable:(0,vn.lu)(()=>(0,si.P)(Te).variable(!1))});const Pe=Array.isArray(ct)?ct[Ee].tensor:ct[de];if(null==Pe)return;const fn=this.accumulatedFirstMoment[Ee].variable,f=this.accumulatedSecondMoment[Ee].variable,E=(0,sr.I)((0,Qn.d)(fn,this.beta1),(0,Qn.d)(Pe,1-this.beta1)),D=(0,sr.I)((0,Qn.d)(f,this.beta2),(0,Qn.d)((0,Dn.h)(Pe),1-this.beta2)),j=(0,Jr.h)(E,Nt),mt=(0,Jr.h)(D,Kt);fn.assign(E),f.assign(D);const Ft=(0,sr.I)((0,Qn.d)((0,Jr.h)(j,(0,sr.I)((0,wr._)(mt),this.epsilon)),-this.learningRate),Te);Te.assign(Ft)}),this.accBeta1.assign((0,Qn.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,Qn.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,vn.B9)(this.accumulatedFirstMoment.map(ct=>ct.variable)),null!=this.accumulatedSecondMoment&&(0,vn.B9)(this.accumulatedSecondMoment.map(ct=>ct.variable))}getWeights(){var ct=this;return(0,lt.Z)(function*(){const _t=[...ct.accumulatedFirstMoment,...ct.accumulatedSecondMoment];return[yield ct.saveIterations()].concat(_t.map(Nt=>({name:Nt.originalName,tensor:Nt.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){ct=yield _t.extractIterations(ct),(0,vn.lu)(()=>{_t.accBeta1.assign((0,Vr.s)(_t.beta1,_t.iterations_+1)),_t.accBeta2.assign((0,Vr.s)(_t.beta2,_t.iterations_+1))});const Nt=ct.length/2;_t.accumulatedFirstMoment=ct.slice(0,Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})),_t.accumulatedSecondMoment=ct.slice(Nt,2*Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.beta1,_t.beta2,_t.epsilon)}}var Pa=y(6989),rs=y(765);class Oa extends Es{static get className(){return"Adamax"}constructor(ct,_t,Nt,Kt=null,de=0){super(),this.learningRate=ct,this.beta1=_t,this.beta2=Nt,this.epsilon=Kt,this.decay=de,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,vn.lu)(()=>{this.iteration=(0,er.i)(0).variable(),this.accBeta1=(0,er.i)(_t).variable()}),null==Kt&&(this.epsilon=Z.BV.backend.epsilon())}applyGradients(ct){const _t=Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct);(0,vn.lu)(()=>{const Nt=(0,Co.l)(1,this.accBeta1),Kt=(0,Jr.h)(-this.learningRate,(0,sr.I)((0,Qn.d)(this.iteration,this.decay),1));_t.forEach((de,Ee)=>{const Te=Z.BV.registeredVariables[de];null==this.accumulatedFirstMoment[Ee]&&(this.accumulatedFirstMoment[Ee]={originalName:`${de}/m`,variable:(0,si.P)(Te).variable(!1)}),null==this.accumulatedWeightedInfNorm[Ee]&&(this.accumulatedWeightedInfNorm[Ee]={originalName:`${de}/v`,variable:(0,si.P)(Te).variable(!1)});const Pe=Array.isArray(ct)?ct[Ee].tensor:ct[de];if(null==Pe)return;const fn=this.accumulatedFirstMoment[Ee].variable,f=this.accumulatedWeightedInfNorm[Ee].variable,E=(0,sr.I)((0,Qn.d)(fn,this.beta1),(0,Qn.d)(Pe,1-this.beta1)),D=(0,Qn.d)(f,this.beta2),j=(0,Pa.W)(Pe),mt=(0,rs.g)(D,j);fn.assign(E),f.assign(mt);const Ft=(0,sr.I)((0,Qn.d)((0,Jr.h)(Kt,Nt),(0,Jr.h)(E,(0,sr.I)(mt,this.epsilon))),Te);Te.assign(Ft)}),this.iteration.assign((0,sr.I)(this.iteration,1)),this.accBeta1.assign((0,Qn.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,vn.B9)(this.accumulatedFirstMoment.map(ct=>ct.variable)),null!=this.accumulatedWeightedInfNorm&&(0,vn.B9)(this.accumulatedWeightedInfNorm.map(ct=>ct.variable))}getWeights(){return(0,lt.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(ct){return(0,lt.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.beta1,_t.beta2,_t.epsilon,_t.decay)}}class eo extends Es{static get className(){return"SGD"}constructor(ct){super(),this.learningRate=ct,this.setLearningRate(ct)}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];if(null==de)return;const Ee=Z.BV.registeredVariables[Nt];(0,vn.lu)(()=>{const Te=(0,sr.I)((0,Qn.d)(this.c,de),Ee);Ee.assign(Te)})}),this.incrementIterations()}setLearningRate(ct){this.learningRate=ct,null!=this.c&&this.c.dispose(),this.c=(0,vn.Cn)((0,er.i)(-ct))}dispose(){this.c.dispose()}getWeights(){var ct=this;return(0,lt.Z)(function*(){return[yield ct.saveIterations()]})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){if(0!==(ct=yield _t.extractIterations(ct)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(ct,_t){return new ct(_t.learningRate)}}class wo extends eo{static get className(){return"Momentum"}constructor(ct,_t,Nt=!1){super(ct),this.learningRate=ct,this.momentum=_t,this.useNesterov=Nt,this.accumulations=[],this.m=(0,er.i)(this.momentum)}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Z.BV.registeredVariables[Nt];null==this.accumulations[Kt]&&(this.accumulations[Kt]={originalName:`${Nt}/momentum`,variable:(0,vn.lu)(()=>(0,si.P)(de).variable(!1))});const Ee=this.accumulations[Kt].variable,Te=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];null!=Te&&(0,vn.lu)(()=>{let xe;const Pe=(0,sr.I)((0,Qn.d)(this.m,Ee),Te);xe=(0,sr.I)((0,Qn.d)(this.c,this.useNesterov?(0,sr.I)(Te,(0,Qn.d)(Pe,this.m)):Pe),de),Ee.assign(Pe),de.assign(xe)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,vn.B9)(this.accumulations.map(ct=>ct.variable))}setMomentum(ct){this.momentum=ct}getWeights(){var ct=this;return(0,lt.Z)(function*(){return[yield ct.saveIterations()].concat(ct.accumulations.map(_t=>({name:_t.originalName,tensor:_t.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){ct=yield _t.extractIterations(ct),_t.accumulations=ct.map(Kt=>({originalName:Kt.name,variable:Kt.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.momentum,_t.useNesterov)}}class ys extends Es{static get className(){return"RMSProp"}constructor(ct,_t=.9,Nt=0,Kt=null,de=!1){if(super(),this.learningRate=ct,this.decay=_t,this.momentum=Nt,this.epsilon=Kt,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=de,null==Kt&&(this.epsilon=Z.BV.backend.epsilon()),null==ct)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Z.BV.registeredVariables[Nt];null==this.accumulatedMeanSquares[Kt]&&(this.accumulatedMeanSquares[Kt]={originalName:`${Nt}/rms`,variable:(0,vn.lu)(()=>(0,si.P)(de).variable(!1))}),null==this.accumulatedMoments[Kt]&&(this.accumulatedMoments[Kt]={originalName:`${Nt}/momentum`,variable:(0,vn.lu)(()=>(0,si.P)(de).variable(!1))}),null==this.accumulatedMeanGrads[Kt]&&this.centered&&(this.accumulatedMeanGrads[Kt]={originalName:`${Nt}/mg`,variable:(0,vn.lu)(()=>(0,si.P)(de).variable(!1))});const Te=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];if(null==Te)return;const xe=this.accumulatedMeanSquares[Kt].variable,Pe=this.accumulatedMoments[Kt].variable;(0,vn.lu)(()=>{const fn=(0,sr.I)((0,Qn.d)(xe,this.decay),(0,Qn.d)((0,Dn.h)(Te),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[Kt].variable,E=(0,sr.I)((0,Qn.d)(f,this.decay),(0,Qn.d)(Te,1-this.decay)),D=(0,Jr.h)((0,Qn.d)(Te,this.learningRate),(0,wr._)((0,Co.l)(fn,(0,sr.I)((0,Dn.h)(E),this.epsilon)))),j=(0,sr.I)((0,Qn.d)(Pe,this.momentum),D);xe.assign(fn),f.assign(E),Pe.assign(j);const mt=(0,Co.l)(de,j);de.assign(mt)}else{const f=(0,sr.I)((0,Qn.d)(xe,this.decay),(0,Qn.d)((0,Dn.h)(Te),1-this.decay)),E=(0,sr.I)((0,Qn.d)(Pe,this.momentum),(0,Jr.h)((0,Qn.d)(Te,this.learningRate),(0,wr._)((0,sr.I)(f,this.epsilon))));xe.assign(f),Pe.assign(E);const D=(0,Co.l)(de,E);de.assign(D)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,vn.B9)(this.accumulatedMeanSquares.map(ct=>ct.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,vn.B9)(this.accumulatedMeanGrads.map(ct=>ct.variable)),null!=this.accumulatedMoments&&(0,vn.B9)(this.accumulatedMoments.map(ct=>ct.variable))}getWeights(){var ct=this;return(0,lt.Z)(function*(){const _t=[...ct.accumulatedMeanSquares,...ct.accumulatedMoments];return ct.centered&&_t.push(...ct.accumulatedMeanGrads),[yield ct.saveIterations()].concat(_t.map(Nt=>({name:Nt.originalName,tensor:Nt.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){ct=yield _t.extractIterations(ct);const Nt=_t.centered?ct.length/3:ct.length/2;_t.accumulatedMeanSquares=ct.slice(0,Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})),_t.accumulatedMoments=ct.slice(Nt,2*Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})),_t.centered&&(_t.accumulatedMeanGrads=ct.slice(2*Nt,3*Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.decay,_t.momentum,_t.epsilon,_t.centered)}}const Wa=[Ks,ti,Ls,Oa,wo,ys,eo];function fu(gt){return new Promise(ct=>setTimeout(ct)).then(gt)}let Xs=(()=>{class gt{constructor(_t){if(!(0,et.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");_t.startsWith(gt.URL_SCHEME)&&(_t=_t.slice(gt.URL_SCHEME.length)),(null==_t||0===_t.length)&&(_t="model"),this.modelJsonFileName=_t+".json",this.weightDataFileName=_t+".weights.bin"}save(_t){var Nt=this;return(0,lt.Z)(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const Kt=P.w.join(_t.weightData),de=window.URL.createObjectURL(new Blob([Kt],{type:"application/octet-stream"}));if(_t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const Te=(0,St.Yd)(_t,[{paths:["./"+Nt.weightDataFileName],weights:_t.weightSpecs}]),xe=window.URL.createObjectURL(new Blob([JSON.stringify(Te)],{type:"application/json"})),Pe=null==Nt.modelJsonAnchor?document.createElement("a"):Nt.modelJsonAnchor;if(Pe.download=Nt.modelJsonFileName,Pe.href=xe,yield fu(()=>Pe.dispatchEvent(new MouseEvent("click"))),null!=_t.weightData){const fn=null==Nt.weightDataAnchor?document.createElement("a"):Nt.weightDataAnchor;fn.download=Nt.weightDataFileName,fn.href=de,yield fu(()=>fn.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:(0,St.Q)(_t)}}})()}}return gt.URL_SCHEME="downloads://",gt})();class Ga{constructor(ct){if(null==ct||ct.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${ct}`);this.jsonFile=ct[0],this.weightsFiles=ct.slice(1)}load(){var ct=this;return(0,lt.Z)(function*(){return new Promise((_t,Nt)=>{const Kt=new FileReader;Kt.onload=de=>{const Ee=JSON.parse(de.target.result),Te=Ee.modelTopology;if(null==Te)return void Nt(new Error(`modelTopology field is missing from file ${ct.jsonFile.name}`));if(null==Ee.weightsManifest)return void Nt(new Error(`weightManifest field is missing from file ${ct.jsonFile.name}`));if(0===ct.weightsFiles.length)return void _t({modelTopology:Te});const Pe=(0,St.jN)(Ee,fn=>ct.loadWeights(fn));_t(Pe)},Kt.onerror=de=>Nt(`Failed to read model topology and weights manifest JSON from file '${ct.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),Kt.readAsText(ct.jsonFile)})})()}loadWeights(ct){const _t=[],Nt=[];for(const Ee of ct)_t.push(...Ee.weights),Nt.push(...Ee.paths);const Kt=this.checkManifestAndWeightFiles(ct),de=Nt.map(Ee=>this.loadWeightsFile(Ee,Kt[Ee]));return Promise.all(de).then(Ee=>[_t,Ee])}loadWeightsFile(ct,_t){return new Promise((Nt,Kt)=>{const de=new FileReader;de.onload=Ee=>{Nt(Ee.target.result)},de.onerror=Ee=>Kt(`Failed to weights data from file of path '${ct}'.`),de.readAsArrayBuffer(_t)})}checkManifestAndWeightFiles(ct){const _t=[],Nt=this.weightsFiles.map(de=>(0,St.EZ)(de.name)),Kt={};for(const de of ct)de.paths.forEach(Ee=>{const Te=(0,St.EZ)(Ee);if(-1!==_t.indexOf(Te))throw new Error(`Duplicate file basename found in weights manifest: '${Te}'`);if(_t.push(Te),-1===Nt.indexOf(Te))throw new Error(`Weight file with basename '${Te}' is not provided.`);Kt[Ee]=this.weightsFiles[Nt.indexOf(Te)]});if(_t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${_t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return Kt}}function jr(gt){return new Ga(gt)}function qn(gt,ct,_t,Nt){(function Ee(xe){(0,jt.hu)(null!=xe&&Array.isArray(xe)&&xe.length>0,()=>"promises must be a none empty array")})(gt),function Te(xe,Pe){(0,jt.hu)(xe>=0&&xe<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${xe}`),(0,jt.hu)(Pe>=0&&Pe<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${Pe}`),(0,jt.hu)(Pe>=xe,()=>`startFraction must be no more than endFraction, but got startFraction ${xe} and endFraction ${Pe}`)}(_t=_t??0,Nt=Nt??1);let Kt=0;return Promise.all(gt.map(xe=>(xe.then(Pe=>{const fn=_t+ ++Kt/gt.length*(Nt-_t);return ct(fn),Pe}),xe)))}Q.registerSaveRouter(gt=>(0,et.OB)().getBool("IS_BROWSER")&&!Array.isArray(gt)&&gt.startsWith(Xs.URL_SCHEME)?function An(gt="model"){return new Xs(gt)}(gt.slice(Xs.URL_SCHEME.length)):null);var ga=y(1352);function nr(gt,ct){return bo.apply(this,arguments)}function bo(){return(bo=(0,lt.Z)(function*(gt,ct){null==ct&&(ct={});const _t=null==ct.fetchFunc?(0,et.OB)().platform.fetch:ct.fetchFunc,Nt=gt.map(f=>_t(f,ct.requestInit,{isBinary:!0})),Te=(null==ct.onProgress?yield Promise.all(Nt):yield qn(Nt,ct.onProgress,0,.5)).map(f=>f.arrayBuffer());return null==ct.onProgress?yield Promise.all(Te):yield qn(Te,ct.onProgress,.5,1)})).apply(this,arguments)}function ya(gt){return Xn.apply(this,arguments)}function Xn(){return(Xn=(0,lt.Z)(function*(gt,ct="",_t,Nt){return Cs(Ee=>nr(Ee,{requestInit:Nt}))(gt,ct,_t)})).apply(this,arguments)}function Cs(gt){return function(){var ct=(0,lt.Z)(function*(_t,Nt="",Kt){const de=_t.map(()=>!1),Ee={},Te=null!=Kt?Kt.map(()=>!1):[],xe=[];if(_t.forEach((j,mt)=>{let Ft=0;j.weights.forEach(ce=>{const Ve=ga.J["quantization"in ce?ce.quantization.dtype:ce.dtype]*jt.NA(ce.shape),sn=()=>{de[mt]=!0,null==Ee[mt]&&(Ee[mt]=[]),Ee[mt].push({manifestEntry:ce,groupOffset:Ft,sizeBytes:Ve})};null!=Kt?Kt.forEach((bn,Pn)=>{bn===ce.name&&(sn(),Te[Pn]=!0)}):sn(),xe.push(ce.name),Ft+=Ve})}),!Te.every(j=>j)){const j=Kt.filter((mt,Ft)=>!Te[Ft]);throw new Error(`Could not find weights in manifest with names: ${j.join(", ")}. \nManifest JSON has weights with names: ${xe.join(", ")}.`)}const Pe=de.reduce((j,mt,Ft)=>(mt&&j.push(Ft),j),[]),fn=[];Pe.forEach(j=>{_t[j].paths.forEach(mt=>{const Ft=Nt+(Nt.endsWith("/")?"":"/")+mt;fn.push(Ft)})});const f=yield gt(fn),E={};let D=0;return Pe.forEach(j=>{const mt=_t[j].paths.length,Ft=new P.w(f.slice(D,D+mt));Ee[j].forEach(ye=>{const Ve=Ft.slice(ye.groupOffset,ye.groupOffset+ye.sizeBytes),sn=(0,St.dI)(Ve,[ye.manifestEntry]);for(const bn in sn)E[bn]=sn[bn]}),D+=mt}),E});return function(_t){return ct.apply(this,arguments)}}()}let an=(()=>{class gt{constructor(_t,Nt){if(this.DEFAULT_METHOD="POST",null==Nt&&(Nt={}),this.weightPathPrefix=Nt.weightPathPrefix,this.weightUrlConverter=Nt.weightUrlConverter,null!=Nt.fetchFunc?((0,jt.hu)("function"==typeof Nt.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=Nt.fetchFunc):this.fetch=(0,et.OB)().platform.fetch,(0,jt.hu)(null!=_t&&_t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(_t)&&(0,jt.hu)(2===_t.length,()=>`URL paths for http must have a length of 2, (actual length is ${_t.length}).`),this.path=_t,null!=Nt.requestInit&&null!=Nt.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=Nt.requestInit||{},this.loadOptions=Nt}save(_t){var Nt=this;return(0,lt.Z)(function*(){if(_t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const Kt=Object.assign({method:Nt.DEFAULT_METHOD},Nt.requestInit);Kt.body=new FormData;const Ee=(0,St.Yd)(_t,[{paths:["./model.weights.bin"],weights:_t.weightSpecs}]);if(Kt.body.append("model.json",new Blob([JSON.stringify(Ee)],{type:"application/json"}),"model.json"),null!=_t.weightData){const xe=P.w.join(_t.weightData);Kt.body.append("model.weights.bin",new Blob([xe],{type:"application/octet-stream"}),"model.weights.bin")}const Te=yield Nt.fetch(Nt.path,Kt);if(Te.ok)return{modelArtifactsInfo:(0,St.Q)(_t),responses:[Te]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${Te.status}.`)})()}loadModelJSON(){var _t=this;return(0,lt.Z)(function*(){const Nt=yield _t.fetch(_t.path,_t.requestInit);if(!Nt.ok)throw new Error(`Request to ${_t.path} failed with status code ${Nt.status}. Please verify this URL points to the model JSON of the model to load.`);let Kt;try{Kt=yield Nt.json()}catch{let xe=`Failed to parse model JSON of response from ${_t.path}.`;throw _t.path.endsWith(".pb")?xe+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":xe+=" Please make sure the server is serving valid JSON for this request.",new Error(xe)}if(null==Kt.modelTopology&&null==Kt.weightsManifest)throw new Error(`The JSON from HTTP path ${_t.path} contains neither model topology or manifest for weights.`);return Kt})()}load(){var _t=this;return(0,lt.Z)(function*(){if(_t.loadOptions.streamWeights)return _t.loadStream();const Nt=yield _t.loadModelJSON();return(0,St.jN)(Nt,Kt=>_t.loadWeights(Kt))})()}loadStream(){var _t=this;return(0,lt.Z)(function*(){const Nt=yield _t.loadModelJSON(),Kt=yield _t.getWeightUrls(Nt.weightsManifest),de=(0,St.hu)(Nt.weightsManifest);return Object.assign(Object.assign({},Nt),{weightSpecs:de,getWeightStream:()=>function Yu(gt,ct){var _t;const Nt=null==ct.fetchFunc?(0,et.OB)().platform.fetch:ct.fetchFunc;let de,Kt=0;return null===(_t=ct.onProgress)||void 0===_t||_t.call(ct,0),new ReadableStream({pull:(Ee=(0,lt.Z)(function*(Te){for(var xe;Kt<gt.length;){de||(de=(yield Nt(gt[Kt],ct.requestInit,{isBinary:!0})).body.getReader());const{done:Pe,value:fn}=yield de.read();if(!Pe)return void Te.enqueue(fn);Kt++,de=void 0,null===(xe=ct.onProgress)||void 0===xe||xe.call(ct,Kt/gt.length)}Te.close()}),function(xe){return Ee.apply(this,arguments)})});var Ee}(Kt,_t.loadOptions)})})()}getWeightUrls(_t){var Nt=this;return(0,lt.Z)(function*(){const Kt=Array.isArray(Nt.path)?Nt.path[1]:Nt.path,[de,Ee]=function ei(gt){const ct=gt.lastIndexOf("/"),_t=gt.lastIndexOf("?");return[gt.substring(0,ct)+"/",_t>ct?gt.substring(_t):""]}(Kt),Te=Nt.weightPathPrefix||de,xe=[],Pe=[];for(const fn of _t)for(const f of fn.paths)null!=Nt.weightUrlConverter?Pe.push(Nt.weightUrlConverter(f)):xe.push(Te+f+Ee);return Nt.weightUrlConverter&&xe.push(...yield Promise.all(Pe)),xe})()}loadWeights(_t){var Nt=this;return(0,lt.Z)(function*(){const Kt=yield Nt.getWeightUrls(_t);return[(0,St.hu)(_t),yield nr(Kt,Nt.loadOptions)]})()}}return gt.URL_SCHEME_REGEX=/^https?:\/\//,gt})();function Fn(gt){return null!=gt.match(an.URL_SCHEME_REGEX)}const Ds=(gt,ct)=>{if(typeof fetch>"u"&&(null==ct||null==ct.fetchFunc))return null;{let _t=!0;if(_t=Array.isArray(gt)?gt.every(Nt=>Fn(Nt)):Fn(gt),_t)return Io(gt,ct)}return null};function Io(gt,ct){return new an(gt,ct)}function ks(gt,ct){return Io(gt,ct)}Q.registerSaveRouter(Ds),Q.registerLoadRouter(Ds);class Ur{constructor(ct){this.modelArtifacts=ct}load(){return this.modelArtifacts}}class We{constructor(ct){this.saveHandler=ct}save(ct){return this.saveHandler(ct)}}class Kr{constructor(ct){ct.load&&(this.load=()=>Promise.resolve(ct.load())),ct.save&&(this.save=_t=>Promise.resolve(ct.save(_t)))}}function mr(gt,ct,_t,Nt){return new Kr(ai(...arguments))}function ai(gt,ct,_t,Nt){return 1===arguments.length?null!=gt.modelTopology||null!=gt.weightSpecs?new Ur(gt):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ur({modelTopology:gt})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ur({modelTopology:gt,weightSpecs:ct,weightData:_t,trainingConfig:Nt}))}function Kn(gt){return new We(gt)}function Pr(gt){return new We(gt)}var br=y(1257),Wr=y(5592),Ts=y(5618),os=y(4195),Iu=y(9194);const Or=(0,os.op)({confusionMatrix_:function $o(gt,ct,_t){const Nt=(0,br._1)(gt,"labels","confusionMatrix"),Kt=(0,br._1)(ct,"predictions","confusionMatrix");jt.hu(null==_t||_t>0&&Number.isInteger(_t),()=>`If provided, numClasses must be a positive integer, but got ${_t}`),jt.hu(1===Nt.rank,()=>`Expected the rank of labels to be 1, but got ${Nt.rank}`),jt.hu(1===Kt.rank,()=>`Expected the rank of predictions to be 1, but got ${Kt.rank}`),jt.hu(Nt.shape[0]===Kt.shape[0],()=>`Mismatch in the number of examples: ${Nt.shape[0]} vs. ${Kt.shape[0]}. Labels and predictions should have the same number of elements.`),jt.hu(_t>0&&Number.isInteger(_t),()=>`numClasses is required to be a positive integer, but got ${_t}`);const de=(0,Ts.l)((0,mn.p)(Nt,"int32"),_t),Ee=(0,Ts.l)((0,mn.p)(Kt,"int32"),_t),Te=(0,Iu.p)(de),xe=(0,Wr.O)(Te,Ee);return(0,mn.p)(xe,"int32")}});var as=y(3239),_e=y(4251),z=y(8987),I=y(2786);let M,tt=!1;function wt(gt,ct=3){if(ct>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==gt)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let _t=!1,Nt=!1,Kt=!1,de=!1,Ee=!1,Te=!1;if(gt.data instanceof Uint8Array)_t=!0;else if(typeof ImageData<"u"&&gt instanceof ImageData)Nt=!0;else if(typeof HTMLVideoElement<"u"&&gt instanceof HTMLVideoElement)Kt=!0;else if(typeof HTMLImageElement<"u"&&gt instanceof HTMLImageElement)de=!0;else if(null!=gt.getContext)Ee=!0;else{if(!(typeof ImageBitmap<"u"&&gt instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${gt.constructor.name}`);Te=!0}if(null!=(0,z.pI)(_e.eBW,Z.BV.backendName))return Z.BV.runKernel(_e.eBW,{pixels:gt},{numChannels:ct});const[Pe,fn]=Kt?[gt.videoWidth,gt.videoHeight]:[gt.width,gt.height];let f,E;if(Ee)f=gt.getContext("2d").getImageData(0,0,Pe,fn).data;else if(Nt||_t)f=gt.data;else if(de||Kt||Te){if(null==M)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");M=new OffscreenCanvas(1,1).getContext("2d")}else M=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});M.canvas.width=Pe,M.canvas.height=fn,M.drawImage(gt,0,0,Pe,fn),f=M.getImageData(0,0,Pe,fn).data}if(4===ct)E=new Int32Array(f);else{const j=Pe*fn;E=new Int32Array(j*ct);for(let mt=0;mt<j;mt++)for(let Ft=0;Ft<ct;++Ft)E[mt*ct+Ft]=f[4*mt+Ft]}return(0,I.w)(E,[fn,Pe,ct],"int32")}function nn(gt){return Ye.apply(this,arguments)}function Ye(){return(Ye=(0,lt.Z)(function*(gt,ct=3){let _t=null;if((0,et.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function ae(gt){return function Yt(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(gt instanceof ImageBitmap)&&function kt(gt){return null!=gt&&0!==gt.width&&0!==gt.height}(gt)&&!function At(gt){return null!=gt&&gt.data instanceof Uint8Array}(gt)}(gt)){let Nt;try{Nt=yield createImageBitmap(gt,{premultiplyAlpha:"none"})}catch{Nt=null}_t=null!=Nt&&Nt.width===gt.width&&Nt.height===gt.height?Nt:gt}else _t=gt;return wt(_t,ct)})).apply(this,arguments)}function $e(gt){if(2!==gt.rank&&3!==gt.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${gt.rank}.`);const ct=2===gt.rank?1:gt.shape[2];if(ct>4||2===ct)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${ct}`);if("float32"!==gt.dtype&&"int32"!==gt.dtype)throw new Error(`Unsupported type for toPixels: ${gt.dtype}. Please use float32 or int32 tensors.`)}function $n(gt,ct){return Vn.apply(this,arguments)}function Vn(){return(Vn=(0,lt.Z)(function*(gt,ct){let _t=(0,br._1)(gt,"img","toPixels");if(!(gt instanceof dr.es)){const Pe=_t;_t=(0,mn.p)(Pe,"int32"),Pe.dispose()}$e(_t);const[Nt,Kt]=_t.shape.slice(0,2),de=2===_t.rank?1:_t.shape[2],Ee=yield _t.data(),Te="float32"===_t.dtype?255:1,xe=new Uint8ClampedArray(Kt*Nt*4);for(let Pe=0;Pe<Nt*Kt;++Pe){const fn=[0,0,0,255];for(let E=0;E<de;E++){const D=Ee[Pe*de+E];if("float32"===_t.dtype){if(D<0||D>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${D}.`)}else if("int32"===_t.dtype&&(D<0||D>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${D}.`);1===de?(fn[0]=D*Te,fn[1]=D*Te,fn[2]=D*Te):fn[E]=D*Te}const f=4*Pe;xe[f+0]=Math.round(fn[0]),xe[f+1]=Math.round(fn[1]),xe[f+2]=Math.round(fn[2]),xe[f+3]=Math.round(fn[3])}if(null!=ct){tt||null!=(0,z.pI)(_e.hGc,Z.BV.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),tt=!0),ct.width=Kt,ct.height=Nt;const Pe=ct.getContext("2d"),fn=new ImageData(xe,Kt,Nt);Pe.putImageData(fn,0,0)}return _t!==gt&&_t.dispose(),xe})).apply(this,arguments)}function vr(gt,ct,_t){let Nt=(0,br._1)(gt,"img","draw");if(!(gt instanceof dr.es)){const Ee=Nt;Nt=(0,mn.p)(Ee,"int32"),Ee.dispose()}$e(Nt),function Cn(gt){const ct=gt?.alpha||1;if(ct>1||ct<0)throw new Error(`Alpha value ${ct} is suppoed to be in range [0 - 1].`)}(_t?.imageOptions),Z.BV.runKernel(_e.hGc,{image:Nt},{canvas:ct,options:_t})}const wn=(0,os.op)({fromPixels_:wt});function _r(gt,ct){const _t=gt.shape.length,Nt=ct.shape.length;if(_t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${_t}.`);if(Nt<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${Nt}.`);if("int32"!==ct.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${ct.dtype}.`);if(ct.shape[Nt-1]>_t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${ct.shape[Nt-1]} vs. ${_t}`);if(0===(0,jt.NA)(gt.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${gt.shape}.`);const Kt=ct.shape,de=Kt[Kt.length-1];let Ee=1;for(let f=0;f<Kt.length-1;++f)Ee*=Kt[f];const Te=gt.shape,xe=Kt.slice();xe.pop();let Pe=1;for(let f=de;f<_t;++f)Pe*=Te[f],xe.push(Te[f]);const fn=[...(0,jt.e3)(gt.shape).map(f=>f/Pe),1].slice(0,de);return[xe,Ee,Pe,fn]}var ni=y(1876),Zs=y(2320),Xr=y(7664),tn=y(1153);const Su=.001,xr=.1;function qi(gt,ct,_t){return null==_t&&(_t=fo()),vs(gt,ct,(Nt,Kt)=>Zr(Nt,Kt,_t))}function fo(){return 32===Z.BV.backend.floatPrecision()?Su:xr}function vs(gt,ct,_t){let Nt=!0;if(((0,tn.isTypedArray)(gt)||(0,tn.isTypedArray)(ct))&&(Nt=!1),(0,tn.isTypedArray)(gt)&&(0,tn.isTypedArray)(ct)&&(Nt=!0),Nt){const Ee=gt.constructor.name,Te=ct.constructor.name;if(Ee!==Te)throw new Error(`Arrays are of different type. Actual: ${Ee}. Expected: ${Te}`)}if(Array.isArray(gt)&&Array.isArray(ct)){const Ee=(0,br.C)(gt),Te=(0,br.C)(ct);if(!(0,jt.cO)(Ee,Te))throw new Error(`Arrays have different shapes. Actual: [${Ee}]. Expected: [${Te}]`)}const Kt=(0,tn.isTypedArray)(gt)?gt:(0,tn.flatten)(gt),de=(0,tn.isTypedArray)(ct)?ct:(0,tn.flatten)(ct);if(Kt.length!==de.length)throw new Error(`Arrays have different lengths actual: ${Kt.length} vs expected: ${de.length}.\nActual:   ${Kt}.\nExpected: ${de}.`);for(let Ee=0;Ee<de.length;++Ee){const Te=Kt[Ee],xe=de[Ee];if(!_t(Te,xe))throw new Error(`Arrays differ: actual[${Ee}] = ${Te}, expected[${Ee}] = ${xe}.\nActual:   ${Kt}.\nExpected: ${de}.`)}typeof expect<"u"&&expect().nothing()}function ku(gt,ct){gt().then(()=>ct.fail(),()=>ct()),typeof expect<"u"&&expect().nothing()}function Rc(gt,ct){const _t="string"==typeof ct||"number"==typeof ct||"boolean"==typeof ct?[ct]:ct;return(0,jt.HD)(gt)||(0,jt.HD)(gt[0])||(0,jt.HD)(ct)||(0,jt.HD)(ct[0])?vs(gt,_t,(Nt,Kt)=>Nt==Kt):vs(gt,ct,(Nt,Kt)=>Zr(Nt,Kt,0))}function us(gt,ct,_t){if(null==_t&&(_t=fo()),!Zr(gt,ct,_t))throw new Error(`Numbers differ: actual === ${gt}, expected === ${ct}`);typeof expect<"u"&&expect().nothing()}function Zr(gt,ct,_t){return!isFinite(gt)&&!isFinite(ct)||!(isNaN(gt)||isNaN(ct)||Math.abs(gt-ct)>_t)}function nu(gt,ct,_t){for(let Nt=0;Nt<gt.length;Nt++)if(gt[Nt]<ct||gt[Nt]>_t)throw new Error(`Value out of range:${gt[Nt]} low: ${ct}, high: ${_t}`)}function In(gt,ct){const _t=new Float32Array(gt),Nt=new Float32Array(ct);if(_t.length!==Nt.length)throw new Error(`Expected ArrayBuffer to be of length ${Nt.length}, but it was ${_t.length}`);for(let Kt=0;Kt<Nt.length;Kt++)if(_t[Kt]!==Nt[Kt])throw new Error(`Expected ArrayBuffer value at ${Kt} to be ${Nt[Kt]} but got ${_t[Kt]} instead`)}function pu(gt){for(let ct=0;ct<gt.length;ct++){const _t=gt[ct];Array.isArray(_t)?pu(_t):gt[ct]=(0,tn.encodeString)(_t)}return gt}function Bo(gt){const ct=document.createElement("video");return"playsInline"in ct&&(ct.playsInline=!0),ct.muted=!0,ct.loop=!0,ct.style.position="fixed",ct.style.left="0px",ct.style.top="0px",ct.preload="auto",ct.appendChild(gt),new Promise(_t=>{ct.addEventListener("loadeddata",Nt=>_t(ct)),ct.load()})}function Hl(gt){return Ir.apply(this,arguments)}function Ir(){return(Ir=(0,lt.Z)(function*(gt){yield gt.play(),"requestVideoFrameCallback"in gt&&(yield new Promise(ct=>{gt.requestVideoFrameCallback(ct)}))})).apply(this,arguments)}const mu="4.17.0";class Gr{static sgd(ct){return new eo(ct)}static momentum(ct,_t,Nt=!1){return new wo(ct,_t,Nt)}static rmsprop(ct,_t=.9,Nt=0,Kt=null,de=!1){return new ys(ct,_t,Nt,Kt,de)}static adam(ct=.001,_t=.9,Nt=.999,Kt=null){return new Ls(ct,_t,Nt,Kt)}static adadelta(ct=.001,_t=.95,Nt=null){return new Ks(ct,_t,Nt)}static adamax(ct=.002,_t=.9,Nt=.999,Kt=null,de=0){return new Oa(ct,_t,Nt,Kt,de)}static adagrad(ct,_t=.1){return new ti(ct,_t)}}var qu=y(1216),he=y(3667),zo=y(4839);const jl=Gr,Fu=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:gt=>gt();function Br(){return new Promise(gt=>Fu(()=>gt()))}var es=y(929);function ru(gt,ct){const _t=gt[0].length;gt.forEach((Kt,de)=>{jt.hu(Kt.length===_t,()=>`Error in concat${_t}D: rank of tensors[${de}] must be the same as the rank of the rest (${_t})`)}),jt.hu(ct>=0&&ct<_t,()=>`Error in concat${_t}D: axis must be between 0 and ${_t-1}.`);const Nt=gt[0];gt.forEach((Kt,de)=>{for(let Ee=0;Ee<_t;Ee++)jt.hu(Ee===ct||Kt[Ee]===Nt[Ee],()=>`Error in concat${_t}D: Shape of tensors[${de}] (${Kt}) does not match the shape of the rest (${Nt}) along the non-concatenated axis ${de}.`)})}function iu(gt,ct){const _t=gt[0].slice();for(let Nt=1;Nt<gt.length;Nt++)_t[ct]+=gt[Nt][ct];return _t}var ls=y(5551),Fs=y(6254),va=function(gt){return gt[gt.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",gt[gt.VALUE_ROWIDS=1]="VALUE_ROWIDS",gt[gt.ROW_LENGTHS=2]="ROW_LENGTHS",gt[gt.ROW_SPLITS=3]="ROW_SPLITS",gt[gt.ROW_LIMITS=4]="ROW_LIMITS",gt[gt.ROW_STARTS=5]="ROW_STARTS",gt}(va||{});function Vo(gt,ct,_t){let Nt=new Array;if(null==_t&&null==ct)return Nt;if(null==ct)for(;Nt.length<gt+_t.length;)Nt.push(-1);else Nt=ct.slice();if(null==_t)return Nt;if(gt+_t.length!==Nt.length)throw new Error(`rt input.shape and shape=${ct} are incompatible: rt input.rank = ${gt+_t.length}, but shape.rank = ${Nt.length}`);for(let Kt=1;Kt<_t.length;++Kt){const de=_t[Kt],Ee=Nt[Nt.length-_t.length+Kt],Te=Nt[Ee];if(de>=0)if(Te>=0){if(Te!==de)throw new Error(`rt input.shape and shape=${ct} are incompatible: rt input.shape[${Kt+gt}] = ${de} but shape[${Kt+gt}] = ${Te}`)}else Nt[Ee]=de}return Nt}function _a(gt){const ct={FIRST_DIM_SIZE:va.FIRST_DIM_SIZE,VALUE_ROWIDS:va.VALUE_ROWIDS,ROW_LENGTHS:va.ROW_LENGTHS,ROW_SPLITS:va.ROW_SPLITS,ROW_LIMITS:va.ROW_LIMITS,ROW_STARTS:va.ROW_STARTS},_t=[];for(const Nt of gt){if(!(Nt in ct))break;_t.push(ct[Nt])}return _t}function po(gt){return 0===gt.length?0:gt[0]===va.FIRST_DIM_SIZE?gt.length-1:gt.length}function Jo(gt,ct){if(null==gt||null==ct)return;const _t=gt.length,Nt=ct.length;if(_t>=Nt)throw new Error(`defaultValue.shape=${gt} and ragged tensor flatValues.shape=${ct}, are incompatible: defaultValue.rank = ${_t} must be less than ragged tensor input flatValues.rank = ${Nt})`);for(let Kt=0;Kt<Math.min(_t,Nt-1);++Kt){const de=gt[Kt],Ee=ct[Kt+1];if(de>=0&&Ee>=0&&1!==de&&de!==Ee)throw new Error(`defaultValue.shape=${gt}, and ragged tensor input flatValues.shape=${ct} are incompatible: defaultValue.shape[${Kt-gt.length}] = ${de} but ragged tensor input.flatValues.shape[${Kt-gt.length}] = ${Ee}`)}}const Wn=30;function Mo(gt){return gt<=Wn?gt:(0,jt.jP)(gt,Math.floor(Math.sqrt(gt)))}function Mn(gt,ct,_t){return[_t*("number"==typeof gt?gt:gt[0]),ct*("number"==typeof gt?gt:gt[1])]}function la(gt,ct,_t,Nt=!0){let Kt=[];if(Nt)Kt=Kt.concat(ct.slice(0)),Kt.push(gt[0]/_t),Kt=Kt.concat(gt.slice(1));else{Kt=Kt.concat(gt[0]);const de=ct.length;for(let Ee=0;Ee<de;++Ee)Kt=Kt.concat([gt[Ee+1]/ct[Ee],ct[Ee]]);Kt=Kt.concat(gt.slice(de+1))}return Kt}function xa(gt,ct,_t=!0){const Nt=[];if(_t){Nt.push(ct);for(let Kt=ct+1;Kt<gt;++Kt)Kt<=2*ct?(Nt.push(Kt),Nt.push(Kt-(ct+1))):Nt.push(Kt)}else{const Kt=[],de=[];for(let Ee=1;Ee<gt;++Ee)Ee>=2*ct+1||Ee%2==1?de.push(Ee):Kt.push(Ee);Nt.push(...Kt),Nt.push(0),Nt.push(...de)}return Nt}function cs(gt,ct,_t,Nt=!0){const Kt=[];Kt.push(Nt?gt[0]/_t:gt[0]*_t);for(let de=1;de<gt.length;++de)Kt.push(de<=ct.length?Nt?ct[de-1]*gt[de]:gt[de]/ct[de-1]:gt[de]);return Kt}function mo(gt,ct){const _t=[0];for(let Nt=0;Nt<ct;++Nt)_t.push(gt[Nt][0]);return _t}function su(gt,ct,_t){const Nt=gt.slice(0,1);for(let Kt=0;Kt<_t;++Kt)Nt.push(gt[Kt+1]-ct[Kt][0]-ct[Kt][1]);return Nt}var Ys=y(2152);const $s=.3275911,Uo=.254829592,Ea=-.284496736,mi=1.421413741,yi=-1.453152027,ka=1.061405429;var Du=y(2932);function Ha(gt,ct){if(gt.length!==ct.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${gt.length}, imag: ${ct.length}.`);const _t=new Float32Array(2*gt.length);for(let Nt=0;Nt<_t.length;Nt+=2)_t[Nt]=gt[Nt/2],_t[Nt+1]=ct[Nt/2];return _t}function pl(gt){const ct=new Float32Array(gt.length/2),_t=new Float32Array(gt.length/2);for(let Nt=0;Nt<gt.length;Nt+=2)ct[Nt/2]=gt[Nt],_t[Nt/2]=gt[Nt+1];return{real:ct,imag:_t}}function ta(gt){const ct=Math.ceil(gt.length/4),_t=new Float32Array(ct),Nt=new Float32Array(ct);for(let Kt=0;Kt<gt.length;Kt+=4)_t[Math.floor(Kt/4)]=gt[Kt],Nt[Math.floor(Kt/4)]=gt[Kt+1];return{real:_t,imag:Nt}}function Wo(gt){const ct=Math.floor(gt.length/4),_t=new Float32Array(ct),Nt=new Float32Array(ct);for(let Kt=2;Kt<gt.length;Kt+=4)_t[Math.floor(Kt/4)]=gt[Kt],Nt[Math.floor(Kt/4)]=gt[Kt+1];return{real:_t,imag:Nt}}function Ns(gt,ct){return{real:gt[2*ct],imag:gt[2*ct+1]}}function Tu(gt,ct,_t,Nt){gt[2*Nt]=ct,gt[2*Nt+1]=_t}function Bs(gt,ct){const _t=new Float32Array(gt/2),Nt=new Float32Array(gt/2);for(let Kt=0;Kt<Math.ceil(gt/2);Kt++){const de=(ct?2:-2)*Math.PI*(Kt/gt);_t[Kt]=Math.cos(de),Nt[Kt]=Math.sin(de)}return{real:_t,imag:Nt}}function Go(gt,ct,_t){const Nt=(_t?2:-2)*Math.PI*(gt/ct);return{real:Math.cos(Nt),imag:Math.sin(Nt)}}const Ca="->",Nu=/->/g,gu=",",ja="...";function wa(gt,ct){const _t=((gt=gt.replace(/\s/g,"")).length-gt.replace(Nu,"").length)/Ca.length;if(_t<1)throw new Error("Equations without an arrow are not supported.");if(_t>1)throw new Error(`Equation must contain exactly one arrow ("${Ca}").`);const[Nt,Kt]=gt.split(Ca);(0,jt.hu)(-1===Nt.indexOf(ja),()=>`The ellipsis notation ("${ja}") is not supported yet.`);const de=Nt.split(gu),Ee=de.length;if(ct!==Ee)throw new Error(`Expected ${Ee} input tensors, received ${ct}`);if(Ee>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const Te=[];for(let E=0;E<Kt.length;++E){const D=Kt[E];if(!de.some(j=>-1!==j.indexOf(D)))throw new Error(`Output subscripts contain the label ${D} not present in the input subscripts.`);-1===Te.indexOf(D)&&Te.push(D)}for(let E=0;E<Nt.length;++E){const D=Nt[E];-1===Te.indexOf(D)&&D!==gu&&Te.push(D)}const xe=new Array(de.length);for(let E=0;E<Ee;++E){if(new Set(de[E].split("")).size!==de[E].length)throw new Error(`Found duplicate axes in input component ${de[E]}. Support for duplicate axes in input is not implemented yet.`);xe[E]=[];for(let D=0;D<de[E].length;++D)xe[E].push(Te.indexOf(de[E][D]))}const Pe=Te.length,f=[];for(let E=Kt.length;E<Pe;++E)f.push(E);return{allDims:Te,summedDims:f,idDims:xe}}function qs(gt,ct){let _t=new Array(gt);_t.fill(-1);for(let Kt=0;Kt<ct.length;++Kt)_t[ct[Kt]]=Kt;const Nt=[];for(let Kt=0;Kt<gt;++Kt)-1===_t[Kt]&&Nt.push(Kt);return _t=_t.filter(Kt=>-1!==Kt),{permutationIndices:_t,expandDims:Nt}}function ea(gt,ct,_t){const Nt=new Array(gt);for(let Kt=0;Kt<_t.length;++Kt){const de=_t[Kt].shape;for(let Ee=0;Ee<ct[Kt].length;++Ee)void 0===Nt[ct[Kt][Ee]]?Nt[ct[Kt][Ee]]=de[Ee]:(0,jt.hu)(Nt[ct[Kt][Ee]]===de[Ee],()=>`Expected dimension ${Nt[ct[Kt][Ee]]} at axis ${Ee} of input shaped ${JSON.stringify(de)}, but got dimension ${de[Ee]}`)}}function go(gt,ct){const _t=gt,Nt=[];let Kt=0;0===gt.length&&_t.push(-1),Kt=gt.length+1;for(let Ee=0;Ee<Kt;++Ee)Nt.push([]);const de=[];for(let Ee=0;Ee<_t.length;++Ee){const xe=yu(ct,_t[Ee]);for(const Pe of xe)-1===de.indexOf(Pe)&&(Nt[Ee].push(Pe),de.push(Pe))}return{path:_t,steps:Nt}}function Fa(gt){return gt.every((ct,_t)=>ct===_t)}function yu(gt,ct){const _t=[];for(let Nt=0;Nt<gt.length;++Nt)(0===gt[Nt].length||-1!==gt[Nt].indexOf(ct)||-1===ct)&&_t.push(Nt);return _t}function So(gt,ct,_t=0){let Nt=[];if("number"==typeof ct)(0,jt.hu)(gt.shape[_t]%ct==0,()=>"Number of splits must evenly divide the axis."),Nt=new Array(ct).fill(gt.shape[_t]/ct);else{const Kt=ct.reduce((Ee,Te)=>(-1===Te&&(Ee+=1),Ee),0);(0,jt.hu)(Kt<=1,()=>"There should be only one negative value in split array.");const de=ct.indexOf(-1);if(-1!==de){const Ee=ct.reduce((Te,xe)=>xe>0?Te+xe:Te);ct[de]=gt.shape[_t]-Ee}(0,jt.hu)(gt.shape[_t]===ct.reduce((Ee,Te)=>Ee+Te),()=>"The sum of sizes must match the size of the axis dimension."),Nt=ct}return Nt}function hs(gt){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${gt}`}function Do(gt,ct){return`indices(${gt}, 0) is invalid: ${ct} < 0`}function ca(gt,ct,_t){return`indices(${gt}, 0) is invalid: ${ct} >= ${_t}`}function ns(gt,ct){return`only one output dimension may be -1, not both ${gt} and ${ct}`}function Il(gt,ct){return`size ${gt} must be non-negative, not ${ct}`}function Au(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Ho(gt,ct){return`Input to reshape is a SparseTensor with ${(0,jt.NA)(gt)}\n  dense values, but the requested shape requires a multiple of ${(0,jt.NA)(ct)}. inputShape=${gt} outputShape= ${ct}`}function ds(gt,ct){return`Input to reshape is a tensor with ${(0,jt.NA)(gt)} dense values, but the requested shape has ${(0,jt.NA)(ct)}. inputShape=${gt} outputShape=${ct}`}function ha(){return"segment ids must be >= 0"}function no(){return"segment ids are not increasing"}function Kl(gt,ct){return`Segment id ${gt} out of range [0, ${ct}), possibly because segmentIds input is not sorted.`}function Ka(gt,ct,_t){return`Bad: indices[${gt}] == ${ct} out of range [0, ${_t})`}function Yr(gt,ct){let Nt,_t=!1;for(gt<=Wn?(Nt=gt,_t=!0):Nt=(0,jt.jP)(gt,Math.floor(Math.sqrt(gt)));!_t;)Nt>ct||Nt===gt?_t=!0:Nt=(0,jt.jP)(gt,Nt+1);return Nt}function da(gt,ct,_t){const Nt=[],Kt=gt.length;for(let de=0;de<Kt;de++)Nt.push(de!==ct?gt[de]:_t);return Nt}function vu(gt,ct,_t,Nt){const Kt=ct.shape.length,de=gt.shape.length;if(0!==Nt&&(Nt<-Kt||Nt>Kt))throw new Error(`Expect batchDims in the range of [-${Kt}, ${Kt}], but got ${Nt}`);if(Nt<0&&(Nt+=Kt),Nt>de)throw new Error(`batchDims (${Nt}) must be less than rank(x) (\n    ${de}).`);if(_t<Nt)throw new Error(`batchDims (${Nt}) must be less than or equal to axis (${_t}).`);for(let f=0;f<Nt;++f)if(gt.shape[f]!==ct.shape[f])throw new Error(`x.shape[${f}]: ${gt.shape[f]} should be equal to indices.shape[${f}]: ${ct.shape[f]}.`);const Ee=gt.shape[_t],Te=[];let xe=1,Pe=1,fn=1;for(let f=0;f<Nt;++f)Te.push(gt.shape[f]),xe*=gt.shape[f];for(let f=Nt;f<_t;f++)Te.push(gt.shape[f]),Pe*=gt.shape[f];for(let f=Nt;f<Kt;f++)Te.push(ct.shape[f]);for(let f=_t+1;f<de;f++)Te.push(gt.shape[f]),fn*=gt.shape[f];return{batchSize:xe,sliceSize:fn,outerSize:Pe,dimSize:Ee,outputShape:Te}}function or(gt){try{return gt.map(ct=>(0,tn.decodeString)(ct))}catch(ct){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${ct}`)}}function ws(gt){return gt.map(ct=>(0,tn.encodeString)(ct))}var Tr=y(5672),ri=y(7349),fs=y(7173);!function bu(){for(const gt of Wa)js(gt)}()},7864:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>V});var $=y(1153);class V{static join(Y){return new V(Y).slice()}constructor(Y){if(this.shards=[],this.previousShardIndex=0,null==Y||(Y instanceof Array||(Y=[Y]),0===(Y=Y.map(W=>$.isTypedArray(W)?W.buffer:W)).length))return;this.bufferUniformSize=Y[0].byteLength;let R=0;for(let W=0;W<Y.length;W++){const k=Y[W];W!==Y.length-1&&k.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const A=R+k.byteLength;this.shards.push({buffer:k,start:R,end:A}),R=A}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(Y=0,R=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(Y=isNaN(Number(Y))?0:Y,R=isNaN(Number(R))?0:R,Y=Math.max(0,Y),(R=Math.min(this.byteLength,R))<=Y)return new ArrayBuffer(0);const W=this.findShardForByte(Y);if(-1===W)throw new Error(`Could not find start shard for byte ${Y}`);const A=new ArrayBuffer(R-Y),X=new Uint8Array(A);let Z=0;for(let G=W;G<this.shards.length;G++){const it=this.shards[G],K=Y+Z-it.start,st=Z,dt=Math.min(R,it.end)-it.start,lt=new Uint8Array(it.buffer,K,dt-K);if(X.set(lt,st),Z+=lt.length,R<it.end)break}return A}findShardForByte(Y){if(0===this.shards.length||Y<0||Y>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(Y/this.bufferUniformSize),this.previousShardIndex;function R(k){return Y<k.start?-1:Y>=k.end?1:0}if(0===R(this.shards[this.previousShardIndex]))return this.previousShardIndex;const W=function H(q,Y){let R=0,W=q.length;for(;R<=W;){const k=Math.floor((W-R)/2)+R,A=Y(q[k]);if(0===A)return k;A<0?W=k:R=k+1}return-1}(this.shards,R);return-1===W?-1:(this.previousShardIndex=W,this.previousShardIndex)}}},8339:(Lt,ut,y)=>{"use strict";y.d(ut,{EZ:()=>at,JY:()=>P,Q:()=>yt,Yd:()=>nt,_n:()=>B,dI:()=>G,hu:()=>vt,jN:()=>O,ji:()=>Gt,n7:()=>ot,r:()=>lt,yz:()=>X});var $=y(5861),V=y(3037),H=y(3905),q=y(5359),Y=y(1352),R=y(7864),W=y(2773),k=y(5527);const A=4;function X(Bt,ee){return Z.apply(this,arguments)}function Z(){return Z=(0,$.Z)(function*(Bt,ee){const jt=[],se=[],be=Array.isArray(Bt)?Bt.map(Xe=>Xe.name):Object.keys(Bt);for(let Xe=0;Xe<be.length;++Xe){const Ue=be[Xe],De=Array.isArray(Bt)?Bt[Xe].tensor:Bt[Ue];if("float32"!==De.dtype&&"int32"!==De.dtype&&"bool"!==De.dtype&&"string"!==De.dtype&&"complex64"!==De.dtype)throw new Error(`Unsupported dtype in weight '${Ue}': ${De.dtype}`);const Tn={name:Ue,shape:De.shape,dtype:De.dtype};if("string"===De.dtype){const On=new Promise(function(){var ne=(0,$.Z)(function*(pe){const Ie=yield De.bytes(),Je=Ie.reduce((Nn,Yn)=>Nn+Yn.length,0)+A*Ie.length,Gn=new Uint8Array(Je);let Er=0;for(let Nn=0;Nn<Ie.length;Nn++){const Yn=Ie[Nn],hi=new Uint8Array(new Uint32Array([Yn.length]).buffer);Gn.set(hi,Er),Er+=A,Gn.set(Yn,Er),Er+=Yn.length}pe(Gn)});return function(pe){return ne.apply(this,arguments)}}());se.push(On)}else se.push(De.data());null!=ee&&(Tn.group=ee),jt.push(Tn)}return{data:Q(yield Promise.all(se)),specs:jt}}),Z.apply(this,arguments)}function G(Bt,ee){const jt=new R.w(Bt),se={};let be=0;for(const Me of ee){const Xe=it(Me,(Ue,De)=>jt.slice(be+Ue,be+De));se[Me.name]=st(Me,jt.slice(be,be+Xe)),be+=Xe}return se}function it(Bt,ee){const jt=(0,q.NA)(Bt.shape);let se;if("quantization"in Bt)se=Y.J[Bt.quantization.dtype];else{if("string"===Bt.dtype){let be=0;for(let Me=0;Me<jt;Me++)be+=A+new Uint32Array(ee(be,be+A))[0];return be}se=Y.J[Bt.dtype]}return jt*se}function bt(Bt,ee){return K.apply(this,arguments)}function K(){return(K=(0,$.Z)(function*(Bt,ee){const jt=(0,q.NA)(Bt.shape);let se;if("quantization"in Bt)se=Y.J[Bt.quantization.dtype];else{if("string"===Bt.dtype){let be=0;for(let Me=0;Me<jt;Me++)be+=A+new Uint32Array(yield ee(be,be+A))[0];return be}se=Y.J[Bt.dtype]}return jt*se})).apply(this,arguments)}function st(Bt,ee){const jt=Bt.name,se=Bt.dtype,be=Bt.shape,Me=(0,q.NA)(be);let Xe,Ue=0;if("quantization"in Bt){const De=Bt.quantization;if("uint8"===De.dtype||"uint16"===De.dtype){if(!("min"in De)||!("scale"in De))throw new Error(`Weight ${Bt.name} with quantization ${De.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==De.dtype)throw new Error(`Weight ${Bt.name} has unknown quantization dtype ${De.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==se)throw new Error(`Weight ${Bt.name} is quantized with ${De.dtype} which only supports weights of type float32 not ${se}.`)}const Tn=Y.J[De.dtype],On="uint8"===De.dtype?new Uint8Array(ee):new Uint16Array(ee);if("float32"===se)if("uint8"===De.dtype||"uint16"===De.dtype){Xe=new Float32Array(On.length);for(let ne=0;ne<On.length;ne++)Xe[ne]=On[ne]*De.scale+De.min}else{if("float16"!==De.dtype)throw new Error(`Unsupported quantization type ${De.dtype} for weight type float32.`);Xe=function re(){const Bt=function xt(){const Bt=jt=>{let se=jt<<13,be=0;for(;!(8388608&se);)be-=8388608,se<<=1;return se&=-8388609,be+=947912704,se|be},ee=new Uint32Array(2048);ee[0]=0;for(let jt=1;jt<1024;jt++)ee[jt]=Bt(jt);for(let jt=1024;jt<2048;jt++)ee[jt]=939524096+(jt-1024<<13);return ee}(),ee=function Mt(){const Bt=new Uint32Array(64);Bt[0]=0,Bt[31]=1199570944,Bt[32]=2147483648,Bt[63]=3347054592;for(let ee=1;ee<31;ee++)Bt[ee]=ee<<23;for(let ee=33;ee<63;ee++)Bt[ee]=2147483648+(ee-32<<23);return Bt}(),jt=function It(){const Bt=new Uint32Array(64);for(let ee=0;ee<64;ee++)Bt[ee]=1024;return Bt[0]=Bt[32]=0,Bt}();return se=>{const be=new ArrayBuffer(4*se.length),Me=new Uint32Array(be);for(let Xe=0;Xe<se.length;Xe++){const Ue=se[Xe];Me[Xe]=Bt[jt[Ue>>10]+(1023&Ue)]+ee[Ue>>10]}return new Float32Array(be)}}()(On)}else{if("int32"!==se)throw new Error(`Unsupported dtype in weight '${jt}': ${se}`);if("uint8"!==De.dtype&&"uint16"!==De.dtype)throw new Error(`Unsupported quantization type ${De.dtype} for weight type int32.`);Xe=new Int32Array(On.length);for(let ne=0;ne<On.length;ne++)Xe[ne]=Math.round(On[ne]*De.scale+De.min)}Ue+=Me*Tn}else if("string"===se){const De=(0,q.NA)(Bt.shape);Xe=[];for(let Tn=0;Tn<De;Tn++){const On=new Uint32Array(ee.slice(Ue,Ue+A))[0];Ue+=A;const ne=new Uint8Array(ee.slice(Ue,Ue+On));Xe.push(ne),Ue+=On}}else{const De=Y.J[se];if("float32"===se)Xe=new Float32Array(ee);else if("int32"===se)Xe=new Int32Array(ee);else{if("bool"!==se){if("complex64"===se){Xe=new Float32Array(ee);const Tn=new Float32Array(Xe.length/2),On=new Float32Array(Xe.length/2);for(let Je=0;Je<Tn.length;Je++)Tn[Je]=Xe[2*Je],On[Je]=Xe[2*Je+1];const ne=(0,H.X)(Tn,be,"float32"),pe=(0,H.X)(On,be,"float32"),Ie=(0,V.P)(ne,pe);return ne.dispose(),pe.dispose(),Ie}throw new Error(`Unsupported dtype in weight '${jt}': ${se}`)}Xe=new Uint8Array(ee)}Ue+=Me*De}return(0,H.X)(Xe,be,se)}function et(Bt,ee,jt){return dt.apply(this,arguments)}function dt(){return(dt=(0,$.Z)(function*(Bt,ee,jt){let se=new Uint8Array(ee);for(;se.byteLength<jt;){const{done:be,value:Me}=yield Bt.read();if(be&&null==Me)throw new Error(`Reader is done but ${jt-se.byteLength} bytes are still expected`);const Xe=new Uint8Array(se.length+Me.byteLength);Xe.set(se,0),Xe.set(new Uint8Array(Me),se.length),se=Xe}return se.buffer})).apply(this,arguments)}function lt(Bt,ee){return St.apply(this,arguments)}function St(){return St=(0,$.Z)(function*(Bt,ee){const jt={},se=Bt.getReader();let be=new ArrayBuffer(0);for(const Me of ee){const Xe=yield bt(Me,function(){var Tn=(0,$.Z)(function*(On,ne){return be=yield et(se,be,ne),be.slice(On,ne)});return function(On,ne){return Tn.apply(this,arguments)}}());be=yield et(se,be,Xe);const Ue=be.slice(0,Xe);be=be.slice(Xe);const De=st(Me,Ue);if(jt[Me.name]=De,"webgpu"===(0,W.N_)()){const Tn=(0,W.y3)();"uploadToGPU"in Tn&&(0,q.NA)(De.shape)>=(0,k.OB)().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&Tn.uploadToGPU(De.dataId)}}return jt}),St.apply(this,arguments)}function Q(Bt){if(null===Bt)throw new Error(`Invalid input value: ${JSON.stringify(Bt)}`);let ee=0;const jt=[];Bt.forEach(Me=>{if(ee+=Me.byteLength,jt.push(Me.byteLength===Me.buffer.byteLength?Me:new Me.constructor(Me)),!(Me instanceof Float32Array||Me instanceof Int32Array||Me instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${Me.constructor.name}`)});const se=new Uint8Array(ee);let be=0;return jt.forEach(Me=>{se.set(new Uint8Array(Me.buffer),be),be+=Me.byteLength}),se.buffer}const ft=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function pt(Bt){return ft?Buffer.byteLength(Bt,"utf8"):new Blob([Bt]).size}function B(Bt){if(ft)return Buffer.from(Bt).toString("base64");const ee=new Uint8Array(Bt);let jt="";for(let se=0,be=ee.length;se<be;se++)jt+=String.fromCharCode(ee[se]);return btoa(jt)}function ot(Bt){if(ft){const se=Buffer.from(Bt,"base64");return se.buffer.slice(se.byteOffset,se.byteOffset+se.byteLength)}const ee=atob(Bt),jt=new Uint8Array(ee.length);for(let se=0;se<ee.length;++se)jt.set([ee.charCodeAt(se)],se);return jt.buffer}function P(Bt){return R.w.join(Bt)}function at(Bt){for(Bt=Bt.trim();Bt.endsWith("/");)Bt=Bt.slice(0,Bt.length-1);const jt=Bt.split("/");return jt[jt.length-1]}function nt(Bt,ee){const jt={modelTopology:Bt.modelTopology,format:Bt.format,generatedBy:Bt.generatedBy,convertedBy:Bt.convertedBy,weightsManifest:ee};return null!=Bt.signature&&(jt.signature=Bt.signature),null!=Bt.userDefinedMetadata&&(jt.userDefinedMetadata=Bt.userDefinedMetadata),null!=Bt.modelInitializer&&(jt.modelInitializer=Bt.modelInitializer),null!=Bt.initializerSignature&&(jt.initializerSignature=Bt.initializerSignature),null!=Bt.trainingConfig&&(jt.trainingConfig=Bt.trainingConfig),jt}function Gt(Bt,ee,jt){const se={modelTopology:Bt.modelTopology,format:Bt.format,generatedBy:Bt.generatedBy,convertedBy:Bt.convertedBy};if(null!=Bt.trainingConfig&&(se.trainingConfig=Bt.trainingConfig),null!=Bt.weightsManifest){if(!ee)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!jt)throw new Error("modelJSON has weightsManifest but weightData is null");se.weightSpecs=ee,se.weightData=jt}return null!=Bt.signature&&(se.signature=Bt.signature),null!=Bt.userDefinedMetadata&&(se.userDefinedMetadata=Bt.userDefinedMetadata),null!=Bt.modelInitializer&&(se.modelInitializer=Bt.modelInitializer),null!=Bt.initializerSignature&&(se.initializerSignature=Bt.initializerSignature),se}function O(Bt,ee){return Ct.apply(this,arguments)}function Ct(){return(Ct=(0,$.Z)(function*(Bt,ee){let jt,se;return null!=Bt.weightsManifest&&([jt,se]=yield ee(Bt.weightsManifest)),Gt(Bt,jt,se)})).apply(this,arguments)}function yt(Bt){if(Bt.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==Bt.modelTopology?0:pt(JSON.stringify(Bt.modelTopology)),weightSpecsBytes:null==Bt.weightSpecs?0:pt(JSON.stringify(Bt.weightSpecs)),weightDataBytes:null==Bt.weightData?0:new R.w(Bt.weightData).byteLength}}function vt(Bt){const ee=[];for(const jt of Bt)ee.push(...jt.weights);return ee}},1352:(Lt,ut,y)=>{"use strict";y.d(ut,{J:()=>$});const $={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},4251:(Lt,ut,y)=>{"use strict";y.d(ut,{$HU:()=>ga,$g6:()=>Gn,$w:()=>Tn,Acj:()=>oe,BMI:()=>Zi,BiW:()=>An,Byc:()=>ee,CAk:()=>mn,CQl:()=>ss,D2d:()=>z,DlI:()=>Xs,Eh3:()=>O,FKq:()=>br,G3Y:()=>Vn,GBy:()=>Wr,Gcp:()=>Iu,HEU:()=>Nn,HZH:()=>bo,Hhh:()=>si,Hmb:()=>ya,IKK:()=>W,IMb:()=>dt,J$2:()=>ue,J7O:()=>Rr,J_u:()=>Oe,JhU:()=>K,Kgp:()=>$r,L8s:()=>os,Ly9:()=>pt,M2y:()=>X,MIZ:()=>Ye,MRv:()=>Pr,MZg:()=>sr,NEP:()=>di,NZg:()=>Co,O3z:()=>$o,OAf:()=>zr,OR:()=>Hn,OU7:()=>js,OV7:()=>oi,Omj:()=>Yn,Oyi:()=>it,PYm:()=>zn,PhF:()=>ks,QCc:()=>bt,QRR:()=>be,Qg5:()=>ze,QiL:()=>bu,Qvg:()=>_r,RFZ:()=>ot,ROF:()=>st,RQH:()=>Kr,RuY:()=>Zs,SIB:()=>Ds,SX0:()=>Er,SYM:()=>$,SbG:()=>Yi,SpW:()=>H,T0n:()=>Me,TQc:()=>Ts,TR1:()=>Bt,ToN:()=>wn,Tr8:()=>ae,Uyb:()=>Eo,VGw:()=>V,Vbg:()=>Vr,VcC:()=>se,VfG:()=>vn,Vn9:()=>pe,W0H:()=>wo,XDQ:()=>ni,XLW:()=>lt,XkS:()=>kt,Xze:()=>Y,Y0y:()=>ii,YFo:()=>to,YoZ:()=>er,ZbH:()=>tr,ZjV:()=>_e,Zz9:()=>nt,_JP:()=>At,_V0:()=>qi,_Yw:()=>Xn,_k9:()=>et,_tC:()=>I,a5O:()=>Kn,aJk:()=>A,avt:()=>je,b9H:()=>Su,bK0:()=>M,bV0:()=>ei,c17:()=>Ks,cWu:()=>Cn,cie:()=>Xe,cye:()=>eo,dDz:()=>Ga,deh:()=>Qo,dpD:()=>Yu,e07:()=>an,e0R:()=>tt,e6w:()=>jr,e7N:()=>un,eBW:()=>tn,eEB:()=>B,eZ0:()=>Dn,ekb:()=>ne,gJX:()=>P,h8e:()=>Xr,hCO:()=>ft,hGc:()=>Ie,hdR:()=>hi,i5y:()=>ai,iHb:()=>jt,iJz:()=>ie,iWB:()=>Xt,iZT:()=>te,ik2:()=>It,jMg:()=>G,jQk:()=>wt,jQs:()=>ti,jeX:()=>Hs,kU:()=>dr,kpP:()=>vr,kuV:()=>Pa,luS:()=>fo,lyA:()=>Ra,mKl:()=>La,mTV:()=>fi,mc4:()=>re,mhS:()=>Ct,mm_:()=>q,n9L:()=>$e,nhH:()=>Or,nr8:()=>Io,o0g:()=>fu,o2y:()=>Mt,oFR:()=>Ur,oHH:()=>Je,oT6:()=>R,p2w:()=>We,p4S:()=>On,pe_:()=>pr,q1x:()=>Rt,q2K:()=>Es,q8u:()=>Ss,qCd:()=>Qn,qIC:()=>wr,qWM:()=>ys,qi_:()=>Et,qkr:()=>nr,qw7:()=>Z,r7n:()=>En,s1s:()=>Yt,sEM:()=>nn,sHE:()=>Ce,sJF:()=>k,sL$:()=>Ue,usg:()=>xr,uv1:()=>Oa,vFR:()=>ho,vtC:()=>en,vwp:()=>yn,w3H:()=>as,w6g:()=>Jr,wUP:()=>yt,wYB:()=>mr,wYn:()=>Ls,we_:()=>Wa,wm:()=>vt,wx7:()=>$n,x12:()=>xt,xJR:()=>qn,xQA:()=>Fn,xnO:()=>at,y7R:()=>De,yQU:()=>rs,yj2:()=>Gt,zbQ:()=>Cs,zvY:()=>Q,zws:()=>St});const $="Abs",V="Acos",H="Acosh",q="Add",Y="AddN",R="All",W="Any",k="ArgMax",A="ArgMin",X="Asin",Z="Asinh",G="Atan",it="Atanh",bt="Atan2",K="AvgPool",st="AvgPoolGrad",et="AvgPool3D",dt="AvgPool3DGrad",lt="BatchMatMul",St="BatchToSpaceND",Q="Bincount",ft="BitwiseAnd",pt="BroadcastTo",B="BroadcastArgs",ot="Cast",P="Ceil",at="ClipByValue",nt="Complex",Gt="ComplexAbs",O="Concat",Ct="Conv2D",yt="Conv2DBackpropFilter",vt="Conv2DBackpropInput",xt="Conv3D",Mt="Conv3DBackpropFilterV2",It="Conv3DBackpropInputV2",re="Cos",Bt="Cosh",ee="Cumprod",jt="Cumsum",se="CropAndResize",be="DenseBincount",Me="DepthToSpace",Xe="DepthwiseConv2dNative",Ue="DepthwiseConv2dNativeBackpropFilter",De="DepthwiseConv2dNativeBackpropInput",Tn="Diag",On="Dilation2D",ne="Dilation2DBackpropInput",pe="Dilation2DBackpropFilter",Ie="Draw",Je="RealDiv",Gn="Einsum",Er="Elu",Nn="EluGrad",Yn="Erf",hi="Equal",di="Exp",to="ExpandDims",ii="Expm1",yn="FFT",Qo="Fill",Eo="FlipLeftRight",Hn="Floor",Hs="FloorDiv",Ce="FusedBatchNorm",Et="GatherV2",Rt="GatherNd",te="Greater",oe="GreaterEqual",ie="Identity",ze="IFFT",Oe="Imag",je="IsFinite",Xt="IsInf",En="IsNan",ue="LeakyRelu",en="Less",mn="LessEqual",un="LinSpace",tr="Log",dr="Log1p",zn="LogicalAnd",vn="LogicalNot",sr="LogicalOr",Jr="LogicalXor",Qn="LogSoftmax",wr="LowerBound",Dn="LRN",si="LRNGrad",Rr="MatrixBandPart",er="Max",Zi="Maximum",fi="MaxPool",oi="MaxPoolGrad",zr="MaxPool3D",js="MaxPool3DGrad",ho="MaxPoolWithArgmax",Es="Mean",Ks="Min",Ss="Minimum",ti="MirrorPad",Vr="Mod",Co="Multinomial",Ls="Multiply",Pa="Neg",rs="NotEqual",Oa="NonMaxSuppressionV3",eo="NonMaxSuppressionV4",wo="NonMaxSuppressionV5",ys="OnesLike",Wa="OneHot",bu="Pack",Ra="PadV2",$r="Pool",pr="Pow",fu="Prelu",Xs="Prod",Ga="RaggedGather",ss="RaggedRange",An="RaggedTensorToTensor",jr="Range",qn="Real",ga="Reciprocal",nr="Relu",bo="Reshape",Yu="ResizeNearestNeighbor",ya="ResizeNearestNeighborGrad",Xn="ResizeBilinear",Cs="ResizeBilinearGrad",Yi="Relu6",La="Reverse",an="Round",ei="Rsqrt",Fn="ScatterNd",Ds="TensorScatterUpdate",Io="SearchSorted",ks="Select",Ur="Selu",We="Slice",Kr="Sin",mr="Sinh",ai="Sign",Kn="Sigmoid",Pr="Softplus",br="Sqrt",Wr="Sum",Ts="SpaceToBatchND",os="SplitV",Iu="Softmax",$o="SparseFillEmptyRows",Or="SparseReshape",as="SparseSegmentMean",_e="SparseSegmentSum",z="SparseToDense",I="SquaredDifference",M="Square",tt="StaticRegexReplace",wt="StridedSlice",At="StringNGrams",Yt="StringSplit",kt="StringToHashBucketFast",ae="Sub",nn="Tan",Ye="Tanh",$e="Tile",Cn="TopK",$n="Transform",Vn="Transpose",vr="Unique",wn="Unpack",_r="UnsortedSegmentSum",ni="UpperBound",Zs="ZerosLike",Xr="Step",tn="FromPixels",Su="RotateWithOffset",xr="_FusedMatMul",qi="FusedConv2D",fo="FusedDepthwiseConv2D"},8987:(Lt,ut,y)=>{"use strict";y.d(ut,{Li:()=>X,T3:()=>it,bt:()=>G,nE:()=>Z,pI:()=>R,tr:()=>k,uk:()=>W,wC:()=>A});var $=y(5527),V=y(2918),H=y(2932);const q=(0,V.R)("kernelRegistry",()=>new Map),Y=(0,V.R)("gradRegistry",()=>new Map);function R(K,st){const et=bt(K,st);return q.get(et)}function W(K){return Y.get(K)}function k(K){const st=q.entries(),et=[];for(;;){const{done:dt,value:lt}=st.next();if(dt)break;const[St,Q]=lt,[ft]=St.split("_");ft===K&&et.push(Q)}return et}function A(K){const{kernelName:st,backendName:et}=K,dt=bt(st,et);q.has(dt)&&H.Z(`The kernel '${st}' for backend '${et}' is already registered`),q.set(dt,K)}function X(K){const{kernelName:st}=K;Y.has(st)&&(0,$.OB)().getBool("DEBUG")&&H.Z(`Overriding the gradient for '${st}'`),Y.set(st,K)}function Z(K,st){const et=bt(K,st);if(!q.has(et))throw new Error(`The kernel '${K}' for backend '${st}' is not registered`);q.delete(et)}function G(K){if(!Y.has(K))throw new Error(`The gradient '${K}' for backend is not registered`);Y.delete(K)}function it(K,st){k(K).forEach(dt=>{A(Object.assign({},dt,{backendName:st}))})}function bt(K,st){return`${st}_${K}`}},2932:(Lt,ut,y)=>{"use strict";y.d(ut,{Z:()=>V,c:()=>H});var $=y(5527);function V(...q){(0,$.OB)().getBool("IS_TEST")||(0,$.OB)().getBool("PROD")||console.warn(...q)}function H(...q){(0,$.OB)().getBool("IS_TEST")||(0,$.OB)().getBool("PROD")||console.log(...q)}},6989:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({abs_:function Y(W){const k=(0,H._1)(W,"x","abs");return $.BV.runKernel("complex64"===k.dtype?V.yj2:V.SYM,{x:k})}})},1184:(Lt,ut,y)=>{"use strict";y.d(ut,{K:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({acos_:function Y(W){const A={x:(0,H._1)(W,"x","acos")};return $.BV.runKernel(V.VGw,A)}})},5622:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({acosh_:function Y(W){const A={x:(0,H._1)(W,"x","acosh")};return $.BV.runKernel(V.SpW,A)}})},7066:(Lt,ut,y)=>{"use strict";y.d(ut,{I:()=>W});var $=y(687),V=y(4251),H=y(7664),q=y(1257);const W=(0,y(4195).op)({add_:function R(k,A){let X=(0,q._1)(k,"a","add"),Z=(0,q._1)(A,"b","add");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.mm_,{a:X,b:Z})}})},1862:(Lt,ut,y)=>{"use strict";y.d(ut,{$:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({all_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","all","bool")};return $.BV.runKernel(V.oT6,Z,{axis:k,keepDims:A})}})},876:(Lt,ut,y)=>{"use strict";y.d(ut,{Y:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({any_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","any","bool")};return $.BV.runKernel(V.IKK,Z,{axis:k,keepDims:A})}})},5784:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({argMax_:function Y(W,k=0){const X={x:(0,H._1)(W,"x","argMax")};return $.BV.runKernel(V.sJF,X,{axis:k})}})},8340:(Lt,ut,y)=>{"use strict";y.d(ut,{v:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({argMin_:function Y(W,k=0){const X={x:(0,H._1)(W,"x","argMin")};return $.BV.runKernel(V.aJk,X,{axis:k})}})},586:(Lt,ut,y)=>{"use strict";y.d(ut,{Z:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({asin_:function Y(W){const A={x:(0,H._1)(W,"x","asin")};return $.BV.runKernel(V.M2y,A)}})},8355:(Lt,ut,y)=>{"use strict";y.d(ut,{V:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({asinh_:function Y(W){const A={x:(0,H._1)(W,"x","asinh")};return $.BV.runKernel(V.qw7,A)}})},7881:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({atan_:function Y(W){const A={x:(0,H._1)(W,"x","atan")};return $.BV.runKernel(V.jMg,A)}})},5825:(Lt,ut,y)=>{"use strict";y.d(ut,{f:()=>W});var $=y(687),V=y(4251),H=y(7664),q=y(1257);const W=(0,y(4195).op)({atan2_:function R(k,A){let X=(0,q._1)(k,"a","atan2"),Z=(0,q._1)(A,"b","atan2");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.QCc,{a:X,b:Z})}})},7932:(Lt,ut,y)=>{"use strict";y.d(ut,{C:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({atanh_:function Y(W){const A={x:(0,H._1)(W,"x","atanh")};return $.BV.runKernel(V.Oyi,A)}})},6903:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>X});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(3062),R=y(5551),W=y(4195),k=y(5715);const X=(0,W.op)({avgPool_:function A(Z,G,it,bt,K){const st=(0,H._1)(Z,"x","avgPool","float32");q.hu(R.jT(it,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${it} and dilations '1'`);let dt=st,lt=!1;3===st.rank&&(lt=!0,dt=(0,k.X)(st,[1,st.shape[0],st.shape[1],st.shape[2]])),q.hu(4===dt.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${dt.rank}.`),R.m("avgPool",bt,K);let ft=$.BV.runKernel(V.JhU,{x:dt},{filterSize:G,strides:it,pad:bt,dimRoundingMode:K});return ft=(0,Y.p)(ft,st.dtype),lt?(0,k.X)(ft,[ft.shape[1],ft.shape[2],ft.shape[3]]):ft}})},929:(Lt,ut,y)=>{"use strict";y.d(ut,{LJ:()=>k,Q3:()=>W,Vh:()=>H,YB:()=>V,kz:()=>q,lB:()=>R,rv:()=>Y,sY:()=>A});var $=y(5359);function V(X,Z){for(let G=0;G<X.length;++G)if(X[X.length-G-1]!==Z-1-G)return!1;return!0}function H(X,Z,G){const it=X.length+Z.length,bt=[];let K=0,st=0;for(let et=0;et<it;et++)-1===G.indexOf(et)?bt.push(X[K++]):bt.push(Z[st++]);return bt}function q(X,Z){const G=[],it=X.length;for(let K=0;K<it;K++)-1===Z.indexOf(K)&&G.push(X[K]);return[G,Z.map(K=>X[K])]}function Y(X,Z){return H(X,Z.map(it=>1),Z)}function R(X,Z,G){$.hu(V(Z,G),()=>`${X} supports only inner-most axes for now. Got axes ${Z} and rank-${G} input.`)}function W(X,Z){if(V(X,Z))return null;const G=[];for(let it=0;it<Z;++it)-1===X.indexOf(it)&&G.push(it);return X.forEach(it=>G.push(it)),G}function k(X){return X.map((Z,G)=>[G,Z]).sort((Z,G)=>Z[1]-G[1]).map(Z=>Z[0])}function A(X,Z){const G=[];for(let it=Z-X;it<Z;++it)G.push(it);return G}},2782:(Lt,ut,y)=>{"use strict";y.d(ut,{E:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({batchToSpaceND_:function R(k,A,X){const Z=(0,H._1)(k,"x","batchToSpaceND"),G=A.reduce((K,st)=>K*st);return q.hu(Z.rank>=1+A.length,()=>`input rank is ${Z.rank} but should be > than blockShape.length ${A.length}`),q.hu(X.length===A.length,()=>`crops.length is ${X.length} but should be equal to blockShape.length  ${A.length}`),q.hu(Z.shape[0]%G==0,()=>`input tensor batch is ${Z.shape[0]} but is not divisible by the product of the elements of blockShape ${A.join(" * ")} === ${G}`),$.BV.runKernel(V.zws,{x:Z},{blockShape:A,crops:X})}})},5307:(Lt,ut,y)=>{"use strict";y.d(ut,{t:()=>A});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(5715);function R(X){let Z;return Z=0===X.rank||1===X.rank?(0,Y.X)(X,[1,1,1,X.size]):2===X.rank?(0,Y.X)(X,[1,1,X.shape[0],X.shape[1]]):3===X.rank?(0,Y.X)(X,[1,X.shape[0],X.shape[1],X.shape[2]]):X,Z}const A=(0,y(4195).op)({batchNorm_:function k(X,Z,G,it,bt,K){null==K&&(K=.001);const st=(0,H._1)(X,"x","batchNorm"),et=(0,H._1)(Z,"mean","batchNorm"),dt=(0,H._1)(G,"variance","batchNorm");let lt,St;null!=bt&&(lt=(0,H._1)(bt,"scale","batchNorm")),null!=it&&(St=(0,H._1)(it,"offset","batchNorm")),q.hu(et.rank===dt.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q.hu(null==St||et.rank===St.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q.hu(null==lt||et.rank===lt.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const ft={x:R(st),scale:lt,offset:St,mean:et,variance:dt},B=$.BV.runKernel(V.sHE,ft,{varianceEpsilon:K});return(0,Y.X)(B,st.shape)}})},983:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>A});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(7315),R=y(4195),W=y(5715);const A=(0,R.op)({broadcastTo_:function k(X,Z){let G=(0,H._1)(X,"broadcastTo","x");const it=G.shape;if((0,q.Mu)(Z),Z.length<G.rank)throw new Error(`broadcastTo(): shape.length=${Z.length} < input.rank=${G.rank}.`);if(Z.length>G.rank){const lt=G.shape.slice();for(;lt.length<Z.length;)lt.unshift(1);G=(0,W.X)(G,lt)}const bt=G.shape,K=Array.from(Z);for(let lt=Z.length-1;lt>=0;lt--)if(bt[lt]===Z[lt])K[lt]=1;else if(1!==G.shape[lt])throw new Error(`broadcastTo(): [${it}] cannot be broadcast to [${Z}].`);return 0===K.map((lt,St)=>lt>1?St:-1).filter(lt=>lt>=0).length?(0,Y.d)(G):$.BV.runKernel(V.n9L,{x:G},{reps:K})}})},3239:(Lt,ut,y)=>{"use strict";function $(q,Y){const R=q.length,W=[];for(let k=0;k<R;k++){const A=R-1-k;(Y[Y.length-1-k]||1)>1&&1===(q[A]||1)&&W.unshift(A)}return W}function V(q,Y){const R=[];for(let W=0;W<Y.length;W++){const k=q[q.length-W-1],A=Y.length-W-1;(null==k||1===k&&Y[A]>1)&&R.unshift(A)}return R}function H(q,Y){const R=Math.max(q.length,Y.length),W=new Array(R);for(let k=0;k<R;k++){let A=q[q.length-k-1];null==A&&(A=1);let X=Y[Y.length-k-1];if(null==X&&(X=1),1===A)W[R-k-1]=X;else if(1===X)W[R-k-1]=A;else{if(A!==X)throw Error(`Operands could not be broadcast together with shapes ${q} and ${Y}.`);W[R-k-1]=A}}return W}y.r(ut),y.d(ut,{assertAndGetBroadcastShape:()=>H,getBroadcastDims:()=>$,getReductionAxes:()=>V})},582:(Lt,ut,y)=>{"use strict";y.d(ut,{f:()=>H});var $=y(4945),V=y(5359);function H(q,Y="float32",R){return Y=Y||"float32",V.Mu(q),new $.YD(q,Y,R)}},3062:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({cast_:function R(k,A){const X=(0,H._1)(k,"x","cast");if(!q.LP(A))throw new Error(`Failed to cast to unknown dtype ${A}`);if("string"===A&&"string"!==X.dtype||"string"!==A&&"string"===X.dtype)throw new Error("Only strings can be casted to strings");return $.BV.runKernel(V.RFZ,{x:X},{dtype:A})}})},9723:(Lt,ut,y)=>{"use strict";y.d(ut,{m:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({ceil_:function Y(W){const A={x:(0,H._1)(W,"x","ceil","float32")};return $.BV.runKernel(V.gJX,A)}})},6672:(Lt,ut,y)=>{"use strict";y.d(ut,{i:()=>k});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(2787);const k=(0,y(4195).op)({clipByValue_:function W(A,X,Z){const G=(0,H._1)(A,"x","clipByValue");return q.hu(X<=Z,()=>`Error in clip: min (${X}) must be less than or equal to max (${Z}).`),X===Z?(0,Y.h)(G.shape,X,G.dtype):$.BV.runKernel(V.xnO,{x:G},{clipValueMin:X,clipValueMax:Z})}})},7315:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({clone_:function Y(W){const A={x:(0,H._1)(W,"x","clone","string_or_numeric")};return $.BV.runKernel(V.iJz,A)}})},3037:(Lt,ut,y)=>{"use strict";y.d(ut,{P:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({complex_:function R(k,A){const X=(0,H._1)(k,"real","complex"),Z=(0,H._1)(A,"imag","complex");return q.k5(X.shape,Z.shape,`real and imag shapes, ${X.shape} and ${Z.shape}, must match in call to tf.complex().`),$.BV.runKernel(V.Zz9,{real:X,imag:Z})}})},4111:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>k});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(7315);const k=(0,y(4195).op)({concat_:function W(A,X=0){(0,q.hu)(A.length>=1,()=>"Pass at least one tensor to concat");const Z=(0,H.sI)(A,"tensors","concat","string_or_numeric");return"complex64"===Z[0].dtype&&Z.forEach(bt=>{if("complex64"!==bt.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${bt.dtype}. `)}),1===Z.length?(0,Y.d)(Z[0]):$.BV.runKernel(V.Eh3,Z,{axis:X})}})},8577:(Lt,ut,y)=>{"use strict";y.d(ut,{P:()=>k});var $=y(1257),V=y(5359),H=y(4451),q=y(5551),Y=y(4195),R=y(5715);const k=(0,Y.op)({conv1d_:function W(A,X,Z,G,it="NWC",bt=1,K){const st=(0,$._1)(A,"x","conv1d"),et=(0,$._1)(X,"filter","conv1d");let dt=st,lt=!1;2===st.rank&&(lt=!0,dt=(0,R.X)(st,[1,st.shape[0],st.shape[1]])),V.hu(3===dt.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${dt.rank}.`),V.hu(3===et.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${et.rank}.`),q.m("conv1d",G,K),V.hu(dt.shape[2]===et.shape[1],()=>`Error in conv1d: depth of input (${dt.shape[2]}) must match input depth for filter ${et.shape[1]}.`),V.hu(q.jT(Z,bt),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${Z} and dilation '${bt}'`),V.hu(q.U3(bt),()=>"Error in conv1D: Dilated rates should be larger than 0."),V.hu(q.U3(Z),()=>"Error in conv1D: Stride should be larger than 0."),V.hu("NWC"===it,()=>`Error in conv1d: got dataFormat of ${it} but only NWC is currently supported.`);const St=(0,R.X)(et,[1,et.shape[0],et.shape[1],et.shape[2]]),Q=(0,R.X)(dt,[dt.shape[0],1,dt.shape[1],dt.shape[2]]),ot=(0,H.T)(Q,St,[1,Z],G,"NHWC",[1,bt],K);return(0,R.X)(ot,lt?[ot.shape[2],ot.shape[3]]:[ot.shape[0],ot.shape[2],ot.shape[3]])}})},4451:(Lt,ut,y)=>{"use strict";y.d(ut,{T:()=>A});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(5551),R=y(4195),W=y(5715);const A=(0,R.op)({conv2d_:function k(X,Z,G,it,bt="NHWC",K=[1,1],st){const et=(0,H._1)(X,"x","conv2d","float32"),dt=(0,H._1)(Z,"filter","conv2d","float32");let lt=et,St=!1;3===et.rank&&(St=!0,lt=(0,W.X)(et,[1,et.shape[0],et.shape[1],et.shape[2]])),q.hu(4===lt.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${lt.rank}.`),q.hu(4===dt.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${dt.rank}.`),Y.m("conv2d",it,st);const Q="NHWC"===bt?lt.shape[3]:lt.shape[1];q.hu(Q===dt.shape[2],()=>`Error in conv2d: depth of input (${Q}) must match input depth for filter ${dt.shape[2]}.`),q.hu(Y.jT(G,K),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${G} and dilations '${K}'`),q.hu(Y.U3(K),()=>"Error in conv2D: Dilated rates should be larger than 0."),q.hu(Y.U3(G),()=>"Error in conv2D: Strides should be larger than 0.");const B=$.BV.runKernel(V.mhS,{x:lt,filter:dt},{strides:G,pad:it,dataFormat:bt,dilations:K,dimRoundingMode:st});return St?(0,W.X)(B,[B.shape[1],B.shape[2],B.shape[3]]):B}})},443:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>k});var $=y(687),V=y(4251),H=y(5359),q=y(5551),Y=y(4195),R=y(5715);const k=(0,Y.op)({conv2DBackpropFilter_:function W(A,X,Z,G,it,bt="NHWC",K){let st=A;3===A.rank&&(st=(0,R.X)(A,[1,A.shape[0],A.shape[1],A.shape[2]]));let et=X;3===et.rank&&(et=(0,R.X)(X,[1,X.shape[0],X.shape[1],X.shape[2]])),H.hu(4===st.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${st.shape}.`),H.hu(4===et.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${et.shape}.`),H.hu(4===Z.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${Z}.`);const dt="NHWC"===bt?st.shape[3]:st.shape[1],lt="NHWC"===bt?et.shape[3]:et.shape[1];return H.hu(dt===Z[2],()=>`Error in conv2dDerFilter: depth of input ${dt}) must match input depth in filter (${Z[2]}.`),H.hu(lt===Z[3],()=>`Error in conv2dDerFilter: depth of dy (${lt}) must match output depth for filter (${Z[3]}).`),q.m("conv2dDerFilter",it,K),$.BV.runKernel(V.wUP,{x:st,dy:et},{strides:G,pad:it,dataFormat:bt,dimRoundingMode:K,filterShape:Z})}})},5743:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>k});var $=y(687),V=y(4251),H=y(5359),q=y(5551),Y=y(4195),R=y(5715);const k=(0,Y.op)({conv2DBackpropInput_:function W(A,X,Z,G,it,bt="NHWC",K){H.hu(A.length===X.rank,()=>`Length of inShape (${A.length}) and rank of dy (${X.rank}) must match`);let st=A,et=X,dt=!1;3===X.rank&&(dt=!0,et=(0,R.X)(X,[1,X.shape[0],X.shape[1],X.shape[2]]),st=[1,A[0],A[1],A[2]]),H.hu(4===st.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${st.length}.`),H.hu(4===et.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${et.rank}`),H.hu(4===Z.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${Z.rank}`);const lt="NHWC"===bt?st[3]:st[1],St="NHWC"===bt?et.shape[3]:et.shape[1];H.hu(lt===Z.shape[2],()=>`Error in conv2dDerInput: depth of input (${lt}) must match input depth for filter ${Z.shape[2]}.`),H.hu(St===Z.shape[3],()=>`Error in conv2dDerInput: depth of output (${St}) must match output depth for filter ${Z.shape[3]}.`),q.m("conv2dDerInput",it,K);const pt=$.BV.runKernel(V.wm,{dy:et,filter:Z},{strides:G,pad:it,dataFormat:bt,dimRoundingMode:K,inputShape:st});return dt?(0,R.X)(pt,[pt.shape[1],pt.shape[2],pt.shape[3]]):pt}})},8554:(Lt,ut,y)=>{"use strict";y.d(ut,{b:()=>Y});var $=y(1257),V=y(5743);const Y=(0,y(4195).op)({conv2dTranspose_:function q(R,W,k,A,X,Z){const G=(0,$._1)(R,"x","conv2dTranspose"),it=(0,$._1)(W,"filter","conv2dTranspose");return(0,V._)(k,G,it,A,X,"NHWC",Z)}})},7022:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>W});var $=y(687),V=y(4251),H=y(5359),q=y(4195),Y=y(5715);const W=(0,q.op)({conv3DBackpropInput_:function R(k,A,X,Z,G){H.hu(k.length===A.rank,()=>`Length of inShape (${k.length}) and rank of dy (${A.rank}) must match`);let it=k,bt=A,K=!1;4===A.rank&&(K=!0,bt=(0,Y.X)(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]]),it=[1,k[0],k[1],k[2],k[3]]);const st=it[4],et=bt.shape[4];H.hu(5===it.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${it.length}.`),H.hu(5===bt.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${bt.rank}`),H.hu(5===X.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${X.rank}`),H.hu(st===X.shape[3],()=>`Error in conv3dDerInput: depth of input (${st}) must match input depth for filter ${X.shape[3]}.`),H.hu(et===X.shape[4],()=>`Error in conv3dDerInput: depth of output (${et}) must match output depth for filter ${X.shape[4]}.`);const St=$.BV.runKernel(V.ik2,{dy:bt,filter:X},{pad:G,strides:Z,inputShape:it});return K?(0,Y.X)(St,[St.shape[1],St.shape[2],St.shape[3],St.shape[4]]):St}})},5551:(Lt,ut,y)=>{"use strict";y.d(ut,{I0:()=>st,Ix:()=>Y,Rf:()=>V,U3:()=>dt,Xw:()=>H,aO:()=>A,jT:()=>et,jw:()=>R,m:()=>St,pl:()=>q,sl:()=>lt});var $=y(5359);function V(Q,ft,pt,B,ot="NHWC",P){return Y(Q,[...ft,Q[3]],pt,P,B,null,null,lt(ot))}function H(Q,ft,pt,B,ot,P,at="channelsLast"){const[nt,Gt]=X(ft);let O;if("channelsLast"===at)O=[nt,Gt,Q[3],Q[3]];else{if("channelsFirst"!==at)throw new Error(`Unknown dataFormat ${at}`);O=[nt,Gt,Q[1],Q[1]]}return Y(Q,O,pt,B,ot,P,!1,at)}function q(Q,ft,pt,B,ot,P,at="NDHWC"){const[nt,Gt,O]=Z(ft);let Ct,yt;if("NDHWC"===at)yt="channelsLast",Ct=[nt,Gt,O,Q[4],Q[4]];else{if("NCDHW"!==at)throw new Error(`Unknown dataFormat ${at}`);yt="channelsFirst",Ct=[nt,Gt,O,Q[1],Q[1]]}return R(Q,Ct,pt,B,ot,!1,yt,P)}function Y(Q,ft,pt,B,ot,P,at=!1,nt="channelsLast"){let[Gt,O,Ct,yt]=[-1,-1,-1,-1];if("channelsLast"===nt)[Gt,O,Ct,yt]=Q;else{if("channelsFirst"!==nt)throw new Error(`Unknown dataFormat ${nt}`);[Gt,yt,O,Ct]=Q}const[vt,xt,,Mt]=ft,[It,re]=X(pt),[Bt,ee]=X(B),jt=G(vt,Bt),se=G(xt,ee),{padInfo:be,outHeight:Me,outWidth:Xe}=function it(Q,ft,pt,B,ot,P,at,nt,Gt){let O,Ct,yt;if("number"==typeof Q){O={top:Q,bottom:Q,left:Q,right:Q,type:0===Q?"VALID":"NUMBER"};const xt=function W(Q,ft,pt,B,ot){null==B&&(B=A(Q,ft,pt));const at=Q[1];return[K((Q[0]-ft+2*B)/pt+1,ot),K((at-ft+2*B)/pt+1,ot)]}([ft,pt],P,B,Q,nt);Ct=xt[0],yt=xt[1]}else if("same"===Q){Ct=Math.ceil(ft/B),yt=Math.ceil(pt/ot);const vt=Math.max(0,(Ct-1)*B+P-ft),xt=Math.max(0,(yt-1)*ot+at-pt),Mt=Math.floor(vt/2),It=vt-Mt,re=Math.floor(xt/2);O={top:Mt,bottom:It,left:re,right:xt-re,type:"SAME"}}else if("valid"===Q)O={top:0,bottom:0,left:0,right:0,type:"VALID"},Ct=Math.ceil((ft-P+1)/B),yt=Math.ceil((pt-at+1)/ot);else{if("object"!=typeof Q)throw Error(`Unknown padding parameter: ${Q}`);{const vt="channelsLast"===Gt?Q[1][0]:Q[2][0],xt="channelsLast"===Gt?Q[1][1]:Q[2][1],Mt="channelsLast"===Gt?Q[2][0]:Q[3][0],It="channelsLast"===Gt?Q[2][1]:Q[3][1];O={top:vt,bottom:xt,left:Mt,right:It,type:0===vt&&0===xt&&0===Mt&&0===It?"VALID":"EXPLICIT"},Ct=K((ft-P+vt+xt)/B+1,nt),yt=K((pt-at+Mt+It)/ot+1,nt)}}return{padInfo:O,outHeight:Ct,outWidth:yt}}(ot,O,Ct,It,re,jt,se,P,nt),Ue=at?Mt*yt:Mt;let De;return"channelsFirst"===nt?De=[Gt,Ue,Me,Xe]:"channelsLast"===nt&&(De=[Gt,Me,Xe,Ue]),{batchSize:Gt,dataFormat:nt,inHeight:O,inWidth:Ct,inChannels:yt,outHeight:Me,outWidth:Xe,outChannels:Ue,padInfo:be,strideHeight:It,strideWidth:re,filterHeight:vt,filterWidth:xt,effectiveFilterHeight:jt,effectiveFilterWidth:se,dilationHeight:Bt,dilationWidth:ee,inShape:Q,outShape:De,filterShape:ft}}function R(Q,ft,pt,B,ot,P=!1,at="channelsLast",nt){let[Gt,O,Ct,yt,vt]=[-1,-1,-1,-1,-1];if("channelsLast"===at)[Gt,O,Ct,yt,vt]=Q;else{if("channelsFirst"!==at)throw new Error(`Unknown dataFormat ${at}`);[Gt,vt,O,Ct,yt]=Q}const[xt,Mt,It,,re]=ft,[Bt,ee,jt]=Z(pt),[se,be,Me]=Z(B),Xe=G(xt,se),Ue=G(Mt,be),De=G(It,Me),{padInfo:Tn,outDepth:On,outHeight:ne,outWidth:pe}=function bt(Q,ft,pt,B,ot,P,at,nt,Gt,O,Ct){let yt,vt,xt,Mt;if("valid"===Q&&(Q=0),"number"==typeof Q){yt={top:Q,bottom:Q,left:Q,right:Q,front:Q,back:Q,type:0===Q?"VALID":"NUMBER"};const re=function k(Q,ft,pt,B,ot,P){null==ot&&(ot=A(Q,ft[0],B[0]));const at=[0,0,0,pt];for(let nt=0;nt<3;nt++)Q[nt]+2*ot>=ft[nt]&&(at[nt]=K((Q[nt]-ft[nt]+2*ot)/B[nt]+1,P));return at}([ft,pt,B,1],[nt,Gt,O],1,[ot,P,at],Q,Ct);vt=re[0],xt=re[1],Mt=re[2]}else{if("same"!==Q)throw Error(`Unknown padding parameter: ${Q}`);{vt=Math.ceil(ft/ot),xt=Math.ceil(pt/P),Mt=Math.ceil(B/at);const It=(vt-1)*ot+nt-ft,re=(xt-1)*P+Gt-pt,Bt=(Mt-1)*at+O-B,ee=Math.floor(It/2),jt=It-ee,se=Math.floor(re/2),be=re-se,Me=Math.floor(Bt/2);yt={top:se,bottom:be,left:Me,right:Bt-Me,front:ee,back:jt,type:"SAME"}}}return{padInfo:yt,outDepth:vt,outHeight:xt,outWidth:Mt}}(ot,O,Ct,yt,Bt,ee,jt,Xe,Ue,De,nt),Ie=P?re*vt:re;let Je;return"channelsFirst"===at?Je=[Gt,Ie,On,ne,pe]:"channelsLast"===at&&(Je=[Gt,On,ne,pe,Ie]),{batchSize:Gt,dataFormat:at,inDepth:O,inHeight:Ct,inWidth:yt,inChannels:vt,outDepth:On,outHeight:ne,outWidth:pe,outChannels:Ie,padInfo:Tn,strideDepth:Bt,strideHeight:ee,strideWidth:jt,filterDepth:xt,filterHeight:Mt,filterWidth:It,effectiveFilterDepth:Xe,effectiveFilterHeight:Ue,effectiveFilterWidth:De,dilationDepth:se,dilationHeight:be,dilationWidth:Me,inShape:Q,outShape:Je,filterShape:ft}}function A(Q,ft,pt,B=1){const ot=G(ft,B);return Math.floor((Q[0]*(pt-1)-pt+ot)/2)}function X(Q){return"number"==typeof Q?[Q,Q,Q]:2===Q.length?[Q[0],Q[1],1]:Q}function Z(Q){return"number"==typeof Q?[Q,Q,Q]:Q}function G(Q,ft){return ft<=1?Q:Q+(Q-1)*(ft-1)}function K(Q,ft){if(!ft)return Math.trunc(Q);switch(ft){case"round":return Math.round(Q);case"ceil":return Math.ceil(Q);case"floor":return Math.floor(Q);default:throw new Error(`Unknown roundingMode ${ft}`)}}function st(Q){const[ft,pt,B]=X(Q);return 1===ft&&1===pt&&1===B}function et(Q,ft){return st(Q)||st(ft)}function dt(Q){return X(Q).every(ft=>ft>0)}function lt(Q){if("NHWC"===Q)return"channelsLast";if("NCHW"===Q)return"channelsFirst";throw new Error(`Unknown dataFormat ${Q}`)}function St(Q,ft,pt){if(null!=pt){if("string"==typeof ft)throw Error(`Error in ${Q}: pad must be an integer when using dimRoundingMode ${pt} but got pad ${ft}.`);if("number"==typeof ft)$.hu($.GN(ft),()=>`Error in ${Q}: pad must be an integer when using dimRoundingMode ${pt} but got pad ${ft}.`);else{if("object"!=typeof ft)throw Error(`Error in ${Q}: Unknown padding parameter: ${ft}`);ft.forEach(B=>{B.forEach(ot=>{$.hu($.GN(ot),()=>`Error in ${Q}: pad must be an integer when using dimRoundingMode ${pt} but got pad ${ot}.`)})})}}}},9018:(Lt,ut,y)=>{"use strict";y.d(ut,{m:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({cos_:function Y(W){const A={x:(0,H._1)(W,"x","cos","float32")};return $.BV.runKernel(V.mc4,A)}})},3237:(Lt,ut,y)=>{"use strict";y.d(ut,{f:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({cosh_:function Y(W){const A={x:(0,H._1)(W,"x","cosh","float32")};return $.BV.runKernel(V.TR1,A)}})},9267:(Lt,ut,y)=>{"use strict";y.d(ut,{$:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({cumprod_:function Y(W,k=0,A=!1,X=!1){const G={x:(0,H._1)(W,"x","cumprod")};return $.BV.runKernel(V.Byc,G,{axis:k,exclusive:A,reverse:X})}})},7157:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({cumsum_:function Y(W,k=0,A=!1,X=!1){const G={x:(0,H._1)(W,"x","cumsum")};return $.BV.runKernel(V.iHb,G,{axis:k,exclusive:A,reverse:X})}})},3961:(Lt,ut,y)=>{"use strict";y.d(ut,{n:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({depthToSpace_:function R(k,A,X="NHWC"){const Z=(0,H._1)(k,"x","depthToSpace","float32"),G="NHWC"===X?Z.shape[1]:Z.shape[2],it="NHWC"===X?Z.shape[2]:Z.shape[3],bt="NHWC"===X?Z.shape[3]:Z.shape[1];return q.hu(A>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${A}`),q.hu(G*A>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${G} and ${A}  for depthToSpace with input shape\n    ${Z.shape}`),q.hu(it*A>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${it} and ${A} for depthToSpace with input shape\n        ${Z.shape}`),q.hu(bt%(A*A)==0,()=>`Dimension size must be evenly divisible by ${A*A} but is ${bt} for depthToSpace with input shape ${Z.shape}`),$.BV.runKernel(V.T0n,{x:Z},{blockSize:A,dataFormat:X})}})},1172:(Lt,ut,y)=>{"use strict";y.d(ut,{B:()=>A});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(5551),R=y(4195),W=y(5715);const A=(0,R.op)({depthwiseConv2d_:function k(X,Z,G,it,bt="NHWC",K=[1,1],st){const et=(0,H._1)(X,"x","depthwiseConv2d","float32"),dt=(0,H._1)(Z,"filter","depthwiseConv2d","float32");let lt=et,St=!1;3===et.rank&&(St=!0,lt=(0,W.X)(et,[1,et.shape[0],et.shape[1],et.shape[2]])),q.hu(4===lt.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${lt.rank}.`),q.hu(4===dt.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${dt.rank}.`);const Q="NHWC"===bt?lt.shape[3]:lt.shape[1];q.hu(Q===dt.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${Q}) must match the inChannels dimension in filter ${dt.shape[2]}.`),Y.m("depthwiseConv2d",it,st);const B=$.BV.runKernel(V.cie,{x:lt,filter:dt},{strides:G,pad:it,dataFormat:bt,dilations:K,dimRoundingMode:st});return St?(0,W.X)(B,[B.shape[1],B.shape[2],B.shape[3]]):B}})},366:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>R});var $=y(687),V=y(4251),H=y(4195),q=y(5715);const R=(0,H.op)({depthwiseConv2dNativeBackpropFilter_:function Y(W,k,A,X,Z,G=[1,1],it){let bt=W;3===W.rank&&(bt=(0,q.X)(W,[1,W.shape[0],W.shape[1],W.shape[2]]));let K=k;return 3===K.rank&&(K=(0,q.X)(k,[1,k.shape[0],k.shape[1],k.shape[2]])),$.BV.runKernel(V.sL$,{x:bt,dy:K},{strides:X,pad:Z,dimRoundingMode:it,dilations:G,filterShape:A})}})},519:(Lt,ut,y)=>{"use strict";y.d(ut,{v:()=>R});var $=y(687),V=y(4251),H=y(4195),q=y(5715);const R=(0,H.op)({depthwiseConv2dNativeBackpropInput_:function Y(W,k,A,X,Z,G=[1,1],it){let bt=k,K=!1;3===k.rank&&(K=!0,bt=(0,q.X)(k,[1,k.shape[0],k.shape[1],k.shape[2]]));const dt=$.BV.runKernel(V.y7R,{dy:bt,filter:A},{strides:X,pad:Z,dimRoundingMode:it,dilations:G,inputShape:W});return K?(0,q.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3]]):dt}})},2395:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>k});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(4195),R=y(5715);const k=(0,Y.op)({dilation2d_:function W(A,X,Z,G,it=[1,1],bt="NHWC"){const K=(0,H._1)(A,"x","dilation2d"),st=(0,H._1)(X,"filter","dilation2d");q.hu(3===K.rank||4===K.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${K.rank}.`),q.hu(3===st.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${st.rank}.`),q.hu("NHWC"===bt,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${bt}`);let et=K,dt=!1;3===K.rank&&(et=(0,R.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]]),dt=!0),q.hu(et.shape[3]===st.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${et.shape[3]} vs ${st.shape[2]}`);const Q=$.BV.runKernel(V.p4S,{x:et,filter:st},{strides:Z,pad:G,dilations:it});return dt?(0,R.X)(Q,[Q.shape[1],Q.shape[2],Q.shape[3]]):Q}})},3530:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>k});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(1030);const k=(0,y(4195).op)({div_:function W(A,X){let Z=(0,q._1)(A,"a","div"),G=(0,q._1)(X,"b","div");return[Z,G]=(0,H.makeTypesMatch)(Z,G),"int32"===Z.dtype&&"int32"===G.dtype?(0,Y.q)(Z,G):$.BV.runKernel(V.oHH,{a:Z,b:G},{})}})},4373:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>A});var $=y(7664),V=y(1257),H=y(3530),q=y(4456),Y=y(4195),R=y(2190),W=y(3143);const A=(0,Y.op)({divNoNan_:function k(X,Z){let G=(0,V._1)(X,"a","div"),it=(0,V._1)(Z,"b","div");[G,it]=(0,$.makeTypesMatch)(G,it);const bt=(0,H.h)(G,it),K=(0,W.P)(bt),st=(0,q.D)(it,K);return(0,R.a)(st,K,bt)}})},5106:(Lt,ut,y)=>{"use strict";y.d(ut,{A:()=>W});var $=y(1257),V=y(5359),H=y(5592),q=y(4195),Y=y(5715);const W=(0,q.op)({dot_:function R(k,A){const X=(0,$._1)(k,"t1","dot"),Z=(0,$._1)(A,"t2","dot");V.hu(!(1!==X.rank&&2!==X.rank||1!==Z.rank&&2!==Z.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${X.rank} and ${Z.rank}.`);const G=1===X.rank?X.size:X.shape[1],it=1===Z.rank?Z.size:Z.shape[0];if(V.hu(G===it,()=>`Error in dot: inner dimensions of inputs must match, but got ${G} and ${it}.`),1===X.rank&&1===Z.rank){const bt=(0,Y.X)(X,[1,-1]),K=(0,Y.X)(Z,[-1,1]),st=(0,H.O)(bt,K);return(0,Y.X)(st,[])}if(1===X.rank&&2===Z.rank){const bt=(0,Y.X)(X,[1,-1]),K=(0,Y.X)(Z,[Z.shape[0],Z.shape[1]]),st=(0,H.O)(bt,K);return(0,Y.X)(st,[st.size])}if(2===X.rank&&1===Z.rank){const bt=(0,Y.X)(Z,[-1,1]),K=(0,H.O)(X,bt);return(0,Y.X)(K,[K.size])}{const bt=(0,Y.X)(Z,[Z.shape[0],Z.shape[1]]);return(0,H.O)(X,bt)}}})},9529:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({elu_:function Y(W){const A={x:(0,H._1)(W,"x","elu","float32")};return $.BV.runKernel(V.SX0,A)}})},4456:(Lt,ut,y)=>{"use strict";y.d(ut,{D:()=>k});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239);const k=(0,y(4195).op)({equal_:function W(A,X){let Z=(0,q._1)(A,"a","equal","string_or_numeric"),G=(0,q._1)(X,"b","equal","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.hdR,{a:Z,b:G})}})},4634:(Lt,ut,y)=>{"use strict";y.d(ut,{q:()=>k});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(3062);const k=(0,y(4195).op)({erf_:function W(A){let X=(0,H._1)(A,"x","erf");return q.hu("int32"===X.dtype||"float32"===X.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===X.dtype&&(X=(0,Y.p)(X,"float32")),$.BV.runKernel(V.Omj,{x:X})}})},4279:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>q});var $=y(3717);const q=(0,y(4195).op)({euclideanNorm_:function H(Y,R=null,W=!1){return(0,$.K)(Y,"euclidean",R,W)}})},5109:(Lt,ut,y)=>{"use strict";y.d(ut,{Q:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({exp_:function Y(W){const A={x:(0,H._1)(W,"x","exp")};return $.BV.runKernel(V.NEP,A)}})},7228:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({expandDims_:function R(k,A=0){const X=(0,H._1)(k,"x","expandDims","string_or_numeric");return q.hu(A<=X.rank,()=>"Axis must be <= rank of the tensor"),$.BV.runKernel(V.YFo,{input:X},{dim:A})}})},5748:(Lt,ut,y)=>{"use strict";y.d(ut,{t:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({expm1_:function Y(W){const A={x:(0,H._1)(W,"x","expm1")};return $.BV.runKernel(V.Y0y,A)}})},2787:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>q});var $=y(687),V=y(4251),H=y(5359);function q(Y,R,W){return(0,H.Mu)(Y),W=W||(0,H.D2)(R),$.BV.runKernel(V.deh,{},{shape:Y,value:R,dtype:W})}},8208:(Lt,ut,y)=>{"use strict";y.d(ut,{G:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({floor_:function Y(W){const A={x:(0,H._1)(W,"x","floor","float32")};return $.BV.runKernel(V.OR,A)}})},1030:(Lt,ut,y)=>{"use strict";y.d(ut,{q:()=>W});var $=y(687),V=y(4251),H=y(7664),q=y(1257);const W=(0,y(4195).op)({floorDiv_:function R(k,A){let X=(0,q._1)(k,"a","floorDiv"),Z=(0,q._1)(A,"b","floorDiv");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.jeX,{a:X,b:Z})}})},6254:(Lt,ut,y)=>{"use strict";y.d(ut,{Fr:()=>G,QH:()=>bt,pf:()=>it,uy:()=>K});var $=y(3239),V=y(9529),H=y(9424),q=y(8737),Y=y(1584),R=y(8586),W=y(4917),k=y(5715),A=y(6139),X=y(6034),Z=y(9929);function G(st,et,dt){if(null==dt||"linear"===dt)return st;if("relu"===dt)return(0,q.d)(st,(0,X.N)(et));throw new Error(`Cannot compute gradient for fused activation ${dt}.`)}function it(st,et){let dt=et;const lt=$.getReductionAxes(st.shape,et.shape);return lt.length>0&&(dt=(0,Z.S)(dt,lt)),(0,k.X)(dt,st.shape)}function bt(st,et,dt,lt){if("linear"===et)return st;if("relu"===et)return(0,R.U)(st);if("elu"===et)return(0,V.p)(st);if("relu6"===et)return(0,W.b)(st);if("prelu"===et)return(0,Y.A)(st,dt);if("leakyrelu"===et)return(0,H.h)(st,lt);if("sigmoid"===et)return(0,A.X)(st);throw new Error(`Unknown fused activation ${et}.`)}const K=(st,et)=>!(st>0)||"linear"===et},6117:(Lt,ut,y)=>{"use strict";y.d(ut,{I:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({gather_:function Y(W,k,A=0,X=0){const Z=(0,H._1)(W,"x","gather"),G=(0,H._1)(k,"indices","gather","int32");return $.BV.runKernel(V.qi_,{x:Z,indices:G},{axis:A,batchDims:X})}})},4803:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>k});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239);const k=(0,y(4195).op)({greater_:function W(A,X){let Z=(0,q._1)(A,"a","greater","string_or_numeric"),G=(0,q._1)(X,"b","greater","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.iZT,{a:Z,b:G})}})},9886:(Lt,ut,y)=>{"use strict";y.d(ut,{b:()=>k});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239);const k=(0,y(4195).op)({greaterEqual_:function W(A,X){let Z=(0,q._1)(A,"a","greaterEqual","string_or_numeric"),G=(0,q._1)(X,"b","greaterEqual","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.Acj,{a:Z,b:G})}})},1844:(Lt,ut,y)=>{"use strict";y.d(ut,{a:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({imag_:function Y(W){const A={input:(0,H._1)(W,"input","imag")};return $.BV.runKernel(V.J_u,A)}})},1265:(Lt,ut,y)=>{"use strict";y.d(ut,{I:()=>k});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(4195),R=y(5715);const k=(0,Y.op)({resizeBilinear_:function W(A,X,Z=!1,G=!1){const it=(0,H._1)(A,"images","resizeBilinear");q.hu(3===it.rank||4===it.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${it.rank}.`),q.hu(2===X.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${X}.`),q.hu(!1===G||!1===Z,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let bt=it,K=!1;3===it.rank&&(K=!0,bt=(0,R.X)(it,[1,it.shape[0],it.shape[1],it.shape[2]]));const[]=X,dt=$.BV.runKernel(V._Yw,{images:bt},{alignCorners:Z,halfPixelCenters:G,size:X});return K?(0,R.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3]]):dt}})},7373:(Lt,ut,y)=>{"use strict";y.d(ut,{j:()=>k});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(4195),R=y(5715);const k=(0,Y.op)({resizeNearestNeighbor_:function W(A,X,Z=!1,G=!1){const it=(0,H._1)(A,"images","resizeNearestNeighbor");q.hu(3===it.rank||4===it.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${it.rank}.`),q.hu(2===X.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${X}.`),q.hu("float32"===it.dtype||"int32"===it.dtype,()=>"`images` must have `int32` or `float32` as dtype"),q.hu(!1===G||!1===Z,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let bt=it,K=!1;3===it.rank&&(K=!0,bt=(0,R.X)(it,[1,it.shape[0],it.shape[1],it.shape[2]]));const[]=X,dt=$.BV.runKernel(V.dpD,{images:bt},{alignCorners:Z,halfPixelCenters:G,size:X});return K?(0,R.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3]]):dt}})},8821:(Lt,ut,y)=>{"use strict";y.d(ut,{x:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({isFinite_:function Y(W){const A={x:(0,H._1)(W,"x","isFinite")};return $.BV.runKernel(V.avt,A)}})},8381:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({isInf_:function Y(W){const A={x:(0,H._1)(W,"x","isInf")};return $.BV.runKernel(V.iWB,A)}})},6483:(Lt,ut,y)=>{"use strict";y.d(ut,{i:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({isNaN_:function Y(W){const A={x:(0,H._1)(W,"x","isNaN")};return $.BV.runKernel(V.r7n,A)}})},9424:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({leakyRelu_:function Y(W,k=.2){const X={x:(0,H._1)(W,"x","leakyRelu")};return $.BV.runKernel(V.J$2,X,{alpha:k})}})},2761:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>k});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239);const k=(0,y(4195).op)({less_:function W(A,X){let Z=(0,q._1)(A,"a","less","string_or_numeric"),G=(0,q._1)(X,"b","less","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.vtC,{a:Z,b:G})}})},2223:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>k});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239);const k=(0,y(4195).op)({lessEqual_:function W(A,X){let Z=(0,q._1)(A,"a","lessEqual","string_or_numeric"),G=(0,q._1)(X,"b","lessEqual","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.CAk,{a:Z,b:G})}})},1523:(Lt,ut,y)=>{"use strict";y.d(ut,{G:()=>k});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(4195),R=y(5715);const k=(0,Y.op)({localResponseNormalization_:function W(A,X=5,Z=1,G=1,it=.5){const bt=(0,H._1)(A,"x","localResponseNormalization");q.hu(4===bt.rank||3===bt.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${bt.rank}.`),q.hu(q.GN(X),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${X}.`);let K=bt,st=!1;3===bt.rank&&(st=!0,K=(0,R.X)(bt,[1,bt.shape[0],bt.shape[1],bt.shape[2]]));const lt=$.BV.runKernel(V.eZ0,{x:K},{depthRadius:X,bias:Z,alpha:G,beta:it});return st?(0,R.X)(lt,[lt.shape[1],lt.shape[2],lt.shape[3]]):lt}})},5919:(Lt,ut,y)=>{"use strict";y.d(ut,{c:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({log_:function Y(W){const A={x:(0,H._1)(W,"x","log","float32")};return $.BV.runKernel(V.ZbH,A)}})},4088:(Lt,ut,y)=>{"use strict";y.d(ut,{K:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({log1p_:function Y(W){const A={x:(0,H._1)(W,"x","log1p")};return $.BV.runKernel(V.kU,A)}})},4034:(Lt,ut,y)=>{"use strict";y.d(ut,{e:()=>A});var $=y(3537),V=y(1257),H=y(8737),q=y(5048),Y=y(4195),R=y(6139),W=y(4487);const A=(0,Y.op)({logSigmoid_:function k(X){const Z=(0,V._1)(X,"x","logSigmoid");return(0,$.cb)(it=>({value:(0,q.W)((0,W.W)((0,q.W)(it))),gradFunc:st=>(0,H.d)(st,(0,R.X)((0,q.W)(it)))}))(Z)}})},6455:(Lt,ut,y)=>{"use strict";y.d(ut,{C:()=>G});var $=y(3537),V=y(1257),H=y(3062),q=y(5109),Y=y(5919),R=y(3043),W=y(8737),k=y(4195),A=y(1191),X=y(9929);const G=(0,k.op)({logSoftmax_:function Z(it,bt=-1){const K=(0,V._1)(it,"logits","logSoftmax");if(-1===bt&&(bt=K.rank-1),bt!==K.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${K.rank} and axis was ${bt}`);return(0,$.cb)((et,dt)=>{const St=(0,R.F)(et,bt,!0),Q=(0,A.l)(et,St),ft=(0,A.l)((0,H.p)(Q,"float32"),(0,Y.c)((0,X.S)((0,q.Q)(Q),bt,!0)));return dt([ft]),{value:ft,gradFunc:(B,ot)=>{const[P]=ot,nt=(0,q.Q)(P);return(0,A.l)(B,(0,W.d)((0,X.S)(B,bt,!0),nt))}}})(K)}})},6735:(Lt,ut,y)=>{"use strict";y.d(ut,{l:()=>it});var $=y(1257),V=y(5359),H=y(7066),q=y(929),Y=y(5109),R=y(5919),W=y(3043),k=y(4195),A=y(5715),X=y(1191),Z=y(9929);const it=(0,k.op)({logSumExp_:function G(bt,K=null,st=!1){const et=(0,$._1)(bt,"x","logSumExp"),dt=(0,V.EC)(K,et.shape),lt=(0,W.F)(et,dt,!0),St=(0,X.l)(et,lt),Q=(0,Y.Q)(St),ft=(0,Z.S)(Q,dt),pt=(0,R.c)(ft),B=(0,H.I)((0,A.X)(lt,pt.shape),pt);if(st){const ot=(0,q.rv)(B.shape,dt);return(0,A.X)(B,ot)}return B}})},3080:(Lt,ut,y)=>{"use strict";y.d(ut,{H:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(3239);const W=(0,y(4195).op)({logicalAnd_:function R(k,A){const X=(0,H._1)(k,"a","logicalAnd","bool"),Z=(0,H._1)(A,"b","logicalAnd","bool");return(0,q.assertAndGetBroadcastShape)(X.shape,Z.shape),$.BV.runKernel(V.PYm,{a:X,b:Z})}})},6399:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({logicalNot_:function Y(W){const A={x:(0,H._1)(W,"x","logicalNot","bool")};return $.BV.runKernel(V.VfG,A)}})},2693:(Lt,ut,y)=>{"use strict";y.d(ut,{K:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(3239);const W=(0,y(4195).op)({logicalOr_:function R(k,A){const X=(0,H._1)(k,"a","logicalOr","bool"),Z=(0,H._1)(A,"b","logicalOr","bool");return(0,q.assertAndGetBroadcastShape)(X.shape,Z.shape),$.BV.runKernel(V.MZg,{a:X,b:Z})}})},4574:(Lt,ut,y)=>{"use strict";y.d(ut,{e:()=>k});var $=y(1257),V=y(3239),H=y(3080),q=y(6399),Y=y(2693);const k=(0,y(4195).op)({logicalXor_:function W(A,X){const Z=(0,$._1)(A,"a","logicalXor","bool"),G=(0,$._1)(X,"b","logicalXor","bool");return(0,V.assertAndGetBroadcastShape)(Z.shape,G.shape),(0,H.H)((0,Y.K)(A,X),(0,q.h)((0,H.H)(A,X)))}})},4839:(Lt,ut,y)=>{"use strict";y.d(ut,{I:()=>$});var $=function(V){return V[V.NONE=0]="NONE",V[V.MEAN=1]="MEAN",V[V.SUM=2]="SUM",V[V.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",V}($||{})},5592:(Lt,ut,y)=>{"use strict";y.d(ut,{O:()=>W});var $=y(687),V=y(4251),H=y(7664),q=y(1257);const W=(0,y(4195).op)({matMul_:function R(k,A,X=!1,Z=!1){let G=(0,q._1)(k,"a","matMul"),it=(0,q._1)(A,"b","matMul");return[G,it]=(0,H.makeTypesMatch)(G,it),$.BV.runKernel(V.XLW,{a:G,b:it},{transposeA:X,transposeB:Z})}})},3043:(Lt,ut,y)=>{"use strict";y.d(ut,{F:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({max_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","max")};return $.BV.runKernel(V.YoZ,Z,{reductionIndices:k,keepDims:A})}})},2444:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>A});var $=y(687),V=y(4251),H=y(1257),q=y(5359),Y=y(5551),R=y(4195),W=y(5715);const A=(0,R.op)({maxPool_:function k(X,Z,G,it,bt){const K=(0,H._1)(X,"x","maxPool");let et=K,dt=!1;3===K.rank&&(dt=!0,et=(0,W.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]])),q.hu(4===et.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${et.rank}.`),q.hu(Y.jT(G,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${G} and dilations '1'`),Y.m("maxPool",it,bt);const Q=$.BV.runKernel(V.mTV,{x:et},{filterSize:Z,strides:G,pad:it,dimRoundingMode:bt});return dt?(0,W.X)(Q,[Q.shape[1],Q.shape[2],Q.shape[3]]):Q}})},765:(Lt,ut,y)=>{"use strict";y.d(ut,{g:()=>A});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239),R=y(3062);const A=(0,y(4195).op)({maximum_:function k(X,Z){let G=(0,q._1)(X,"a","maximum"),it=(0,q._1)(Z,"b","maximum");return[G,it]=(0,H.makeTypesMatch)(G,it),"bool"===G.dtype&&(G=(0,R.p)(G,"int32"),it=(0,R.p)(it,"int32")),(0,Y.assertAndGetBroadcastShape)(G.shape,it.shape),$.BV.runKernel(V.BMI,{a:G,b:it})}})},9357:(Lt,ut,y)=>{"use strict";y.d(ut,{J:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({mean_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","mean")};return $.BV.runKernel(V.q2K,Z,{axis:k,keepDims:A})}})},9602:(Lt,ut,y)=>{"use strict";y.d(ut,{V:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({min_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","min")};return $.BV.runKernel(V.c17,Z,{axis:k,keepDims:A})}})},2684:(Lt,ut,y)=>{"use strict";y.d(ut,{L:()=>A});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239),R=y(3062);const A=(0,y(4195).op)({minimum_:function k(X,Z){let G=(0,q._1)(X,"a","minimum"),it=(0,q._1)(Z,"b","minimum");return[G,it]=(0,H.makeTypesMatch)(G,it),"bool"===G.dtype&&(G=(0,R.p)(G,"int32"),it=(0,R.p)(it,"int32")),(0,Y.assertAndGetBroadcastShape)(G.shape,it.shape),$.BV.runKernel(V.q8u,{a:G,b:it})}})},4639:(Lt,ut,y)=>{"use strict";y.d(ut,{V:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({mirrorPad_:function R(k,A,X){q.hu("reflect"===X||"symmetric"===X,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${X}.`);const Z=(0,H._1)(k,"x","mirrorPad");if(0===Z.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");q.hu(A.length===Z.rank,()=>`Padding doesn't match input. Must be ${Z.rank}. Got ${A.length}.`);const G="reflect"===X?1:0;for(let K=0;K<Z.rank;K++)q.hu(2===A[K].length,()=>"Invalid number of paddings. Must be length of 2 each."),q.hu(A[K][0]>=0&&A[K][0]<=Z.shape[K]-G&&A[K][1]>=0&&A[K][1]<=Z.shape[K]-G,()=>`Padding in dimension ${K} cannot be greater than or equal to ${Z.shape[K]-G} or less than 0 for input of shape ${Z.shape}`);return $.BV.runKernel(V.jQs,{x:Z},{paddings:A,mode:X})}})},1612:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>W});var $=y(687),V=y(4251),H=y(7664),q=y(1257);const W=(0,y(4195).op)({mod_:function R(k,A){let X=(0,q._1)(k,"a","mod"),Z=(0,q._1)(A,"b","mod");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.Vbg,{a:X,b:Z})}})},8737:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>W});var $=y(687),V=y(4251),H=y(7664),q=y(1257);const W=(0,y(4195).op)({mul_:function R(k,A){let X=(0,q._1)(k,"a","mul"),Z=(0,q._1)(A,"b","mul");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.wYn,{a:X,b:Z})}})},5048:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({neg_:function Y(W){const A={x:(0,H._1)(W,"x","neg")};return $.BV.runKernel(V.kuV,A)}})},3717:(Lt,ut,y)=>{"use strict";y.d(ut,{K:()=>st});var $=y(1257),V=y(5359),H=y(6989),q=y(929),Y=y(3043),R=y(9602),W=y(4195),k=y(2962),A=y(5715),X=y(8661),Z=y(930),G=y(7527),it=y(9929);function K(et,dt,lt=null){if(0===et.rank)return(0,H.W)(et);if(1!==et.rank&&null===lt)return K((0,A.X)(et,[-1]),dt,lt);if(1===et.rank||"number"==typeof lt||Array.isArray(lt)&&1===lt.length){if(1===dt)return(0,it.S)((0,H.W)(et),lt);if(dt===1/0)return(0,Y.F)((0,H.W)(et),lt);if(dt===-1/0)return(0,R.V)((0,H.W)(et),lt);if("euclidean"===dt||2===dt)return(0,Z._)((0,it.S)((0,k.s)((0,H.W)(et),(0,X.i)(2,"int32")),lt));throw new Error(`Error in norm: invalid ord value: ${dt}`)}if(Array.isArray(lt)&&2===lt.length){if(1===dt)return(0,Y.F)((0,it.S)((0,H.W)(et),lt[0]),lt[1]-1);if(dt===1/0)return(0,Y.F)((0,it.S)((0,H.W)(et),lt[1]),lt[0]);if(dt===-1/0)return(0,R.V)((0,it.S)((0,H.W)(et),lt[1]),lt[0]);if("fro"===dt||"euclidean"===dt)return(0,Z._)((0,it.S)((0,G.h)(et),lt));throw new Error(`Error in norm: invalid ord value: ${dt}`)}throw new Error(`Error in norm: invalid axis: ${lt}`)}const st=(0,W.op)({norm_:function bt(et,dt="euclidean",lt=null,St=!1){const Q=K(et=(0,$._1)(et,"x","norm"),dt,lt);let ft=Q.shape;if(St){const pt=(0,V.EC)(lt,et.shape);ft=q.rv(Q.shape,pt)}return(0,A.X)(Q,ft)}})},4015:(Lt,ut,y)=>{"use strict";y.d(ut,{Q:()=>k});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239);const k=(0,y(4195).op)({notEqual_:function W(A,X){let Z=(0,q._1)(A,"a","notEqual","string_or_numeric"),G=(0,q._1)(X,"b","notEqual","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.yQU,{a:Z,b:G})}})},5618:(Lt,ut,y)=>{"use strict";y.d(ut,{l:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({oneHot_:function Y(W,k,A=1,X=0,Z="int32"){if(k<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${k}`);const it={indices:(0,H._1)(W,"indices","oneHot","int32")};return $.BV.runKernel(V.we_,it,{dtype:Z,depth:k,onValue:A,offValue:X})}})},4968:(Lt,ut,y)=>{"use strict";y.d(ut,{i:()=>Y});var $=y(687),V=y(5359),H=y(3037),q=y(6467);function Y(R,W="float32"){if((0,V.Mu)(R),"complex64"===W){const A=Y(R,"float32"),X=(0,q.l)(R,"float32");return(0,H.P)(A,X)}const k=(0,V.p8)((0,V.NA)(R),W);return $.BV.makeTensor(k,R,W)}},5034:(Lt,ut,y)=>{"use strict";y.d(ut,{J:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({onesLike_:function Y(W){const A={x:(0,H._1)(W,"x","onesLike")};return $.BV.runKernel(V.qWM,A)}})},4195:(Lt,ut,y)=>{"use strict";y.d(ut,{op:()=>q,z:()=>H});var $=y(687),V=y(5359);const H="__op";function q(Y){const R=Object.keys(Y);if(1!==R.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${R.length} keys.`);let W=R[0];const k=Y[W];W.endsWith("_")&&(W=W.substring(0,W.length-1)),W+=H;const A=(...X)=>{$.BV.startScope(W);try{const Z=k(...X);return(0,V.tI)(Z)&&console.error("Cannot return a Promise inside of tidy."),$.BV.endScope(Z),Z}catch(Z){throw $.BV.endScope(null),Z}};return Object.defineProperty(A,"name",{value:W,configurable:!0}),A}},3667:(Lt,ut,y)=>{"use strict";y.d(ut,{zvA:()=>X.z,WnP:()=>V.W,Khb:()=>H.K,__u:()=>q._,IHx:()=>Y.I,QBD:()=>G,$6P:()=>it.$,YjB:()=>bt.Y,NqF:()=>K.N,vHJ:()=>st.v,ZRM:()=>et.Z,VfV:()=>dt.V,z4N:()=>lt.z,fvJ:()=>St.f,C80:()=>Q.C,wS1:()=>ft.w,uR5:()=>at,zEQ:()=>Mt,tgs:()=>re.t,Dxk:()=>ee,JY5:()=>se,p3b:()=>Me,E4h:()=>It.E,yE8:()=>Ue,ycw:()=>Tn,anm:()=>D,XsQ:()=>ne,UFq:()=>pe.U,f3b:()=>Ie.f,pju:()=>pt.p,mDi:()=>Je.m,iUl:()=>Gn.i,d9v:()=>Er.d,PYB:()=>Nn.P,zoF:()=>nt.z,gME:()=>hi,Izb:()=>to,MNy:()=>yn,ZaL:()=>Eo,PAt:()=>Hn.P,Tek:()=>Hs.T,bc:()=>Ce.b,pdZ:()=>Rt,$QV:()=>ie,mCk:()=>ze.m,f9Y:()=>Oe.f,mew:()=>cr,$Gn:()=>je.$,zbp:()=>Xt.z,ppE:()=>ue,nTT:()=>en.n,B10:()=>mn.B,Ka3:()=>tr,WmZ:()=>dr.W,hiC:()=>zn.h,NTj:()=>vn.N,AKD:()=>sr.A,rvX:()=>na,WYO:()=>Qn,pyx:()=>wr.p,GRh:()=>fa,EDe:()=>si,DgJ:()=>Rr.D,qNN:()=>er.q,d2q:()=>Zi.d,Qqt:()=>fi.Q,dt4:()=>oi.d,t$B:()=>zr.t,iyy:()=>Es,kp_:()=>ja.k,hlL:()=>Ks.h,GWj:()=>Ss.G,qPi:()=>ti.q,imm:()=>$,Iqj:()=>Vr.I,dbB:()=>Qi,pjt:()=>Co.p,brS:()=>Ls.b,Sxn:()=>wa.S,asL:()=>Pa.a,BHj:()=>tl,V3u:()=>Sl,wx0:()=>qs.w,xVT:()=>rs.x,UWc:()=>Oa.U,i2d:()=>eo.i,hi7:()=>wo.h,d9m:()=>ys.d,zN1:()=>Wa.z,$r2:()=>G1,SX3:()=>bu,G9k:()=>Ra.G,cM7:()=>$r.c,Krr:()=>pr.K,e_t:()=>fu.e,CmS:()=>Xs.C,l_t:()=>Ga.l,HvI:()=>ss.H,hJK:()=>An.h,K5V:()=>jr.K,egP:()=>qn.e,MB5:()=>H1,eab:()=>Yu,OI3:()=>Gt.O,Fp7:()=>ya.F,_sB:()=>Xn._,YQQ:()=>Yi,Ip$:()=>an,gWQ:()=>ei.g,J69:()=>Fn.J,ry_:()=>ks,VV$:()=>Ur.V,LTh:()=>We.L,VdP:()=>Kr.V,wQq:()=>mr.w,Gi7:()=>Wr,p_:()=>ye,dC7:()=>O.d,rq4:()=>os,SJ_:()=>$o,W76:()=>Or.W,KOy:()=>mt.K,Quu:()=>as.Q,lfX:()=>_e.l,iUs:()=>Ds.i,JpU:()=>z.J,op:()=>X.op,N2O:()=>M,vku:()=>tt.v,pNR:()=>At,koy:()=>kt,t1L:()=>nn,lGY:()=>$e,d_R:()=>Cn.d,sQ3:()=>$n.s,AL3:()=>Vn.A,S0v:()=>vr.S,WVs:()=>wn.W,$gW:()=>ni,VT$:()=>Xr,N89:()=>Su,TN_:()=>qi,wzB:()=>Ir,nGf:()=>Gr,ruB:()=>he,LGj:()=>jl,pe5:()=>Br,w6H:()=>es,kwC:()=>ru.k,M25:()=>iu.M,UYe:()=>ls.U,btT:()=>Fs.b,XLQ:()=>ot.X,GYS:()=>va.G,SDf:()=>_a,diP:()=>Jo,sx7:()=>Mo,mG2:()=>la,QEs:()=>ea.Q,NMM:()=>xa.N,bp0:()=>cs.b,iD$:()=>mo.i,snQ:()=>sn,zcT:()=>bo,U8D:()=>su.U,U_I:()=>Ys.U,ODp:()=>mi,XD2:()=>Ct.X,Xxe:()=>yi.X,tdS:()=>Oh,O$l:()=>ka.O,R_K:()=>Du.R,tPi:()=>yt.t,jZU:()=>pl,SmN:()=>Wo,CnO:()=>Tu,p0P:()=>Go,XAC:()=>Ca.X,Wvh:()=>Nu.W,fBT:()=>gu.f,rVs:()=>j1,ers:()=>Nr,uN7:()=>Dy,Vl2:()=>go.V,_b3:()=>Fa._,h62:()=>Kn.h,$i:()=>yu.$,L9e:()=>So.L,knu:()=>hs.k,Nbs:()=>Do.N,NXj:()=>ca.N,Z_8:()=>kc,luU:()=>Pr.l,Smz:()=>ns.S,ORZ:()=>Il.O,AEp:()=>vt.A,XeE:()=>Au.X,RRF:()=>ds,odF:()=>ha,wOQ:()=>no.w,yXz:()=>Kl,Bfx:()=>Ka,xZs:()=>Yr,Pg0:()=>or,Gg6:()=>js.G,hg7:()=>ws.h,p4s:()=>j.p,Xu6:()=>ri,Two:()=>fs.T,pUJ:()=>gt.p,HHK:()=>ct.H,GaM:()=>_t,VD$:()=>Nt,arb:()=>Kt.a,itS:()=>xe,lls:()=>Pe.l,P84:()=>fn.P});var $={};y.r($),y.d($,{conv2d:()=>l,depthwiseConv2d:()=>C,matMul:()=>rt});var V=y(6989),H=y(1184),q=y(5622),Y=y(7066),R=y(687),W=y(4251),k=y(1257),A=y(5359),X=y(4195);const G=(0,X.op)({addN_:function Z(Ht){A.hu(Array.isArray(Ht),()=>"The argument passed to tf.addN() must be a list of tensors"),A.hu(Ht.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${Ht.length}`);const Vt=Ht.map((Zt,Jt)=>(0,k._1)(Zt,`tensors${Jt}`,"addN")),$t=Vt[0];return Vt.forEach(Zt=>{if(Zt.dtype!==$t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),Vt.forEach(Zt=>{if(!A.cO(Zt.shape,$t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),R.BV.runKernel(W.Xze,Vt)}});var it=y(1862),bt=y(876),K=y(5784),st=y(8340),et=y(586),dt=y(8355),lt=y(7881),St=y(5825),Q=y(7932),ft=y(6903),pt=y(3062),B=y(5551),ot=y(5715);const at=(0,X.op)({avgPool3d_:function P(Ht,Vt,$t,Ut,Zt,Jt="NDHWC"){const qt=(0,k._1)(Ht,"x","avgPool3d","float32");let me=qt,Fe=!1;4===qt.rank&&(Fe=!0,me=(0,ot.X)(qt,[1,qt.shape[0],qt.shape[1],qt.shape[2],qt.shape[3]])),A.hu(5===me.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${me.rank}.`),A.hu("NDHWC"===Jt,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${Jt}`),A.hu("number"==typeof $t&&$t>0||Array.isArray($t)&&$t[0]>0&&$t[1]>0&&$t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${$t}'`),(0,B.m)("avgPool3d",Ut,Zt);let hn=R.BV.runKernel(W._k9,{x:me},{filterSize:Vt,strides:$t,pad:Ut,dimRoundingMode:Zt,dataFormat:Jt});return hn=(0,pt.p)(hn,me.dtype),Fe?(0,ot.X)(hn,[hn.shape[1],hn.shape[2],hn.shape[3],hn.shape[4]]):hn}});var nt=y(4111),Gt=y(5592),O=y(8737),Ct=y(6139),yt=y(8317),vt=y(5987);const Mt=(0,X.op)({basicLSTMCell_:function xt(Ht,Vt,$t,Ut,Zt,Jt){const qt=(0,k._1)(Ht,"forgetBias","basicLSTMCell"),me=(0,k._1)(Vt,"lstmKernel","basicLSTMCell"),Fe=(0,k._1)($t,"lstmBias","basicLSTMCell"),He=(0,k._1)(Ut,"data","basicLSTMCell"),ln=(0,k._1)(Zt,"c","basicLSTMCell"),hn=(0,k._1)(Jt,"h","basicLSTMCell"),rr=(0,nt.z)([He,hn],1),fr=(0,Gt.O)(rr,me),vi=(0,Y.I)(fr,Fe),Ei=vi.shape[1]/4,ps=[vi.shape[0],Ei],au=(0,yt.t)(vi,[0,0],ps),qe=(0,yt.t)(vi,[0,Ei],ps),kr=(0,yt.t)(vi,[0,2*Ei],ps),ba=(0,yt.t)(vi,[0,3*Ei],ps),Ci=(0,Y.I)((0,O.d)((0,Ct.X)(au),(0,vt.A)(qe)),(0,O.d)(ln,(0,Ct.X)((0,Y.I)(qt,kr))));return[Ci,(0,O.d)((0,vt.A)(Ci),(0,Ct.X)(ba))]}});var It=y(2782),re=y(5307);const ee=(0,X.op)({batchNorm2d_:function Bt(Ht,Vt,$t,Ut,Zt,Jt){const qt=(0,k._1)(Ht,"x","batchNorm"),me=(0,k._1)(Vt,"mean","batchNorm"),Fe=(0,k._1)($t,"variance","batchNorm");let He,ln;return null!=Zt&&(He=(0,k._1)(Zt,"scale","batchNorm")),null!=Ut&&(ln=(0,k._1)(Ut,"offset","batchNorm")),A.hu(2===qt.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${qt.rank}.`),A.hu(2===me.rank||1===me.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${me.rank}.`),A.hu(2===Fe.rank||1===Fe.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${Fe.rank}.`),null!=He&&A.hu(2===He.rank||1===He.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${He.rank}.`),null!=ln&&A.hu(2===ln.rank||1===ln.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${ln.rank}.`),(0,re.t)(qt,me,Fe,ln,He,Jt)}}),se=(0,X.op)({batchNorm3d_:function jt(Ht,Vt,$t,Ut,Zt,Jt){const qt=(0,k._1)(Ht,"x","batchNorm"),me=(0,k._1)(Vt,"mean","batchNorm"),Fe=(0,k._1)($t,"variance","batchNorm");let He,ln;return null!=Zt&&(He=(0,k._1)(Zt,"scale","batchNorm")),null!=Ut&&(ln=(0,k._1)(Ut,"offset","batchNorm")),A.hu(3===qt.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${qt.rank}.`),A.hu(3===me.rank||1===me.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${me.rank}.`),A.hu(3===Fe.rank||1===Fe.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${Fe.rank}.`),null!=He&&A.hu(3===He.rank||1===He.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${He.rank}.`),null!=ln&&A.hu(3===ln.rank||1===ln.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${ln.rank}.`),(0,re.t)(qt,me,Fe,ln,He,Jt)}}),Me=(0,X.op)({batchNorm4d_:function be(Ht,Vt,$t,Ut,Zt,Jt){const qt=(0,k._1)(Ht,"x","batchNorm"),me=(0,k._1)(Vt,"mean","batchNorm"),Fe=(0,k._1)($t,"variance","batchNorm");let He,ln;return null!=Zt&&(He=(0,k._1)(Zt,"scale","batchNorm")),null!=Ut&&(ln=(0,k._1)(Ut,"offset","batchNorm")),A.hu(4===qt.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${qt.rank}.`),A.hu(4===me.rank||1===me.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${me.rank}.`),A.hu(4===Fe.rank||1===Fe.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${Fe.rank}.`),null!=He&&A.hu(4===He.rank||1===He.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${He.rank}.`),null!=ln&&A.hu(4===ln.rank||1===ln.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${ln.rank}.`),(0,re.t)(qt,me,Fe,ln,He,Jt)}}),Ue=(0,X.op)({bincount_:function Xe(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","bincount"),Zt=(0,k._1)(Vt,"weights","bincount");return A.hu("int32"===Ut.dtype,()=>`Error in bincount: input dtype must be int32, but got ${Ut.dtype}`),A.hu($t>=0,()=>`size must be non-negative, but got ${$t}.`),A.hu(Zt.size===Ut.size||0===Zt.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${Ut.shape}, weights shape: ${Zt.shape}.`),R.BV.runKernel(W.zvY,{x:Ut,weights:Zt},{size:$t})}}),Tn=(0,X.op)({bitwiseAnd_:function De(Ht,Vt){const $t=(0,k._1)(Ht,"x","bitwiseAnd"),Ut=(0,k._1)(Vt,"y","bitwiseAnd");if(!(0,A.cO)($t.shape,Ut.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${$t.shape}, y: ${Ut.shape}`);if("int32"!==$t.dtype||"int32"!==Ut.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${$t.dtype} and type of y: ${Ut.dtype}`);return R.BV.runKernel(W.hCO,{a:$t,b:Ut})}}),ne=(0,X.op)({broadcastArgs_:function On(Ht,Vt){const $t=(0,k._1)(Ht,"s0","broadcastArgs","int32"),Ut=(0,k._1)(Vt,"s1","broadcastArgs","int32");if(1!==$t.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${$t.rank}`);if(1!==Ut.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${Ut.rank}`);return R.BV.runKernel(W.eEB,{s0:$t,s1:Ut})}});var pe=y(983),Ie=y(582),Je=y(9723),Gn=y(6672),Er=y(7315),Nn=y(3037);const hi=(0,X.op)({concat1d_:function Yn(Ht){return(0,nt.z)(Ht,0)}}),to=(0,X.op)({concat2d_:function di(Ht,Vt){return(0,nt.z)(Ht,Vt)}}),yn=(0,X.op)({concat3d_:function ii(Ht,Vt){return(0,nt.z)(Ht,Vt)}}),Eo=(0,X.op)({concat4d_:function Qo(Ht,Vt){return(0,nt.z)(Ht,Vt)}});var Hn=y(8577),Hs=y(4451),Ce=y(8554);const Rt=(0,X.op)({conv3d_:function Et(Ht,Vt,$t,Ut,Zt="NDHWC",Jt=[1,1,1]){const qt=(0,k._1)(Ht,"x","conv3d"),me=(0,k._1)(Vt,"filter","conv3d");let Fe=qt,He=!1;4===qt.rank&&(He=!0,Fe=(0,ot.X)(qt,[1,qt.shape[0],qt.shape[1],qt.shape[2],qt.shape[3]])),A.hu(5===Fe.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${Fe.rank}.`),A.hu(5===me.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${me.rank}.`),A.hu(Fe.shape[4]===me.shape[3],()=>`Error in conv3d: depth of input (${Fe.shape[4]}) must match input depth for filter ${me.shape[3]}.`),A.hu((0,B.jT)($t,Jt),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${$t} and dilations '${Jt}'`),A.hu("NDHWC"===Zt,()=>`Error in conv3d: got dataFormat of ${Zt} but only NDHWC is currently supported.`),A.hu((0,B.U3)(Jt),()=>"Error in conv3D: Dilated rates should be larger than 0."),A.hu((0,B.U3)($t),()=>"Error in conv3D: Strides should be larger than 0.");const rr=R.BV.runKernel(W.x12,{x:Fe,filter:me},{strides:$t,pad:Ut,dataFormat:Zt,dilations:Jt});return He?(0,ot.X)(rr,[rr.shape[1],rr.shape[2],rr.shape[3],rr.shape[4]]):rr}});var te=y(7022);const ie=(0,X.op)({conv3dTranspose_:function oe(Ht,Vt,$t,Ut,Zt){const Jt=(0,k._1)(Ht,"x","conv3dTranspose"),qt=(0,k._1)(Vt,"filter","conv3dTranspose");return(0,te._)($t,Jt,qt,Ut,Zt)}});var ze=y(9018),Oe=y(3237),je=y(9267),Xt=y(7157);const ue=(0,X.op)({denseBincount_:function En(Ht,Vt,$t,Ut=!1){const Zt=(0,k._1)(Ht,"x","denseBincount"),Jt=(0,k._1)(Vt,"weights","denseBincount");return A.hu("int32"===Zt.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${Zt.dtype}`),A.hu(Zt.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${Zt.rank}.`),A.hu($t>=0,()=>`size must be non-negative, but got ${$t}.`),A.hu(Jt.size===Zt.size||0===Jt.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${Zt.shape}, weights shape: ${Jt.shape}.`),R.BV.runKernel(W.QRR,{x:Zt,weights:Jt},{size:$t,binaryOutput:Ut})}});var en=y(3961),mn=y(1172);const tr=(0,X.op)({diag_:function un(Ht){const $t={x:(0,k._1)(Ht,"x","diag")};return R.BV.runKernel(W.$w,$t)}});var dr=y(2395),zn=y(3530),vn=y(4373),sr=y(5106);const Qn=(0,X.op)({einsum_:function Jr(Ht,...Vt){const $t=Vt.map((Zt,Jt)=>(0,k._1)(Zt,`tensors${Jt}`,"einsum"));return R.BV.runKernel(W.$g6,$t,{equation:Ht})}});var wr=y(9529);const si=(0,X.op)({ensureShape_:function Dn(Ht,Vt){const $t=(0,k._1)(Ht,"x","ensureShape","string_or_numeric");if(!(0,A.DK)($t.shape,Vt))throw new Error(`EnsureShape: Shape of tensor ${$t.shape} is not compatible with expected shape ${Vt}`);return Ht}});var Rr=y(4456),er=y(4634),Zi=y(4279),fi=y(5109),oi=y(7228),zr=y(5748),js=y(2005);const Es=(0,X.op)({eye_:function ho(Ht,Vt,$t,Ut="float32"){null==Vt&&(Vt=Ht);const Zt=(0,Ie.f)([Ht,Vt],Ut),Jt=Ht<=Vt?Ht:Vt;for(let me=0;me<Jt;++me)Zt.set(1,me,me);const qt=(0,ot.X)(Zt.toTensor(),[Ht,Vt]);if(null==$t)return qt;if(1===$t.length)return(0,js.G)((0,oi.d)(qt,0),[$t[0],1,1]);if(2===$t.length)return(0,js.G)((0,oi.d)((0,oi.d)(qt,0),0),[$t[0],$t[1],1,1]);if(3===$t.length)return(0,js.G)((0,oi.d)((0,oi.d)((0,oi.d)(qt,0),0),0),[$t[0],$t[1],$t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${$t.length}D.`)}});var Ks=y(2787),Ss=y(8208),ti=y(1030),Vr=y(6117),Co=y(4803),Ls=y(9886),Pa=y(1844),rs=y(8821),Oa=y(8381),eo=y(6483),wo=y(9424),ys=y(2761),Wa=y(2223);function bu(Ht,Vt,$t){if($t<=0)throw new Error("The number of values should be positive.");return R.BV.runKernel(W.e7N,{},{start:Ht,stop:Vt,num:$t})}var Ra=y(1523),$r=y(5919),pr=y(4088),fu=y(4034),Xs=y(6455),Ga=y(6735),ss=y(3080),An=y(6399),jr=y(2693),qn=y(4574);const ga=2147483648,bo=(0,X.op)({searchSorted_:function nr(Ht,Vt,$t="left"){const Ut=(0,k._1)(Ht,"sortedSequence","searchSorted"),Zt=(0,k._1)(Vt,"values","searchSorted"),qt=Zt.shape[Zt.shape.length-1],me=(0,ot.X)(Ut,[-1,Ut.shape[Ut.shape.length-1]]),Fe=(0,ot.X)(Zt,[-1,qt]);if(me.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(me.shape[0]!==Fe.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,A.NA)(Fe.shape)>=ga)throw new Error(`values tensor size must less than ${ga}`);if(me.shape[1]>=ga)throw new Error(`trailing dim_size must less than ${ga} for int32 output type, was ${me.shape[1]}`);return R.BV.runKernel(W.nr8,{sortedSequence:me,values:Fe},{side:$t})}});function Yu(Ht,Vt){return bo(Ht,Vt,"left")}var ya=y(3043),Xn=y(2444);const Yi=(0,X.op)({maxPool3d_:function Cs(Ht,Vt=[1,1,1],$t,Ut,Zt,Jt="NDHWC"){const qt=(0,k._1)(Ht,"x","maxPool3d");let me=qt,Fe=!1;4===qt.rank&&(Fe=!0,me=(0,ot.X)(qt,[1,qt.shape[0],qt.shape[1],qt.shape[2],qt.shape[3]])),A.hu(5===me.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${me.rank}.`),A.hu("NDHWC"===Jt,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${Jt}`),(0,B.m)("maxPool3d",Ut,Zt);const hn=R.BV.runKernel(W.OAf,{x:me},{filterSize:Vt,strides:$t,pad:Ut,dimRoundingMode:Zt,dataFormat:Jt});return Fe?(0,ot.X)(hn,[hn.shape[1],hn.shape[2],hn.shape[3],hn.shape[4]]):hn}}),an=(0,X.op)({maxPoolWithArgmax_:function La(Ht,Vt,$t,Ut,Zt=!1){const qt={x:(0,k._1)(Ht,"x","maxPoolWithArgmax")},Fe=R.BV.runKernel(W.vFR,qt,{filterSize:Vt,strides:$t,pad:Ut,includeBatchInIndex:Zt});return{result:Fe[0],indexes:Fe[1]}}});var ei=y(765),Fn=y(9357),Ds=y(4968),Io=y(4945);function ks(Ht,Vt,{indexing:$t="xy"}={}){if("xy"!==$t&&"ij"!==$t)throw new TypeError(`${$t} is not a valid third argument to meshgrid`);if(void 0===Ht)return[];let Ut=(0,k._1)(Ht,"x","meshgrid",Ht instanceof Io.es?Ht.dtype:"float32");if(void 0===Vt)return[Ut];let Zt=(0,k._1)(Vt,"y","meshgrid",Vt instanceof Io.es?Vt.dtype:"float32");const Jt=(0,A.NA)(Ut.shape),qt=(0,A.NA)(Zt.shape);return"xy"===$t?(Ut=(0,ot.X)(Ut,[1,-1]),Zt=(0,ot.X)(Zt,[-1,1]),[(0,Gt.O)((0,Ds.i)([qt,1],Ut.dtype),Ut),(0,Gt.O)(Zt,(0,Ds.i)([1,Jt],Zt.dtype))]):(Ut=(0,ot.X)(Ut,[-1,1]),Zt=(0,ot.X)(Zt,[1,-1]),[(0,Gt.O)(Ut,(0,Ds.i)([1,qt],Ut.dtype)),(0,Gt.O)((0,Ds.i)([Jt,1],Zt.dtype),Zt)])}var Ur=y(9602),We=y(2684),Kr=y(4639),mr=y(1612),ai=y(929),Kn=y(7527),Pr=y(1191);const Wr=(0,X.op)({moments_:function br(Ht,Vt=null,$t=!1){Ht=(0,k._1)(Ht,"x","moments");const Ut=(0,A.EC)(Vt,Ht.shape),Zt=(0,Fn.J)(Ht,Ut,$t);let Jt=Zt.shape;$t||(Jt=(0,ai.rv)(Zt.shape,Ut));const qt=(0,Kn.h)((0,Pr.l)((0,pt.p)(Ht,"float32"),(0,ot.X)(Zt,Jt)));return{mean:Zt,variance:(0,Fn.J)(qt,Ut,$t)}}}),os=(0,X.op)({multiRNNCell_:function Ts(Ht,Vt,$t,Ut){const Zt=(0,k._1)(Vt,"data","multiRNNCell"),Jt=(0,k.sI)($t,"c","multiRNNCell"),qt=(0,k.sI)(Ut,"h","multiRNNCell");let me=Zt;const Fe=[];for(let hn=0;hn<Ht.length;hn++){const rr=Ht[hn](me,Jt[hn],qt[hn]);Fe.push(rr[0]),Fe.push(rr[1]),me=rr[1]}const He=[],ln=[];for(let hn=0;hn<Fe.length;hn+=2)He.push(Fe[hn]),ln.push(Fe[hn+1]);return[He,ln]}}),$o=(0,X.op)({multinomial_:function Iu(Ht,Vt,$t,Ut=!1){const Zt=(0,k._1)(Ht,"logits","multinomial"),Jt=Zt.size,qt=Zt.rank;if(Jt<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${Jt}.`);if(qt>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${qt}`);$t=$t||Math.random();const Fe={logits:1===qt?(0,ot.X)(Zt,[1,-1]):Zt},ln=R.BV.runKernel(W.NZg,Fe,{numSamples:Vt,seed:$t,normalized:Ut});return 1===qt?(0,ot.X)(ln,[ln.size]):ln}});var Or=y(5048),as=y(4015),_e=y(5618),z=y(5034);const M=(0,X.op)({outerProduct_:function I(Ht,Vt){const $t=(0,k._1)(Ht,"v1","outerProduct"),Ut=(0,k._1)(Vt,"v2","outerProduct");A.hu(1===$t.rank&&1===Ut.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${$t.rank} and ${Ut.rank}.`);const Zt=(0,ot.X)($t,[-1,1]),Jt=(0,ot.X)(Ut,[1,-1]);return(0,Gt.O)(Zt,Jt)}});var tt=y(404);const At=(0,X.op)({pad1d_:function wt(Ht,Vt,$t=0){return(0,A.hu)(2===Vt.length,()=>"Invalid number of paddings. Must be length of 2."),(0,tt.v)(Ht,[Vt],$t)}}),kt=(0,X.op)({pad2d_:function Yt(Ht,Vt,$t=0){return(0,A.hu)(2===Vt.length&&2===Vt[0].length&&2===Vt[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,tt.v)(Ht,Vt,$t)}}),nn=(0,X.op)({pad3d_:function ae(Ht,Vt,$t=0){return(0,A.hu)(3===Vt.length&&2===Vt[0].length&&2===Vt[1].length&&2===Vt[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,tt.v)(Ht,Vt,$t)}}),$e=(0,X.op)({pad4d_:function Ye(Ht,Vt,$t=0){return(0,A.hu)(4===Vt.length&&2===Vt[0].length&&2===Vt[1].length&&2===Vt[2].length&&2===Vt[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,tt.v)(Ht,Vt,$t)}});var Cn=y(1640),$n=y(2962),Vn=y(1584),vr=y(3006),wn=y(794);const ni=(0,X.op)({raggedGather_:function _r(Ht,Vt,$t,Ut){const Zt=Ht.map((ln,hn)=>(0,k._1)(ln,`tensors${hn}`,"raggedGather","int32")),Jt=(0,k._1)(Vt,"paramsDenseValues","raggedGather"),qt=(0,k._1)($t,"indices","raggedGather","int32"),He=R.BV.runKernel(W.dDz,{paramsNestedSplits:Zt,paramsDenseValues:Jt,indices:qt},{outputRaggedRank:Ut});return{outputNestedSplits:He.slice(0,He.length-1),outputDenseValues:He[He.length-1]}}}),Xr=(0,X.op)({raggedRange_:function Zs(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"starts","raggedRange"),Zt=(0,k._1)(Vt,"limits","raggedRange",Ut.dtype),Jt=(0,k._1)($t,"deltas","raggedRange",Ut.dtype),me=R.BV.runKernel(W.CQl,{starts:Ut,limits:Zt,deltas:Jt});return{rtNestedSplits:me[0],rtDenseValues:me[1]}}}),Su=(0,X.op)({raggedTensorToTensor_:function tn(Ht,Vt,$t,Ut,Zt){const Jt=(0,k._1)(Ht,"shape","raggedTensorToTensor","int32"),qt=(0,k._1)(Vt,"values","raggedTensorToTensor"),me=(0,k._1)($t,"defaultValue","raggedTensorToTensor",qt.dtype),Fe=Ut.map((hn,rr)=>(0,k._1)(hn,`tensors${rr}`,"raggedTensorToTensor","int32"));return R.BV.runKernel(W.BiW,{shape:Jt,values:qt,defaultValue:me,rowPartitionTensors:Fe},{rowPartitionTypes:Zt})}}),qi=(0,X.op)({rand_:function xr(Ht,Vt,$t){(0,A.Mu)(Ht);const Ut=(0,A.NA)(Ht);let Zt=null;if(null==$t||"float32"===$t)Zt=new Float32Array(Ut);else if("int32"===$t)Zt=new Int32Array(Ut);else{if("bool"!==$t)throw new Error(`Unknown data type ${$t}`);Zt=new Uint8Array(Ut)}for(let Jt=0;Jt<Ut;Jt++)Zt[Jt]=Vt();return R.BV.makeTensor(Zt,Ht,$t)}});var fo=y(9128);class vs{constructor(Vt,$t,Ut,Zt,Jt){this.mean=Vt,this.stdDev=$t,this.dtype=Ut,this.nextVal=NaN,this.truncated=Zt,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const qt=Jt||Math.random();this.random=fo.alea(qt.toString())}nextValue(){if(!isNaN(this.nextVal)){const Zt=this.nextVal;return this.nextVal=NaN,Zt}let Vt,$t,Ut=!1;for(;!Ut;){let Zt,Jt,qt;do{Zt=2*this.random()-1,Jt=2*this.random()-1,qt=Zt*Zt+Jt*Jt}while(qt>=1||0===qt);const me=Math.sqrt(-2*Math.log(qt)/qt);Vt=this.mean+this.stdDev*Zt*me,$t=this.mean+this.stdDev*Jt*me,(!this.truncated||this.isValidTruncated(Vt))&&(Ut=!0)}return(!this.truncated||this.isValidTruncated($t))&&(this.nextVal=this.convertValue($t)),this.convertValue(Vt)}convertValue(Vt){return null==this.dtype||"float32"===this.dtype?Vt:Math.round(Vt)}isValidTruncated(Vt){return Vt<=this.upper&&Vt>=this.lower}}class ku{constructor(Vt,$t,Ut,Zt){this.alpha=Vt,this.beta=1/$t,this.dtype=Ut;const Jt=Zt||Math.random();this.randu=fo.alea(Jt.toString()),this.randn=new vs(0,1,Ut,!1,this.randu()),this.d=Vt<1?Vt+2/3:Vt-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let Vt,$t,Ut,Zt,Jt,qt;for(;;){do{Zt=this.randn.nextValue(),qt=1+this.c*Zt}while(qt<=0);if(qt*=qt*qt,Vt=Zt*Zt,$t=1-.331*Vt*Vt,Ut=.5*Vt+this.d*(1-qt+Math.log(qt)),Jt=this.randu(),Jt<$t||Math.log(Jt)<Ut)break}return qt*=1/this.beta*this.d,this.alpha<1&&(qt*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(qt)}convertValue(Vt){return"float32"===this.dtype?Vt:Math.round(Vt)}}class Rc{constructor(Vt=0,$t=1,Ut,Zt){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=Vt,this.range=$t-Vt,this.dtype=Ut,null==Zt&&(Zt=Math.random()),"number"==typeof Zt&&(Zt=Zt.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${Vt} - ${$t} <= 1 and dtype is not float`);this.random=fo.alea(Zt)}convertValue(Vt){return this.canReturnFloat()?Vt:Math.round(Vt)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ir=(0,X.op)({randomGamma_:function Hl(Ht,Vt,$t=1,Ut="float32",Zt){if((0,A.Mu)(Ht),null==$t&&($t=1),null==Ut&&(Ut="float32"),"float32"!==Ut&&"int32"!==Ut)throw new Error(`Unsupported data type ${Ut}`);const Jt=new ku(Vt,$t,Ut,Zt),qt=(0,Ie.f)(Ht,Ut);for(let me=0;me<qt.values.length;me++)qt.values[me]=Jt.nextValue();return qt.toTensor()}}),Gr=(0,X.op)({randomNormal_:function mu(Ht,Vt=0,$t=1,Ut,Zt){if((0,A.Mu)(Ht),null!=Ut&&"bool"===Ut)throw new Error(`Unsupported data type ${Ut}`);const Jt=new vs(Vt,$t,Ut,!1,Zt),qt=(0,Ie.f)(Ht,Ut);for(let me=0;me<qt.values.length;me++)qt.values[me]=Jt.nextValue();return qt.toTensor()}}),he=(0,X.op)({randomStandardNormal_:function qu(Ht,Vt,$t){if(null!=Vt&&"bool"===Vt)throw new Error(`Unsupported data type ${Vt}`);return Gr(Ht,0,1,Vt,$t)}}),jl=(0,X.op)({randomUniform_:function zo(Ht,Vt=0,$t=1,Ut="float32",Zt){(0,A.Mu)(Ht);const Jt=(0,Ie.f)(Ht,Ut),qt=new Rc(Vt,$t,null,Zt);for(let me=0;me<Jt.values.length;me++)Jt.values[me]=qt.nextValue();return Jt.toTensor()}}),Br=(0,X.op)({randomUniformInt_:function Fu(Ht,Vt,$t,Ut){return jl(Ht,Vt,$t,"int32",Ut)}});function es(Ht,Vt,$t=1,Ut="float32"){if(0===$t)throw new Error("Cannot have a step of zero");return R.BV.runKernel(W.e6w,{},{start:Ht,stop:Vt,step:$t,dtype:Ut})}var ru=y(6027),iu=y(4831),ls=y(8586),Fs=y(4917),va=y(6825);const _a=(0,X.op)({reverse1d_:function Vo(Ht){const Vt=(0,k._1)(Ht,"x","reverse");return A.hu(1===Vt.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${Vt.rank}.`),(0,va.G)(Vt,0)}}),Jo=(0,X.op)({reverse2d_:function po(Ht,Vt){const $t=(0,k._1)(Ht,"x","reverse");return A.hu(2===$t.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${$t.rank}.`),(0,va.G)($t,Vt)}}),Mo=(0,X.op)({reverse3d_:function Wn(Ht,Vt){const $t=(0,k._1)(Ht,"x","reverse");return A.hu(3===$t.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${$t.rank}.`),(0,va.G)($t,Vt)}}),la=(0,X.op)({reverse4d_:function Mn(Ht,Vt){const $t=(0,k._1)(Ht,"x","reverse");return A.hu(4===$t.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${$t.rank}.`),(0,va.G)($t,Vt)}});var xa=y(1974),cs=y(8893),mo=y(8661),su=y(9614),Ys=y(6762),$s=y(5861);function Ea(){return(Ea=(0,$s.Z)(function*(Ht,Vt){const $t=(0,k._1)(Ht,"x","setdiff1d"),Ut=(0,k._1)(Vt,"y","setdiff1d");A.hu($t.dtype===Ut.dtype,()=>`x and y should have the same dtype, but got x (${$t.dtype}) and y (${Ut.dtype}).`),A.hu(1===$t.rank,()=>`x should be 1D tensor, but got x (${$t.shape}).`),A.hu(1===Ut.rank,()=>`y should be 1D tensor, but got y (${Ut.shape}).`);const Zt=yield $t.data(),Jt=yield Ut.data(),qt=new Set(Jt);let me=0;for(let ln=0;ln<Zt.length;ln++)qt.has(Zt[ln])||me++;const Fe=new Io.YD([me],$t.dtype),He=new Io.YD([me],"int32");for(let ln=0,hn=0;ln<Zt.length;ln++)qt.has(Zt[ln])||(Fe.values[hn]=Zt[ln],He.values[hn]=ln,hn++);return[Fe.toTensor(),He.toTensor()]})).apply(this,arguments)}const mi=function Uo(Ht,Vt){return Ea.apply(this,arguments)};var yi=y(4058),ka=y(2438),Du=y(319);const pl=(0,X.op)({slice1d_:function Ha(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","slice1d");return A.hu(1===Ut.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${Ut.rank} tensor`),(0,yt.t)(Ut,[Vt],[$t])}}),Wo=(0,X.op)({slice2d_:function ta(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","slice2d");return A.hu(2===Ut.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${Ut.rank} tensor`),(0,yt.t)(Ut,Vt,$t)}}),Tu=(0,X.op)({slice3d_:function Ns(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","slice3d");return A.hu(3===Ut.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${Ut.rank} tensor`),(0,yt.t)(Ut,Vt,$t)}}),Go=(0,X.op)({slice4d_:function Bs(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","slice4d");return A.hu(4===Ut.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${Ut.rank} tensor`),(0,yt.t)(Ut,Vt,$t)}});var Ca=y(8683),Nu=y(4487),gu=y(9619),ja=y(9738),wa=y(527),qs=y(6065),ea=y(1638),go=y(8874),Fa=y(930),yu=y(9539),So=y(2494),hs=y(7958),Do=y(6034),ca=y(5367),ns=y(9929),Il=y(2500),Au=y(3905),Ho=y(7431);function ds(Ht,Vt){(0,A.Cq)(Ht);const $t=(0,k.C)(Ht,Vt);if(1!==$t.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,Ho.H)(Ht,null,$t,Vt)}function ha(Ht,Vt,$t){if((0,A.Cq)(Ht),null!=Vt&&2!==Vt.length)throw new Error("tensor2d() requires shape to have two numbers");const Ut=(0,k.C)(Ht,$t);if(2!==Ut.length&&1!==Ut.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===Ut.length&&null==Vt)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,Ho.H)(Ht,Vt,Ut,$t)}var no=y(2786);function Kl(Ht,Vt,$t){if((0,A.Cq)(Ht),null!=Vt&&4!==Vt.length)throw new Error("tensor4d() requires shape to have four numbers");const Ut=(0,k.C)(Ht,$t);if(4!==Ut.length&&1!==Ut.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===Ut.length&&null==Vt)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,Ho.H)(Ht,Vt,Ut,$t)}function Ka(Ht,Vt,$t){if((0,A.Cq)(Ht),null!=Vt&&5!==Vt.length)throw new Error("tensor5d() requires shape to have five numbers");const Ut=(0,k.C)(Ht,$t);if(5!==Ut.length&&1!==Ut.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===Ut.length&&null==Vt)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,Ho.H)(Ht,Vt,Ut,$t)}function Yr(Ht,Vt,$t){if((0,A.Cq)(Ht),null!=Vt&&6!==Vt.length)throw new Error("tensor6d() requires shape to have six numbers");const Ut=(0,k.C)(Ht,$t);if(6!==Ut.length&&1!==Ut.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===Ut.length&&null==Vt)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return(0,Ho.H)(Ht,Vt=Vt||Ut,Ut,$t)}var da=y(1876);const or=(0,X.op)({tensorScatterUpdate_:function vu(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"tensor","tensorScatterupdate"),Zt=(0,k._1)(Vt,"indices","tensorScatterupdate","int32"),Jt=(0,k._1)($t,"updates","tensorScatterupdate");if(da.validateInput(Jt,Zt,Ut.shape),Ut.dtype!==Jt.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${Ut.dtype} and ${Jt.dtype}.`);return R.BV.runKernel(W.SIB,{tensor:Ut,indices:Zt,updates:Jt},{})}});var ws=y(4927);const ri=(0,X.op)({truncatedNormal_:function Tr(Ht,Vt=0,$t=1,Ut,Zt){if((0,A.Mu)(Ht),null!=Ut&&"bool"===Ut)throw new Error("Unsupported data type $ { dtype }");const Jt=new vs(Vt,$t,Ut,!0,Zt),qt=(0,Ie.f)(Ht,Ut);for(let me=0;me<qt.values.length;me++)qt.values[me]=Jt.nextValue();return qt.toTensor()}});var fs=y(8130),gt=y(7715),ct=y(2219);function _t(Ht,Vt){return bo(Ht,Vt,"right")}function Nt(Ht,Vt=!0,$t,Ut){return R.BV.makeVariable(Ht,Vt,$t,Ut)}var Kt=y(2190),de=y(7349);function Te(){return(Te=(0,$s.Z)(function*(Ht){const Vt=(0,k._1)(Ht,"condition","whereAsync","bool"),$t=yield Vt.data(),Ut=(0,de.Z)(Vt.shape,$t);return Ht!==Vt&&Vt.dispose(),Ut})).apply(this,arguments)}const xe=function Ee(Ht){return Te.apply(this,arguments)};var Pe=y(6467),fn=y(3143);function E(){return(E=(0,$s.Z)(function*(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"tensor","boolMask"),Zt=(0,k._1)(Vt,"mask","boolMask","bool"),Jt=$t??0,qt=Zt.rank,me=Ut.shape;A.hu(qt>0,()=>"mask cannot be scalar"),A.k5(me.slice(Jt,Jt+qt),Zt.shape,"mask's shape must match the first K dimensions of tensor's shape,");let Fe=1;for(let is=Jt;is<Jt+qt;is++)Fe*=me[is];const He=me.slice(0,Jt).concat([Fe],me.slice(Jt+qt)),ln=(0,ot.X)(Ut,He),hn=(0,ot.X)(Zt,[-1]),rr=yield xe(hn),fr=(0,So.L)(rr,[1]),vi=(0,Vr.I)(ln,fr,Jt);return Ht!==Ut&&Ut.dispose(),Vt!==Zt&&Zt.dispose(),fr.dispose(),ln.dispose(),hn.dispose(),rr.dispose(),vi})).apply(this,arguments)}const D=function f(Ht,Vt,$t){return E.apply(this,arguments)};var j=y(9194),mt=y(3717),Ft=y(7664);const ye=(0,X.op)({movingAverage_:function ce(Ht,Vt,$t,Ut,Zt=!0){const Jt=(0,k._1)(Ht,"v","movingAverage"),qt=(0,k._1)(Vt,"x","movingAverage"),me=(0,k._1)($t,"decay","movingAverage");(0,Ft.assertTypesMatch)(Jt,qt),A.hu(A.cO(Jt.shape,qt.shape),()=>"Shape mismatch in v and x");const Fe=(0,mo.i)(1),He=(0,Pr.l)(Fe,me);let ln=(0,O.d)((0,Pr.l)(qt,Jt),He);if(Zt){A.hu(null!=Ut,()=>"When using zeroDebias: true, step is required.");const hn=(0,k._1)(Ut,"step","movingAverage");ln=(0,zn.h)(ln,(0,Pr.l)(Fe,(0,$n.s)(me,hn)))}return(0,Y.I)(Jt,ln)}}),sn=(0,X.op)({scatterND_:function Ve(Ht,Vt,$t){(0,A.Mu)($t);const Ut=(0,k._1)(Ht,"indices","scatterND","int32"),Zt=(0,k._1)(Vt,"updates","scatterND");return da.validateInput(Zt,Ut,$t),R.BV.runKernel(W.xQA,{indices:Ut,updates:Zt},{shape:$t})}}),Nr=(0,X.op)({sparseToDense_:function Pn(Ht,Vt,$t,Ut=0){(0,A.Mu)($t);const Zt=(0,k._1)(Ht,"sparseIndices","sparseToDense","int32"),Jt=(0,k._1)(Vt,"sparseValues","sparseToDense","string_or_numeric"),qt=(0,k._1)(Ut,"defaultValue","sparseToDense",Jt.dtype);return function bn(Ht,Vt,$t,Ut){if("int32"!==Ht.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${Ht.dtype}.`);if(Ht.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${Ht.shape}.`);const Zt=Ht.rank>0?Ht.shape[0]:1,Jt=Ht.rank>1?Ht.shape[1]:1;if($t.length!==Jt)throw new Error(`outputShape has incorrect number of elements:, ${$t.length}, should be: ${Jt}.`);if(0!==Vt.rank&&(1!==Vt.rank||Vt.size!==Zt))throw new Error(`sparseValues has incorrect shape ${Vt.shape}, should be [] or [${Zt}]`);if(Vt.dtype!==Ut.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(Zt,Jt,$t,qt),R.BV.runKernel(W.D2d,{sparseIndices:Zt,sparseValues:Jt,defaultValue:qt},{outputShape:$t})}}),Qi=(0,X.op)({gatherND_:function yo(Ht,Vt){const $t=(0,k._1)(Vt,"indices","gatherND","int32"),Zt={params:(0,k._1)(Ht,"x","gatherND","string_or_numeric"),indices:$t};return R.BV.runKernel(W.q1x,Zt)}}),na=(0,X.op)({dropout_:function jo(Ht,Vt,$t,Ut){const Zt=(0,k._1)(Ht,"x","dropout");if(A.hu("float32"===Zt.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${Zt.dtype} tensor instead.`),A.hu(Vt>=0&&Vt<1,()=>`rate must be a float in the range [0, 1), but got ${Vt}.`),0===Vt)return Ht instanceof Io.es?Zt.clone():Zt;const Jt=function ro(Ht,Vt){if(null==Vt)return Ht.shape.slice();if(A.cO(Ht.shape,Vt))return Vt;if(Ht.shape.length===Vt.length){const $t=[];for(let Ut=0;Ut<Ht.shape.length;Ut++)$t.push(null==Vt[Ut]&&null!=Ht.shape[Ut]?Ht.shape[Ut]:Vt[Ut]);return $t}return Vt}(Zt,$t),qt=1-Vt,me=(0,zn.h)((0,Ss.G)((0,Y.I)(jl(Jt,0,1,"float32",Ut),qt)),qt);return(0,O.d)(Zt,me)}});function fa(Ht){return Math.floor(Math.pow(2,Math.ceil(Math.log(Ht)/Math.log(2))))}function cr(Ht,Vt,$t){const Ut=1-Ht%2,Zt=new Float32Array(Ht);for(let Jt=0;Jt<Ht;++Jt){const qt=2*Math.PI*Jt/(Ht+Ut-1);Zt[Jt]=Vt-$t*Math.cos(qt)}return ds(Zt,"float32")}function Lr(){return(Lr=(0,$s.Z)(function*(Ht,Vt,$t=1){const Ut=(0,k._1)(Ht,"predictions","inTopK"),Zt=(0,k._1)(Vt,"targets","inTopK");(0,A.hu)(Ut.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${Ut.rank}`),(0,A.hu)(Ut.rank-1===Zt.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${Ut.rank} and targets rank ${Zt.rank}`),(0,A.k5)(Ut.shape.slice(0,Ut.shape.length-1),Zt.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const Jt=Ut.shape[Ut.shape.length-1];(0,A.hu)($t>0&&$t<=Jt,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${Jt}), but got ${$t}`);const qt=yield Ut.data(),me=yield Zt.data(),[Fe,He]=[qt.length/Jt,Jt],ln=(0,A.WP)("bool",Fe);for(let hn=0;hn<Fe;hn++){const rr=hn*He,fr=qt.subarray(rr,rr+He),vi=[];for(let is=0;is<fr.length;is++)vi.push({value:fr[is],index:is});vi.sort((is,Ei)=>Ei.value-is.value),ln[hn]=0;for(let is=0;is<$t;is++)if(vi[is].index===me[hn]){ln[hn]=1;break}}return Ht!==Ut&&Ut.dispose(),Vt!==Zt&&Zt.dispose(),(0,Au.X)(ln,Zt.shape,"bool")})).apply(this,arguments)}const Sl=function ou(Ht,Vt){return Lr.apply(this,arguments)};var Qs=y(3537),As=y(3239),bs=y(443),Is=y(5743),ra=y(6254);const l=(0,X.op)({fusedConv2d_:function Qu({x:Ht,filter:Vt,strides:$t,pad:Ut,dataFormat:Zt="NHWC",dilations:Jt=[1,1],dimRoundingMode:qt,bias:me,activation:Fe="linear",preluActivationWeights:He,leakyreluAlpha:ln}){if(!1===(0,ra.uy)(R.BV.state.gradientDepth,Fe=Fe||"linear")){A.hu("NHWC"===Zt,()=>`Error in fused conv2d: got dataFormat of ${Zt} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Ci=(0,Hs.T)(Ht,Vt,$t,Ut,Zt,Jt,qt);return null!=me&&(Ci=(0,Y.I)(Ci,me)),(0,ra.QH)(Ci,Fe,He,ln)}const hn=(0,k._1)(Ht,"x","conv2d","float32"),rr=(0,k._1)(Vt,"filter","conv2d","float32");let fr=hn,vi=!1;3===hn.rank&&(vi=!0,fr=(0,ot.X)(hn,[1,hn.shape[0],hn.shape[1],hn.shape[2]])),A.hu(4===fr.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${fr.rank}.`),A.hu(4===rr.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${rr.rank}.`),B.m("fused conv2d",Ut,qt);const is="NHWC"===Zt?fr.shape[3]:fr.shape[1];A.hu(rr.shape[2]===is,()=>`Error in conv2d: depth of input (${is}) must match input depth for filter ${rr.shape[2]}.`),A.hu(B.jT($t,Jt),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${$t} and dilations '${Jt}'`);const Ei=B.Ix(fr.shape,rr.shape,$t,Jt,Ut,qt);let ps,au;if(null!=me&&(ps=(0,k._1)(me,"bias","fused conv2d"),[ps]=(0,Ft.makeTypesMatch)(ps,hn),"NHWC"===Zt?As.assertAndGetBroadcastShape(Ei.outShape,ps.shape):(A.hu(ps.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${ps.shape.length}.`),A.hu(0===ps.shape.length||ps.shape[0]===Ei.outChannels||1===ps.shape[0],()=>`Error in fused conv2d: bias shape (${ps.shape}) is not compatible with the number of output channels (${Ei.outChannels})`))),null!=He){const Ci=He.shape;if(A.hu(Ci.length<=1||3===Ci.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Ci.length}.`),1===Ci.length)A.hu(1===Ci[0]||Ci[0]===Ei.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Ci}) is not compatible with the number of output channels (${Ei.outChannels}).`);else if(3===Ci.length)try{As.assertAndGetBroadcastShape(Ci,Ei.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${Ci}) is not compatible with the output shape of the conv2d (${Ei.outShape}).`)}au=(0,k._1)(He,"prelu weights","fused conv2d")}const qe=(Ci,wi)=>{A.hu("NHWC"===Zt,()=>`Error in gradient of fused conv2D: got dataFormat of ${Zt} but only NHWC is currently supported.`);const[Po,zs,ms,Oo]=wi,Bu=(0,ra.Fr)(Ci,ms,Fe);A.hu(B.I0(Jt),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${Jt}'`);const Tl=[(0,Is._)(zs.shape,Bu,Po,$t,Ut),(0,bs.p)(zs,Bu,Po.shape,$t,Ut)];if(null!=Oo){const Ia=(0,ra.pf)(Oo,Bu);Tl.push(Ia)}return Tl},kr={x:fr,filter:rr,bias:ps,preluActivationWeights:au},ba={strides:$t,pad:Ut,dataFormat:Zt,dilations:Jt,dimRoundingMode:qt,activation:Fe,leakyreluAlpha:ln};return null==me?(0,Qs.cb)((wi,Po,zs)=>{let ms=R.BV.runKernel(W._V0,kr,ba);return zs([Po,wi,ms]),vi&&(ms=(0,ot.X)(ms,[ms.shape[1],ms.shape[2],ms.shape[3]])),{value:ms,gradFunc:qe}})(fr,rr):(0,Qs.cb)((wi,Po,zs,ms)=>{let Oo=R.BV.runKernel(W._V0,kr,ba);return ms([Po,wi,Oo,zs]),vi&&(Oo=(0,ot.X)(Oo,[Oo.shape[1],Oo.shape[2],Oo.shape[3]])),{value:Oo,gradFunc:qe}})(fr,rr,ps)}});var h=y(366),m=y(519);const C=(0,X.op)({fusedDepthwiseConv2d_:function _({x:Ht,filter:Vt,strides:$t,pad:Ut,dataFormat:Zt="NHWC",dilations:Jt=[1,1],dimRoundingMode:qt,bias:me,activation:Fe="linear",preluActivationWeights:He,leakyreluAlpha:ln}){if(!1===(0,ra.uy)(R.BV.state.gradientDepth,Fe)){let ba=(0,mn.B)(Ht,Vt,$t,Ut,Zt,Jt,qt);return null!=me&&(ba=(0,Y.I)(ba,me)),(0,ra.QH)(ba,Fe,He,ln)}const hn=(0,k._1)(Ht,"x","depthwiseConv2d","float32"),rr=(0,k._1)(Vt,"filter","depthwiseConv2d","float32");let fr=hn,vi=!1;3===hn.rank&&(vi=!0,fr=(0,ot.X)(hn,[1,hn.shape[0],hn.shape[1],hn.shape[2]])),A.hu(4===fr.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${fr.rank}.`),A.hu(4===rr.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${rr.rank}.`),A.hu(fr.shape[3]===rr.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${fr.shape[3]}) must match the inChannels dimension in filter ${rr.shape[2]}.`),null==Jt&&(Jt=[1,1]),A.hu(B.jT($t,Jt),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${$t} and dilations '${Jt}'`),B.m("fused depthwiseConv2d",Ut,qt);const is=B.Ix(fr.shape,rr.shape,$t,Jt,Ut,qt,!0);let Ei,ps;null!=me&&(Ei=(0,k._1)(me,"bias","fused conv2d"),[Ei]=(0,Ft.makeTypesMatch)(Ei,hn),As.assertAndGetBroadcastShape(is.outShape,Ei.shape)),null!=He&&(ps=(0,k._1)(He,"prelu weights","fused depthwiseConv2d"));const au=(ba,Ci)=>{A.hu(B.I0(Jt),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${Jt}'`);const[wi,Po,zs,ms]=Ci,Oo=(0,ra.Fr)(ba,zs,Fe),Bu=(0,m.v)(Po.shape,Oo,wi,$t,Ut,Jt,qt),el=(0,h.z)(Po,Oo,wi.shape,$t,Ut,Jt,qt);return null!=ms?[Bu,el,(0,ra.pf)(Ei,Oo)]:[Bu,el]},qe={x:fr,filter:rr,bias:Ei,preluActivationWeights:ps},kr={strides:$t,pad:Ut,dataFormat:Zt,dilations:Jt,dimRoundingMode:qt,activation:Fe,leakyreluAlpha:ln};return null==me?(0,Qs.cb)((Ci,wi,Po)=>{let zs=R.BV.runKernel(W.luS,qe,kr);return Po([wi,Ci,zs]),vi&&(zs=(0,ot.X)(zs,[zs.shape[1],zs.shape[2],zs.shape[3]])),{value:zs,gradFunc:au}})(fr,rr):(0,Qs.cb)((Ci,wi,Po,zs)=>{let ms=R.BV.runKernel(W.luS,qe,kr);return zs([wi,Ci,ms,Po]),vi&&(ms=(0,ot.X)(ms,[ms.shape[1],ms.shape[2],ms.shape[3]])),{value:ms,gradFunc:au}})(fr,rr,Ei)}}),rt=(0,X.op)({fusedMatMul_:function F({a:Ht,b:Vt,transposeA:$t=!1,transposeB:Ut=!1,bias:Zt,activation:Jt="linear",preluActivationWeights:qt,leakyreluAlpha:me=.2}){if(!1===(0,ra.uy)(R.BV.state.gradientDepth,Jt)){let Oo=(0,Gt.O)(Ht,Vt,$t,Ut);return null!=Zt&&(Oo=(0,Y.I)(Oo,Zt)),(0,ra.QH)(Oo,Jt,qt,me)}let Fe=(0,k._1)(Ht,"a","fused matMul"),He=(0,k._1)(Vt,"b","fused matMul");[Fe,He]=(0,Ft.makeTypesMatch)(Fe,He);const ln=$t?Fe.shape[Fe.rank-2]:Fe.shape[Fe.rank-1],hn=Ut?He.shape[He.rank-1]:He.shape[He.rank-2],rr=$t?Fe.shape[Fe.rank-1]:Fe.shape[Fe.rank-2],fr=Ut?He.shape[He.rank-2]:He.shape[He.rank-1],vi=Fe.shape.slice(0,-2),is=He.shape.slice(0,-2),Ei=A.NA(vi),ps=A.NA(is);A.hu(ln===hn,()=>`Error in fused matMul: inner shapes (${ln}) and (${hn}) of Tensors with shapes ${Fe.shape} and ${He.shape} and transposeA=${$t} and transposeB=${Ut} must match.`);const qe=As.assertAndGetBroadcastShape(Fe.shape.slice(0,-2),He.shape.slice(0,-2)).concat([rr,fr]),kr=(0,ot.X)(Fe,$t?[Ei,ln,rr]:[Ei,rr,ln]),ba=(0,ot.X)(He,Ut?[ps,fr,hn]:[ps,hn,fr]);let Ci,wi;null!=Zt&&(Ci=(0,k._1)(Zt,"bias","fused matMul"),[Ci]=(0,Ft.makeTypesMatch)(Ci,Fe),As.assertAndGetBroadcastShape(qe,Ci.shape)),null!=qt&&(wi=(0,k._1)(qt,"prelu weights","fused matMul"));const Po=(Oo,Bu)=>{const[el,Dl,Tl,Ia]=Bu,uu=(0,ra.Fr)((0,ot.X)(Oo,Tl.shape),Tl,Jt);let uh,Nl;return $t||Ut?!$t&&Ut?(uh=(0,Gt.O)(uu,Dl,!1,!1),Nl=(0,Gt.O)(uu,el,!0,!1)):$t&&!Ut?(uh=(0,Gt.O)(Dl,uu,!1,!0),Nl=(0,Gt.O)(el,uu,!1,!1)):(uh=(0,Gt.O)(Dl,uu,!0,!0),Nl=(0,Gt.O)(uu,el,!0,!0)):(uh=(0,Gt.O)(uu,Dl,!1,!0),Nl=(0,Gt.O)(el,uu,!0,!1)),null!=Zt?[uh,Nl,(0,ra.pf)(Ia,uu)]:[uh,Nl]},zs={a:kr,b:ba,bias:Ci,preluActivationWeights:wi},ms={transposeA:$t,transposeB:Ut,activation:Jt,leakyreluAlpha:me};return null==Zt?(0,Qs.cb)((Bu,el,Dl)=>{const Tl=R.BV.runKernel(W.usg,zs,ms);return Dl([Bu,el,Tl]),{value:(0,ot.X)(Tl,qe),gradFunc:Po}})(kr,ba):(0,Qs.cb)((Bu,el,Dl,Tl)=>{const Ia=R.BV.runKernel(W.usg,zs,ms);return Tl([Bu,el,Ia,Dl]),{value:(0,ot.X)(Ia,qe),gradFunc:Po}})(kr,ba,Ci)}}),Qt=(0,X.op)({hammingWindow_:function Dt(Ht){return cr(Ht,.54,.46)}}),ke=(0,X.op)({hannWindow_:function fe(Ht){return cr(Ht,.5,.5)}}),_n=(0,X.op)({frame_:function Ge(Ht,Vt,$t,Ut=!1,Zt=0){let Jt=0;const qt=[];for(;Jt+Vt<=Ht.size;)qt.push((0,yt.t)(Ht,Jt,Vt)),Jt+=$t;if(Ut)for(;Jt<Ht.size;){const me=Jt+Vt-Ht.size,Fe=(0,nt.z)([(0,yt.t)(Ht,Jt,Vt-me),(0,Ks.h)([me],Zt)]);qt.push(Fe),Jt+=$t}return 0===qt.length?ha([],[0,Vt]):(0,ot.X)((0,nt.z)(qt),[qt.length,Vt])}}),Un=(0,X.op)({stft_:function Sn(Ht,Vt,$t,Ut,Zt=ke){null==Ut&&(Ut=fa(Vt));const Jt=_n(Ht,Vt,$t),qt=(0,O.d)(Jt,Zt(Vt));return(0,ea.Q)(qt,Ut)}}),Ji=(0,X.op)({cropAndResize_:function ur(Ht,Vt,$t,Ut,Zt="bilinear",Jt=0){const qt=(0,k._1)(Ht,"image","cropAndResize"),me=(0,k._1)(Vt,"boxes","cropAndResize","float32"),Fe=(0,k._1)($t,"boxInd","cropAndResize","int32"),He=me.shape[0];return A.hu(4===qt.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${qt.rank}.`),A.hu(2===me.rank&&4===me.shape[1],()=>`Error in cropAndResize: boxes must be have size [${He},4] but had shape ${me.shape}.`),A.hu(1===Fe.rank&&Fe.shape[0]===He,()=>`Error in cropAndResize: boxInd must be have size [${He}] but had shape ${me.shape}.`),A.hu(2===Ut.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${Ut.length}.`),A.hu(Ut[0]>=1&&Ut[1]>=1,()=>`cropSize must be atleast [1,1], but was ${Ut}`),A.hu("bilinear"===Zt||"nearest"===Zt,()=>`method must be bilinear or nearest, but was ${Zt}`),R.BV.runKernel(W.VcC,{image:qt,boxes:me,boxInd:Fe},{method:Zt,extrapolationValue:Jt,cropSize:Ut})}}),$a=(0,X.op)({flipLeftRight_:function To(Ht){const Vt=(0,k._1)(Ht,"image","flipLeftRight","float32");return A.hu(4===Vt.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${Vt.rank}.`),R.BV.runKernel(W.Uyb,{image:Vt},{})}}),Xl=(0,X.op)({grayscaleToRGB_:function ml(Ht){const Vt=(0,k._1)(Ht,"image","grayscaleToRGB"),$t=Vt.rank-1,Ut=Vt.shape[$t];A.hu(Vt.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${Vt.rank}.`),A.hu(1===Ut,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${Ut}.`);const Zt=new Array(Vt.rank);return Zt.fill(1,0,$t),Zt[$t]=3,(0,js.G)(Vt,Zt)}}),bS=(0,X.op)({rgbToGrayscale_:function uf(Ht){const Vt=(0,k._1)(Ht,"image","RGBToGrayscale"),Ut=Vt.shape[Vt.rank-1];A.hu(Vt.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${Vt.rank}.`),A.hu(3===Ut,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${Ut}.`);const Zt=Vt.dtype,Jt=(0,pt.p)(Vt,"float32"),qt=ds([.2989,.587,.114]);let me;switch(Vt.rank){case 2:me=Qn("ij,j->i",Jt,qt);break;case 3:me=Qn("ijk,k->ij",Jt,qt);break;case 4:me=Qn("ijkl,l->ijk",Jt,qt);break;case 5:me=Qn("ijklm,m->ijkl",Jt,qt);break;case 6:me=Qn("ijklmn,n->ijklm",Jt,qt);break;default:throw new Error("Not a valid tensor rank.")}return me=(0,oi.d)(me,-1),(0,pt.p)(me,Zt)}}),SS=(0,X.op)({rotateWithOffset_:function IS(Ht,Vt,$t=0,Ut=.5){const Zt=(0,k._1)(Ht,"image","rotateWithOffset","float32");return A.hu(4===Zt.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${Zt.rank}.`),R.BV.runKernel(W.b9H,{image:Zt},{radians:Vt,fillValue:$t,center:Ut})}});function vd(Ht,Vt,$t,Ut,Zt,Jt){null==Ut&&(Ut=.5),null==Zt&&(Zt=Number.NEGATIVE_INFINITY),null==Jt&&(Jt=0);const qt=Ht.shape[0];return $t=Math.min($t,qt),A.hu(0<=Ut&&Ut<=1,()=>`iouThreshold must be in [0, 1], but was '${Ut}'`),A.hu(2===Ht.rank,()=>`boxes must be a 2D tensor, but was of rank '${Ht.rank}'`),A.hu(4===Ht.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${Ht.shape[1]}`),A.hu(1===Vt.rank,()=>"scores must be a 1D tensor"),A.hu(Vt.shape[0]===qt,()=>`scores has incompatible shape with boxes. Expected ${qt}, but was ${Vt.shape[0]}`),A.hu(0<=Jt&&Jt<=1,()=>`softNmsSigma must be in [0, 1], but was '${Jt}'`),{maxOutputSize:$t,iouThreshold:Ut,scoreThreshold:Zt,softNmsSigma:Jt}}const ay=(0,X.op)({nonMaxSuppression_:function oy(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY){const Jt=(0,k._1)(Ht,"boxes","nonMaxSuppression","float32"),qt=(0,k._1)(Vt,"scores","nonMaxSuppression","float32"),me=vd(Jt,qt,$t,Ut,Zt);return R.BV.runKernel(W.uv1,{boxes:Jt,scores:qt},{maxOutputSize:$t=me.maxOutputSize,iouThreshold:Ut=me.iouThreshold,scoreThreshold:Zt=me.scoreThreshold})}});var uy=y(5672);function ly(){return(ly=(0,$s.Z)(function*(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY){const Jt=(0,k._1)(Ht,"boxes","nonMaxSuppressionAsync"),qt=(0,k._1)(Vt,"scores","nonMaxSuppressionAsync"),me=vd(Jt,qt,$t,Ut,Zt);$t=me.maxOutputSize,Ut=me.iouThreshold,Zt=me.scoreThreshold;const Fe=yield Promise.all([Jt.data(),qt.data()]),He=Fe[0],ln=Fe[1],{selectedIndices:hn}=(0,uy.GP)(He,ln,$t,Ut,Zt);return Jt!==Ht&&Jt.dispose(),qt!==Vt&&qt.dispose(),ds(hn,"int32")})).apply(this,arguments)}const TS=(0,X.op)({nonMaxSuppressionWithScore_:function Lc(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY,Jt=0){const qt=(0,k._1)(Ht,"boxes","nonMaxSuppression"),me=(0,k._1)(Vt,"scores","nonMaxSuppression"),Fe=vd(qt,me,$t,Ut,Zt,Jt),hn=R.BV.runKernel(W.W0H,{boxes:qt,scores:me},{maxOutputSize:$t=Fe.maxOutputSize,iouThreshold:Ut=Fe.iouThreshold,scoreThreshold:Zt=Fe.scoreThreshold,softNmsSigma:Jt=Fe.softNmsSigma});return{selectedIndices:hn[0],selectedScores:hn[1]}}});function Ba(){return(Ba=(0,$s.Z)(function*(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY,Jt=0){const qt=(0,k._1)(Ht,"boxes","nonMaxSuppressionAsync"),me=(0,k._1)(Vt,"scores","nonMaxSuppressionAsync"),Fe=vd(qt,me,$t,Ut,Zt,Jt);$t=Fe.maxOutputSize,Ut=Fe.iouThreshold,Zt=Fe.scoreThreshold,Jt=Fe.softNmsSigma;const He=yield Promise.all([qt.data(),me.data()]),ln=He[0],hn=He[1],{selectedIndices:rr,selectedScores:fr}=(0,uy.pA)(ln,hn,$t,Ut,Zt,Jt);return qt!==Ht&&qt.dispose(),me!==Vt&&me.dispose(),{selectedIndices:ds(rr,"int32"),selectedScores:ds(fr)}})).apply(this,arguments)}const cy=(0,X.op)({nonMaxSuppressionPadded_:function gl(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY,Jt=!1){const qt=(0,k._1)(Ht,"boxes","nonMaxSuppression"),me=(0,k._1)(Vt,"scores","nonMaxSuppression"),Fe=vd(qt,me,$t,Ut,Zt,null),vi=R.BV.runKernel(W.cye,{boxes:qt,scores:me},{maxOutputSize:Fe.maxOutputSize,iouThreshold:Fe.iouThreshold,scoreThreshold:Fe.scoreThreshold,padToMaxOutputSize:Jt});return{selectedIndices:vi[0],validOutputs:vi[1]}}});function cf(){return(cf=(0,$s.Z)(function*(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY,Jt=!1){const qt=(0,k._1)(Ht,"boxes","nonMaxSuppressionAsync"),me=(0,k._1)(Vt,"scores","nonMaxSuppressionAsync"),Fe=vd(qt,me,$t,Ut,Zt,null),He=Fe.maxOutputSize,ln=Fe.iouThreshold,hn=Fe.scoreThreshold,[rr,fr]=yield Promise.all([qt.data(),me.data()]),{selectedIndices:vi,validOutputs:is}=(0,uy.qP)(rr,fr,He,ln,hn,Jt);return qt!==Ht&&qt.dispose(),me!==Vt&&me.dispose(),{selectedIndices:ds(vi,"int32"),validOutputs:(0,mo.i)(is,"int32")}})).apply(this,arguments)}var Xp=y(1265),fy=y(7373);const py=(0,X.op)({threshold_:function Zp(Ht,Vt="binary",$t=!1,Ut=.5){const Zt=(0,k._1)(Ht,"image","threshold"),Fe=Zt.shape[0]*Zt.shape[1];let ln,hn,rr,fr,He=(0,O.d)(ds([Ut]),255);if(A.hu(3===Zt.rank,()=>`Error in threshold: image must be rank 3,but got rank ${Zt.rank}.`),A.hu(3===Zt.shape[2]||1===Zt.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${Zt.shape[2]}.`),A.hu("int32"===Zt.dtype||"float32"===Zt.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${Zt.dtype}.`),A.hu("otsu"===Vt||"binary"===Vt,()=>`Method must be binary or otsu, but was ${Vt}`),3===Zt.shape[2]){[ln,hn,rr]=(0,go.V)(Zt,[1,1,1],-1);const Ei=(0,O.d)(ln,.2989),ps=(0,O.d)(hn,.587),au=(0,O.d)(rr,.114);fr=(0,Y.I)((0,Y.I)(Ei,ps),au)}else fr=Ht;"otsu"===Vt&&(He=function Yp(Ht,Vt){let Jt,qt,me,Fe,He,ln,$t=ds([-1]),Ut=ds([0]),Zt=ds([0]);for(let hn=0;hn<Ht.size-1;hn++){Jt=(0,yt.t)(Ht,0,hn+1),qt=(0,yt.t)(Ht,hn+1),He=(0,zn.h)((0,ns.S)(Jt),Vt),ln=(0,zn.h)((0,ns.S)(qt),Vt);const rr=(0,ns.S)((0,O.d)(Jt,es(0,Jt.size)));me=(0,zn.h)(rr,(0,ns.S)(Jt));const fr=(0,Ks.h)(qt.shape,Jt.size),vi=(0,Y.I)(es(0,qt.size),fr),is=(0,O.d)(qt,vi);Fe=(0,zn.h)((0,ns.S)(is),(0,ns.S)(qt));const Ei=(0,Pr.l)(me,Fe),ps=(0,Pr.l)(me,Fe),au=(0,O.d)(He,ln);Zt=(0,O.d)((0,O.d)(au,Ei),ps);const qe=(0,Co.p)(Zt,Ut);Ut=(0,Kt.a)(qe,Zt,Ut),$t=(0,Kt.a)(qe,ds([hn]),$t)}return $t}(Ue((0,pt.p)((0,xa.N)(fr),"int32"),(0,Au.X)([]),256),Fe));const vi=$t?(0,Wa.z)(fr,He):(0,Co.p)(fr,He);return(0,pt.p)((0,O.d)(vi,255),"int32")}}),gy=(0,X.op)({transform_:function my(Ht,Vt,$t="nearest",Ut="constant",Zt=0,Jt){const qt=(0,k._1)(Ht,"image","transform","float32"),me=(0,k._1)(Vt,"transforms","transform","float32");return A.hu(4===qt.rank,()=>`Error in transform: image must be rank 4,but got rank ${qt.rank}.`),A.hu(2===me.rank&&(me.shape[0]===qt.shape[0]||1===me.shape[0])&&8===me.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A.hu(null==Jt||2===Jt.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${Jt}.`),R.BV.runKernel(W.wx7,{image:qt,transforms:me},{interpolation:$t,fillMode:Ut,fillValue:Zt,outputShape:Jt})}}),_d=(0,X.op)({bandPart_:function hf(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"a","bandPart");(0,A.hu)(Ut.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${Ut.rank}.`);const Zt=Ut.shape,[Jt,qt]=Ut.shape.slice(-2);let me,Fe;"number"==typeof Vt?((0,A.hu)(Vt%1==0,()=>`bandPart(): numLower must be an integer, got ${Vt}.`),(0,A.hu)(Vt<=Jt,()=>`bandPart(): numLower (${Vt}) must not be greater than the number of rows (${Jt}).`),me=(0,k._1)(Vt<0?Jt:Vt,"numLower","bandPart")):((0,A.hu)("int32"===Vt.dtype,()=>"bandPart(): numLower's dtype must be an int32."),me=(0,Kt.a)((0,ys.d)(Vt,0),Jt,(0,We.L)(Vt,Jt))),"number"==typeof $t?((0,A.hu)($t%1==0,()=>`bandPart(): numUpper must be an integer, got ${$t}.`),(0,A.hu)($t<=qt,()=>`bandPart(): numUpper (${$t}) must not be greater than the number of columns (${qt}).`),Fe=(0,k._1)($t<0?qt:$t,"numUpper","bandPart")):((0,A.hu)("int32"===$t.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),Fe=(0,Kt.a)((0,ys.d)($t,0),qt,(0,We.L)($t,qt)));const He=(0,ot.X)(es(0,Jt,1,"int32"),[-1,1]),ln=es(0,qt,1,"int32"),hn=(0,Pr.l)(He,ln),rr=(0,ss.H)((0,Wa.z)(hn,me),(0,Ls.b)(hn,(0,Or.W)(Fe))),fr=(0,Pe.l)([Jt,qt],Ut.dtype);return(0,ot.X)((0,hs.k)((0,ct.H)((0,ot.X)(Ut,[-1,Jt,qt])).map(vi=>(0,Kt.a)(rr,vi,fr))),Zt)}}),yy=(0,X.op)({gramSchmidt_:function Ph(Ht){let Vt;if(Array.isArray(Ht)){Vt=!1,(0,A.hu)(null!=Ht&&Ht.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const Zt=Ht[0].shape[0];for(let Jt=1;Jt<Ht.length;++Jt)(0,A.hu)(Ht[Jt].shape[0]===Zt,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${Ht[Jt].shape[0]} vs. ${Zt})`)}else Vt=!0,Ht=(0,go.V)(Ht,Ht.shape[0],0).map(Zt=>(0,So.L)(Zt,[0]));(0,A.hu)(Ht.length<=Ht[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${Ht.length}) exceeds number of dimensions (${Ht[0].shape[0]}).`);const $t=[],Ut=Ht;for(let Zt=0;Zt<Ht.length;++Zt)$t.push(R.BV.tidy(()=>{let Jt=Ut[Zt];if(Zt>0)for(let qt=0;qt<Zt;++qt){const me=(0,O.d)((0,ns.S)((0,O.d)($t[qt],Jt)),$t[qt]);Jt=(0,Pr.l)(Jt,me)}return(0,zn.h)(Jt,(0,mt.K)(Jt,"euclidean"))}));return Vt?(0,hs.k)($t,0):$t}});var AS=y(2773);function N1(Ht,Vt=!1){return R.BV.tidy(()=>{(0,A.hu)(2===Ht.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${Ht.shape.length}D Tensor.`);const $t=Ht.shape[0],Ut=Ht.shape[1];let Zt=Es($t),Jt=(0,Er.d)(Ht);const qt=ha([[1]],[1,1]);let me=(0,Er.d)(qt);const Fe=$t>=Ut?Ut:$t;for(let He=0;He<Fe;++He){const ln=Jt,hn=me,rr=Zt;[me,Jt,Zt]=R.BV.tidy(()=>{const fr=(0,yt.t)(Jt,[He,He],[$t-He,1]),vi=(0,mt.K)(fr),is=(0,yt.t)(Jt,[He,He],[1,1]),Ei=(0,Kt.a)((0,Co.p)(is,0),ha([[-1]]),ha([[1]])),ps=(0,Pr.l)(is,(0,O.d)(Ei,vi)),au=(0,zn.h)(fr,ps);me=1===au.shape[0]?(0,Er.d)(qt):(0,nt.z)([qt,(0,yt.t)(au,[1,0],[au.shape[0]-1,au.shape[1]])],0);const qe=(0,Or.W)((0,zn.h)((0,Gt.O)(Ei,ps),vi)),kr=(0,yt.t)(Jt,[He,0],[$t-He,Ut]),ba=(0,O.d)(qe,me),Ci=(0,j.p)(me);if(0===He)Jt=(0,Pr.l)(kr,(0,Gt.O)(ba,(0,Gt.O)(Ci,kr)));else{const zs=(0,Pr.l)(kr,(0,Gt.O)(ba,(0,Gt.O)(Ci,kr)));Jt=(0,nt.z)([(0,yt.t)(Jt,[0,0],[He,Ut]),zs],0)}const wi=(0,j.p)(ba),Po=(0,yt.t)(Zt,[0,He],[$t,Zt.shape[1]-He]);if(0===He)Zt=(0,Pr.l)(Po,(0,Gt.O)((0,Gt.O)(Po,me),wi));else{const zs=(0,Pr.l)(Po,(0,Gt.O)((0,Gt.O)(Po,me),wi));Zt=(0,nt.z)([(0,yt.t)(Zt,[0,0],[$t,He]),zs],1)}return[me,Jt,Zt]}),(0,AS.B9)([ln,hn,rr])}return!Vt&&$t>Ut&&(Zt=(0,yt.t)(Zt,[0,0],[$t,Ut]),Jt=(0,yt.t)(Jt,[0,0],[Ut,Ut])),[Zt,Jt]})}const A1=(0,X.op)({qr_:function MS(Ht,Vt=!1){if((0,A.hu)(Ht.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${Ht.rank}`),2===Ht.rank)return N1(Ht,Vt);{const $t=Ht.shape.slice(0,Ht.shape.length-2).reduce((Fe,He)=>Fe*He),Ut=(0,ct.H)((0,ot.X)(Ht,[$t,Ht.shape[Ht.shape.length-2],Ht.shape[Ht.shape.length-1]]),0),Zt=[],Jt=[];return Ut.forEach(Fe=>{const[He,ln]=N1(Fe,Vt);Zt.push(He),Jt.push(ln)}),[(0,ot.X)((0,hs.k)(Zt,0),Ht.shape),(0,ot.X)((0,hs.k)(Jt,0),Ht.shape)]}}});var Ju=y(4839);const Zl=(0,X.op)({computeWeightedLoss_:function PS(Ht,Vt,$t=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Ut=(0,k._1)(Ht,"losses","computeWeightedLoss");let Zt=null;null!=Vt&&(Zt=(0,k._1)(Vt,"weights","computeWeightedLoss"));const Jt=null==Zt?Ut:(0,O.d)(Ut,Zt);if($t===Ju.I.NONE)return Jt;if($t===Ju.I.SUM)return(0,ns.S)(Jt);if($t===Ju.I.MEAN){if(null==Zt)return(0,Fn.J)(Jt);{const qt=Ut.size/Zt.size,me=(0,zn.h)((0,ns.S)(Jt),(0,ns.S)(Zt));return qt>1?(0,zn.h)(me,(0,mo.i)(qt)):me}}if($t===Ju.I.SUM_BY_NONZERO_WEIGHTS){if(null==Zt)return(0,zn.h)((0,ns.S)(Jt),(0,mo.i)(Ut.size));{const qt=(0,O.d)(Zt,(0,Ds.i)(Ut.shape)),me=(0,pt.p)((0,ns.S)((0,as.Q)(qt,(0,mo.i)(0))),"float32");return(0,zn.h)((0,ns.S)(Jt),me)}}throw Error(`Unknown reduction: ${$t}`)}}),M1=(0,X.op)({absoluteDifference_:function qp(Ht,Vt,$t,Ut=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Zt=(0,k._1)(Ht,"labels","absoluteDifference"),Jt=(0,k._1)(Vt,"predictions","absoluteDifference");let qt=null;null!=$t&&(qt=(0,k._1)($t,"weights","absoluteDifference")),(0,A.k5)(Zt.shape,Jt.shape,"Error in absoluteDifference: ");const me=(0,V.W)((0,Pr.l)(Zt,Jt));return Zl(me,qt,Ut)}}),OS=(0,X.op)({cosineDistance_:function Qp(Ht,Vt,$t,Ut,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Jt=(0,k._1)(Ht,"labels","cosineDistance"),qt=(0,k._1)(Vt,"predictions","cosineDistance");let me=null;null!=Ut&&(me=(0,k._1)(Ut,"weights","cosineDistance")),(0,A.k5)(Jt.shape,qt.shape,"Error in cosineDistance: ");const Fe=(0,mo.i)(1),He=(0,Pr.l)(Fe,(0,ns.S)((0,O.d)(Jt,qt),$t,!0));return Zl(He,me,Zt)}}),P1=(0,X.op)({hingeLoss_:function RS(Ht,Vt,$t,Ut=Ju.I.SUM_BY_NONZERO_WEIGHTS){let Zt=(0,k._1)(Ht,"labels","hingeLoss");const Jt=(0,k._1)(Vt,"predictions","hingeLoss");let qt=null;null!=$t&&(qt=(0,k._1)($t,"weights","hingeLoss")),(0,A.k5)(Zt.shape,Jt.shape,"Error in hingeLoss: ");const me=(0,mo.i)(1);Zt=(0,Pr.l)((0,O.d)((0,mo.i)(2),Zt),me);const Fe=(0,ls.U)((0,Pr.l)(me,(0,O.d)(Zt,Jt)));return Zl(Fe,qt,Ut)}}),_y=(0,X.op)({huberLoss_:function vy(Ht,Vt,$t,Ut=1,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Jt=(0,k._1)(Ht,"labels","huberLoss"),qt=(0,k._1)(Vt,"predictions","huberLoss");let me=null;null!=$t&&(me=(0,k._1)($t,"weights","huberLoss")),(0,A.k5)(Jt.shape,qt.shape,"Error in huberLoss: ");const Fe=(0,mo.i)(Ut),He=(0,V.W)((0,Pr.l)(qt,Jt)),ln=(0,We.L)(He,Fe),hn=(0,Pr.l)(He,ln),rr=(0,Y.I)((0,O.d)((0,mo.i)(.5),(0,Kn.h)(ln)),(0,O.d)(Fe,hn));return Zl(rr,me,Zt)}}),R1=(0,X.op)({logLoss_:function O1(Ht,Vt,$t,Ut=1e-7,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Jt=(0,k._1)(Ht,"labels","logLoss"),qt=(0,k._1)(Vt,"predictions","logLoss");let me=null;null!=$t&&(me=(0,k._1)($t,"weights","logLoss")),(0,A.k5)(Jt.shape,qt.shape,"Error in logLoss: ");const Fe=(0,mo.i)(1),He=(0,mo.i)(Ut),ln=(0,Or.W)((0,O.d)(Jt,(0,$r.c)((0,Y.I)(qt,He)))),hn=(0,O.d)((0,Pr.l)(Fe,Jt),(0,$r.c)((0,Y.I)((0,Pr.l)(Fe,qt),He))),rr=(0,Pr.l)(ln,hn);return Zl(rr,me,Zt)}}),xy=(0,X.op)({meanSquaredError_:function L1(Ht,Vt,$t,Ut=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Zt=(0,k._1)(Ht,"labels","meanSquaredError"),Jt=(0,k._1)(Vt,"predictions","meanSquaredError");let qt=null;null!=$t&&(qt=(0,k._1)($t,"weights","meanSquaredError")),(0,A.k5)(Zt.shape,Jt.shape,"Error in meanSquaredError: ");const me=(0,yu.$)(Zt,Jt);return Zl(me,qt,Ut)}}),F1=(0,X.op)({sigmoidCrossEntropy_:function Ey(Ht,Vt,$t,Ut=0,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){let Jt=(0,k._1)(Ht,"multiClassLabels","sigmoidCrossEntropy");const qt=(0,k._1)(Vt,"logits","sigmoidCrossEntropy");let me=null;if(null!=$t&&(me=(0,k._1)($t,"weights","sigmoidCrossEntropy")),(0,A.k5)(Jt.shape,qt.shape,"Error in sigmoidCrossEntropy: "),Ut>0){const He=(0,mo.i)(Ut),ln=(0,mo.i)(1),hn=(0,mo.i)(.5);Jt=(0,Y.I)((0,O.d)(Jt,(0,Pr.l)(ln,He)),(0,O.d)(hn,He))}const Fe=function k1(Ht,Vt){const $t=(0,k._1)(Ht,"labels","sigmoidCrossEntropyWithLogits"),Ut=(0,k._1)(Vt,"logits","sigmoidCrossEntropyWithLogits");(0,A.k5)($t.shape,Ut.shape,"Error in sigmoidCrossEntropyWithLogits: ");const Zt=(0,ls.U)(Ut),Jt=(0,O.d)(Ut,$t),qt=(0,pr.K)((0,fi.Q)((0,Or.W)((0,V.W)(Ut))));return(0,Y.I)((0,Pr.l)(Zt,Jt),qt)}(Jt,qt);return Zl(Fe,me,Zt)}}),yl=(0,X.op)({softmaxCrossEntropy_:function $1(Ht,Vt,$t,Ut=0,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){let Jt=(0,k._1)(Ht,"onehotLabels","softmaxCrossEntropy");const qt=(0,k._1)(Vt,"logits","softmaxCrossEntropy");let me=null;if(null!=$t&&(me=(0,k._1)($t,"weights","softmaxCrossEntropy")),(0,A.k5)(Jt.shape,qt.shape,"Error in softmaxCrossEntropy: "),Ut>0){const He=(0,mo.i)(Ut),ln=(0,mo.i)(1),hn=(0,mo.i)(Jt.shape[1]);Jt=(0,Y.I)((0,O.d)(Jt,(0,Pr.l)(ln,He)),(0,zn.h)(He,hn))}const Fe=function LS(Ht,Vt,$t=-1){if(-1===$t&&($t=Vt.rank-1),$t!==Vt.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${Vt.rank} and dim was ${$t}`);return(0,Qs.cb)((Zt,Jt,qt)=>{const Fe=(0,Ga.l)(Jt,[$t],!0),He=(0,Pr.l)((0,pt.p)(Jt,"float32"),Fe);qt([Zt,He]);const ln=(0,Or.W)((0,O.d)(He,Zt));return{value:(0,ns.S)(ln,[$t]),gradFunc:(fr,vi)=>{const[is,Ei]=vi,ps=(0,ai.rv)(fr.shape,[$t]);return[(0,O.d)((0,ot.X)(fr,ps),(0,Pr.l)((0,pt.p)(is,"float32"),(0,fi.Q)(Ei))),(0,O.d)((0,ot.X)(fr,ps),(0,Pr.l)((0,fi.Q)(Ei),(0,pt.p)(is,"float32")))]}}})(Ht,Vt)}(Jt,qt);return Zl(Fe,me,Zt)}}),Dy={fft:ja.k,ifft:wa.S,rfft:ea.Q,irfft:qs.w},Oh={hammingWindow:Qt,hannWindow:ke,frame:_n,stft:Un},tl={flipLeftRight:$a,grayscaleToRGB:Xl,resizeNearestNeighbor:fy.j,resizeBilinear:Xp.I,rgbToGrayscale:bS,rotateWithOffset:SS,cropAndResize:Ji,nonMaxSuppression:ay,nonMaxSuppressionAsync:function DS(Ht,Vt,$t){return ly.apply(this,arguments)},nonMaxSuppressionWithScore:TS,nonMaxSuppressionWithScoreAsync:function NS(Ht,Vt,$t){return Ba.apply(this,arguments)},nonMaxSuppressionPadded:cy,nonMaxSuppressionPaddedAsync:function hy(Ht,Vt,$t){return cf.apply(this,arguments)},threshold:py,transform:gy},G1={bandPart:_d,gramSchmidt:yy,qr:A1},H1={absoluteDifference:M1,computeWeightedLoss:Zl,cosineDistance:OS,hingeLoss:P1,huberLoss:_y,logLoss:R1,meanSquaredError:xy,sigmoidCrossEntropy:F1,softmaxCrossEntropy:yl},j1={sparseFillEmptyRows:(0,X.op)({sparseFillEmptyRows_:function Cy(Ht,Vt,$t,Ut){const Zt=(0,k._1)(Ht,"indices","sparseFillEmptyRows","int32"),Jt=(0,k._1)(Vt,"values","sparseFillEmptyRows"),qt=(0,k._1)($t,"denseShape","sparseFillEmptyRows","int32"),me=(0,k._1)(Ut,"defaultValue","sparseFillEmptyRows",Jt.dtype);if(2!==Zt.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${Zt.shape}`);if(1!==Jt.rank)throw new Error(`Values should be Tensor1D but received shape ${Jt.shape}`);if(1!==qt.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${qt.shape}`);if(0!==me.rank)throw new Error(`Default value should be a scalar but received shape ${me.shape}`);const He=R.BV.runKernel(W.O3z,{indices:Zt,values:Jt,denseShape:qt,defaultValue:me});return{outputIndices:He[0],outputValues:He[1],emptyRowIndicator:He[2],reverseIndexMap:He[3]}}}),sparseReshape:(0,X.op)({sparseReshape_:function z1(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"inputIndices","sparseReshape","int32"),Zt=(0,k._1)(Vt,"inputShape","sparseReshape","int32"),Jt=(0,k._1)($t,"newShape","sparseReshape","int32");if(2!==Ut.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${Ut.shape}`);if(1!==Zt.rank)throw new Error(`Input shape should be Tensor1D but received shape ${Zt.shape}`);if(1!==Jt.rank)throw new Error(`New shape should be Tensor1D but received shape ${Jt.shape}`);const me=R.BV.runKernel(W.nhH,{inputIndices:Ut,inputShape:Zt,newShape:Jt});return{outputIndices:me[0],outputShape:me[1]}}}),sparseSegmentMean:(0,X.op)({sparseSegmentMean_:function by(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"data","sparseSegmentMean"),Zt=(0,k._1)(Vt,"indices","sparseSegmentMean","int32"),Jt=(0,k._1)($t,"segmentIds","sparseSegmentMean","int32");if(Ut.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==Zt.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${Zt.shape}`);if(1!==Jt.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${Jt.shape}`);return R.BV.runKernel(W.w3H,{data:Ut,indices:Zt,segmentIds:Jt})}}),sparseSegmentSum:(0,X.op)({sparseSegmentSum_:function Jp(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"data","sparseSegmentSum"),Zt=(0,k._1)(Vt,"indices","sparseSegmentSum","int32"),Jt=(0,k._1)($t,"segmentIds","sparseSegmentSum","int32");if(Ut.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==Zt.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${Zt.shape}`);if(1!==Jt.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${Jt.shape}`);return R.BV.runKernel(W.ZjV,{data:Ut,indices:Zt,segmentIds:Jt})}})},kc={stringNGrams:(0,X.op)({stringNGrams_:function Yl(Ht,Vt,$t,Ut,Zt,Jt,qt,me){const Fe=(0,k._1)(Ht,"data","stringNGrams","string");if("string"!==Fe.dtype)throw new Error("Data must be of datatype string");if(1!==Fe.shape.length)throw new Error(`Data must be a vector, saw: ${Fe.shape}`);const He=(0,k._1)(Vt,"dataSplits","stringNGrams");if("int32"!==He.dtype)throw new Error("Data splits must be of datatype int32");const rr=R.BV.runKernel(W._JP,{data:Fe,dataSplits:He},{separator:$t,nGramWidths:Ut,leftPad:Zt,rightPad:Jt,padWidth:qt,preserveShortSequences:me});return{nGrams:rr[0],nGramsSplits:rr[1]}}}),stringSplit:(0,X.op)({stringSplit_:function Sy(Ht,Vt,$t=!0){const Ut=(0,k._1)(Ht,"input","stringSplit","string"),Zt=(0,k._1)(Vt,"delimiter","stringSplit","string");if(1!==Ut.rank)throw new Error(`Input should be Tensor1D but received shape ${Ut.shape}`);if(0!==Zt.rank)throw new Error(`Delimiter should be a scalar but received shape ${Zt.shape}`);const me=R.BV.runKernel(W.s1s,{input:Ut,delimiter:Zt},{skipEmpty:$t});return{indices:me[0],values:me[1],shape:me[2]}}}),stringToHashBucketFast:(0,X.op)({stringToHashBucketFast_:function tm(Ht,Vt){const $t=(0,k._1)(Ht,"input","stringToHashBucketFast","string"),Ut={numBuckets:Vt};if(Vt<=0)throw new Error("Number of buckets must be at least 1");return R.BV.runKernel(W.XkS,{input:$t},Ut)}}),staticRegexReplace:(0,X.op)({staticRegexReplace_:function $u(Ht,Vt,$t,Ut=!0){const Zt=(0,k._1)(Ht,"input","staticRegexReplace","string");return R.BV.runKernel(W.e0R,{x:Zt},{pattern:Vt,rewrite:$t,replaceGlobal:Ut})}})}},404:(Lt,ut,y)=>{"use strict";y.d(ut,{v:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({pad_:function Y(W,k,A=0){const X=(0,H._1)(W,"x","pad");if(0===X.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return $.BV.runKernel(V.lyA,{x:X},{paddings:k,constantValue:A})}})},1640:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>it});var $=y(1257),V=y(5359),H=y(6903),q=y(2782),Y=y(5551),R=y(2444),W=y(4195),k=y(5715),A=y(9619);const it=(0,W.op)({pool_:function X(bt,K,st,et,dt,lt,St){null==dt&&(dt=[1,1]),null==lt&&(lt=1),0===et&&(et="valid");const Q=(0,$._1)(bt,"x","maxPool");let ft=Q,pt=!1;3===Q.rank&&(pt=!0,ft=(0,k.X)(Q,[1,Q.shape[0],Q.shape[1],Q.shape[2]])),V.hu(Y.jT(lt,dt),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${lt} and dilations '${dt}'`);const B=Y.Xw(ft.shape,K,lt,dt,et),ot=[B.dilationHeight,B.dilationWidth];let P;P="same"===et?function G(bt,K){const et=bt.map((St,Q)=>St+(St-1)*(K[Q]-1)).map(St=>St-1),dt=et.map(St=>Math.floor(St/2)),lt=et.map((St,Q)=>St-dt[Q]);return et.map((St,Q)=>[dt[Q],lt[Q]])}([B.filterHeight,B.filterWidth],ot):[[0,0],[0,0]];const at=1===ot[0]&&1===ot[1],[nt,Gt]=function Z(bt,K,st){const et=st.map(B=>B[0]),dt=st.map(B=>B[1]),lt=bt.concat(et,dt),St=K.map((B,ot)=>(B-lt[ot]%B)%B),Q=dt.map((B,ot)=>B+St[ot]),ft=K.map((B,ot)=>[et[ot],Q[ot]]),pt=K.map((B,ot)=>[0,St[ot]]);return[ft,pt]}([B.inHeight,B.inWidth],ot,P),O=at?et:"valid",Ct=at?ft:(0,A.f)(ft,ot,nt),vt=("avg"===st?()=>(0,H.w)(Ct,K,lt,O,St):()=>(0,R._)(Ct,K,lt,O,St))(),xt=at?vt:(0,q.E)(vt,ot,Gt);return pt?(0,k.X)(xt,[xt.shape[1],xt.shape[2],xt.shape[3]]):xt}})},2962:(Lt,ut,y)=>{"use strict";y.d(ut,{s:()=>W});var $=y(687),V=y(4251),H=y(7664),q=y(1257);const W=(0,y(4195).op)({pow_:function R(k,A){let X=(0,q._1)(k,"base","pow"),Z=(0,q._1)(A,"exp","pow");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.pe_,{a:X,b:Z})}})},1584:(Lt,ut,y)=>{"use strict";y.d(ut,{A:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({prelu_:function Y(W,k){const A=(0,H._1)(W,"x","prelu"),X=(0,H._1)(k,"alpha","prelu");return $.BV.runKernel(V.o0g,{x:A,alpha:X})}})},3006:(Lt,ut,y)=>{"use strict";function $(V,H=!1){console.log(V.toString(H))}y.d(ut,{S:()=>$})},794:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(3062);const W=(0,y(4195).op)({prod_:function R(k,A=null,X=!1){let Z=(0,H._1)(k,"x","prod");return"bool"===Z.dtype&&(Z=(0,q.p)(Z,"int32")),$.BV.runKernel(V.DlI,{x:Z},{axis:A,keepDims:X})}})},6027:(Lt,ut,y)=>{"use strict";y.d(ut,{k:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({real_:function Y(W){const A={input:(0,H._1)(W,"input","real")};return $.BV.runKernel(V.xJR,A)}})},4831:(Lt,ut,y)=>{"use strict";y.d(ut,{M:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({reciprocal_:function Y(W){const A={x:(0,H._1)(W,"x","reciprocal")};return $.BV.runKernel(V.$HU,A)}})},8586:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({relu_:function Y(W){const A={x:(0,H._1)(W,"x","relu")};return $.BV.runKernel(V.qkr,A)}})},4917:(Lt,ut,y)=>{"use strict";y.d(ut,{b:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({relu6_:function Y(W){const A={x:(0,H._1)(W,"x","relu6")};return $.BV.runKernel(V.SbG,A)}})},5715:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({reshape_:function Y(W,k){const X={x:(0,H._1)(W,"x","reshape","string_or_numeric")};return $.BV.runKernel(V.HZH,X,{shape:k})}})},6825:(Lt,ut,y)=>{"use strict";y.d(ut,{G:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({reverse_:function Y(W,k){const X={x:(0,H._1)(W,"x","reverse")};return $.BV.runKernel(V.mKl,X,{dims:k})}})},1974:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({round_:function Y(W){const A={x:(0,H._1)(W,"x","round")};return $.BV.runKernel(V.e07,A)}})},8893:(Lt,ut,y)=>{"use strict";y.d(ut,{b:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({rsqrt_:function Y(W){const A={x:(0,H._1)(W,"x","rsqrt","float32")};return $.BV.runKernel(V.bV0,A)}})},8661:(Lt,ut,y)=>{"use strict";y.d(ut,{i:()=>H});var $=y(1153),V=y(7431);function H(q,Y){if(((0,$.isTypedArray)(q)&&"string"!==Y||Array.isArray(q))&&"complex64"!==Y)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===Y&&(0,$.isTypedArray)(q)&&!(q instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,V.H)(q,[],[],Y)}},1876:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{calculateShapes:()=>q,validateInput:()=>H,validateUpdateShape:()=>V});var $=y(5359);function V(Y,R,W){const k=R.rank>1?R.shape[R.rank-1]:1,A=R.rank>1?R.rank-1:1,X=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${W.shape}, indices.shape: ${R.shape}, shape: ${Y}, sliceDim: ${k}, and batchDim: ${A}.`;if(W.rank<A)throw new Error(X+` update.rank < ${A}. `);if(Y.length<k+(W.rank-A))throw new Error(X+` Output shape length < ${k+(W.rank-A)}`);if(W.rank!==A+Y.length-k)throw new Error(X+" update.rank != "+(A+Y.length-k));for(let Z=0;Z<A;++Z)if(W.shape[Z]!==R.shape[Z])throw new Error(X+` updates.shape[${Z}] (${W.shape[Z]}) != indices.shape[${Z}] (${R.shape[Z]}).`);for(let Z=0;Z<W.rank-A;++Z)if(W.shape[Z+A]!==Y[Z+k])throw new Error(X+` updates.shape[${Z+A}] (${W.shape[Z+A]}) != shape[${Z+A}] (${Y[Z+A]})`)}function H(Y,R,W){if(R.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${R.rank}.`);if(Y.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${Y.rank}.`);if("int32"!==R.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${R.dtype}`);if(W.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${W}`);if(0===W.length){if(0===R.size)throw new Error(`Indices specified for empty output. indices shape: ${R.shape}`);if(0===Y.size)throw new Error(`Updates specified for empty output. updates shape: ${Y.shape}`)}V(W,R,Y)}function q(Y,R,W){const k=R.shape.length,A=k>1?R.shape[k-1]:1,X=W.length;let Z=1;for(let st=A;st<X;++st)Z*=W[st];const G=A<1?1:A;return{sliceRank:A,numUpdates:(0,$.NA)(R.shape)/G,sliceSize:Z,strides:[...(0,$.e3)(W.slice(0,A)),1],outputSize:(0,$.NA)(W)}}},9614:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({selu_:function Y(W){const A={x:(0,H._1)(W,"x","selu")};return $.BV.runKernel(V.oFR,A)}})},2152:(Lt,ut,y)=>{"use strict";y.d(ut,{$:()=>V,y:()=>$});const $=1.7580993408473768,V=1.0507009873554805},6762:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>k});var $=y(1257),V=y(5359),H=y(4451),q=y(1172),Y=y(4195),R=y(5715);const k=(0,Y.op)({separableConv2d_:function W(A,X,Z,G,it,bt=[1,1],K="NHWC"){const st=(0,$._1)(A,"x","separableConv2d"),et=(0,$._1)(X,"depthwiseFilter","separableConv2d"),dt=(0,$._1)(Z,"pointwiseFilter","separableConv2d");let lt=st,St=!1;if(3===st.rank&&(St=!0,lt=(0,R.X)(st,[1,st.shape[0],st.shape[1],st.shape[2]])),"NCHW"===K)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");V.hu(4===lt.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${lt.rank}.`),V.hu(4===et.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${et.rank}.`),V.hu(4===dt.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${et.rank}.`),V.hu(1===dt.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${dt.shape[0]}.`),V.hu(1===dt.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${dt.shape[1]}.`);const Q=et.shape[2],ft=et.shape[3];V.hu(dt.shape[2]===Q*ft,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${Q*ft}, but got ${dt.shape[2]}.`);const pt=(0,q.B)(lt,et,G,it,K,bt),ot=(0,H.T)(pt,dt,1,"valid",K);return St?(0,R.X)(ot,[ot.shape[1],ot.shape[2],ot.shape[3]]):ot}})},6139:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sigmoid_:function Y(W){const A={x:(0,H._1)(W,"x","sigmoid","float32")};return $.BV.runKernel(V.a5O,A)}})},4058:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sign_:function Y(W){const A={x:(0,H._1)(W,"x","sign")};return $.BV.runKernel(V.i5y,A)}})},2438:(Lt,ut,y)=>{"use strict";y.d(ut,{O:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sin_:function Y(W){const A={x:(0,H._1)(W,"x","sin","float32")};return $.BV.runKernel(V.RQH,A)}})},319:(Lt,ut,y)=>{"use strict";y.d(ut,{R:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sinh_:function Y(W){const A={x:(0,H._1)(W,"x","sinh")};return $.BV.runKernel(V.wYB,A)}})},8317:(Lt,ut,y)=>{"use strict";y.d(ut,{t:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({slice_:function Y(W,k,A){const X=(0,H._1)(W,"x","slice","string_or_numeric");if(0===X.rank)throw new Error("Slicing scalar is not possible");return $.BV.runKernel(V.p2w,{x:X},{begin:k,size:A})}})},2320:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{assertParamsValid:()=>q,computeFlatOffset:()=>et,computeOutShape:()=>R,getNormalizedAxes:()=>X,isSliceContinous:()=>st,maskToAxes:()=>Y,parseSliceParams:()=>dt,sliceInfo:()=>lt,startForAxis:()=>bt,startIndicesWithElidedDims:()=>Z,stopForAxis:()=>K,stopIndicesWithElidedDims:()=>G,stridesForAxis:()=>it,stridesWithElidedDims:()=>W});var $=y(5359);const V=-2,H=-1;function q(ft,pt,B){const ot=ft.shape.length;$.hu(ot===pt.length,()=>`Error in slice${ot}D: Length of begin ${pt} must match the rank of the array (${ot}).`),$.hu(ot===B.length,()=>`Error in slice${ot}D: Length of size ${B} must match the rank of the array (${ot}).`);for(let P=0;P<ot;++P)$.hu(pt[P]+B[P]<=ft.shape[P],()=>`Error in slice${ot}D: begin[${P}] + size[${P}] (${pt[P]+B[P]}) would overflow input.shape[${P}] (${ft.shape[P]})`)}function Y(ft){const pt=[];let B=0;for(;ft>0;)1&ft&&pt.push(B),ft/=2,B++;return pt}function R(ft,pt,B){const ot=[];for(let P=0;P<ft.length;P++)ot[P]=Math.ceil((pt[P]-ft[P])/B[P]);return ot}function W(ft,pt,B,ot){const P=[...ft];for(let at=P.length;at<ot.length;at++)P.push(1);for(let at=0;at<B;at++)0===at?P[pt]=1:(P.splice(pt,0,1),P.pop());return P}function k(ft,pt,B){return B<=ft?B:B-(pt-1)}function A(ft,pt){const B=[];for(let ot=0;ot<ft;ot++)B.push(pt+ot);return B}function X(ft,pt,B,ot,P,at,nt,Gt,O){const Ct=ft.length;let yt=new Array(Ct),vt=new Array(Ct),xt=new Array(Ct);if(pt.length&&B>0){const Mt=pt[0],It=B+1;yt=Z(nt,Mt,It,ot,ft),vt=G(Gt,Mt,It,P,ft),xt=W(at,Mt,It,ft)}else for(let Mt=0;Mt<Ct;Mt++)yt[Mt]=bt(nt,ot,at,ft,Mt,O),vt[Mt]=K(Gt,P,at,ft,Mt,O),xt[Mt]=it(at,Mt,O);return{begin:yt,end:vt,strides:xt}}function Z(ft,pt,B,ot,P){const at=[...P],nt=A(B,pt);for(let Gt=0;Gt<at.length;Gt++)if(nt.indexOf(Gt)>-1)at[Gt]=0;else{const O=k(pt,B,Gt);let Ct=ot[O];ft&1<<O&&(Ct=0),at[Gt]=Ct}return at}function G(ft,pt,B,ot,P){const at=[...P],nt=A(B,pt);for(let Gt=0;Gt<at.length;Gt++)if(nt.indexOf(Gt)>-1)at[Gt]=Number.MAX_SAFE_INTEGER;else{const O=k(pt,B,Gt);let Ct=ot[O];ft&1<<O&&(Ct=Number.MAX_SAFE_INTEGER),at[Gt]=Ct}for(let Gt=0;Gt<at.length;Gt++)at[Gt]<0&&(at[Gt]+=P[Gt]),at[Gt]=$.uZ(0,at[Gt],P[Gt]);return at}function it(ft,pt,B){let ot=ft[pt];return(B&1<<pt||null==ot)&&(ot=1),ot}function bt(ft,pt,B,ot,P,at){let nt=pt[P];(ft&1<<P||at&1<<P||null==nt)&&(nt=(B[P]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const O=ot[P];return nt<0&&(nt+=O),nt=$.uZ(0,nt,O-1),nt}function K(ft,pt,B,ot,P,at){let nt=pt[P];const Gt=B[P]||1;(ft&1<<P||at&1<<P||null==nt)&&(nt=Gt>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const O=ot[P];return nt<0&&(nt+=O),nt=Gt>0?$.uZ(0,nt,O):$.uZ(-1,nt,O-1),nt}function st(ft,pt,B){let ot=B.length;for(let P=0;P<B.length;P++)if(B[P]>1){ot=P;break}for(let P=ot+1;P<B.length;P++)if(pt[P]>0||B[P]!==ft[P])return!1;return!0}function et(ft,pt){let B=ft.length>0?ft[ft.length-1]:1;for(let ot=0;ot<ft.length-1;ot++)B+=ft[ot]*pt[ot];return B}function dt(ft,pt,B){let ot;const P=ft.shape.length;let at;return ot="number"==typeof pt?[pt,...new Array(P-1).fill(0)]:pt.length<P?pt.concat(new Array(P-pt.length).fill(0)):pt.slice(),ot.forEach(nt=>{$.hu(-1!==nt,()=>"slice() does not support negative begin indexing.")}),at=null==B?new Array(P).fill(-1):"number"==typeof B?[B,...new Array(P-1).fill(-1)]:B.length<P?B.concat(new Array(P-B.length).fill(-1)):B,at=at.map((nt,Gt)=>nt>=0?nt:($.hu(-1===nt,()=>`Negative size values should be exactly -1 but got ${nt} for the slice() size at index ${Gt}.`),ft.shape[Gt]-ot[Gt])),[ot,at]}function lt(ft,pt,B,ot,P,at,nt,Gt,O){let Ct;if(null==ot?(Ct=new Array(pt.length),Ct.fill(1)):Ct=ot,null!=nt&&nt&nt-1)throw new Error("Multiple ellipses in slice is not allowed.");let yt=!1;const vt={dims:Ct.length,numAddAxisAfterEllipsis:0,begin:pt.slice(),end:B.slice(),strides:Ct.slice(),beginMask:P,endMask:at,ellipsisMask:nt,newAxisMask:Gt,shrinkAxisMask:O};for(let se=0;se<vt.dims;se++)yt&&1<<se&Gt&&vt.numAddAxisAfterEllipsis++,1<<se&nt&&(yt=!0);yt||(vt.ellipsisMask|=1<<vt.dims,vt.dims++);const xt={dims:ft.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function St(ft,pt){pt.beginMask=0,pt.endMask=0,pt.shrinkAxisMask=0;let B=0;pt.beginValid=null!=ft.begin,pt.endValid=null!=ft.end,pt.begin=new Array(pt.dims),pt.end=new Array(pt.dims),pt.strides=new Array(pt.dims),pt.finalShapeGatherIndices=[],pt.finalShapeGatherIndicesSparse=[],pt.inputShapeGatherIndicesSparse=new Array(pt.dims);for(let ot=0;ot<ft.dims;ot++)if(1<<ot&ft.ellipsisMask){const P=Math.min(pt.dims-(ft.dims-ot)+1+ft.numAddAxisAfterEllipsis,pt.dims);for(;B<P;B++)pt.begin[B]=0,pt.end[B]=0,pt.strides[B]=1,pt.beginMask|=1<<B,pt.endMask|=1<<B,pt.finalShapeGatherIndices.push(B),pt.finalShapeGatherIndicesSparse.push(-1),pt.inputShapeGatherIndicesSparse[B]=ot}else if(1<<ot&ft.newAxisMask)pt.finalShapeGatherIndices.push(V),pt.finalShapeGatherIndicesSparse.push(-1);else{if(B===pt.begin.length)throw Error(`Index out of range using input dim ${B}; input has only ${pt.dims} dims, ${pt.begin.length}.`);null!=ft.begin&&(pt.begin[B]=ft.begin[ot]),null!=ft.end&&(pt.end[B]=ft.end[ot]),pt.strides[B]=ft.strides[ot],ft.beginMask&1<<ot&&(pt.beginMask|=1<<B),ft.endMask&1<<ot&&(pt.endMask|=1<<B),ft.shrinkAxisMask&1<<ot?(pt.finalShapeGatherIndices.push(H),pt.finalShapeGatherIndicesSparse.push(-1),pt.shrinkAxisMask|=1<<B):(pt.finalShapeGatherIndices.push(B),pt.finalShapeGatherIndicesSparse.push(ot)),pt.inputShapeGatherIndicesSparse[B]=ot,B++}}(vt,xt);let Mt=!0,It=!0,re=!0;const Bt=[],ee=[];for(let se=0;se<ft.length;++se){if(0===xt.strides[se])throw Error(`strides[${se}] must be non-zero`);const be=!!(xt.shrinkAxisMask&1<<se),Me=ft[se];if(-1===Me){Bt.push(be?1:-1);continue}const Xe=[xt.beginMask&1<<se,xt.endMask&1<<se],Ue=[xt.strides[se]>0?0:-1,xt.strides[se]>0?Me:Me-1];if(be&&xt.strides[se]<=0)throw Error("only stride 1 allowed on non-range indexing.");re=re&&1===xt.strides[se];const De=!!(xt.beginMask&1<<se&&xt.endMask&1<<se);if(xt.beginValid&&xt.endValid){if(be){const pe=xt.begin[se]<0?Me+xt.begin[se]:xt.begin[se];if(xt.begin[se]=pe,xt.end[se]=xt.begin[se]+1,pe<0||pe>=Me)throw Error(`slice index ${xt.begin[se]} of dimension ${se} out of bounds.`)}else xt.begin[se]=Q(xt.begin[se],0,xt.strides[se],Me,Xe,Ue),xt.end[se]=Q(xt.end[se],1,xt.strides[se],Me,Xe,Ue);const ne=1===xt.strides[se]&&0===xt.begin[se]&&xt.end[se]===Me;Mt=Mt&&ne,It=It&&(0===se&&1===xt.strides[se]||ne)}else Mt=Mt&&1===xt.strides[se]&&De,It=It&&(0===se&&1===xt.strides[se]||De);let Tn,On=!1;if(xt.beginValid&&xt.endValid?(Tn=xt.end[se]-xt.begin[se],On=!0):be?(Tn=1,On=!0):De&&Me>=0&&(Tn=xt.strides[se]<0?-Me:Me,On=!0),On){let ne;ne=0===Tn||Tn<0!=xt.strides[se]<0?0:Math.trunc(Tn/xt.strides[se])+(Tn%xt.strides[se]!=0?1:0),Bt.push(ne)}else Bt.push(-1)}for(let se=0;se<xt.finalShapeGatherIndices.length;++se){const be=xt.finalShapeGatherIndices[se];be>=0?ee.push(Bt[be]):be===V&&ee.push(1)}return{finalShapeSparse:ee.filter((se,be)=>xt.finalShapeGatherIndices[be]!==V),finalShape:ee,isIdentity:Mt,sliceDim0:It,isSimpleSlice:re,begin:xt.begin,end:xt.end,strides:xt.strides}}function Q(ft,pt,B,ot,P,at){if(P[pt])return B>0?at[pt]:at[pt+1&1];{const nt=ft<0?ot+ft:ft;return nt<at[0]?at[0]:nt>at[1]?at[1]:nt}}},8683:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({softmax_:function Y(W,k=-1){const A=(0,H._1)(W,"logits","softmax","float32");if(-1===k&&(k=A.rank-1),k!==A.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${A.rank} and dim was ${k}`);return $.BV.runKernel(V.Gcp,{logits:A},{dim:k})}})},4487:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({softplus_:function Y(W){const A={x:(0,H._1)(W,"x","softplus")};return $.BV.runKernel(V.MRv,A)}})},9619:(Lt,ut,y)=>{"use strict";y.d(ut,{f:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({spaceToBatchND_:function R(k,A,X){const Z=(0,H._1)(k,"x","spaceToBatchND");return q.hu(Z.rank>=1+A.length,()=>`input rank ${Z.rank} should be > than [blockShape] ${A.length}`),q.hu(X.length===A.length,()=>`paddings.shape[0] ${X.length} must be equal to [blockShape] ${A.length}`),q.hu(Z.shape.reduce((bt,K,st)=>st>0&&st<=A.length?bt&&(K+X[st-1][0]+X[st-1][1])%A[st-1]==0:bt,!0),()=>`input spatial dimensions ${Z.shape.slice(1)} with paddings ${X.toString()} must be divisible by blockShapes ${A.toString()}`),$.BV.runKernel(V.TQc,{x:Z},{blockShape:A,paddings:X})}})},9738:(Lt,ut,y)=>{"use strict";y.d(ut,{k:()=>R});var $=y(687),V=y(4251),H=y(5359);const R=(0,y(4195).op)({fft_:function Y(W){return(0,H.hu)("complex64"===W.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${W.dtype}.`),$.BV.runKernel(V.vwp,{input:W})}})},527:(Lt,ut,y)=>{"use strict";y.d(ut,{S:()=>R});var $=y(687),V=y(4251),H=y(5359);const R=(0,y(4195).op)({ifft_:function Y(W){return(0,H.hu)("complex64"===W.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${W.dtype}.`),$.BV.runKernel(V.Qg5,{input:W})}})},6065:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>it});var $=y(3037),V=y(4111),H=y(1844),q=y(8737),Y=y(4195),R=y(6027),W=y(5715),k=y(6825),A=y(8661),X=y(8317),Z=y(527);const it=(0,Y.op)({irfft_:function G(bt){const K=bt.shape[bt.shape.length-1],st=bt.size/K;let et;if(K<=2){const dt=(0,W.X)(bt,[st,K]);et=(0,Z.S)(dt)}else{const dt=[st,2*(K-1)],lt=(0,W.X)((0,R.k)(bt),[st,K]),St=(0,W.X)((0,H.a)(bt),[st,K]),Q=(0,k.G)((0,X.t)(lt,[0,1],[st,K-2]),1),ft=(0,q.d)((0,k.G)((0,X.t)(St,[0,1],[st,K-2]),1),(0,A.i)(-1)),pt=(0,V.z)([lt,Q],1),B=(0,V.z)([St,ft],1),ot=(0,W.X)((0,$.P)(pt,B),[dt[0],dt[1]]);et=(0,Z.S)(ot)}if(et=(0,R.k)(et),3===bt.rank&&0!==bt.shape[0]){const dt=et,lt=bt.shape[0];et=(0,W.X)(et,[lt,et.shape[0]/lt,et.shape[1]]),dt.dispose()}return et}})},1638:(Lt,ut,y)=>{"use strict";y.d(ut,{Q:()=>bt});var $=y(5359),V=y(3037),H=y(4111),q=y(1844),Y=y(4195),R=y(6027),W=y(5715),k=y(8317),A=y(8874),X=y(6467),Z=y(3143),G=y(9738);const bt=(0,Y.op)({rfft_:function it(K,st){(0,$.hu)("float32"===K.dtype,()=>`The dtype for rfft() must be real value but got ${K.dtype}`);let et=K.shape[K.shape.length-1];const dt=K.size/et;let lt;if(null!=st&&st<et){const Gt=K.shape.map(Ct=>0),O=K.shape.map(Ct=>Ct);O[K.shape.length-1]=st,lt=(0,k.t)(K,Gt,O),et=st}else if(null!=st&&st>et){const Gt=K.shape.map(O=>O);Gt[K.shape.length-1]=st-et,lt=(0,H.z)([K,(0,X.l)(Gt)],K.shape.length-1),et=st}else lt=K;const St=(0,Z.P)(lt),Q=(0,W.X)((0,V.P)(lt,St),[dt,et]),ft=(0,G.k)(Q),pt=Math.floor(et/2)+1,B=(0,R.k)(ft),ot=(0,q.a)(ft),P=(0,A.V)(B,[pt,et-pt],B.shape.length-1),at=(0,A.V)(ot,[pt,et-pt],ot.shape.length-1),nt=lt.shape.slice();return nt[lt.shape.length-1]=pt,(0,W.X)((0,V.P)(P[0],at[0]),nt)}})},8874:(Lt,ut,y)=>{"use strict";y.d(ut,{V:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({split_:function Y(W,k,A=0){const Z={x:(0,H._1)(W,"x","split")};return $.BV.runKernel(V.L8s,Z,{numOrSizeSplits:k,axis:A})}})},930:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sqrt_:function Y(W){const A={x:(0,H._1)(W,"x","sqrt","float32")};return $.BV.runKernel(V.FKq,A)}})},7527:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>Y});var $=y(687),V=y(1257);const Y=(0,y(4195).op)({square_:function q(R){const W=(0,V._1)(R,"x","square");return $.BV.runKernel("Square",{x:W},{})}})},9539:(Lt,ut,y)=>{"use strict";y.d(ut,{$:()=>k});var $=y(687),V=y(4251),H=y(7664),q=y(1257),Y=y(3239);const k=(0,y(4195).op)({squaredDifference_:function W(A,X){let Z=(0,q._1)(A,"a","squaredDifference"),G=(0,q._1)(X,"b","squaredDifference");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V._tC,{a:Z,b:G},{})}})},2494:(Lt,ut,y)=>{"use strict";y.d(ut,{L:()=>R});var $=y(1257),V=y(5359),H=y(4195),q=y(5715);const R=(0,H.op)({squeeze_:function Y(W,k){const A=(0,$._1)(W,"x","squeeze","string_or_numeric");return(0,q.X)(A,(0,V.bp)(A.shape,k).newShape)}})},7958:(Lt,ut,y)=>{"use strict";y.d(ut,{k:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({stack_:function R(k,A=0){const X=(0,H.sI)(k,"tensors","stack","string_or_numeric");return q.hu(X.length>=1,()=>"Pass at least one tensor to tf.stack"),X.length>0&&q.hu(A<=X[0].rank,()=>"Axis must be <= rank of the tensor"),$.BV.runKernel(V.QiL,X,{axis:A})}})},6034:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({step_:function Y(W,k=0){const X={x:(0,H._1)(W,"x","step")};return $.BV.runKernel(V.h8e,X,{alpha:k})}})},5367:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({stridedSlice_:function Y(W,k,A,X,Z=0,G=0,it=0,bt=0,K=0){const et={x:(0,H._1)(W,"x","stridedSlice","string_or_numeric")};return $.BV.runKernel(V.jQk,et,{begin:k,end:A,strides:X,beginMask:Z,endMask:G,ellipsisMask:it,newAxisMask:bt,shrinkAxisMask:K})}})},1191:(Lt,ut,y)=>{"use strict";y.d(ut,{l:()=>W});var $=y(687),V=y(4251),H=y(7664),q=y(1257);const W=(0,y(4195).op)({sub_:function R(k,A){let X=(0,q._1)(k,"a","sub"),Z=(0,q._1)(A,"b","sub");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.Tr8,{a:X,b:Z})}})},9929:(Lt,ut,y)=>{"use strict";y.d(ut,{S:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(3062);const W=(0,y(4195).op)({sum_:function R(k,A=null,X=!1){let Z=(0,H._1)(k,"x","sum");return"bool"===Z.dtype&&(Z=(0,q.p)(Z,"int32")),$.BV.runKernel(V.GBy,{x:Z},{axis:A,keepDims:X})}})},2500:(Lt,ut,y)=>{"use strict";y.d(ut,{O:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({tan_:function Y(W){const A={x:(0,H._1)(W,"x","tan","float32")};return $.BV.runKernel(V.sEM,A)}})},5987:(Lt,ut,y)=>{"use strict";y.d(ut,{A:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({tanh_:function Y(W){const A={x:(0,H._1)(W,"x","tanh","float32")};return $.BV.runKernel(V.MIZ,A)}})},3905:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>H});var $=y(1257),V=y(7431);function H(q,Y,R){const W=(0,$.C)(q,R);return(0,V.H)(q,Y,W,R)}},2786:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>q});var $=y(1257),V=y(5359),H=y(7431);function q(Y,R,W){if((0,V.Cq)(Y),null!=R&&3!==R.length)throw new Error("tensor3d() requires shape to have three numbers");const k=(0,$.C)(Y,W);if(3!==k.length&&1!==k.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===k.length&&null==R)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,H.H)(Y,R,k,W)}},7431:(Lt,ut,y)=>{"use strict";y.d(ut,{H:()=>Y});var $=y(687),V=y(1216),H=y(5359),q=y(1153);function Y(R,W,k,A){if(null==A)A=(0,H.D2)(R);else if("complex64"===A)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,V.$F)(R)||(0,V.Oq)(R)){if("float32"!==A&&"int32"!==A)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${A}.`);return $.BV.backend.createTensorFromGPUData(R,W||k,A)}if(!(0,q.isTypedArray)(R)&&!Array.isArray(R)&&"number"!=typeof R&&"boolean"!=typeof R&&"string"!=typeof R)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=W){(0,H.Mu)(W);const X=(0,H.NA)(W),Z=(0,H.NA)(k);(0,H.hu)(X===Z,()=>`Based on the provided shape, [${W}], the tensor should have ${X} values but has ${Z}`);for(let G=0;G<k.length;++G){const bt=G!==k.length-1||k[G]!==(0,H.NA)(W.slice(G));(0,H.hu)(k[G]===W[G]||!bt,()=>`Error creating a new Tensor. Inferred shape (${k}) does not match the provided shape (${W}). `)}}return!(0,q.isTypedArray)(R)&&!Array.isArray(R)&&(R=[R]),W=W||k,R="string"!==A?(0,q.toTypedArray)(R,A):(0,q.flatten)(R,[],!0),$.BV.makeTensor(R,W,A)}},2005:(Lt,ut,y)=>{"use strict";y.d(ut,{G:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({tile_:function R(k,A){const X=(0,H._1)(k,"x","tile","string_or_numeric");return q.hu(X.rank===A.length,()=>`Error in transpose: rank of input ${X.rank} must match length of reps ${A}.`),$.BV.runKernel(V.n9L,{x:X},{reps:A})}})},4927:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({topk_:function Y(W,k=1,A=!0){const X=(0,H._1)(W,"x","topk");if(0===X.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const Z=X.shape[X.shape.length-1];if(k<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${k}`);if(k>Z)throw new Error(`'k' passed to topk() must be <= the last dimension (${Z}) but got ${k}`);const G={x:X},it={k,sorted:A},[bt,K]=$.BV.runKernel(V.cWu,G,it);return{values:bt,indices:K}}})},9194:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>G});var $=y(687),V=y(2773),H=y(4251),q=y(1257),Y=y(5359),R=y(3037),W=y(1844),k=y(5048),A=y(4195),X=y(6027);const G=(0,A.op)({transpose_:function Z(it,bt,K){const st=(0,q._1)(it,"x","transpose");if(null==bt&&(bt=st.shape.map((lt,St)=>St).reverse()),Y.hu(st.rank===bt.length,()=>`Error in transpose: rank of input ${st.rank} must match length of perm ${bt}.`),bt.forEach(lt=>{Y.hu(lt>=0&&lt<st.rank,()=>`All entries in 'perm' must be between 0 and ${st.rank-1} but got ${bt}`)}),st.rank<=1)return st.clone();const et={x:st},dt={perm:bt};return"complex64"===st.dtype?(0,V.lu)(()=>{let lt=(0,X.k)(st),St=(0,W.a)(st);return lt=$.BV.runKernel(H.G3Y,{x:lt},dt),St=$.BV.runKernel(H.G3Y,{x:St},dt),K&&(St=(0,k.W)(St)),(0,R.P)(lt,St)}):$.BV.runKernel(H.G3Y,et,dt)}})},8130:(Lt,ut,y)=>{"use strict";y.d(ut,{T:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({unique_:function R(k,A=0){const X=(0,H._1)(k,"x","unique","string_or_numeric");(0,q.hu)(X.rank>0,()=>"The input tensor must be at least 1D");const Z={x:X},G={axis:A},[it,bt]=$.BV.runKernel(V.kpP,Z,G);return{values:it,indices:bt}}})},7715:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({unsortedSegmentSum_:function R(k,A,X){const Z=(0,H._1)(k,"x","unsortedSegmentSum"),G=(0,H._1)(A,"segmentIds","unsortedSegmentSum","int32");return(0,q.hu)((0,q.GN)(X),()=>"numSegments must be of dtype int"),$.BV.runKernel(V.Qvg,{x:Z,segmentIds:G},{numSegments:X})}})},2219:(Lt,ut,y)=>{"use strict";y.d(ut,{H:()=>W});var $=y(687),V=y(4251),H=y(1257),q=y(5359);const W=(0,y(4195).op)({unstack_:function R(k,A=0){const X=(0,H._1)(k,"x","unstack","string_or_numeric");return q.hu(A>=-X.shape.length&&A<X.shape.length,()=>`Axis = ${A} is not in [-${X.shape.length}, ${X.shape.length})`),$.BV.runKernel(V.ToN,{value:X},{axis:A})}})},2190:(Lt,ut,y)=>{"use strict";y.d(ut,{a:()=>k});var $=y(687),V=y(4251),H=y(1257),q=y(983),Y=y(3239);const k=(0,y(4195).op)({where_:function W(A,X,Z){const G=(0,H._1)(X,"a","where"),it=(0,H._1)(Z,"b","where"),bt=(0,H._1)(A,"condition","where","bool"),K=(0,Y.assertAndGetBroadcastShape)((0,Y.assertAndGetBroadcastShape)(bt.shape,G.shape),it.shape),st=(0,q.U)(bt,K),et=(0,q.U)(G,K),dt=(0,q.U)(it,K);return $.BV.runKernel(V.PhF,{condition:st,t:et,e:dt})}})},6467:(Lt,ut,y)=>{"use strict";y.d(ut,{l:()=>q});var $=y(687),V=y(5359),H=y(3037);function q(Y,R="float32"){if((0,V.Mu)(Y),"complex64"===R){const k=q(Y,"float32"),A=q(Y,"float32");return(0,H.P)(k,A)}const W=(0,V.wT)((0,V.NA)(Y),R);return $.BV.makeTensor(W,Y,R)}},3143:(Lt,ut,y)=>{"use strict";y.d(ut,{P:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({zerosLike_:function Y(W){const A={x:(0,H._1)(W,"x","zerosLike")};return $.BV.runKernel(V.RuY,A)}})},4705:(Lt,ut,y)=>{"use strict";function $(V){return V instanceof Float32Array||V instanceof Int32Array||V instanceof Uint8Array||V instanceof Uint8ClampedArray}y.d(ut,{j:()=>$})},4945:(Lt,ut,y)=>{"use strict";y.d(ut,{es:()=>Q,YD:()=>bt,_w:()=>pt,t3:()=>ft,FZ:()=>St,Vp:()=>lt,Vi:()=>dt});var $=y(5861),V=y(2918),H=y(5359);const q=20,Y=3,R=7;function W(B,ot,P,at){const nt=(0,H.e3)(ot),Gt=function k(B,ot,P,at){const nt=(0,H.NA)(ot),Gt=at[at.length-1],O=new Array(Gt).fill(0),Ct=ot.length,yt="complex64"===P?G(B):B;if(Ct>1)for(let vt=0;vt<nt/Gt;vt++){const xt=vt*Gt;for(let Mt=0;Mt<Gt;Mt++)O[Mt]=Math.max(O[Mt],A(yt[xt+Mt],0,P).length)}return O}(B,ot,P,nt),O=ot.length,Ct=Z(B,ot,P,nt,Gt),yt=["Tensor"];return at&&(yt.push(`  dtype: ${P}`),yt.push(`  rank: ${O}`),yt.push(`  shape: [${ot}]`),yt.push("  values:")),yt.push(Ct.map(vt=>"    "+vt).join("\n")),yt.join("\n")}function A(B,ot,P){let at;return at=Array.isArray(B)?`${parseFloat(B[0].toFixed(R))} + ${parseFloat(B[1].toFixed(R))}j`:(0,H.HD)(B)?`'${B}'`:"bool"===P?X(B):parseFloat(B.toFixed(R)).toString(),(0,H.oj)(at,ot)}function X(B){return 0===B?"false":"true"}function Z(B,ot,P,at,nt,Gt=!0){const O="complex64"===P?2:1,Ct=ot[0],yt=ot.length;if(0===yt)return"complex64"===P?[A(G(B)[0],0,P)]:"bool"===P?[X(B[0])]:[B[0].toString()];if(1===yt){if(Ct>q){let se=Array.from(B.slice(0,Y*O)),be=Array.from(B.slice((Ct-Y)*O,Ct*O));return"complex64"===P&&(se=G(se),be=G(be)),["["+se.map((Me,Xe)=>A(Me,nt[Xe],P)).join(", ")+", ..., "+be.map((Me,Xe)=>A(Me,nt[Ct-Y+Xe],P)).join(", ")+"]"]}return["["+("complex64"===P?G(B):Array.from(B)).map((jt,se)=>A(jt,nt[se],P)).join(", ")+"]"]}const vt=ot.slice(1),xt=at.slice(1),Mt=at[0]*O,It=[];if(Ct>q){for(let ee=0;ee<Y;ee++){const jt=ee*Mt;It.push(...Z(B.slice(jt,jt+Mt),vt,P,xt,nt,!1))}It.push("...");for(let ee=Ct-Y;ee<Ct;ee++){const jt=ee*Mt;It.push(...Z(B.slice(jt,jt+Mt),vt,P,xt,nt,ee===Ct-1))}}else for(let ee=0;ee<Ct;ee++){const jt=ee*Mt;It.push(...Z(B.slice(jt,jt+Mt),vt,P,xt,nt,ee===Ct-1))}const re=2===yt?",":"";It[0]="["+(Ct>0?It[0]+re:"");for(let ee=1;ee<It.length-1;ee++)It[ee]=" "+It[ee]+re;let Bt=",\n";for(let ee=2;ee<yt;ee++)Bt+="\n";return It[It.length-1]=" "+It[It.length-1]+"]"+(Gt?"":Bt),It}function G(B){const ot=[];for(let P=0;P<B.length;P+=2)ot.push([B[P],B[P+1]]);return ot}var it=y(1153);class bt{constructor(ot,P,at){if(this.dtype=P,this.shape=ot.slice(),this.size=H.NA(ot),null!=at){const nt=at.length;H.hu(nt===this.size,()=>`Length of values '${nt}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===P)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=at||H.rQ(P,this.size),this.strides=(0,H.e3)(ot)}set(ot,...P){0===P.length&&(P=[0]),H.hu(P.length===this.rank,()=>`The number of provided coordinates (${P.length}) must match the rank (${this.rank})`);const at=this.locToIndex(P);this.values[at]=ot}get(...ot){0===ot.length&&(ot=[0]);let P=0;for(const nt of ot){if(nt<0||nt>=this.shape[P])throw new Error(`Requested out of range element at ${ot}.   Buffer shape=${this.shape}`);P++}let at=ot[ot.length-1];for(let nt=0;nt<ot.length-1;++nt)at+=this.strides[nt]*ot[nt];return this.values[at]}locToIndex(ot){if(0===this.rank)return 0;if(1===this.rank)return ot[0];let P=ot[ot.length-1];for(let at=0;at<ot.length-1;++at)P+=this.strides[at]*ot[at];return P}indexToLoc(ot){if(0===this.rank)return[];if(1===this.rank)return[ot];const P=new Array(this.shape.length);for(let at=0;at<P.length-1;++at)P[at]=Math.floor(ot/this.strides[at]),ot-=P[at]*this.strides[at];return P[P.length-1]=ot,P}get rank(){return this.shape.length}toTensor(){return K().makeTensor(this.values,this.shape,this.dtype)}}let K=null,st=null,et=null;function dt(B){K=B}function lt(B){st=B}function St(B){et=B}class Q{constructor(ot,P,at,nt){this.kept=!1,this.isDisposedInternal=!1,this.shape=ot.slice(),this.dtype=P||"float32",this.size=H.NA(ot),this.strides=(0,H.e3)(ot),this.dataId=at,this.id=nt,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var ot=this;return(0,$.Z)(function*(){const P=yield ot.data();return st.buffer(ot.shape,ot.dtype,P)})()}bufferSync(){return st.buffer(this.shape,this.dtype,this.dataSync())}array(){var ot=this;return(0,$.Z)(function*(){const P=yield ot.data();return(0,H.GX)(ot.shape,P,"complex64"===ot.dtype)})()}arraySync(){return(0,H.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var ot=this;return(0,$.Z)(function*(){ot.throwIfDisposed();const P=K().read(ot.dataId);if("string"===ot.dtype){const at=yield P;try{return at.map(nt=>it.decodeString(nt))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return P})()}dataToGPU(ot){return this.throwIfDisposed(),K().readToGPU(this.dataId,ot)}dataSync(){this.throwIfDisposed();const ot=K().readSync(this.dataId);if("string"===this.dtype)try{return ot.map(P=>it.decodeString(P))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return ot}bytes(){var ot=this;return(0,$.Z)(function*(){ot.throwIfDisposed();const P=yield K().read(ot.dataId);return"string"===ot.dtype?P:new Uint8Array(P.buffer)})()}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),K().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(ot=!1){return st.print(this,ot)}clone(){return this.throwIfDisposed(),st.clone(this)}toString(ot=!1){return W(this.dataSync(),this.shape,this.dtype,ot)}cast(ot){return this.throwIfDisposed(),st.cast(this,ot)}variable(ot=!0,P,at){return this.throwIfDisposed(),K().makeVariable(this,ot,P,at)}}function ft(){return(0,V.R)("Tensor",()=>Q)}Object.defineProperty(Q,Symbol.hasInstance,{value:B=>!!B&&null!=B.data&&null!=B.dataSync&&null!=B.throwIfDisposed}),ft();class pt extends Q{constructor(ot,P,at,nt){super(ot.shape,ot.dtype,ot.dataId,nt),this.trainable=P,this.name=at}assign(ot){if(ot.dtype!==this.dtype)throw new Error(`dtype of the new value (${ot.dtype}) and previous value (${this.dtype}) must match`);if(!H.cO(ot.shape,this.shape))throw new Error(`shape of the new value (${ot.shape}) and previous value (${this.shape}) must match`);K().disposeTensor(this),this.dataId=ot.dataId,K().incRef(this,null)}dispose(){K().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(pt,Symbol.hasInstance,{value:B=>B instanceof Q&&null!=B.assign&&B.assign instanceof Function})},7664:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{assertTypesMatch:()=>Y,getTensorsInContainer:()=>W,isTensorInList:()=>R,makeTypesMatch:()=>q});var $=y(4945),V=y(1216),H=y(5359);function q(X,Z){if(X.dtype===Z.dtype)return[X,Z];const G=(0,V.x8)(X.dtype,Z.dtype);return[X.cast(G),Z.cast(G)]}function Y(X,Z){(0,H.hu)(X.dtype===Z.dtype,()=>`The dtypes of the first(${X.dtype}) and second(${Z.dtype}) input must match`)}function R(X,Z){return Z.some(G=>G.id===X.id)}function W(X){const Z=[];return k(X,Z,new Set),Z}function k(X,Z,G){if(null==X)return;if(X instanceof $.es)return void Z.push(X);if(!function A(X){return Array.isArray(X)||"object"==typeof X}(X))return;const it=X;for(const bt in it){const K=it[bt];G.has(K)||(G.add(K),k(K,Z,G))}}},1257:(Lt,ut,y)=>{"use strict";y.d(ut,{C:()=>W,_1:()=>X,sI:()=>Z});var $=y(687),V=y(5527),H=y(4945),q=y(1216),Y=y(1153),R=y(5359);function W(G,it){let bt=G;if((0,Y.isTypedArray)(G))return"string"===it?[]:[G.length];if((0,q.Oq)(G))return[G.height,G.width*(G.channels||"RGBA").length];if((0,q.$F)(G))return[G.buffer.size/(null==it?4:(0,R.bT)(it))];if(!Array.isArray(G))return[];const K=[];for(;Array.isArray(bt)||(0,Y.isTypedArray)(bt)&&"string"!==it;)K.push(bt.length),bt=bt[0];return Array.isArray(G)&&(0,V.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&k(G,K,[]),K}function k(G,it,bt){if(bt=bt||[],!Array.isArray(G)&&!(0,Y.isTypedArray)(G))return void(0,R.hu)(0===it.length,()=>`Element arr[${bt.join("][")}] is a primitive, but should be an array/TypedArray of ${it[0]} elements`);(0,R.hu)(it.length>0,()=>`Element arr[${bt.join("][")}] should be a primitive, but is an array of ${G.length} elements`),(0,R.hu)(G.length===it[0],()=>`Element arr[${bt.join("][")}] should have ${it[0]} elements, but has ${G.length} elements`);const K=it.slice(1);for(let st=0;st<G.length;++st)k(G[st],K,bt.concat(st))}function A(G,it,bt,K){if("string_or_numeric"!==G){if(null==G)throw new Error("Expected dtype cannot be null.");if("numeric"!==G&&G!==it||"numeric"===G&&"string"===it)throw new Error(`Argument '${bt}' passed to '${K}' must be ${G} tensor, but got ${it} tensor`)}}function X(G,it,bt,K="numeric"){if(G instanceof(0,H.t3)())return A(K,G.dtype,it,bt),G;let st=(0,R.D2)(G);if("string"!==st&&["bool","int32","float32"].indexOf(K)>=0&&(st=K),A(K,st,it,bt),null==G||!(0,Y.isTypedArray)(G)&&!Array.isArray(G)&&"number"!=typeof G&&"boolean"!=typeof G&&"string"!=typeof G)throw new Error(`Argument '${it}' passed to '${bt}' must be a Tensor or TensorLike, but got '${null==G?"null":G.constructor.name}'`);const et=W(G,st);!(0,Y.isTypedArray)(G)&&!Array.isArray(G)&&(G=[G]);const lt="string"!==st?(0,Y.toTypedArray)(G,st):(0,Y.flatten)(G,[],!0);return $.BV.makeTensor(lt,et,st)}function Z(G,it,bt,K="numeric"){if(!Array.isArray(G))throw new Error(`Argument ${it} passed to ${bt} must be a \`Tensor[]\` or \`TensorLike[]\``);return G.map((et,dt)=>X(et,`${it}[${dt}]`,bt,K))}},1216:(Lt,ut,y)=>{"use strict";y.d(ut,{$F:()=>X,Oq:()=>A,x8:()=>W,yw:()=>$,z4:()=>k});var $=function(Z){return Z.R0="R0",Z.R1="R1",Z.R2="R2",Z.R3="R3",Z.R4="R4",Z.R5="R5",Z.R6="R6",Z}($||{}),V=function(Z){return Z.float32="float32",Z.int32="int32",Z.bool="int32",Z.complex64="complex64",Z}(V||{}),H=function(Z){return Z.float32="float32",Z.int32="int32",Z.bool="bool",Z.complex64="complex64",Z}(H||{}),q=function(Z){return Z.float32="float32",Z.int32="float32",Z.bool="float32",Z.complex64="complex64",Z}(q||{}),Y=function(Z){return Z.float32="complex64",Z.int32="complex64",Z.bool="complex64",Z.complex64="complex64",Z}(Y||{});const R={float32:q,int32:V,bool:H,complex64:Y};function W(Z,G){if("string"===Z||"string"===G){if("string"===Z&&"string"===G)return"string";throw new Error(`Can not upcast ${Z} with ${G}`)}return R[Z][G]}function k(Z){return W(Z,"int32")}function A(Z){return null!=Z&&"object"==typeof Z&&"texture"in Z&&Z.texture instanceof WebGLTexture}function X(Z){return typeof GPUBuffer<"u"&&null!=Z&&"object"==typeof Z&&"buffer"in Z&&Z.buffer instanceof GPUBuffer}},1153:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{arraysEqual:()=>H.cO,arraysEqualWithNull:()=>H.DK,assert:()=>H.hu,assertNonNegativeIntegerDimensions:()=>H.Mu,assertNonNull:()=>H.Cq,assertShapesMatch:()=>H.k5,bytesFromStringArray:()=>H.Ub,bytesPerElement:()=>H.bT,checkConversionForErrors:()=>H.D5,clamp:()=>H.uZ,computeStrides:()=>H.e3,convertBackendValuesAndArrayBuffer:()=>H.KS,createScalarValue:()=>pt,createShuffledIndices:()=>H.U$,decodeString:()=>Gt,distSquared:()=>H.E7,encodeString:()=>nt,fetch:()=>at,fingerPrint64:()=>ft,flatten:()=>Ct,getArrayFromDType:()=>H.rQ,getTypedArrayFromDType:()=>H.WP,hasEncodingLoss:()=>H.QB,hexToLong:()=>W,indexToLoc:()=>H.NE,inferDtype:()=>H.D2,inferFromImplicitShape:()=>H.JZ,isBoolean:()=>H.jn,isFunction:()=>H.mf,isInt:()=>H.GN,isNumber:()=>H.hj,isPromise:()=>H.tI,isScalarShape:()=>H.xH,isString:()=>H.HD,isTypedArray:()=>O,isValidDtype:()=>H.LP,locToIndex:()=>H.qy,makeOnesTypedArray:()=>H.p8,makeZerosNestedTypedArray:()=>H.l6,makeZerosTypedArray:()=>H.wT,nearestDivisor:()=>H.jP,nearestLargerEven:()=>H.nY,now:()=>P,parseAxisParam:()=>H.EC,randUniform:()=>H.bj,repeatedTry:()=>H.WD,rightPad:()=>H.oj,shuffle:()=>H.TV,shuffleCombo:()=>H.d7,sizeFromShape:()=>H.NA,sizeToSquarishShape:()=>H.YP,squeezeShape:()=>H.bp,sum:()=>H.Sm,swap:()=>H.LF,tanh:()=>H.AE,toNestedArray:()=>H.GX,toTypedArray:()=>ot});var $=y(5527),V=y(4705),H=y(5359),q=y(186);const R=y.n(q)()||q;function W(yt){return R.fromString(yt,!0,16)}const k=W("c3a5c85c97cb3127"),A=W("b492b66fbe98f273"),X=W("9ae16a3b2f90404f");function Z(yt){return yt.xor(yt.shru(47))}function G(yt,vt,xt){const Mt=yt.slice(vt,vt+xt);return R.fromBytes(Array.from(Mt),!0,!0)}function it(yt,vt){return G(yt,vt,8)}function bt(yt,vt){return G(yt,vt,4)}function K(yt,vt){return 0===vt?yt:yt.shru(vt).or(yt.shl(64-vt))}function st(yt,vt,xt=W("9ddfea08eb382d69")){let Mt=yt.xor(vt).mul(xt);Mt=Mt.xor(Mt.shru(47));let It=vt.xor(Mt).mul(xt);return It=It.xor(It.shru(47)),It=It.mul(xt),It}function dt(yt,vt,xt,Mt){return function et(yt,vt,xt,Mt,It,re){It=It.add(yt),re=K(re.add(It).add(Mt),21);const Bt=It;return It=(It=It.add(vt)).add(xt),re=re.add(K(It,44)),[It.add(Mt),re.add(Bt)]}(it(yt,vt),it(yt,vt+8),it(yt,vt+16),it(yt,vt+24),xt,Mt)}function ft(yt,vt=yt.length){const xt=R.fromNumber(81,!0);if(vt<=32)return vt<=16?function lt(yt,vt=yt.length){if(vt>=8){const xt=X.add(2*vt),Mt=it(yt,0).add(X),It=it(yt,vt-8);return st(K(It,37).mul(xt).add(Mt),K(Mt,25).add(It).mul(xt),xt)}if(vt>=4){const xt=X.add(2*vt);return st(bt(yt,0).shl(3).add(vt),bt(yt,vt-4),xt)}if(vt>0){const Bt=vt+(yt[vt-1]<<2);return Z(X.mul(yt[0]+(yt[vt>>1]<<8)).xor(k.mul(Bt))).mul(X)}return X}(yt,vt):function St(yt,vt=yt.length){const xt=X.add(2*vt),Mt=it(yt,0).mul(A),It=it(yt,8),re=it(yt,vt-8).mul(xt),Bt=it(yt,vt-16).mul(X);return st(K(Mt.add(It),43).add(K(re,30)).add(Bt),Mt.add(K(It.add(X),18)).add(re),xt)}(yt,vt);if(vt<=64)return function Q(yt,vt=yt.length){const xt=X.add(2*vt),Mt=it(yt,0).mul(X),It=it(yt,8),re=it(yt,vt-8).mul(xt),Bt=it(yt,vt-16).mul(X),ee=K(Mt.add(It),43).add(K(re,30)).add(Bt),jt=st(ee,Mt.add(K(It.add(X),18)).add(re),xt),se=it(yt,16).mul(xt),be=it(yt,24),Me=ee.add(it(yt,vt-32)).mul(xt),Xe=jt.add(it(yt,vt-24)).mul(xt);return st(K(se.add(be),43).add(K(Me,30)).add(Xe),se.add(K(be.add(Mt),18)).add(Me),xt)}(yt,vt);let Mt=xt,It=xt.mul(A).add(113),re=Z(It.mul(X).add(113)).mul(X),Bt=[R.UZERO,R.UZERO],ee=[R.UZERO,R.UZERO];Mt=Mt.mul(X).add(it(yt,0));let jt=0;const se=64*(vt-1>>6),be=se+(vt-1&63)-63;do{Mt=K(Mt.add(It).add(Bt[0]).add(it(yt,jt+8)),37).mul(A),It=K(It.add(Bt[1]).add(it(yt,jt+48)),42).mul(A),Mt=Mt.xor(ee[1]),It=It.add(Bt[0]).add(it(yt,jt+40)),re=K(re.add(ee[0]),33).mul(A),Bt=dt(yt,jt,Bt[1].mul(A),Mt.add(ee[0])),ee=dt(yt,jt+32,re.add(ee[1]),It.add(it(yt,jt+16))),[re,Mt]=[Mt,re],jt+=64}while(jt!==se);const Me=A.add(re.and(255).shl(1));return jt=be,ee[0]=ee[0].add(vt-1&63),Bt[0]=Bt[0].add(ee[0]),ee[0]=ee[0].add(Bt[0]),Mt=K(Mt.add(It).add(Bt[0]).add(it(yt,jt+8)),37).mul(Me),It=K(It.add(Bt[1]).add(it(yt,jt+48)),42).mul(Me),Mt=Mt.xor(ee[1].mul(9)),It=It.add(Bt[0].mul(9).add(it(yt,jt+40))),re=K(re.add(ee[0]),33).mul(Me),Bt=dt(yt,jt,Bt[1].mul(Me),Mt.add(ee[0])),ee=dt(yt,jt+32,re.add(ee[1]),It.add(it(yt,jt+16))),[re,Mt]=[Mt,re],st(st(Bt[0],ee[0],Me).add(Z(It).mul(k)).add(re),st(Bt[1],ee[1],Me).add(Mt),Me)}function pt(yt,vt){return"string"===vt?nt(yt):ot([yt],vt)}function ot(yt,vt){if("string"===vt)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(yt)&&(yt=Ct(yt)),(0,$.OB)().getBool("DEBUG")&&H.D5(yt,vt),function B(yt,vt){return yt instanceof Float32Array&&"float32"===vt||yt instanceof Int32Array&&"int32"===vt||yt instanceof Uint8Array&&"bool"===vt}(yt,vt))return yt;if(null==vt||"float32"===vt||"complex64"===vt)return new Float32Array(yt);if("int32"===vt)return new Int32Array(yt);if("bool"===vt){const xt=new Uint8Array(yt.length);for(let Mt=0;Mt<xt.length;++Mt)0!==Math.round(yt[Mt])&&(xt[Mt]=1);return xt}throw new Error(`Unknown data type ${vt}`)}function P(){return(0,$.OB)().platform.now()}function at(yt,vt){return(0,$.OB)().platform.fetch(yt,vt)}function nt(yt,vt="utf-8"){return vt=vt||"utf-8",(0,$.OB)().platform.encode(yt,vt)}function Gt(yt,vt="utf-8"){return vt=vt||"utf-8",(0,$.OB)().platform.decode(yt,vt)}function O(yt){return null!=(0,$.OB)().platform.isTypedArray?(0,$.OB)().platform.isTypedArray(yt):(0,V.j)(yt)}function Ct(yt,vt=[],xt=!1){if(null==vt&&(vt=[]),"boolean"==typeof yt||"number"==typeof yt||"string"==typeof yt||H.tI(yt)||null==yt||O(yt)&&xt)vt.push(yt);else if(Array.isArray(yt)||O(yt))for(let Mt=0;Mt<yt.length;++Mt)Ct(yt[Mt],vt,xt);else{let Mt=-1;for(const It of Object.keys(yt))/^([1-9]+[0-9]*|0)$/.test(It)&&(Mt=Math.max(Mt,Number(It)));for(let It=0;It<=Mt;It++)Ct(yt[It],vt,xt)}return vt}},5359:(Lt,ut,y)=>{"use strict";function $(ne){let pe=ne.length,Ie=0;for(;pe>0;)Ie=Math.random()*pe|0,pe--,Y(ne,pe,Ie)}function V(ne,pe){if(ne.length!==pe.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${ne.length}Second array length was ${pe.length}`);let Ie=ne.length,Je=0;for(;Ie>0;)Je=Math.random()*Ie|0,Ie--,Y(ne,Ie,Je),Y(pe,Ie,Je)}function H(ne,pe,Ie){return Math.max(ne,Math.min(pe,Ie))}function q(ne){return ne%2==0?ne:ne+1}function Y(ne,pe,Ie){const Je=ne[pe];ne[pe]=ne[Ie],ne[Ie]=Je}function R(ne){let pe=0;for(let Ie=0;Ie<ne.length;Ie++)pe+=ne[Ie];return pe}function W(ne,pe){const Ie=Math.random();return pe*Ie+(1-Ie)*ne}function k(ne,pe){let Ie=0;for(let Je=0;Je<ne.length;Je++){const Gn=Number(ne[Je])-Number(pe[Je]);Ie+=Gn*Gn}return Ie}function A(ne,pe){if(!ne)throw new Error("string"==typeof pe?pe:pe())}function X(ne,pe,Ie=""){A(K(ne,pe),()=>Ie+` Shapes ${ne} and ${pe} must match`)}function Z(ne){A(null!=ne,()=>"The input to the tensor constructor must be a non-null value.")}function G(ne){if(0===ne.length)return 1;let pe=ne[0];for(let Ie=1;Ie<ne.length;Ie++)pe*=ne[Ie];return pe}function it(ne){return 0===ne.length}function bt(ne,pe){if(ne===pe)return!0;if(null==ne||null==pe||ne.length!==pe.length)return!1;for(let Ie=0;Ie<ne.length;Ie++)if(null!==ne[Ie]&&null!==pe[Ie]&&ne[Ie]!==pe[Ie])return!1;return!0}function K(ne,pe){if(ne===pe)return!0;if(null==ne||null==pe||ne.length!==pe.length)return!1;for(let Ie=0;Ie<ne.length;Ie++)if(ne[Ie]!==pe[Ie])return!1;return!0}function st(ne){return ne%1==0}function et(ne){if(null!=Math.tanh)return Math.tanh(ne);if(ne===1/0)return 1;if(ne===-1/0)return-1;{const pe=Math.exp(2*ne);return(pe-1)/(pe+1)}}function dt(ne){const pe=Math.ceil(Math.sqrt(ne));return[pe,Math.ceil(ne/pe)]}function lt(ne){const pe=new Uint32Array(ne);for(let Ie=0;Ie<ne;++Ie)pe[Ie]=Ie;return $(pe),pe}function St(ne,pe){return pe<=ne.length?ne:ne+" ".repeat(pe-ne.length)}function Q(ne,pe=(Gn=>0),Ie,Je){return new Promise((Gn,Er)=>{let Nn=0;const Yn=()=>{if(ne())return void Gn();Nn++;const hi=pe(Nn);null!=Ie&&Nn>=Ie?Er():null!=Je?Je(Yn,hi):setTimeout(Yn,hi)};Yn()})}function ft(ne,pe){let Ie=1,Je=-1;for(let Er=0;Er<ne.length;++Er)if(ne[Er]>=0)Ie*=ne[Er];else if(-1===ne[Er]){if(-1!==Je)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Je} and dim ${Er}`);Je=Er}else if(ne[Er]<0)throw Error(`Shapes can not be < 0. Found ${ne[Er]} at dim ${Er}`);if(-1===Je){if(pe>0&&pe!==Ie)throw Error(`Size(${pe}) must match the product of shape ${ne}`);return ne}if(0===Ie)throw Error(`Cannot infer the missing size in [${ne}] when there are 0 elements`);if(pe%Ie!=0)throw Error(`The implicit shape can't be a fractional number. Got ${pe} / ${Ie}`);const Gn=ne.slice();return Gn[Je]=pe/Ie,Gn}function pt(ne,pe){const Ie=pe.length;return A((ne=null==ne?pe.map((Je,Gn)=>Gn):[].concat(ne)).every(Je=>Je>=-Ie&&Je<Ie),()=>`All values in axis param must be in range [-${Ie}, ${Ie}) but got axis ${ne}`),A(ne.every(Je=>st(Je)),()=>`All values in axis param must be integers but got axis ${ne}`),ne.map(Je=>Je<0?Ie+Je:Je)}function B(ne,pe){const Ie=[],Je=[],Gn=null!=pe&&Array.isArray(pe)&&0===pe.length,Er=null==pe||Gn?null:pt(pe,ne).sort();let Nn=0;for(let Yn=0;Yn<ne.length;++Yn){if(null!=Er){if(Er[Nn]===Yn&&1!==ne[Yn])throw new Error(`Can't squeeze axis ${Yn} since its dim '${ne[Yn]}' is not 1`);(null==Er[Nn]||Er[Nn]>Yn)&&1===ne[Yn]&&(Ie.push(ne[Yn]),Je.push(Yn)),Er[Nn]<=Yn&&Nn++}1!==ne[Yn]&&(Ie.push(ne[Yn]),Je.push(Yn))}return{newShape:Ie,keptDims:Je}}function ot(ne,pe){return P(ne,pe)}function P(ne,pe){let Ie=null;if(null==ne||"float32"===ne)Ie=new Float32Array(pe);else if("int32"===ne)Ie=new Int32Array(pe);else if("bool"===ne)Ie=new Uint8Array(pe);else{if("string"!==ne)throw new Error(`Unknown data type ${ne}`);Ie=new Array(pe)}return Ie}function at(ne,pe){for(let Ie=0;Ie<ne.length;Ie++){const Je=ne[Ie];if(isNaN(Je)||!isFinite(Je))throw Error(`A tensor of type ${pe} being uploaded contains ${Je}.`)}}function nt(ne){return"bool"===ne||"complex64"===ne||"float32"===ne||"int32"===ne||"string"===ne}function Gt(ne,pe){return!("complex64"===pe||"float32"===pe&&"complex64"!==ne||"int32"===pe&&"float32"!==ne&&"complex64"!==ne||"bool"===pe&&"bool"===ne)}function O(ne){if("float32"===ne||"int32"===ne)return 4;if("complex64"===ne)return 8;if("bool"===ne)return 1;throw new Error(`Unknown dtype ${ne}`)}function Ct(ne){if(null==ne)return 0;let pe=0;return ne.forEach(Ie=>pe+=Ie.length),pe}function yt(ne){return"string"==typeof ne||ne instanceof String}function vt(ne){return"boolean"==typeof ne}function xt(ne){return"number"==typeof ne}function Mt(ne){return Array.isArray(ne)?Mt(ne[0]):ne instanceof Float32Array?"float32":ne instanceof Int32Array||ne instanceof Uint8Array||ne instanceof Uint8ClampedArray?"int32":xt(ne)?"float32":yt(ne)?"string":vt(ne)?"bool":"float32"}function It(ne){return!!(ne&&ne.constructor&&ne.call&&ne.apply)}function re(ne,pe){for(let Ie=pe;Ie<ne;++Ie)if(ne%Ie==0)return Ie;return ne}function Bt(ne){const pe=ne.length;if(pe<2)return[];const Ie=new Array(pe-1);Ie[pe-2]=ne[pe-1];for(let Je=pe-3;Je>=0;--Je)Ie[Je]=Ie[Je+1]*ne[Je+1];return Ie}function ee(ne,pe,Ie,Je=!1){const Gn=new Array;if(1===pe.length){const Er=pe[0]*(Je?2:1);for(let Nn=0;Nn<Er;Nn++)Gn[Nn]=Ie[ne+Nn]}else{const Er=pe[0],Nn=pe.slice(1),Yn=Nn.reduce((hi,di)=>hi*di)*(Je?2:1);for(let hi=0;hi<Er;hi++)Gn[hi]=ee(ne+hi*Yn,Nn,Ie,Je)}return Gn}function jt(ne,pe,Ie=!1){if(0===ne.length)return pe[0];const Je=ne.reduce((Gn,Er)=>Gn*Er)*(Ie?2:1);if(0===Je)return[];if(Je!==pe.length)throw new Error(`[${ne}] does not match the input size ${pe.length}${Ie?" for a complex tensor":""}.`);return ee(0,ne,pe,Ie)}function se(ne,pe){if(Array.isArray(ne))return ne;if("float32"===pe)return ne instanceof Float32Array?ne:new Float32Array(ne);if("int32"===pe)return ne instanceof Int32Array?ne:new Int32Array(ne);if("bool"===pe||"string"===pe)return Uint8Array.from(new Int32Array(ne));throw new Error(`Unknown dtype ${pe}`)}function be(ne,pe){const Ie=Me(ne,pe);for(let Je=0;Je<Ie.length;Je++)Ie[Je]=1;return Ie}function Me(ne,pe){if(null==pe||"float32"===pe||"complex64"===pe)return new Float32Array(ne);if("int32"===pe)return new Int32Array(ne);if("bool"===pe)return new Uint8Array(ne);throw new Error(`Unknown data type ${pe}`)}function Xe(ne,pe){const Ie=ne.reduce((Je,Gn)=>Je*Gn,1);if(null==pe||"float32"===pe)return jt(ne,new Float32Array(Ie));if("int32"===pe)return jt(ne,new Int32Array(Ie));if("bool"===pe)return jt(ne,new Uint8Array(Ie));throw new Error(`Unknown data type ${pe}`)}function Ue(ne){ne.forEach(pe=>{A(Number.isInteger(pe)&&pe>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${ne}].`)})}function De(ne,pe,Ie){if(0===pe)return 0;if(1===pe)return ne[0];let Je=ne[ne.length-1];for(let Gn=0;Gn<ne.length-1;++Gn)Je+=Ie[Gn]*ne[Gn];return Je}function Tn(ne,pe,Ie){if(0===pe)return[];if(1===pe)return[ne];const Je=new Array(pe);for(let Gn=0;Gn<Je.length-1;++Gn)Je[Gn]=Math.floor(ne/Ie[Gn]),ne-=Je[Gn]*Ie[Gn];return Je[Je.length-1]=ne,Je}function On(ne){return ne&&ne.then&&"function"==typeof ne.then}y.d(ut,{AE:()=>et,Cq:()=>Z,D2:()=>Mt,D5:()=>at,DK:()=>bt,E7:()=>k,EC:()=>pt,GN:()=>st,GX:()=>jt,HD:()=>yt,JZ:()=>ft,KS:()=>se,LF:()=>Y,LP:()=>nt,Mu:()=>Ue,NA:()=>G,NE:()=>Tn,QB:()=>Gt,Sm:()=>R,TV:()=>$,U$:()=>lt,Ub:()=>Ct,WD:()=>Q,WP:()=>ot,YP:()=>dt,bT:()=>O,bj:()=>W,bp:()=>B,cO:()=>K,d7:()=>V,e3:()=>Bt,hj:()=>xt,hu:()=>A,jP:()=>re,jn:()=>vt,k5:()=>X,l6:()=>Xe,mf:()=>It,nY:()=>q,oj:()=>St,p8:()=>be,qy:()=>De,rQ:()=>P,tI:()=>On,uZ:()=>H,wT:()=>Me,xH:()=>it})},1568:(Lt,ut,y)=>{"use strict";var V=y(8570);function H(q){var Y=[1/0,1/0,-1/0,-1/0];return V.coordEach(q,function(R){Y[0]>R[0]&&(Y[0]=R[0]),Y[1]>R[1]&&(Y[1]=R[1]),Y[2]<R[0]&&(Y[2]=R[0]),Y[3]<R[1]&&(Y[3]=R[1])}),Y}H.default=H,ut.Z=H},621:(Lt,ut)=>{"use strict";function y(P,at,nt){void 0===nt&&(nt={});var Gt={type:"Feature"};return(0===nt.id||nt.id)&&(Gt.id=nt.id),nt.bbox&&(Gt.bbox=nt.bbox),Gt.properties=at||{},Gt.geometry=P,Gt}function V(P,at,nt){if(void 0===nt&&(nt={}),!P)throw new Error("coordinates is required");if(!Array.isArray(P))throw new Error("coordinates must be an Array");if(P.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!ft(P[0])||!ft(P[1]))throw new Error("coordinates must contain numbers");return y({type:"Point",coordinates:P},at,nt)}function q(P,at,nt){void 0===nt&&(nt={});for(var Gt=0,O=P;Gt<O.length;Gt++){var Ct=O[Gt];if(Ct.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var yt=0;yt<Ct[Ct.length-1].length;yt++)if(Ct[Ct.length-1][yt]!==Ct[0][yt])throw new Error("First and last Position are not equivalent.")}return y({type:"Polygon",coordinates:P},at,nt)}function R(P,at,nt){if(void 0===nt&&(nt={}),P.length<2)throw new Error("coordinates must be an array of two or more positions");return y({type:"LineString",coordinates:P},at,nt)}function k(P,at){void 0===at&&(at={});var nt={type:"FeatureCollection"};return at.id&&(nt.id=at.id),at.bbox&&(nt.bbox=at.bbox),nt.features=P,nt}function A(P,at,nt){return void 0===nt&&(nt={}),y({type:"MultiLineString",coordinates:P},at,nt)}function X(P,at,nt){return void 0===nt&&(nt={}),y({type:"MultiPoint",coordinates:P},at,nt)}function Z(P,at,nt){return void 0===nt&&(nt={}),y({type:"MultiPolygon",coordinates:P},at,nt)}function bt(P,at){void 0===at&&(at="kilometers");var nt=ut.factors[at];if(!nt)throw new Error(at+" units is invalid");return P*nt}function K(P,at){void 0===at&&(at="kilometers");var nt=ut.factors[at];if(!nt)throw new Error(at+" units is invalid");return P/nt}function dt(P){return P%(2*Math.PI)*180/Math.PI}function ft(P){return!isNaN(P)&&null!==P&&!Array.isArray(P)}Object.defineProperty(ut,"__esModule",{value:!0}),ut.earthRadius=6371008.8,ut.factors={centimeters:100*ut.earthRadius,centimetres:100*ut.earthRadius,degrees:ut.earthRadius/111325,feet:3.28084*ut.earthRadius,inches:39.37*ut.earthRadius,kilometers:ut.earthRadius/1e3,kilometres:ut.earthRadius/1e3,meters:ut.earthRadius,metres:ut.earthRadius,miles:ut.earthRadius/1609.344,millimeters:1e3*ut.earthRadius,millimetres:1e3*ut.earthRadius,nauticalmiles:ut.earthRadius/1852,radians:1,yards:1.0936*ut.earthRadius},ut.unitsFactors={centimeters:100,centimetres:100,degrees:1/111325,feet:3.28084,inches:39.37,kilometers:.001,kilometres:.001,meters:1,metres:1,miles:1/1609.344,millimeters:1e3,millimetres:1e3,nauticalmiles:1/1852,radians:1/ut.earthRadius,yards:1.0936133},ut.areaFactors={acres:247105e-9,centimeters:1e4,centimetres:1e4,feet:10.763910417,hectares:1e-4,inches:1550.003100006,kilometers:1e-6,kilometres:1e-6,meters:1,metres:1,miles:386e-9,millimeters:1e6,millimetres:1e6,yards:1.195990046},ut.feature=y,ut.geometry=function $(P,at,nt){switch(void 0===nt&&(nt={}),P){case"Point":return V(at).geometry;case"LineString":return R(at).geometry;case"Polygon":return q(at).geometry;case"MultiPoint":return X(at).geometry;case"MultiLineString":return A(at).geometry;case"MultiPolygon":return Z(at).geometry;default:throw new Error(P+" is invalid")}},ut.point=V,ut.points=function H(P,at,nt){return void 0===nt&&(nt={}),k(P.map(function(Gt){return V(Gt,at)}),nt)},ut.polygon=q,ut.polygons=function Y(P,at,nt){return void 0===nt&&(nt={}),k(P.map(function(Gt){return q(Gt,at)}),nt)},ut.lineString=R,ut.lineStrings=function W(P,at,nt){return void 0===nt&&(nt={}),k(P.map(function(Gt){return R(Gt,at)}),nt)},ut.featureCollection=k,ut.multiLineString=A,ut.multiPoint=X,ut.multiPolygon=Z,ut.geometryCollection=function G(P,at,nt){return void 0===nt&&(nt={}),y({type:"GeometryCollection",geometries:P},at,nt)},ut.round=function it(P,at){if(void 0===at&&(at=0),at&&!(at>=0))throw new Error("precision must be a positive number");var nt=Math.pow(10,at||0);return Math.round(P*nt)/nt},ut.radiansToLength=bt,ut.lengthToRadians=K,ut.lengthToDegrees=function st(P,at){return dt(K(P,at))},ut.bearingToAzimuth=function et(P){var at=P%360;return at<0&&(at+=360),at},ut.radiansToDegrees=dt,ut.degreesToRadians=function lt(P){return P%360*Math.PI/180},ut.convertLength=function St(P,at,nt){if(void 0===at&&(at="kilometers"),void 0===nt&&(nt="kilometers"),!(P>=0))throw new Error("length must be a positive number");return bt(K(P,at),nt)},ut.convertArea=function Q(P,at,nt){if(void 0===at&&(at="meters"),void 0===nt&&(nt="kilometers"),!(P>=0))throw new Error("area must be a positive number");var Gt=ut.areaFactors[at];if(!Gt)throw new Error("invalid original units");var O=ut.areaFactors[nt];if(!O)throw new Error("invalid final units");return P/Gt*O},ut.isNumber=ft,ut.isObject=function pt(P){return!!P&&P.constructor===Object},ut.validateBBox=function B(P){if(!P)throw new Error("bbox is required");if(!Array.isArray(P))throw new Error("bbox must be an Array");if(4!==P.length&&6!==P.length)throw new Error("bbox must be an Array of 4 or 6 numbers");P.forEach(function(at){if(!ft(at))throw new Error("bbox must only contain numbers")})},ut.validateId=function ot(P){if(!P)throw new Error("id is required");if(-1===["string","number"].indexOf(typeof P))throw new Error("id must be a number or a string")}},8570:(Lt,ut,y)=>{"use strict";Object.defineProperty(ut,"__esModule",{value:!0});var $=y(621);function V(lt,St,Q){if(null!==lt)for(var ft,pt,B,ot,P,at,nt,Ct,Gt=0,O=0,yt=lt.type,vt="FeatureCollection"===yt,xt="Feature"===yt,Mt=vt?lt.features.length:1,It=0;It<Mt;It++){P=(Ct=!!(nt=vt?lt.features[It].geometry:xt?lt.geometry:lt)&&"GeometryCollection"===nt.type)?nt.geometries.length:1;for(var re=0;re<P;re++){var Bt=0,ee=0;if(null!==(ot=Ct?nt.geometries[re]:nt)){at=ot.coordinates;var jt=ot.type;switch(Gt=!Q||"Polygon"!==jt&&"MultiPolygon"!==jt?0:1,jt){case null:break;case"Point":if(!1===St(at,O,It,Bt,ee))return!1;O++,Bt++;break;case"LineString":case"MultiPoint":for(ft=0;ft<at.length;ft++){if(!1===St(at[ft],O,It,Bt,ee))return!1;O++,"MultiPoint"===jt&&Bt++}"LineString"===jt&&Bt++;break;case"Polygon":case"MultiLineString":for(ft=0;ft<at.length;ft++){for(pt=0;pt<at[ft].length-Gt;pt++){if(!1===St(at[ft][pt],O,It,Bt,ee))return!1;O++}"MultiLineString"===jt&&Bt++,"Polygon"===jt&&ee++}"Polygon"===jt&&Bt++;break;case"MultiPolygon":for(ft=0;ft<at.length;ft++){for(ee=0,pt=0;pt<at[ft].length;pt++){for(B=0;B<at[ft][pt].length-Gt;B++){if(!1===St(at[ft][pt][B],O,It,Bt,ee))return!1;O++}ee++}Bt++}break;case"GeometryCollection":for(ft=0;ft<ot.geometries.length;ft++)if(!1===V(ot.geometries[ft],St,Q))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function q(lt,St){var Q;switch(lt.type){case"FeatureCollection":for(Q=0;Q<lt.features.length&&!1!==St(lt.features[Q].properties,Q);Q++);break;case"Feature":St(lt.properties,0)}}function R(lt,St){if("Feature"===lt.type)St(lt,0);else if("FeatureCollection"===lt.type)for(var Q=0;Q<lt.features.length&&!1!==St(lt.features[Q],Q);Q++);}function A(lt,St){var Q,ft,pt,B,ot,P,at,nt,Gt,O,Ct=0,yt="FeatureCollection"===lt.type,vt="Feature"===lt.type,xt=yt?lt.features.length:1;for(Q=0;Q<xt;Q++){for(nt=yt?lt.features[Q].properties:vt?lt.properties:{},Gt=yt?lt.features[Q].bbox:vt?lt.bbox:void 0,O=yt?lt.features[Q].id:vt?lt.id:void 0,ot=(at=!!(P=yt?lt.features[Q].geometry:vt?lt.geometry:lt)&&"GeometryCollection"===P.type)?P.geometries.length:1,pt=0;pt<ot;pt++)if(null!==(B=at?P.geometries[pt]:P))switch(B.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===St(B,Ct,nt,Gt,O))return!1;break;case"GeometryCollection":for(ft=0;ft<B.geometries.length;ft++)if(!1===St(B.geometries[ft],Ct,nt,Gt,O))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===St(null,Ct,nt,Gt,O))return!1;Ct++}}function Z(lt,St){A(lt,function(Q,ft,pt,B,ot){var at,P=null===Q?null:Q.type;switch(P){case null:case"Point":case"LineString":case"Polygon":return!1!==St($.feature(Q,pt,{bbox:B,id:ot}),ft,0)&&void 0}switch(P){case"MultiPoint":at="Point";break;case"MultiLineString":at="LineString";break;case"MultiPolygon":at="Polygon"}for(var nt=0;nt<Q.coordinates.length;nt++)if(!1===St($.feature({type:at,coordinates:Q.coordinates[nt]},pt),ft,nt))return!1})}function it(lt,St){Z(lt,function(Q,ft,pt){var B=0;if(Q.geometry){var ot=Q.geometry.type;if("Point"!==ot&&"MultiPoint"!==ot){var P,at=0,nt=0,Gt=0;if(!1===V(Q,function(O,Ct,yt,vt,xt){if(void 0===P||ft>at||vt>nt||xt>Gt)return P=O,at=ft,nt=vt,Gt=xt,void(B=0);var Mt=$.lineString([P,O],Q.properties);if(!1===St(Mt,ft,pt,xt,B))return!1;B++,P=O}))return!1}}})}function K(lt,St){if(!lt)throw new Error("geojson is required");Z(lt,function(Q,ft,pt){if(null!==Q.geometry){var ot=Q.geometry.coordinates;switch(Q.geometry.type){case"LineString":if(!1===St(Q,ft,pt,0,0))return!1;break;case"Polygon":for(var P=0;P<ot.length;P++)if(!1===St($.lineString(ot[P],Q.properties),ft,pt,P))return!1}}})}ut.coordAll=function k(lt){var St=[];return V(lt,function(Q){St.push(Q)}),St},ut.coordEach=V,ut.coordReduce=function H(lt,St,Q,ft){var pt=Q;return V(lt,function(B,ot,P,at,nt){pt=0===ot&&void 0===Q?B:St(pt,B,ot,P,at,nt)},ft),pt},ut.featureEach=R,ut.featureReduce=function W(lt,St,Q){var ft=Q;return R(lt,function(pt,B){ft=0===B&&void 0===Q?pt:St(ft,pt,B)}),ft},ut.findPoint=function dt(lt,St){if(!$.isObject(St=St||{}))throw new Error("options is invalid");var P,Q=St.featureIndex||0,ft=St.multiFeatureIndex||0,pt=St.geometryIndex||0,B=St.coordIndex||0,ot=St.properties;switch(lt.type){case"FeatureCollection":Q<0&&(Q=lt.features.length+Q),ot=ot||lt.features[Q].properties,P=lt.features[Q].geometry;break;case"Feature":ot=ot||lt.properties,P=lt.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":P=lt;break;default:throw new Error("geojson is invalid")}if(null===P)return null;var at=P.coordinates;switch(P.type){case"Point":return $.point(at,ot,St);case"MultiPoint":return ft<0&&(ft=at.length+ft),$.point(at[ft],ot,St);case"LineString":return B<0&&(B=at.length+B),$.point(at[B],ot,St);case"Polygon":return pt<0&&(pt=at.length+pt),B<0&&(B=at[pt].length+B),$.point(at[pt][B],ot,St);case"MultiLineString":return ft<0&&(ft=at.length+ft),B<0&&(B=at[ft].length+B),$.point(at[ft][B],ot,St);case"MultiPolygon":return ft<0&&(ft=at.length+ft),pt<0&&(pt=at[ft].length+pt),B<0&&(B=at[ft][pt].length-B),$.point(at[ft][pt][B],ot,St)}throw new Error("geojson is invalid")},ut.findSegment=function et(lt,St){if(!$.isObject(St=St||{}))throw new Error("options is invalid");var P,Q=St.featureIndex||0,ft=St.multiFeatureIndex||0,pt=St.geometryIndex||0,B=St.segmentIndex||0,ot=St.properties;switch(lt.type){case"FeatureCollection":Q<0&&(Q=lt.features.length+Q),ot=ot||lt.features[Q].properties,P=lt.features[Q].geometry;break;case"Feature":ot=ot||lt.properties,P=lt.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":P=lt;break;default:throw new Error("geojson is invalid")}if(null===P)return null;var at=P.coordinates;switch(P.type){case"Point":case"MultiPoint":return null;case"LineString":return B<0&&(B=at.length+B-1),$.lineString([at[B],at[B+1]],ot,St);case"Polygon":return pt<0&&(pt=at.length+pt),B<0&&(B=at[pt].length+B-1),$.lineString([at[pt][B],at[pt][B+1]],ot,St);case"MultiLineString":return ft<0&&(ft=at.length+ft),B<0&&(B=at[ft].length+B-1),$.lineString([at[ft][B],at[ft][B+1]],ot,St);case"MultiPolygon":return ft<0&&(ft=at.length+ft),pt<0&&(pt=at[ft].length+pt),B<0&&(B=at[ft][pt].length-B-1),$.lineString([at[ft][pt][B],at[ft][pt][B+1]],ot,St)}throw new Error("geojson is invalid")},ut.flattenEach=Z,ut.flattenReduce=function G(lt,St,Q){var ft=Q;return Z(lt,function(pt,B,ot){ft=0===B&&0===ot&&void 0===Q?pt:St(ft,pt,B,ot)}),ft},ut.geomEach=A,ut.geomReduce=function X(lt,St,Q){var ft=Q;return A(lt,function(pt,B,ot,P,at){ft=0===B&&void 0===Q?pt:St(ft,pt,B,ot,P,at)}),ft},ut.lineEach=K,ut.lineReduce=function st(lt,St,Q){var ft=Q;return K(lt,function(pt,B,ot,P){ft=0===B&&void 0===Q?pt:St(ft,pt,B,ot,P)}),ft},ut.propEach=q,ut.propReduce=function Y(lt,St,Q){var ft=Q;return q(lt,function(pt,B){ft=0===B&&void 0===Q?pt:St(ft,pt,B)}),ft},ut.segmentEach=it,ut.segmentReduce=function bt(lt,St,Q){var ft=Q,pt=!1;return it(lt,function(B,ot,P,at,nt){ft=!1===pt&&void 0===Q?B:St(ft,B,ot,P,at,nt),pt=!0}),ft}},1098:(Lt,ut,y)=>{"use strict";var $=y(491),V=y(5436),H=V($("String.prototype.indexOf"));Lt.exports=function(Y,R){var W=$(Y,!!R);return"function"==typeof W&&H(Y,".prototype.")>-1?V(W):W}},5436:(Lt,ut,y)=>{"use strict";var $=y(5333),V=y(491),H=y(2245),q=y(5223),Y=V("%Function.prototype.apply%"),R=V("%Function.prototype.call%"),W=V("%Reflect.apply%",!0)||$.call(R,Y),k=y(474),A=V("%Math.max%");Lt.exports=function(G){if("function"!=typeof G)throw new q("a function is required");var it=W($,R,arguments);return H(it,1+A(0,G.length-(arguments.length-1)),!0)};var X=function(){return W($,Y,arguments)};k?k(Lt.exports,"apply",{value:X}):Lt.exports.apply=X},3664:(Lt,ut,y)=>{"use strict";var $=y(938),V=y(7935),H=y(4179),q=y(6138).orient2d;function Y(Q,ft,pt){ft=Math.max(0,void 0===ft?2:ft),pt=pt||0;var B=function bt(Q){for(var ft=Q[0],pt=Q[0],B=Q[0],ot=Q[0],P=0;P<Q.length;P++){var at=Q[P];at[0]<ft[0]&&(ft=at),at[0]>B[0]&&(B=at),at[1]<pt[1]&&(pt=at),at[1]>ot[1]&&(ot=at)}var nt=[ft,pt,B,ot],Gt=nt.slice();for(P=0;P<Q.length;P++)H(Q[P],nt)||Gt.push(Q[P]);return function St(Q){Q.sort(lt);for(var ft=[],pt=0;pt<Q.length;pt++){for(;ft.length>=2&&Z(ft[ft.length-2],ft[ft.length-1],Q[pt])<=0;)ft.pop();ft.push(Q[pt])}for(var B=[],ot=Q.length-1;ot>=0;ot--){for(;B.length>=2&&Z(B[B.length-2],B[B.length-1],Q[ot])<=0;)B.pop();B.push(Q[ot])}return B.pop(),ft.pop(),ft.concat(B)}(Gt)}(Q),ot=new $(16);ot.toBBox=function(ee){return{minX:ee[0],minY:ee[1],maxX:ee[0],maxY:ee[1]}},ot.compareMinX=function(ee,jt){return ee[0]-jt[0]},ot.compareMinY=function(ee,jt){return ee[1]-jt[1]},ot.load(Q);for(var nt,P=[],at=0;at<B.length;at++){var Gt=B[at];ot.remove(Gt),nt=K(Gt,nt),P.push(nt)}var O=new $(16);for(at=0;at<P.length;at++)O.insert(it(P[at]));for(var Ct=ft*ft,yt=pt*pt;P.length;){var vt=P.shift(),xt=vt.p,Mt=vt.next.p,It=st(xt,Mt);if(!(It<yt)){var re=It/Ct;(Gt=R(ot,vt.prev.p,xt,Mt,vt.next.next.p,re,O))&&Math.min(st(Gt,xt),st(Gt,Mt))<=re&&(P.push(vt),P.push(K(Gt,vt)),ot.remove(Gt),O.remove(vt),O.insert(it(vt)),O.insert(it(vt.next)))}}vt=nt;var Bt=[];do{Bt.push(vt.p),vt=vt.next}while(vt!==nt);return Bt.push(vt.p),Bt}function R(Q,ft,pt,B,ot,P,at){for(var nt=new V([],W),Gt=Q.data;Gt;){for(var O=0;O<Gt.children.length;O++){var Ct=Gt.children[O],yt=Gt.leaf?et(Ct,pt,B):k(pt,B,Ct);yt>P||nt.push({node:Ct,dist:yt})}for(;nt.length&&!nt.peek().node.children;){var vt=nt.pop(),xt=vt.node,Mt=et(xt,ft,pt),It=et(xt,B,ot);if(vt.dist<Mt&&vt.dist<It&&X(pt,xt,at)&&X(B,xt,at))return xt}(Gt=nt.pop())&&(Gt=Gt.node)}return null}function W(Q,ft){return Q.dist-ft.dist}function k(Q,ft,pt){if(A(Q,pt)||A(ft,pt))return 0;var B=dt(Q[0],Q[1],ft[0],ft[1],pt.minX,pt.minY,pt.maxX,pt.minY);if(0===B)return 0;var ot=dt(Q[0],Q[1],ft[0],ft[1],pt.minX,pt.minY,pt.minX,pt.maxY);if(0===ot)return 0;var P=dt(Q[0],Q[1],ft[0],ft[1],pt.maxX,pt.minY,pt.maxX,pt.maxY);if(0===P)return 0;var at=dt(Q[0],Q[1],ft[0],ft[1],pt.minX,pt.maxY,pt.maxX,pt.maxY);return 0===at?0:Math.min(B,ot,P,at)}function A(Q,ft){return Q[0]>=ft.minX&&Q[0]<=ft.maxX&&Q[1]>=ft.minY&&Q[1]<=ft.maxY}function X(Q,ft,pt){for(var B=Math.min(Q[0],ft[0]),ot=Math.min(Q[1],ft[1]),P=Math.max(Q[0],ft[0]),at=Math.max(Q[1],ft[1]),nt=pt.search({minX:B,minY:ot,maxX:P,maxY:at}),Gt=0;Gt<nt.length;Gt++)if(G(nt[Gt].p,nt[Gt].next.p,Q,ft))return!1;return!0}function Z(Q,ft,pt){return q(Q[0],Q[1],ft[0],ft[1],pt[0],pt[1])}function G(Q,ft,pt,B){return Q!==B&&ft!==pt&&Z(Q,ft,pt)>0!=Z(Q,ft,B)>0&&Z(pt,B,Q)>0!=Z(pt,B,ft)>0}function it(Q){var ft=Q.p,pt=Q.next.p;return Q.minX=Math.min(ft[0],pt[0]),Q.minY=Math.min(ft[1],pt[1]),Q.maxX=Math.max(ft[0],pt[0]),Q.maxY=Math.max(ft[1],pt[1]),Q}function K(Q,ft){var pt={p:Q,prev:null,next:null,minX:0,minY:0,maxX:0,maxY:0};return ft?(pt.next=ft.next,pt.prev=ft,ft.next.prev=pt,ft.next=pt):(pt.prev=pt,pt.next=pt),pt}function st(Q,ft){var pt=Q[0]-ft[0],B=Q[1]-ft[1];return pt*pt+B*B}function et(Q,ft,pt){var B=ft[0],ot=ft[1],P=pt[0]-B,at=pt[1]-ot;if(0!==P||0!==at){var nt=((Q[0]-B)*P+(Q[1]-ot)*at)/(P*P+at*at);nt>1?(B=pt[0],ot=pt[1]):nt>0&&(B+=P*nt,ot+=at*nt)}return(P=Q[0]-B)*P+(at=Q[1]-ot)*at}function dt(Q,ft,pt,B,ot,P,at,nt){var se,be,Me,Xe,Gt=pt-Q,O=B-ft,Ct=at-ot,yt=nt-P,vt=Q-ot,xt=ft-P,Mt=Gt*Gt+O*O,It=Gt*Ct+O*yt,re=Ct*Ct+yt*yt,Bt=Gt*vt+O*xt,ee=Ct*vt+yt*xt,jt=Mt*re-It*It,Ue=jt,De=jt;0===jt?(be=0,Ue=1,Xe=ee,De=re):(Xe=Mt*ee-It*Bt,(be=It*ee-re*Bt)<0?(be=0,Xe=ee,De=re):be>Ue&&(be=Ue,Xe=ee+It,De=re)),Xe<0?(Xe=0,-Bt<0?be=0:-Bt>Mt?be=Ue:(be=-Bt,Ue=Mt)):Xe>De&&(Xe=De,-Bt+It<0?be=0:-Bt+It>Mt?be=Ue:(be=-Bt+It,Ue=Mt));var Ie=(1-(Me=0===Xe?0:Xe/De))*ot+Me*at-((1-(se=0===be?0:be/Ue))*Q+se*pt),Je=(1-Me)*P+Me*nt-((1-se)*ft+se*B);return Ie*Ie+Je*Je}function lt(Q,ft){return Q[0]===ft[0]?Q[1]-ft[1]:Q[0]-ft[0]}V.default&&(V=V.default),Lt.exports=Y,Lt.exports.default=Y},938:function(Lt){Lt.exports=function(){"use strict";function ut(K,st,et,dt,lt){!function St(Q,ft,pt,B,ot){for(;B>pt;){if(B-pt>600){var P=B-pt+1,at=ft-pt+1,nt=Math.log(P),Gt=.5*Math.exp(2*nt/3),O=.5*Math.sqrt(nt*Gt*(P-Gt)/P)*(at-P/2<0?-1:1);St(Q,ft,Math.max(pt,Math.floor(ft-at*Gt/P+O)),Math.min(B,Math.floor(ft+(P-at)*Gt/P+O)),ot)}var vt=Q[ft],xt=pt,Mt=B;for(y(Q,pt,ft),ot(Q[B],vt)>0&&y(Q,pt,B);xt<Mt;){for(y(Q,xt,Mt),xt++,Mt--;ot(Q[xt],vt)<0;)xt++;for(;ot(Q[Mt],vt)>0;)Mt--}0===ot(Q[pt],vt)?y(Q,pt,Mt):y(Q,++Mt,B),Mt<=ft&&(pt=Mt+1),ft<=Mt&&(B=Mt-1)}}(K,st,et||0,dt||K.length-1,lt||$)}function y(K,st,et){var dt=K[st];K[st]=K[et],K[et]=dt}function $(K,st){return K<st?-1:K>st?1:0}var V=function(K){void 0===K&&(K=9),this._maxEntries=Math.max(4,K),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function H(K,st,et){if(!et)return st.indexOf(K);for(var dt=0;dt<st.length;dt++)if(et(K,st[dt]))return dt;return-1}function q(K,st){Y(K,0,K.children.length,st,K)}function Y(K,st,et,dt,lt){lt||(lt=it(null)),lt.minX=1/0,lt.minY=1/0,lt.maxX=-1/0,lt.maxY=-1/0;for(var St=st;St<et;St++){var Q=K.children[St];R(lt,K.leaf?dt(Q):Q)}return lt}function R(K,st){return K.minX=Math.min(K.minX,st.minX),K.minY=Math.min(K.minY,st.minY),K.maxX=Math.max(K.maxX,st.maxX),K.maxY=Math.max(K.maxY,st.maxY),K}function W(K,st){return K.minX-st.minX}function k(K,st){return K.minY-st.minY}function A(K){return(K.maxX-K.minX)*(K.maxY-K.minY)}function X(K){return K.maxX-K.minX+(K.maxY-K.minY)}function Z(K,st){return K.minX<=st.minX&&K.minY<=st.minY&&st.maxX<=K.maxX&&st.maxY<=K.maxY}function G(K,st){return st.minX<=K.maxX&&st.minY<=K.maxY&&st.maxX>=K.minX&&st.maxY>=K.minY}function it(K){return{children:K,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function bt(K,st,et,dt,lt){for(var St=[st,et];St.length;)if(!((et=St.pop())-(st=St.pop())<=dt)){var Q=st+Math.ceil((et-st)/dt/2)*dt;ut(K,Q,st,et,lt),St.push(st,Q,Q,et)}}return V.prototype.all=function(){return this._all(this.data,[])},V.prototype.search=function(K){var st=this.data,et=[];if(!G(K,st))return et;for(var dt=this.toBBox,lt=[];st;){for(var St=0;St<st.children.length;St++){var Q=st.children[St],ft=st.leaf?dt(Q):Q;G(K,ft)&&(st.leaf?et.push(Q):Z(K,ft)?this._all(Q,et):lt.push(Q))}st=lt.pop()}return et},V.prototype.collides=function(K){var st=this.data;if(!G(K,st))return!1;for(var et=[];st;){for(var dt=0;dt<st.children.length;dt++){var lt=st.children[dt],St=st.leaf?this.toBBox(lt):lt;if(G(K,St)){if(st.leaf||Z(K,St))return!0;et.push(lt)}}st=et.pop()}return!1},V.prototype.load=function(K){if(!K||!K.length)return this;if(K.length<this._minEntries){for(var st=0;st<K.length;st++)this.insert(K[st]);return this}var et=this._build(K.slice(),0,K.length-1,0);if(this.data.children.length)if(this.data.height===et.height)this._splitRoot(this.data,et);else{if(this.data.height<et.height){var dt=this.data;this.data=et,et=dt}this._insert(et,this.data.height-et.height-1,!0)}else this.data=et;return this},V.prototype.insert=function(K){return K&&this._insert(K,this.data.height-1),this},V.prototype.clear=function(){return this.data=it([]),this},V.prototype.remove=function(K,st){if(!K)return this;for(var et,dt,lt,St=this.data,Q=this.toBBox(K),ft=[],pt=[];St||ft.length;){if(St||(St=ft.pop(),dt=ft[ft.length-1],et=pt.pop(),lt=!0),St.leaf){var B=H(K,St.children,st);if(-1!==B)return St.children.splice(B,1),ft.push(St),this._condense(ft),this}lt||St.leaf||!Z(St,Q)?dt?(et++,St=dt.children[et],lt=!1):St=null:(ft.push(St),pt.push(et),et=0,dt=St,St=St.children[0])}return this},V.prototype.toBBox=function(K){return K},V.prototype.compareMinX=function(K,st){return K.minX-st.minX},V.prototype.compareMinY=function(K,st){return K.minY-st.minY},V.prototype.toJSON=function(){return this.data},V.prototype.fromJSON=function(K){return this.data=K,this},V.prototype._all=function(K,st){for(var et=[];K;)K.leaf?st.push.apply(st,K.children):et.push.apply(et,K.children),K=et.pop();return st},V.prototype._build=function(K,st,et,dt){var lt,St=et-st+1,Q=this._maxEntries;if(St<=Q)return q(lt=it(K.slice(st,et+1)),this.toBBox),lt;dt||(dt=Math.ceil(Math.log(St)/Math.log(Q)),Q=Math.ceil(St/Math.pow(Q,dt-1))),(lt=it([])).leaf=!1,lt.height=dt;var ft=Math.ceil(St/Q),pt=ft*Math.ceil(Math.sqrt(Q));bt(K,st,et,pt,this.compareMinX);for(var B=st;B<=et;B+=pt){var ot=Math.min(B+pt-1,et);bt(K,B,ot,ft,this.compareMinY);for(var P=B;P<=ot;P+=ft){var at=Math.min(P+ft-1,ot);lt.children.push(this._build(K,P,at,dt-1))}}return q(lt,this.toBBox),lt},V.prototype._chooseSubtree=function(K,st,et,dt){for(;dt.push(st),!st.leaf&&dt.length-1!==et;){for(var lt=1/0,St=1/0,Q=void 0,ft=0;ft<st.children.length;ft++){var pt=st.children[ft],B=A(pt),ot=(P=K,at=pt,(Math.max(at.maxX,P.maxX)-Math.min(at.minX,P.minX))*(Math.max(at.maxY,P.maxY)-Math.min(at.minY,P.minY))-B);ot<St?(St=ot,lt=B<lt?B:lt,Q=pt):ot===St&&B<lt&&(lt=B,Q=pt)}st=Q||st.children[0]}var P,at;return st},V.prototype._insert=function(K,st,et){var dt=et?K:this.toBBox(K),lt=[],St=this._chooseSubtree(dt,this.data,st,lt);for(St.children.push(K),R(St,dt);st>=0&&lt[st].children.length>this._maxEntries;)this._split(lt,st),st--;this._adjustParentBBoxes(dt,lt,st)},V.prototype._split=function(K,st){var et=K[st],dt=et.children.length,lt=this._minEntries;this._chooseSplitAxis(et,lt,dt);var St=this._chooseSplitIndex(et,lt,dt),Q=it(et.children.splice(St,et.children.length-St));Q.height=et.height,Q.leaf=et.leaf,q(et,this.toBBox),q(Q,this.toBBox),st?K[st-1].children.push(Q):this._splitRoot(et,Q)},V.prototype._splitRoot=function(K,st){this.data=it([K,st]),this.data.height=K.height+1,this.data.leaf=!1,q(this.data,this.toBBox)},V.prototype._chooseSplitIndex=function(K,st,et){for(var dt,lt,St,Q,ft,pt,B,ot=1/0,P=1/0,at=st;at<=et-st;at++){var nt=Y(K,0,at,this.toBBox),Gt=Y(K,at,et,this.toBBox),O=(lt=nt,St=Gt,void 0,void 0,void 0,void 0,Q=Math.max(lt.minX,St.minX),ft=Math.max(lt.minY,St.minY),pt=Math.min(lt.maxX,St.maxX),B=Math.min(lt.maxY,St.maxY),Math.max(0,pt-Q)*Math.max(0,B-ft)),Ct=A(nt)+A(Gt);O<ot?(ot=O,dt=at,P=Ct<P?Ct:P):O===ot&&Ct<P&&(P=Ct,dt=at)}return dt||et-st},V.prototype._chooseSplitAxis=function(K,st,et){var dt=K.leaf?this.compareMinX:W,lt=K.leaf?this.compareMinY:k;this._allDistMargin(K,st,et,dt)<this._allDistMargin(K,st,et,lt)&&K.children.sort(dt)},V.prototype._allDistMargin=function(K,st,et,dt){K.children.sort(dt);for(var lt=this.toBBox,St=Y(K,0,st,lt),Q=Y(K,et-st,et,lt),ft=X(St)+X(Q),pt=st;pt<et-st;pt++){var B=K.children[pt];R(St,K.leaf?lt(B):B),ft+=X(St)}for(var ot=et-st-1;ot>=st;ot--){var P=K.children[ot];R(Q,K.leaf?lt(P):P),ft+=X(Q)}return ft},V.prototype._adjustParentBBoxes=function(K,st,et){for(var dt=et;dt>=0;dt--)R(st[dt],K)},V.prototype._condense=function(K){for(var st=K.length-1,et=void 0;st>=0;st--)0===K[st].children.length?st>0?(et=K[st-1].children).splice(et.indexOf(K[st]),1):this.clear():q(K[st],this.toBBox)},V}()},3970:(Lt,ut,y)=>{var $=y(7809),V=y(8147),H=y(314),q=y(4720),Y=y(1139),R=y(2365),W=Date.prototype.getTime;function A(G){return null==G}function X(G){return!(!G||"object"!=typeof G||"number"!=typeof G.length||"function"!=typeof G.copy||"function"!=typeof G.slice||G.length>0&&"number"!=typeof G[0])}Lt.exports=function k(G,it,bt){var K=bt||{};return!!(K.strict?H(G,it):G===it)||(!G||!it||"object"!=typeof G&&"object"!=typeof it?K.strict?H(G,it):G==it:function Z(G,it,bt){var K,st;if(typeof G!=typeof it||A(G)||A(it)||G.prototype!==it.prototype||V(G)!==V(it))return!1;var et=q(G),dt=q(it);if(et!==dt)return!1;if(et||dt)return G.source===it.source&&Y(G)===Y(it);if(R(G)&&R(it))return W.call(G)===W.call(it);var lt=X(G),St=X(it);if(lt!==St)return!1;if(lt||St){if(G.length!==it.length)return!1;for(K=0;K<G.length;K++)if(G[K]!==it[K])return!1;return!0}if(typeof G!=typeof it)return!1;try{var Q=$(G),ft=$(it)}catch{return!1}if(Q.length!==ft.length)return!1;for(Q.sort(),ft.sort(),K=Q.length-1;K>=0;K--)if(Q[K]!=ft[K])return!1;for(K=Q.length-1;K>=0;K--)if(!k(G[st=Q[K]],it[st],bt))return!1;return!0}(G,it,K))}},9224:(Lt,ut,y)=>{"use strict";var $=y(474),V=y(4203),H=y(5223),q=y(9262);Lt.exports=function(R,W,k){if(!R||"object"!=typeof R&&"function"!=typeof R)throw new H("`obj` must be an object or a function`");if("string"!=typeof W&&"symbol"!=typeof W)throw new H("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!=typeof arguments[3]&&null!==arguments[3])throw new H("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!=typeof arguments[4]&&null!==arguments[4])throw new H("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!=typeof arguments[5]&&null!==arguments[5])throw new H("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!=typeof arguments[6])throw new H("`loose`, if provided, must be a boolean");var A=arguments.length>3?arguments[3]:null,X=arguments.length>4?arguments[4]:null,Z=arguments.length>5?arguments[5]:null,G=arguments.length>6&&arguments[6],it=!!q&&q(R,W);if($)$(R,W,{configurable:null===Z&&it?it.configurable:!Z,enumerable:null===A&&it?it.enumerable:!A,value:k,writable:null===X&&it?it.writable:!X});else{if(!G&&(A||X||Z))throw new V("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");R[W]=k}}},1648:(Lt,ut,y)=>{"use strict";var $=y(7809),V="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),H=Object.prototype.toString,q=Array.prototype.concat,Y=y(9224),W=y(2486)(),k=function(X,Z,G,it){if(Z in X)if(!0===it){if(X[Z]===G)return}else if(!function(X){return"function"==typeof X&&"[object Function]"===H.call(X)}(it)||!it())return;W?Y(X,Z,G,!0):Y(X,Z,G)},A=function(X,Z){var G=arguments.length>2?arguments[2]:{},it=$(Z);V&&(it=q.call(it,Object.getOwnPropertySymbols(Z)));for(var bt=0;bt<it.length;bt+=1)k(X,it[bt],Z[it[bt]],G[it[bt]])};A.supportsDescriptors=!!W,Lt.exports=A},7649:Lt=>{function ut(y,$,V,H){this.dataset=[],this.epsilon=1,this.minPts=2,this.distance=this._euclideanDistance,this.clusters=[],this.noise=[],this._visited=[],this._assigned=[],this._datasetLength=0,this._init(y,$,V,H)}ut.prototype.run=function(y,$,V,H){this._init(y,$,V,H);for(var q=0;q<this._datasetLength;q++)if(1!==this._visited[q]){this._visited[q]=1;var Y=this._regionQuery(q);if(Y.length<this.minPts)this.noise.push(q);else{var R=this.clusters.length;this.clusters.push([]),this._addToCluster(q,R),this._expandCluster(R,Y)}}return this.clusters},ut.prototype._init=function(y,$,V,H){if(y){if(!(y instanceof Array))throw Error("Dataset must be of type array, "+typeof y+" given");this.dataset=y,this.clusters=[],this.noise=[],this._datasetLength=y.length,this._visited=new Array(this._datasetLength),this._assigned=new Array(this._datasetLength)}$&&(this.epsilon=$),V&&(this.minPts=V),H&&(this.distance=H)},ut.prototype._expandCluster=function(y,$){for(var V=0;V<$.length;V++){var H=$[V];if(1!==this._visited[H]){this._visited[H]=1;var q=this._regionQuery(H);q.length>=this.minPts&&($=this._mergeArrays($,q))}1!==this._assigned[H]&&this._addToCluster(H,y)}},ut.prototype._addToCluster=function(y,$){this.clusters[$].push(y),this._assigned[y]=1},ut.prototype._regionQuery=function(y){for(var $=[],V=0;V<this._datasetLength;V++)this.distance(this.dataset[y],this.dataset[V])<this.epsilon&&$.push(V);return $},ut.prototype._mergeArrays=function(y,$){for(var V=$.length,H=0;H<V;H++){var q=$[H];y.indexOf(q)<0&&y.push(q)}return y},ut.prototype._euclideanDistance=function(y,$){for(var V=0,H=Math.min(y.length,$.length);H--;)V+=(y[H]-$[H])*(y[H]-$[H]);return Math.sqrt(V)},Lt.exports&&(Lt.exports=ut)},442:Lt=>{function ut(y,$,V){this.k=3,this.dataset=[],this.assignments=[],this.centroids=[],this.init(y,$,V)}ut.prototype.init=function(y,$,V){this.assignments=[],this.centroids=[],typeof y<"u"&&(this.dataset=y),typeof $<"u"&&(this.k=$),typeof V<"u"&&(this.distance=V)},ut.prototype.run=function(y,$){this.init(y,$);for(var V=this.dataset.length,H=0;H<this.k;H++)this.centroids[H]=this.randomCentroid();for(var q=!0;q;){q=this.assign();for(var Y=0;Y<this.k;Y++){for(var R=new Array(X),W=0,k=0;k<X;k++)R[k]=0;for(var A=0;A<V;A++){var X=this.dataset[A].length;if(Y===this.assignments[A]){for(k=0;k<X;k++)R[k]+=this.dataset[A][k];W++}}if(W>0){for(k=0;k<X;k++)R[k]/=W;this.centroids[Y]=R}else this.centroids[Y]=this.randomCentroid(),q=!0}}return this.getClusters()},ut.prototype.randomCentroid=function(){var $,V,y=this.dataset.length-1;do{V=Math.round(Math.random()*y),$=this.dataset[V]}while(this.centroids.indexOf($)>=0);return $},ut.prototype.assign=function(){for(var V,y=!1,$=this.dataset.length,H=0;H<$;H++)(V=this.argmin(this.dataset[H],this.centroids,this.distance))!=this.assignments[H]&&(this.assignments[H]=V,y=!0);return y},ut.prototype.getClusters=function(){for(var $,y=new Array(this.k),V=0;V<this.assignments.length;V++)typeof y[$=this.assignments[V]]>"u"&&(y[$]=[]),y[$].push(V);return y},ut.prototype.argmin=function(y,$,V){for(var R,H=Number.MAX_VALUE,q=0,Y=$.length,W=0;W<Y;W++)(R=V(y,$[W]))<H&&(H=R,q=W);return q},ut.prototype.distance=function(y,$){for(var V=0,H=Math.min(y.length,$.length);H--;){var q=y[H]-$[H];V+=q*q}return Math.sqrt(V)},Lt.exports&&(Lt.exports=ut)},2195:(Lt,ut,y)=>{if(Lt.exports)var $=y(6216);function V(H,q,Y,R){this.epsilon=1,this.minPts=1,this.distance=this._euclideanDistance,this._reachability=[],this._processed=[],this._coreDistance=0,this._orderedList=[],this._init(H,q,Y,R)}V.prototype.run=function(H,q,Y,R){this._init(H,q,Y,R);for(var W=0,k=this.dataset.length;W<k;W++)if(1!==this._processed[W]){this._processed[W]=1,this.clusters.push([W]);var A=this.clusters.length-1;this._orderedList.push(W);var X=new $(null,null,"asc"),Z=this._regionQuery(W);void 0!==this._distanceToCore(W)&&(this._updateQueue(W,Z,X),this._expandCluster(A,X))}return this.clusters},V.prototype.getReachabilityPlot=function(){for(var H=[],q=0,Y=this._orderedList.length;q<Y;q++){var R=this._orderedList[q];H.push([R,this._reachability[R]])}return H},V.prototype._init=function(H,q,Y,R){if(H){if(!(H instanceof Array))throw Error("Dataset must be of type array, "+typeof H+" given");this.dataset=H,this.clusters=[],this._reachability=new Array(this.dataset.length),this._processed=new Array(this.dataset.length),this._coreDistance=0,this._orderedList=[]}q&&(this.epsilon=q),Y&&(this.minPts=Y),R&&(this.distance=R)},V.prototype._updateQueue=function(H,q,Y){var R=this;this._coreDistance=this._distanceToCore(H),q.forEach(function(W){if(void 0===R._processed[W]){var k=R.distance(R.dataset[H],R.dataset[W]),A=Math.max(R._coreDistance,k);void 0===R._reachability[W]?(R._reachability[W]=A,Y.insert(W,A)):A<R._reachability[W]&&(R._reachability[W]=A,Y.remove(W),Y.insert(W,A))}})},V.prototype._expandCluster=function(H,q){for(var Y=q.getElements(),R=0,W=Y.length;R<W;R++){var k=Y[R];if(void 0===this._processed[k]){var A=this._regionQuery(k);this._processed[k]=1,this.clusters[H].push(k),this._orderedList.push(k),void 0!==this._distanceToCore(k)&&(this._updateQueue(k,A,q),this._expandCluster(H,q))}}},V.prototype._distanceToCore=function(H){for(var q=this.epsilon,Y=0;Y<q;Y++)if(this._regionQuery(H,Y).length>=this.minPts)return Y},V.prototype._regionQuery=function(H,q){q=q||this.epsilon;for(var Y=[],R=0,W=this.dataset.length;R<W;R++)this.distance(this.dataset[H],this.dataset[R])<q&&Y.push(R);return Y},V.prototype._euclideanDistance=function(H,q){for(var Y=0,R=Math.min(H.length,q.length);R--;)Y+=(H[R]-q[R])*(H[R]-q[R]);return Math.sqrt(Y)},Lt.exports&&(Lt.exports=V)},6216:Lt=>{function ut(y,$,V){this._queue=[],this._priorities=[],this._sorting="desc",this._init(y,$,V)}ut.prototype.insert=function(y,$){for(var V=this._queue.length,H=V;H--;){var q=this._priorities[H];"desc"===this._sorting?$>q&&(V=H):$<q&&(V=H)}this._insertAt(y,$,V)},ut.prototype.remove=function(y){for(var $=this._queue.length;$--;)if(y===this._queue[$]){this._queue.splice($,1),this._priorities.splice($,1);break}},ut.prototype.forEach=function(y){this._queue.forEach(y)},ut.prototype.getElements=function(){return this._queue},ut.prototype.getElementPriority=function(y){return this._priorities[y]},ut.prototype.getPriorities=function(){return this._priorities},ut.prototype.getElementsWithPriorities=function(){for(var y=[],$=0,V=this._queue.length;$<V;$++)y.push([this._queue[$],this._priorities[$]]);return y},ut.prototype._init=function(y,$,V){if(y&&$){if(this._queue=[],this._priorities=[],y.length!==$.length)throw new Error("Arrays must have the same length");for(var H=0;H<y.length;H++)this.insert(y[H],$[H])}V&&(this._sorting=V)},ut.prototype._insertAt=function(y,$,V){this._queue.length===V?(this._queue.push(y),this._priorities.push($)):(this._queue.splice(V,0,y),this._priorities.splice(V,0,$))},Lt.exports&&(Lt.exports=ut)},3367:(Lt,ut,y)=>{Lt.exports&&(Lt.exports={DBSCAN:y(7649),KMEANS:y(442),OPTICS:y(2195),PriorityQueue:y(6216)})},9145:Lt=>{"use strict";function ut(Ct,yt,vt){vt=vt||2;var Bt,ee,jt,se,be,Me,Xe,xt=yt&&yt.length,Mt=xt?yt[0]*vt:Ct.length,It=y(Ct,0,Mt,vt,!0),re=[];if(!It||It.next===It.prev)return re;if(xt&&(It=function W(Ct,yt,vt,xt){var It,re,jt,Mt=[];for(It=0,re=yt.length;It<re;It++)(jt=y(Ct,yt[It]*xt,It<re-1?yt[It+1]*xt:Ct.length,xt,!1))===jt.next&&(jt.steiner=!0),Mt.push(K(jt));for(Mt.sort(k),It=0;It<Mt.length;It++)vt=A(Mt[It],vt);return vt}(Ct,yt,It,vt)),Ct.length>80*vt){Bt=jt=Ct[0],ee=se=Ct[1];for(var Ue=vt;Ue<Mt;Ue+=vt)(be=Ct[Ue])<Bt&&(Bt=be),(Me=Ct[Ue+1])<ee&&(ee=Me),be>jt&&(jt=be),Me>se&&(se=Me);Xe=0!==(Xe=Math.max(jt-Bt,se-ee))?32767/Xe:0}return V(It,re,vt,Bt,ee,Xe,0),re}function y(Ct,yt,vt,xt,Mt){var It,re;if(Mt===O(Ct,yt,vt,xt)>0)for(It=yt;It<vt;It+=xt)re=at(It,Ct[It],Ct[It+1],re);else for(It=vt-xt;It>=yt;It-=xt)re=at(It,Ct[It],Ct[It+1],re);return re&&lt(re,re.next)&&(nt(re),re=re.next),re}function $(Ct,yt){if(!Ct)return Ct;yt||(yt=Ct);var xt,vt=Ct;do{if(xt=!1,vt.steiner||!lt(vt,vt.next)&&0!==dt(vt.prev,vt,vt.next))vt=vt.next;else{if(nt(vt),(vt=yt=vt.prev)===vt.next)break;xt=!0}}while(xt||vt!==yt);return yt}function V(Ct,yt,vt,xt,Mt,It,re){if(Ct){!re&&It&&function G(Ct,yt,vt,xt){var Mt=Ct;do{0===Mt.z&&(Mt.z=bt(Mt.x,Mt.y,yt,vt,xt)),Mt.prevZ=Mt.prev,Mt.nextZ=Mt.next,Mt=Mt.next}while(Mt!==Ct);Mt.prevZ.nextZ=null,Mt.prevZ=null,function it(Ct){var yt,vt,xt,Mt,It,re,Bt,ee,jt=1;do{for(vt=Ct,Ct=null,It=null,re=0;vt;){for(re++,xt=vt,Bt=0,yt=0;yt<jt&&(Bt++,xt=xt.nextZ);yt++);for(ee=jt;Bt>0||ee>0&&xt;)0!==Bt&&(0===ee||!xt||vt.z<=xt.z)?(Mt=vt,vt=vt.nextZ,Bt--):(Mt=xt,xt=xt.nextZ,ee--),It?It.nextZ=Mt:Ct=Mt,Mt.prevZ=It,It=Mt;vt=xt}It.nextZ=null,jt*=2}while(re>1)}(Mt)}(Ct,xt,Mt,It);for(var ee,jt,Bt=Ct;Ct.prev!==Ct.next;)if(ee=Ct.prev,jt=Ct.next,It?q(Ct,xt,Mt,It):H(Ct))yt.push(ee.i/vt|0),yt.push(Ct.i/vt|0),yt.push(jt.i/vt|0),nt(Ct),Ct=jt.next,Bt=jt.next;else if((Ct=jt)===Bt){re?1===re?V(Ct=Y($(Ct),yt,vt),yt,vt,xt,Mt,It,2):2===re&&R(Ct,yt,vt,xt,Mt,It):V($(Ct),yt,vt,xt,Mt,It,1);break}}}function H(Ct){var yt=Ct.prev,vt=Ct,xt=Ct.next;if(dt(yt,vt,xt)>=0)return!1;for(var Mt=yt.x,It=vt.x,re=xt.x,Bt=yt.y,ee=vt.y,jt=xt.y,se=Mt<It?Mt<re?Mt:re:It<re?It:re,be=Bt<ee?Bt<jt?Bt:jt:ee<jt?ee:jt,Me=Mt>It?Mt>re?Mt:re:It>re?It:re,Xe=Bt>ee?Bt>jt?Bt:jt:ee>jt?ee:jt,Ue=xt.next;Ue!==yt;){if(Ue.x>=se&&Ue.x<=Me&&Ue.y>=be&&Ue.y<=Xe&&st(Mt,Bt,It,ee,re,jt,Ue.x,Ue.y)&&dt(Ue.prev,Ue,Ue.next)>=0)return!1;Ue=Ue.next}return!0}function q(Ct,yt,vt,xt){var Mt=Ct.prev,It=Ct,re=Ct.next;if(dt(Mt,It,re)>=0)return!1;for(var Bt=Mt.x,ee=It.x,jt=re.x,se=Mt.y,be=It.y,Me=re.y,Xe=Bt<ee?Bt<jt?Bt:jt:ee<jt?ee:jt,Ue=se<be?se<Me?se:Me:be<Me?be:Me,De=Bt>ee?Bt>jt?Bt:jt:ee>jt?ee:jt,Tn=se>be?se>Me?se:Me:be>Me?be:Me,On=bt(Xe,Ue,yt,vt,xt),ne=bt(De,Tn,yt,vt,xt),pe=Ct.prevZ,Ie=Ct.nextZ;pe&&pe.z>=On&&Ie&&Ie.z<=ne;){if(pe.x>=Xe&&pe.x<=De&&pe.y>=Ue&&pe.y<=Tn&&pe!==Mt&&pe!==re&&st(Bt,se,ee,be,jt,Me,pe.x,pe.y)&&dt(pe.prev,pe,pe.next)>=0||(pe=pe.prevZ,Ie.x>=Xe&&Ie.x<=De&&Ie.y>=Ue&&Ie.y<=Tn&&Ie!==Mt&&Ie!==re&&st(Bt,se,ee,be,jt,Me,Ie.x,Ie.y)&&dt(Ie.prev,Ie,Ie.next)>=0))return!1;Ie=Ie.nextZ}for(;pe&&pe.z>=On;){if(pe.x>=Xe&&pe.x<=De&&pe.y>=Ue&&pe.y<=Tn&&pe!==Mt&&pe!==re&&st(Bt,se,ee,be,jt,Me,pe.x,pe.y)&&dt(pe.prev,pe,pe.next)>=0)return!1;pe=pe.prevZ}for(;Ie&&Ie.z<=ne;){if(Ie.x>=Xe&&Ie.x<=De&&Ie.y>=Ue&&Ie.y<=Tn&&Ie!==Mt&&Ie!==re&&st(Bt,se,ee,be,jt,Me,Ie.x,Ie.y)&&dt(Ie.prev,Ie,Ie.next)>=0)return!1;Ie=Ie.nextZ}return!0}function Y(Ct,yt,vt){var xt=Ct;do{var Mt=xt.prev,It=xt.next.next;!lt(Mt,It)&&St(Mt,xt,xt.next,It)&&B(Mt,It)&&B(It,Mt)&&(yt.push(Mt.i/vt|0),yt.push(xt.i/vt|0),yt.push(It.i/vt|0),nt(xt),nt(xt.next),xt=Ct=It),xt=xt.next}while(xt!==Ct);return $(xt)}function R(Ct,yt,vt,xt,Mt,It){var re=Ct;do{for(var Bt=re.next.next;Bt!==re.prev;){if(re.i!==Bt.i&&et(re,Bt)){var ee=P(re,Bt);return re=$(re,re.next),ee=$(ee,ee.next),V(re,yt,vt,xt,Mt,It,0),void V(ee,yt,vt,xt,Mt,It,0)}Bt=Bt.next}re=re.next}while(re!==Ct)}function k(Ct,yt){return Ct.x-yt.x}function A(Ct,yt){var vt=function X(Ct,yt){var re,vt=yt,xt=Ct.x,Mt=Ct.y,It=-1/0;do{if(Mt<=vt.y&&Mt>=vt.next.y&&vt.next.y!==vt.y){var Bt=vt.x+(Mt-vt.y)*(vt.next.x-vt.x)/(vt.next.y-vt.y);if(Bt<=xt&&Bt>It&&(It=Bt,re=vt.x<vt.next.x?vt:vt.next,Bt===xt))return re}vt=vt.next}while(vt!==yt);if(!re)return null;var Me,ee=re,jt=re.x,se=re.y,be=1/0;vt=re;do{xt>=vt.x&&vt.x>=jt&&xt!==vt.x&&st(Mt<se?xt:It,Mt,jt,se,Mt<se?It:xt,Mt,vt.x,vt.y)&&(Me=Math.abs(Mt-vt.y)/(xt-vt.x),B(vt,Ct)&&(Me<be||Me===be&&(vt.x>re.x||vt.x===re.x&&Z(re,vt)))&&(re=vt,be=Me)),vt=vt.next}while(vt!==ee);return re}(Ct,yt);if(!vt)return yt;var xt=P(vt,Ct);return $(xt,xt.next),$(vt,vt.next)}function Z(Ct,yt){return dt(Ct.prev,Ct,yt.prev)<0&&dt(yt.next,Ct,Ct.next)<0}function bt(Ct,yt,vt,xt,Mt){return(Ct=1431655765&((Ct=858993459&((Ct=252645135&((Ct=16711935&((Ct=(Ct-vt)*Mt|0)|Ct<<8))|Ct<<4))|Ct<<2))|Ct<<1))|(yt=1431655765&((yt=858993459&((yt=252645135&((yt=16711935&((yt=(yt-xt)*Mt|0)|yt<<8))|yt<<4))|yt<<2))|yt<<1))<<1}function K(Ct){var yt=Ct,vt=Ct;do{(yt.x<vt.x||yt.x===vt.x&&yt.y<vt.y)&&(vt=yt),yt=yt.next}while(yt!==Ct);return vt}function st(Ct,yt,vt,xt,Mt,It,re,Bt){return(Mt-re)*(yt-Bt)>=(Ct-re)*(It-Bt)&&(Ct-re)*(xt-Bt)>=(vt-re)*(yt-Bt)&&(vt-re)*(It-Bt)>=(Mt-re)*(xt-Bt)}function et(Ct,yt){return Ct.next.i!==yt.i&&Ct.prev.i!==yt.i&&!function pt(Ct,yt){var vt=Ct;do{if(vt.i!==Ct.i&&vt.next.i!==Ct.i&&vt.i!==yt.i&&vt.next.i!==yt.i&&St(vt,vt.next,Ct,yt))return!0;vt=vt.next}while(vt!==Ct);return!1}(Ct,yt)&&(B(Ct,yt)&&B(yt,Ct)&&function ot(Ct,yt){var vt=Ct,xt=!1,Mt=(Ct.x+yt.x)/2,It=(Ct.y+yt.y)/2;do{vt.y>It!=vt.next.y>It&&vt.next.y!==vt.y&&Mt<(vt.next.x-vt.x)*(It-vt.y)/(vt.next.y-vt.y)+vt.x&&(xt=!xt),vt=vt.next}while(vt!==Ct);return xt}(Ct,yt)&&(dt(Ct.prev,Ct,yt.prev)||dt(Ct,yt.prev,yt))||lt(Ct,yt)&&dt(Ct.prev,Ct,Ct.next)>0&&dt(yt.prev,yt,yt.next)>0)}function dt(Ct,yt,vt){return(yt.y-Ct.y)*(vt.x-yt.x)-(yt.x-Ct.x)*(vt.y-yt.y)}function lt(Ct,yt){return Ct.x===yt.x&&Ct.y===yt.y}function St(Ct,yt,vt,xt){var Mt=ft(dt(Ct,yt,vt)),It=ft(dt(Ct,yt,xt)),re=ft(dt(vt,xt,Ct)),Bt=ft(dt(vt,xt,yt));return!!(Mt!==It&&re!==Bt||0===Mt&&Q(Ct,vt,yt)||0===It&&Q(Ct,xt,yt)||0===re&&Q(vt,Ct,xt)||0===Bt&&Q(vt,yt,xt))}function Q(Ct,yt,vt){return yt.x<=Math.max(Ct.x,vt.x)&&yt.x>=Math.min(Ct.x,vt.x)&&yt.y<=Math.max(Ct.y,vt.y)&&yt.y>=Math.min(Ct.y,vt.y)}function ft(Ct){return Ct>0?1:Ct<0?-1:0}function B(Ct,yt){return dt(Ct.prev,Ct,Ct.next)<0?dt(Ct,yt,Ct.next)>=0&&dt(Ct,Ct.prev,yt)>=0:dt(Ct,yt,Ct.prev)<0||dt(Ct,Ct.next,yt)<0}function P(Ct,yt){var vt=new Gt(Ct.i,Ct.x,Ct.y),xt=new Gt(yt.i,yt.x,yt.y),Mt=Ct.next,It=yt.prev;return Ct.next=yt,yt.prev=Ct,vt.next=Mt,Mt.prev=vt,xt.next=vt,vt.prev=xt,It.next=xt,xt.prev=It,xt}function at(Ct,yt,vt,xt){var Mt=new Gt(Ct,yt,vt);return xt?(Mt.next=xt.next,Mt.prev=xt,xt.next.prev=Mt,xt.next=Mt):(Mt.prev=Mt,Mt.next=Mt),Mt}function nt(Ct){Ct.next.prev=Ct.prev,Ct.prev.next=Ct.next,Ct.prevZ&&(Ct.prevZ.nextZ=Ct.nextZ),Ct.nextZ&&(Ct.nextZ.prevZ=Ct.prevZ)}function Gt(Ct,yt,vt){this.i=Ct,this.x=yt,this.y=vt,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function O(Ct,yt,vt,xt){for(var Mt=0,It=yt,re=vt-xt;It<vt;It+=xt)Mt+=(Ct[re]-Ct[It])*(Ct[It+1]+Ct[re+1]),re=It;return Mt}Lt.exports=ut,Lt.exports.default=ut,ut.deviation=function(Ct,yt,vt,xt){var Mt=yt&&yt.length,re=Math.abs(O(Ct,0,Mt?yt[0]*vt:Ct.length,vt));if(Mt)for(var Bt=0,ee=yt.length;Bt<ee;Bt++)re-=Math.abs(O(Ct,yt[Bt]*vt,Bt<ee-1?yt[Bt+1]*vt:Ct.length,vt));var be=0;for(Bt=0;Bt<xt.length;Bt+=3){var Me=xt[Bt]*vt,Xe=xt[Bt+1]*vt,Ue=xt[Bt+2]*vt;be+=Math.abs((Ct[Me]-Ct[Ue])*(Ct[Xe+1]-Ct[Me+1])-(Ct[Me]-Ct[Xe])*(Ct[Ue+1]-Ct[Me+1]))}return 0===re&&0===be?0:Math.abs((be-re)/re)},ut.flatten=function(Ct){for(var yt=Ct[0][0].length,vt={vertices:[],holes:[],dimensions:yt},xt=0,Mt=0;Mt<Ct.length;Mt++){for(var It=0;It<Ct[Mt].length;It++)for(var re=0;re<yt;re++)vt.vertices.push(Ct[Mt][It][re]);Mt>0&&vt.holes.push(xt+=Ct[Mt-1].length)}return vt}},474:(Lt,ut,y)=>{"use strict";var V=y(491)("%Object.defineProperty%",!0)||!1;if(V)try{V({},"a",{value:1})}catch{V=!1}Lt.exports=V},4500:Lt=>{"use strict";Lt.exports=EvalError},2050:Lt=>{"use strict";Lt.exports=Error},2992:Lt=>{"use strict";Lt.exports=RangeError},3944:Lt=>{"use strict";Lt.exports=ReferenceError},4203:Lt=>{"use strict";Lt.exports=SyntaxError},5223:Lt=>{"use strict";Lt.exports=TypeError},6130:Lt=>{"use strict";Lt.exports=URIError},238:Lt=>{"use strict";var y=Object.prototype.toString,$=Math.max,H=function(W,k){for(var A=[],X=0;X<W.length;X+=1)A[X]=W[X];for(var Z=0;Z<k.length;Z+=1)A[Z+W.length]=k[Z];return A};Lt.exports=function(W){var k=this;if("function"!=typeof k||"[object Function]"!==y.apply(k))throw new TypeError("Function.prototype.bind called on incompatible "+k);for(var X,A=function(W,k){for(var A=[],X=1,Z=0;X<W.length;X+=1,Z+=1)A[Z]=W[X];return A}(arguments),G=$(0,k.length-A.length),it=[],bt=0;bt<G;bt++)it[bt]="$"+bt;if(X=Function("binder","return function ("+function(R,W){for(var k="",A=0;A<R.length;A+=1)k+=R[A],A+1<R.length&&(k+=",");return k}(it)+"){ return binder.apply(this,arguments); }")(function(){if(this instanceof X){var st=k.apply(this,H(A,arguments));return Object(st)===st?st:this}return k.apply(W,H(A,arguments))}),k.prototype){var K=function(){};K.prototype=k.prototype,X.prototype=new K,K.prototype=null}return X}},5333:(Lt,ut,y)=>{"use strict";var $=y(238);Lt.exports=Function.prototype.bind||$},1552:Lt=>{"use strict";var ut=function(){return"string"==typeof function(){}.name},y=Object.getOwnPropertyDescriptor;if(y)try{y([],"length")}catch{y=null}ut.functionsHaveConfigurableNames=function(){if(!ut()||!y)return!1;var H=y(function(){},"name");return!!H&&!!H.configurable};var $=Function.prototype.bind;ut.boundFunctionsHaveNames=function(){return ut()&&"function"==typeof $&&""!==function(){}.bind().name},Lt.exports=ut},3198:(Lt,ut,y)=>{var $=y(3970),V=function(R){this.precision=R&&R.precision?R.precision:17,this.direction=!(!R||!R.direction)&&R.direction,this.pseudoNode=!(!R||!R.pseudoNode)&&R.pseudoNode,this.objectComparator=R&&R.objectComparator?R.objectComparator:Y};function H(R){return R.coordinates.map(function(W){return{type:R.type.replace("Multi",""),coordinates:W}})}function q(R,W){return R.hasOwnProperty("coordinates")?R.coordinates.length===W.coordinates.length:R.length===W.length}function Y(R,W){return $(R,W,{strict:!0})}V.prototype.compare=function(R,W){if(R.type!==W.type||!q(R,W))return!1;switch(R.type){case"Point":return this.compareCoord(R.coordinates,W.coordinates);case"LineString":return this.compareLine(R.coordinates,W.coordinates,0,!1);case"Polygon":return this.comparePolygon(R,W);case"Feature":return this.compareFeature(R,W);default:if(0===R.type.indexOf("Multi")){var k=this,A=H(R),X=H(W);return A.every(function(Z){return this.some(function(G){return k.compare(Z,G)})},X)}}return!1},V.prototype.compareCoord=function(R,W){if(R.length!==W.length)return!1;for(var k=0;k<R.length;k++)if(R[k].toFixed(this.precision)!==W[k].toFixed(this.precision))return!1;return!0},V.prototype.compareLine=function(R,W,k,A){if(!q(R,W))return!1;var X=this.pseudoNode?R:this.removePseudo(R),Z=this.pseudoNode?W:this.removePseudo(W);if(!A||this.compareCoord(X[0],Z[0])||(Z=this.fixStartIndex(Z,X))){var G=this.compareCoord(X[k],Z[k]);return this.direction||G?this.comparePath(X,Z):!!this.compareCoord(X[k],Z[Z.length-(1+k)])&&this.comparePath(X.slice().reverse(),Z)}},V.prototype.fixStartIndex=function(R,W){for(var k,A=-1,X=0;X<R.length;X++)if(this.compareCoord(R[X],W[0])){A=X;break}return A>=0&&(k=[].concat(R.slice(A,R.length),R.slice(1,A+1))),k},V.prototype.comparePath=function(R,W){var k=this;return R.every(function(A,X){return k.compareCoord(A,this[X])},W)},V.prototype.comparePolygon=function(R,W){if(this.compareLine(R.coordinates[0],W.coordinates[0],1,!0)){var k=R.coordinates.slice(1,R.coordinates.length),A=W.coordinates.slice(1,W.coordinates.length),X=this;return k.every(function(Z){return this.some(function(G){return X.compareLine(Z,G,1,!0)})},A)}return!1},V.prototype.compareFeature=function(R,W){return!(R.id!==W.id||!this.objectComparator(R.properties,W.properties)||!this.compareBBox(R,W))&&this.compare(R.geometry,W.geometry)},V.prototype.compareBBox=function(R,W){return!!(!R.bbox&&!W.bbox||R.bbox&&W.bbox&&this.compareCoord(R.bbox,W.bbox))},V.prototype.removePseudo=function(R){return R},Lt.exports=V},5665:(Lt,ut,y)=>{var $=y(7571),V=y(621),H=y(8570),q=y(1568).Z,Y=H.featureEach,k=V.featureCollection;function A(X){var Z=new $(X);return Z.insert=function(G){if("Feature"!==G.type)throw new Error("invalid feature");return G.bbox=G.bbox?G.bbox:q(G),$.prototype.insert.call(this,G)},Z.load=function(G){var it=[];return Array.isArray(G)?G.forEach(function(bt){if("Feature"!==bt.type)throw new Error("invalid features");bt.bbox=bt.bbox?bt.bbox:q(bt),it.push(bt)}):Y(G,function(bt){if("Feature"!==bt.type)throw new Error("invalid features");bt.bbox=bt.bbox?bt.bbox:q(bt),it.push(bt)}),$.prototype.load.call(this,it)},Z.remove=function(G,it){if("Feature"!==G.type)throw new Error("invalid feature");return G.bbox=G.bbox?G.bbox:q(G),$.prototype.remove.call(this,G,it)},Z.clear=function(){return $.prototype.clear.call(this)},Z.search=function(G){var it=$.prototype.search.call(this,this.toBBox(G));return k(it)},Z.collides=function(G){return $.prototype.collides.call(this,this.toBBox(G))},Z.all=function(){var G=$.prototype.all.call(this);return k(G)},Z.toJSON=function(){return $.prototype.toJSON.call(this)},Z.fromJSON=function(G){return $.prototype.fromJSON.call(this,G)},Z.toBBox=function(G){var it;if(G.bbox)it=G.bbox;else if(Array.isArray(G)&&4===G.length)it=G;else if(Array.isArray(G)&&6===G.length)it=[G[0],G[1],G[3],G[4]];else if("Feature"===G.type)it=q(G);else{if("FeatureCollection"!==G.type)throw new Error("invalid geojson");it=q(G)}return{minX:it[0],minY:it[1],maxX:it[2],maxY:it[3]}},Z}Lt.exports=A,Lt.exports.default=A},7571:function(Lt){Lt.exports=function(){"use strict";function ut(K,st,et,dt,lt){!function St(Q,ft,pt,B,ot){for(;B>pt;){if(B-pt>600){var P=B-pt+1,at=ft-pt+1,nt=Math.log(P),Gt=.5*Math.exp(2*nt/3),O=.5*Math.sqrt(nt*Gt*(P-Gt)/P)*(at-P/2<0?-1:1);St(Q,ft,Math.max(pt,Math.floor(ft-at*Gt/P+O)),Math.min(B,Math.floor(ft+(P-at)*Gt/P+O)),ot)}var vt=Q[ft],xt=pt,Mt=B;for(y(Q,pt,ft),ot(Q[B],vt)>0&&y(Q,pt,B);xt<Mt;){for(y(Q,xt,Mt),xt++,Mt--;ot(Q[xt],vt)<0;)xt++;for(;ot(Q[Mt],vt)>0;)Mt--}0===ot(Q[pt],vt)?y(Q,pt,Mt):y(Q,++Mt,B),Mt<=ft&&(pt=Mt+1),ft<=Mt&&(B=Mt-1)}}(K,st,et||0,dt||K.length-1,lt||$)}function y(K,st,et){var dt=K[st];K[st]=K[et],K[et]=dt}function $(K,st){return K<st?-1:K>st?1:0}var V=function(K){void 0===K&&(K=9),this._maxEntries=Math.max(4,K),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function H(K,st,et){if(!et)return st.indexOf(K);for(var dt=0;dt<st.length;dt++)if(et(K,st[dt]))return dt;return-1}function q(K,st){Y(K,0,K.children.length,st,K)}function Y(K,st,et,dt,lt){lt||(lt=it(null)),lt.minX=1/0,lt.minY=1/0,lt.maxX=-1/0,lt.maxY=-1/0;for(var St=st;St<et;St++){var Q=K.children[St];R(lt,K.leaf?dt(Q):Q)}return lt}function R(K,st){return K.minX=Math.min(K.minX,st.minX),K.minY=Math.min(K.minY,st.minY),K.maxX=Math.max(K.maxX,st.maxX),K.maxY=Math.max(K.maxY,st.maxY),K}function W(K,st){return K.minX-st.minX}function k(K,st){return K.minY-st.minY}function A(K){return(K.maxX-K.minX)*(K.maxY-K.minY)}function X(K){return K.maxX-K.minX+(K.maxY-K.minY)}function Z(K,st){return K.minX<=st.minX&&K.minY<=st.minY&&st.maxX<=K.maxX&&st.maxY<=K.maxY}function G(K,st){return st.minX<=K.maxX&&st.minY<=K.maxY&&st.maxX>=K.minX&&st.maxY>=K.minY}function it(K){return{children:K,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function bt(K,st,et,dt,lt){for(var St=[st,et];St.length;)if(!((et=St.pop())-(st=St.pop())<=dt)){var Q=st+Math.ceil((et-st)/dt/2)*dt;ut(K,Q,st,et,lt),St.push(st,Q,Q,et)}}return V.prototype.all=function(){return this._all(this.data,[])},V.prototype.search=function(K){var st=this.data,et=[];if(!G(K,st))return et;for(var dt=this.toBBox,lt=[];st;){for(var St=0;St<st.children.length;St++){var Q=st.children[St],ft=st.leaf?dt(Q):Q;G(K,ft)&&(st.leaf?et.push(Q):Z(K,ft)?this._all(Q,et):lt.push(Q))}st=lt.pop()}return et},V.prototype.collides=function(K){var st=this.data;if(!G(K,st))return!1;for(var et=[];st;){for(var dt=0;dt<st.children.length;dt++){var lt=st.children[dt],St=st.leaf?this.toBBox(lt):lt;if(G(K,St)){if(st.leaf||Z(K,St))return!0;et.push(lt)}}st=et.pop()}return!1},V.prototype.load=function(K){if(!K||!K.length)return this;if(K.length<this._minEntries){for(var st=0;st<K.length;st++)this.insert(K[st]);return this}var et=this._build(K.slice(),0,K.length-1,0);if(this.data.children.length)if(this.data.height===et.height)this._splitRoot(this.data,et);else{if(this.data.height<et.height){var dt=this.data;this.data=et,et=dt}this._insert(et,this.data.height-et.height-1,!0)}else this.data=et;return this},V.prototype.insert=function(K){return K&&this._insert(K,this.data.height-1),this},V.prototype.clear=function(){return this.data=it([]),this},V.prototype.remove=function(K,st){if(!K)return this;for(var et,dt,lt,St=this.data,Q=this.toBBox(K),ft=[],pt=[];St||ft.length;){if(St||(St=ft.pop(),dt=ft[ft.length-1],et=pt.pop(),lt=!0),St.leaf){var B=H(K,St.children,st);if(-1!==B)return St.children.splice(B,1),ft.push(St),this._condense(ft),this}lt||St.leaf||!Z(St,Q)?dt?(et++,St=dt.children[et],lt=!1):St=null:(ft.push(St),pt.push(et),et=0,dt=St,St=St.children[0])}return this},V.prototype.toBBox=function(K){return K},V.prototype.compareMinX=function(K,st){return K.minX-st.minX},V.prototype.compareMinY=function(K,st){return K.minY-st.minY},V.prototype.toJSON=function(){return this.data},V.prototype.fromJSON=function(K){return this.data=K,this},V.prototype._all=function(K,st){for(var et=[];K;)K.leaf?st.push.apply(st,K.children):et.push.apply(et,K.children),K=et.pop();return st},V.prototype._build=function(K,st,et,dt){var lt,St=et-st+1,Q=this._maxEntries;if(St<=Q)return q(lt=it(K.slice(st,et+1)),this.toBBox),lt;dt||(dt=Math.ceil(Math.log(St)/Math.log(Q)),Q=Math.ceil(St/Math.pow(Q,dt-1))),(lt=it([])).leaf=!1,lt.height=dt;var ft=Math.ceil(St/Q),pt=ft*Math.ceil(Math.sqrt(Q));bt(K,st,et,pt,this.compareMinX);for(var B=st;B<=et;B+=pt){var ot=Math.min(B+pt-1,et);bt(K,B,ot,ft,this.compareMinY);for(var P=B;P<=ot;P+=ft){var at=Math.min(P+ft-1,ot);lt.children.push(this._build(K,P,at,dt-1))}}return q(lt,this.toBBox),lt},V.prototype._chooseSubtree=function(K,st,et,dt){for(;dt.push(st),!st.leaf&&dt.length-1!==et;){for(var lt=1/0,St=1/0,Q=void 0,ft=0;ft<st.children.length;ft++){var pt=st.children[ft],B=A(pt),ot=(P=K,at=pt,(Math.max(at.maxX,P.maxX)-Math.min(at.minX,P.minX))*(Math.max(at.maxY,P.maxY)-Math.min(at.minY,P.minY))-B);ot<St?(St=ot,lt=B<lt?B:lt,Q=pt):ot===St&&B<lt&&(lt=B,Q=pt)}st=Q||st.children[0]}var P,at;return st},V.prototype._insert=function(K,st,et){var dt=et?K:this.toBBox(K),lt=[],St=this._chooseSubtree(dt,this.data,st,lt);for(St.children.push(K),R(St,dt);st>=0&&lt[st].children.length>this._maxEntries;)this._split(lt,st),st--;this._adjustParentBBoxes(dt,lt,st)},V.prototype._split=function(K,st){var et=K[st],dt=et.children.length,lt=this._minEntries;this._chooseSplitAxis(et,lt,dt);var St=this._chooseSplitIndex(et,lt,dt),Q=it(et.children.splice(St,et.children.length-St));Q.height=et.height,Q.leaf=et.leaf,q(et,this.toBBox),q(Q,this.toBBox),st?K[st-1].children.push(Q):this._splitRoot(et,Q)},V.prototype._splitRoot=function(K,st){this.data=it([K,st]),this.data.height=K.height+1,this.data.leaf=!1,q(this.data,this.toBBox)},V.prototype._chooseSplitIndex=function(K,st,et){for(var dt,lt,St,Q,ft,pt,B,ot=1/0,P=1/0,at=st;at<=et-st;at++){var nt=Y(K,0,at,this.toBBox),Gt=Y(K,at,et,this.toBBox),O=(lt=nt,St=Gt,void 0,void 0,void 0,void 0,Q=Math.max(lt.minX,St.minX),ft=Math.max(lt.minY,St.minY),pt=Math.min(lt.maxX,St.maxX),B=Math.min(lt.maxY,St.maxY),Math.max(0,pt-Q)*Math.max(0,B-ft)),Ct=A(nt)+A(Gt);O<ot?(ot=O,dt=at,P=Ct<P?Ct:P):O===ot&&Ct<P&&(P=Ct,dt=at)}return dt||et-st},V.prototype._chooseSplitAxis=function(K,st,et){var dt=K.leaf?this.compareMinX:W,lt=K.leaf?this.compareMinY:k;this._allDistMargin(K,st,et,dt)<this._allDistMargin(K,st,et,lt)&&K.children.sort(dt)},V.prototype._allDistMargin=function(K,st,et,dt){K.children.sort(dt);for(var lt=this.toBBox,St=Y(K,0,st,lt),Q=Y(K,et-st,et,lt),ft=X(St)+X(Q),pt=st;pt<et-st;pt++){var B=K.children[pt];R(St,K.leaf?lt(B):B),ft+=X(St)}for(var ot=et-st-1;ot>=st;ot--){var P=K.children[ot];R(Q,K.leaf?lt(P):P),ft+=X(Q)}return ft},V.prototype._adjustParentBBoxes=function(K,st,et){for(var dt=et;dt>=0;dt--)R(st[dt],K)},V.prototype._condense=function(K){for(var st=K.length-1,et=void 0;st>=0;st--)0===K[st].children.length?st>0?(et=K[st-1].children).splice(et.indexOf(K[st]),1):this.clear():q(K[st],this.toBBox)},V}()},491:(Lt,ut,y)=>{"use strict";var $,V=y(2050),H=y(4500),q=y(2992),Y=y(3944),R=y(4203),W=y(5223),k=y(6130),A=Function,X=function(xt){try{return A('"use strict"; return ('+xt+").constructor;")()}catch{}},Z=Object.getOwnPropertyDescriptor;if(Z)try{Z({},"")}catch{Z=null}var G=function(){throw new W},it=Z?function(){try{return G}catch{try{return Z(arguments,"callee").get}catch{return G}}}():G,bt=y(6152)(),K=y(9028)(),st=Object.getPrototypeOf||(K?function(xt){return xt.__proto__}:null),et={},dt=typeof Uint8Array>"u"||!st?$:st(Uint8Array),lt={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?$:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?$:ArrayBuffer,"%ArrayIteratorPrototype%":bt&&st?st([][Symbol.iterator]()):$,"%AsyncFromSyncIteratorPrototype%":$,"%AsyncFunction%":et,"%AsyncGenerator%":et,"%AsyncGeneratorFunction%":et,"%AsyncIteratorPrototype%":et,"%Atomics%":typeof Atomics>"u"?$:Atomics,"%BigInt%":typeof BigInt>"u"?$:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?$:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?$:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?$:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":V,"%eval%":eval,"%EvalError%":H,"%Float32Array%":typeof Float32Array>"u"?$:Float32Array,"%Float64Array%":typeof Float64Array>"u"?$:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?$:FinalizationRegistry,"%Function%":A,"%GeneratorFunction%":et,"%Int8Array%":typeof Int8Array>"u"?$:Int8Array,"%Int16Array%":typeof Int16Array>"u"?$:Int16Array,"%Int32Array%":typeof Int32Array>"u"?$:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":bt&&st?st(st([][Symbol.iterator]())):$,"%JSON%":"object"==typeof JSON?JSON:$,"%Map%":typeof Map>"u"?$:Map,"%MapIteratorPrototype%":typeof Map>"u"||!bt||!st?$:st((new Map)[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?$:Promise,"%Proxy%":typeof Proxy>"u"?$:Proxy,"%RangeError%":q,"%ReferenceError%":Y,"%Reflect%":typeof Reflect>"u"?$:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?$:Set,"%SetIteratorPrototype%":typeof Set>"u"||!bt||!st?$:st((new Set)[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?$:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":bt&&st?st(""[Symbol.iterator]()):$,"%Symbol%":bt?Symbol:$,"%SyntaxError%":R,"%ThrowTypeError%":it,"%TypedArray%":dt,"%TypeError%":W,"%Uint8Array%":typeof Uint8Array>"u"?$:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?$:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?$:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?$:Uint32Array,"%URIError%":k,"%WeakMap%":typeof WeakMap>"u"?$:WeakMap,"%WeakRef%":typeof WeakRef>"u"?$:WeakRef,"%WeakSet%":typeof WeakSet>"u"?$:WeakSet};if(st)try{null.error}catch(xt){var St=st(st(xt));lt["%Error.prototype%"]=St}var Q=function xt(Mt){var It;if("%AsyncFunction%"===Mt)It=X("async function () {}");else if("%GeneratorFunction%"===Mt)It=X("function* () {}");else if("%AsyncGeneratorFunction%"===Mt)It=X("async function* () {}");else if("%AsyncGenerator%"===Mt){var re=xt("%AsyncGeneratorFunction%");re&&(It=re.prototype)}else if("%AsyncIteratorPrototype%"===Mt){var Bt=xt("%AsyncGenerator%");Bt&&st&&(It=st(Bt.prototype))}return lt[Mt]=It,It},ft={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},pt=y(5333),B=y(836),ot=pt.call(Function.call,Array.prototype.concat),P=pt.call(Function.apply,Array.prototype.splice),at=pt.call(Function.call,String.prototype.replace),nt=pt.call(Function.call,String.prototype.slice),Gt=pt.call(Function.call,RegExp.prototype.exec),O=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,Ct=/\\(\\)?/g,vt=function(Mt,It){var Bt,re=Mt;if(B(ft,re)&&(re="%"+(Bt=ft[re])[0]+"%"),B(lt,re)){var ee=lt[re];if(ee===et&&(ee=Q(re)),typeof ee>"u"&&!It)throw new W("intrinsic "+Mt+" exists, but is not available. Please file an issue!");return{alias:Bt,name:re,value:ee}}throw new R("intrinsic "+Mt+" does not exist!")};Lt.exports=function(Mt,It){if("string"!=typeof Mt||0===Mt.length)throw new W("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof It)throw new W('"allowMissing" argument must be a boolean');if(null===Gt(/^%?[^%]*%?$/,Mt))throw new R("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var re=function(Mt){var It=nt(Mt,0,1),re=nt(Mt,-1);if("%"===It&&"%"!==re)throw new R("invalid intrinsic syntax, expected closing `%`");if("%"===re&&"%"!==It)throw new R("invalid intrinsic syntax, expected opening `%`");var Bt=[];return at(Mt,O,function(ee,jt,se,be){Bt[Bt.length]=se?at(be,Ct,"$1"):jt||ee}),Bt}(Mt),Bt=re.length>0?re[0]:"",ee=vt("%"+Bt+"%",It),jt=ee.name,se=ee.value,be=!1,Me=ee.alias;Me&&(Bt=Me[0],P(re,ot([0,1],Me)));for(var Xe=1,Ue=!0;Xe<re.length;Xe+=1){var De=re[Xe],Tn=nt(De,0,1),On=nt(De,-1);if(('"'===Tn||"'"===Tn||"`"===Tn||'"'===On||"'"===On||"`"===On)&&Tn!==On)throw new R("property names with quotes must have matching quotes");if(("constructor"===De||!Ue)&&(be=!0),B(lt,jt="%"+(Bt+="."+De)+"%"))se=lt[jt];else if(null!=se){if(!(De in se)){if(!It)throw new W("base intrinsic for "+Mt+" exists, but the property is not available.");return}if(Z&&Xe+1>=re.length){var ne=Z(se,De);se=(Ue=!!ne)&&"get"in ne&&!("originalValue"in ne.get)?ne.get:se[De]}else Ue=B(se,De),se=se[De];Ue&&!be&&(lt[jt]=se)}}return se}},9262:(Lt,ut,y)=>{"use strict";var V=y(491)("%Object.getOwnPropertyDescriptor%",!0);if(V)try{V([],"length")}catch{V=null}Lt.exports=V},2486:(Lt,ut,y)=>{"use strict";var $=y(474),V=function(){return!!$};V.hasArrayLengthDefineBug=function(){if(!$)return null;try{return 1!==$([],"length",{value:1}).length}catch{return!0}},Lt.exports=V},9028:Lt=>{"use strict";var ut={__proto__:null,foo:{}},y=Object;Lt.exports=function(){return{__proto__:ut}.foo===ut.foo&&!(ut instanceof y)}},6152:(Lt,ut,y)=>{"use strict";var $=typeof Symbol<"u"&&Symbol,V=y(5441);Lt.exports=function(){return"function"==typeof $&&"function"==typeof Symbol&&"symbol"==typeof $("foo")&&"symbol"==typeof Symbol("bar")&&V()}},5441:Lt=>{"use strict";Lt.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var y={},$=Symbol("test"),V=Object($);if("string"==typeof $||"[object Symbol]"!==Object.prototype.toString.call($)||"[object Symbol]"!==Object.prototype.toString.call(V))return!1;for($ in y[$]=42,y)return!1;if("function"==typeof Object.keys&&0!==Object.keys(y).length||"function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(y).length)return!1;var q=Object.getOwnPropertySymbols(y);if(1!==q.length||q[0]!==$||!Object.prototype.propertyIsEnumerable.call(y,$))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var Y=Object.getOwnPropertyDescriptor(y,$);if(42!==Y.value||!0!==Y.enumerable)return!1}return!0}},8041:(Lt,ut,y)=>{"use strict";var $=y(5441);Lt.exports=function(){return $()&&!!Symbol.toStringTag}},836:(Lt,ut,y)=>{"use strict";var $=Function.prototype.call,V=Object.prototype.hasOwnProperty,H=y(5333);Lt.exports=H.call($,V)},8147:(Lt,ut,y)=>{"use strict";var $=y(8041)(),H=y(1098)("Object.prototype.toString"),q=function(k){return!($&&k&&"object"==typeof k&&Symbol.toStringTag in k)&&"[object Arguments]"===H(k)},Y=function(k){return!!q(k)||null!==k&&"object"==typeof k&&"number"==typeof k.length&&k.length>=0&&"[object Array]"!==H(k)&&"[object Function]"===H(k.callee)},R=function(){return q(arguments)}();q.isLegacyArguments=Y,Lt.exports=R?q:Y},2365:(Lt,ut,y)=>{"use strict";var $=Date.prototype.getDay,H=Object.prototype.toString,Y=y(8041)();Lt.exports=function(W){return"object"==typeof W&&null!==W&&(Y?function(W){try{return $.call(W),!0}catch{return!1}}(W):"[object Date]"===H.call(W))}},4720:(Lt,ut,y)=>{"use strict";var H,q,Y,R,$=y(1098),V=y(8041)();if(V){H=$("Object.prototype.hasOwnProperty"),q=$("RegExp.prototype.exec"),Y={};var W=function(){throw Y};R={toString:W,valueOf:W},"symbol"==typeof Symbol.toPrimitive&&(R[Symbol.toPrimitive]=W)}var k=$("Object.prototype.toString"),A=Object.getOwnPropertyDescriptor;Lt.exports=V?function(G){if(!G||"object"!=typeof G)return!1;var it=A(G,"lastIndex");if(!it||!H(it,"value"))return!1;try{q(G,R)}catch(K){return K===Y}}:function(G){return!(!G||"object"!=typeof G&&"function"!=typeof G)&&"[object RegExp]"===k(G)}},3727:()=>{(function(){"use strict";function Lt(ut){return this instanceof Lt?(this._canvas=ut="string"==typeof ut?document.getElementById(ut):ut,this._ctx=ut.getContext("2d"),this._width=ut.width,this._height=ut.height,this._max=1,void this.clear()):new Lt(ut)}Lt.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(ut,y){return this._data=ut,this},max:function(ut){return this._max=ut,this},add:function(ut){return this._data.push(ut),this},clear:function(){return this._data=[],this},radius:function(ut,y){y=y||15;var $=this._circle=document.createElement("canvas"),V=$.getContext("2d"),H=this._r=ut+y;return $.width=$.height=2*H,V.shadowOffsetX=V.shadowOffsetY=200,V.shadowBlur=y,V.shadowColor="black",V.beginPath(),V.arc(H-200,H-200,ut,0,2*Math.PI,!0),V.closePath(),V.fill(),this},gradient:function(ut){var y=document.createElement("canvas"),$=y.getContext("2d"),V=$.createLinearGradient(0,0,0,256);for(var H in y.width=1,y.height=256,ut)V.addColorStop(H,ut[H]);return $.fillStyle=V,$.fillRect(0,0,1,256),this._grad=$.getImageData(0,0,1,256).data,this},draw:function(ut){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var y=this._ctx;y.clearRect(0,0,this._width,this._height);for(var $,V=0,H=this._data.length;H>V;V++)$=this._data[V],y.globalAlpha=Math.max($[2]/this._max,ut||.05),y.drawImage(this._circle,$[0]-this._r,$[1]-this._r);var q=y.getImageData(0,0,this._width,this._height);return this._colorize(q.data,this._grad),y.putImageData(q,0,0),this},_colorize:function(ut,y){for(var $,V=3,H=ut.length;H>V;V+=4)($=4*ut[V])&&(ut[V-3]=y[$],ut[V-2]=y[$+1],ut[V-1]=y[$+2])}},window.simpleheat=Lt})(),L.HeatLayer=(L.Layer?L.Layer:L.Class).extend({initialize:function(Lt,ut){this._latlngs=Lt,L.setOptions(this,ut)},setLatLngs:function(Lt){return this._latlngs=Lt,this.redraw()},addLatLng:function(Lt){return this._latlngs.push(Lt),this.redraw()},setOptions:function(Lt){return L.setOptions(this,Lt),this._heat&&this._updateOptions(),this.redraw()},redraw:function(){return!this._heat||this._frame||this._map._animating||(this._frame=L.Util.requestAnimFrame(this._redraw,this)),this},onAdd:function(Lt){this._map=Lt,this._canvas||this._initCanvas(),Lt._panes.overlayPane.appendChild(this._canvas),Lt.on("moveend",this._reset,this),Lt.options.zoomAnimation&&L.Browser.any3d&&Lt.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(Lt){Lt.getPanes().overlayPane.removeChild(this._canvas),Lt.off("moveend",this._reset,this),Lt.options.zoomAnimation&&Lt.off("zoomanim",this._animateZoom,this)},addTo:function(Lt){return Lt.addLayer(this),this},_initCanvas:function(){var Lt=this._canvas=L.DomUtil.create("canvas","leaflet-heatmap-layer leaflet-layer"),ut=L.DomUtil.testProp(["transformOrigin","WebkitTransformOrigin","msTransformOrigin"]);Lt.style[ut]="50% 50%";var y=this._map.getSize();Lt.width=y.x,Lt.height=y.y;var $=this._map.options.zoomAnimation&&L.Browser.any3d;L.DomUtil.addClass(Lt,"leaflet-zoom-"+($?"animated":"hide")),this._heat=simpleheat(Lt),this._updateOptions()},_updateOptions:function(){this._heat.radius(this.options.radius||this._heat.defaultRadius,this.options.blur),this.options.gradient&&this._heat.gradient(this.options.gradient),this.options.max&&this._heat.max(this.options.max)},_reset:function(){var Lt=this._map.containerPointToLayerPoint([0,0]);L.DomUtil.setPosition(this._canvas,Lt);var ut=this._map.getSize();this._heat._width!==ut.x&&(this._canvas.width=this._heat._width=ut.x),this._heat._height!==ut.y&&(this._canvas.height=this._heat._height=ut.y),this._redraw()},_redraw:function(){var Lt,ut,y,$,V,H,q,Y,R,W=[],k=this._heat._r,A=this._map.getSize(),X=new L.Bounds(L.point([-k,-k]),A.add([k,k])),Z=void 0===this.options.max?1:this.options.max,G=void 0===this.options.maxZoom?this._map.getMaxZoom():this.options.maxZoom,it=1/Math.pow(2,Math.max(0,Math.min(G-this._map.getZoom(),12))),bt=k/2,K=[],st=this._map._getMapPanePos(),et=st.x%bt,dt=st.y%bt;for(Lt=0,ut=this._latlngs.length;ut>Lt;Lt++)y=this._map.latLngToContainerPoint(this._latlngs[Lt]),X.contains(y)&&(V=Math.floor((y.x-et)/bt)+2,H=Math.floor((y.y-dt)/bt)+2,R=(void 0!==this._latlngs[Lt].alt?this._latlngs[Lt].alt:void 0!==this._latlngs[Lt][2]?+this._latlngs[Lt][2]:1)*it,K[H]=K[H]||[],($=K[H][V])?($[0]=($[0]*$[2]+y.x*R)/($[2]+R),$[1]=($[1]*$[2]+y.y*R)/($[2]+R),$[2]+=R):K[H][V]=[y.x,y.y,R]);for(Lt=0,ut=K.length;ut>Lt;Lt++)if(K[Lt])for(q=0,Y=K[Lt].length;Y>q;q++)($=K[Lt][q])&&W.push([Math.round($[0]),Math.round($[1]),Math.min($[2],Z)]);this._heat.data(W).draw(this.options.minOpacity),this._frame=null},_animateZoom:function(Lt){var ut=this._map.getZoomScale(Lt.zoom),y=this._map._getCenterOffset(Lt.center)._multiplyBy(-ut).subtract(this._map._getMapPanePos());L.DomUtil.setTransform?L.DomUtil.setTransform(this._canvas,y,ut):this._canvas.style[L.DomUtil.TRANSFORM]=L.DomUtil.getTranslateString(y)+" scale("+ut+")"}}),L.heatLayer=function(Lt,ut){return new L.HeatLayer(Lt,ut)}},8433:function(Lt,ut){!function(y){"use strict";function V(f){var E,D,j,mt;for(D=1,j=arguments.length;D<j;D++)for(E in mt=arguments[D])f[E]=mt[E];return f}var H=Object.create||function(){function f(){}return function(E){return f.prototype=E,new f}}();function q(f,E){var D=Array.prototype.slice;if(f.bind)return f.bind.apply(f,D.call(arguments,1));var j=D.call(arguments,2);return function(){return f.apply(E,j.length?j.concat(D.call(arguments)):arguments)}}var Y=0;function R(f){return"_leaflet_id"in f||(f._leaflet_id=++Y),f._leaflet_id}function W(f,E,D){var j,mt,Ft,ce;return ce=function(){j=!1,mt&&(Ft.apply(D,mt),mt=!1)},Ft=function(){j?mt=arguments:(f.apply(D,arguments),setTimeout(ce,E),j=!0)},Ft}function k(f,E,D){var j=E[1],mt=E[0],Ft=j-mt;return f===j&&D?f:((f-mt)%Ft+Ft)%Ft+mt}function A(){return!1}function X(f,E){if(!1===E)return f;var D=Math.pow(10,void 0===E?6:E);return Math.round(f*D)/D}function Z(f){return f.trim?f.trim():f.replace(/^\s+|\s+$/g,"")}function G(f){return Z(f).split(/\s+/)}function it(f,E){for(var D in Object.prototype.hasOwnProperty.call(f,"options")||(f.options=f.options?H(f.options):{}),E)f.options[D]=E[D];return f.options}function bt(f,E,D){var j=[];for(var mt in f)j.push(encodeURIComponent(D?mt.toUpperCase():mt)+"="+encodeURIComponent(f[mt]));return(E&&-1!==E.indexOf("?")?"&":"?")+j.join("&")}var K=/\{ *([\w_ -]+) *\}/g;function st(f,E){return f.replace(K,function(D,j){var mt=E[j];if(void 0===mt)throw new Error("No value provided for variable "+D);return"function"==typeof mt&&(mt=mt(E)),mt})}var et=Array.isArray||function(f){return"[object Array]"===Object.prototype.toString.call(f)};function dt(f,E){for(var D=0;D<f.length;D++)if(f[D]===E)return D;return-1}var lt="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";function St(f){return window["webkit"+f]||window["moz"+f]||window["ms"+f]}var Q=0;function ft(f){var E=+new Date,D=Math.max(0,16-(E-Q));return Q=E+D,window.setTimeout(f,D)}var pt=window.requestAnimationFrame||St("RequestAnimationFrame")||ft,B=window.cancelAnimationFrame||St("CancelAnimationFrame")||St("CancelRequestAnimationFrame")||function(f){window.clearTimeout(f)};function ot(f,E,D){if(!D||pt!==ft)return pt.call(window,q(f,E));f.call(E)}function P(f){f&&B.call(window,f)}var at={__proto__:null,extend:V,create:H,bind:q,get lastId(){return Y},stamp:R,throttle:W,wrapNum:k,falseFn:A,formatNum:X,trim:Z,splitWords:G,setOptions:it,getParamString:bt,template:st,isArray:et,indexOf:dt,emptyImageUrl:lt,requestFn:pt,cancelFn:B,requestAnimFrame:ot,cancelAnimFrame:P};function nt(){}nt.extend=function(f){var E=function(){it(this),this.initialize&&this.initialize.apply(this,arguments),this.callInitHooks()},D=E.__super__=this.prototype,j=H(D);for(var mt in j.constructor=E,E.prototype=j,this)Object.prototype.hasOwnProperty.call(this,mt)&&"prototype"!==mt&&"__super__"!==mt&&(E[mt]=this[mt]);return f.statics&&V(E,f.statics),f.includes&&(function Gt(f){if(!(typeof L>"u")&&L&&L.Mixin){f=et(f)?f:[f];for(var E=0;E<f.length;E++)f[E]===L.Mixin.Events&&console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.",(new Error).stack)}}(f.includes),V.apply(null,[j].concat(f.includes))),V(j,f),delete j.statics,delete j.includes,j.options&&(j.options=D.options?H(D.options):{},V(j.options,f.options)),j._initHooks=[],j.callInitHooks=function(){if(!this._initHooksCalled){D.callInitHooks&&D.callInitHooks.call(this),this._initHooksCalled=!0;for(var Ft=0,ce=j._initHooks.length;Ft<ce;Ft++)j._initHooks[Ft].call(this)}},E},nt.include=function(f){var E=this.prototype.options;return V(this.prototype,f),f.options&&(this.prototype.options=E,this.mergeOptions(f.options)),this},nt.mergeOptions=function(f){return V(this.prototype.options,f),this},nt.addInitHook=function(f){var E=Array.prototype.slice.call(arguments,1),D="function"==typeof f?f:function(){this[f].apply(this,E)};return this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(D),this};var O={on:function(f,E,D){if("object"==typeof f)for(var j in f)this._on(j,f[j],E);else for(var mt=0,Ft=(f=G(f)).length;mt<Ft;mt++)this._on(f[mt],E,D);return this},off:function(f,E,D){if(arguments.length)if("object"==typeof f)for(var j in f)this._off(j,f[j],E);else{f=G(f);for(var mt=1===arguments.length,Ft=0,ce=f.length;Ft<ce;Ft++)mt?this._off(f[Ft]):this._off(f[Ft],E,D)}else delete this._events;return this},_on:function(f,E,D,j){if("function"==typeof E){if(!1===this._listens(f,E,D)){D===this&&(D=void 0);var mt={fn:E,ctx:D};j&&(mt.once=!0),this._events=this._events||{},this._events[f]=this._events[f]||[],this._events[f].push(mt)}}else console.warn("wrong listener type: "+typeof E)},_off:function(f,E,D){var j,mt,Ft;if(this._events&&(j=this._events[f])){if(1===arguments.length){if(this._firingCount)for(mt=0,Ft=j.length;mt<Ft;mt++)j[mt].fn=A;return void delete this._events[f]}if("function"!=typeof E)return void console.warn("wrong listener type: "+typeof E);var ce=this._listens(f,E,D);!1!==ce&&(this._firingCount&&(j[ce].fn=A,this._events[f]=j=j.slice()),j.splice(ce,1))}},fire:function(f,E,D){if(!this.listens(f,D))return this;var j=V({},E,{type:f,target:this,sourceTarget:E&&E.sourceTarget||this});if(this._events){var mt=this._events[f];if(mt){this._firingCount=this._firingCount+1||1;for(var Ft=0,ce=mt.length;Ft<ce;Ft++){var ye=mt[Ft],Ve=ye.fn;ye.once&&this.off(f,Ve,ye.ctx),Ve.call(ye.ctx||this,j)}this._firingCount--}}return D&&this._propagateEvent(j),this},listens:function(f,E,D,j){"string"!=typeof f&&console.warn('"string" type argument expected');var mt=E;"function"!=typeof E&&(j=!!E,mt=void 0,D=void 0);var Ft=this._events&&this._events[f];if(Ft&&Ft.length&&!1!==this._listens(f,mt,D))return!0;if(j)for(var ce in this._eventParents)if(this._eventParents[ce].listens(f,E,D,j))return!0;return!1},_listens:function(f,E,D){if(!this._events)return!1;var j=this._events[f]||[];if(!E)return!!j.length;D===this&&(D=void 0);for(var mt=0,Ft=j.length;mt<Ft;mt++)if(j[mt].fn===E&&j[mt].ctx===D)return mt;return!1},once:function(f,E,D){if("object"==typeof f)for(var j in f)this._on(j,f[j],E,!0);else for(var mt=0,Ft=(f=G(f)).length;mt<Ft;mt++)this._on(f[mt],E,D,!0);return this},addEventParent:function(f){return this._eventParents=this._eventParents||{},this._eventParents[R(f)]=f,this},removeEventParent:function(f){return this._eventParents&&delete this._eventParents[R(f)],this},_propagateEvent:function(f){for(var E in this._eventParents)this._eventParents[E].fire(f.type,V({layer:f.target,propagatedFrom:f.target},f),!0)}};O.addEventListener=O.on,O.removeEventListener=O.clearAllEventListeners=O.off,O.addOneTimeEventListener=O.once,O.fireEvent=O.fire,O.hasEventListeners=O.listens;var Ct=nt.extend(O);function yt(f,E,D){this.x=D?Math.round(f):f,this.y=D?Math.round(E):E}var vt=Math.trunc||function(f){return f>0?Math.floor(f):Math.ceil(f)};function xt(f,E,D){return f instanceof yt?f:et(f)?new yt(f[0],f[1]):null==f?f:"object"==typeof f&&"x"in f&&"y"in f?new yt(f.x,f.y):new yt(f,E,D)}function Mt(f,E){if(f)for(var D=E?[f,E]:f,j=0,mt=D.length;j<mt;j++)this.extend(D[j])}function It(f,E){return!f||f instanceof Mt?f:new Mt(f,E)}function re(f,E){if(f)for(var D=E?[f,E]:f,j=0,mt=D.length;j<mt;j++)this.extend(D[j])}function Bt(f,E){return f instanceof re?f:new re(f,E)}function ee(f,E,D){if(isNaN(f)||isNaN(E))throw new Error("Invalid LatLng object: ("+f+", "+E+")");this.lat=+f,this.lng=+E,void 0!==D&&(this.alt=+D)}function jt(f,E,D){return f instanceof ee?f:et(f)&&"object"!=typeof f[0]?3===f.length?new ee(f[0],f[1],f[2]):2===f.length?new ee(f[0],f[1]):null:null==f?f:"object"==typeof f&&"lat"in f?new ee(f.lat,"lng"in f?f.lng:f.lon,f.alt):void 0===E?null:new ee(f,E,D)}yt.prototype={clone:function(){return new yt(this.x,this.y)},add:function(f){return this.clone()._add(xt(f))},_add:function(f){return this.x+=f.x,this.y+=f.y,this},subtract:function(f){return this.clone()._subtract(xt(f))},_subtract:function(f){return this.x-=f.x,this.y-=f.y,this},divideBy:function(f){return this.clone()._divideBy(f)},_divideBy:function(f){return this.x/=f,this.y/=f,this},multiplyBy:function(f){return this.clone()._multiplyBy(f)},_multiplyBy:function(f){return this.x*=f,this.y*=f,this},scaleBy:function(f){return new yt(this.x*f.x,this.y*f.y)},unscaleBy:function(f){return new yt(this.x/f.x,this.y/f.y)},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.clone()._ceil()},_ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},trunc:function(){return this.clone()._trunc()},_trunc:function(){return this.x=vt(this.x),this.y=vt(this.y),this},distanceTo:function(f){var E=(f=xt(f)).x-this.x,D=f.y-this.y;return Math.sqrt(E*E+D*D)},equals:function(f){return(f=xt(f)).x===this.x&&f.y===this.y},contains:function(f){return f=xt(f),Math.abs(f.x)<=Math.abs(this.x)&&Math.abs(f.y)<=Math.abs(this.y)},toString:function(){return"Point("+X(this.x)+", "+X(this.y)+")"}},Mt.prototype={extend:function(f){var E,D;if(!f)return this;if(f instanceof yt||"number"==typeof f[0]||"x"in f)E=D=xt(f);else if(D=(f=It(f)).max,!(E=f.min)||!D)return this;return this.min||this.max?(this.min.x=Math.min(E.x,this.min.x),this.max.x=Math.max(D.x,this.max.x),this.min.y=Math.min(E.y,this.min.y),this.max.y=Math.max(D.y,this.max.y)):(this.min=E.clone(),this.max=D.clone()),this},getCenter:function(f){return xt((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,f)},getBottomLeft:function(){return xt(this.min.x,this.max.y)},getTopRight:function(){return xt(this.max.x,this.min.y)},getTopLeft:function(){return this.min},getBottomRight:function(){return this.max},getSize:function(){return this.max.subtract(this.min)},contains:function(f){var E,D;return(f="number"==typeof f[0]||f instanceof yt?xt(f):It(f))instanceof Mt?(E=f.min,D=f.max):E=D=f,E.x>=this.min.x&&D.x<=this.max.x&&E.y>=this.min.y&&D.y<=this.max.y},intersects:function(f){f=It(f);var E=this.min,D=this.max,j=f.min,mt=f.max;return mt.x>=E.x&&j.x<=D.x&&mt.y>=E.y&&j.y<=D.y},overlaps:function(f){f=It(f);var E=this.min,D=this.max,j=f.min,mt=f.max;return mt.x>E.x&&j.x<D.x&&mt.y>E.y&&j.y<D.y},isValid:function(){return!(!this.min||!this.max)},pad:function(f){var E=this.min,D=this.max,j=Math.abs(E.x-D.x)*f,mt=Math.abs(E.y-D.y)*f;return It(xt(E.x-j,E.y-mt),xt(D.x+j,D.y+mt))},equals:function(f){return!!f&&(f=It(f),this.min.equals(f.getTopLeft())&&this.max.equals(f.getBottomRight()))}},re.prototype={extend:function(f){var j,mt,E=this._southWest,D=this._northEast;if(f instanceof ee)j=f,mt=f;else{if(!(f instanceof re))return f?this.extend(jt(f)||Bt(f)):this;if(mt=f._northEast,!(j=f._southWest)||!mt)return this}return E||D?(E.lat=Math.min(j.lat,E.lat),E.lng=Math.min(j.lng,E.lng),D.lat=Math.max(mt.lat,D.lat),D.lng=Math.max(mt.lng,D.lng)):(this._southWest=new ee(j.lat,j.lng),this._northEast=new ee(mt.lat,mt.lng)),this},pad:function(f){var E=this._southWest,D=this._northEast,j=Math.abs(E.lat-D.lat)*f,mt=Math.abs(E.lng-D.lng)*f;return new re(new ee(E.lat-j,E.lng-mt),new ee(D.lat+j,D.lng+mt))},getCenter:function(){return new ee((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new ee(this.getNorth(),this.getWest())},getSouthEast:function(){return new ee(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(f){f="number"==typeof f[0]||f instanceof ee||"lat"in f?jt(f):Bt(f);var j,mt,E=this._southWest,D=this._northEast;return f instanceof re?(j=f.getSouthWest(),mt=f.getNorthEast()):j=mt=f,j.lat>=E.lat&&mt.lat<=D.lat&&j.lng>=E.lng&&mt.lng<=D.lng},intersects:function(f){f=Bt(f);var E=this._southWest,D=this._northEast,j=f.getSouthWest(),mt=f.getNorthEast();return mt.lat>=E.lat&&j.lat<=D.lat&&mt.lng>=E.lng&&j.lng<=D.lng},overlaps:function(f){f=Bt(f);var E=this._southWest,D=this._northEast,j=f.getSouthWest(),mt=f.getNorthEast();return mt.lat>E.lat&&j.lat<D.lat&&mt.lng>E.lng&&j.lng<D.lng},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(f,E){return!!f&&(f=Bt(f),this._southWest.equals(f.getSouthWest(),E)&&this._northEast.equals(f.getNorthEast(),E))},isValid:function(){return!(!this._southWest||!this._northEast)}},ee.prototype={equals:function(f,E){return!!f&&(f=jt(f),Math.max(Math.abs(this.lat-f.lat),Math.abs(this.lng-f.lng))<=(void 0===E?1e-9:E))},toString:function(f){return"LatLng("+X(this.lat,f)+", "+X(this.lng,f)+")"},distanceTo:function(f){return be.distance(this,jt(f))},wrap:function(){return be.wrapLatLng(this)},toBounds:function(f){var E=180*f/40075017,D=E/Math.cos(Math.PI/180*this.lat);return Bt([this.lat-E,this.lng-D],[this.lat+E,this.lng+D])},clone:function(){return new ee(this.lat,this.lng,this.alt)}};var f,se={latLngToPoint:function(f,E){var D=this.projection.project(f),j=this.scale(E);return this.transformation._transform(D,j)},pointToLatLng:function(f,E){var D=this.scale(E),j=this.transformation.untransform(f,D);return this.projection.unproject(j)},project:function(f){return this.projection.project(f)},unproject:function(f){return this.projection.unproject(f)},scale:function(f){return 256*Math.pow(2,f)},zoom:function(f){return Math.log(f/256)/Math.LN2},getProjectedBounds:function(f){if(this.infinite)return null;var E=this.projection.bounds,D=this.scale(f);return new Mt(this.transformation.transform(E.min,D),this.transformation.transform(E.max,D))},infinite:!1,wrapLatLng:function(f){var E=this.wrapLng?k(f.lng,this.wrapLng,!0):f.lng;return new ee(this.wrapLat?k(f.lat,this.wrapLat,!0):f.lat,E,f.alt)},wrapLatLngBounds:function(f){var E=f.getCenter(),D=this.wrapLatLng(E),j=E.lat-D.lat,mt=E.lng-D.lng;if(0===j&&0===mt)return f;var Ft=f.getSouthWest(),ce=f.getNorthEast();return new re(new ee(Ft.lat-j,Ft.lng-mt),new ee(ce.lat-j,ce.lng-mt))}},be=V({},se,{wrapLng:[-180,180],R:6371e3,distance:function(f,E){var D=Math.PI/180,j=f.lat*D,mt=E.lat*D,Ft=Math.sin((E.lat-f.lat)*D/2),ce=Math.sin((E.lng-f.lng)*D/2),ye=Ft*Ft+Math.cos(j)*Math.cos(mt)*ce*ce,Ve=2*Math.atan2(Math.sqrt(ye),Math.sqrt(1-ye));return this.R*Ve}}),Xe={R:6378137,MAX_LATITUDE:85.0511287798,project:function(f){var E=Math.PI/180,D=this.MAX_LATITUDE,j=Math.max(Math.min(D,f.lat),-D),mt=Math.sin(j*E);return new yt(this.R*f.lng*E,this.R*Math.log((1+mt)/(1-mt))/2)},unproject:function(f){var E=180/Math.PI;return new ee((2*Math.atan(Math.exp(f.y/this.R))-Math.PI/2)*E,f.x*E/this.R)},bounds:(f=6378137*Math.PI,new Mt([-f,-f],[f,f]))};function Ue(f,E,D,j){if(et(f))return this._a=f[0],this._b=f[1],this._c=f[2],void(this._d=f[3]);this._a=f,this._b=E,this._c=D,this._d=j}function De(f,E,D,j){return new Ue(f,E,D,j)}Ue.prototype={transform:function(f,E){return this._transform(f.clone(),E)},_transform:function(f,E){return f.x=(E=E||1)*(this._a*f.x+this._b),f.y=E*(this._c*f.y+this._d),f},untransform:function(f,E){return new yt((f.x/(E=E||1)-this._b)/this._a,(f.y/E-this._d)/this._c)}};var Tn=V({},be,{code:"EPSG:3857",projection:Xe,transformation:function(){var f=.5/(Math.PI*Xe.R);return De(f,.5,-f,.5)}()}),On=V({},Tn,{code:"EPSG:900913"});function ne(f){return document.createElementNS("http://www.w3.org/2000/svg",f)}function pe(f,E){var j,mt,Ft,ce,ye,Ve,D="";for(j=0,Ft=f.length;j<Ft;j++){for(mt=0,ce=(ye=f[j]).length;mt<ce;mt++)D+=(mt?"L":"M")+(Ve=ye[mt]).x+" "+Ve.y;D+=E?Dn.svg?"z":"x":""}return D||"M0 0"}var Ie=document.documentElement.style,Je="ActiveXObject"in window,Gn=Je&&!document.addEventListener,Er="msLaunchUri"in navigator&&!("documentMode"in document),Nn=wr("webkit"),Yn=wr("android"),hi=wr("android 2")||wr("android 3"),di=parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1],10),to=Yn&&wr("Google")&&di<537&&!("AudioNode"in window),ii=!!window.opera,yn=!Er&&wr("chrome"),Qo=wr("gecko")&&!Nn&&!ii&&!Je,Eo=!yn&&wr("safari"),Hn=wr("phantom"),Hs="OTransition"in Ie,Ce=0===navigator.platform.indexOf("Win"),Et=Je&&"transition"in Ie,Rt="WebKitCSSMatrix"in window&&"m11"in new window.WebKitCSSMatrix&&!hi,te="MozPerspective"in Ie,oe=!window.L_DISABLE_3D&&(Et||Rt||te)&&!Hs&&!Hn,ie=typeof orientation<"u"||wr("mobile"),ze=ie&&Nn,Oe=ie&&Rt,je=!window.PointerEvent&&window.MSPointerEvent,Xt=!(!window.PointerEvent&&!je),En="ontouchstart"in window||!!window.TouchEvent,ue=!window.L_NO_TOUCH&&(En||Xt),en=ie&&ii,mn=ie&&Qo,un=(window.devicePixelRatio||window.screen.deviceXDPI/window.screen.logicalXDPI)>1,tr=function(){var f=!1;try{var E=Object.defineProperty({},"passive",{get:function(){f=!0}});window.addEventListener("testPassiveEventSupport",A,E),window.removeEventListener("testPassiveEventSupport",A,E)}catch{}return f}(),dr=!!document.createElement("canvas").getContext,zn=!(!document.createElementNS||!ne("svg").createSVGRect),vn=!!zn&&function(){var f=document.createElement("div");return f.innerHTML="<svg/>","http://www.w3.org/2000/svg"===(f.firstChild&&f.firstChild.namespaceURI)}(),sr=!zn&&function(){try{var f=document.createElement("div");f.innerHTML='<v:shape adj="1"/>';var E=f.firstChild;return E.style.behavior="url(#default#VML)",E&&"object"==typeof E.adj}catch{return!1}}();function wr(f){return navigator.userAgent.toLowerCase().indexOf(f)>=0}var Dn={ie:Je,ielt9:Gn,edge:Er,webkit:Nn,android:Yn,android23:hi,androidStock:to,opera:ii,chrome:yn,gecko:Qo,safari:Eo,phantom:Hn,opera12:Hs,win:Ce,ie3d:Et,webkit3d:Rt,gecko3d:te,any3d:oe,mobile:ie,mobileWebkit:ze,mobileWebkit3d:Oe,msPointer:je,pointer:Xt,touch:ue,touchNative:En,mobileOpera:en,mobileGecko:mn,retina:un,passiveEvents:tr,canvas:dr,svg:zn,vml:sr,inlineSvg:vn,mac:0===navigator.platform.indexOf("Mac"),linux:0===navigator.platform.indexOf("Linux")},si=Dn.msPointer?"MSPointerDown":"pointerdown",Rr=Dn.msPointer?"MSPointerMove":"pointermove",er=Dn.msPointer?"MSPointerUp":"pointerup",Zi=Dn.msPointer?"MSPointerCancel":"pointercancel",fi={touchstart:si,touchmove:Rr,touchend:er,touchcancel:Zi},oi={touchstart:function Ls(f,E){E.MSPOINTER_TYPE_TOUCH&&E.pointerType===E.MSPOINTER_TYPE_TOUCH&&_e(E),Co(f,E)},touchmove:Co,touchend:Co,touchcancel:Co},zr={},js=!1;function ho(f,E,D){return"touchstart"===E&&function Vr(){js||(document.addEventListener(si,Ks,!0),document.addEventListener(Rr,Ss,!0),document.addEventListener(er,ti,!0),document.addEventListener(Zi,ti,!0),js=!0)}(),oi[E]?(D=oi[E].bind(this,D),f.addEventListener(fi[E],D,!1),D):(console.warn("wrong event specified:",E),A)}function Ks(f){zr[f.pointerId]=f}function Ss(f){zr[f.pointerId]&&(zr[f.pointerId]=f)}function ti(f){delete zr[f.pointerId]}function Co(f,E){if(E.pointerType!==(E.MSPOINTER_TYPE_MOUSE||"mouse")){for(var D in E.touches=[],zr)E.touches.push(zr[D]);E.changedTouches=[E],f(E)}}var rs=200;var Yi,La,an,Io,ks,wo=Yu(["transform","webkitTransform","OTransform","MozTransform","msTransform"]),ys=Yu(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),Wa="webkitTransition"===ys||"OTransition"===ys?ys+"End":"transitionend";function bu(f){return"string"==typeof f?document.getElementById(f):f}function Ra(f,E){var D=f.style[E]||f.currentStyle&&f.currentStyle[E];if((!D||"auto"===D)&&document.defaultView){var j=document.defaultView.getComputedStyle(f,null);D=j?j[E]:null}return"auto"===D?null:D}function $r(f,E,D){var j=document.createElement(f);return j.className=E||"",D&&D.appendChild(j),j}function pr(f){var E=f.parentNode;E&&E.removeChild(f)}function fu(f){for(;f.firstChild;)f.removeChild(f.firstChild)}function Xs(f){var E=f.parentNode;E&&E.lastChild!==f&&E.appendChild(f)}function Ga(f){var E=f.parentNode;E&&E.firstChild!==f&&E.insertBefore(f,E.firstChild)}function ss(f,E){if(void 0!==f.classList)return f.classList.contains(E);var D=ga(f);return D.length>0&&new RegExp("(^|\\s)"+E+"(\\s|$)").test(D)}function An(f,E){if(void 0!==f.classList)for(var D=G(E),j=0,mt=D.length;j<mt;j++)f.classList.add(D[j]);else if(!ss(f,E)){var Ft=ga(f);qn(f,(Ft?Ft+" ":"")+E)}}function jr(f,E){void 0!==f.classList?f.classList.remove(E):qn(f,Z((" "+ga(f)+" ").replace(" "+E+" "," ")))}function qn(f,E){void 0===f.className.baseVal?f.className=E:f.className.baseVal=E}function ga(f){return f.correspondingElement&&(f=f.correspondingElement),void 0===f.className.baseVal?f.className:f.className.baseVal}function nr(f,E){"opacity"in f.style?f.style.opacity=E:"filter"in f.style&&function bo(f,E){var D=!1,j="DXImageTransform.Microsoft.Alpha";try{D=f.filters.item(j)}catch{if(1===E)return}E=Math.round(100*E),D?(D.Enabled=100!==E,D.Opacity=E):f.style.filter+=" progid:"+j+"(opacity="+E+")"}(f,E)}function Yu(f){for(var E=document.documentElement.style,D=0;D<f.length;D++)if(f[D]in E)return f[D];return!1}function ya(f,E,D){var j=E||new yt(0,0);f.style[wo]=(Dn.ie3d?"translate("+j.x+"px,"+j.y+"px)":"translate3d("+j.x+"px,"+j.y+"px,0)")+(D?" scale("+D+")":"")}function Xn(f,E){f._leaflet_pos=E,Dn.any3d?ya(f,E):(f.style.left=E.x+"px",f.style.top=E.y+"px")}function Cs(f){return f._leaflet_pos||new yt(0,0)}if("onselectstart"in document)Yi=function(){Kn(window,"selectstart",_e)},La=function(){br(window,"selectstart",_e)};else{var ei=Yu(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);Yi=function(){if(ei){var f=document.documentElement.style;an=f[ei],f[ei]="none"}},La=function(){ei&&(document.documentElement.style[ei]=an,an=void 0)}}function Fn(){Kn(window,"dragstart",_e)}function Ds(){br(window,"dragstart",_e)}function Ur(f){for(;-1===f.tabIndex;)f=f.parentNode;f.style&&(We(),Io=f,ks=f.style.outlineStyle,f.style.outlineStyle="none",Kn(window,"keydown",We))}function We(){Io&&(Io.style.outlineStyle=ks,Io=void 0,ks=void 0,br(window,"keydown",We))}function Kr(f){do{f=f.parentNode}while(!(f.offsetWidth&&f.offsetHeight||f===document.body));return f}function mr(f){var E=f.getBoundingClientRect();return{x:E.width/f.offsetWidth||1,y:E.height/f.offsetHeight||1,boundingClientRect:E}}var ai={__proto__:null,TRANSFORM:wo,TRANSITION:ys,TRANSITION_END:Wa,get:bu,getStyle:Ra,create:$r,remove:pr,empty:fu,toFront:Xs,toBack:Ga,hasClass:ss,addClass:An,removeClass:jr,setClass:qn,getClass:ga,setOpacity:nr,testProp:Yu,setTransform:ya,setPosition:Xn,getPosition:Cs,get disableTextSelection(){return Yi},get enableTextSelection(){return La},disableImageDrag:Fn,enableImageDrag:Ds,preventOutline:Ur,restoreOutline:We,getSizedParentNode:Kr,getScale:mr};function Kn(f,E,D,j){if(E&&"object"==typeof E)for(var mt in E)os(f,mt,E[mt],D);else for(var Ft=0,ce=(E=G(E)).length;Ft<ce;Ft++)os(f,E[Ft],D,j);return this}var Pr="_leaflet_events";function br(f,E,D,j){if(1===arguments.length)Wr(f),delete f[Pr];else if(E&&"object"==typeof E)for(var mt in E)Iu(f,mt,E[mt],D);else if(E=G(E),2===arguments.length)Wr(f,function(ye){return-1!==dt(E,ye)});else for(var Ft=0,ce=E.length;Ft<ce;Ft++)Iu(f,E[Ft],D,j);return this}function Wr(f,E){for(var D in f[Pr]){var j=D.split(/\d/)[0];(!E||E(j))&&Iu(f,j,null,null,D)}}var Ts={mouseenter:"mouseover",mouseleave:"mouseout",wheel:!("onwheel"in window)&&"mousewheel"};function os(f,E,D,j){var mt=E+R(D)+(j?"_"+R(j):"");if(f[Pr]&&f[Pr][mt])return this;var Ft=function(ye){return D.call(j||f,ye||window.event)},ce=Ft;!Dn.touchNative&&Dn.pointer&&0===E.indexOf("touch")?Ft=ho(f,E,Ft):Dn.touch&&"dblclick"===E?Ft=function Oa(f,E){f.addEventListener("dblclick",E);var j,D=0;function mt(Ft){if(1===Ft.detail){if("mouse"!==Ft.pointerType&&(!Ft.sourceCapabilities||Ft.sourceCapabilities.firesTouchEvents)){var ce=I(Ft);if(!ce.some(function(Ve){return Ve instanceof HTMLLabelElement&&Ve.attributes.for})||ce.some(function(Ve){return Ve instanceof HTMLInputElement||Ve instanceof HTMLSelectElement})){var ye=Date.now();ye-D<=rs?2==++j&&E(function Pa(f){var D,j,E={};for(j in f)E[j]=(D=f[j])&&D.bind?D.bind(f):D;return f=E,E.type="dblclick",E.detail=2,E.isTrusted=!1,E._simulated=!0,E}(Ft)):j=1,D=ye}}}else j=Ft.detail}return f.addEventListener("click",mt),{dblclick:E,simDblclick:mt}}(f,Ft):"addEventListener"in f?"touchstart"===E||"touchmove"===E||"wheel"===E||"mousewheel"===E?f.addEventListener(Ts[E]||E,Ft,!!Dn.passiveEvents&&{passive:!1}):"mouseenter"===E||"mouseleave"===E?f.addEventListener(Ts[E],Ft=function(ye){ye=ye||window.event,At(f,ye)&&ce(ye)},!1):f.addEventListener(E,ce,!1):f.attachEvent("on"+E,Ft),f[Pr]=f[Pr]||{},f[Pr][mt]=Ft}function Iu(f,E,D,j,mt){mt=mt||E+R(D)+(j?"_"+R(j):"");var Ft=f[Pr]&&f[Pr][mt];if(!Ft)return this;!Dn.touchNative&&Dn.pointer&&0===E.indexOf("touch")?function Es(f,E,D){fi[E]?f.removeEventListener(fi[E],D,!1):console.warn("wrong event specified:",E)}(f,E,Ft):Dn.touch&&"dblclick"===E?function eo(f,E){f.removeEventListener("dblclick",E.dblclick),f.removeEventListener("click",E.simDblclick)}(f,Ft):"removeEventListener"in f?f.removeEventListener(Ts[E]||E,Ft,!1):f.detachEvent("on"+E,Ft),f[Pr][mt]=null}function $o(f){return f.stopPropagation?f.stopPropagation():f.originalEvent?f.originalEvent._stopped=!0:f.cancelBubble=!0,this}function Or(f){return os(f,"wheel",$o),this}function as(f){return Kn(f,"mousedown touchstart dblclick contextmenu",$o),f._leaflet_disable_click=!0,this}function _e(f){return f.preventDefault?f.preventDefault():f.returnValue=!1,this}function z(f){return _e(f),$o(f),this}function I(f){if(f.composedPath)return f.composedPath();for(var E=[],D=f.target;D;)E.push(D),D=D.parentNode;return E}function M(f,E){if(!E)return new yt(f.clientX,f.clientY);var D=mr(E),j=D.boundingClientRect;return new yt((f.clientX-j.left)/D.x-E.clientLeft,(f.clientY-j.top)/D.y-E.clientTop)}var tt=Dn.linux&&Dn.chrome?window.devicePixelRatio:Dn.mac?3*window.devicePixelRatio:window.devicePixelRatio>0?2*window.devicePixelRatio:1;function wt(f){return Dn.edge?f.wheelDeltaY/2:f.deltaY&&0===f.deltaMode?-f.deltaY/tt:f.deltaY&&1===f.deltaMode?20*-f.deltaY:f.deltaY&&2===f.deltaMode?60*-f.deltaY:f.deltaX||f.deltaZ?0:f.wheelDelta?(f.wheelDeltaY||f.wheelDelta)/2:f.detail&&Math.abs(f.detail)<32765?20*-f.detail:f.detail?f.detail/-32765*60:0}function At(f,E){var D=E.relatedTarget;if(!D)return!0;try{for(;D&&D!==f;)D=D.parentNode}catch{return!1}return D!==f}var Yt={__proto__:null,on:Kn,off:br,stopPropagation:$o,disableScrollPropagation:Or,disableClickPropagation:as,preventDefault:_e,stop:z,getPropagationPath:I,getMousePosition:M,getWheelDelta:wt,isExternalTarget:At,addListener:Kn,removeListener:br},kt=Ct.extend({run:function(f,E,D,j){this.stop(),this._el=f,this._inProgress=!0,this._duration=D||.25,this._easeOutPower=1/Math.max(j||.5,.2),this._startPos=Cs(f),this._offset=E.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(!0),this._complete())},_animate:function(){this._animId=ot(this._animate,this),this._step()},_step:function(f){var E=+new Date-this._startTime,D=1e3*this._duration;E<D?this._runFrame(this._easeOut(E/D),f):(this._runFrame(1),this._complete())},_runFrame:function(f,E){var D=this._startPos.add(this._offset.multiplyBy(f));E&&D._round(),Xn(this._el,D),this.fire("step")},_complete:function(){P(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(f){return 1-Math.pow(1-f,this._easeOutPower)}}),ae=Ct.extend({options:{crs:Tn,center:void 0,zoom:void 0,minZoom:void 0,maxZoom:void 0,layers:[],maxBounds:void 0,renderer:void 0,zoomAnimation:!0,zoomAnimationThreshold:4,fadeAnimation:!0,markerZoomAnimation:!0,transform3DLimit:8388608,zoomSnap:1,zoomDelta:1,trackResize:!0},initialize:function(f,E){E=it(this,E),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._sizeChanged=!0,this._initContainer(f),this._initLayout(),this._onResize=q(this._onResize,this),this._initEvents(),E.maxBounds&&this.setMaxBounds(E.maxBounds),void 0!==E.zoom&&(this._zoom=this._limitZoom(E.zoom)),E.center&&void 0!==E.zoom&&this.setView(jt(E.center),E.zoom,{reset:!0}),this.callInitHooks(),this._zoomAnimated=ys&&Dn.any3d&&!Dn.mobileOpera&&this.options.zoomAnimation,this._zoomAnimated&&(this._createAnimProxy(),Kn(this._proxy,Wa,this._catchTransitionEnd,this)),this._addLayers(this.options.layers)},setView:function(f,E,D){return E=void 0===E?this._zoom:this._limitZoom(E),f=this._limitCenter(jt(f),E,this.options.maxBounds),D=D||{},this._stop(),this._loaded&&!D.reset&&!0!==D&&(void 0!==D.animate&&(D.zoom=V({animate:D.animate},D.zoom),D.pan=V({animate:D.animate,duration:D.duration},D.pan)),this._zoom!==E?this._tryAnimatedZoom&&this._tryAnimatedZoom(f,E,D.zoom):this._tryAnimatedPan(f,D.pan))?(clearTimeout(this._sizeTimer),this):(this._resetView(f,E,D.pan&&D.pan.noMoveStart),this)},setZoom:function(f,E){return this._loaded?this.setView(this.getCenter(),f,{zoom:E}):(this._zoom=f,this)},zoomIn:function(f,E){return this.setZoom(this._zoom+(f=f||(Dn.any3d?this.options.zoomDelta:1)),E)},zoomOut:function(f,E){return this.setZoom(this._zoom-(f=f||(Dn.any3d?this.options.zoomDelta:1)),E)},setZoomAround:function(f,E,D){var j=this.getZoomScale(E),mt=this.getSize().divideBy(2),ce=(f instanceof yt?f:this.latLngToContainerPoint(f)).subtract(mt).multiplyBy(1-1/j),ye=this.containerPointToLatLng(mt.add(ce));return this.setView(ye,E,{zoom:D})},_getBoundsCenterZoom:function(f,E){E=E||{},f=f.getBounds?f.getBounds():Bt(f);var D=xt(E.paddingTopLeft||E.padding||[0,0]),j=xt(E.paddingBottomRight||E.padding||[0,0]),mt=this.getBoundsZoom(f,!1,D.add(j));if((mt="number"==typeof E.maxZoom?Math.min(E.maxZoom,mt):mt)===1/0)return{center:f.getCenter(),zoom:mt};var Ft=j.subtract(D).divideBy(2),ce=this.project(f.getSouthWest(),mt),ye=this.project(f.getNorthEast(),mt);return{center:this.unproject(ce.add(ye).divideBy(2).add(Ft),mt),zoom:mt}},fitBounds:function(f,E){if(!(f=Bt(f)).isValid())throw new Error("Bounds are not valid.");var D=this._getBoundsCenterZoom(f,E);return this.setView(D.center,D.zoom,E)},fitWorld:function(f){return this.fitBounds([[-90,-180],[90,180]],f)},panTo:function(f,E){return this.setView(f,this._zoom,{pan:E})},panBy:function(f,E){if(E=E||{},!(f=xt(f).round()).x&&!f.y)return this.fire("moveend");if(!0!==E.animate&&!this.getSize().contains(f))return this._resetView(this.unproject(this.project(this.getCenter()).add(f)),this.getZoom()),this;if(this._panAnim||(this._panAnim=new kt,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),E.noMoveStart||this.fire("movestart"),!1!==E.animate){An(this._mapPane,"leaflet-pan-anim");var D=this._getMapPanePos().subtract(f).round();this._panAnim.run(this._mapPane,D,E.duration||.25,E.easeLinearity)}else this._rawPanBy(f),this.fire("move").fire("moveend");return this},flyTo:function(f,E,D){if(!1===(D=D||{}).animate||!Dn.any3d)return this.setView(f,E,D);this._stop();var j=this.project(this.getCenter()),mt=this.project(f),Ft=this.getSize(),ce=this._zoom;f=jt(f),E=void 0===E?ce:E;var ye=Math.max(Ft.x,Ft.y),Ve=ye*this.getZoomScale(ce,E),sn=mt.distanceTo(j)||1,bn=1.42,Pn=bn*bn;function Nr(As){var l=(Ve*Ve-ye*ye+(As?-1:1)*Pn*Pn*sn*sn)/(2*(As?Ve:ye)*Pn*sn),h=Math.sqrt(l*l+1)-l;return h<1e-9?-18:Math.log(h)}function yo(As){return(Math.exp(As)-Math.exp(-As))/2}function Qi(As){return(Math.exp(As)+Math.exp(-As))/2}var jo=Nr(0);function fa(As){return ye*(Qi(jo)*function ro(As){return yo(As)/Qi(As)}(jo+bn*As)-yo(jo))/Pn}var ou=Date.now(),Lr=(Nr(1)-jo)/bn,Sl=D.duration?1e3*D.duration:1e3*Lr*.8;return this._moveStart(!0,D.noMoveStart),function Qs(){var As=(Date.now()-ou)/Sl,bs=function cr(As){return 1-Math.pow(1-As,1.5)}(As)*Lr;As<=1?(this._flyToFrame=ot(Qs,this),this._move(this.unproject(j.add(mt.subtract(j).multiplyBy(fa(bs)/sn)),ce),this.getScaleZoom(ye/function na(As){return ye*(Qi(jo)/Qi(jo+bn*As))}(bs),ce),{flyTo:!0})):this._move(f,E)._moveEnd(!0)}.call(this),this},flyToBounds:function(f,E){var D=this._getBoundsCenterZoom(f,E);return this.flyTo(D.center,D.zoom,E)},setMaxBounds:function(f){return f=Bt(f),this.listens("moveend",this._panInsideMaxBounds)&&this.off("moveend",this._panInsideMaxBounds),f.isValid()?(this.options.maxBounds=f,this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds)):(this.options.maxBounds=null,this)},setMinZoom:function(f){var E=this.options.minZoom;return this.options.minZoom=f,this._loaded&&E!==f&&(this.fire("zoomlevelschange"),this.getZoom()<this.options.minZoom)?this.setZoom(f):this},setMaxZoom:function(f){var E=this.options.maxZoom;return this.options.maxZoom=f,this._loaded&&E!==f&&(this.fire("zoomlevelschange"),this.getZoom()>this.options.maxZoom)?this.setZoom(f):this},panInsideBounds:function(f,E){this._enforcingBounds=!0;var D=this.getCenter(),j=this._limitCenter(D,this._zoom,Bt(f));return D.equals(j)||this.panTo(j,E),this._enforcingBounds=!1,this},panInside:function(f,E){var D=xt((E=E||{}).paddingTopLeft||E.padding||[0,0]),j=xt(E.paddingBottomRight||E.padding||[0,0]),mt=this.project(this.getCenter()),Ft=this.project(f),ce=this.getPixelBounds(),ye=It([ce.min.add(D),ce.max.subtract(j)]),Ve=ye.getSize();if(!ye.contains(Ft)){this._enforcingBounds=!0;var sn=Ft.subtract(ye.getCenter()),bn=ye.extend(Ft).getSize().subtract(Ve);mt.x+=sn.x<0?-bn.x:bn.x,mt.y+=sn.y<0?-bn.y:bn.y,this.panTo(this.unproject(mt),E),this._enforcingBounds=!1}return this},invalidateSize:function(f){if(!this._loaded)return this;f=V({animate:!1,pan:!0},!0===f?{animate:!0}:f);var E=this.getSize();this._sizeChanged=!0,this._lastCenter=null;var D=this.getSize(),j=E.divideBy(2).round(),mt=D.divideBy(2).round(),Ft=j.subtract(mt);return Ft.x||Ft.y?(f.animate&&f.pan?this.panBy(Ft):(f.pan&&this._rawPanBy(Ft),this.fire("move"),f.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(q(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:E,newSize:D})):this},stop:function(){return this.setZoom(this._limitZoom(this._zoom)),this.options.zoomSnap||this.fire("viewreset"),this._stop()},locate:function(f){if(f=this._locateOptions=V({timeout:1e4,watch:!1},f),!("geolocation"in navigator))return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var E=q(this._handleGeolocationResponse,this),D=q(this._handleGeolocationError,this);return f.watch?this._locationWatchId=navigator.geolocation.watchPosition(E,D,f):navigator.geolocation.getCurrentPosition(E,D,f),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(f){if(this._container._leaflet_id){var E=f.code,D=f.message||(1===E?"permission denied":2===E?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:E,message:"Geolocation error: "+D+"."})}},_handleGeolocationResponse:function(f){if(this._container._leaflet_id){var j=new ee(f.coords.latitude,f.coords.longitude),mt=j.toBounds(2*f.coords.accuracy),Ft=this._locateOptions;if(Ft.setView){var ce=this.getBoundsZoom(mt);this.setView(j,Ft.maxZoom?Math.min(ce,Ft.maxZoom):ce)}var ye={latlng:j,bounds:mt,timestamp:f.timestamp};for(var Ve in f.coords)"number"==typeof f.coords[Ve]&&(ye[Ve]=f.coords[Ve]);this.fire("locationfound",ye)}},addHandler:function(f,E){if(!E)return this;var D=this[f]=new E(this);return this._handlers.push(D),this.options[f]&&D.enable(),this},remove:function(){if(this._initEvents(!0),this.options.maxBounds&&this.off("moveend",this._panInsideMaxBounds),this._containerId!==this._container._leaflet_id)throw new Error("Map container is being reused by another instance");try{delete this._container._leaflet_id,delete this._containerId}catch{this._container._leaflet_id=void 0,this._containerId=void 0}var f;for(f in void 0!==this._locationWatchId&&this.stopLocate(),this._stop(),pr(this._mapPane),this._clearControlPos&&this._clearControlPos(),this._resizeRequest&&(P(this._resizeRequest),this._resizeRequest=null),this._clearHandlers(),this._loaded&&this.fire("unload"),this._layers)this._layers[f].remove();for(f in this._panes)pr(this._panes[f]);return this._layers=[],this._panes=[],delete this._mapPane,delete this._renderer,this},createPane:function(f,E){var j=$r("div","leaflet-pane"+(f?" leaflet-"+f.replace("Pane","")+"-pane":""),E||this._mapPane);return f&&(this._panes[f]=j),j},getCenter:function(){return this._checkIfLoaded(),this._lastCenter&&!this._moved()?this._lastCenter.clone():this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var f=this.getPixelBounds();return new re(this.unproject(f.getBottomLeft()),this.unproject(f.getTopRight()))},getMinZoom:function(){return void 0===this.options.minZoom?this._layersMinZoom||0:this.options.minZoom},getMaxZoom:function(){return void 0===this.options.maxZoom?void 0===this._layersMaxZoom?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(f,E,D){f=Bt(f),D=xt(D||[0,0]);var j=this.getZoom()||0,mt=this.getMinZoom(),Ft=this.getMaxZoom(),ce=f.getNorthWest(),ye=f.getSouthEast(),Ve=this.getSize().subtract(D),sn=It(this.project(ye,j),this.project(ce,j)).getSize(),bn=Dn.any3d?this.options.zoomSnap:1,Pn=Ve.x/sn.x,Nr=Ve.y/sn.y,yo=E?Math.max(Pn,Nr):Math.min(Pn,Nr);return j=this.getScaleZoom(yo,j),bn&&(j=Math.round(j/(bn/100))*(bn/100),j=E?Math.ceil(j/bn)*bn:Math.floor(j/bn)*bn),Math.max(mt,Math.min(Ft,j))},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new yt(this._container.clientWidth||0,this._container.clientHeight||0),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(f,E){var D=this._getTopLeftPoint(f,E);return new Mt(D,D.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._pixelOrigin},getPixelWorldBounds:function(f){return this.options.crs.getProjectedBounds(void 0===f?this.getZoom():f)},getPane:function(f){return"string"==typeof f?this._panes[f]:f},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(f,E){var D=this.options.crs;return E=void 0===E?this._zoom:E,D.scale(f)/D.scale(E)},getScaleZoom:function(f,E){var D=this.options.crs,j=D.zoom(f*D.scale(E=void 0===E?this._zoom:E));return isNaN(j)?1/0:j},project:function(f,E){return E=void 0===E?this._zoom:E,this.options.crs.latLngToPoint(jt(f),E)},unproject:function(f,E){return E=void 0===E?this._zoom:E,this.options.crs.pointToLatLng(xt(f),E)},layerPointToLatLng:function(f){var E=xt(f).add(this.getPixelOrigin());return this.unproject(E)},latLngToLayerPoint:function(f){return this.project(jt(f))._round()._subtract(this.getPixelOrigin())},wrapLatLng:function(f){return this.options.crs.wrapLatLng(jt(f))},wrapLatLngBounds:function(f){return this.options.crs.wrapLatLngBounds(Bt(f))},distance:function(f,E){return this.options.crs.distance(jt(f),jt(E))},containerPointToLayerPoint:function(f){return xt(f).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(f){return xt(f).add(this._getMapPanePos())},containerPointToLatLng:function(f){var E=this.containerPointToLayerPoint(xt(f));return this.layerPointToLatLng(E)},latLngToContainerPoint:function(f){return this.layerPointToContainerPoint(this.latLngToLayerPoint(jt(f)))},mouseEventToContainerPoint:function(f){return M(f,this._container)},mouseEventToLayerPoint:function(f){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(f))},mouseEventToLatLng:function(f){return this.layerPointToLatLng(this.mouseEventToLayerPoint(f))},_initContainer:function(f){var E=this._container=bu(f);if(!E)throw new Error("Map container not found.");if(E._leaflet_id)throw new Error("Map container is already initialized.");Kn(E,"scroll",this._onScroll,this),this._containerId=R(E)},_initLayout:function(){var f=this._container;this._fadeAnimated=this.options.fadeAnimation&&Dn.any3d,An(f,"leaflet-container"+(Dn.touch?" leaflet-touch":"")+(Dn.retina?" leaflet-retina":"")+(Dn.ielt9?" leaflet-oldie":"")+(Dn.safari?" leaflet-safari":"")+(this._fadeAnimated?" leaflet-fade-anim":""));var E=Ra(f,"position");"absolute"!==E&&"relative"!==E&&"fixed"!==E&&"sticky"!==E&&(f.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var f=this._panes={};this._paneRenderers={},this._mapPane=this.createPane("mapPane",this._container),Xn(this._mapPane,new yt(0,0)),this.createPane("tilePane"),this.createPane("overlayPane"),this.createPane("shadowPane"),this.createPane("markerPane"),this.createPane("tooltipPane"),this.createPane("popupPane"),this.options.markerZoomAnimation||(An(f.markerPane,"leaflet-zoom-hide"),An(f.shadowPane,"leaflet-zoom-hide"))},_resetView:function(f,E,D){Xn(this._mapPane,new yt(0,0));var j=!this._loaded;this._loaded=!0,E=this._limitZoom(E),this.fire("viewprereset");var mt=this._zoom!==E;this._moveStart(mt,D)._move(f,E)._moveEnd(mt),this.fire("viewreset"),j&&this.fire("load")},_moveStart:function(f,E){return f&&this.fire("zoomstart"),E||this.fire("movestart"),this},_move:function(f,E,D,j){void 0===E&&(E=this._zoom);var mt=this._zoom!==E;return this._zoom=E,this._lastCenter=f,this._pixelOrigin=this._getNewPixelOrigin(f),j?D&&D.pinch&&this.fire("zoom",D):((mt||D&&D.pinch)&&this.fire("zoom",D),this.fire("move",D)),this},_moveEnd:function(f){return f&&this.fire("zoomend"),this.fire("moveend")},_stop:function(){return P(this._flyToFrame),this._panAnim&&this._panAnim.stop(),this},_rawPanBy:function(f){Xn(this._mapPane,this._getMapPanePos().subtract(f))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_panInsideMaxBounds:function(){this._enforcingBounds||this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(f){this._targets={},this._targets[R(this._container)]=this;var E=f?br:Kn;E(this._container,"click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup",this._handleDOMEvent,this),this.options.trackResize&&E(window,"resize",this._onResize,this),Dn.any3d&&this.options.transform3DLimit&&(f?this.off:this.on).call(this,"moveend",this._onMoveEnd)},_onResize:function(){P(this._resizeRequest),this._resizeRequest=ot(function(){this.invalidateSize({debounceMoveend:!0})},this)},_onScroll:function(){this._container.scrollTop=0,this._container.scrollLeft=0},_onMoveEnd:function(){var f=this._getMapPanePos();Math.max(Math.abs(f.x),Math.abs(f.y))>=this.options.transform3DLimit&&this._resetView(this.getCenter(),this.getZoom())},_findEventTargets:function(f,E){for(var j,D=[],mt="mouseout"===E||"mouseover"===E,Ft=f.target||f.srcElement,ce=!1;Ft;){if((j=this._targets[R(Ft)])&&("click"===E||"preclick"===E)&&this._draggableMoved(j)){ce=!0;break}if(j&&j.listens(E,!0)&&(mt&&!At(Ft,f)||(D.push(j),mt))||Ft===this._container)break;Ft=Ft.parentNode}return!D.length&&!ce&&!mt&&this.listens(E,!0)&&(D=[this]),D},_isClickDisabled:function(f){for(;f&&f!==this._container;){if(f._leaflet_disable_click)return!0;f=f.parentNode}},_handleDOMEvent:function(f){var E=f.target||f.srcElement;if(!(!this._loaded||E._leaflet_disable_events||"click"===f.type&&this._isClickDisabled(E))){var D=f.type;"mousedown"===D&&Ur(E),this._fireDOMEvent(f,D)}},_mouseEvents:["click","dblclick","mouseover","mouseout","contextmenu"],_fireDOMEvent:function(f,E,D){if("click"===f.type){var j=V({},f);j.type="preclick",this._fireDOMEvent(j,j.type,D)}var mt=this._findEventTargets(f,E);if(D){for(var Ft=[],ce=0;ce<D.length;ce++)D[ce].listens(E,!0)&&Ft.push(D[ce]);mt=Ft.concat(mt)}if(mt.length){"contextmenu"===E&&_e(f);var ye=mt[0],Ve={originalEvent:f};if("keypress"!==f.type&&"keydown"!==f.type&&"keyup"!==f.type){var sn=ye.getLatLng&&(!ye._radius||ye._radius<=10);Ve.containerPoint=sn?this.latLngToContainerPoint(ye.getLatLng()):this.mouseEventToContainerPoint(f),Ve.layerPoint=this.containerPointToLayerPoint(Ve.containerPoint),Ve.latlng=sn?ye.getLatLng():this.layerPointToLatLng(Ve.layerPoint)}for(ce=0;ce<mt.length;ce++)if(mt[ce].fire(E,Ve,!0),Ve.originalEvent._stopped||!1===mt[ce].options.bubblingMouseEvents&&-1!==dt(this._mouseEvents,E))return}},_draggableMoved:function(f){return(f=f.dragging&&f.dragging.enabled()?f:this).dragging&&f.dragging.moved()||this.boxZoom&&this.boxZoom.moved()},_clearHandlers:function(){for(var f=0,E=this._handlers.length;f<E;f++)this._handlers[f].disable()},whenReady:function(f,E){return this._loaded?f.call(E||this,{target:this}):this.on("load",f,E),this},_getMapPanePos:function(){return Cs(this._mapPane)||new yt(0,0)},_moved:function(){var f=this._getMapPanePos();return f&&!f.equals([0,0])},_getTopLeftPoint:function(f,E){return(f&&void 0!==E?this._getNewPixelOrigin(f,E):this.getPixelOrigin()).subtract(this._getMapPanePos())},_getNewPixelOrigin:function(f,E){var D=this.getSize()._divideBy(2);return this.project(f,E)._subtract(D)._add(this._getMapPanePos())._round()},_latLngToNewLayerPoint:function(f,E,D){var j=this._getNewPixelOrigin(D,E);return this.project(f,E)._subtract(j)},_latLngBoundsToNewLayerBounds:function(f,E,D){var j=this._getNewPixelOrigin(D,E);return It([this.project(f.getSouthWest(),E)._subtract(j),this.project(f.getNorthWest(),E)._subtract(j),this.project(f.getSouthEast(),E)._subtract(j),this.project(f.getNorthEast(),E)._subtract(j)])},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(f){return this.latLngToLayerPoint(f).subtract(this._getCenterLayerPoint())},_limitCenter:function(f,E,D){if(!D)return f;var j=this.project(f,E),mt=this.getSize().divideBy(2),Ft=new Mt(j.subtract(mt),j.add(mt)),ce=this._getBoundsOffset(Ft,D,E);return Math.abs(ce.x)<=1&&Math.abs(ce.y)<=1?f:this.unproject(j.add(ce),E)},_limitOffset:function(f,E){if(!E)return f;var D=this.getPixelBounds(),j=new Mt(D.min.add(f),D.max.add(f));return f.add(this._getBoundsOffset(j,E))},_getBoundsOffset:function(f,E,D){var j=It(this.project(E.getNorthEast(),D),this.project(E.getSouthWest(),D)),mt=j.min.subtract(f.min),Ft=j.max.subtract(f.max);return new yt(this._rebound(mt.x,-Ft.x),this._rebound(mt.y,-Ft.y))},_rebound:function(f,E){return f+E>0?Math.round(f-E)/2:Math.max(0,Math.ceil(f))-Math.max(0,Math.floor(E))},_limitZoom:function(f){var E=this.getMinZoom(),D=this.getMaxZoom(),j=Dn.any3d?this.options.zoomSnap:1;return j&&(f=Math.round(f/j)*j),Math.max(E,Math.min(D,f))},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){jr(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(f,E){var D=this._getCenterOffset(f)._trunc();return!(!0!==(E&&E.animate)&&!this.getSize().contains(D)||(this.panBy(D,E),0))},_createAnimProxy:function(){var f=this._proxy=$r("div","leaflet-proxy leaflet-zoom-animated");this._panes.mapPane.appendChild(f),this.on("zoomanim",function(E){var D=wo,j=this._proxy.style[D];ya(this._proxy,this.project(E.center,E.zoom),this.getZoomScale(E.zoom,1)),j===this._proxy.style[D]&&this._animatingZoom&&this._onZoomTransitionEnd()},this),this.on("load moveend",this._animMoveEnd,this),this._on("unload",this._destroyAnimProxy,this)},_destroyAnimProxy:function(){pr(this._proxy),this.off("load moveend",this._animMoveEnd,this),delete this._proxy},_animMoveEnd:function(){var f=this.getCenter(),E=this.getZoom();ya(this._proxy,this.project(f,E),this.getZoomScale(E,1))},_catchTransitionEnd:function(f){this._animatingZoom&&f.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(f,E,D){if(this._animatingZoom)return!0;if(D=D||{},!this._zoomAnimated||!1===D.animate||this._nothingToAnimate()||Math.abs(E-this._zoom)>this.options.zoomAnimationThreshold)return!1;var j=this.getZoomScale(E),mt=this._getCenterOffset(f)._divideBy(1-1/j);return!(!0!==D.animate&&!this.getSize().contains(mt)||(ot(function(){this._moveStart(!0,D.noMoveStart||!1)._animateZoom(f,E,!0)},this),0))},_animateZoom:function(f,E,D,j){this._mapPane&&(D&&(this._animatingZoom=!0,this._animateToCenter=f,this._animateToZoom=E,An(this._mapPane,"leaflet-zoom-anim")),this.fire("zoomanim",{center:f,zoom:E,noUpdate:j}),this._tempFireZoomEvent||(this._tempFireZoomEvent=this._zoom!==this._animateToZoom),this._move(this._animateToCenter,this._animateToZoom,void 0,!0),setTimeout(q(this._onZoomTransitionEnd,this),250))},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._mapPane&&jr(this._mapPane,"leaflet-zoom-anim"),this._animatingZoom=!1,this._move(this._animateToCenter,this._animateToZoom,void 0,!0),this._tempFireZoomEvent&&this.fire("zoom"),delete this._tempFireZoomEvent,this.fire("move"),this._moveEnd(!0))}});var Ye=nt.extend({options:{position:"topright"},initialize:function(f){it(this,f)},getPosition:function(){return this.options.position},setPosition:function(f){var E=this._map;return E&&E.removeControl(this),this.options.position=f,E&&E.addControl(this),this},getContainer:function(){return this._container},addTo:function(f){this.remove(),this._map=f;var E=this._container=this.onAdd(f),D=this.getPosition(),j=f._controlCorners[D];return An(E,"leaflet-control"),-1!==D.indexOf("bottom")?j.insertBefore(E,j.firstChild):j.appendChild(E),this._map.on("unload",this.remove,this),this},remove:function(){return this._map?(pr(this._container),this.onRemove&&this.onRemove(this._map),this._map.off("unload",this.remove,this),this._map=null,this):this},_refocusOnMap:function(f){this._map&&f&&f.screenX>0&&f.screenY>0&&this._map.getContainer().focus()}}),$e=function(f){return new Ye(f)};ae.include({addControl:function(f){return f.addTo(this),this},removeControl:function(f){return f.remove(),this},_initControlPos:function(){var f=this._controlCorners={},E="leaflet-",D=this._controlContainer=$r("div",E+"control-container",this._container);function j(mt,Ft){f[mt+Ft]=$r("div",E+mt+" "+E+Ft,D)}j("top","left"),j("top","right"),j("bottom","left"),j("bottom","right")},_clearControlPos:function(){for(var f in this._controlCorners)pr(this._controlCorners[f]);pr(this._controlContainer),delete this._controlCorners,delete this._controlContainer}});var Cn=Ye.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0,hideSingleBase:!1,sortLayers:!1,sortFunction:function(f,E,D,j){return D<j?-1:j<D?1:0}},initialize:function(f,E,D){for(var j in it(this,D),this._layerControlInputs=[],this._layers=[],this._lastZIndex=0,this._handlingClick=!1,this._preventClick=!1,f)this._addLayer(f[j],j);for(j in E)this._addLayer(E[j],j,!0)},onAdd:function(f){this._initLayout(),this._update(),this._map=f,f.on("zoomend",this._checkDisabledLayers,this);for(var E=0;E<this._layers.length;E++)this._layers[E].layer.on("add remove",this._onLayerChange,this);return this._container},addTo:function(f){return Ye.prototype.addTo.call(this,f),this._expandIfNotCollapsed()},onRemove:function(){this._map.off("zoomend",this._checkDisabledLayers,this);for(var f=0;f<this._layers.length;f++)this._layers[f].layer.off("add remove",this._onLayerChange,this)},addBaseLayer:function(f,E){return this._addLayer(f,E),this._map?this._update():this},addOverlay:function(f,E){return this._addLayer(f,E,!0),this._map?this._update():this},removeLayer:function(f){f.off("add remove",this._onLayerChange,this);var E=this._getLayer(R(f));return E&&this._layers.splice(this._layers.indexOf(E),1),this._map?this._update():this},expand:function(){An(this._container,"leaflet-control-layers-expanded"),this._section.style.height=null;var f=this._map.getSize().y-(this._container.offsetTop+50);return f<this._section.clientHeight?(An(this._section,"leaflet-control-layers-scrollbar"),this._section.style.height=f+"px"):jr(this._section,"leaflet-control-layers-scrollbar"),this._checkDisabledLayers(),this},collapse:function(){return jr(this._container,"leaflet-control-layers-expanded"),this},_initLayout:function(){var f="leaflet-control-layers",E=this._container=$r("div",f),D=this.options.collapsed;E.setAttribute("aria-haspopup",!0),as(E),Or(E);var j=this._section=$r("section",f+"-list");D&&(this._map.on("click",this.collapse,this),Kn(E,{mouseenter:this._expandSafely,mouseleave:this.collapse},this));var mt=this._layersLink=$r("a",f+"-toggle",E);mt.href="#",mt.title="Layers",mt.setAttribute("role","button"),Kn(mt,{keydown:function(Ft){13===Ft.keyCode&&this._expandSafely()},click:function(Ft){_e(Ft),this._expandSafely()}},this),D||this.expand(),this._baseLayersList=$r("div",f+"-base",j),this._separator=$r("div",f+"-separator",j),this._overlaysList=$r("div",f+"-overlays",j),E.appendChild(j)},_getLayer:function(f){for(var E=0;E<this._layers.length;E++)if(this._layers[E]&&R(this._layers[E].layer)===f)return this._layers[E]},_addLayer:function(f,E,D){this._map&&f.on("add remove",this._onLayerChange,this),this._layers.push({layer:f,name:E,overlay:D}),this.options.sortLayers&&this._layers.sort(q(function(j,mt){return this.options.sortFunction(j.layer,mt.layer,j.name,mt.name)},this)),this.options.autoZIndex&&f.setZIndex&&(this._lastZIndex++,f.setZIndex(this._lastZIndex)),this._expandIfNotCollapsed()},_update:function(){if(!this._container)return this;fu(this._baseLayersList),fu(this._overlaysList),this._layerControlInputs=[];var f,E,D,j,mt=0;for(D=0;D<this._layers.length;D++)this._addItem(j=this._layers[D]),E=E||j.overlay,f=f||!j.overlay,mt+=j.overlay?0:1;return this.options.hideSingleBase&&(this._baseLayersList.style.display=(f=f&&mt>1)?"":"none"),this._separator.style.display=E&&f?"":"none",this},_onLayerChange:function(f){this._handlingClick||this._update();var E=this._getLayer(R(f.target)),D=E.overlay?"add"===f.type?"overlayadd":"overlayremove":"add"===f.type?"baselayerchange":null;D&&this._map.fire(D,E)},_createRadioElement:function(f,E){var D='<input type="radio" class="leaflet-control-layers-selector" name="'+f+'"'+(E?' checked="checked"':"")+"/>",j=document.createElement("div");return j.innerHTML=D,j.firstChild},_addItem:function(f){var j,E=document.createElement("label"),D=this._map.hasLayer(f.layer);f.overlay?((j=document.createElement("input")).type="checkbox",j.className="leaflet-control-layers-selector",j.defaultChecked=D):j=this._createRadioElement("leaflet-base-layers_"+R(this),D),this._layerControlInputs.push(j),j.layerId=R(f.layer),Kn(j,"click",this._onInputClick,this);var mt=document.createElement("span");mt.innerHTML=" "+f.name;var Ft=document.createElement("span");return E.appendChild(Ft),Ft.appendChild(j),Ft.appendChild(mt),(f.overlay?this._overlaysList:this._baseLayersList).appendChild(E),this._checkDisabledLayers(),E},_onInputClick:function(){if(!this._preventClick){var E,D,f=this._layerControlInputs,j=[],mt=[];this._handlingClick=!0;for(var Ft=f.length-1;Ft>=0;Ft--)D=this._getLayer((E=f[Ft]).layerId).layer,E.checked?j.push(D):E.checked||mt.push(D);for(Ft=0;Ft<mt.length;Ft++)this._map.hasLayer(mt[Ft])&&this._map.removeLayer(mt[Ft]);for(Ft=0;Ft<j.length;Ft++)this._map.hasLayer(j[Ft])||this._map.addLayer(j[Ft]);this._handlingClick=!1,this._refocusOnMap()}},_checkDisabledLayers:function(){for(var E,D,f=this._layerControlInputs,j=this._map.getZoom(),mt=f.length-1;mt>=0;mt--)D=this._getLayer((E=f[mt]).layerId).layer,E.disabled=void 0!==D.options.minZoom&&j<D.options.minZoom||void 0!==D.options.maxZoom&&j>D.options.maxZoom},_expandIfNotCollapsed:function(){return this._map&&!this.options.collapsed&&this.expand(),this},_expandSafely:function(){var f=this._section;this._preventClick=!0,Kn(f,"click",_e),this.expand();var E=this;setTimeout(function(){br(f,"click",_e),E._preventClick=!1})}}),Vn=Ye.extend({options:{position:"topleft",zoomInText:'<span aria-hidden="true">+</span>',zoomInTitle:"Zoom in",zoomOutText:'<span aria-hidden="true">&#x2212;</span>',zoomOutTitle:"Zoom out"},onAdd:function(f){var E="leaflet-control-zoom",D=$r("div",E+" leaflet-bar"),j=this.options;return this._zoomInButton=this._createButton(j.zoomInText,j.zoomInTitle,E+"-in",D,this._zoomIn),this._zoomOutButton=this._createButton(j.zoomOutText,j.zoomOutTitle,E+"-out",D,this._zoomOut),this._updateDisabled(),f.on("zoomend zoomlevelschange",this._updateDisabled,this),D},onRemove:function(f){f.off("zoomend zoomlevelschange",this._updateDisabled,this)},disable:function(){return this._disabled=!0,this._updateDisabled(),this},enable:function(){return this._disabled=!1,this._updateDisabled(),this},_zoomIn:function(f){!this._disabled&&this._map._zoom<this._map.getMaxZoom()&&this._map.zoomIn(this._map.options.zoomDelta*(f.shiftKey?3:1))},_zoomOut:function(f){!this._disabled&&this._map._zoom>this._map.getMinZoom()&&this._map.zoomOut(this._map.options.zoomDelta*(f.shiftKey?3:1))},_createButton:function(f,E,D,j,mt){var Ft=$r("a",D,j);return Ft.innerHTML=f,Ft.href="#",Ft.title=E,Ft.setAttribute("role","button"),Ft.setAttribute("aria-label",E),as(Ft),Kn(Ft,"click",z),Kn(Ft,"click",mt,this),Kn(Ft,"click",this._refocusOnMap,this),Ft},_updateDisabled:function(){var f=this._map,E="leaflet-disabled";jr(this._zoomInButton,E),jr(this._zoomOutButton,E),this._zoomInButton.setAttribute("aria-disabled","false"),this._zoomOutButton.setAttribute("aria-disabled","false"),(this._disabled||f._zoom===f.getMinZoom())&&(An(this._zoomOutButton,E),this._zoomOutButton.setAttribute("aria-disabled","true")),(this._disabled||f._zoom===f.getMaxZoom())&&(An(this._zoomInButton,E),this._zoomInButton.setAttribute("aria-disabled","true"))}});ae.mergeOptions({zoomControl:!0}),ae.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new Vn,this.addControl(this.zoomControl))});var wn=Ye.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0},onAdd:function(f){var E="leaflet-control-scale",D=$r("div",E),j=this.options;return this._addScales(j,E+"-line",D),f.on(j.updateWhenIdle?"moveend":"move",this._update,this),f.whenReady(this._update,this),D},onRemove:function(f){f.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(f,E,D){f.metric&&(this._mScale=$r("div",E,D)),f.imperial&&(this._iScale=$r("div",E,D))},_update:function(){var f=this._map,E=f.getSize().y/2,D=f.distance(f.containerPointToLatLng([0,E]),f.containerPointToLatLng([this.options.maxWidth,E]));this._updateScales(D)},_updateScales:function(f){this.options.metric&&f&&this._updateMetric(f),this.options.imperial&&f&&this._updateImperial(f)},_updateMetric:function(f){var E=this._getRoundNum(f);this._updateScale(this._mScale,E<1e3?E+" m":E/1e3+" km",E/f)},_updateImperial:function(f){var D,j,mt,E=3.2808399*f;E>5280?(j=this._getRoundNum(D=E/5280),this._updateScale(this._iScale,j+" mi",j/D)):(mt=this._getRoundNum(E),this._updateScale(this._iScale,mt+" ft",mt/E))},_updateScale:function(f,E,D){f.style.width=Math.round(this.options.maxWidth*D)+"px",f.innerHTML=E},_getRoundNum:function(f){var E=Math.pow(10,(Math.floor(f)+"").length-1),D=f/E;return E*(D>=10?10:D>=5?5:D>=3?3:D>=2?2:1)}}),Zs=Ye.extend({options:{position:"bottomright",prefix:'<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">'+(Dn.inlineSvg?'<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg> ':"")+"Leaflet</a>"},initialize:function(f){it(this,f),this._attributions={}},onAdd:function(f){for(var E in f.attributionControl=this,this._container=$r("div","leaflet-control-attribution"),as(this._container),f._layers)f._layers[E].getAttribution&&this.addAttribution(f._layers[E].getAttribution());return this._update(),f.on("layeradd",this._addAttribution,this),this._container},onRemove:function(f){f.off("layeradd",this._addAttribution,this)},_addAttribution:function(f){f.layer.getAttribution&&(this.addAttribution(f.layer.getAttribution()),f.layer.once("remove",function(){this.removeAttribution(f.layer.getAttribution())},this))},setPrefix:function(f){return this.options.prefix=f,this._update(),this},addAttribution:function(f){return f?(this._attributions[f]||(this._attributions[f]=0),this._attributions[f]++,this._update(),this):this},removeAttribution:function(f){return f?(this._attributions[f]&&(this._attributions[f]--,this._update()),this):this},_update:function(){if(this._map){var f=[];for(var E in this._attributions)this._attributions[E]&&f.push(E);var D=[];this.options.prefix&&D.push(this.options.prefix),f.length&&D.push(f.join(", ")),this._container.innerHTML=D.join(' <span aria-hidden="true">|</span> ')}}});ae.mergeOptions({attributionControl:!0}),ae.addInitHook(function(){this.options.attributionControl&&(new Zs).addTo(this)});Ye.Layers=Cn,Ye.Zoom=Vn,Ye.Scale=wn,Ye.Attribution=Zs,$e.layers=function(f,E,D){return new Cn(f,E,D)},$e.zoom=function(f){return new Vn(f)},$e.scale=function(f){return new wn(f)},$e.attribution=function(f){return new Zs(f)};var tn=nt.extend({initialize:function(f){this._map=f},enable:function(){return this._enabled||(this._enabled=!0,this.addHooks()),this},disable:function(){return this._enabled?(this._enabled=!1,this.removeHooks(),this):this},enabled:function(){return!!this._enabled}});tn.addTo=function(f,E){return f.addHandler(E,this),this};var Su={Events:O},xr=Dn.touch?"touchstart mousedown":"mousedown",qi=Ct.extend({options:{clickTolerance:3},initialize:function(f,E,D,j){it(this,j),this._element=f,this._dragStartTarget=E||f,this._preventOutline=D},enable:function(){this._enabled||(Kn(this._dragStartTarget,xr,this._onDown,this),this._enabled=!0)},disable:function(){this._enabled&&(qi._dragging===this&&this.finishDrag(!0),br(this._dragStartTarget,xr,this._onDown,this),this._enabled=!1,this._moved=!1)},_onDown:function(f){if(this._enabled&&(this._moved=!1,!ss(this._element,"leaflet-zoom-anim"))){if(f.touches&&1!==f.touches.length)return void(qi._dragging===this&&this.finishDrag());if(!(qi._dragging||f.shiftKey||1!==f.which&&1!==f.button&&!f.touches||(qi._dragging=this,this._preventOutline&&Ur(this._element),Fn(),Yi(),this._moving))){this.fire("down");var E=f.touches?f.touches[0]:f,D=Kr(this._element);this._startPoint=new yt(E.clientX,E.clientY),this._startPos=Cs(this._element),this._parentScale=mr(D);var j="mousedown"===f.type;Kn(document,j?"mousemove":"touchmove",this._onMove,this),Kn(document,j?"mouseup":"touchend touchcancel",this._onUp,this)}}},_onMove:function(f){if(this._enabled){if(f.touches&&f.touches.length>1)return void(this._moved=!0);var E=f.touches&&1===f.touches.length?f.touches[0]:f,D=new yt(E.clientX,E.clientY)._subtract(this._startPoint);!D.x&&!D.y||Math.abs(D.x)+Math.abs(D.y)<this.options.clickTolerance||(D.x/=this._parentScale.x,D.y/=this._parentScale.y,_e(f),this._moved||(this.fire("dragstart"),this._moved=!0,An(document.body,"leaflet-dragging"),this._lastTarget=f.target||f.srcElement,window.SVGElementInstance&&this._lastTarget instanceof window.SVGElementInstance&&(this._lastTarget=this._lastTarget.correspondingUseElement),An(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(D),this._moving=!0,this._lastEvent=f,this._updatePosition())}},_updatePosition:function(){var f={originalEvent:this._lastEvent};this.fire("predrag",f),Xn(this._element,this._newPos),this.fire("drag",f)},_onUp:function(){this._enabled&&this.finishDrag()},finishDrag:function(f){jr(document.body,"leaflet-dragging"),this._lastTarget&&(jr(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null),br(document,"mousemove touchmove",this._onMove,this),br(document,"mouseup touchend touchcancel",this._onUp,this),Ds(),La();var E=this._moved&&this._moving;this._moving=!1,qi._dragging=!1,E&&this.fire("dragend",{noInertia:f,distance:this._newPos.distanceTo(this._startPos)})}});function fo(f,E,D){var j,Ft,ce,ye,Ve,sn,bn,Pn,Nr,mt=[1,4,2,8];for(Ft=0,bn=f.length;Ft<bn;Ft++)f[Ft]._code=Gr(f[Ft],E);for(ye=0;ye<4;ye++){for(Pn=mt[ye],j=[],Ft=0,ce=(bn=f.length)-1;Ft<bn;ce=Ft++)sn=f[ce],(Ve=f[Ft])._code&Pn?sn._code&Pn||((Nr=mu(sn,Ve,Pn,E,D))._code=Gr(Nr,E),j.push(Nr)):(sn._code&Pn&&((Nr=mu(sn,Ve,Pn,E,D))._code=Gr(Nr,E),j.push(Nr)),j.push(Ve));f=j}return f}function vs(f,E){var D,j,mt,Ft,ce,ye,Ve,sn;if(!f||0===f.length)throw new Error("latlngs not passed");zo(f)||(console.warn("latlngs are not flat! Only the first ring will be used"),f=f[0]);var Pn=jt([0,0]),Nr=Bt(f);Nr.getNorthWest().distanceTo(Nr.getSouthWest())*Nr.getNorthEast().distanceTo(Nr.getNorthWest())<1700&&(Pn=ku(f));var Qi=f.length,ro=[];for(D=0;D<Qi;D++){var jo=jt(f[D]);ro.push(E.project(jt([jo.lat-Pn.lat,jo.lng-Pn.lng])))}for(ye=Ve=sn=0,D=0,j=Qi-1;D<Qi;j=D++)Ve+=((mt=ro[D]).x+(Ft=ro[j]).x)*(ce=mt.y*Ft.x-Ft.y*mt.x),sn+=(mt.y+Ft.y)*ce,ye+=3*ce;var na=E.unproject(xt(0===ye?ro[0]:[Ve/ye,sn/ye]));return jt([na.lat+Pn.lat,na.lng+Pn.lng])}function ku(f){for(var E=0,D=0,j=0,mt=0;mt<f.length;mt++){var Ft=jt(f[mt]);E+=Ft.lat,D+=Ft.lng,j++}return jt([E/j,D/j])}var Hl,Rc={__proto__:null,clipPolygon:fo,polygonCenter:vs,centroid:ku};function us(f,E){if(!E||!f.length)return f.slice();var D=E*E;return function In(f,E){var D=f.length,mt=new(typeof Uint8Array!=void 0+""?Uint8Array:Array)(D);mt[0]=mt[D-1]=1,pu(f,mt,E,0,D-1);var Ft,ce=[];for(Ft=0;Ft<D;Ft++)mt[Ft]&&ce.push(f[Ft]);return ce}(f=function Bo(f,E){for(var D=[f[0]],j=1,mt=0,Ft=f.length;j<Ft;j++)qu(f[j],f[mt])>E&&(D.push(f[j]),mt=j);return mt<Ft-1&&D.push(f[Ft-1]),D}(f,D),D)}function Zr(f,E,D){return Math.sqrt(he(f,E,D,!0))}function pu(f,E,D,j,mt){var ce,ye,Ve,Ft=0;for(ye=j+1;ye<=mt-1;ye++)(Ve=he(f[ye],f[j],f[mt],!0))>Ft&&(ce=ye,Ft=Ve);Ft>D&&(E[ce]=1,pu(f,E,D,j,ce),pu(f,E,D,ce,mt))}function Ir(f,E,D,j,mt){var ye,Ve,sn,Ft=j?Hl:Gr(f,D),ce=Gr(E,D);for(Hl=ce;;){if(!(Ft|ce))return[f,E];if(Ft&ce)return!1;sn=Gr(Ve=mu(f,E,ye=Ft||ce,D,mt),D),ye===Ft?(f=Ve,Ft=sn):(E=Ve,ce=sn)}}function mu(f,E,D,j,mt){var sn,bn,Ft=E.x-f.x,ce=E.y-f.y,ye=j.min,Ve=j.max;return 8&D?(sn=f.x+Ft*(Ve.y-f.y)/ce,bn=Ve.y):4&D?(sn=f.x+Ft*(ye.y-f.y)/ce,bn=ye.y):2&D?(sn=Ve.x,bn=f.y+ce*(Ve.x-f.x)/Ft):1&D&&(sn=ye.x,bn=f.y+ce*(ye.x-f.x)/Ft),new yt(sn,bn,mt)}function Gr(f,E){var D=0;return f.x<E.min.x?D|=1:f.x>E.max.x&&(D|=2),f.y<E.min.y?D|=4:f.y>E.max.y&&(D|=8),D}function qu(f,E){var D=E.x-f.x,j=E.y-f.y;return D*D+j*j}function he(f,E,D,j){var sn,mt=E.x,Ft=E.y,ce=D.x-mt,ye=D.y-Ft,Ve=ce*ce+ye*ye;return Ve>0&&((sn=((f.x-mt)*ce+(f.y-Ft)*ye)/Ve)>1?(mt=D.x,Ft=D.y):sn>0&&(mt+=ce*sn,Ft+=ye*sn)),ce=f.x-mt,ye=f.y-Ft,j?ce*ce+ye*ye:new yt(mt,Ft)}function zo(f){return!et(f[0])||"object"!=typeof f[0][0]&&typeof f[0][0]<"u"}function jl(f){return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."),zo(f)}function Fu(f,E){var D,j,mt,Ft,ce,ye,Ve,sn;if(!f||0===f.length)throw new Error("latlngs not passed");zo(f)||(console.warn("latlngs are not flat! Only the first ring will be used"),f=f[0]);var bn=jt([0,0]),Pn=Bt(f);Pn.getNorthWest().distanceTo(Pn.getSouthWest())*Pn.getNorthEast().distanceTo(Pn.getNorthWest())<1700&&(bn=ku(f));var yo=f.length,Qi=[];for(D=0;D<yo;D++){var ro=jt(f[D]);Qi.push(E.project(jt([ro.lat-bn.lat,ro.lng-bn.lng])))}for(D=0,j=0;D<yo-1;D++)j+=Qi[D].distanceTo(Qi[D+1])/2;if(0===j)sn=Qi[0];else for(D=0,Ft=0;D<yo-1;D++)if((Ft+=mt=(ce=Qi[D]).distanceTo(ye=Qi[D+1]))>j){sn=[ye.x-(Ve=(Ft-j)/mt)*(ye.x-ce.x),ye.y-Ve*(ye.y-ce.y)];break}var jo=E.unproject(xt(sn));return jt([jo.lat+bn.lat,jo.lng+bn.lng])}var Br={__proto__:null,simplify:us,pointToSegmentDistance:Zr,closestPointOnSegment:function nu(f,E,D){return he(f,E,D)},clipSegment:Ir,_getEdgeIntersection:mu,_getBitCode:Gr,_sqClosestPointOnSegment:he,isFlat:zo,_flat:jl,polylineCenter:Fu},es={project:function(f){return new yt(f.lng,f.lat)},unproject:function(f){return new ee(f.y,f.x)},bounds:new Mt([-180,-90],[180,90])},ru={R:6378137,R_MINOR:6356752.314245179,bounds:new Mt([-20037508.34279,-15496570.73972],[20037508.34279,18764656.23138]),project:function(f){var E=Math.PI/180,D=this.R,j=f.lat*E,mt=this.R_MINOR/D,Ft=Math.sqrt(1-mt*mt),ce=Ft*Math.sin(j),ye=Math.tan(Math.PI/4-j/2)/Math.pow((1-ce)/(1+ce),Ft/2);return j=-D*Math.log(Math.max(ye,1e-10)),new yt(f.lng*E*D,j)},unproject:function(f){for(var sn,E=180/Math.PI,D=this.R,j=this.R_MINOR/D,mt=Math.sqrt(1-j*j),Ft=Math.exp(-f.y/D),ce=Math.PI/2-2*Math.atan(Ft),ye=0,Ve=.1;ye<15&&Math.abs(Ve)>1e-7;ye++)sn=mt*Math.sin(ce),sn=Math.pow((1-sn)/(1+sn),mt/2),ce+=Ve=Math.PI/2-2*Math.atan(Ft*sn)-ce;return new ee(ce*E,f.x*E/D)}},iu={__proto__:null,LonLat:es,Mercator:ru,SphericalMercator:Xe},ls=V({},be,{code:"EPSG:3395",projection:ru,transformation:function(){var f=.5/(Math.PI*ru.R);return De(f,.5,-f,.5)}()}),Fs=V({},be,{code:"EPSG:4326",projection:es,transformation:De(1/180,1,-1/180,.5)}),va=V({},se,{projection:es,transformation:De(1,0,-1,0),scale:function(f){return Math.pow(2,f)},zoom:function(f){return Math.log(f)/Math.LN2},distance:function(f,E){var D=E.lng-f.lng,j=E.lat-f.lat;return Math.sqrt(D*D+j*j)},infinite:!0});se.Earth=be,se.EPSG3395=ls,se.EPSG3857=Tn,se.EPSG900913=On,se.EPSG4326=Fs,se.Simple=va;var Vo=Ct.extend({options:{pane:"overlayPane",attribution:null,bubblingMouseEvents:!0},addTo:function(f){return f.addLayer(this),this},remove:function(){return this.removeFrom(this._map||this._mapToAdd)},removeFrom:function(f){return f&&f.removeLayer(this),this},getPane:function(f){return this._map.getPane(f?this.options[f]||f:this.options.pane)},addInteractiveTarget:function(f){return this._map._targets[R(f)]=this,this},removeInteractiveTarget:function(f){return delete this._map._targets[R(f)],this},getAttribution:function(){return this.options.attribution},_layerAdd:function(f){var E=f.target;if(E.hasLayer(this)){if(this._map=E,this._zoomAnimated=E._zoomAnimated,this.getEvents){var D=this.getEvents();E.on(D,this),this.once("remove",function(){E.off(D,this)},this)}this.onAdd(E),this.fire("add"),E.fire("layeradd",{layer:this})}}});ae.include({addLayer:function(f){if(!f._layerAdd)throw new Error("The provided object is not a Layer.");var E=R(f);return this._layers[E]||(this._layers[E]=f,f._mapToAdd=this,f.beforeAdd&&f.beforeAdd(this),this.whenReady(f._layerAdd,f)),this},removeLayer:function(f){var E=R(f);return this._layers[E]?(this._loaded&&f.onRemove(this),delete this._layers[E],this._loaded&&(this.fire("layerremove",{layer:f}),f.fire("remove")),f._map=f._mapToAdd=null,this):this},hasLayer:function(f){return R(f)in this._layers},eachLayer:function(f,E){for(var D in this._layers)f.call(E,this._layers[D]);return this},_addLayers:function(f){for(var E=0,D=(f=f?et(f)?f:[f]:[]).length;E<D;E++)this.addLayer(f[E])},_addZoomLimit:function(f){(!isNaN(f.options.maxZoom)||!isNaN(f.options.minZoom))&&(this._zoomBoundLayers[R(f)]=f,this._updateZoomLevels())},_removeZoomLimit:function(f){var E=R(f);this._zoomBoundLayers[E]&&(delete this._zoomBoundLayers[E],this._updateZoomLevels())},_updateZoomLevels:function(){var f=1/0,E=-1/0,D=this._getZoomSpan();for(var j in this._zoomBoundLayers){var mt=this._zoomBoundLayers[j].options;f=void 0===mt.minZoom?f:Math.min(f,mt.minZoom),E=void 0===mt.maxZoom?E:Math.max(E,mt.maxZoom)}this._layersMaxZoom=E===-1/0?void 0:E,this._layersMinZoom=f===1/0?void 0:f,D!==this._getZoomSpan()&&this.fire("zoomlevelschange"),void 0===this.options.maxZoom&&this._layersMaxZoom&&this.getZoom()>this._layersMaxZoom&&this.setZoom(this._layersMaxZoom),void 0===this.options.minZoom&&this._layersMinZoom&&this.getZoom()<this._layersMinZoom&&this.setZoom(this._layersMinZoom)}});var _a=Vo.extend({initialize:function(f,E){var D,j;if(it(this,E),this._layers={},f)for(D=0,j=f.length;D<j;D++)this.addLayer(f[D])},addLayer:function(f){var E=this.getLayerId(f);return this._layers[E]=f,this._map&&this._map.addLayer(f),this},removeLayer:function(f){var E=f in this._layers?f:this.getLayerId(f);return this._map&&this._layers[E]&&this._map.removeLayer(this._layers[E]),delete this._layers[E],this},hasLayer:function(f){return("number"==typeof f?f:this.getLayerId(f))in this._layers},clearLayers:function(){return this.eachLayer(this.removeLayer,this)},invoke:function(f){var D,j,E=Array.prototype.slice.call(arguments,1);for(D in this._layers)(j=this._layers[D])[f]&&j[f].apply(j,E);return this},onAdd:function(f){this.eachLayer(f.addLayer,f)},onRemove:function(f){this.eachLayer(f.removeLayer,f)},eachLayer:function(f,E){for(var D in this._layers)f.call(E,this._layers[D]);return this},getLayer:function(f){return this._layers[f]},getLayers:function(){var f=[];return this.eachLayer(f.push,f),f},setZIndex:function(f){return this.invoke("setZIndex",f)},getLayerId:function(f){return R(f)}}),Jo=_a.extend({addLayer:function(f){return this.hasLayer(f)?this:(f.addEventParent(this),_a.prototype.addLayer.call(this,f),this.fire("layeradd",{layer:f}))},removeLayer:function(f){return this.hasLayer(f)?(f in this._layers&&(f=this._layers[f]),f.removeEventParent(this),_a.prototype.removeLayer.call(this,f),this.fire("layerremove",{layer:f})):this},setStyle:function(f){return this.invoke("setStyle",f)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var f=new re;for(var E in this._layers){var D=this._layers[E];f.extend(D.getBounds?D.getBounds():D.getLatLng())}return f}}),Mo=nt.extend({options:{popupAnchor:[0,0],tooltipAnchor:[0,0],crossOrigin:!1},initialize:function(f){it(this,f)},createIcon:function(f){return this._createIcon("icon",f)},createShadow:function(f){return this._createIcon("shadow",f)},_createIcon:function(f,E){var D=this._getIconUrl(f);if(!D){if("icon"===f)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var j=this._createImg(D,E&&"IMG"===E.tagName?E:null);return this._setIconStyles(j,f),(this.options.crossOrigin||""===this.options.crossOrigin)&&(j.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),j},_setIconStyles:function(f,E){var D=this.options,j=D[E+"Size"];"number"==typeof j&&(j=[j,j]);var mt=xt(j),Ft=xt("shadow"===E&&D.shadowAnchor||D.iconAnchor||mt&&mt.divideBy(2,!0));f.className="leaflet-marker-"+E+" "+(D.className||""),Ft&&(f.style.marginLeft=-Ft.x+"px",f.style.marginTop=-Ft.y+"px"),mt&&(f.style.width=mt.x+"px",f.style.height=mt.y+"px")},_createImg:function(f,E){return(E=E||document.createElement("img")).src=f,E},_getIconUrl:function(f){return Dn.retina&&this.options[f+"RetinaUrl"]||this.options[f+"Url"]}});var la=Mo.extend({options:{iconUrl:"marker-icon.png",iconRetinaUrl:"marker-icon-2x.png",shadowUrl:"marker-shadow.png",iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],tooltipAnchor:[16,-28],shadowSize:[41,41]},_getIconUrl:function(f){return"string"!=typeof la.imagePath&&(la.imagePath=this._detectIconPath()),(this.options.imagePath||la.imagePath)+Mo.prototype._getIconUrl.call(this,f)},_stripUrl:function(f){var E=function(D,j,mt){var Ft=j.exec(D);return Ft&&Ft[mt]};return(f=E(f,/^url\((['"])?(.+)\1\)$/,2))&&E(f,/^(.*)marker-icon\.png$/,1)},_detectIconPath:function(){var f=$r("div","leaflet-default-icon-path",document.body),E=Ra(f,"background-image")||Ra(f,"backgroundImage");if(document.body.removeChild(f),E=this._stripUrl(E))return E;var D=document.querySelector('link[href$="leaflet.css"]');return D?D.href.substring(0,D.href.length-11-1):""}}),xa=tn.extend({initialize:function(f){this._marker=f},addHooks:function(){var f=this._marker._icon;this._draggable||(this._draggable=new qi(f,f,!0)),this._draggable.on({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).enable(),An(f,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).disable(),this._marker._icon&&jr(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_adjustPan:function(f){var E=this._marker,D=E._map,j=this._marker.options.autoPanSpeed,mt=this._marker.options.autoPanPadding,Ft=Cs(E._icon),ce=D.getPixelBounds(),ye=D.getPixelOrigin(),Ve=It(ce.min._subtract(ye).add(mt),ce.max._subtract(ye).subtract(mt));if(!Ve.contains(Ft)){var sn=xt((Math.max(Ve.max.x,Ft.x)-Ve.max.x)/(ce.max.x-Ve.max.x)-(Math.min(Ve.min.x,Ft.x)-Ve.min.x)/(ce.min.x-Ve.min.x),(Math.max(Ve.max.y,Ft.y)-Ve.max.y)/(ce.max.y-Ve.max.y)-(Math.min(Ve.min.y,Ft.y)-Ve.min.y)/(ce.min.y-Ve.min.y)).multiplyBy(j);D.panBy(sn,{animate:!1}),this._draggable._newPos._add(sn),this._draggable._startPos._add(sn),Xn(E._icon,this._draggable._newPos),this._onDrag(f),this._panRequest=ot(this._adjustPan.bind(this,f))}},_onDragStart:function(){this._oldLatLng=this._marker.getLatLng(),this._marker.closePopup&&this._marker.closePopup(),this._marker.fire("movestart").fire("dragstart")},_onPreDrag:function(f){this._marker.options.autoPan&&(P(this._panRequest),this._panRequest=ot(this._adjustPan.bind(this,f)))},_onDrag:function(f){var E=this._marker,D=E._shadow,j=Cs(E._icon),mt=E._map.layerPointToLatLng(j);D&&Xn(D,j),E._latlng=mt,f.latlng=mt,f.oldLatLng=this._oldLatLng,E.fire("move",f).fire("drag",f)},_onDragEnd:function(f){P(this._panRequest),delete this._oldLatLng,this._marker.fire("moveend").fire("dragend",f)}}),cs=Vo.extend({options:{icon:new la,interactive:!0,keyboard:!0,title:"",alt:"Marker",zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250,pane:"markerPane",shadowPane:"shadowPane",bubblingMouseEvents:!1,autoPanOnFocus:!0,draggable:!1,autoPan:!1,autoPanPadding:[50,50],autoPanSpeed:10},initialize:function(f,E){it(this,E),this._latlng=jt(f)},onAdd:function(f){this._zoomAnimated=this._zoomAnimated&&f.options.markerZoomAnimation,this._zoomAnimated&&f.on("zoomanim",this._animateZoom,this),this._initIcon(),this.update()},onRemove:function(f){this.dragging&&this.dragging.enabled()&&(this.options.draggable=!0,this.dragging.removeHooks()),delete this.dragging,this._zoomAnimated&&f.off("zoomanim",this._animateZoom,this),this._removeIcon(),this._removeShadow()},getEvents:function(){return{zoom:this.update,viewreset:this.update}},getLatLng:function(){return this._latlng},setLatLng:function(f){var E=this._latlng;return this._latlng=jt(f),this.update(),this.fire("move",{oldLatLng:E,latlng:this._latlng})},setZIndexOffset:function(f){return this.options.zIndexOffset=f,this.update()},getIcon:function(){return this.options.icon},setIcon:function(f){return this.options.icon=f,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup,this._popup.options),this},getElement:function(){return this._icon},update:function(){if(this._icon&&this._map){var f=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(f)}return this},_initIcon:function(){var f=this.options,E="leaflet-zoom-"+(this._zoomAnimated?"animated":"hide"),D=f.icon.createIcon(this._icon),j=!1;D!==this._icon&&(this._icon&&this._removeIcon(),j=!0,f.title&&(D.title=f.title),"IMG"===D.tagName&&(D.alt=f.alt||"")),An(D,E),f.keyboard&&(D.tabIndex="0",D.setAttribute("role","button")),this._icon=D,f.riseOnHover&&this.on({mouseover:this._bringToFront,mouseout:this._resetZIndex}),this.options.autoPanOnFocus&&Kn(D,"focus",this._panOnFocus,this);var mt=f.icon.createShadow(this._shadow),Ft=!1;mt!==this._shadow&&(this._removeShadow(),Ft=!0),mt&&(An(mt,E),mt.alt=""),this._shadow=mt,f.opacity<1&&this._updateOpacity(),j&&this.getPane().appendChild(this._icon),this._initInteraction(),mt&&Ft&&this.getPane(f.shadowPane).appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&this.off({mouseover:this._bringToFront,mouseout:this._resetZIndex}),this.options.autoPanOnFocus&&br(this._icon,"focus",this._panOnFocus,this),pr(this._icon),this.removeInteractiveTarget(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&pr(this._shadow),this._shadow=null},_setPos:function(f){this._icon&&Xn(this._icon,f),this._shadow&&Xn(this._shadow,f),this._zIndex=f.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(f){this._icon&&(this._icon.style.zIndex=this._zIndex+f)},_animateZoom:function(f){var E=this._map._latLngToNewLayerPoint(this._latlng,f.zoom,f.center).round();this._setPos(E)},_initInteraction:function(){if(this.options.interactive&&(An(this._icon,"leaflet-interactive"),this.addInteractiveTarget(this._icon),xa)){var f=this.options.draggable;this.dragging&&(f=this.dragging.enabled(),this.dragging.disable()),this.dragging=new xa(this),f&&this.dragging.enable()}},setOpacity:function(f){return this.options.opacity=f,this._map&&this._updateOpacity(),this},_updateOpacity:function(){var f=this.options.opacity;this._icon&&nr(this._icon,f),this._shadow&&nr(this._shadow,f)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)},_panOnFocus:function(){var f=this._map;if(f){var E=this.options.icon.options,D=E.iconSize?xt(E.iconSize):xt(0,0),j=E.iconAnchor?xt(E.iconAnchor):xt(0,0);f.panInside(this._latlng,{paddingTopLeft:j,paddingBottomRight:D.subtract(j)})}},_getPopupAnchor:function(){return this.options.icon.options.popupAnchor},_getTooltipAnchor:function(){return this.options.icon.options.tooltipAnchor}});var su=Vo.extend({options:{stroke:!0,color:"#3388ff",weight:3,opacity:1,lineCap:"round",lineJoin:"round",dashArray:null,dashOffset:null,fill:!1,fillColor:null,fillOpacity:.2,fillRule:"evenodd",interactive:!0,bubblingMouseEvents:!0},beforeAdd:function(f){this._renderer=f.getRenderer(this)},onAdd:function(){this._renderer._initPath(this),this._reset(),this._renderer._addPath(this)},onRemove:function(){this._renderer._removePath(this)},redraw:function(){return this._map&&this._renderer._updatePath(this),this},setStyle:function(f){return it(this,f),this._renderer&&(this._renderer._updateStyle(this),this.options.stroke&&f&&Object.prototype.hasOwnProperty.call(f,"weight")&&this._updateBounds()),this},bringToFront:function(){return this._renderer&&this._renderer._bringToFront(this),this},bringToBack:function(){return this._renderer&&this._renderer._bringToBack(this),this},getElement:function(){return this._path},_reset:function(){this._project(),this._update()},_clickTolerance:function(){return(this.options.stroke?this.options.weight/2:0)+(this._renderer.options.tolerance||0)}}),Ys=su.extend({options:{fill:!0,radius:10},initialize:function(f,E){it(this,E),this._latlng=jt(f),this._radius=this.options.radius},setLatLng:function(f){var E=this._latlng;return this._latlng=jt(f),this.redraw(),this.fire("move",{oldLatLng:E,latlng:this._latlng})},getLatLng:function(){return this._latlng},setRadius:function(f){return this.options.radius=this._radius=f,this.redraw()},getRadius:function(){return this._radius},setStyle:function(f){var E=f&&f.radius||this._radius;return su.prototype.setStyle.call(this,f),this.setRadius(E),this},_project:function(){this._point=this._map.latLngToLayerPoint(this._latlng),this._updateBounds()},_updateBounds:function(){var f=this._radius,E=this._radiusY||f,D=this._clickTolerance(),j=[f+D,E+D];this._pxBounds=new Mt(this._point.subtract(j),this._point.add(j))},_update:function(){this._map&&this._updatePath()},_updatePath:function(){this._renderer._updateCircle(this)},_empty:function(){return this._radius&&!this._renderer._bounds.intersects(this._pxBounds)},_containsPoint:function(f){return f.distanceTo(this._point)<=this._radius+this._clickTolerance()}});var Uo=Ys.extend({initialize:function(f,E,D){if("number"==typeof E&&(E=V({},D,{radius:E})),it(this,E),this._latlng=jt(f),isNaN(this.options.radius))throw new Error("Circle radius cannot be NaN");this._mRadius=this.options.radius},setRadius:function(f){return this._mRadius=f,this.redraw()},getRadius:function(){return this._mRadius},getBounds:function(){var f=[this._radius,this._radiusY||this._radius];return new re(this._map.layerPointToLatLng(this._point.subtract(f)),this._map.layerPointToLatLng(this._point.add(f)))},setStyle:su.prototype.setStyle,_project:function(){var f=this._latlng.lng,E=this._latlng.lat,D=this._map,j=D.options.crs;if(j.distance===be.distance){var mt=Math.PI/180,Ft=this._mRadius/be.R/mt,ce=D.project([E+Ft,f]),ye=D.project([E-Ft,f]),Ve=ce.add(ye).divideBy(2),sn=D.unproject(Ve).lat,bn=Math.acos((Math.cos(Ft*mt)-Math.sin(E*mt)*Math.sin(sn*mt))/(Math.cos(E*mt)*Math.cos(sn*mt)))/mt;(isNaN(bn)||0===bn)&&(bn=Ft/Math.cos(Math.PI/180*E)),this._point=Ve.subtract(D.getPixelOrigin()),this._radius=isNaN(bn)?0:Ve.x-D.project([sn,f-bn]).x,this._radiusY=Ve.y-ce.y}else{var Pn=j.unproject(j.project(this._latlng).subtract([this._mRadius,0]));this._point=D.latLngToLayerPoint(this._latlng),this._radius=this._point.x-D.latLngToLayerPoint(Pn).x}this._updateBounds()}});var mi=su.extend({options:{smoothFactor:1,noClip:!1},initialize:function(f,E){it(this,E),this._setLatLngs(f)},getLatLngs:function(){return this._latlngs},setLatLngs:function(f){return this._setLatLngs(f),this.redraw()},isEmpty:function(){return!this._latlngs.length},closestLayerPoint:function(f){for(var mt,Ft,E=1/0,D=null,j=he,ce=0,ye=this._parts.length;ce<ye;ce++)for(var Ve=this._parts[ce],sn=1,bn=Ve.length;sn<bn;sn++){var Pn=j(f,mt=Ve[sn-1],Ft=Ve[sn],!0);Pn<E&&(E=Pn,D=j(f,mt,Ft))}return D&&(D.distance=Math.sqrt(E)),D},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");return Fu(this._defaultShape(),this._map.options.crs)},getBounds:function(){return this._bounds},addLatLng:function(f,E){return E=E||this._defaultShape(),f=jt(f),E.push(f),this._bounds.extend(f),this.redraw()},_setLatLngs:function(f){this._bounds=new re,this._latlngs=this._convertLatLngs(f)},_defaultShape:function(){return zo(this._latlngs)?this._latlngs:this._latlngs[0]},_convertLatLngs:function(f){for(var E=[],D=zo(f),j=0,mt=f.length;j<mt;j++)D?(E[j]=jt(f[j]),this._bounds.extend(E[j])):E[j]=this._convertLatLngs(f[j]);return E},_project:function(){var f=new Mt;this._rings=[],this._projectLatlngs(this._latlngs,this._rings,f),this._bounds.isValid()&&f.isValid()&&(this._rawPxBounds=f,this._updateBounds())},_updateBounds:function(){var f=this._clickTolerance(),E=new yt(f,f);this._rawPxBounds&&(this._pxBounds=new Mt([this._rawPxBounds.min.subtract(E),this._rawPxBounds.max.add(E)]))},_projectLatlngs:function(f,E,D){var Ft,ce,mt=f.length;if(f[0]instanceof ee){for(ce=[],Ft=0;Ft<mt;Ft++)ce[Ft]=this._map.latLngToLayerPoint(f[Ft]),D.extend(ce[Ft]);E.push(ce)}else for(Ft=0;Ft<mt;Ft++)this._projectLatlngs(f[Ft],E,D)},_clipPoints:function(){var f=this._renderer._bounds;if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(f)){if(this.options.noClip)return void(this._parts=this._rings);var D,j,mt,Ft,ce,ye,Ve,E=this._parts;for(D=0,mt=0,Ft=this._rings.length;D<Ft;D++)for(j=0,ce=(Ve=this._rings[D]).length;j<ce-1;j++)(ye=Ir(Ve[j],Ve[j+1],f,j,!0))&&(E[mt]=E[mt]||[],E[mt].push(ye[0]),(ye[1]!==Ve[j+1]||j===ce-2)&&(E[mt].push(ye[1]),mt++))}},_simplifyPoints:function(){for(var f=this._parts,E=this.options.smoothFactor,D=0,j=f.length;D<j;D++)f[D]=us(f[D],E)},_update:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),this._updatePath())},_updatePath:function(){this._renderer._updatePoly(this)},_containsPoint:function(f,E){var D,j,mt,Ft,ce,ye,Ve=this._clickTolerance();if(!this._pxBounds||!this._pxBounds.contains(f))return!1;for(D=0,Ft=this._parts.length;D<Ft;D++)for(j=0,mt=(ce=(ye=this._parts[D]).length)-1;j<ce;mt=j++)if((E||0!==j)&&Zr(f,ye[mt],ye[j])<=Ve)return!0;return!1}});mi._flat=jl;var ka=mi.extend({options:{fill:!0},isEmpty:function(){return!this._latlngs.length||!this._latlngs[0].length},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");return vs(this._defaultShape(),this._map.options.crs)},_convertLatLngs:function(f){var E=mi.prototype._convertLatLngs.call(this,f),D=E.length;return D>=2&&E[0]instanceof ee&&E[0].equals(E[D-1])&&E.pop(),E},_setLatLngs:function(f){mi.prototype._setLatLngs.call(this,f),zo(this._latlngs)&&(this._latlngs=[this._latlngs])},_defaultShape:function(){return zo(this._latlngs[0])?this._latlngs[0]:this._latlngs[0][0]},_clipPoints:function(){var f=this._renderer._bounds,E=this.options.weight,D=new yt(E,E);if(f=new Mt(f.min.subtract(D),f.max.add(D)),this._parts=[],this._pxBounds&&this._pxBounds.intersects(f)){if(this.options.noClip)return void(this._parts=this._rings);for(var Ft,j=0,mt=this._rings.length;j<mt;j++)(Ft=fo(this._rings[j],f,!0)).length&&this._parts.push(Ft)}},_updatePath:function(){this._renderer._updatePoly(this,!0)},_containsPoint:function(f){var D,j,mt,Ft,ce,ye,Ve,sn,E=!1;if(!this._pxBounds||!this._pxBounds.contains(f))return!1;for(Ft=0,Ve=this._parts.length;Ft<Ve;Ft++)for(ce=0,ye=(sn=(D=this._parts[Ft]).length)-1;ce<sn;ye=ce++)(j=D[ce]).y>f.y!=(mt=D[ye]).y>f.y&&f.x<(mt.x-j.x)*(f.y-j.y)/(mt.y-j.y)+j.x&&(E=!E);return E||mi.prototype._containsPoint.call(this,f,!0)}});var Ha=Jo.extend({initialize:function(f,E){it(this,E),this._layers={},f&&this.addData(f)},addData:function(f){var D,j,mt,E=et(f)?f:f.features;if(E){for(D=0,j=E.length;D<j;D++)((mt=E[D]).geometries||mt.geometry||mt.features||mt.coordinates)&&this.addData(mt);return this}var Ft=this.options;if(Ft.filter&&!Ft.filter(f))return this;var ce=pl(f,Ft);return ce?(ce.feature=Ca(f),ce.defaultOptions=ce.options,this.resetStyle(ce),Ft.onEachFeature&&Ft.onEachFeature(f,ce),this.addLayer(ce)):this},resetStyle:function(f){return void 0===f?this.eachLayer(this.resetStyle,this):(f.options=V({},f.defaultOptions),this._setLayerStyle(f,this.options.style),this)},setStyle:function(f){return this.eachLayer(function(E){this._setLayerStyle(E,f)},this)},_setLayerStyle:function(f,E){f.setStyle&&("function"==typeof E&&(E=E(f.feature)),f.setStyle(E))}});function pl(f,E){var ye,Ve,sn,bn,D="Feature"===f.type?f.geometry:f,j=D?D.coordinates:null,mt=[],Ft=E&&E.pointToLayer,ce=E&&E.coordsToLatLng||Wo;if(!j&&!D)return null;switch(D.type){case"Point":return ta(Ft,f,ye=ce(j),E);case"MultiPoint":for(sn=0,bn=j.length;sn<bn;sn++)ye=ce(j[sn]),mt.push(ta(Ft,f,ye,E));return new Jo(mt);case"LineString":case"MultiLineString":return Ve=Ns(j,"LineString"===D.type?0:1,ce),new mi(Ve,E);case"Polygon":case"MultiPolygon":return Ve=Ns(j,"Polygon"===D.type?1:2,ce),new ka(Ve,E);case"GeometryCollection":for(sn=0,bn=D.geometries.length;sn<bn;sn++){var Pn=pl({geometry:D.geometries[sn],type:"Feature",properties:f.properties},E);Pn&&mt.push(Pn)}return new Jo(mt);case"FeatureCollection":for(sn=0,bn=D.features.length;sn<bn;sn++){var Nr=pl(D.features[sn],E);Nr&&mt.push(Nr)}return new Jo(mt);default:throw new Error("Invalid GeoJSON object.")}}function ta(f,E,D,j){return f?f(E,D):new cs(D,j&&j.markersInheritOptions&&j)}function Wo(f){return new ee(f[1],f[0],f[2])}function Ns(f,E,D){for(var ce,j=[],mt=0,Ft=f.length;mt<Ft;mt++)ce=E?Ns(f[mt],E-1,D):(D||Wo)(f[mt]),j.push(ce);return j}function Tu(f,E){return void 0!==(f=jt(f)).alt?[X(f.lng,E),X(f.lat,E),X(f.alt,E)]:[X(f.lng,E),X(f.lat,E)]}function Bs(f,E,D,j){for(var mt=[],Ft=0,ce=f.length;Ft<ce;Ft++)mt.push(E?Bs(f[Ft],zo(f[Ft])?0:E-1,D,j):Tu(f[Ft],j));return!E&&D&&mt.length>0&&mt.push(mt[0].slice()),mt}function Go(f,E){return f.feature?V({},f.feature,{geometry:E}):Ca(E)}function Ca(f){return"Feature"===f.type||"FeatureCollection"===f.type?f:{type:"Feature",properties:{},geometry:f}}var Nu={toGeoJSON:function(f){return Go(this,{type:"Point",coordinates:Tu(this.getLatLng(),f)})}};function gu(f,E){return new Ha(f,E)}cs.include(Nu),Uo.include(Nu),Ys.include(Nu),mi.include({toGeoJSON:function(f){var E=!zo(this._latlngs);return Go(this,{type:(E?"Multi":"")+"LineString",coordinates:Bs(this._latlngs,E?1:0,!1,f)})}}),ka.include({toGeoJSON:function(f){var E=!zo(this._latlngs),D=E&&!zo(this._latlngs[0]),j=Bs(this._latlngs,D?2:E?1:0,!0,f);return E||(j=[j]),Go(this,{type:(D?"Multi":"")+"Polygon",coordinates:j})}}),_a.include({toMultiPoint:function(f){var E=[];return this.eachLayer(function(D){E.push(D.toGeoJSON(f).geometry.coordinates)}),Go(this,{type:"MultiPoint",coordinates:E})},toGeoJSON:function(f){var E=this.feature&&this.feature.geometry&&this.feature.geometry.type;if("MultiPoint"===E)return this.toMultiPoint(f);var D="GeometryCollection"===E,j=[];return this.eachLayer(function(mt){if(mt.toGeoJSON){var Ft=mt.toGeoJSON(f);if(D)j.push(Ft.geometry);else{var ce=Ca(Ft);"FeatureCollection"===ce.type?j.push.apply(j,ce.features):j.push(ce)}}}),D?Go(this,{geometries:j,type:"GeometryCollection"}):{type:"FeatureCollection",features:j}}});var ja=gu,wa=Vo.extend({options:{opacity:1,alt:"",interactive:!1,crossOrigin:!1,errorOverlayUrl:"",zIndex:1,className:""},initialize:function(f,E,D){this._url=f,this._bounds=Bt(E),it(this,D)},onAdd:function(){this._image||(this._initImage(),this.options.opacity<1&&this._updateOpacity()),this.options.interactive&&(An(this._image,"leaflet-interactive"),this.addInteractiveTarget(this._image)),this.getPane().appendChild(this._image),this._reset()},onRemove:function(){pr(this._image),this.options.interactive&&this.removeInteractiveTarget(this._image)},setOpacity:function(f){return this.options.opacity=f,this._image&&this._updateOpacity(),this},setStyle:function(f){return f.opacity&&this.setOpacity(f.opacity),this},bringToFront:function(){return this._map&&Xs(this._image),this},bringToBack:function(){return this._map&&Ga(this._image),this},setUrl:function(f){return this._url=f,this._image&&(this._image.src=f),this},setBounds:function(f){return this._bounds=Bt(f),this._map&&this._reset(),this},getEvents:function(){var f={zoom:this._reset,viewreset:this._reset};return this._zoomAnimated&&(f.zoomanim=this._animateZoom),f},setZIndex:function(f){return this.options.zIndex=f,this._updateZIndex(),this},getBounds:function(){return this._bounds},getElement:function(){return this._image},_initImage:function(){var f="IMG"===this._url.tagName,E=this._image=f?this._url:$r("img");An(E,"leaflet-image-layer"),this._zoomAnimated&&An(E,"leaflet-zoom-animated"),this.options.className&&An(E,this.options.className),E.onselectstart=A,E.onmousemove=A,E.onload=q(this.fire,this,"load"),E.onerror=q(this._overlayOnError,this,"error"),(this.options.crossOrigin||""===this.options.crossOrigin)&&(E.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),this.options.zIndex&&this._updateZIndex(),f?this._url=E.src:(E.src=this._url,E.alt=this.options.alt)},_animateZoom:function(f){var E=this._map.getZoomScale(f.zoom),D=this._map._latLngBoundsToNewLayerBounds(this._bounds,f.zoom,f.center).min;ya(this._image,D,E)},_reset:function(){var f=this._image,E=new Mt(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast())),D=E.getSize();Xn(f,E.min),f.style.width=D.x+"px",f.style.height=D.y+"px"},_updateOpacity:function(){nr(this._image,this.options.opacity)},_updateZIndex:function(){this._image&&null!=this.options.zIndex&&(this._image.style.zIndex=this.options.zIndex)},_overlayOnError:function(){this.fire("error");var f=this.options.errorOverlayUrl;f&&this._url!==f&&(this._url=f,this._image.src=f)},getCenter:function(){return this._bounds.getCenter()}}),ea=wa.extend({options:{autoplay:!0,loop:!0,keepAspectRatio:!0,muted:!1,playsInline:!0},_initImage:function(){var f="VIDEO"===this._url.tagName,E=this._image=f?this._url:$r("video");if(An(E,"leaflet-image-layer"),this._zoomAnimated&&An(E,"leaflet-zoom-animated"),this.options.className&&An(E,this.options.className),E.onselectstart=A,E.onmousemove=A,E.onloadeddata=q(this.fire,this,"load"),f){for(var D=E.getElementsByTagName("source"),j=[],mt=0;mt<D.length;mt++)j.push(D[mt].src);this._url=D.length>0?j:[E.src]}else{et(this._url)||(this._url=[this._url]),!this.options.keepAspectRatio&&Object.prototype.hasOwnProperty.call(E.style,"objectFit")&&(E.style.objectFit="fill"),E.autoplay=!!this.options.autoplay,E.loop=!!this.options.loop,E.muted=!!this.options.muted,E.playsInline=!!this.options.playsInline;for(var Ft=0;Ft<this._url.length;Ft++){var ce=$r("source");ce.src=this._url[Ft],E.appendChild(ce)}}}});var Fa=wa.extend({_initImage:function(){var f=this._image=this._url;An(f,"leaflet-image-layer"),this._zoomAnimated&&An(f,"leaflet-zoom-animated"),this.options.className&&An(f,this.options.className),f.onselectstart=A,f.onmousemove=A}});var So=Vo.extend({options:{interactive:!1,offset:[0,0],className:"",pane:void 0,content:""},initialize:function(f,E){f&&(f instanceof ee||et(f))?(this._latlng=jt(f),it(this,E)):(it(this,f),this._source=E),this.options.content&&(this._content=this.options.content)},openOn:function(f){return(f=arguments.length?f:this._source._map).hasLayer(this)||f.addLayer(this),this},close:function(){return this._map&&this._map.removeLayer(this),this},toggle:function(f){return this._map?this.close():(arguments.length?this._source=f:f=this._source,this._prepareOpen(),this.openOn(f._map)),this},onAdd:function(f){this._zoomAnimated=f._zoomAnimated,this._container||this._initLayout(),f._fadeAnimated&&nr(this._container,0),clearTimeout(this._removeTimeout),this.getPane().appendChild(this._container),this.update(),f._fadeAnimated&&nr(this._container,1),this.bringToFront(),this.options.interactive&&(An(this._container,"leaflet-interactive"),this.addInteractiveTarget(this._container))},onRemove:function(f){f._fadeAnimated?(nr(this._container,0),this._removeTimeout=setTimeout(q(pr,void 0,this._container),200)):pr(this._container),this.options.interactive&&(jr(this._container,"leaflet-interactive"),this.removeInteractiveTarget(this._container))},getLatLng:function(){return this._latlng},setLatLng:function(f){return this._latlng=jt(f),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(f){return this._content=f,this.update(),this},getElement:function(){return this._container},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},getEvents:function(){var f={zoom:this._updatePosition,viewreset:this._updatePosition};return this._zoomAnimated&&(f.zoomanim=this._animateZoom),f},isOpen:function(){return!!this._map&&this._map.hasLayer(this)},bringToFront:function(){return this._map&&Xs(this._container),this},bringToBack:function(){return this._map&&Ga(this._container),this},_prepareOpen:function(f){var E=this._source;if(!E._map)return!1;if(E instanceof Jo){E=null;var D=this._source._layers;for(var j in D)if(D[j]._map){E=D[j];break}if(!E)return!1;this._source=E}if(!f)if(E.getCenter)f=E.getCenter();else if(E.getLatLng)f=E.getLatLng();else{if(!E.getBounds)throw new Error("Unable to get source layer LatLng.");f=E.getBounds().getCenter()}return this.setLatLng(f),this._map&&this.update(),!0},_updateContent:function(){if(this._content){var f=this._contentNode,E="function"==typeof this._content?this._content(this._source||this):this._content;if("string"==typeof E)f.innerHTML=E;else{for(;f.hasChildNodes();)f.removeChild(f.firstChild);f.appendChild(E)}this.fire("contentupdate")}},_updatePosition:function(){if(this._map){var f=this._map.latLngToLayerPoint(this._latlng),E=xt(this.options.offset),D=this._getAnchor();this._zoomAnimated?Xn(this._container,f.add(D)):E=E.add(f).add(D);var j=this._containerBottom=-E.y,mt=this._containerLeft=-Math.round(this._containerWidth/2)+E.x;this._container.style.bottom=j+"px",this._container.style.left=mt+"px"}},_getAnchor:function(){return[0,0]}});ae.include({_initOverlay:function(f,E,D,j){var mt=E;return mt instanceof f||(mt=new f(j).setContent(E)),D&&mt.setLatLng(D),mt}}),Vo.include({_initOverlay:function(f,E,D,j){var mt=D;return mt instanceof f?(it(mt,j),mt._source=this):(mt=E&&!j?E:new f(j,this)).setContent(D),mt}});var hs=So.extend({options:{pane:"popupPane",offset:[0,7],maxWidth:300,minWidth:50,maxHeight:null,autoPan:!0,autoPanPaddingTopLeft:null,autoPanPaddingBottomRight:null,autoPanPadding:[5,5],keepInView:!1,closeButton:!0,autoClose:!0,closeOnEscapeKey:!0,className:""},openOn:function(f){return!(f=arguments.length?f:this._source._map).hasLayer(this)&&f._popup&&f._popup.options.autoClose&&f.removeLayer(f._popup),f._popup=this,So.prototype.openOn.call(this,f)},onAdd:function(f){So.prototype.onAdd.call(this,f),f.fire("popupopen",{popup:this}),this._source&&(this._source.fire("popupopen",{popup:this},!0),this._source instanceof su||this._source.on("preclick",$o))},onRemove:function(f){So.prototype.onRemove.call(this,f),f.fire("popupclose",{popup:this}),this._source&&(this._source.fire("popupclose",{popup:this},!0),this._source instanceof su||this._source.off("preclick",$o))},getEvents:function(){var f=So.prototype.getEvents.call(this);return(void 0!==this.options.closeOnClick?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(f.preclick=this.close),this.options.keepInView&&(f.moveend=this._adjustPan),f},_initLayout:function(){var f="leaflet-popup",E=this._container=$r("div",f+" "+(this.options.className||"")+" leaflet-zoom-animated"),D=this._wrapper=$r("div",f+"-content-wrapper",E);if(this._contentNode=$r("div",f+"-content",D),as(E),Or(this._contentNode),Kn(E,"contextmenu",$o),this._tipContainer=$r("div",f+"-tip-container",E),this._tip=$r("div",f+"-tip",this._tipContainer),this.options.closeButton){var j=this._closeButton=$r("a",f+"-close-button",E);j.setAttribute("role","button"),j.setAttribute("aria-label","Close popup"),j.href="#close",j.innerHTML='<span aria-hidden="true">&#215;</span>',Kn(j,"click",function(mt){_e(mt),this.close()},this)}},_updateLayout:function(){var f=this._contentNode,E=f.style;E.width="",E.whiteSpace="nowrap";var D=f.offsetWidth;D=Math.min(D,this.options.maxWidth),D=Math.max(D,this.options.minWidth),E.width=D+1+"px",E.whiteSpace="",E.height="";var mt=this.options.maxHeight,Ft="leaflet-popup-scrolled";mt&&f.offsetHeight>mt?(E.height=mt+"px",An(f,Ft)):jr(f,Ft),this._containerWidth=this._container.offsetWidth},_animateZoom:function(f){var E=this._map._latLngToNewLayerPoint(this._latlng,f.zoom,f.center),D=this._getAnchor();Xn(this._container,E.add(D))},_adjustPan:function(){if(this.options.autoPan){if(this._map._panAnim&&this._map._panAnim.stop(),this._autopanning)return void(this._autopanning=!1);var f=this._map,E=parseInt(Ra(this._container,"marginBottom"),10)||0,D=this._container.offsetHeight+E,j=this._containerWidth,mt=new yt(this._containerLeft,-D-this._containerBottom);mt._add(Cs(this._container));var Ft=f.layerPointToContainerPoint(mt),ce=xt(this.options.autoPanPadding),ye=xt(this.options.autoPanPaddingTopLeft||ce),Ve=xt(this.options.autoPanPaddingBottomRight||ce),sn=f.getSize(),bn=0,Pn=0;Ft.x+j+Ve.x>sn.x&&(bn=Ft.x+j-sn.x+Ve.x),Ft.x-bn-ye.x<0&&(bn=Ft.x-ye.x),Ft.y+D+Ve.y>sn.y&&(Pn=Ft.y+D-sn.y+Ve.y),Ft.y-Pn-ye.y<0&&(Pn=Ft.y-ye.y),(bn||Pn)&&(this.options.keepInView&&(this._autopanning=!0),f.fire("autopanstart").panBy([bn,Pn]))}},_getAnchor:function(){return xt(this._source&&this._source._getPopupAnchor?this._source._getPopupAnchor():[0,0])}});ae.mergeOptions({closePopupOnClick:!0}),ae.include({openPopup:function(f,E,D){return this._initOverlay(hs,f,E,D).openOn(this),this},closePopup:function(f){return(f=arguments.length?f:this._popup)&&f.close(),this}}),Vo.include({bindPopup:function(f,E){return this._popup=this._initOverlay(hs,this._popup,f,E),this._popupHandlersAdded||(this.on({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this.off({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!1,this._popup=null),this},openPopup:function(f){return this._popup&&(this instanceof Jo||(this._popup._source=this),this._popup._prepareOpen(f||this._latlng)&&this._popup.openOn(this._map)),this},closePopup:function(){return this._popup&&this._popup.close(),this},togglePopup:function(){return this._popup&&this._popup.toggle(this),this},isPopupOpen:function(){return!!this._popup&&this._popup.isOpen()},setPopupContent:function(f){return this._popup&&this._popup.setContent(f),this},getPopup:function(){return this._popup},_openPopup:function(f){if(this._popup&&this._map){z(f);var E=f.layer||f.target;if(this._popup._source===E&&!(E instanceof su))return void(this._map.hasLayer(this._popup)?this.closePopup():this.openPopup(f.latlng));this._popup._source=E,this.openPopup(f.latlng)}},_movePopup:function(f){this._popup.setLatLng(f.latlng)},_onKeyPress:function(f){13===f.originalEvent.keyCode&&this._openPopup(f)}});var ca=So.extend({options:{pane:"tooltipPane",offset:[0,0],direction:"auto",permanent:!1,sticky:!1,opacity:.9},onAdd:function(f){So.prototype.onAdd.call(this,f),this.setOpacity(this.options.opacity),f.fire("tooltipopen",{tooltip:this}),this._source&&(this.addEventParent(this._source),this._source.fire("tooltipopen",{tooltip:this},!0))},onRemove:function(f){So.prototype.onRemove.call(this,f),f.fire("tooltipclose",{tooltip:this}),this._source&&(this.removeEventParent(this._source),this._source.fire("tooltipclose",{tooltip:this},!0))},getEvents:function(){var f=So.prototype.getEvents.call(this);return this.options.permanent||(f.preclick=this.close),f},_initLayout:function(){this._contentNode=this._container=$r("div","leaflet-tooltip "+(this.options.className||"")+" leaflet-zoom-"+(this._zoomAnimated?"animated":"hide")),this._container.setAttribute("role","tooltip"),this._container.setAttribute("id","leaflet-tooltip-"+R(this))},_updateLayout:function(){},_adjustPan:function(){},_setPosition:function(f){var E,D,j=this._map,mt=this._container,Ft=j.latLngToContainerPoint(j.getCenter()),ce=j.layerPointToContainerPoint(f),ye=this.options.direction,Ve=mt.offsetWidth,sn=mt.offsetHeight,bn=xt(this.options.offset),Pn=this._getAnchor();"top"===ye?(E=Ve/2,D=sn):"bottom"===ye?(E=Ve/2,D=0):"center"===ye?(E=Ve/2,D=sn/2):"right"===ye?(E=0,D=sn/2):"left"===ye?(E=Ve,D=sn/2):ce.x<Ft.x?(ye="right",E=0,D=sn/2):(ye="left",E=Ve+2*(bn.x+Pn.x),D=sn/2),f=f.subtract(xt(E,D,!0)).add(bn).add(Pn),jr(mt,"leaflet-tooltip-right"),jr(mt,"leaflet-tooltip-left"),jr(mt,"leaflet-tooltip-top"),jr(mt,"leaflet-tooltip-bottom"),An(mt,"leaflet-tooltip-"+ye),Xn(mt,f)},_updatePosition:function(){var f=this._map.latLngToLayerPoint(this._latlng);this._setPosition(f)},setOpacity:function(f){this.options.opacity=f,this._container&&nr(this._container,f)},_animateZoom:function(f){var E=this._map._latLngToNewLayerPoint(this._latlng,f.zoom,f.center);this._setPosition(E)},_getAnchor:function(){return xt(this._source&&this._source._getTooltipAnchor&&!this.options.sticky?this._source._getTooltipAnchor():[0,0])}});ae.include({openTooltip:function(f,E,D){return this._initOverlay(ca,f,E,D).openOn(this),this},closeTooltip:function(f){return f.close(),this}}),Vo.include({bindTooltip:function(f,E){return this._tooltip&&this.isTooltipOpen()&&this.unbindTooltip(),this._tooltip=this._initOverlay(ca,this._tooltip,f,E),this._initTooltipInteractions(),this._tooltip.options.permanent&&this._map&&this._map.hasLayer(this)&&this.openTooltip(),this},unbindTooltip:function(){return this._tooltip&&(this._initTooltipInteractions(!0),this.closeTooltip(),this._tooltip=null),this},_initTooltipInteractions:function(f){if(f||!this._tooltipHandlersAdded){var E=f?"off":"on",D={remove:this.closeTooltip,move:this._moveTooltip};this._tooltip.options.permanent?D.add=this._openTooltip:(D.mouseover=this._openTooltip,D.mouseout=this.closeTooltip,D.click=this._openTooltip,this._map?this._addFocusListeners():D.add=this._addFocusListeners),this._tooltip.options.sticky&&(D.mousemove=this._moveTooltip),this[E](D),this._tooltipHandlersAdded=!f}},openTooltip:function(f){return this._tooltip&&(this instanceof Jo||(this._tooltip._source=this),this._tooltip._prepareOpen(f)&&(this._tooltip.openOn(this._map),this.getElement?this._setAriaDescribedByOnLayer(this):this.eachLayer&&this.eachLayer(this._setAriaDescribedByOnLayer,this))),this},closeTooltip:function(){if(this._tooltip)return this._tooltip.close()},toggleTooltip:function(){return this._tooltip&&this._tooltip.toggle(this),this},isTooltipOpen:function(){return this._tooltip.isOpen()},setTooltipContent:function(f){return this._tooltip&&this._tooltip.setContent(f),this},getTooltip:function(){return this._tooltip},_addFocusListeners:function(){this.getElement?this._addFocusListenersOnLayer(this):this.eachLayer&&this.eachLayer(this._addFocusListenersOnLayer,this)},_addFocusListenersOnLayer:function(f){var E="function"==typeof f.getElement&&f.getElement();E&&(Kn(E,"focus",function(){this._tooltip._source=f,this.openTooltip()},this),Kn(E,"blur",this.closeTooltip,this))},_setAriaDescribedByOnLayer:function(f){var E="function"==typeof f.getElement&&f.getElement();E&&E.setAttribute("aria-describedby",this._tooltip._container.id)},_openTooltip:function(f){if(this._tooltip&&this._map){if(this._map.dragging&&this._map.dragging.moving()&&!this._openOnceFlag){this._openOnceFlag=!0;var E=this;return void this._map.once("moveend",function(){E._openOnceFlag=!1,E._openTooltip(f)})}this._tooltip._source=f.layer||f.target,this.openTooltip(this._tooltip.options.sticky?f.latlng:void 0)}},_moveTooltip:function(f){var D,j,E=f.latlng;this._tooltip.options.sticky&&f.originalEvent&&(D=this._map.mouseEventToContainerPoint(f.originalEvent),j=this._map.containerPointToLayerPoint(D),E=this._map.layerPointToLatLng(j)),this._tooltip.setLatLng(E)}});var Il=Mo.extend({options:{iconSize:[12,12],html:!1,bgPos:null,className:"leaflet-div-icon"},createIcon:function(f){var E=f&&"DIV"===f.tagName?f:document.createElement("div"),D=this.options;if(D.html instanceof Element?(fu(E),E.appendChild(D.html)):E.innerHTML=!1!==D.html?D.html:"",D.bgPos){var j=xt(D.bgPos);E.style.backgroundPosition=-j.x+"px "+-j.y+"px"}return this._setIconStyles(E,"icon"),E},createShadow:function(){return null}});Mo.Default=la;var Ho=Vo.extend({options:{tileSize:256,opacity:1,updateWhenIdle:Dn.mobile,updateWhenZooming:!0,updateInterval:200,zIndex:1,bounds:null,minZoom:0,maxZoom:void 0,maxNativeZoom:void 0,minNativeZoom:void 0,noWrap:!1,pane:"tilePane",className:"",keepBuffer:2},initialize:function(f){it(this,f)},onAdd:function(){this._initContainer(),this._levels={},this._tiles={},this._resetView()},beforeAdd:function(f){f._addZoomLimit(this)},onRemove:function(f){this._removeAllTiles(),pr(this._container),f._removeZoomLimit(this),this._container=null,this._tileZoom=void 0},bringToFront:function(){return this._map&&(Xs(this._container),this._setAutoZIndex(Math.max)),this},bringToBack:function(){return this._map&&(Ga(this._container),this._setAutoZIndex(Math.min)),this},getContainer:function(){return this._container},setOpacity:function(f){return this.options.opacity=f,this._updateOpacity(),this},setZIndex:function(f){return this.options.zIndex=f,this._updateZIndex(),this},isLoading:function(){return this._loading},redraw:function(){if(this._map){this._removeAllTiles();var f=this._clampZoom(this._map.getZoom());f!==this._tileZoom&&(this._tileZoom=f,this._updateLevels()),this._update()}return this},getEvents:function(){var f={viewprereset:this._invalidateAll,viewreset:this._resetView,zoom:this._resetView,moveend:this._onMoveEnd};return this.options.updateWhenIdle||(this._onMove||(this._onMove=W(this._onMoveEnd,this.options.updateInterval,this)),f.move=this._onMove),this._zoomAnimated&&(f.zoomanim=this._animateZoom),f},createTile:function(){return document.createElement("div")},getTileSize:function(){var f=this.options.tileSize;return f instanceof yt?f:new yt(f,f)},_updateZIndex:function(){this._container&&null!=this.options.zIndex&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(f){for(var Ft,E=this.getPane().children,D=-f(-1/0,1/0),j=0,mt=E.length;j<mt;j++)Ft=E[j].style.zIndex,E[j]!==this._container&&Ft&&(D=f(D,+Ft));isFinite(D)&&(this.options.zIndex=D+f(-1,1),this._updateZIndex())},_updateOpacity:function(){if(this._map&&!Dn.ielt9){nr(this._container,this.options.opacity);var f=+new Date,E=!1,D=!1;for(var j in this._tiles){var mt=this._tiles[j];if(mt.current&&mt.loaded){var Ft=Math.min(1,(f-mt.loaded)/200);nr(mt.el,Ft),Ft<1?E=!0:(mt.active?D=!0:this._onOpaqueTile(mt),mt.active=!0)}}D&&!this._noPrune&&this._pruneTiles(),E&&(P(this._fadeFrame),this._fadeFrame=ot(this._updateOpacity,this))}},_onOpaqueTile:A,_initContainer:function(){this._container||(this._container=$r("div","leaflet-layer "+(this.options.className||"")),this._updateZIndex(),this.options.opacity<1&&this._updateOpacity(),this.getPane().appendChild(this._container))},_updateLevels:function(){var f=this._tileZoom,E=this.options.maxZoom;if(void 0!==f){for(var D in this._levels)D=Number(D),this._levels[D].el.children.length||D===f?(this._levels[D].el.style.zIndex=E-Math.abs(f-D),this._onUpdateLevel(D)):(pr(this._levels[D].el),this._removeTilesAtZoom(D),this._onRemoveLevel(D),delete this._levels[D]);var j=this._levels[f],mt=this._map;return j||((j=this._levels[f]={}).el=$r("div","leaflet-tile-container leaflet-zoom-animated",this._container),j.el.style.zIndex=E,j.origin=mt.project(mt.unproject(mt.getPixelOrigin()),f).round(),j.zoom=f,this._setZoomTransform(j,mt.getCenter(),mt.getZoom()),this._onCreateLevel(j)),this._level=j,j}},_onUpdateLevel:A,_onRemoveLevel:A,_onCreateLevel:A,_pruneTiles:function(){if(this._map){var f,E,D=this._map.getZoom();if(D>this.options.maxZoom||D<this.options.minZoom)return void this._removeAllTiles();for(f in this._tiles)(E=this._tiles[f]).retain=E.current;for(f in this._tiles)if((E=this._tiles[f]).current&&!E.active){var j=E.coords;this._retainParent(j.x,j.y,j.z,j.z-5)||this._retainChildren(j.x,j.y,j.z,j.z+2)}for(f in this._tiles)this._tiles[f].retain||this._removeTile(f)}},_removeTilesAtZoom:function(f){for(var E in this._tiles)this._tiles[E].coords.z===f&&this._removeTile(E)},_removeAllTiles:function(){for(var f in this._tiles)this._removeTile(f)},_invalidateAll:function(){for(var f in this._levels)pr(this._levels[f].el),this._onRemoveLevel(Number(f)),delete this._levels[f];this._removeAllTiles(),this._tileZoom=void 0},_retainParent:function(f,E,D,j){var mt=Math.floor(f/2),Ft=Math.floor(E/2),ce=D-1,ye=new yt(+mt,+Ft);ye.z=+ce;var Ve=this._tileCoordsToKey(ye),sn=this._tiles[Ve];return sn&&sn.active?(sn.retain=!0,!0):(sn&&sn.loaded&&(sn.retain=!0),ce>j&&this._retainParent(mt,Ft,ce,j))},_retainChildren:function(f,E,D,j){for(var mt=2*f;mt<2*f+2;mt++)for(var Ft=2*E;Ft<2*E+2;Ft++){var ce=new yt(mt,Ft);ce.z=D+1;var ye=this._tileCoordsToKey(ce),Ve=this._tiles[ye];Ve&&Ve.active?Ve.retain=!0:(Ve&&Ve.loaded&&(Ve.retain=!0),D+1<j&&this._retainChildren(mt,Ft,D+1,j))}},_resetView:function(f){var E=f&&(f.pinch||f.flyTo);this._setView(this._map.getCenter(),this._map.getZoom(),E,E)},_animateZoom:function(f){this._setView(f.center,f.zoom,!0,f.noUpdate)},_clampZoom:function(f){var E=this.options;return void 0!==E.minNativeZoom&&f<E.minNativeZoom?E.minNativeZoom:void 0!==E.maxNativeZoom&&E.maxNativeZoom<f?E.maxNativeZoom:f},_setView:function(f,E,D,j){var mt=Math.round(E);mt=void 0!==this.options.maxZoom&&mt>this.options.maxZoom||void 0!==this.options.minZoom&&mt<this.options.minZoom?void 0:this._clampZoom(mt),(!j||this.options.updateWhenZooming&&mt!==this._tileZoom)&&(this._tileZoom=mt,this._abortLoading&&this._abortLoading(),this._updateLevels(),this._resetGrid(),void 0!==mt&&this._update(f),D||this._pruneTiles(),this._noPrune=!!D),this._setZoomTransforms(f,E)},_setZoomTransforms:function(f,E){for(var D in this._levels)this._setZoomTransform(this._levels[D],f,E)},_setZoomTransform:function(f,E,D){var j=this._map.getZoomScale(D,f.zoom),mt=f.origin.multiplyBy(j).subtract(this._map._getNewPixelOrigin(E,D)).round();Dn.any3d?ya(f.el,mt,j):Xn(f.el,mt)},_resetGrid:function(){var f=this._map,E=f.options.crs,D=this._tileSize=this.getTileSize(),j=this._tileZoom,mt=this._map.getPixelWorldBounds(this._tileZoom);mt&&(this._globalTileRange=this._pxBoundsToTileRange(mt)),this._wrapX=E.wrapLng&&!this.options.noWrap&&[Math.floor(f.project([0,E.wrapLng[0]],j).x/D.x),Math.ceil(f.project([0,E.wrapLng[1]],j).x/D.y)],this._wrapY=E.wrapLat&&!this.options.noWrap&&[Math.floor(f.project([E.wrapLat[0],0],j).y/D.x),Math.ceil(f.project([E.wrapLat[1],0],j).y/D.y)]},_onMoveEnd:function(){!this._map||this._map._animatingZoom||this._update()},_getTiledPixelBounds:function(f){var E=this._map,D=E._animatingZoom?Math.max(E._animateToZoom,E.getZoom()):E.getZoom(),j=E.getZoomScale(D,this._tileZoom),mt=E.project(f,this._tileZoom).floor(),Ft=E.getSize().divideBy(2*j);return new Mt(mt.subtract(Ft),mt.add(Ft))},_update:function(f){var E=this._map;if(E){var D=this._clampZoom(E.getZoom());if(void 0===f&&(f=E.getCenter()),void 0!==this._tileZoom){var j=this._getTiledPixelBounds(f),mt=this._pxBoundsToTileRange(j),Ft=mt.getCenter(),ce=[],ye=this.options.keepBuffer,Ve=new Mt(mt.getBottomLeft().subtract([ye,-ye]),mt.getTopRight().add([ye,-ye]));if(!(isFinite(mt.min.x)&&isFinite(mt.min.y)&&isFinite(mt.max.x)&&isFinite(mt.max.y)))throw new Error("Attempted to load an infinite number of tiles");for(var sn in this._tiles){var bn=this._tiles[sn].coords;(bn.z!==this._tileZoom||!Ve.contains(new yt(bn.x,bn.y)))&&(this._tiles[sn].current=!1)}if(Math.abs(D-this._tileZoom)>1)return void this._setView(f,D);for(var Pn=mt.min.y;Pn<=mt.max.y;Pn++)for(var Nr=mt.min.x;Nr<=mt.max.x;Nr++){var yo=new yt(Nr,Pn);if(yo.z=this._tileZoom,this._isValidTile(yo)){var Qi=this._tiles[this._tileCoordsToKey(yo)];Qi?Qi.current=!0:ce.push(yo)}}if(ce.sort(function(jo,na){return jo.distanceTo(Ft)-na.distanceTo(Ft)}),0!==ce.length){this._loading||(this._loading=!0,this.fire("loading"));var ro=document.createDocumentFragment();for(Nr=0;Nr<ce.length;Nr++)this._addTile(ce[Nr],ro);this._level.el.appendChild(ro)}}}},_isValidTile:function(f){var E=this._map.options.crs;if(!E.infinite){var D=this._globalTileRange;if(!E.wrapLng&&(f.x<D.min.x||f.x>D.max.x)||!E.wrapLat&&(f.y<D.min.y||f.y>D.max.y))return!1}if(!this.options.bounds)return!0;var j=this._tileCoordsToBounds(f);return Bt(this.options.bounds).overlaps(j)},_keyToBounds:function(f){return this._tileCoordsToBounds(this._keyToTileCoords(f))},_tileCoordsToNwSe:function(f){var E=this._map,D=this.getTileSize(),j=f.scaleBy(D),mt=j.add(D);return[E.unproject(j,f.z),E.unproject(mt,f.z)]},_tileCoordsToBounds:function(f){var E=this._tileCoordsToNwSe(f),D=new re(E[0],E[1]);return this.options.noWrap||(D=this._map.wrapLatLngBounds(D)),D},_tileCoordsToKey:function(f){return f.x+":"+f.y+":"+f.z},_keyToTileCoords:function(f){var E=f.split(":"),D=new yt(+E[0],+E[1]);return D.z=+E[2],D},_removeTile:function(f){var E=this._tiles[f];E&&(pr(E.el),delete this._tiles[f],this.fire("tileunload",{tile:E.el,coords:this._keyToTileCoords(f)}))},_initTile:function(f){An(f,"leaflet-tile");var E=this.getTileSize();f.style.width=E.x+"px",f.style.height=E.y+"px",f.onselectstart=A,f.onmousemove=A,Dn.ielt9&&this.options.opacity<1&&nr(f,this.options.opacity)},_addTile:function(f,E){var D=this._getTilePos(f),j=this._tileCoordsToKey(f),mt=this.createTile(this._wrapCoords(f),q(this._tileReady,this,f));this._initTile(mt),this.createTile.length<2&&ot(q(this._tileReady,this,f,null,mt)),Xn(mt,D),this._tiles[j]={el:mt,coords:f,current:!0},E.appendChild(mt),this.fire("tileloadstart",{tile:mt,coords:f})},_tileReady:function(f,E,D){E&&this.fire("tileerror",{error:E,tile:D,coords:f});var j=this._tileCoordsToKey(f);(D=this._tiles[j])&&(D.loaded=+new Date,this._map._fadeAnimated?(nr(D.el,0),P(this._fadeFrame),this._fadeFrame=ot(this._updateOpacity,this)):(D.active=!0,this._pruneTiles()),E||(An(D.el,"leaflet-tile-loaded"),this.fire("tileload",{tile:D.el,coords:f})),this._noTilesToLoad()&&(this._loading=!1,this.fire("load"),Dn.ielt9||!this._map._fadeAnimated?ot(this._pruneTiles,this):setTimeout(q(this._pruneTiles,this),250)))},_getTilePos:function(f){return f.scaleBy(this.getTileSize()).subtract(this._level.origin)},_wrapCoords:function(f){var E=new yt(this._wrapX?k(f.x,this._wrapX):f.x,this._wrapY?k(f.y,this._wrapY):f.y);return E.z=f.z,E},_pxBoundsToTileRange:function(f){var E=this.getTileSize();return new Mt(f.min.unscaleBy(E).floor(),f.max.unscaleBy(E).ceil().subtract([1,1]))},_noTilesToLoad:function(){for(var f in this._tiles)if(!this._tiles[f].loaded)return!1;return!0}});var ha=Ho.extend({options:{minZoom:0,maxZoom:18,subdomains:"abc",errorTileUrl:"",zoomOffset:0,tms:!1,zoomReverse:!1,detectRetina:!1,crossOrigin:!1,referrerPolicy:!1},initialize:function(f,E){this._url=f,(E=it(this,E)).detectRetina&&Dn.retina&&E.maxZoom>0?(E.tileSize=Math.floor(E.tileSize/2),E.zoomReverse?(E.zoomOffset--,E.minZoom=Math.min(E.maxZoom,E.minZoom+1)):(E.zoomOffset++,E.maxZoom=Math.max(E.minZoom,E.maxZoom-1)),E.minZoom=Math.max(0,E.minZoom)):E.zoomReverse?E.minZoom=Math.min(E.maxZoom,E.minZoom):E.maxZoom=Math.max(E.minZoom,E.maxZoom),"string"==typeof E.subdomains&&(E.subdomains=E.subdomains.split("")),this.on("tileunload",this._onTileRemove)},setUrl:function(f,E){return this._url===f&&void 0===E&&(E=!0),this._url=f,E||this.redraw(),this},createTile:function(f,E){var D=document.createElement("img");return Kn(D,"load",q(this._tileOnLoad,this,E,D)),Kn(D,"error",q(this._tileOnError,this,E,D)),(this.options.crossOrigin||""===this.options.crossOrigin)&&(D.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),"string"==typeof this.options.referrerPolicy&&(D.referrerPolicy=this.options.referrerPolicy),D.alt="",D.src=this.getTileUrl(f),D},getTileUrl:function(f){var E={r:Dn.retina?"@2x":"",s:this._getSubdomain(f),x:f.x,y:f.y,z:this._getZoomForUrl()};if(this._map&&!this._map.options.crs.infinite){var D=this._globalTileRange.max.y-f.y;this.options.tms&&(E.y=D),E["-y"]=D}return st(this._url,V(E,this.options))},_tileOnLoad:function(f,E){Dn.ielt9?setTimeout(q(f,this,null,E),0):f(null,E)},_tileOnError:function(f,E,D){var j=this.options.errorTileUrl;j&&E.getAttribute("src")!==j&&(E.src=j),f(D,E)},_onTileRemove:function(f){f.tile.onload=null},_getZoomForUrl:function(){var f=this._tileZoom;return this.options.zoomReverse&&(f=this.options.maxZoom-f),f+this.options.zoomOffset},_getSubdomain:function(f){var E=Math.abs(f.x+f.y)%this.options.subdomains.length;return this.options.subdomains[E]},_abortLoading:function(){var f,E;for(f in this._tiles)if(this._tiles[f].coords.z!==this._tileZoom&&((E=this._tiles[f].el).onload=A,E.onerror=A,!E.complete)){E.src=lt;var D=this._tiles[f].coords;pr(E),delete this._tiles[f],this.fire("tileabort",{tile:E,coords:D})}},_removeTile:function(f){var E=this._tiles[f];if(E)return E.el.setAttribute("src",lt),Ho.prototype._removeTile.call(this,f)},_tileReady:function(f,E,D){if(this._map&&(!D||D.getAttribute("src")!==lt))return Ho.prototype._tileReady.call(this,f,E,D)}});function no(f,E){return new ha(f,E)}var Kl=ha.extend({defaultWmsParams:{service:"WMS",request:"GetMap",layers:"",styles:"",format:"image/jpeg",transparent:!1,version:"1.1.1"},options:{crs:null,uppercase:!1},initialize:function(f,E){this._url=f;var D=V({},this.defaultWmsParams);for(var j in E)j in this.options||(D[j]=E[j]);var mt=(E=it(this,E)).detectRetina&&Dn.retina?2:1,Ft=this.getTileSize();D.width=Ft.x*mt,D.height=Ft.y*mt,this.wmsParams=D},onAdd:function(f){this._crs=this.options.crs||f.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version),this.wmsParams[this._wmsVersion>=1.3?"crs":"srs"]=this._crs.code,ha.prototype.onAdd.call(this,f)},getTileUrl:function(f){var E=this._tileCoordsToNwSe(f),D=this._crs,j=It(D.project(E[0]),D.project(E[1])),mt=j.min,Ft=j.max,ce=(this._wmsVersion>=1.3&&this._crs===Fs?[mt.y,mt.x,Ft.y,Ft.x]:[mt.x,mt.y,Ft.x,Ft.y]).join(","),ye=ha.prototype.getTileUrl.call(this,f);return ye+bt(this.wmsParams,ye,this.options.uppercase)+(this.options.uppercase?"&BBOX=":"&bbox=")+ce},setParams:function(f,E){return V(this.wmsParams,f),E||this.redraw(),this}});ha.WMS=Kl,no.wms=function Ka(f,E){return new Kl(f,E)};var Yr=Vo.extend({options:{padding:.1},initialize:function(f){it(this,f),R(this),this._layers=this._layers||{}},onAdd:function(){this._container||(this._initContainer(),An(this._container,"leaflet-zoom-animated")),this.getPane().appendChild(this._container),this._update(),this.on("update",this._updatePaths,this)},onRemove:function(){this.off("update",this._updatePaths,this),this._destroyContainer()},getEvents:function(){var f={viewreset:this._reset,zoom:this._onZoom,moveend:this._update,zoomend:this._onZoomEnd};return this._zoomAnimated&&(f.zoomanim=this._onAnimZoom),f},_onAnimZoom:function(f){this._updateTransform(f.center,f.zoom)},_onZoom:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom())},_updateTransform:function(f,E){var D=this._map.getZoomScale(E,this._zoom),j=this._map.getSize().multiplyBy(.5+this.options.padding),mt=this._map.project(this._center,E),Ft=j.multiplyBy(-D).add(mt).subtract(this._map._getNewPixelOrigin(f,E));Dn.any3d?ya(this._container,Ft,D):Xn(this._container,Ft)},_reset:function(){for(var f in this._update(),this._updateTransform(this._center,this._zoom),this._layers)this._layers[f]._reset()},_onZoomEnd:function(){for(var f in this._layers)this._layers[f]._project()},_updatePaths:function(){for(var f in this._layers)this._layers[f]._update()},_update:function(){var f=this.options.padding,E=this._map.getSize(),D=this._map.containerPointToLayerPoint(E.multiplyBy(-f)).round();this._bounds=new Mt(D,D.add(E.multiplyBy(1+2*f)).round()),this._center=this._map.getCenter(),this._zoom=this._map.getZoom()}}),da=Yr.extend({options:{tolerance:0},getEvents:function(){var f=Yr.prototype.getEvents.call(this);return f.viewprereset=this._onViewPreReset,f},_onViewPreReset:function(){this._postponeUpdatePaths=!0},onAdd:function(){Yr.prototype.onAdd.call(this),this._draw()},_initContainer:function(){var f=this._container=document.createElement("canvas");Kn(f,"mousemove",this._onMouseMove,this),Kn(f,"click dblclick mousedown mouseup contextmenu",this._onClick,this),Kn(f,"mouseout",this._handleMouseOut,this),f._leaflet_disable_events=!0,this._ctx=f.getContext("2d")},_destroyContainer:function(){P(this._redrawRequest),delete this._ctx,pr(this._container),br(this._container),delete this._container},_updatePaths:function(){if(!this._postponeUpdatePaths){for(var E in this._redrawBounds=null,this._layers)this._layers[E]._update();this._redraw()}},_update:function(){if(!this._map._animatingZoom||!this._bounds){Yr.prototype._update.call(this);var f=this._bounds,E=this._container,D=f.getSize(),j=Dn.retina?2:1;Xn(E,f.min),E.width=j*D.x,E.height=j*D.y,E.style.width=D.x+"px",E.style.height=D.y+"px",Dn.retina&&this._ctx.scale(2,2),this._ctx.translate(-f.min.x,-f.min.y),this.fire("update")}},_reset:function(){Yr.prototype._reset.call(this),this._postponeUpdatePaths&&(this._postponeUpdatePaths=!1,this._updatePaths())},_initPath:function(f){this._updateDashArray(f),this._layers[R(f)]=f;var E=f._order={layer:f,prev:this._drawLast,next:null};this._drawLast&&(this._drawLast.next=E),this._drawLast=E,this._drawFirst=this._drawFirst||this._drawLast},_addPath:function(f){this._requestRedraw(f)},_removePath:function(f){var E=f._order,D=E.next,j=E.prev;D?D.prev=j:this._drawLast=j,j?j.next=D:this._drawFirst=D,delete f._order,delete this._layers[R(f)],this._requestRedraw(f)},_updatePath:function(f){this._extendRedrawBounds(f),f._project(),f._update(),this._requestRedraw(f)},_updateStyle:function(f){this._updateDashArray(f),this._requestRedraw(f)},_updateDashArray:function(f){if("string"==typeof f.options.dashArray){var j,mt,E=f.options.dashArray.split(/[, ]+/),D=[];for(mt=0;mt<E.length;mt++){if(j=Number(E[mt]),isNaN(j))return;D.push(j)}f.options._dashArray=D}else f.options._dashArray=f.options.dashArray},_requestRedraw:function(f){this._map&&(this._extendRedrawBounds(f),this._redrawRequest=this._redrawRequest||ot(this._redraw,this))},_extendRedrawBounds:function(f){if(f._pxBounds){var E=(f.options.weight||0)+1;this._redrawBounds=this._redrawBounds||new Mt,this._redrawBounds.extend(f._pxBounds.min.subtract([E,E])),this._redrawBounds.extend(f._pxBounds.max.add([E,E]))}},_redraw:function(){this._redrawRequest=null,this._redrawBounds&&(this._redrawBounds.min._floor(),this._redrawBounds.max._ceil()),this._clear(),this._draw(),this._redrawBounds=null},_clear:function(){var f=this._redrawBounds;if(f){var E=f.getSize();this._ctx.clearRect(f.min.x,f.min.y,E.x,E.y)}else this._ctx.save(),this._ctx.setTransform(1,0,0,1,0,0),this._ctx.clearRect(0,0,this._container.width,this._container.height),this._ctx.restore()},_draw:function(){var f,E=this._redrawBounds;if(this._ctx.save(),E){var D=E.getSize();this._ctx.beginPath(),this._ctx.rect(E.min.x,E.min.y,D.x,D.y),this._ctx.clip()}this._drawing=!0;for(var j=this._drawFirst;j;j=j.next)f=j.layer,(!E||f._pxBounds&&f._pxBounds.intersects(E))&&f._updatePath();this._drawing=!1,this._ctx.restore()},_updatePoly:function(f,E){if(this._drawing){var D,j,mt,Ft,ce=f._parts,ye=ce.length,Ve=this._ctx;if(ye){for(Ve.beginPath(),D=0;D<ye;D++){for(j=0,mt=ce[D].length;j<mt;j++)Ve[j?"lineTo":"moveTo"]((Ft=ce[D][j]).x,Ft.y);E&&Ve.closePath()}this._fillStroke(Ve,f)}}},_updateCircle:function(f){if(this._drawing&&!f._empty()){var E=f._point,D=this._ctx,j=Math.max(Math.round(f._radius),1),mt=(Math.max(Math.round(f._radiusY),1)||j)/j;1!==mt&&(D.save(),D.scale(1,mt)),D.beginPath(),D.arc(E.x,E.y/mt,j,0,2*Math.PI,!1),1!==mt&&D.restore(),this._fillStroke(D,f)}},_fillStroke:function(f,E){var D=E.options;D.fill&&(f.globalAlpha=D.fillOpacity,f.fillStyle=D.fillColor||D.color,f.fill(D.fillRule||"evenodd")),D.stroke&&0!==D.weight&&(f.setLineDash&&f.setLineDash(E.options&&E.options._dashArray||[]),f.globalAlpha=D.opacity,f.lineWidth=D.weight,f.strokeStyle=D.color,f.lineCap=D.lineCap,f.lineJoin=D.lineJoin,f.stroke())},_onClick:function(f){for(var D,j,E=this._map.mouseEventToLayerPoint(f),mt=this._drawFirst;mt;mt=mt.next)(D=mt.layer).options.interactive&&D._containsPoint(E)&&("click"!==f.type&&"preclick"!==f.type||!this._map._draggableMoved(D))&&(j=D);this._fireEvent(!!j&&[j],f)},_onMouseMove:function(f){if(this._map&&!this._map.dragging.moving()&&!this._map._animatingZoom){var E=this._map.mouseEventToLayerPoint(f);this._handleMouseHover(f,E)}},_handleMouseOut:function(f){var E=this._hoveredLayer;E&&(jr(this._container,"leaflet-interactive"),this._fireEvent([E],f,"mouseout"),this._hoveredLayer=null,this._mouseHoverThrottled=!1)},_handleMouseHover:function(f,E){if(!this._mouseHoverThrottled){for(var D,j,mt=this._drawFirst;mt;mt=mt.next)(D=mt.layer).options.interactive&&D._containsPoint(E)&&(j=D);j!==this._hoveredLayer&&(this._handleMouseOut(f),j&&(An(this._container,"leaflet-interactive"),this._fireEvent([j],f,"mouseover"),this._hoveredLayer=j)),this._fireEvent(!!this._hoveredLayer&&[this._hoveredLayer],f),this._mouseHoverThrottled=!0,setTimeout(q(function(){this._mouseHoverThrottled=!1},this),32)}},_fireEvent:function(f,E,D){this._map._fireDOMEvent(E,D||E.type,f)},_bringToFront:function(f){var E=f._order;if(E){var D=E.next,j=E.prev;if(!D)return;D.prev=j,j?j.next=D:D&&(this._drawFirst=D),E.prev=this._drawLast,this._drawLast.next=E,E.next=null,this._drawLast=E,this._requestRedraw(f)}},_bringToBack:function(f){var E=f._order;if(E){var D=E.next,j=E.prev;if(!j)return;j.next=D,D?D.prev=j:j&&(this._drawLast=j),E.prev=null,E.next=this._drawFirst,this._drawFirst.prev=E,this._drawFirst=E,this._requestRedraw(f)}}});function vu(f){return Dn.canvas?new da(f):null}var or=function(){try{return document.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(f){return document.createElement("<lvml:"+f+' class="lvml">')}}catch{}return function(f){return document.createElement("<"+f+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}(),ws={_initContainer:function(){this._container=$r("div","leaflet-vml-container")},_update:function(){this._map._animatingZoom||(Yr.prototype._update.call(this),this.fire("update"))},_initPath:function(f){var E=f._container=or("shape");An(E,"leaflet-vml-shape "+(this.options.className||"")),E.coordsize="1 1",f._path=or("path"),E.appendChild(f._path),this._updateStyle(f),this._layers[R(f)]=f},_addPath:function(f){var E=f._container;this._container.appendChild(E),f.options.interactive&&f.addInteractiveTarget(E)},_removePath:function(f){var E=f._container;pr(E),f.removeInteractiveTarget(E),delete this._layers[R(f)]},_updateStyle:function(f){var E=f._stroke,D=f._fill,j=f.options,mt=f._container;mt.stroked=!!j.stroke,mt.filled=!!j.fill,j.stroke?(E||(E=f._stroke=or("stroke")),mt.appendChild(E),E.weight=j.weight+"px",E.color=j.color,E.opacity=j.opacity,E.dashStyle=j.dashArray?et(j.dashArray)?j.dashArray.join(" "):j.dashArray.replace(/( *, *)/g," "):"",E.endcap=j.lineCap.replace("butt","flat"),E.joinstyle=j.lineJoin):E&&(mt.removeChild(E),f._stroke=null),j.fill?(D||(D=f._fill=or("fill")),mt.appendChild(D),D.color=j.fillColor||j.color,D.opacity=j.fillOpacity):D&&(mt.removeChild(D),f._fill=null)},_updateCircle:function(f){var E=f._point.round(),D=Math.round(f._radius),j=Math.round(f._radiusY||D);this._setPath(f,f._empty()?"M0 0":"AL "+E.x+","+E.y+" "+D+","+j+" 0,23592600")},_setPath:function(f,E){f._path.v=E},_bringToFront:function(f){Xs(f._container)},_bringToBack:function(f){Ga(f._container)}},Tr=Dn.vml?or:ne,ri=Yr.extend({_initContainer:function(){this._container=Tr("svg"),this._container.setAttribute("pointer-events","none"),this._rootGroup=Tr("g"),this._container.appendChild(this._rootGroup)},_destroyContainer:function(){pr(this._container),br(this._container),delete this._container,delete this._rootGroup,delete this._svgSize},_update:function(){if(!this._map._animatingZoom||!this._bounds){Yr.prototype._update.call(this);var f=this._bounds,E=f.getSize(),D=this._container;(!this._svgSize||!this._svgSize.equals(E))&&(this._svgSize=E,D.setAttribute("width",E.x),D.setAttribute("height",E.y)),Xn(D,f.min),D.setAttribute("viewBox",[f.min.x,f.min.y,E.x,E.y].join(" ")),this.fire("update")}},_initPath:function(f){var E=f._path=Tr("path");f.options.className&&An(E,f.options.className),f.options.interactive&&An(E,"leaflet-interactive"),this._updateStyle(f),this._layers[R(f)]=f},_addPath:function(f){this._rootGroup||this._initContainer(),this._rootGroup.appendChild(f._path),f.addInteractiveTarget(f._path)},_removePath:function(f){pr(f._path),f.removeInteractiveTarget(f._path),delete this._layers[R(f)]},_updatePath:function(f){f._project(),f._update()},_updateStyle:function(f){var E=f._path,D=f.options;E&&(D.stroke?(E.setAttribute("stroke",D.color),E.setAttribute("stroke-opacity",D.opacity),E.setAttribute("stroke-width",D.weight),E.setAttribute("stroke-linecap",D.lineCap),E.setAttribute("stroke-linejoin",D.lineJoin),D.dashArray?E.setAttribute("stroke-dasharray",D.dashArray):E.removeAttribute("stroke-dasharray"),D.dashOffset?E.setAttribute("stroke-dashoffset",D.dashOffset):E.removeAttribute("stroke-dashoffset")):E.setAttribute("stroke","none"),D.fill?(E.setAttribute("fill",D.fillColor||D.color),E.setAttribute("fill-opacity",D.fillOpacity),E.setAttribute("fill-rule",D.fillRule||"evenodd")):E.setAttribute("fill","none"))},_updatePoly:function(f,E){this._setPath(f,pe(f._parts,E))},_updateCircle:function(f){var E=f._point,D=Math.max(Math.round(f._radius),1),mt="a"+D+","+(Math.max(Math.round(f._radiusY),1)||D)+" 0 1,0 ",Ft=f._empty()?"M0 0":"M"+(E.x-D)+","+E.y+mt+2*D+",0 "+mt+2*-D+",0 ";this._setPath(f,Ft)},_setPath:function(f,E){f._path.setAttribute("d",E)},_bringToFront:function(f){Xs(f._path)},_bringToBack:function(f){Ga(f._path)}});function fs(f){return Dn.svg||Dn.vml?new ri(f):null}Dn.vml&&ri.include(ws),ae.include({getRenderer:function(f){var E=f.options.renderer||this._getPaneRenderer(f.options.pane)||this.options.renderer||this._renderer;return E||(E=this._renderer=this._createRenderer()),this.hasLayer(E)||this.addLayer(E),E},_getPaneRenderer:function(f){if("overlayPane"===f||void 0===f)return!1;var E=this._paneRenderers[f];return void 0===E&&(E=this._createRenderer({pane:f}),this._paneRenderers[f]=E),E},_createRenderer:function(f){return this.options.preferCanvas&&vu(f)||fs(f)}});var gt=ka.extend({initialize:function(f,E){ka.prototype.initialize.call(this,this._boundsToLatLngs(f),E)},setBounds:function(f){return this.setLatLngs(this._boundsToLatLngs(f))},_boundsToLatLngs:function(f){return[(f=Bt(f)).getSouthWest(),f.getNorthWest(),f.getNorthEast(),f.getSouthEast()]}});ri.create=Tr,ri.pointsToPath=pe,Ha.geometryToLayer=pl,Ha.coordsToLatLng=Wo,Ha.coordsToLatLngs=Ns,Ha.latLngToCoords=Tu,Ha.latLngsToCoords=Bs,Ha.getFeature=Go,Ha.asFeature=Ca,ae.mergeOptions({boxZoom:!0});var _t=tn.extend({initialize:function(f){this._map=f,this._container=f._container,this._pane=f._panes.overlayPane,this._resetStateTimeout=0,f.on("unload",this._destroy,this)},addHooks:function(){Kn(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){br(this._container,"mousedown",this._onMouseDown,this)},moved:function(){return this._moved},_destroy:function(){pr(this._pane),delete this._pane},_resetState:function(){this._resetStateTimeout=0,this._moved=!1},_clearDeferredResetState:function(){0!==this._resetStateTimeout&&(clearTimeout(this._resetStateTimeout),this._resetStateTimeout=0)},_onMouseDown:function(f){if(!f.shiftKey||1!==f.which&&1!==f.button)return!1;this._clearDeferredResetState(),this._resetState(),Yi(),Fn(),this._startPoint=this._map.mouseEventToContainerPoint(f),Kn(document,{contextmenu:z,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseMove:function(f){this._moved||(this._moved=!0,this._box=$r("div","leaflet-zoom-box",this._container),An(this._container,"leaflet-crosshair"),this._map.fire("boxzoomstart")),this._point=this._map.mouseEventToContainerPoint(f);var E=new Mt(this._point,this._startPoint),D=E.getSize();Xn(this._box,E.min),this._box.style.width=D.x+"px",this._box.style.height=D.y+"px"},_finish:function(){this._moved&&(pr(this._box),jr(this._container,"leaflet-crosshair")),La(),Ds(),br(document,{contextmenu:z,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseUp:function(f){if((1===f.which||1===f.button)&&(this._finish(),this._moved)){this._clearDeferredResetState(),this._resetStateTimeout=setTimeout(q(this._resetState,this),0);var E=new re(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point));this._map.fitBounds(E).fire("boxzoomend",{boxZoomBounds:E})}},_onKeyDown:function(f){27===f.keyCode&&(this._finish(),this._clearDeferredResetState(),this._resetState())}});ae.addInitHook("addHandler","boxZoom",_t),ae.mergeOptions({doubleClickZoom:!0});var Nt=tn.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(f){var E=this._map,D=E.getZoom(),j=E.options.zoomDelta,mt=f.originalEvent.shiftKey?D-j:D+j;"center"===E.options.doubleClickZoom?E.setZoom(mt):E.setZoomAround(f.containerPoint,mt)}});ae.addInitHook("addHandler","doubleClickZoom",Nt),ae.mergeOptions({dragging:!0,inertia:!0,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,easeLinearity:.2,worldCopyJump:!1,maxBoundsViscosity:0});var Kt=tn.extend({addHooks:function(){if(!this._draggable){var f=this._map;this._draggable=new qi(f._mapPane,f._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),this._draggable.on("predrag",this._onPreDragLimit,this),f.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDragWrap,this),f.on("zoomend",this._onZoomEnd,this),f.whenReady(this._onZoomEnd,this))}An(this._map._container,"leaflet-grab leaflet-touch-drag"),this._draggable.enable(),this._positions=[],this._times=[]},removeHooks:function(){jr(this._map._container,"leaflet-grab"),jr(this._map._container,"leaflet-touch-drag"),this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},moving:function(){return this._draggable&&this._draggable._moving},_onDragStart:function(){var f=this._map;if(f._stop(),this._map.options.maxBounds&&this._map.options.maxBoundsViscosity){var E=Bt(this._map.options.maxBounds);this._offsetLimit=It(this._map.latLngToContainerPoint(E.getNorthWest()).multiplyBy(-1),this._map.latLngToContainerPoint(E.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),this._viscosity=Math.min(1,Math.max(0,this._map.options.maxBoundsViscosity))}else this._offsetLimit=null;f.fire("movestart").fire("dragstart"),f.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(f){if(this._map.options.inertia){var E=this._lastTime=+new Date,D=this._lastPos=this._draggable._absPos||this._draggable._newPos;this._positions.push(D),this._times.push(E),this._prunePositions(E)}this._map.fire("move",f).fire("drag",f)},_prunePositions:function(f){for(;this._positions.length>1&&f-this._times[0]>50;)this._positions.shift(),this._times.shift()},_onZoomEnd:function(){var f=this._map.getSize().divideBy(2),E=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=E.subtract(f).x,this._worldWidth=this._map.getPixelWorldBounds().getSize().x},_viscousLimit:function(f,E){return f-(f-E)*this._viscosity},_onPreDragLimit:function(){if(this._viscosity&&this._offsetLimit){var f=this._draggable._newPos.subtract(this._draggable._startPos),E=this._offsetLimit;f.x<E.min.x&&(f.x=this._viscousLimit(f.x,E.min.x)),f.y<E.min.y&&(f.y=this._viscousLimit(f.y,E.min.y)),f.x>E.max.x&&(f.x=this._viscousLimit(f.x,E.max.x)),f.y>E.max.y&&(f.y=this._viscousLimit(f.y,E.max.y)),this._draggable._newPos=this._draggable._startPos.add(f)}},_onPreDragWrap:function(){var f=this._worldWidth,E=Math.round(f/2),D=this._initialWorldOffset,j=this._draggable._newPos.x,mt=(j-E+D)%f+E-D,Ft=(j+E+D)%f-E-D,ce=Math.abs(mt+D)<Math.abs(Ft+D)?mt:Ft;this._draggable._absPos=this._draggable._newPos.clone(),this._draggable._newPos.x=ce},_onDragEnd:function(f){var E=this._map,D=E.options,j=!D.inertia||f.noInertia||this._times.length<2;if(E.fire("dragend",f),j)E.fire("moveend");else{this._prunePositions(+new Date);var mt=this._lastPos.subtract(this._positions[0]),ce=D.easeLinearity,ye=mt.multiplyBy(ce/((this._lastTime-this._times[0])/1e3)),Ve=ye.distanceTo([0,0]),sn=Math.min(D.inertiaMaxSpeed,Ve),bn=ye.multiplyBy(sn/Ve),Pn=sn/(D.inertiaDeceleration*ce),Nr=bn.multiplyBy(-Pn/2).round();Nr.x||Nr.y?(Nr=E._limitOffset(Nr,E.options.maxBounds),ot(function(){E.panBy(Nr,{duration:Pn,easeLinearity:ce,noMoveStart:!0,animate:!0})})):E.fire("moveend")}}});ae.addInitHook("addHandler","dragging",Kt),ae.mergeOptions({keyboard:!0,keyboardPanDelta:80});var de=tn.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,54,173]},initialize:function(f){this._map=f,this._setPanDelta(f.options.keyboardPanDelta),this._setZoomDelta(f.options.zoomDelta)},addHooks:function(){var f=this._map._container;f.tabIndex<=0&&(f.tabIndex="0"),Kn(f,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.on({focus:this._addHooks,blur:this._removeHooks},this)},removeHooks:function(){this._removeHooks(),br(this._map._container,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.off({focus:this._addHooks,blur:this._removeHooks},this)},_onMouseDown:function(){if(!this._focused){var f=document.body,E=document.documentElement,D=f.scrollTop||E.scrollTop,j=f.scrollLeft||E.scrollLeft;this._map._container.focus(),window.scrollTo(j,D)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanDelta:function(f){var j,mt,E=this._panKeys={},D=this.keyCodes;for(j=0,mt=D.left.length;j<mt;j++)E[D.left[j]]=[-1*f,0];for(j=0,mt=D.right.length;j<mt;j++)E[D.right[j]]=[f,0];for(j=0,mt=D.down.length;j<mt;j++)E[D.down[j]]=[0,f];for(j=0,mt=D.up.length;j<mt;j++)E[D.up[j]]=[0,-1*f]},_setZoomDelta:function(f){var j,mt,E=this._zoomKeys={},D=this.keyCodes;for(j=0,mt=D.zoomIn.length;j<mt;j++)E[D.zoomIn[j]]=f;for(j=0,mt=D.zoomOut.length;j<mt;j++)E[D.zoomOut[j]]=-f},_addHooks:function(){Kn(document,"keydown",this._onKeyDown,this)},_removeHooks:function(){br(document,"keydown",this._onKeyDown,this)},_onKeyDown:function(f){if(!(f.altKey||f.ctrlKey||f.metaKey)){var j,E=f.keyCode,D=this._map;if(E in this._panKeys){if(!D._panAnim||!D._panAnim._inProgress)if(j=this._panKeys[E],f.shiftKey&&(j=xt(j).multiplyBy(3)),D.options.maxBounds&&(j=D._limitOffset(xt(j),D.options.maxBounds)),D.options.worldCopyJump){var mt=D.wrapLatLng(D.unproject(D.project(D.getCenter()).add(j)));D.panTo(mt)}else D.panBy(j)}else if(E in this._zoomKeys)D.setZoom(D.getZoom()+(f.shiftKey?3:1)*this._zoomKeys[E]);else{if(27!==E||!D._popup||!D._popup.options.closeOnEscapeKey)return;D.closePopup()}z(f)}}});ae.addInitHook("addHandler","keyboard",de),ae.mergeOptions({scrollWheelZoom:!0,wheelDebounceTime:40,wheelPxPerZoomLevel:60});var Ee=tn.extend({addHooks:function(){Kn(this._map._container,"wheel",this._onWheelScroll,this),this._delta=0},removeHooks:function(){br(this._map._container,"wheel",this._onWheelScroll,this)},_onWheelScroll:function(f){var E=wt(f),D=this._map.options.wheelDebounceTime;this._delta+=E,this._lastMousePos=this._map.mouseEventToContainerPoint(f),this._startTime||(this._startTime=+new Date);var j=Math.max(D-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(q(this._performZoom,this),j),z(f)},_performZoom:function(){var f=this._map,E=f.getZoom(),D=this._map.options.zoomSnap||0;f._stop();var mt=4*Math.log(2/(1+Math.exp(-Math.abs(this._delta/(4*this._map.options.wheelPxPerZoomLevel)))))/Math.LN2,Ft=D?Math.ceil(mt/D)*D:mt,ce=f._limitZoom(E+(this._delta>0?Ft:-Ft))-E;this._delta=0,this._startTime=null,ce&&("center"===f.options.scrollWheelZoom?f.setZoom(E+ce):f.setZoomAround(this._lastMousePos,E+ce))}});ae.addInitHook("addHandler","scrollWheelZoom",Ee);ae.mergeOptions({tapHold:Dn.touchNative&&Dn.safari&&Dn.mobile,tapTolerance:15});var xe=tn.extend({addHooks:function(){Kn(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){br(this._map._container,"touchstart",this._onDown,this)},_onDown:function(f){if(clearTimeout(this._holdTimeout),1===f.touches.length){var E=f.touches[0];this._startPos=this._newPos=new yt(E.clientX,E.clientY),this._holdTimeout=setTimeout(q(function(){this._cancel(),this._isTapValid()&&(Kn(document,"touchend",_e),Kn(document,"touchend touchcancel",this._cancelClickPrevent),this._simulateEvent("contextmenu",E))},this),600),Kn(document,"touchend touchcancel contextmenu",this._cancel,this),Kn(document,"touchmove",this._onMove,this)}},_cancelClickPrevent:function f(){br(document,"touchend",_e),br(document,"touchend touchcancel",f)},_cancel:function(){clearTimeout(this._holdTimeout),br(document,"touchend touchcancel contextmenu",this._cancel,this),br(document,"touchmove",this._onMove,this)},_onMove:function(f){var E=f.touches[0];this._newPos=new yt(E.clientX,E.clientY)},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_simulateEvent:function(f,E){var D=new MouseEvent(f,{bubbles:!0,cancelable:!0,view:window,screenX:E.screenX,screenY:E.screenY,clientX:E.clientX,clientY:E.clientY});D._simulated=!0,E.target.dispatchEvent(D)}});ae.addInitHook("addHandler","tapHold",xe),ae.mergeOptions({touchZoom:Dn.touch,bounceAtZoomLimits:!0});var Pe=tn.extend({addHooks:function(){An(this._map._container,"leaflet-touch-zoom"),Kn(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){jr(this._map._container,"leaflet-touch-zoom"),br(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(f){var E=this._map;if(f.touches&&2===f.touches.length&&!E._animatingZoom&&!this._zooming){var D=E.mouseEventToContainerPoint(f.touches[0]),j=E.mouseEventToContainerPoint(f.touches[1]);this._centerPoint=E.getSize()._divideBy(2),this._startLatLng=E.containerPointToLatLng(this._centerPoint),"center"!==E.options.touchZoom&&(this._pinchStartLatLng=E.containerPointToLatLng(D.add(j)._divideBy(2))),this._startDist=D.distanceTo(j),this._startZoom=E.getZoom(),this._moved=!1,this._zooming=!0,E._stop(),Kn(document,"touchmove",this._onTouchMove,this),Kn(document,"touchend touchcancel",this._onTouchEnd,this),_e(f)}},_onTouchMove:function(f){if(f.touches&&2===f.touches.length&&this._zooming){var E=this._map,D=E.mouseEventToContainerPoint(f.touches[0]),j=E.mouseEventToContainerPoint(f.touches[1]),mt=D.distanceTo(j)/this._startDist;if(this._zoom=E.getScaleZoom(mt,this._startZoom),!E.options.bounceAtZoomLimits&&(this._zoom<E.getMinZoom()&&mt<1||this._zoom>E.getMaxZoom()&&mt>1)&&(this._zoom=E._limitZoom(this._zoom)),"center"===E.options.touchZoom){if(this._center=this._startLatLng,1===mt)return}else{var Ft=D._add(j)._divideBy(2)._subtract(this._centerPoint);if(1===mt&&0===Ft.x&&0===Ft.y)return;this._center=E.unproject(E.project(this._pinchStartLatLng,this._zoom).subtract(Ft),this._zoom)}this._moved||(E._moveStart(!0,!1),this._moved=!0),P(this._animRequest);var ce=q(E._move,E,this._center,this._zoom,{pinch:!0,round:!1},void 0);this._animRequest=ot(ce,this,!0),_e(f)}},_onTouchEnd:function(){this._moved&&this._zooming?(this._zooming=!1,P(this._animRequest),br(document,"touchmove",this._onTouchMove,this),br(document,"touchend touchcancel",this._onTouchEnd,this),this._map.options.zoomAnimation?this._map._animateZoom(this._center,this._map._limitZoom(this._zoom),!0,this._map.options.zoomSnap):this._map._resetView(this._center,this._map._limitZoom(this._zoom))):this._zooming=!1}});ae.addInitHook("addHandler","touchZoom",Pe),ae.BoxZoom=_t,ae.DoubleClickZoom=Nt,ae.Drag=Kt,ae.Keyboard=de,ae.ScrollWheelZoom=Ee,ae.TapHold=xe,ae.TouchZoom=Pe,y.Bounds=Mt,y.Browser=Dn,y.CRS=se,y.Canvas=da,y.Circle=Uo,y.CircleMarker=Ys,y.Class=nt,y.Control=Ye,y.DivIcon=Il,y.DivOverlay=So,y.DomEvent=Yt,y.DomUtil=ai,y.Draggable=qi,y.Evented=Ct,y.FeatureGroup=Jo,y.GeoJSON=Ha,y.GridLayer=Ho,y.Handler=tn,y.Icon=Mo,y.ImageOverlay=wa,y.LatLng=ee,y.LatLngBounds=re,y.Layer=Vo,y.LayerGroup=_a,y.LineUtil=Br,y.Map=ae,y.Marker=cs,y.Mixin=Su,y.Path=su,y.Point=yt,y.PolyUtil=Rc,y.Polygon=ka,y.Polyline=mi,y.Popup=hs,y.PosAnimation=kt,y.Projection=iu,y.Rectangle=gt,y.Renderer=Yr,y.SVG=ri,y.SVGOverlay=Fa,y.TileLayer=ha,y.Tooltip=ca,y.Transformation=Ue,y.Util=at,y.VideoOverlay=ea,y.bind=q,y.bounds=It,y.canvas=vu,y.circle=function Ea(f,E,D){return new Uo(f,E,D)},y.circleMarker=function $s(f,E){return new Ys(f,E)},y.control=$e,y.divIcon=function Au(f){return new Il(f)},y.extend=V,y.featureGroup=function(f,E){return new Jo(f,E)},y.geoJSON=gu,y.geoJson=ja,y.gridLayer=function ds(f){return new Ho(f)},y.icon=function Mn(f){return new Mo(f)},y.imageOverlay=function(f,E,D){return new wa(f,E,D)},y.latLng=jt,y.latLngBounds=Bt,y.layerGroup=function(f,E){return new _a(f,E)},y.map=function nn(f,E){return new ae(f,E)},y.marker=function mo(f,E){return new cs(f,E)},y.point=xt,y.polygon=function Du(f,E){return new ka(f,E)},y.polyline=function yi(f,E){return new mi(f,E)},y.popup=function(f,E){return new hs(f,E)},y.rectangle=function ct(f,E){return new gt(f,E)},y.setOptions=it,y.stamp=R,y.svg=fs,y.svgOverlay=function yu(f,E,D){return new Fa(f,E,D)},y.tileLayer=no,y.tooltip=function(f,E){return new ca(f,E)},y.transformation=De,y.version="1.9.4",y.videoOverlay=function go(f,E,D){return new ea(f,E,D)};var fn=window.L;y.noConflict=function(){return window.L=fn,this},window.L=y}(ut)},186:Lt=>{Lt.exports=y;var ut=null;try{ut=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function y(ot,P,at){this.low=0|ot,this.high=0|P,this.unsigned=!!at}function $(ot){return!0===(ot&&ot.__isLong__)}Object.defineProperty(y.prototype,"__isLong__",{value:!0}),y.isLong=$;var V={},H={};function q(ot,P){var at,nt,Gt;return P?(Gt=0<=(ot>>>=0)&&ot<256)&&(nt=H[ot])?nt:(at=R(ot,(0|ot)<0?-1:0,!0),Gt&&(H[ot]=at),at):(Gt=-128<=(ot|=0)&&ot<128)&&(nt=V[ot])?nt:(at=R(ot,ot<0?-1:0,!1),Gt&&(V[ot]=at),at)}function Y(ot,P){if(isNaN(ot))return P?et:st;if(P){if(ot<0)return et;if(ot>=it)return ft}else{if(ot<=-bt)return pt;if(ot+1>=bt)return Q}return ot<0?Y(-ot,P).neg():R(ot%G|0,ot/G|0,P)}function R(ot,P,at){return new y(ot,P,at)}y.fromInt=q,y.fromNumber=Y,y.fromBits=R;var W=Math.pow;function k(ot,P,at){if(0===ot.length)throw Error("empty string");if("NaN"===ot||"Infinity"===ot||"+Infinity"===ot||"-Infinity"===ot)return st;if("number"==typeof P?(at=P,P=!1):P=!!P,(at=at||10)<2||36<at)throw RangeError("radix");var nt;if((nt=ot.indexOf("-"))>0)throw Error("interior hyphen");if(0===nt)return k(ot.substring(1),P,at).neg();for(var Gt=Y(W(at,8)),O=st,Ct=0;Ct<ot.length;Ct+=8){var yt=Math.min(8,ot.length-Ct),vt=parseInt(ot.substring(Ct,Ct+yt),at);if(yt<8){var xt=Y(W(at,yt));O=O.mul(xt).add(Y(vt))}else O=(O=O.mul(Gt)).add(Y(vt))}return O.unsigned=P,O}function A(ot,P){return"number"==typeof ot?Y(ot,P):"string"==typeof ot?k(ot,P):R(ot.low,ot.high,"boolean"==typeof P?P:ot.unsigned)}y.fromString=k,y.fromValue=A;var G=4294967296,it=G*G,bt=it/2,K=q(1<<24),st=q(0);y.ZERO=st;var et=q(0,!0);y.UZERO=et;var dt=q(1);y.ONE=dt;var lt=q(1,!0);y.UONE=lt;var St=q(-1);y.NEG_ONE=St;var Q=R(-1,2147483647,!1);y.MAX_VALUE=Q;var ft=R(-1,-1,!0);y.MAX_UNSIGNED_VALUE=ft;var pt=R(0,-2147483648,!1);y.MIN_VALUE=pt;var B=y.prototype;B.toInt=function(){return this.unsigned?this.low>>>0:this.low},B.toNumber=function(){return this.unsigned?(this.high>>>0)*G+(this.low>>>0):this.high*G+(this.low>>>0)},B.toString=function(P){if((P=P||10)<2||36<P)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(pt)){var at=Y(P),nt=this.div(at),Gt=nt.mul(at).sub(this);return nt.toString(P)+Gt.toInt().toString(P)}return"-"+this.neg().toString(P)}for(var O=Y(W(P,6),this.unsigned),Ct=this,yt="";;){var vt=Ct.div(O),Mt=(Ct.sub(vt.mul(O)).toInt()>>>0).toString(P);if((Ct=vt).isZero())return Mt+yt;for(;Mt.length<6;)Mt="0"+Mt;yt=""+Mt+yt}},B.getHighBits=function(){return this.high},B.getHighBitsUnsigned=function(){return this.high>>>0},B.getLowBits=function(){return this.low},B.getLowBitsUnsigned=function(){return this.low>>>0},B.getNumBitsAbs=function(){if(this.isNegative())return this.eq(pt)?64:this.neg().getNumBitsAbs();for(var P=0!=this.high?this.high:this.low,at=31;at>0&&!(P&1<<at);at--);return 0!=this.high?at+33:at+1},B.isZero=function(){return 0===this.high&&0===this.low},B.eqz=B.isZero,B.isNegative=function(){return!this.unsigned&&this.high<0},B.isPositive=function(){return this.unsigned||this.high>=0},B.isOdd=function(){return 1==(1&this.low)},B.isEven=function(){return 0==(1&this.low)},B.equals=function(P){return $(P)||(P=A(P)),(this.unsigned===P.unsigned||this.high>>>31!=1||P.high>>>31!=1)&&this.high===P.high&&this.low===P.low},B.eq=B.equals,B.notEquals=function(P){return!this.eq(P)},B.neq=B.notEquals,B.ne=B.notEquals,B.lessThan=function(P){return this.comp(P)<0},B.lt=B.lessThan,B.lessThanOrEqual=function(P){return this.comp(P)<=0},B.lte=B.lessThanOrEqual,B.le=B.lessThanOrEqual,B.greaterThan=function(P){return this.comp(P)>0},B.gt=B.greaterThan,B.greaterThanOrEqual=function(P){return this.comp(P)>=0},B.gte=B.greaterThanOrEqual,B.ge=B.greaterThanOrEqual,B.compare=function(P){if($(P)||(P=A(P)),this.eq(P))return 0;var at=this.isNegative(),nt=P.isNegative();return at&&!nt?-1:!at&&nt?1:this.unsigned?P.high>>>0>this.high>>>0||P.high===this.high&&P.low>>>0>this.low>>>0?-1:1:this.sub(P).isNegative()?-1:1},B.comp=B.compare,B.negate=function(){return!this.unsigned&&this.eq(pt)?pt:this.not().add(dt)},B.neg=B.negate,B.add=function(P){$(P)||(P=A(P));var Mt=0,It=0,re=0,Bt=0;return re+=(Bt+=(65535&this.low)+(65535&P.low))>>>16,It+=(re+=(this.low>>>16)+(P.low>>>16))>>>16,Mt+=(It+=(65535&this.high)+(65535&P.high))>>>16,Mt+=(this.high>>>16)+(P.high>>>16),R((re&=65535)<<16|(Bt&=65535),(Mt&=65535)<<16|(It&=65535),this.unsigned)},B.subtract=function(P){return $(P)||(P=A(P)),this.add(P.neg())},B.sub=B.subtract,B.multiply=function(P){if(this.isZero())return st;if($(P)||(P=A(P)),ut)return R(ut.mul(this.low,this.high,P.low,P.high),ut.get_high(),this.unsigned);if(P.isZero())return st;if(this.eq(pt))return P.isOdd()?pt:st;if(P.eq(pt))return this.isOdd()?pt:st;if(this.isNegative())return P.isNegative()?this.neg().mul(P.neg()):this.neg().mul(P).neg();if(P.isNegative())return this.mul(P.neg()).neg();if(this.lt(K)&&P.lt(K))return Y(this.toNumber()*P.toNumber(),this.unsigned);var Gt=65535&this.high,O=this.low>>>16,Ct=65535&this.low,vt=65535&P.high,xt=P.low>>>16,Mt=65535&P.low,It=0,re=0,Bt=0,ee=0;return Bt+=(ee+=Ct*Mt)>>>16,re+=(Bt+=O*Mt)>>>16,Bt&=65535,re+=(Bt+=Ct*xt)>>>16,It+=(re+=Gt*Mt)>>>16,re&=65535,It+=(re+=O*xt)>>>16,re&=65535,It+=(re+=Ct*vt)>>>16,It+=(this.high>>>16)*Mt+Gt*xt+O*vt+Ct*(P.high>>>16),R((Bt&=65535)<<16|(ee&=65535),(It&=65535)<<16|(re&=65535),this.unsigned)},B.mul=B.multiply,B.divide=function(P){if($(P)||(P=A(P)),P.isZero())throw Error("division by zero");var nt,Gt,O;if(ut)return this.unsigned||-2147483648!==this.high||-1!==P.low||-1!==P.high?R((this.unsigned?ut.div_u:ut.div_s)(this.low,this.high,P.low,P.high),ut.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?et:st;if(this.unsigned){if(P.unsigned||(P=P.toUnsigned()),P.gt(this))return et;if(P.gt(this.shru(1)))return lt;O=et}else{if(this.eq(pt))return P.eq(dt)||P.eq(St)?pt:P.eq(pt)?dt:(nt=this.shr(1).div(P).shl(1)).eq(st)?P.isNegative()?dt:St:(Gt=this.sub(P.mul(nt)),O=nt.add(Gt.div(P)));if(P.eq(pt))return this.unsigned?et:st;if(this.isNegative())return P.isNegative()?this.neg().div(P.neg()):this.neg().div(P).neg();if(P.isNegative())return this.div(P.neg()).neg();O=st}for(Gt=this;Gt.gte(P);){nt=Math.max(1,Math.floor(Gt.toNumber()/P.toNumber()));for(var yt=Math.ceil(Math.log(nt)/Math.LN2),vt=yt<=48?1:W(2,yt-48),xt=Y(nt),Mt=xt.mul(P);Mt.isNegative()||Mt.gt(Gt);)Mt=(xt=Y(nt-=vt,this.unsigned)).mul(P);xt.isZero()&&(xt=dt),O=O.add(xt),Gt=Gt.sub(Mt)}return O},B.div=B.divide,B.modulo=function(P){return $(P)||(P=A(P)),ut?R((this.unsigned?ut.rem_u:ut.rem_s)(this.low,this.high,P.low,P.high),ut.get_high(),this.unsigned):this.sub(this.div(P).mul(P))},B.mod=B.modulo,B.rem=B.modulo,B.not=function(){return R(~this.low,~this.high,this.unsigned)},B.and=function(P){return $(P)||(P=A(P)),R(this.low&P.low,this.high&P.high,this.unsigned)},B.or=function(P){return $(P)||(P=A(P)),R(this.low|P.low,this.high|P.high,this.unsigned)},B.xor=function(P){return $(P)||(P=A(P)),R(this.low^P.low,this.high^P.high,this.unsigned)},B.shiftLeft=function(P){return $(P)&&(P=P.toInt()),0==(P&=63)?this:P<32?R(this.low<<P,this.high<<P|this.low>>>32-P,this.unsigned):R(0,this.low<<P-32,this.unsigned)},B.shl=B.shiftLeft,B.shiftRight=function(P){return $(P)&&(P=P.toInt()),0==(P&=63)?this:P<32?R(this.low>>>P|this.high<<32-P,this.high>>P,this.unsigned):R(this.high>>P-32,this.high>=0?0:-1,this.unsigned)},B.shr=B.shiftRight,B.shiftRightUnsigned=function(P){if($(P)&&(P=P.toInt()),0==(P&=63))return this;var at=this.high;return P<32?R(this.low>>>P|at<<32-P,at>>>P,this.unsigned):R(32===P?at:at>>>P-32,0,this.unsigned)},B.shru=B.shiftRightUnsigned,B.shr_u=B.shiftRightUnsigned,B.toSigned=function(){return this.unsigned?R(this.low,this.high,!1):this},B.toUnsigned=function(){return this.unsigned?this:R(this.low,this.high,!0)},B.toBytes=function(P){return P?this.toBytesLE():this.toBytesBE()},B.toBytesLE=function(){var P=this.high,at=this.low;return[255&at,at>>>8&255,at>>>16&255,at>>>24,255&P,P>>>8&255,P>>>16&255,P>>>24]},B.toBytesBE=function(){var P=this.high,at=this.low;return[P>>>24,P>>>16&255,P>>>8&255,255&P,at>>>24,at>>>16&255,at>>>8&255,255&at]},y.fromBytes=function(P,at,nt){return nt?y.fromBytesLE(P,at):y.fromBytesBE(P,at)},y.fromBytesLE=function(P,at){return new y(P[0]|P[1]<<8|P[2]<<16|P[3]<<24,P[4]|P[5]<<8|P[6]<<16|P[7]<<24,at)},y.fromBytesBE=function(P,at){return new y(P[4]<<24|P[5]<<16|P[6]<<8|P[7],P[0]<<24|P[1]<<16|P[2]<<8|P[3],at)}},4772:Lt=>{"use strict";var ut=Object.getOwnPropertySymbols,y=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable;Lt.exports=function H(){try{if(!Object.assign)return!1;var q=new String("abc");if(q[5]="de","5"===Object.getOwnPropertyNames(q)[0])return!1;for(var Y={},R=0;R<10;R++)Y["_"+String.fromCharCode(R)]=R;if("0123456789"!==Object.getOwnPropertyNames(Y).map(function(A){return Y[A]}).join(""))return!1;var k={};return"abcdefghijklmnopqrst".split("").forEach(function(A){k[A]=A}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},k)).join("")}catch{return!1}}()?Object.assign:function(q,Y){for(var R,k,W=function V(q){if(null==q)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(q)}(q),A=1;A<arguments.length;A++){for(var X in R=Object(arguments[A]))y.call(R,X)&&(W[X]=R[X]);if(ut){k=ut(R);for(var Z=0;Z<k.length;Z++)$.call(R,k[Z])&&(W[k[Z]]=R[k[Z]])}}return W}},4246:Lt=>{"use strict";var ut=function(y){return y!=y};Lt.exports=function($,V){return 0===$&&0===V?1/$==1/V:!!($===V||ut($)&&ut(V))}},314:(Lt,ut,y)=>{"use strict";var $=y(1648),V=y(5436),H=y(4246),q=y(1353),Y=y(3090),R=V(q(),Object);$(R,{getPolyfill:q,implementation:H,shim:Y}),Lt.exports=R},1353:(Lt,ut,y)=>{"use strict";var $=y(4246);Lt.exports=function(){return"function"==typeof Object.is?Object.is:$}},3090:(Lt,ut,y)=>{"use strict";var $=y(1353),V=y(1648);Lt.exports=function(){var q=$();return V(Object,{is:q},{is:function(){return Object.is!==q}}),q}},7972:(Lt,ut,y)=>{"use strict";var $;if(!Object.keys){var V=Object.prototype.hasOwnProperty,H=Object.prototype.toString,q=y(9637),Y=Object.prototype.propertyIsEnumerable,R=!Y.call({toString:null},"toString"),W=Y.call(function(){},"prototype"),k=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],A=function(it){var bt=it.constructor;return bt&&bt.prototype===it},X={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},Z=function(){if(typeof window>"u")return!1;for(var it in window)try{if(!X["$"+it]&&V.call(window,it)&&null!==window[it]&&"object"==typeof window[it])try{A(window[it])}catch{return!0}}catch{return!0}return!1}();$=function(bt){var K=null!==bt&&"object"==typeof bt,st="[object Function]"===H.call(bt),et=q(bt),dt=K&&"[object String]"===H.call(bt),lt=[];if(!K&&!st&&!et)throw new TypeError("Object.keys called on a non-object");var St=W&&st;if(dt&&bt.length>0&&!V.call(bt,0))for(var Q=0;Q<bt.length;++Q)lt.push(String(Q));if(et&&bt.length>0)for(var ft=0;ft<bt.length;++ft)lt.push(String(ft));else for(var pt in bt)(!St||"prototype"!==pt)&&V.call(bt,pt)&&lt.push(String(pt));if(R)for(var B=function(it){if(typeof window>"u"||!Z)return A(it);try{return A(it)}catch{return!1}}(bt),ot=0;ot<k.length;++ot)(!B||"constructor"!==k[ot])&&V.call(bt,k[ot])&&lt.push(k[ot]);return lt}}Lt.exports=$},7809:(Lt,ut,y)=>{"use strict";var $=Array.prototype.slice,V=y(9637),H=Object.keys,q=H?function(W){return H(W)}:y(7972),Y=Object.keys;q.shim=function(){if(Object.keys){var W=function(){var k=Object.keys(arguments);return k&&k.length===arguments.length}(1,2);W||(Object.keys=function(A){return V(A)?Y($.call(A)):Y(A)})}else Object.keys=q;return Object.keys||q},Lt.exports=q},9637:Lt=>{"use strict";var ut=Object.prototype.toString;Lt.exports=function($){var V=ut.call($),H="[object Arguments]"===V;return H||(H="[object Array]"!==V&&null!==$&&"object"==typeof $&&"number"==typeof $.length&&$.length>=0&&"[object Function]"===ut.call($.callee)),H}},4018:Lt=>{Lt.exports=function(y,$,V,H){var q=y[0],Y=y[1],R=!1;void 0===V&&(V=0),void 0===H&&(H=$.length);for(var W=(H-V)/2,k=0,A=W-1;k<W;A=k++){var X=$[V+2*k+0],Z=$[V+2*k+1],it=$[V+2*A+1];Z>Y!=it>Y&&q<($[V+2*A+0]-X)*(Y-Z)/(it-Z)+X&&(R=!R)}return R}},4179:(Lt,ut,y)=>{var $=y(4018),V=y(8875);Lt.exports=function(q,Y,R,W){return Y.length>0&&Array.isArray(Y[0])?V(q,Y,R,W):$(q,Y,R,W)},Lt.exports.nested=V,Lt.exports.flat=$},8875:Lt=>{Lt.exports=function(y,$,V,H){var q=y[0],Y=y[1],R=!1;void 0===V&&(V=0),void 0===H&&(H=$.length);for(var W=H-V,k=0,A=W-1;k<W;A=k++){var X=$[k+V][0],Z=$[k+V][1],it=$[A+V][1];Z>Y!=it>Y&&q<($[A+V][0]-X)*(Y-Z)/(it-Z)+X&&(R=!R)}return R}},8464:function(Lt){Lt.exports=function(){"use strict";function ut(Ce,Et){var te,oe,ie,ze,Rt={label:0,sent:function(){if(1&ie[0])throw ie[1];return ie[1]},trys:[],ops:[]};return ze={next:Oe(0),throw:Oe(1),return:Oe(2)},"function"==typeof Symbol&&(ze[Symbol.iterator]=function(){return this}),ze;function Oe(Xt){return function(En){return function je(Xt){if(te)throw new TypeError("Generator is already executing.");for(;Rt;)try{if(te=1,oe&&(ie=2&Xt[0]?oe.return:Xt[0]?oe.throw||((ie=oe.return)&&ie.call(oe),0):oe.next)&&!(ie=ie.call(oe,Xt[1])).done)return ie;switch(oe=0,ie&&(Xt=[2&Xt[0],ie.value]),Xt[0]){case 0:case 1:ie=Xt;break;case 4:return Rt.label++,{value:Xt[1],done:!1};case 5:Rt.label++,oe=Xt[1],Xt=[0];continue;case 7:Xt=Rt.ops.pop(),Rt.trys.pop();continue;default:if(!(ie=(ie=Rt.trys).length>0&&ie[ie.length-1])&&(6===Xt[0]||2===Xt[0])){Rt=0;continue}if(3===Xt[0]&&(!ie||Xt[1]>ie[0]&&Xt[1]<ie[3])){Rt.label=Xt[1];break}if(6===Xt[0]&&Rt.label<ie[1]){Rt.label=ie[1],ie=Xt;break}if(ie&&Rt.label<ie[2]){Rt.label=ie[2],Rt.ops.push(Xt);break}ie[2]&&Rt.ops.pop(),Rt.trys.pop();continue}Xt=Et.call(Ce,Rt)}catch(En){Xt=[6,En],oe=0}finally{te=ie=0}if(5&Xt[0])throw Xt[1];return{value:Xt[0]?Xt[1]:void 0,done:!0}}([Xt,En])}}}var y=function Ce(Et,Rt){this.next=null,this.key=Et,this.data=Rt,this.left=null,this.right=null};function $(Ce,Et){return Ce>Et?1:Ce<Et?-1:0}function V(Ce,Et,Rt){for(var te=new y(null,null),oe=te,ie=te;;){var ze=Rt(Ce,Et.key);if(ze<0){if(null===Et.left)break;if(Rt(Ce,Et.left.key)<0&&(Et.left=(Oe=Et.left).right,Oe.right=Et,null===(Et=Oe).left))break;ie.left=Et,ie=Et,Et=Et.left}else{if(!(ze>0))break;if(null===Et.right)break;var Oe;if(Rt(Ce,Et.right.key)>0&&(Et.right=(Oe=Et.right).left,Oe.left=Et,null===(Et=Oe).right))break;oe.right=Et,oe=Et,Et=Et.right}}return oe.right=Et.left,ie.left=Et.right,Et.left=te.right,Et.right=te.left,Et}function H(Ce,Et,Rt,te){var oe=new y(Ce,Et);if(null===Rt)return oe.left=oe.right=null,oe;var ie=te(Ce,(Rt=V(Ce,Rt,te)).key);return ie<0?(oe.left=Rt.left,oe.right=Rt,Rt.left=null):ie>=0&&(oe.right=Rt.right,oe.left=Rt,Rt.right=null),oe}function q(Ce,Et,Rt){var te=null,oe=null;if(Et){var ie=Rt((Et=V(Ce,Et,Rt)).key,Ce);0===ie?(te=Et.left,oe=Et.right):ie<0?(oe=Et.right,Et.right=null,te=Et):(te=Et.left,Et.left=null,oe=Et)}return{left:te,right:oe}}function R(Ce,Et,Rt,te,oe){if(Ce){te(Et+(Rt?"\u2514\u2500\u2500 ":"\u251c\u2500\u2500 ")+oe(Ce)+"\n");var ie=Et+(Rt?"    ":"\u2502   ");Ce.left&&R(Ce.left,ie,!1,te,oe),Ce.right&&R(Ce.right,ie,!0,te,oe)}}var W=function(){function Ce(Et){void 0===Et&&(Et=$),this._root=null,this._size=0,this._comparator=Et}return Ce.prototype.insert=function(Et,Rt){return this._size++,this._root=H(Et,Rt,this._root,this._comparator)},Ce.prototype.add=function(Et,Rt){var te=new y(Et,Rt);null===this._root&&(te.left=te.right=null,this._size++,this._root=te);var oe=this._comparator,ie=V(Et,this._root,oe),ze=oe(Et,ie.key);return 0===ze?this._root=ie:(ze<0?(te.left=ie.left,te.right=ie,ie.left=null):ze>0&&(te.right=ie.right,te.left=ie,ie.right=null),this._size++,this._root=te),this._root},Ce.prototype.remove=function(Et){this._root=this._remove(Et,this._root,this._comparator)},Ce.prototype._remove=function(Et,Rt,te){var oe;return null===Rt?null:0===te(Et,(Rt=V(Et,Rt,te)).key)?(null===Rt.left?oe=Rt.right:(oe=V(Et,Rt.left,te)).right=Rt.right,this._size--,oe):Rt},Ce.prototype.pop=function(){var Et=this._root;if(Et){for(;Et.left;)Et=Et.left;return this._root=V(Et.key,this._root,this._comparator),this._root=this._remove(Et.key,this._root,this._comparator),{key:Et.key,data:Et.data}}return null},Ce.prototype.findStatic=function(Et){for(var Rt=this._root,te=this._comparator;Rt;){var oe=te(Et,Rt.key);if(0===oe)return Rt;Rt=oe<0?Rt.left:Rt.right}return null},Ce.prototype.find=function(Et){return this._root&&(this._root=V(Et,this._root,this._comparator),0!==this._comparator(Et,this._root.key))?null:this._root},Ce.prototype.contains=function(Et){for(var Rt=this._root,te=this._comparator;Rt;){var oe=te(Et,Rt.key);if(0===oe)return!0;Rt=oe<0?Rt.left:Rt.right}return!1},Ce.prototype.forEach=function(Et,Rt){for(var te=this._root,oe=[],ie=!1;!ie;)null!==te?(oe.push(te),te=te.left):0!==oe.length?(te=oe.pop(),Et.call(Rt,te),te=te.right):ie=!0;return this},Ce.prototype.range=function(Et,Rt,te,oe){for(var ie=[],ze=this._comparator,Oe=this._root;0!==ie.length||Oe;)if(Oe)ie.push(Oe),Oe=Oe.left;else{if(ze((Oe=ie.pop()).key,Rt)>0)break;if(ze(Oe.key,Et)>=0&&te.call(oe,Oe))return this;Oe=Oe.right}return this},Ce.prototype.keys=function(){var Et=[];return this.forEach(function(Rt){return Et.push(Rt.key)}),Et},Ce.prototype.values=function(){var Et=[];return this.forEach(function(Rt){return Et.push(Rt.data)}),Et},Ce.prototype.min=function(){return this._root?this.minNode(this._root).key:null},Ce.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},Ce.prototype.minNode=function(Et){if(void 0===Et&&(Et=this._root),Et)for(;Et.left;)Et=Et.left;return Et},Ce.prototype.maxNode=function(Et){if(void 0===Et&&(Et=this._root),Et)for(;Et.right;)Et=Et.right;return Et},Ce.prototype.at=function(Et){for(var Rt=this._root,te=!1,oe=0,ie=[];!te;)if(Rt)ie.push(Rt),Rt=Rt.left;else if(ie.length>0){if(Rt=ie.pop(),oe===Et)return Rt;oe++,Rt=Rt.right}else te=!0;return null},Ce.prototype.next=function(Et){var Rt=this._root,te=null;if(Et.right){for(te=Et.right;te.left;)te=te.left;return te}for(var oe=this._comparator;Rt;){var ie=oe(Et.key,Rt.key);if(0===ie)break;ie<0?(te=Rt,Rt=Rt.left):Rt=Rt.right}return te},Ce.prototype.prev=function(Et){var Rt=this._root,te=null;if(null!==Et.left){for(te=Et.left;te.right;)te=te.right;return te}for(var oe=this._comparator;Rt;){var ie=oe(Et.key,Rt.key);if(0===ie)break;ie<0?Rt=Rt.left:(te=Rt,Rt=Rt.right)}return te},Ce.prototype.clear=function(){return this._root=null,this._size=0,this},Ce.prototype.toList=function(){return function X(Ce){for(var Et=Ce,Rt=[],te=!1,oe=new y(null,null),ie=oe;!te;)Et?(Rt.push(Et),Et=Et.left):Rt.length>0?Et=(Et=ie=ie.next=Rt.pop()).right:te=!0;return ie.next=null,oe.next}(this._root)},Ce.prototype.load=function(Et,Rt,te){void 0===Rt&&(Rt=[]),void 0===te&&(te=!1);var oe=Et.length,ie=this._comparator;if(te&&it(Et,Rt,0,oe-1,ie),null===this._root)this._root=k(Et,Rt,0,oe),this._size=oe;else{var ze=function G(Ce,Et,Rt){for(var te=new y(null,null),oe=te,ie=Ce,ze=Et;null!==ie&&null!==ze;)Rt(ie.key,ze.key)<0?(oe.next=ie,ie=ie.next):(oe.next=ze,ze=ze.next),oe=oe.next;return null!==ie?oe.next=ie:null!==ze&&(oe.next=ze),te.next}(this.toList(),function A(Ce,Et){for(var Rt=new y(null,null),te=Rt,oe=0;oe<Ce.length;oe++)te=te.next=new y(Ce[oe],Et[oe]);return te.next=null,Rt.next}(Et,Rt),ie);this._root=Z({head:ze},0,oe=this._size+oe)}return this},Ce.prototype.isEmpty=function(){return null===this._root},Object.defineProperty(Ce.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(Ce.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),Ce.prototype.toString=function(Et){void 0===Et&&(Et=function(te){return String(te.key)});var Rt=[];return R(this._root,"",!0,function(te){return Rt.push(te)},Et),Rt.join("")},Ce.prototype.update=function(Et,Rt,te){var oe=this._comparator,ie=q(Et,this._root,oe),ze=ie.left,Oe=ie.right;oe(Et,Rt)<0?Oe=H(Rt,te,Oe,oe):ze=H(Rt,te,ze,oe),this._root=function Y(Ce,Et,Rt){return null===Et?Ce:(null===Ce||((Et=V(Ce.key,Et,Rt)).left=Ce),Et)}(ze,Oe,oe)},Ce.prototype.split=function(Et){return q(Et,this._root,this._comparator)},Ce.prototype[Symbol.iterator]=function(){var Et,Rt,te;return ut(this,function(oe){switch(oe.label){case 0:Et=this._root,Rt=[],te=!1,oe.label=1;case 1:return te?[3,6]:null===Et?[3,2]:(Rt.push(Et),Et=Et.left,[3,5]);case 2:return 0===Rt.length?[3,4]:[4,Et=Rt.pop()];case 3:return oe.sent(),Et=Et.right,[3,5];case 4:te=!0,oe.label=5;case 5:return[3,1];case 6:return[2]}})},Ce}();function k(Ce,Et,Rt,te){var oe=te-Rt;if(oe>0){var ie=Rt+Math.floor(oe/2),je=new y(Ce[ie],Et[ie]);return je.left=k(Ce,Et,Rt,ie),je.right=k(Ce,Et,ie+1,te),je}return null}function Z(Ce,Et,Rt){var te=Rt-Et;if(te>0){var oe=Et+Math.floor(te/2),ie=Z(Ce,Et,oe),ze=Ce.head;return ze.left=ie,Ce.head=Ce.head.next,ze.right=Z(Ce,oe+1,Rt),ze}return null}function it(Ce,Et,Rt,te,oe){if(!(Rt>=te)){for(var ie=Ce[Rt+te>>1],ze=Rt-1,Oe=te+1;;){do{ze++}while(oe(Ce[ze],ie)<0);do{Oe--}while(oe(Ce[Oe],ie)>0);if(ze>=Oe)break;var je=Ce[ze];Ce[ze]=Ce[Oe],Ce[Oe]=je,je=Et[ze],Et[ze]=Et[Oe],Et[Oe]=je}it(Ce,Et,Rt,Oe,oe),it(Ce,Et,Oe+1,te,oe)}}const bt=(Ce,Et)=>Ce.ll.x<=Et.x&&Et.x<=Ce.ur.x&&Ce.ll.y<=Et.y&&Et.y<=Ce.ur.y,K=(Ce,Et)=>Et.ur.x<Ce.ll.x||Ce.ur.x<Et.ll.x||Et.ur.y<Ce.ll.y||Ce.ur.y<Et.ll.y?null:{ll:{x:Ce.ll.x<Et.ll.x?Et.ll.x:Ce.ll.x,y:Ce.ll.y<Et.ll.y?Et.ll.y:Ce.ll.y},ur:{x:Ce.ur.x<Et.ur.x?Ce.ur.x:Et.ur.x,y:Ce.ur.y<Et.ur.y?Ce.ur.y:Et.ur.y}};let st=Number.EPSILON;void 0===st&&(st=Math.pow(2,-52));const et=st*st,dt=(Ce,Et)=>{if(-st<Ce&&Ce<st&&-st<Et&&Et<st)return 0;const Rt=Ce-Et;return Rt*Rt<et*Ce*Et?0:Ce<Et?-1:1};class St{constructor(){this.tree=new W,this.round(0)}round(Et){const Rt=this.tree.add(Et),te=this.tree.prev(Rt);if(null!==te&&0===dt(Rt.key,te.key))return this.tree.remove(Et),te.key;const oe=this.tree.next(Rt);return null!==oe&&0===dt(Rt.key,oe.key)?(this.tree.remove(Et),oe.key):Et}}const Q=new class lt{constructor(){this.reset()}reset(){this.xRounder=new St,this.yRounder=new St}round(Et,Rt){return{x:this.xRounder.round(Et),y:this.yRounder.round(Rt)}}},ft=11102230246251565e-32,pt=134217729,B=(3+8*ft)*ft;function ot(Ce,Et,Rt,te,oe){let ie,ze,Oe,je,Xt=Et[0],En=te[0],ue=0,en=0;En>Xt==En>-Xt?(ie=Xt,Xt=Et[++ue]):(ie=En,En=te[++en]);let mn=0;if(ue<Ce&&en<Rt)for(En>Xt==En>-Xt?(ze=Xt+ie,Oe=ie-(ze-Xt),Xt=Et[++ue]):(ze=En+ie,Oe=ie-(ze-En),En=te[++en]),ie=ze,0!==Oe&&(oe[mn++]=Oe);ue<Ce&&en<Rt;)En>Xt==En>-Xt?(ze=ie+Xt,je=ze-ie,Oe=ie-(ze-je)+(Xt-je),Xt=Et[++ue]):(ze=ie+En,je=ze-ie,Oe=ie-(ze-je)+(En-je),En=te[++en]),ie=ze,0!==Oe&&(oe[mn++]=Oe);for(;ue<Ce;)ze=ie+Xt,je=ze-ie,Oe=ie-(ze-je)+(Xt-je),Xt=Et[++ue],ie=ze,0!==Oe&&(oe[mn++]=Oe);for(;en<Rt;)ze=ie+En,je=ze-ie,Oe=ie-(ze-je)+(En-je),En=te[++en],ie=ze,0!==Oe&&(oe[mn++]=Oe);return(0!==ie||0===mn)&&(oe[mn++]=ie),mn}function at(Ce){return new Float64Array(Ce)}const Gt=(2+12*ft)*ft,O=(9+64*ft)*ft*ft,Ct=at(4),yt=at(8),vt=at(12),xt=at(16),Mt=at(4);function re(Ce,Et,Rt,te,oe,ie){const ze=(Et-ie)*(Rt-oe),Oe=(Ce-oe)*(te-ie),je=ze-Oe,Xt=Math.abs(ze+Oe);return Math.abs(je)>=33306690738754716e-32*Xt?je:-function It(Ce,Et,Rt,te,oe,ie,ze){let Oe,je,Xt,En,ue,en,mn,un,tr,dr,zn,vn,sr,Jr,Qn,wr,Dn,si;const Rr=Ce-oe,er=Rt-oe,Zi=Et-ie,fi=te-ie;Jr=Rr*fi,en=pt*Rr,mn=en-(en-Rr),un=Rr-mn,en=pt*fi,tr=en-(en-fi),dr=fi-tr,Qn=un*dr-(Jr-mn*tr-un*tr-mn*dr),wr=Zi*er,en=pt*Zi,mn=en-(en-Zi),un=Zi-mn,en=pt*er,tr=en-(en-er),dr=er-tr,Dn=un*dr-(wr-mn*tr-un*tr-mn*dr),zn=Qn-Dn,ue=Qn-zn,Ct[0]=Qn-(zn+ue)+(ue-Dn),vn=Jr+zn,ue=vn-Jr,sr=Jr-(vn-ue)+(zn-ue),zn=sr-wr,ue=sr-zn,Ct[1]=sr-(zn+ue)+(ue-wr),si=vn+zn,ue=si-vn,Ct[2]=vn-(si-ue)+(zn-ue),Ct[3]=si;let oi=function P(Ce,Et){let Rt=Et[0];for(let te=1;te<Ce;te++)Rt+=Et[te];return Rt}(4,Ct),zr=Gt*ze;if(oi>=zr||-oi>=zr||(ue=Ce-Rr,Oe=Ce-(Rr+ue)+(ue-oe),ue=Rt-er,Xt=Rt-(er+ue)+(ue-oe),ue=Et-Zi,je=Et-(Zi+ue)+(ue-ie),ue=te-fi,En=te-(fi+ue)+(ue-ie),0===Oe&&0===je&&0===Xt&&0===En)||(zr=O*ze+B*Math.abs(oi),oi+=Rr*En+fi*Oe-(Zi*Xt+er*je),oi>=zr||-oi>=zr))return oi;Jr=Oe*fi,en=pt*Oe,mn=en-(en-Oe),un=Oe-mn,en=pt*fi,tr=en-(en-fi),dr=fi-tr,Qn=un*dr-(Jr-mn*tr-un*tr-mn*dr),wr=je*er,en=pt*je,mn=en-(en-je),un=je-mn,en=pt*er,tr=en-(en-er),dr=er-tr,Dn=un*dr-(wr-mn*tr-un*tr-mn*dr),zn=Qn-Dn,ue=Qn-zn,Mt[0]=Qn-(zn+ue)+(ue-Dn),vn=Jr+zn,ue=vn-Jr,sr=Jr-(vn-ue)+(zn-ue),zn=sr-wr,ue=sr-zn,Mt[1]=sr-(zn+ue)+(ue-wr),si=vn+zn,ue=si-vn,Mt[2]=vn-(si-ue)+(zn-ue),Mt[3]=si;const js=ot(4,Ct,4,Mt,yt);Jr=Rr*En,en=pt*Rr,mn=en-(en-Rr),un=Rr-mn,en=pt*En,tr=en-(en-En),dr=En-tr,Qn=un*dr-(Jr-mn*tr-un*tr-mn*dr),wr=Zi*Xt,en=pt*Zi,mn=en-(en-Zi),un=Zi-mn,en=pt*Xt,tr=en-(en-Xt),dr=Xt-tr,Dn=un*dr-(wr-mn*tr-un*tr-mn*dr),zn=Qn-Dn,ue=Qn-zn,Mt[0]=Qn-(zn+ue)+(ue-Dn),vn=Jr+zn,ue=vn-Jr,sr=Jr-(vn-ue)+(zn-ue),zn=sr-wr,ue=sr-zn,Mt[1]=sr-(zn+ue)+(ue-wr),si=vn+zn,ue=si-vn,Mt[2]=vn-(si-ue)+(zn-ue),Mt[3]=si;const ho=ot(js,yt,4,Mt,vt);Jr=Oe*En,en=pt*Oe,mn=en-(en-Oe),un=Oe-mn,en=pt*En,tr=en-(en-En),dr=En-tr,Qn=un*dr-(Jr-mn*tr-un*tr-mn*dr),wr=je*Xt,en=pt*je,mn=en-(en-je),un=je-mn,en=pt*Xt,tr=en-(en-Xt),dr=Xt-tr,Dn=un*dr-(wr-mn*tr-un*tr-mn*dr),zn=Qn-Dn,ue=Qn-zn,Mt[0]=Qn-(zn+ue)+(ue-Dn),vn=Jr+zn,ue=vn-Jr,sr=Jr-(vn-ue)+(zn-ue),zn=sr-wr,ue=sr-zn,Mt[1]=sr-(zn+ue)+(ue-wr),si=vn+zn,ue=si-vn,Mt[2]=vn-(si-ue)+(zn-ue),Mt[3]=si;const Es=ot(ho,vt,4,Mt,xt);return xt[Es-1]}(Ce,Et,Rt,te,oe,ie,Xt)}const Bt=(Ce,Et)=>Ce.x*Et.y-Ce.y*Et.x,ee=(Ce,Et)=>Ce.x*Et.x+Ce.y*Et.y,jt=(Ce,Et,Rt)=>{const te=re(Ce.x,Ce.y,Et.x,Et.y,Rt.x,Rt.y);return te>0?-1:te<0?1:0},se=Ce=>Math.sqrt(ee(Ce,Ce)),be=(Ce,Et,Rt)=>{const te={x:Et.x-Ce.x,y:Et.y-Ce.y},oe={x:Rt.x-Ce.x,y:Rt.y-Ce.y};return Bt(oe,te)/se(oe)/se(te)},Me=(Ce,Et,Rt)=>{const te={x:Et.x-Ce.x,y:Et.y-Ce.y},oe={x:Rt.x-Ce.x,y:Rt.y-Ce.y};return ee(oe,te)/se(oe)/se(te)},Xe=(Ce,Et,Rt)=>0===Et.y?null:{x:Ce.x+Et.x/Et.y*(Rt-Ce.y),y:Rt},Ue=(Ce,Et,Rt)=>0===Et.x?null:{x:Rt,y:Ce.y+Et.y/Et.x*(Rt-Ce.x)};class Tn{static compare(Et,Rt){const te=Tn.comparePoints(Et.point,Rt.point);return 0!==te?te:(Et.point!==Rt.point&&Et.link(Rt),Et.isLeft!==Rt.isLeft?Et.isLeft?1:-1:ne.compare(Et.segment,Rt.segment))}static comparePoints(Et,Rt){return Et.x<Rt.x?-1:Et.x>Rt.x?1:Et.y<Rt.y?-1:Et.y>Rt.y?1:0}constructor(Et,Rt){void 0===Et.events?Et.events=[this]:Et.events.push(this),this.point=Et,this.isLeft=Rt}link(Et){if(Et.point===this.point)throw new Error("Tried to link already linked events");const Rt=Et.point.events;for(let te=0,oe=Rt.length;te<oe;te++){const ie=Rt[te];this.point.events.push(ie),ie.point=this.point}this.checkForConsuming()}checkForConsuming(){const Et=this.point.events.length;for(let Rt=0;Rt<Et;Rt++){const te=this.point.events[Rt];if(void 0===te.segment.consumedBy)for(let oe=Rt+1;oe<Et;oe++){const ie=this.point.events[oe];void 0===ie.consumedBy&&te.otherSE.point.events===ie.otherSE.point.events&&te.segment.consume(ie.segment)}}}getAvailableLinkedEvents(){const Et=[];for(let Rt=0,te=this.point.events.length;Rt<te;Rt++){const oe=this.point.events[Rt];oe!==this&&!oe.segment.ringOut&&oe.segment.isInResult()&&Et.push(oe)}return Et}getLeftmostComparator(Et){const Rt=new Map,te=oe=>{const ie=oe.otherSE;Rt.set(oe,{sine:be(this.point,Et.point,ie.point),cosine:Me(this.point,Et.point,ie.point)})};return(oe,ie)=>{Rt.has(oe)||te(oe),Rt.has(ie)||te(ie);const{sine:ze,cosine:Oe}=Rt.get(oe),{sine:je,cosine:Xt}=Rt.get(ie);return ze>=0&&je>=0?Oe<Xt?1:Oe>Xt?-1:0:ze<0&&je<0?Oe<Xt?-1:Oe>Xt?1:0:je<ze?-1:je>ze?1:0}}}let On=0;class ne{static compare(Et,Rt){const te=Et.leftSE.point.x,oe=Rt.leftSE.point.x,ie=Et.rightSE.point.x,ze=Rt.rightSE.point.x;if(ze<te)return 1;if(ie<oe)return-1;const Oe=Et.leftSE.point.y,je=Rt.leftSE.point.y,Xt=Et.rightSE.point.y,En=Rt.rightSE.point.y;if(te<oe){if(je<Oe&&je<Xt)return 1;if(je>Oe&&je>Xt)return-1;const ue=Et.comparePoint(Rt.leftSE.point);if(ue<0)return 1;if(ue>0)return-1;const en=Rt.comparePoint(Et.rightSE.point);return 0!==en?en:-1}if(te>oe){if(Oe<je&&Oe<En)return-1;if(Oe>je&&Oe>En)return 1;const ue=Rt.comparePoint(Et.leftSE.point);if(0!==ue)return ue;const en=Et.comparePoint(Rt.rightSE.point);return en<0?1:en>0?-1:1}if(Oe<je)return-1;if(Oe>je)return 1;if(ie<ze){const ue=Rt.comparePoint(Et.rightSE.point);if(0!==ue)return ue}if(ie>ze){const ue=Et.comparePoint(Rt.rightSE.point);if(ue<0)return 1;if(ue>0)return-1}if(ie!==ze){const ue=Xt-Oe,en=ie-te,mn=En-je,un=ze-oe;if(ue>en&&mn<un)return 1;if(ue<en&&mn>un)return-1}return ie>ze?1:ie<ze||Xt<En?-1:Xt>En?1:Et.id<Rt.id?-1:Et.id>Rt.id?1:0}constructor(Et,Rt,te,oe){this.id=++On,this.leftSE=Et,Et.segment=this,Et.otherSE=Rt,this.rightSE=Rt,Rt.segment=this,Rt.otherSE=Et,this.rings=te,this.windings=oe}static fromRing(Et,Rt,te){let oe,ie,ze;const Oe=Tn.comparePoints(Et,Rt);if(Oe<0)oe=Et,ie=Rt,ze=1;else{if(!(Oe>0))throw new Error(`Tried to create degenerate segment at [${Et.x}, ${Et.y}]`);oe=Rt,ie=Et,ze=-1}const je=new Tn(oe,!0),Xt=new Tn(ie,!1);return new ne(je,Xt,[te],[ze])}replaceRightSE(Et){this.rightSE=Et,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const Et=this.leftSE.point.y,Rt=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:Et<Rt?Et:Rt},ur:{x:this.rightSE.point.x,y:Et>Rt?Et:Rt}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(Et){return Et.x===this.leftSE.point.x&&Et.y===this.leftSE.point.y||Et.x===this.rightSE.point.x&&Et.y===this.rightSE.point.y}comparePoint(Et){if(this.isAnEndpoint(Et))return 0;const Rt=this.leftSE.point,te=this.rightSE.point,oe=this.vector();if(Rt.x===te.x)return Et.x===Rt.x?0:Et.x<Rt.x?1:-1;if(Et.x===Rt.x+(Et.y-Rt.y)/oe.y*oe.x)return 0;const je=Rt.y+(Et.x-Rt.x)/oe.x*oe.y;return Et.y===je?0:Et.y<je?-1:1}getIntersection(Et){const Rt=this.bbox(),te=Et.bbox(),oe=K(Rt,te);if(null===oe)return null;const ie=this.leftSE.point,ze=this.rightSE.point,Oe=Et.leftSE.point,je=Et.rightSE.point,Xt=bt(Rt,Oe)&&0===this.comparePoint(Oe),En=bt(te,ie)&&0===Et.comparePoint(ie),ue=bt(Rt,je)&&0===this.comparePoint(je),en=bt(te,ze)&&0===Et.comparePoint(ze);if(En&&Xt)return en&&!ue?ze:!en&&ue?je:null;if(En)return ue&&ie.x===je.x&&ie.y===je.y?null:ie;if(Xt)return en&&ze.x===Oe.x&&ze.y===Oe.y?null:Oe;if(en&&ue)return null;if(en)return ze;if(ue)return je;const mn=((Ce,Et,Rt,te)=>{if(0===Et.x)return Ue(Rt,te,Ce.x);if(0===te.x)return Ue(Ce,Et,Rt.x);if(0===Et.y)return Xe(Rt,te,Ce.y);if(0===te.y)return Xe(Ce,Et,Rt.y);const oe=Bt(Et,te);if(0==oe)return null;const ie={x:Rt.x-Ce.x,y:Rt.y-Ce.y},ze=Bt(ie,Et)/oe,Oe=Bt(ie,te)/oe;return{x:(Ce.x+Oe*Et.x+(Rt.x+ze*te.x))/2,y:(Ce.y+Oe*Et.y+(Rt.y+ze*te.y))/2}})(ie,this.vector(),Oe,Et.vector());return null!==mn&&bt(oe,mn)?Q.round(mn.x,mn.y):null}split(Et){const Rt=[],te=void 0!==Et.events,oe=new Tn(Et,!0),ie=new Tn(Et,!1),ze=this.rightSE;this.replaceRightSE(ie),Rt.push(ie),Rt.push(oe);const Oe=new ne(oe,ze,this.rings.slice(),this.windings.slice());return Tn.comparePoints(Oe.leftSE.point,Oe.rightSE.point)>0&&Oe.swapEvents(),Tn.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),te&&(oe.checkForConsuming(),ie.checkForConsuming()),Rt}swapEvents(){const Et=this.rightSE;this.rightSE=this.leftSE,this.leftSE=Et,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let Rt=0,te=this.windings.length;Rt<te;Rt++)this.windings[Rt]*=-1}consume(Et){let Rt=this,te=Et;for(;Rt.consumedBy;)Rt=Rt.consumedBy;for(;te.consumedBy;)te=te.consumedBy;const oe=ne.compare(Rt,te);if(0!==oe){if(oe>0){const ie=Rt;Rt=te,te=ie}if(Rt.prev===te){const ie=Rt;Rt=te,te=ie}for(let ie=0,ze=te.rings.length;ie<ze;ie++){const Oe=te.rings[ie],je=te.windings[ie],Xt=Rt.rings.indexOf(Oe);-1===Xt?(Rt.rings.push(Oe),Rt.windings.push(je)):Rt.windings[Xt]+=je}te.rings=null,te.windings=null,te.consumedBy=Rt,te.leftSE.consumedBy=Rt.leftSE,te.rightSE.consumedBy=Rt.rightSE}}prevInResult(){return void 0!==this._prevInResult||(this._prevInResult=this.prev?this.prev.isInResult()?this.prev:this.prev.prevInResult():null),this._prevInResult}beforeState(){return void 0!==this._beforeState||(this._beforeState=this.prev?(this.prev.consumedBy||this.prev).afterState():{rings:[],windings:[],multiPolys:[]}),this._beforeState}afterState(){if(void 0!==this._afterState)return this._afterState;const Et=this.beforeState();this._afterState={rings:Et.rings.slice(0),windings:Et.windings.slice(0),multiPolys:[]};const Rt=this._afterState.rings,te=this._afterState.windings,oe=this._afterState.multiPolys;for(let Oe=0,je=this.rings.length;Oe<je;Oe++){const Xt=this.rings[Oe],En=this.windings[Oe],ue=Rt.indexOf(Xt);-1===ue?(Rt.push(Xt),te.push(En)):te[ue]+=En}const ie=[],ze=[];for(let Oe=0,je=Rt.length;Oe<je;Oe++){if(0===te[Oe])continue;const Xt=Rt[Oe],En=Xt.poly;if(-1===ze.indexOf(En))if(Xt.isExterior)ie.push(En);else{-1===ze.indexOf(En)&&ze.push(En);const ue=ie.indexOf(Xt.poly);-1!==ue&&ie.splice(ue,1)}}for(let Oe=0,je=ie.length;Oe<je;Oe++){const Xt=ie[Oe].multiPoly;-1===oe.indexOf(Xt)&&oe.push(Xt)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;const Et=this.beforeState().multiPolys,Rt=this.afterState().multiPolys;switch(ii.type){case"union":this._isInResult=0===Et.length!=(0===Rt.length);break;case"intersection":{let te,oe;Et.length<Rt.length?(te=Et.length,oe=Rt.length):(te=Rt.length,oe=Et.length),this._isInResult=oe===ii.numMultiPolys&&te<oe;break}case"xor":{const te=Math.abs(Et.length-Rt.length);this._isInResult=te%2==1;break}case"difference":{const te=oe=>1===oe.length&&oe[0].isSubject;this._isInResult=te(Et)!==te(Rt);break}default:throw new Error(`Unrecognized operation type found ${ii.type}`)}return this._isInResult}}class pe{constructor(Et,Rt,te){if(!Array.isArray(Et)||0===Et.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=Rt,this.isExterior=te,this.segments=[],"number"!=typeof Et[0][0]||"number"!=typeof Et[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const oe=Q.round(Et[0][0],Et[0][1]);this.bbox={ll:{x:oe.x,y:oe.y},ur:{x:oe.x,y:oe.y}};let ie=oe;for(let ze=1,Oe=Et.length;ze<Oe;ze++){if("number"!=typeof Et[ze][0]||"number"!=typeof Et[ze][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let je=Q.round(Et[ze][0],Et[ze][1]);je.x===ie.x&&je.y===ie.y||(this.segments.push(ne.fromRing(ie,je,this)),je.x<this.bbox.ll.x&&(this.bbox.ll.x=je.x),je.y<this.bbox.ll.y&&(this.bbox.ll.y=je.y),je.x>this.bbox.ur.x&&(this.bbox.ur.x=je.x),je.y>this.bbox.ur.y&&(this.bbox.ur.y=je.y),ie=je)}(oe.x!==ie.x||oe.y!==ie.y)&&this.segments.push(ne.fromRing(ie,oe,this))}getSweepEvents(){const Et=[];for(let Rt=0,te=this.segments.length;Rt<te;Rt++){const oe=this.segments[Rt];Et.push(oe.leftSE),Et.push(oe.rightSE)}return Et}}class Ie{constructor(Et,Rt){if(!Array.isArray(Et))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new pe(Et[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let te=1,oe=Et.length;te<oe;te++){const ie=new pe(Et[te],this,!1);ie.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=ie.bbox.ll.x),ie.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=ie.bbox.ll.y),ie.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=ie.bbox.ur.x),ie.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=ie.bbox.ur.y),this.interiorRings.push(ie)}this.multiPoly=Rt}getSweepEvents(){const Et=this.exteriorRing.getSweepEvents();for(let Rt=0,te=this.interiorRings.length;Rt<te;Rt++){const oe=this.interiorRings[Rt].getSweepEvents();for(let ie=0,ze=oe.length;ie<ze;ie++)Et.push(oe[ie])}return Et}}class Je{constructor(Et,Rt){if(!Array.isArray(Et))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof Et[0][0][0]&&(Et=[Et])}catch{}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let te=0,oe=Et.length;te<oe;te++){const ie=new Ie(Et[te],this);ie.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=ie.bbox.ll.x),ie.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=ie.bbox.ll.y),ie.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=ie.bbox.ur.x),ie.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=ie.bbox.ur.y),this.polys.push(ie)}this.isSubject=Rt}getSweepEvents(){const Et=[];for(let Rt=0,te=this.polys.length;Rt<te;Rt++){const oe=this.polys[Rt].getSweepEvents();for(let ie=0,ze=oe.length;ie<ze;ie++)Et.push(oe[ie])}return Et}}class Gn{static factory(Et){const Rt=[];for(let te=0,oe=Et.length;te<oe;te++){const ie=Et[te];if(!ie.isInResult()||ie.ringOut)continue;let ze=null,Oe=ie.leftSE,je=ie.rightSE;const Xt=[Oe],En=Oe.point,ue=[];for(;ze=Oe,Oe=je,Xt.push(Oe),Oe.point!==En;)for(;;){const en=Oe.getAvailableLinkedEvents();if(0===en.length){const tr=Xt[0].point,dr=Xt[Xt.length-1].point;throw new Error(`Unable to complete output ring starting at [${tr.x}, ${tr.y}]. Last matching segment found ends at [${dr.x}, ${dr.y}].`)}if(1===en.length){je=en[0].otherSE;break}let mn=null;for(let tr=0,dr=ue.length;tr<dr;tr++)if(ue[tr].point===Oe.point){mn=tr;break}if(null!==mn){const tr=ue.splice(mn)[0],dr=Xt.splice(tr.index);dr.unshift(dr[0].otherSE),Rt.push(new Gn(dr.reverse()));continue}ue.push({index:Xt.length,point:Oe.point});const un=Oe.getLeftmostComparator(ze);je=en.sort(un)[0].otherSE;break}Rt.push(new Gn(Xt))}return Rt}constructor(Et){this.events=Et;for(let Rt=0,te=Et.length;Rt<te;Rt++)Et[Rt].segment.ringOut=this;this.poly=null}getGeom(){let Et=this.events[0].point;const Rt=[Et];for(let Xt=1,En=this.events.length-1;Xt<En;Xt++){const ue=this.events[Xt].point;0!==jt(ue,Et,this.events[Xt+1].point)&&(Rt.push(ue),Et=ue)}if(1===Rt.length)return null;0===jt(Rt[0],Et,Rt[1])&&Rt.shift(),Rt.push(Rt[0]);const ie=this.isExteriorRing()?1:-1,ze=this.isExteriorRing()?0:Rt.length-1,Oe=this.isExteriorRing()?Rt.length:-1,je=[];for(let Xt=ze;Xt!=Oe;Xt+=ie)je.push([Rt[Xt].x,Rt[Xt].y]);return je}isExteriorRing(){if(void 0===this._isExteriorRing){const Et=this.enclosingRing();this._isExteriorRing=!Et||!Et.isExteriorRing()}return this._isExteriorRing}enclosingRing(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let Et=this.events[0];for(let oe=1,ie=this.events.length;oe<ie;oe++){const ze=this.events[oe];Tn.compare(Et,ze)>0&&(Et=ze)}let Rt=Et.segment.prevInResult(),te=Rt?Rt.prevInResult():null;for(;;){if(!Rt)return null;if(!te)return Rt.ringOut;if(te.ringOut!==Rt.ringOut)return te.ringOut.enclosingRing()!==Rt.ringOut?Rt.ringOut:Rt.ringOut.enclosingRing();Rt=te.prevInResult(),te=Rt?Rt.prevInResult():null}}}class Er{constructor(Et){this.exteriorRing=Et,Et.poly=this,this.interiorRings=[]}addInterior(Et){this.interiorRings.push(Et),Et.poly=this}getGeom(){const Et=[this.exteriorRing.getGeom()];if(null===Et[0])return null;for(let Rt=0,te=this.interiorRings.length;Rt<te;Rt++){const oe=this.interiorRings[Rt].getGeom();null!==oe&&Et.push(oe)}return Et}}class Nn{constructor(Et){this.rings=Et,this.polys=this._composePolys(Et)}getGeom(){const Et=[];for(let Rt=0,te=this.polys.length;Rt<te;Rt++){const oe=this.polys[Rt].getGeom();null!==oe&&Et.push(oe)}return Et}_composePolys(Et){const Rt=[];for(let te=0,oe=Et.length;te<oe;te++){const ie=Et[te];if(!ie.poly)if(ie.isExteriorRing())Rt.push(new Er(ie));else{const ze=ie.enclosingRing();ze.poly||Rt.push(new Er(ze)),ze.poly.addInterior(ie)}}return Rt}}class Yn{constructor(Et){let Rt=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ne.compare;this.queue=Et,this.tree=new W(Rt),this.segments=[]}process(Et){const Rt=Et.segment,te=[];if(Et.consumedBy)return Et.isLeft?this.queue.remove(Et.otherSE):this.tree.remove(Rt),te;const oe=Et.isLeft?this.tree.add(Rt):this.tree.find(Rt);if(!oe)throw new Error(`Unable to find segment #${Rt.id} [${Rt.leftSE.point.x}, ${Rt.leftSE.point.y}] -> [${Rt.rightSE.point.x}, ${Rt.rightSE.point.y}] in SweepLine tree.`);let Oe,je,ie=oe,ze=oe;for(;void 0===Oe;)ie=this.tree.prev(ie),null===ie?Oe=null:void 0===ie.key.consumedBy&&(Oe=ie.key);for(;void 0===je;)ze=this.tree.next(ze),null===ze?je=null:void 0===ze.key.consumedBy&&(je=ze.key);if(Et.isLeft){let Xt=null;if(Oe){const ue=Oe.getIntersection(Rt);if(null!==ue&&(Rt.isAnEndpoint(ue)||(Xt=ue),!Oe.isAnEndpoint(ue))){const en=this._splitSafely(Oe,ue);for(let mn=0,un=en.length;mn<un;mn++)te.push(en[mn])}}let En=null;if(je){const ue=je.getIntersection(Rt);if(null!==ue&&(Rt.isAnEndpoint(ue)||(En=ue),!je.isAnEndpoint(ue))){const en=this._splitSafely(je,ue);for(let mn=0,un=en.length;mn<un;mn++)te.push(en[mn])}}if(null!==Xt||null!==En){let ue=null;ue=null===Xt?En:null===En||Tn.comparePoints(Xt,En)<=0?Xt:En,this.queue.remove(Rt.rightSE),te.push(Rt.rightSE);const en=Rt.split(ue);for(let mn=0,un=en.length;mn<un;mn++)te.push(en[mn])}te.length>0?(this.tree.remove(Rt),te.push(Et)):(this.segments.push(Rt),Rt.prev=Oe)}else{if(Oe&&je){const Xt=Oe.getIntersection(je);if(null!==Xt){if(!Oe.isAnEndpoint(Xt)){const En=this._splitSafely(Oe,Xt);for(let ue=0,en=En.length;ue<en;ue++)te.push(En[ue])}if(!je.isAnEndpoint(Xt)){const En=this._splitSafely(je,Xt);for(let ue=0,en=En.length;ue<en;ue++)te.push(En[ue])}}}this.tree.remove(Rt)}return te}_splitSafely(Et,Rt){this.tree.remove(Et);const te=Et.rightSE;this.queue.remove(te);const oe=Et.split(Rt);return oe.push(te),void 0===Et.consumedBy&&this.tree.add(Et),oe}}const hi=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,di=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;const ii=new class to{run(Et,Rt,te){ii.type=Et,Q.reset();const oe=[new Je(Rt,!0)];for(let ue=0,en=te.length;ue<en;ue++)oe.push(new Je(te[ue],!1));if(ii.numMultiPolys=oe.length,"difference"===ii.type){const ue=oe[0];let en=1;for(;en<oe.length;)null!==K(oe[en].bbox,ue.bbox)?en++:oe.splice(en,1)}if("intersection"===ii.type)for(let ue=0,en=oe.length;ue<en;ue++){const mn=oe[ue];for(let un=ue+1,tr=oe.length;un<tr;un++)if(null===K(mn.bbox,oe[un].bbox))return[]}const ie=new W(Tn.compare);for(let ue=0,en=oe.length;ue<en;ue++){const mn=oe[ue].getSweepEvents();for(let un=0,tr=mn.length;un<tr;un++)if(ie.insert(mn[un]),ie.size>hi)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const ze=new Yn(ie);let Oe=ie.size,je=ie.pop();for(;je;){const ue=je.key;if(ie.size===Oe){const mn=ue.segment;throw new Error(`Unable to pop() ${ue.isLeft?"left":"right"} SweepEvent [${ue.point.x}, ${ue.point.y}] from segment #${mn.id} [${mn.leftSE.point.x}, ${mn.leftSE.point.y}] -> [${mn.rightSE.point.x}, ${mn.rightSE.point.y}] from queue.`)}if(ie.size>hi)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(ze.segments.length>di)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const en=ze.process(ue);for(let mn=0,un=en.length;mn<un;mn++){const tr=en[mn];void 0===tr.consumedBy&&ie.insert(tr)}Oe=ie.size,je=ie.pop()}Q.reset();const Xt=Gn.factory(ze.segments);return new Nn(Xt).getGeom()}};var Hs={union:function(Ce){for(var Et=arguments.length,Rt=new Array(Et>1?Et-1:0),te=1;te<Et;te++)Rt[te-1]=arguments[te];return ii.run("union",Ce,Rt)},intersection:function(Ce){for(var Et=arguments.length,Rt=new Array(Et>1?Et-1:0),te=1;te<Et;te++)Rt[te-1]=arguments[te];return ii.run("intersection",Ce,Rt)},xor:function(Ce){for(var Et=arguments.length,Rt=new Array(Et>1?Et-1:0),te=1;te<Et;te++)Rt[te-1]=arguments[te];return ii.run("xor",Ce,Rt)},difference:function(Ce){for(var Et=arguments.length,Rt=new Array(Et>1?Et-1:0),te=1;te<Et;te++)Rt[te-1]=arguments[te];return ii.run("difference",Ce,Rt)}};return Hs}()},5262:function(Lt){Lt.exports=function(){"use strict";function y(H,q,Y,R,W){for(;R>Y;){if(R-Y>600){var k=R-Y+1,A=q-Y+1,X=Math.log(k),Z=.5*Math.exp(2*X/3),G=.5*Math.sqrt(X*Z*(k-Z)/k)*(A-k/2<0?-1:1);y(H,q,Math.max(Y,Math.floor(q-A*Z/k+G)),Math.min(R,Math.floor(q+(k-A)*Z/k+G)),W)}var K=H[q],st=Y,et=R;for($(H,Y,q),W(H[R],K)>0&&$(H,Y,R);st<et;){for($(H,st,et),st++,et--;W(H[st],K)<0;)st++;for(;W(H[et],K)>0;)et--}0===W(H[Y],K)?$(H,Y,et):$(H,++et,R),et<=q&&(Y=et+1),q<=et&&(R=et-1)}}function $(H,q,Y){var R=H[q];H[q]=H[Y],H[Y]=R}function V(H,q){return H<q?-1:H>q?1:0}return function ut(H,q,Y,R,W){y(H,q,Y||0,R||H.length-1,W||V)}}()},7861:(Lt,ut,y)=>{"use strict";Lt.exports=V,Lt.exports.default=V;var $=y(5262);function V(et,dt){if(!(this instanceof V))return new V(et,dt);this._maxEntries=Math.max(4,et||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),dt&&this._initFormat(dt),this.clear()}function H(et,dt,lt){if(!lt)return dt.indexOf(et);for(var St=0;St<dt.length;St++)if(lt(et,dt[St]))return St;return-1}function q(et,dt){Y(et,0,et.children.length,dt,et)}function Y(et,dt,lt,St,Q){Q||(Q=K(null)),Q.minX=1/0,Q.minY=1/0,Q.maxX=-1/0,Q.maxY=-1/0;for(var pt,ft=dt;ft<lt;ft++)pt=et.children[ft],R(Q,et.leaf?St(pt):pt);return Q}function R(et,dt){return et.minX=Math.min(et.minX,dt.minX),et.minY=Math.min(et.minY,dt.minY),et.maxX=Math.max(et.maxX,dt.maxX),et.maxY=Math.max(et.maxY,dt.maxY),et}function W(et,dt){return et.minX-dt.minX}function k(et,dt){return et.minY-dt.minY}function A(et){return(et.maxX-et.minX)*(et.maxY-et.minY)}function X(et){return et.maxX-et.minX+(et.maxY-et.minY)}function Z(et,dt){return(Math.max(dt.maxX,et.maxX)-Math.min(dt.minX,et.minX))*(Math.max(dt.maxY,et.maxY)-Math.min(dt.minY,et.minY))}function G(et,dt){var lt=Math.max(et.minX,dt.minX),St=Math.max(et.minY,dt.minY),Q=Math.min(et.maxX,dt.maxX),ft=Math.min(et.maxY,dt.maxY);return Math.max(0,Q-lt)*Math.max(0,ft-St)}function it(et,dt){return et.minX<=dt.minX&&et.minY<=dt.minY&&dt.maxX<=et.maxX&&dt.maxY<=et.maxY}function bt(et,dt){return dt.minX<=et.maxX&&dt.minY<=et.maxY&&dt.maxX>=et.minX&&dt.maxY>=et.minY}function K(et){return{children:et,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function st(et,dt,lt,St,Q){for(var pt,ft=[dt,lt];ft.length;)!((lt=ft.pop())-(dt=ft.pop())<=St)&&(pt=dt+Math.ceil((lt-dt)/St/2)*St,$(et,pt,dt,lt,Q),ft.push(dt,pt,pt,lt))}V.prototype={all:function(){return this._all(this.data,[])},search:function(et){var dt=this.data,lt=[],St=this.toBBox;if(!bt(et,dt))return lt;for(var ft,pt,B,ot,Q=[];dt;){for(ft=0,pt=dt.children.length;ft<pt;ft++)B=dt.children[ft],bt(et,ot=dt.leaf?St(B):B)&&(dt.leaf?lt.push(B):it(et,ot)?this._all(B,lt):Q.push(B));dt=Q.pop()}return lt},collides:function(et){var dt=this.data,lt=this.toBBox;if(!bt(et,dt))return!1;for(var Q,ft,pt,B,St=[];dt;){for(Q=0,ft=dt.children.length;Q<ft;Q++)if(pt=dt.children[Q],bt(et,B=dt.leaf?lt(pt):pt)){if(dt.leaf||it(et,B))return!0;St.push(pt)}dt=St.pop()}return!1},load:function(et){if(!et||!et.length)return this;if(et.length<this._minEntries){for(var dt=0,lt=et.length;dt<lt;dt++)this.insert(et[dt]);return this}var St=this._build(et.slice(),0,et.length-1,0);if(this.data.children.length)if(this.data.height===St.height)this._splitRoot(this.data,St);else{if(this.data.height<St.height){var Q=this.data;this.data=St,St=Q}this._insert(St,this.data.height-St.height-1,!0)}else this.data=St;return this},insert:function(et){return et&&this._insert(et,this.data.height-1),this},clear:function(){return this.data=K([]),this},remove:function(et,dt){if(!et)return this;for(var pt,B,ot,P,lt=this.data,St=this.toBBox(et),Q=[],ft=[];lt||Q.length;){if(lt||(lt=Q.pop(),B=Q[Q.length-1],pt=ft.pop(),P=!0),lt.leaf&&-1!==(ot=H(et,lt.children,dt)))return lt.children.splice(ot,1),Q.push(lt),this._condense(Q),this;P||lt.leaf||!it(lt,St)?B?(pt++,lt=B.children[pt],P=!1):lt=null:(Q.push(lt),ft.push(pt),pt=0,B=lt,lt=lt.children[0])}return this},toBBox:function(et){return et},compareMinX:W,compareMinY:k,toJSON:function(){return this.data},fromJSON:function(et){return this.data=et,this},_all:function(et,dt){for(var lt=[];et;)et.leaf?dt.push.apply(dt,et.children):lt.push.apply(lt,et.children),et=lt.pop();return dt},_build:function(et,dt,lt,St){var pt,Q=lt-dt+1,ft=this._maxEntries;if(Q<=ft)return q(pt=K(et.slice(dt,lt+1)),this.toBBox),pt;St||(St=Math.ceil(Math.log(Q)/Math.log(ft)),ft=Math.ceil(Q/Math.pow(ft,St-1))),(pt=K([])).leaf=!1,pt.height=St;var P,at,nt,Gt,B=Math.ceil(Q/ft),ot=B*Math.ceil(Math.sqrt(ft));for(st(et,dt,lt,ot,this.compareMinX),P=dt;P<=lt;P+=ot)for(st(et,P,nt=Math.min(P+ot-1,lt),B,this.compareMinY),at=P;at<=nt;at+=B)Gt=Math.min(at+B-1,nt),pt.children.push(this._build(et,at,Gt,St-1));return q(pt,this.toBBox),pt},_chooseSubtree:function(et,dt,lt,St){for(var Q,ft,pt,B,ot,P,at,nt;St.push(dt),!dt.leaf&&St.length-1!==lt;){for(at=nt=1/0,Q=0,ft=dt.children.length;Q<ft;Q++)ot=A(pt=dt.children[Q]),(P=Z(et,pt)-ot)<nt?(nt=P,at=ot<at?ot:at,B=pt):P===nt&&ot<at&&(at=ot,B=pt);dt=B||dt.children[0]}return dt},_insert:function(et,dt,lt){var Q=lt?et:(0,this.toBBox)(et),ft=[],pt=this._chooseSubtree(Q,this.data,dt,ft);for(pt.children.push(et),R(pt,Q);dt>=0&&ft[dt].children.length>this._maxEntries;)this._split(ft,dt),dt--;this._adjustParentBBoxes(Q,ft,dt)},_split:function(et,dt){var lt=et[dt],St=lt.children.length,Q=this._minEntries;this._chooseSplitAxis(lt,Q,St);var ft=this._chooseSplitIndex(lt,Q,St),pt=K(lt.children.splice(ft,lt.children.length-ft));pt.height=lt.height,pt.leaf=lt.leaf,q(lt,this.toBBox),q(pt,this.toBBox),dt?et[dt-1].children.push(pt):this._splitRoot(lt,pt)},_splitRoot:function(et,dt){this.data=K([et,dt]),this.data.height=et.height+1,this.data.leaf=!1,q(this.data,this.toBBox)},_chooseSplitIndex:function(et,dt,lt){var St,Q,ft,pt,B,ot,P,at;for(ot=P=1/0,St=dt;St<=lt-dt;St++)pt=G(Q=Y(et,0,St,this.toBBox),ft=Y(et,St,lt,this.toBBox)),B=A(Q)+A(ft),pt<ot?(ot=pt,at=St,P=B<P?B:P):pt===ot&&B<P&&(P=B,at=St);return at},_chooseSplitAxis:function(et,dt,lt){var St=et.leaf?this.compareMinX:W,Q=et.leaf?this.compareMinY:k;this._allDistMargin(et,dt,lt,St)<this._allDistMargin(et,dt,lt,Q)&&et.children.sort(St)},_allDistMargin:function(et,dt,lt,St){et.children.sort(St);var ot,P,Q=this.toBBox,ft=Y(et,0,dt,Q),pt=Y(et,lt-dt,lt,Q),B=X(ft)+X(pt);for(ot=dt;ot<lt-dt;ot++)P=et.children[ot],R(ft,et.leaf?Q(P):P),B+=X(ft);for(ot=lt-dt-1;ot>=dt;ot--)P=et.children[ot],R(pt,et.leaf?Q(P):P),B+=X(pt);return B},_adjustParentBBoxes:function(et,dt,lt){for(var St=lt;St>=0;St--)R(dt[St],et)},_condense:function(et){for(var lt,dt=et.length-1;dt>=0;dt--)0===et[dt].children.length?dt>0?(lt=et[dt-1].children).splice(lt.indexOf(et[dt]),1):this.clear():q(et[dt],this.toBBox)},_initFormat:function(et){var dt=["return a"," - b",";"];this.compareMinX=new Function("a","b",dt.join(et[0])),this.compareMinY=new Function("a","b",dt.join(et[1])),this.toBBox=new Function("a","return {minX: a"+et[0]+", minY: a"+et[1]+", maxX: a"+et[2]+", maxY: a"+et[3]+"};")}}},3817:(Lt,ut,y)=>{"use strict";var $=y(9789),V=y(5223),H=Object;Lt.exports=$(function(){if(null==this||this!==H(this))throw new V("RegExp.prototype.flags getter called on non-object");var Y="";return this.hasIndices&&(Y+="d"),this.global&&(Y+="g"),this.ignoreCase&&(Y+="i"),this.multiline&&(Y+="m"),this.dotAll&&(Y+="s"),this.unicode&&(Y+="u"),this.unicodeSets&&(Y+="v"),this.sticky&&(Y+="y"),Y},"get flags",!0)},1139:(Lt,ut,y)=>{"use strict";var $=y(1648),V=y(5436),H=y(3817),q=y(4861),Y=y(6002),R=V(q());$(R,{getPolyfill:q,implementation:H,shim:Y}),Lt.exports=R},4861:(Lt,ut,y)=>{"use strict";var $=y(3817),V=y(1648).supportsDescriptors,H=Object.getOwnPropertyDescriptor;Lt.exports=function(){if(V&&"gim"===/a/gim.flags){var Y=H(RegExp.prototype,"flags");if(Y&&"function"==typeof Y.get&&"boolean"==typeof RegExp.prototype.dotAll&&"boolean"==typeof RegExp.prototype.hasIndices){var R="",W={};if(Object.defineProperty(W,"hasIndices",{get:function(){R+="d"}}),Object.defineProperty(W,"sticky",{get:function(){R+="y"}}),"dy"===R)return Y.get}}return $}},6002:(Lt,ut,y)=>{"use strict";var $=y(1648).supportsDescriptors,V=y(4861),H=Object.getOwnPropertyDescriptor,q=Object.defineProperty,Y=TypeError,R=Object.getPrototypeOf,W=/a/;Lt.exports=function(){if(!$||!R)throw new Y("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");var A=V(),X=R(W),Z=H(X,"flags");return(!Z||Z.get!==A)&&q(X,"flags",{configurable:!0,enumerable:!1,get:A}),A}},6138:function(Lt,ut){!function(y){"use strict";function H(it,bt,K,st,et){let dt,lt,St,Q,ft=bt[0],pt=st[0],B=0,ot=0;pt>ft==pt>-ft?(dt=ft,ft=bt[++B]):(dt=pt,pt=st[++ot]);let P=0;if(B<it&&ot<K)for(pt>ft==pt>-ft?(St=dt-((lt=ft+dt)-ft),ft=bt[++B]):(St=dt-((lt=pt+dt)-pt),pt=st[++ot]),dt=lt,0!==St&&(et[P++]=St);B<it&&ot<K;)pt>ft==pt>-ft?(St=dt-((lt=dt+ft)-(Q=lt-dt))+(ft-Q),ft=bt[++B]):(St=dt-((lt=dt+pt)-(Q=lt-dt))+(pt-Q),pt=st[++ot]),dt=lt,0!==St&&(et[P++]=St);for(;B<it;)St=dt-((lt=dt+ft)-(Q=lt-dt))+(ft-Q),ft=bt[++B],dt=lt,0!==St&&(et[P++]=St);for(;ot<K;)St=dt-((lt=dt+pt)-(Q=lt-dt))+(pt-Q),pt=st[++ot],dt=lt,0!==St&&(et[P++]=St);return 0===dt&&0!==P||(et[P++]=dt),P}function q(it){return new Float64Array(it)}const k=q(4),A=q(8),X=q(12),Z=q(16),G=q(4);y.orient2d=function(it,bt,K,st,et,dt){const lt=(bt-dt)*(K-et),St=(it-et)*(st-dt),Q=lt-St;if(0===lt||0===St||lt>0!=St>0)return Q;const ft=Math.abs(lt+St);return Math.abs(Q)>=33306690738754716e-32*ft?Q:-function(pt,B,ot,P,at,nt,Gt){let O,Ct,yt,vt,xt,Mt,It,re,Bt,ee,jt,se,be,Me,Xe,Ue,De,Tn;const On=pt-at,ne=ot-at,pe=B-nt,Ie=P-nt;xt=(Xe=(re=On-(It=(Mt=134217729*On)-(Mt-On)))*(ee=Ie-(Bt=(Mt=134217729*Ie)-(Mt-Ie)))-((Me=On*Ie)-It*Bt-re*Bt-It*ee))-(jt=Xe-(De=(re=pe-(It=(Mt=134217729*pe)-(Mt-pe)))*(ee=ne-(Bt=(Mt=134217729*ne)-(Mt-ne)))-((Ue=pe*ne)-It*Bt-re*Bt-It*ee))),k[0]=Xe-(jt+xt)+(xt-De),xt=(be=Me-((se=Me+jt)-(xt=se-Me))+(jt-xt))-(jt=be-Ue),k[1]=be-(jt+xt)+(xt-Ue),xt=(Tn=se+jt)-se,k[2]=se-(Tn-xt)+(jt-xt),k[3]=Tn;let Je=function(hi,di){let to=di[0];for(let ii=1;ii<4;ii++)to+=di[ii];return to}(0,k),Gn=22204460492503146e-32*Gt;if(Je>=Gn||-Je>=Gn||(O=pt-(On+(xt=pt-On))+(xt-at),yt=ot-(ne+(xt=ot-ne))+(xt-at),Ct=B-(pe+(xt=B-pe))+(xt-nt),vt=P-(Ie+(xt=P-Ie))+(xt-nt),0===O&&0===Ct&&0===yt&&0===vt)||(Gn=11093356479670487e-47*Gt+33306690738754706e-32*Math.abs(Je),(Je+=On*vt+Ie*O-(pe*yt+ne*Ct))>=Gn||-Je>=Gn))return Je;xt=(Xe=(re=O-(It=(Mt=134217729*O)-(Mt-O)))*(ee=Ie-(Bt=(Mt=134217729*Ie)-(Mt-Ie)))-((Me=O*Ie)-It*Bt-re*Bt-It*ee))-(jt=Xe-(De=(re=Ct-(It=(Mt=134217729*Ct)-(Mt-Ct)))*(ee=ne-(Bt=(Mt=134217729*ne)-(Mt-ne)))-((Ue=Ct*ne)-It*Bt-re*Bt-It*ee))),G[0]=Xe-(jt+xt)+(xt-De),xt=(be=Me-((se=Me+jt)-(xt=se-Me))+(jt-xt))-(jt=be-Ue),G[1]=be-(jt+xt)+(xt-Ue),xt=(Tn=se+jt)-se,G[2]=se-(Tn-xt)+(jt-xt),G[3]=Tn;const Er=H(4,k,4,G,A);xt=(Xe=(re=On-(It=(Mt=134217729*On)-(Mt-On)))*(ee=vt-(Bt=(Mt=134217729*vt)-(Mt-vt)))-((Me=On*vt)-It*Bt-re*Bt-It*ee))-(jt=Xe-(De=(re=pe-(It=(Mt=134217729*pe)-(Mt-pe)))*(ee=yt-(Bt=(Mt=134217729*yt)-(Mt-yt)))-((Ue=pe*yt)-It*Bt-re*Bt-It*ee))),G[0]=Xe-(jt+xt)+(xt-De),xt=(be=Me-((se=Me+jt)-(xt=se-Me))+(jt-xt))-(jt=be-Ue),G[1]=be-(jt+xt)+(xt-Ue),xt=(Tn=se+jt)-se,G[2]=se-(Tn-xt)+(jt-xt),G[3]=Tn;const Nn=H(Er,A,4,G,X);xt=(Xe=(re=O-(It=(Mt=134217729*O)-(Mt-O)))*(ee=vt-(Bt=(Mt=134217729*vt)-(Mt-vt)))-((Me=O*vt)-It*Bt-re*Bt-It*ee))-(jt=Xe-(De=(re=Ct-(It=(Mt=134217729*Ct)-(Mt-Ct)))*(ee=yt-(Bt=(Mt=134217729*yt)-(Mt-yt)))-((Ue=Ct*yt)-It*Bt-re*Bt-It*ee))),G[0]=Xe-(jt+xt)+(xt-De),xt=(be=Me-((se=Me+jt)-(xt=se-Me))+(jt-xt))-(jt=be-Ue),G[1]=be-(jt+xt)+(xt-Ue),xt=(Tn=se+jt)-se,G[2]=se-(Tn-xt)+(jt-xt),G[3]=Tn;const Yn=H(Nn,X,4,G,Z);return Z[Yn-1]}(it,bt,K,st,et,dt,ft)},y.orient2dfast=function(it,bt,K,st,et,dt){return(bt-dt)*(K-et)-(it-et)*(st-dt)},Object.defineProperty(y,"__esModule",{value:!0})}(ut)},9128:(Lt,ut,y)=>{var $=y(9864),V=y(3919),H=y(3263),q=y(5353),Y=y(3358),R=y(3789),W=y(2508);W.alea=$,W.xor128=V,W.xorwow=H,W.xorshift7=q,W.xor4096=Y,W.tychei=R,Lt.exports=W},9864:function(Lt,ut,y){var $;!function(V,H,q){function Y(A){var X=this,Z=function k(){var A=4022871197;return function(Z){Z=String(Z);for(var G=0;G<Z.length;G++){var it=.02519603282416938*(A+=Z.charCodeAt(G));it-=A=it>>>0,A=(it*=A)>>>0,A+=4294967296*(it-=A)}return 2.3283064365386963e-10*(A>>>0)}}();X.next=function(){var G=2091639*X.s0+2.3283064365386963e-10*X.c;return X.s0=X.s1,X.s1=X.s2,X.s2=G-(X.c=0|G)},X.c=1,X.s0=Z(" "),X.s1=Z(" "),X.s2=Z(" "),X.s0-=Z(A),X.s0<0&&(X.s0+=1),X.s1-=Z(A),X.s1<0&&(X.s1+=1),X.s2-=Z(A),X.s2<0&&(X.s2+=1),Z=null}function R(A,X){return X.c=A.c,X.s0=A.s0,X.s1=A.s1,X.s2=A.s2,X}function W(A,X){var Z=new Y(A),G=X&&X.state,it=Z.next;return it.int32=function(){return 4294967296*Z.next()|0},it.double=function(){return it()+11102230246251565e-32*(2097152*it()|0)},it.quick=it,G&&("object"==typeof G&&R(G,Z),it.state=function(){return R(Z,{})}),it}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.alea=W}(0,Lt=y.nmd(Lt))},3789:function(Lt,ut,y){var $;!function(V,H,q){function Y(k){var A=this,X="";A.next=function(){var G=A.b,it=A.c,bt=A.d,K=A.a;return G=G<<25^G>>>7^it,it=it-bt|0,bt=bt<<24^bt>>>8^K,K=K-G|0,A.b=G=G<<20^G>>>12^it,A.c=it=it-bt|0,A.d=bt<<16^it>>>16^K,A.a=K-G|0},A.a=0,A.b=0,A.c=-1640531527,A.d=1367130551,k===Math.floor(k)?(A.a=k/4294967296|0,A.b=0|k):X+=k;for(var Z=0;Z<X.length+20;Z++)A.b^=0|X.charCodeAt(Z),A.next()}function R(k,A){return A.a=k.a,A.b=k.b,A.c=k.c,A.d=k.d,A}function W(k,A){var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&("object"==typeof Z&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.tychei=W}(0,Lt=y.nmd(Lt))},3919:function(Lt,ut,y){var $;!function(V,H,q){function Y(k){var A=this,X="";A.x=0,A.y=0,A.z=0,A.w=0,A.next=function(){var G=A.x^A.x<<11;return A.x=A.y,A.y=A.z,A.z=A.w,A.w^=A.w>>>19^G^G>>>8},k===(0|k)?A.x=k:X+=k;for(var Z=0;Z<X.length+64;Z++)A.x^=0|X.charCodeAt(Z),A.next()}function R(k,A){return A.x=k.x,A.y=k.y,A.z=k.z,A.w=k.w,A}function W(k,A){var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&("object"==typeof Z&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.xor128=W}(0,Lt=y.nmd(Lt))},3358:function(Lt,ut,y){var $;!function(V,H,q){function Y(k){var A=this;A.next=function(){var bt,K,Z=A.w,G=A.X,it=A.i;return A.w=Z=Z+1640531527|0,K=G[it+34&127],bt=G[it=it+1&127],K^=K<<13,bt^=bt<<17,K=G[it]=(K^=K>>>15)^(bt^=bt>>>12),A.i=it,K+(Z^Z>>>16)|0},function X(Z,G){var it,bt,K,st,et,dt=[],lt=128;for(G===(0|G)?(bt=G,G=null):(G+="\0",bt=0,lt=Math.max(lt,G.length)),K=0,st=-32;st<lt;++st)G&&(bt^=G.charCodeAt((st+32)%G.length)),0===st&&(et=bt),bt^=bt<<10,bt^=bt>>>15,bt^=bt<<4,bt^=bt>>>13,st>=0&&(K=0==(it=dt[127&st]^=bt+(et=et+1640531527|0))?K+1:0);for(K>=128&&(dt[127&(G&&G.length||0)]=-1),K=127,st=512;st>0;--st)bt=dt[K+34&127],it=dt[K=K+1&127],bt^=bt<<13,it^=it<<17,dt[K]=(bt^=bt>>>15)^(it^=it>>>12);Z.w=et,Z.X=dt,Z.i=K}(A,k)}function R(k,A){return A.i=k.i,A.w=k.w,A.X=k.X.slice(),A}function W(k,A){null==k&&(k=+new Date);var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&(Z.X&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.xor4096=W}(0,Lt=y.nmd(Lt))},5353:function(Lt,ut,y){var $;!function(V,H,q){function Y(k){var A=this;A.next=function(){var it,bt,Z=A.x,G=A.i;return it=Z[G],bt=(it^=it>>>7)^it<<24,bt^=(it=Z[G+1&7])^it>>>10,bt^=(it=Z[G+3&7])^it>>>3,bt^=(it=Z[G+4&7])^it<<7,it=Z[G+7&7],Z[G]=bt^=(it^=it<<13)^it<<9,A.i=G+1&7,bt},function X(Z,G){var it,K=[];if(G===(0|G))K[0]=G;else for(G=""+G,it=0;it<G.length;++it)K[7&it]=K[7&it]<<15^G.charCodeAt(it)+K[it+1&7]<<13;for(;K.length<8;)K.push(0);for(it=0;it<8&&0===K[it];++it);for(8==it&&(K[7]=-1),Z.x=K,Z.i=0,it=256;it>0;--it)Z.next()}(A,k)}function R(k,A){return A.x=k.x.slice(),A.i=k.i,A}function W(k,A){null==k&&(k=+new Date);var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&(Z.x&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.xorshift7=W}(0,Lt=y.nmd(Lt))},3263:function(Lt,ut,y){var $;!function(V,H,q){function Y(k){var A=this,X="";A.next=function(){var G=A.x^A.x>>>2;return A.x=A.y,A.y=A.z,A.z=A.w,A.w=A.v,(A.d=A.d+362437|0)+(A.v=A.v^A.v<<4^G^G<<1)|0},A.x=0,A.y=0,A.z=0,A.w=0,A.v=0,k===(0|k)?A.x=k:X+=k;for(var Z=0;Z<X.length+64;Z++)A.x^=0|X.charCodeAt(Z),Z==X.length&&(A.d=A.x<<10^A.x>>>4),A.next()}function R(k,A){return A.x=k.x,A.y=k.y,A.z=k.z,A.w=k.w,A.v=k.v,A.d=k.d,A}function W(k,A){var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&("object"==typeof Z&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.xorwow=W}(0,Lt=y.nmd(Lt))},2508:function(Lt,ut,y){var $;!function(V,H,q){var it,Y=256,A=q.pow(Y,6),X=q.pow(2,52),Z=2*X,G=Y-1;function bt(Q,ft,pt){var B=[],ot=dt(et((ft=1==ft?{entropy:!0}:ft||{}).entropy?[Q,St(H)]:Q??function lt(){try{var Q;return it&&(Q=it.randomBytes)?Q=Q(Y):(Q=new Uint8Array(Y),(V.crypto||V.msCrypto).getRandomValues(Q)),St(Q)}catch{var ft=V.navigator,pt=ft&&ft.plugins;return[+new Date,V,pt,V.screen,St(H)]}}(),3),B),P=new K(B),at=function(){for(var nt=P.g(6),Gt=A,O=0;nt<X;)nt=(nt+O)*Y,Gt*=Y,O=P.g(1);for(;nt>=Z;)nt/=2,Gt/=2,O>>>=1;return(nt+O)/Gt};return at.int32=function(){return 0|P.g(4)},at.quick=function(){return P.g(4)/4294967296},at.double=at,dt(St(P.S),H),(ft.pass||pt||function(nt,Gt,O,Ct){return Ct&&(Ct.S&&st(Ct,P),nt.state=function(){return st(P,{})}),O?(q.random=nt,Gt):nt})(at,ot,"global"in ft?ft.global:this==q,ft.state)}function K(Q){var ft,pt=Q.length,B=this,ot=0,P=B.i=B.j=0,at=B.S=[];for(pt||(Q=[pt++]);ot<Y;)at[ot]=ot++;for(ot=0;ot<Y;ot++)at[ot]=at[P=G&P+Q[ot%pt]+(ft=at[ot])],at[P]=ft;(B.g=function(nt){for(var Gt,O=0,Ct=B.i,yt=B.j,vt=B.S;nt--;)Gt=vt[Ct=G&Ct+1],O=O*Y+vt[G&(vt[Ct]=vt[yt=G&yt+Gt])+(vt[yt]=Gt)];return B.i=Ct,B.j=yt,O})(Y)}function st(Q,ft){return ft.i=Q.i,ft.j=Q.j,ft.S=Q.S.slice(),ft}function et(Q,ft){var ot,pt=[],B=typeof Q;if(ft&&"object"==B)for(ot in Q)try{pt.push(et(Q[ot],ft-1))}catch{}return pt.length?pt:"string"==B?Q:Q+"\0"}function dt(Q,ft){for(var B,pt=Q+"",ot=0;ot<pt.length;)ft[G&ot]=G&(B^=19*ft[G&ot])+pt.charCodeAt(ot++);return St(ft)}function St(Q){return String.fromCharCode.apply(0,Q)}if(dt(q.random(),H),Lt.exports){Lt.exports=bt;try{it=y(5042)}catch{}}else void 0!==($=function(){return bt}.call(ut,y,ut,Lt))&&(Lt.exports=$)}(typeof self<"u"?self:this,[],Math)},2245:(Lt,ut,y)=>{"use strict";var $=y(491),V=y(9224),H=y(2486)(),q=y(9262),Y=y(5223),R=$("%Math.floor%");Lt.exports=function(k,A){if("function"!=typeof k)throw new Y("`fn` is not a function");if("number"!=typeof A||A<0||A>4294967295||R(A)!==A)throw new Y("`length` must be a positive 32-bit integer");var X=arguments.length>2&&!!arguments[2],Z=!0,G=!0;if("length"in k&&q){var it=q(k,"length");it&&!it.configurable&&(Z=!1),it&&!it.writable&&(G=!1)}return(Z||G||!X)&&(H?V(k,"length",A,!0,!0):V(k,"length",A)),k}},9789:(Lt,ut,y)=>{"use strict";var $=y(9224),V=y(2486)(),H=y(1552).functionsHaveConfigurableNames(),q=y(5223);Lt.exports=function(R,W){if("function"!=typeof R)throw new q("`fn` is not a function");return(!(arguments.length>2&&arguments[2])||H)&&(V?$(R,"name",W,!0,!0):$(R,"name",W)),R}},9579:Lt=>{"use strict";Lt.exports={eudist:function(y,$,V){for(var H=y.length,q=0,Y=0;Y<H;Y++){var R=(y[Y]||0)-($[Y]||0);q+=R*R}return V?Math.sqrt(q):q},mandist:function(y,$,V){for(var H=y.length,q=0,Y=0;Y<H;Y++)q+=Math.abs((y[Y]||0)-($[Y]||0));return V?Math.sqrt(q):q},dist:function(y,$,V){var H=Math.abs(y-$);return V?H:H*H}}},7180:(Lt,ut,y)=>{"use strict";var $=y(9579),V=$.eudist,H=$.dist;Lt.exports={kmrand:function(Y,R){for(var W={},k=[],A=R<<2,X=Y.length,Z=Y[0].length>0;k.length<R&&A-- >0;){var G=Y[Math.floor(Math.random()*X)],it=Z?G.join("_"):""+G;W[it]||(W[it]=!0,k.push(G))}if(k.length<R)throw new Error("Error initializating clusters");return k},kmpp:function(Y,R){var W=Y[0].length?V:H,k=[],A=Y.length,X=Y[0].length>0,G=Y[Math.floor(Math.random()*A)];for(X&&G.join("_"),k.push(G);k.length<R;){for(var bt=[],K=k.length,st=0,et=[],dt=0;dt<A;dt++){for(var lt=1/0,St=0;St<K;St++){var Q=W(Y[dt],k[St]);Q<=lt&&(lt=Q)}bt[dt]=lt}for(var ft=0;ft<A;ft++)st+=bt[ft];for(var pt=0;pt<A;pt++)et[pt]={i:pt,v:Y[pt],pr:bt[pt]/st,cs:0};et.sort(function(at,nt){return at.pr-nt.pr}),et[0].cs=et[0].pr;for(var B=1;B<A;B++)et[B].cs=et[B-1].cs+et[B].pr;for(var ot=Math.random(),P=0;P<A-1&&et[P++].cs<ot;);k.push(et[P-1].v)}return k}}},3282:(Lt,ut,y)=>{"use strict";var $=y(9579),V=y(7180),H=$.eudist,R=V.kmrand,W=V.kmpp;function A(Z,G,it){it=it||[];for(var bt=0;bt<Z;bt++)it[bt]=G;return it}Lt.exports=function X(Z,G,it,bt){var K=[],st=[],et=[],dt=[],lt=!1,St=bt||1e4,Q=Z.length,ft=Z[0].length,pt=ft>0,B=[];if(it)K="kmrand"==it?R(Z,G):"kmpp"==it?W(Z,G):it;else for(var ot={};K.length<G;){var P=Math.floor(Math.random()*Q);ot[P]||(ot[P]=!0,K.push(Z[P]))}do{A(G,0,B);for(var at=0;at<Q;at++){for(var nt=1/0,Gt=0,O=0;O<G;O++)(dt=pt?H(Z[at],K[O]):Math.abs(Z[at]-K[O]))<=nt&&(nt=dt,Gt=O);et[at]=Gt,B[Gt]++}for(var Ct=[],vt=(st=[],0);vt<G;vt++)Ct[vt]=pt?A(ft,0,Ct[vt]):0,st[vt]=K[vt];if(pt){for(var xt=0;xt<G;xt++)K[xt]=[];for(var Mt=0;Mt<Q;Mt++)for(var re=Ct[et[Mt]],Bt=Z[Mt],ee=0;ee<ft;ee++)re[ee]+=Bt[ee];lt=!0;for(var jt=0;jt<G;jt++){for(var se=K[jt],be=Ct[jt],Me=st[jt],Xe=B[jt],Ue=0;Ue<ft;Ue++)se[Ue]=be[Ue]/Xe||0;if(lt)for(var De=0;De<ft;De++)if(Me[De]!=se[De]){lt=!1;break}}}else{for(var Tn=0;Tn<Q;Tn++)Ct[et[Tn]]+=Z[Tn];for(var ne=0;ne<G;ne++)K[ne]=Ct[ne]/B[ne]||0;lt=!0;for(var pe=0;pe<G;pe++)if(st[pe]!=K[pe]){lt=!1;break}}lt=lt||--St<=0}while(!lt);return{it:1e4-St,k:G,idxs:et,centroids:K}}},7935:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{default:()=>$});class ${constructor(q=[],Y=V){if(this.data=q,this.length=this.data.length,this.compare=Y,this.length>0)for(let R=(this.length>>1)-1;R>=0;R--)this._down(R)}push(q){this.data.push(q),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const q=this.data[0],Y=this.data.pop();return this.length--,this.length>0&&(this.data[0]=Y,this._down(0)),q}peek(){return this.data[0]}_up(q){const{data:Y,compare:R}=this,W=Y[q];for(;q>0;){const k=q-1>>1,A=Y[k];if(R(W,A)>=0)break;Y[q]=A,q=k}Y[q]=W}_down(q){const{data:Y,compare:R}=this,W=this.length>>1,k=Y[q];for(;q<W;){let A=1+(q<<1),X=Y[A];const Z=A+1;if(Z<this.length&&R(Y[Z],X)<0&&(A=Z,X=Y[Z]),R(X,k)>=0)break;Y[q]=X,q=A}Y[q]=k}}function V(H,q){return H<q?-1:H>q?1:0}},4855:function(Lt,ut){!function(y){"use strict";function $(){}function V(l){this.message=l||""}function H(l){this.message=l||""}function q(l){this.message=l||""}function Y(){}function R(l){return null===l?wr:l.color}function W(l){return null===l?null:l.parent}function k(l,h){null!==l&&(l.color=h)}function A(l){return null===l?null:l.left}function X(l){return null===l?null:l.right}function Z(){this.root_=null,this.size_=0}function G(){}function it(){this.array_=[],arguments[0]instanceof je&&this.addAll(arguments[0])}function bt(){}function K(l){this.message=l||""}function st(){this.array_=[]}"fill"in Array.prototype||Object.defineProperty(Array.prototype,"fill",{configurable:!0,value:function(l){if(null==this)throw new TypeError(this+" is not an object");var h=Object(this),m=Math.max(Math.min(h.length,9007199254740991),0)||0,_=1 in arguments&&parseInt(Number(arguments[1]),10)||0;_=_<0?Math.max(m+_,0):Math.min(_,m);var C=2 in arguments&&void 0!==arguments[2]?parseInt(Number(arguments[2]),10)||0:m;for(C=C<0?Math.max(m+arguments[2],0):Math.min(C,m);_<C;)h[_]=l,++_;return h},writable:!0}),Number.isFinite=Number.isFinite||function(l){return"number"==typeof l&&isFinite(l)},Number.isInteger=Number.isInteger||function(l){return"number"==typeof l&&isFinite(l)&&Math.floor(l)===l},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(l){return l!=l},Math.trunc=Math.trunc||function(l){return l<0?Math.ceil(l):Math.floor(l)};var et=function(){};et.prototype.interfaces_=function(){return[]},et.prototype.getClass=function(){return et},et.prototype.equalsWithTolerance=function(l,h,m){return Math.abs(l-h)<=m};var dt=function(l){function h(m){l.call(this,m),this.name="IllegalArgumentException",this.message=m,this.stack=(new l).stack}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h}(Error),lt=function(){},St={MAX_VALUE:{configurable:!0}};lt.isNaN=function(l){return Number.isNaN(l)},lt.doubleToLongBits=function(l){return l},lt.longBitsToDouble=function(l){return l},lt.isInfinite=function(l){return!Number.isFinite(l)},St.MAX_VALUE.get=function(){return Number.MAX_VALUE},Object.defineProperties(lt,St);var Q=function(){},ft=function(){},pt=function(){},B=function l(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)this.x=0,this.y=0,this.z=l.NULL_ORDINATE;else if(1===arguments.length){var h=arguments[0];this.x=h.x,this.y=h.y,this.z=h.z}else 2===arguments.length?(this.x=arguments[0],this.y=arguments[1],this.z=l.NULL_ORDINATE):3===arguments.length&&(this.x=arguments[0],this.y=arguments[1],this.z=arguments[2])},ot={DimensionalComparator:{configurable:!0},serialVersionUID:{configurable:!0},NULL_ORDINATE:{configurable:!0},X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0}};B.prototype.setOrdinate=function(l,h){switch(l){case B.X:this.x=h;break;case B.Y:this.y=h;break;case B.Z:this.z=h;break;default:throw new dt("Invalid ordinate index: "+l)}},B.prototype.equals2D=function(){if(1===arguments.length){var l=arguments[0];return this.x===l.x&&this.y===l.y}if(2===arguments.length){var h=arguments[0],m=arguments[1];return!!et.equalsWithTolerance(this.x,h.x,m)&&!!et.equalsWithTolerance(this.y,h.y,m)}},B.prototype.getOrdinate=function(l){switch(l){case B.X:return this.x;case B.Y:return this.y;case B.Z:return this.z}throw new dt("Invalid ordinate index: "+l)},B.prototype.equals3D=function(l){return this.x===l.x&&this.y===l.y&&(this.z===l.z||lt.isNaN(this.z))&&lt.isNaN(l.z)},B.prototype.equals=function(l){return l instanceof B&&this.equals2D(l)},B.prototype.equalInZ=function(l,h){return et.equalsWithTolerance(this.z,l.z,h)},B.prototype.compareTo=function(l){return this.x<l.x?-1:this.x>l.x?1:this.y<l.y?-1:this.y>l.y?1:0},B.prototype.clone=function(){},B.prototype.copy=function(){return new B(this)},B.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+")"},B.prototype.distance3D=function(l){var h=this.x-l.x,m=this.y-l.y,_=this.z-l.z;return Math.sqrt(h*h+m*m+_*_)},B.prototype.distance=function(l){var h=this.x-l.x,m=this.y-l.y;return Math.sqrt(h*h+m*m)},B.prototype.hashCode=function(){var l=17;return 37*(l=37*l+B.hashCode(this.x))+B.hashCode(this.y)},B.prototype.setCoordinate=function(l){this.x=l.x,this.y=l.y,this.z=l.z},B.prototype.interfaces_=function(){return[Q,ft,$]},B.prototype.getClass=function(){return B},B.hashCode=function(){if(1===arguments.length){var h=lt.doubleToLongBits(arguments[0]);return Math.trunc((h^h)>>>32)}},ot.DimensionalComparator.get=function(){return P},ot.serialVersionUID.get=function(){return 0x5cbf2c235c7e5800},ot.NULL_ORDINATE.get=function(){return lt.NaN},ot.X.get=function(){return 0},ot.Y.get=function(){return 1},ot.Z.get=function(){return 2},Object.defineProperties(B,ot);var P=function(l){if(this._dimensionsToTest=2,0!==arguments.length&&1===arguments.length){var h=arguments[0];if(2!==h&&3!==h)throw new dt("only 2 or 3 dimensions may be specified");this._dimensionsToTest=h}};P.prototype.compare=function(l,h){var m=l,_=h,C=P.compare(m.x,_.x);if(0!==C)return C;var F=P.compare(m.y,_.y);return 0!==F?F:this._dimensionsToTest<=2?0:P.compare(m.z,_.z)},P.prototype.interfaces_=function(){return[pt]},P.prototype.getClass=function(){return P},P.compare=function(l,h){return l<h?-1:l>h?1:lt.isNaN(l)?lt.isNaN(h)?0:-1:lt.isNaN(h)?1:0};var at=function(){};at.prototype.create=function(){},at.prototype.interfaces_=function(){return[]},at.prototype.getClass=function(){return at};var nt=function(){},Gt={INTERIOR:{configurable:!0},BOUNDARY:{configurable:!0},EXTERIOR:{configurable:!0},NONE:{configurable:!0}};nt.prototype.interfaces_=function(){return[]},nt.prototype.getClass=function(){return nt},nt.toLocationSymbol=function(l){switch(l){case nt.EXTERIOR:return"e";case nt.BOUNDARY:return"b";case nt.INTERIOR:return"i";case nt.NONE:return"-"}throw new dt("Unknown location value: "+l)},Gt.INTERIOR.get=function(){return 0},Gt.BOUNDARY.get=function(){return 1},Gt.EXTERIOR.get=function(){return 2},Gt.NONE.get=function(){return-1},Object.defineProperties(nt,Gt);var O=function(l,h){return l.interfaces_&&l.interfaces_().indexOf(h)>-1},Ct=function(){},yt={LOG_10:{configurable:!0}};Ct.prototype.interfaces_=function(){return[]},Ct.prototype.getClass=function(){return Ct},Ct.log10=function(l){var h=Math.log(l);return lt.isInfinite(h)||lt.isNaN(h)?h:h/Ct.LOG_10},Ct.min=function(l,h,m,_){var C=l;return h<C&&(C=h),m<C&&(C=m),_<C&&(C=_),C},Ct.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var l=arguments[0],h=arguments[1],m=arguments[2];return l<h?h:l>m?m:l}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var _=arguments[0],C=arguments[1],F=arguments[2];return _<C?C:_>F?F:_}},Ct.wrap=function(l,h){return l<0?h- -l%h:l%h},Ct.max=function(){if(3===arguments.length){var h=arguments[1],m=arguments[2],_=arguments[0];return h>_&&(_=h),m>_&&(_=m),_}if(4===arguments.length){var F=arguments[1],rt=arguments[2],Dt=arguments[3],Qt=arguments[0];return F>Qt&&(Qt=F),rt>Qt&&(Qt=rt),Dt>Qt&&(Qt=Dt),Qt}},Ct.average=function(l,h){return(l+h)/2},yt.LOG_10.get=function(){return Math.log(10)},Object.defineProperties(Ct,yt);var vt=function(l){this.str=l};vt.prototype.append=function(l){this.str+=l},vt.prototype.setCharAt=function(l,h){this.str=this.str.substr(0,l)+h+this.str.substr(l+1)},vt.prototype.toString=function(l){return this.str};var xt=function(l){this.value=l};xt.prototype.intValue=function(){return this.value},xt.prototype.compareTo=function(l){return this.value<l?-1:this.value>l?1:0},xt.isNaN=function(l){return Number.isNaN(l)};var Mt=function(){};Mt.isWhitespace=function(l){return l<=32&&l>=0||127===l},Mt.toUpperCase=function(l){return l.toUpperCase()};var It=function l(){this._hi=0,this._lo=0,0===arguments.length?this.init(0):1===arguments.length?"number"==typeof arguments[0]||arguments[0]instanceof l?this.init(arguments[0]):"string"==typeof arguments[0]&&l.call(this,l.parse(arguments[0])):2===arguments.length&&this.init(arguments[0],arguments[1])},re={PI:{configurable:!0},TWO_PI:{configurable:!0},PI_2:{configurable:!0},E:{configurable:!0},NaN:{configurable:!0},EPS:{configurable:!0},SPLIT:{configurable:!0},MAX_PRINT_DIGITS:{configurable:!0},TEN:{configurable:!0},ONE:{configurable:!0},SCI_NOT_EXPONENT_CHAR:{configurable:!0},SCI_NOT_ZERO:{configurable:!0}};It.prototype.le=function(l){return(this._hi<l._hi||this._hi===l._hi)&&this._lo<=l._lo},It.prototype.extractSignificantDigits=function(l,h){var m=this.abs(),_=It.magnitude(m._hi),C=It.TEN.pow(_);(m=m.divide(C)).gt(It.TEN)?(m=m.divide(It.TEN),_+=1):m.lt(It.ONE)&&(m=m.multiply(It.TEN),_-=1);for(var F=_+1,rt=new vt,Dt=It.MAX_PRINT_DIGITS-1,Qt=0;Qt<=Dt;Qt++){l&&Qt===F&&rt.append(".");var fe=Math.trunc(m._hi);if(fe<0)break;var ke=!1,Ge=0;fe>9?(ke=!0,Ge="9"):Ge="0"+fe,rt.append(Ge),m=m.subtract(It.valueOf(fe)).multiply(It.TEN),ke&&m.selfAdd(It.TEN);var _n=!0,Sn=It.magnitude(m._hi);if(Sn<0&&Math.abs(Sn)>=Dt-Qt&&(_n=!1),!_n)break}return h[0]=_,rt.toString()},It.prototype.sqr=function(){return this.multiply(this)},It.prototype.doubleValue=function(){return this._hi+this._lo},It.prototype.subtract=function(){return arguments[0]instanceof It?this.add(arguments[0].negate()):"number"==typeof arguments[0]?this.add(-arguments[0]):void 0},It.prototype.equals=function(){if(1===arguments.length){var l=arguments[0];return this._hi===l._hi&&this._lo===l._lo}},It.prototype.isZero=function(){return 0===this._hi&&0===this._lo},It.prototype.selfSubtract=function(){if(arguments[0]instanceof It){var l=arguments[0];return this.isNaN()?this:this.selfAdd(-l._hi,-l._lo)}if("number"==typeof arguments[0]){var h=arguments[0];return this.isNaN()?this:this.selfAdd(-h,0)}},It.prototype.getSpecialNumberString=function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},It.prototype.min=function(l){return this.le(l)?this:l},It.prototype.selfDivide=function(){if(1===arguments.length){if(arguments[0]instanceof It){var l=arguments[0];return this.selfDivide(l._hi,l._lo)}if("number"==typeof arguments[0])return this.selfDivide(arguments[0],0)}else if(2===arguments.length){var F,Dt,Qt,ke,m=arguments[0],C=null,rt=null,fe=null,Ge=null;return this._hi=Ge=(Qt=this._hi/m)+(fe=(this._hi-(ke=Qt*m)-(Ge=(C=(fe=It.SPLIT*Qt)-(C=fe-Qt))*(rt=(Ge=It.SPLIT*m)-(rt=Ge-m))-ke+C*(Dt=m-rt)+(F=Qt-C)*rt+F*Dt)+this._lo-Qt*arguments[1])/m),this._lo=Qt-Ge+fe,this}},It.prototype.dump=function(){return"DD<"+this._hi+", "+this._lo+">"},It.prototype.divide=function(){if(arguments[0]instanceof It){var m,C,F,Dt,l=arguments[0],h=null,_=null,rt=null,Qt=null;return m=(F=this._hi/l._hi)-(h=(rt=It.SPLIT*F)-(h=rt-F)),Qt=h*(_=(Qt=It.SPLIT*l._hi)-(_=Qt-l._hi))-(Dt=F*l._hi)+h*(C=l._hi-_)+m*_+m*C,new It(Qt=F+(rt=(this._hi-Dt-Qt+this._lo-F*l._lo)/l._hi),F-Qt+rt)}if("number"==typeof arguments[0]){var fe=arguments[0];return lt.isNaN(fe)?It.createNaN():It.copy(this).selfDivide(fe,0)}},It.prototype.ge=function(l){return(this._hi>l._hi||this._hi===l._hi)&&this._lo>=l._lo},It.prototype.pow=function(l){if(0===l)return It.valueOf(1);var h=new It(this),m=It.valueOf(1),_=Math.abs(l);if(_>1)for(;_>0;)_%2==1&&m.selfMultiply(h),(_/=2)>0&&(h=h.sqr());else m=h;return l<0?m.reciprocal():m},It.prototype.ceil=function(){if(this.isNaN())return It.NaN;var l=Math.ceil(this._hi),h=0;return l===this._hi&&(h=Math.ceil(this._lo)),new It(l,h)},It.prototype.compareTo=function(l){return this._hi<l._hi?-1:this._hi>l._hi?1:this._lo<l._lo?-1:this._lo>l._lo?1:0},It.prototype.rint=function(){return this.isNaN()?this:this.add(.5).floor()},It.prototype.setValue=function(){return arguments[0]instanceof It||"number"==typeof arguments[0]?(this.init(arguments[0]),this):void 0},It.prototype.max=function(l){return this.ge(l)?this:l},It.prototype.sqrt=function(){if(this.isZero())return It.valueOf(0);if(this.isNegative())return It.NaN;var l=1/Math.sqrt(this._hi),m=It.valueOf(this._hi*l),_=this.subtract(m.sqr())._hi*(.5*l);return m.add(_)},It.prototype.selfAdd=function(){if(1===arguments.length){if(arguments[0]instanceof It){var l=arguments[0];return this.selfAdd(l._hi,l._lo)}if("number"==typeof arguments[0]){var m,_,C,rt,Dt,h=arguments[0];return this._hi=(m=(C=this._hi+h)+(Dt=h-(rt=C-this._hi)+(this._hi-(C-rt))+this._lo))+(_=Dt+(C-m)),this._lo=_+(m-this._hi),this}}else if(2===arguments.length){var ke,Ge,Sn,Ji,Qt=arguments[0],fe=arguments[1],_n=null,Un=null,ur=null;Un=(Sn=this._hi+Qt)-(ur=Sn-this._hi),_n=(Ge=this._lo+fe)-(Ji=Ge-this._lo);var To=(ke=Sn+(ur=(Un=Qt-ur+(this._hi-Un))+Ge))+(ur=(_n=fe-Ji+(this._lo-_n))+(ur+(Sn-ke))),$a=ur+(ke-To);return this._hi=To,this._lo=$a,this}},It.prototype.selfMultiply=function(){if(1===arguments.length){if(arguments[0]instanceof It){var l=arguments[0];return this.selfMultiply(l._hi,l._lo)}if("number"==typeof arguments[0])return this.selfMultiply(arguments[0],0)}else if(2===arguments.length){var F,Dt,m=arguments[0],C=null,rt=null,Qt=null,fe=null;C=(Qt=It.SPLIT*this._hi)-this._hi,C=Qt-C;var ke=(Qt=this._hi*m)+(fe=C*(rt=(fe=It.SPLIT*m)-(rt=fe-m))-Qt+C*(Dt=m-rt)+(F=this._hi-C)*rt+F*Dt+(this._hi*arguments[1]+this._lo*m)),Ge=fe+(C=Qt-ke);return this._hi=ke,this._lo=Ge,this}},It.prototype.selfSqr=function(){return this.selfMultiply(this)},It.prototype.floor=function(){if(this.isNaN())return It.NaN;var l=Math.floor(this._hi),h=0;return l===this._hi&&(h=Math.floor(this._lo)),new It(l,h)},It.prototype.negate=function(){return this.isNaN()?this:new It(-this._hi,-this._lo)},It.prototype.clone=function(){},It.prototype.multiply=function(){if(arguments[0]instanceof It){var l=arguments[0];return l.isNaN()?It.createNaN():It.copy(this).selfMultiply(l)}if("number"==typeof arguments[0]){var h=arguments[0];return lt.isNaN(h)?It.createNaN():It.copy(this).selfMultiply(h,0)}},It.prototype.isNaN=function(){return lt.isNaN(this._hi)},It.prototype.intValue=function(){return Math.trunc(this._hi)},It.prototype.toString=function(){var l=It.magnitude(this._hi);return l>=-3&&l<=20?this.toStandardNotation():this.toSciNotation()},It.prototype.toStandardNotation=function(){var l=this.getSpecialNumberString();if(null!==l)return l;var h=new Array(1).fill(null),m=this.extractSignificantDigits(!0,h),_=h[0]+1,C=m;return"."===m.charAt(0)?C="0"+m:_<0?C="0."+It.stringOfChar("0",-_)+m:-1===m.indexOf(".")&&(C=m+It.stringOfChar("0",_-m.length)+".0"),this.isNegative()?"-"+C:C},It.prototype.reciprocal=function(){var h,_,C,rt,l=null,m=null,F=null,Dt=null;h=(C=1/this._hi)-(l=(F=It.SPLIT*C)-(l=F-C)),m=(Dt=It.SPLIT*this._hi)-this._hi;var Qt=C+(F=(1-(rt=C*this._hi)-(Dt=l*(m=Dt-m)-rt+l*(_=this._hi-m)+h*m+h*_)-C*this._lo)/this._hi);return new It(Qt,C-Qt+F)},It.prototype.toSciNotation=function(){if(this.isZero())return It.SCI_NOT_ZERO;var l=this.getSpecialNumberString();if(null!==l)return l;var h=new Array(1).fill(null),m=this.extractSignificantDigits(!1,h),_=It.SCI_NOT_EXPONENT_CHAR+h[0];if("0"===m.charAt(0))throw new Error("Found leading zero: "+m);var C="";m.length>1&&(C=m.substring(1));var F=m.charAt(0)+"."+C;return this.isNegative()?"-"+F+_:F+_},It.prototype.abs=function(){return this.isNaN()?It.NaN:this.isNegative()?this.negate():new It(this)},It.prototype.isPositive=function(){return(this._hi>0||0===this._hi)&&this._lo>0},It.prototype.lt=function(l){return(this._hi<l._hi||this._hi===l._hi)&&this._lo<l._lo},It.prototype.add=function(){if(arguments[0]instanceof It){var l=arguments[0];return It.copy(this).selfAdd(l)}if("number"==typeof arguments[0]){var h=arguments[0];return It.copy(this).selfAdd(h)}},It.prototype.init=function(){if(1===arguments.length){if("number"==typeof arguments[0])this._hi=arguments[0],this._lo=0;else if(arguments[0]instanceof It){var h=arguments[0];this._hi=h._hi,this._lo=h._lo}}else if(2===arguments.length){var _=arguments[1];this._hi=arguments[0],this._lo=_}},It.prototype.gt=function(l){return(this._hi>l._hi||this._hi===l._hi)&&this._lo>l._lo},It.prototype.isNegative=function(){return(this._hi<0||0===this._hi)&&this._lo<0},It.prototype.trunc=function(){return this.isNaN()?It.NaN:this.isPositive()?this.floor():this.ceil()},It.prototype.signum=function(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0},It.prototype.interfaces_=function(){return[$,Q,ft]},It.prototype.getClass=function(){return It},It.sqr=function(l){return It.valueOf(l).selfMultiply(l)},It.valueOf=function(){return"string"==typeof arguments[0]?It.parse(arguments[0]):"number"==typeof arguments[0]?new It(arguments[0]):void 0},It.sqrt=function(l){return It.valueOf(l).sqrt()},It.parse=function(l){for(var h=0,m=l.length;Mt.isWhitespace(l.charAt(h));)h++;var _=!1;if(h<m){var C=l.charAt(h);"-"!==C&&"+"!==C||(h++,"-"===C&&(_=!0))}for(var F=new It,rt=0,Dt=0,Qt=0;!(h>=m);){var fe=l.charAt(h);if(h++,Mt.isDigit(fe)){var ke=fe-"0";F.selfMultiply(It.TEN),F.selfAdd(ke),rt++}else{if("."!==fe){if("e"===fe||"E"===fe){var Ge=l.substring(h);try{Qt=xt.parseInt(Ge)}catch(Ji){throw Ji instanceof Error?new Error("Invalid exponent "+Ge+" in string "+l):Ji}break}throw new Error("Unexpected character '"+fe+"' at position "+h+" in string "+l)}Dt=rt}}var _n=F,Sn=rt-Dt-Qt;if(0===Sn)_n=F;else if(Sn>0){var Un=It.TEN.pow(Sn);_n=F.divide(Un)}else if(Sn<0){var ur=It.TEN.pow(-Sn);_n=F.multiply(ur)}return _?_n.negate():_n},It.createNaN=function(){return new It(lt.NaN,lt.NaN)},It.copy=function(l){return new It(l)},It.magnitude=function(l){var h=Math.abs(l),m=Math.log(h)/Math.log(10),_=Math.trunc(Math.floor(m));return 10*Math.pow(10,_)<=h&&(_+=1),_},It.stringOfChar=function(l,h){for(var m=new vt,_=0;_<h;_++)m.append(l);return m.toString()},re.PI.get=function(){return new It(3.141592653589793,12246467991473532e-32)},re.TWO_PI.get=function(){return new It(6.283185307179586,24492935982947064e-32)},re.PI_2.get=function(){return new It(1.5707963267948966,6123233995736766e-32)},re.E.get=function(){return new It(2.718281828459045,14456468917292502e-32)},re.NaN.get=function(){return new It(lt.NaN,lt.NaN)},re.EPS.get=function(){return 123259516440783e-46},re.SPLIT.get=function(){return 134217729},re.MAX_PRINT_DIGITS.get=function(){return 32},re.TEN.get=function(){return It.valueOf(10)},re.ONE.get=function(){return It.valueOf(1)},re.SCI_NOT_EXPONENT_CHAR.get=function(){return"E"},re.SCI_NOT_ZERO.get=function(){return"0.0E0"},Object.defineProperties(It,re);var Bt=function(){},ee={DP_SAFE_EPSILON:{configurable:!0}};Bt.prototype.interfaces_=function(){return[]},Bt.prototype.getClass=function(){return Bt},Bt.orientationIndex=function(l,h,m){var _=Bt.orientationIndexFilter(l,h,m);if(_<=1)return _;var C=It.valueOf(h.x).selfAdd(-l.x),F=It.valueOf(h.y).selfAdd(-l.y),rt=It.valueOf(m.x).selfAdd(-h.x),Dt=It.valueOf(m.y).selfAdd(-h.y);return C.selfMultiply(Dt).selfSubtract(F.selfMultiply(rt)).signum()},Bt.signOfDet2x2=function(l,h,m,_){return l.multiply(_).selfSubtract(h.multiply(m)).signum()},Bt.intersection=function(l,h,m,_){var C=It.valueOf(_.y).selfSubtract(m.y).selfMultiply(It.valueOf(h.x).selfSubtract(l.x)),F=It.valueOf(_.x).selfSubtract(m.x).selfMultiply(It.valueOf(h.y).selfSubtract(l.y)),rt=C.subtract(F),Dt=It.valueOf(_.x).selfSubtract(m.x).selfMultiply(It.valueOf(l.y).selfSubtract(m.y)),Qt=It.valueOf(_.y).selfSubtract(m.y).selfMultiply(It.valueOf(l.x).selfSubtract(m.x)),fe=Dt.subtract(Qt).selfDivide(rt).doubleValue(),ke=It.valueOf(l.x).selfAdd(It.valueOf(h.x).selfSubtract(l.x).selfMultiply(fe)).doubleValue(),Ge=It.valueOf(h.x).selfSubtract(l.x).selfMultiply(It.valueOf(l.y).selfSubtract(m.y)),_n=It.valueOf(h.y).selfSubtract(l.y).selfMultiply(It.valueOf(l.x).selfSubtract(m.x)),Sn=Ge.subtract(_n).selfDivide(rt).doubleValue(),Un=It.valueOf(m.y).selfAdd(It.valueOf(_.y).selfSubtract(m.y).selfMultiply(Sn)).doubleValue();return new B(ke,Un)},Bt.orientationIndexFilter=function(l,h,m){var _=null,C=(l.x-m.x)*(h.y-m.y),F=(l.y-m.y)*(h.x-m.x),rt=C-F;if(C>0){if(F<=0)return Bt.signum(rt);_=C+F}else{if(!(C<0)||F>=0)return Bt.signum(rt);_=-C-F}var Dt=Bt.DP_SAFE_EPSILON*_;return rt>=Dt||-rt>=Dt?Bt.signum(rt):2},Bt.signum=function(l){return l>0?1:l<0?-1:0},ee.DP_SAFE_EPSILON.get=function(){return 1e-15},Object.defineProperties(Bt,ee);var jt=function(){},se={X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0},M:{configurable:!0}};se.X.get=function(){return 0},se.Y.get=function(){return 1},se.Z.get=function(){return 2},se.M.get=function(){return 3},jt.prototype.setOrdinate=function(l,h,m){},jt.prototype.size=function(){},jt.prototype.getOrdinate=function(l,h){},jt.prototype.getCoordinate=function(){},jt.prototype.getCoordinateCopy=function(l){},jt.prototype.getDimension=function(){},jt.prototype.getX=function(l){},jt.prototype.clone=function(){},jt.prototype.expandEnvelope=function(l){},jt.prototype.copy=function(){},jt.prototype.getY=function(l){},jt.prototype.toCoordinateArray=function(){},jt.prototype.interfaces_=function(){return[ft]},jt.prototype.getClass=function(){return jt},Object.defineProperties(jt,se);var be=function(){},Me=function(l){function h(){l.call(this,"Projective point not representable on the Cartesian plane.")}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(be),Xe=function(){};Xe.arraycopy=function(l,h,m,_,C){for(var F=0,rt=h;rt<h+C;rt++)m[_+F]=l[rt],F++},Xe.getProperty=function(l){return{"line.separator":"\n"}[l]};var Ue=function l(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var h=arguments[0];this.x=h.x,this.y=h.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var _=arguments[1];this.x=arguments[0],this.y=_,this.w=1}else if(arguments[0]instanceof l&&arguments[1]instanceof l){var C=arguments[0],F=arguments[1];this.x=C.y*F.w-F.y*C.w,this.y=F.x*C.w-C.x*F.w,this.w=C.x*F.y-F.x*C.y}else if(arguments[0]instanceof B&&arguments[1]instanceof B){var rt=arguments[0],Dt=arguments[1];this.x=rt.y-Dt.y,this.y=Dt.x-rt.x,this.w=rt.x*Dt.y-Dt.x*rt.y}}else if(3===arguments.length){var fe=arguments[1],ke=arguments[2];this.x=arguments[0],this.y=fe,this.w=ke}else if(4===arguments.length){var Ge=arguments[0],_n=arguments[1],Sn=arguments[2],Un=arguments[3],ur=Ge.y-_n.y,Ji=_n.x-Ge.x,To=Ge.x*_n.y-_n.x*Ge.y,$a=Sn.y-Un.y,ml=Un.x-Sn.x,Xl=Sn.x*Un.y-Un.x*Sn.y;this.x=Ji*Xl-ml*To,this.y=$a*To-ur*Xl,this.w=ur*ml-$a*Ji}};Ue.prototype.getY=function(){var l=this.y/this.w;if(lt.isNaN(l)||lt.isInfinite(l))throw new Me;return l},Ue.prototype.getX=function(){var l=this.x/this.w;if(lt.isNaN(l)||lt.isInfinite(l))throw new Me;return l},Ue.prototype.getCoordinate=function(){var l=new B;return l.x=this.getX(),l.y=this.getY(),l},Ue.prototype.interfaces_=function(){return[]},Ue.prototype.getClass=function(){return Ue},Ue.intersection=function(l,h,m,_){var C=l.y-h.y,F=h.x-l.x,rt=l.x*h.y-h.x*l.y,Dt=m.y-_.y,Qt=_.x-m.x,fe=m.x*_.y-_.x*m.y,ke=C*Qt-Dt*F,Ge=(F*fe-Qt*rt)/ke,_n=(Dt*rt-C*fe)/ke;if(lt.isNaN(Ge)||lt.isInfinite(Ge)||lt.isNaN(_n)||lt.isInfinite(_n))throw new Me;return new B(Ge,_n)};var De=function l(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length)if(arguments[0]instanceof B){var h=arguments[0];this.init(h.x,h.x,h.y,h.y)}else arguments[0]instanceof l&&this.init(arguments[0]);else if(2===arguments.length){var _=arguments[0],C=arguments[1];this.init(_.x,C.x,_.y,C.y)}else 4===arguments.length&&this.init(arguments[0],arguments[1],arguments[2],arguments[3])},Tn={serialVersionUID:{configurable:!0}};De.prototype.getArea=function(){return this.getWidth()*this.getHeight()},De.prototype.equals=function(l){if(!(l instanceof De))return!1;var h=l;return this.isNull()?h.isNull():this._maxx===h.getMaxX()&&this._maxy===h.getMaxY()&&this._minx===h.getMinX()&&this._miny===h.getMinY()},De.prototype.intersection=function(l){return this.isNull()||l.isNull()||!this.intersects(l)?new De:new De(this._minx>l._minx?this._minx:l._minx,this._maxx<l._maxx?this._maxx:l._maxx,this._miny>l._miny?this._miny:l._miny,this._maxy<l._maxy?this._maxy:l._maxy)},De.prototype.isNull=function(){return this._maxx<this._minx},De.prototype.getMaxX=function(){return this._maxx},De.prototype.covers=function(){if(1===arguments.length){if(arguments[0]instanceof B){var l=arguments[0];return this.covers(l.x,l.y)}if(arguments[0]instanceof De){var h=arguments[0];return!this.isNull()&&!h.isNull()&&h.getMinX()>=this._minx&&h.getMaxX()<=this._maxx&&h.getMinY()>=this._miny&&h.getMaxY()<=this._maxy}}else if(2===arguments.length){var m=arguments[0],_=arguments[1];return!this.isNull()&&m>=this._minx&&m<=this._maxx&&_>=this._miny&&_<=this._maxy}},De.prototype.intersects=function(){if(1===arguments.length){if(arguments[0]instanceof De){var l=arguments[0];return!this.isNull()&&!l.isNull()&&!(l._minx>this._maxx||l._maxx<this._minx||l._miny>this._maxy||l._maxy<this._miny)}if(arguments[0]instanceof B){var h=arguments[0];return this.intersects(h.x,h.y)}}else if(2===arguments.length){var m=arguments[0],_=arguments[1];return!this.isNull()&&!(m>this._maxx||m<this._minx||_>this._maxy||_<this._miny)}},De.prototype.getMinY=function(){return this._miny},De.prototype.getMinX=function(){return this._minx},De.prototype.expandToInclude=function(){if(1===arguments.length){if(arguments[0]instanceof B){var l=arguments[0];this.expandToInclude(l.x,l.y)}else if(arguments[0]instanceof De){var h=arguments[0];if(h.isNull())return null;this.isNull()?(this._minx=h.getMinX(),this._maxx=h.getMaxX(),this._miny=h.getMinY(),this._maxy=h.getMaxY()):(h._minx<this._minx&&(this._minx=h._minx),h._maxx>this._maxx&&(this._maxx=h._maxx),h._miny<this._miny&&(this._miny=h._miny),h._maxy>this._maxy&&(this._maxy=h._maxy))}}else if(2===arguments.length){var m=arguments[0],_=arguments[1];this.isNull()?(this._minx=m,this._maxx=m,this._miny=_,this._maxy=_):(m<this._minx&&(this._minx=m),m>this._maxx&&(this._maxx=m),_<this._miny&&(this._miny=_),_>this._maxy&&(this._maxy=_))}},De.prototype.minExtent=function(){if(this.isNull())return 0;var l=this.getWidth(),h=this.getHeight();return l<h?l:h},De.prototype.getWidth=function(){return this.isNull()?0:this._maxx-this._minx},De.prototype.compareTo=function(l){var h=l;return this.isNull()?h.isNull()?0:-1:h.isNull()?1:this._minx<h._minx?-1:this._minx>h._minx?1:this._miny<h._miny?-1:this._miny>h._miny?1:this._maxx<h._maxx?-1:this._maxx>h._maxx?1:this._maxy<h._maxy?-1:this._maxy>h._maxy?1:0},De.prototype.translate=function(l,h){if(this.isNull())return null;this.init(this.getMinX()+l,this.getMaxX()+l,this.getMinY()+h,this.getMaxY()+h)},De.prototype.toString=function(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"},De.prototype.setToNull=function(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1},De.prototype.getHeight=function(){return this.isNull()?0:this._maxy-this._miny},De.prototype.maxExtent=function(){if(this.isNull())return 0;var l=this.getWidth(),h=this.getHeight();return l>h?l:h},De.prototype.expandBy=function(){if(1===arguments.length){var l=arguments[0];this.expandBy(l,l)}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this.isNull())return null;this._minx-=h,this._maxx+=h,this._miny-=m,this._maxy+=m,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}},De.prototype.contains=function(){if(1===arguments.length){if(arguments[0]instanceof De)return this.covers(arguments[0]);if(arguments[0]instanceof B)return this.covers(arguments[0])}else if(2===arguments.length)return this.covers(arguments[0],arguments[1])},De.prototype.centre=function(){return this.isNull()?null:new B((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},De.prototype.init=function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof B){var l=arguments[0];this.init(l.x,l.x,l.y,l.y)}else if(arguments[0]instanceof De){var h=arguments[0];this._minx=h._minx,this._maxx=h._maxx,this._miny=h._miny,this._maxy=h._maxy}}else if(2===arguments.length){var m=arguments[0],_=arguments[1];this.init(m.x,_.x,m.y,_.y)}else if(4===arguments.length){var C=arguments[0],F=arguments[1],rt=arguments[2],Dt=arguments[3];C<F?(this._minx=C,this._maxx=F):(this._minx=F,this._maxx=C),rt<Dt?(this._miny=rt,this._maxy=Dt):(this._miny=Dt,this._maxy=rt)}},De.prototype.getMaxY=function(){return this._maxy},De.prototype.distance=function(l){if(this.intersects(l))return 0;var h=0;this._maxx<l._minx?h=l._minx-this._maxx:this._minx>l._maxx&&(h=this._minx-l._maxx);var m=0;return this._maxy<l._miny?m=l._miny-this._maxy:this._miny>l._maxy&&(m=this._miny-l._maxy),0===h?m:0===m?h:Math.sqrt(h*h+m*m)},De.prototype.hashCode=function(){var l=17;return 37*(l=37*(l=37*(l=37*l+B.hashCode(this._minx))+B.hashCode(this._maxx))+B.hashCode(this._miny))+B.hashCode(this._maxy)},De.prototype.interfaces_=function(){return[Q,$]},De.prototype.getClass=function(){return De},De.intersects=function(){if(3===arguments.length){var l=arguments[0],h=arguments[1],m=arguments[2];return m.x>=(l.x<h.x?l.x:h.x)&&m.x<=(l.x>h.x?l.x:h.x)&&m.y>=(l.y<h.y?l.y:h.y)&&m.y<=(l.y>h.y?l.y:h.y)}if(4===arguments.length){var _=arguments[0],C=arguments[1],F=arguments[2],rt=arguments[3],Dt=Math.min(F.x,rt.x),Qt=Math.max(F.x,rt.x),fe=Math.min(_.x,C.x),ke=Math.max(_.x,C.x);return!(fe>Qt||ke<Dt||(Dt=Math.min(F.y,rt.y),Qt=Math.max(F.y,rt.y),fe=Math.min(_.y,C.y),ke=Math.max(_.y,C.y),fe>Qt||ke<Dt))}},Tn.serialVersionUID.get=function(){return 0x51845cd552189800},Object.defineProperties(De,Tn);var On={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/},ne=function(l){this.geometryFactory=l||new nr};ne.prototype.read=function(l){var h,m;l=l.replace(/[\n\r]/g," ");var C=On.typeStr.exec(l);if(-1!==l.search("EMPTY")&&((C=On.emptyTypeStr.exec(l))[2]=void 0),C&&(m=C[1].toLowerCase(),Ie[m]&&(h=Ie[m].apply(this,[C[2]]))),void 0===h)throw new Error("Could not parse WKT "+l);return h},ne.prototype.write=function(l){return this.extractGeometry(l)},ne.prototype.extractGeometry=function(l){var h=l.getGeometryType().toLowerCase();if(!pe[h])return null;var m=h.toUpperCase();return l.isEmpty()?m+" EMPTY":m+"("+pe[h].apply(this,[l])+")"};var pe={coordinate:function(l){return l.x+" "+l.y},point:function(l){return pe.coordinate.call(this,l._coordinates._coordinates[0])},multipoint:function(l){for(var h=[],m=0,_=l._geometries.length;m<_;++m)h.push("("+pe.point.apply(this,[l._geometries[m]])+")");return h.join(",")},linestring:function(l){for(var h=[],m=0,_=l._points._coordinates.length;m<_;++m)h.push(pe.coordinate.apply(this,[l._points._coordinates[m]]));return h.join(",")},linearring:function(l){for(var h=[],m=0,_=l._points._coordinates.length;m<_;++m)h.push(pe.coordinate.apply(this,[l._points._coordinates[m]]));return h.join(",")},multilinestring:function(l){for(var h=[],m=0,_=l._geometries.length;m<_;++m)h.push("("+pe.linestring.apply(this,[l._geometries[m]])+")");return h.join(",")},polygon:function(l){var h=[];h.push("("+pe.linestring.apply(this,[l._shell])+")");for(var m=0,_=l._holes.length;m<_;++m)h.push("("+pe.linestring.apply(this,[l._holes[m]])+")");return h.join(",")},multipolygon:function(l){for(var h=[],m=0,_=l._geometries.length;m<_;++m)h.push("("+pe.polygon.apply(this,[l._geometries[m]])+")");return h.join(",")},geometrycollection:function(l){for(var h=[],m=0,_=l._geometries.length;m<_;++m)h.push(this.extractGeometry(l._geometries[m]));return h.join(",")}},Ie={point:function(l){if(void 0===l)return this.geometryFactory.createPoint();var h=l.trim().split(On.spaces);return this.geometryFactory.createPoint(new B(Number.parseFloat(h[0]),Number.parseFloat(h[1])))},multipoint:function(l){if(void 0===l)return this.geometryFactory.createMultiPoint();for(var h,m=l.trim().split(","),_=[],C=0,F=m.length;C<F;++C)h=m[C].replace(On.trimParens,"$1"),_.push(Ie.point.apply(this,[h]));return this.geometryFactory.createMultiPoint(_)},linestring:function(l){if(void 0===l)return this.geometryFactory.createLineString();for(var h,m=l.trim().split(","),_=[],C=0,F=m.length;C<F;++C)h=m[C].trim().split(On.spaces),_.push(new B(Number.parseFloat(h[0]),Number.parseFloat(h[1])));return this.geometryFactory.createLineString(_)},linearring:function(l){if(void 0===l)return this.geometryFactory.createLinearRing();for(var h,m=l.trim().split(","),_=[],C=0,F=m.length;C<F;++C)h=m[C].trim().split(On.spaces),_.push(new B(Number.parseFloat(h[0]),Number.parseFloat(h[1])));return this.geometryFactory.createLinearRing(_)},multilinestring:function(l){if(void 0===l)return this.geometryFactory.createMultiLineString();for(var h,m=l.trim().split(On.parenComma),_=[],C=0,F=m.length;C<F;++C)h=m[C].replace(On.trimParens,"$1"),_.push(Ie.linestring.apply(this,[h]));return this.geometryFactory.createMultiLineString(_)},polygon:function(l){if(void 0===l)return this.geometryFactory.createPolygon();for(var h,m,_,C,F=l.trim().split(On.parenComma),rt=[],Dt=0,Qt=F.length;Dt<Qt;++Dt)h=F[Dt].replace(On.trimParens,"$1"),m=Ie.linestring.apply(this,[h]),_=this.geometryFactory.createLinearRing(m._points),0===Dt?C=_:rt.push(_);return this.geometryFactory.createPolygon(C,rt)},multipolygon:function(l){if(void 0===l)return this.geometryFactory.createMultiPolygon();for(var h,m=l.trim().split(On.doubleParenComma),_=[],C=0,F=m.length;C<F;++C)h=m[C].replace(On.trimParens,"$1"),_.push(Ie.polygon.apply(this,[h]));return this.geometryFactory.createMultiPolygon(_)},geometrycollection:function(l){if(void 0===l)return this.geometryFactory.createGeometryCollection();for(var h=(l=l.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),m=[],_=0,C=h.length;_<C;++_)m.push(this.read(h[_]));return this.geometryFactory.createGeometryCollection(m)}},Je=function(l){this.parser=new ne(l)};Je.prototype.write=function(l){return this.parser.write(l)},Je.toLineString=function(l,h){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+l.x+" "+l.y+", "+h.x+" "+h.y+" )"};var Gn=function(l){function h(m){l.call(this,m),this.name="RuntimeException",this.message=m,this.stack=(new l).stack}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h}(Error),Er=function(l){function h(){l.call(this),0===arguments.length?l.call(this):1===arguments.length&&l.call(this,arguments[0])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Gn),Nn=function(){};Nn.prototype.interfaces_=function(){return[]},Nn.prototype.getClass=function(){return Nn},Nn.shouldNeverReachHere=function(){if(0===arguments.length)Nn.shouldNeverReachHere(null);else if(1===arguments.length){var l=arguments[0];throw new Er("Should never reach here"+(null!==l?": "+l:""))}},Nn.isTrue=function(){var h;if(1===arguments.length)Nn.isTrue(arguments[0],null);else if(2===arguments.length&&(h=arguments[1],!arguments[0]))throw null===h?new Er:new Er(h)},Nn.equals=function(){var l,h,m;if(2===arguments.length)Nn.equals(l=arguments[0],h=arguments[1],null);else if(3===arguments.length&&(m=arguments[2],!(h=arguments[1]).equals(l=arguments[0])))throw new Er("Expected "+l+" but encountered "+h+(null!==m?": "+m:""))};var Yn=function(){this._result=null,this._inputLines=Array(2).fill().map(function(){return Array(2)}),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new B,this._intPt[1]=new B,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},hi={DONT_INTERSECT:{configurable:!0},DO_INTERSECT:{configurable:!0},COLLINEAR:{configurable:!0},NO_INTERSECTION:{configurable:!0},POINT_INTERSECTION:{configurable:!0},COLLINEAR_INTERSECTION:{configurable:!0}};Yn.prototype.getIndexAlongSegment=function(l,h){return this.computeIntLineIndex(),this._intLineIndex[l][h]},Yn.prototype.getTopologySummary=function(){var l=new vt;return this.isEndPoint()&&l.append(" endpoint"),this._isProper&&l.append(" proper"),this.isCollinear()&&l.append(" collinear"),l.toString()},Yn.prototype.computeIntersection=function(l,h,m,_){this._inputLines[0][0]=l,this._inputLines[0][1]=h,this._inputLines[1][0]=m,this._inputLines[1][1]=_,this._result=this.computeIntersect(l,h,m,_)},Yn.prototype.getIntersectionNum=function(){return this._result},Yn.prototype.computeIntLineIndex=function(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var l=arguments[0];this.getEdgeDistance(l,0)>this.getEdgeDistance(l,1)?(this._intLineIndex[l][0]=0,this._intLineIndex[l][1]=1):(this._intLineIndex[l][0]=1,this._intLineIndex[l][1]=0)}},Yn.prototype.isProper=function(){return this.hasIntersection()&&this._isProper},Yn.prototype.setPrecisionModel=function(l){this._precisionModel=l},Yn.prototype.isInteriorIntersection=function(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){for(var l=arguments[0],h=0;h<this._result;h++)if(!this._intPt[h].equals2D(this._inputLines[l][0])&&!this._intPt[h].equals2D(this._inputLines[l][1]))return!0;return!1}},Yn.prototype.getIntersection=function(l){return this._intPt[l]},Yn.prototype.isEndPoint=function(){return this.hasIntersection()&&!this._isProper},Yn.prototype.hasIntersection=function(){return this._result!==Yn.NO_INTERSECTION},Yn.prototype.getEdgeDistance=function(l,h){return Yn.computeEdgeDistance(this._intPt[h],this._inputLines[l][0],this._inputLines[l][1])},Yn.prototype.isCollinear=function(){return this._result===Yn.COLLINEAR_INTERSECTION},Yn.prototype.toString=function(){return Je.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Je.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()},Yn.prototype.getEndpoint=function(l,h){return this._inputLines[l][h]},Yn.prototype.isIntersection=function(l){for(var h=0;h<this._result;h++)if(this._intPt[h].equals2D(l))return!0;return!1},Yn.prototype.getIntersectionAlongSegment=function(l,h){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[l][h]]},Yn.prototype.interfaces_=function(){return[]},Yn.prototype.getClass=function(){return Yn},Yn.computeEdgeDistance=function(l,h,m){var _=Math.abs(m.x-h.x),C=Math.abs(m.y-h.y),F=-1;if(l.equals(h))F=0;else if(l.equals(m))F=_>C?_:C;else{var rt=Math.abs(l.x-h.x),Dt=Math.abs(l.y-h.y);0!==(F=_>C?rt:Dt)||l.equals(h)||(F=Math.max(rt,Dt))}return Nn.isTrue(!(0===F&&!l.equals(h)),"Bad distance calculation"),F},Yn.nonRobustComputeEdgeDistance=function(l,h,m){var _=l.x-h.x,C=l.y-h.y,F=Math.sqrt(_*_+C*C);return Nn.isTrue(!(0===F&&!l.equals(h)),"Invalid distance calculation"),F},hi.DONT_INTERSECT.get=function(){return 0},hi.DO_INTERSECT.get=function(){return 1},hi.COLLINEAR.get=function(){return 2},hi.NO_INTERSECTION.get=function(){return 0},hi.POINT_INTERSECTION.get=function(){return 1},hi.COLLINEAR_INTERSECTION.get=function(){return 2},Object.defineProperties(Yn,hi);var di=function(l){function h(){l.apply(this,arguments)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.isInSegmentEnvelopes=function(m){var _=new De(this._inputLines[0][0],this._inputLines[0][1]),C=new De(this._inputLines[1][0],this._inputLines[1][1]);return _.contains(m)&&C.contains(m)},h.prototype.computeIntersection=function(){if(3!==arguments.length)return l.prototype.computeIntersection.apply(this,arguments);var m=arguments[0],_=arguments[1],C=arguments[2];if(this._isProper=!1,De.intersects(_,C,m)&&0===yn.orientationIndex(_,C,m)&&0===yn.orientationIndex(C,_,m))return this._isProper=!0,(m.equals(_)||m.equals(C))&&(this._isProper=!1),this._result=l.POINT_INTERSECTION,null;this._result=l.NO_INTERSECTION},h.prototype.normalizeToMinimum=function(m,_,C,F,rt){rt.x=this.smallestInAbsValue(m.x,_.x,C.x,F.x),rt.y=this.smallestInAbsValue(m.y,_.y,C.y,F.y),m.x-=rt.x,m.y-=rt.y,_.x-=rt.x,_.y-=rt.y,C.x-=rt.x,C.y-=rt.y,F.x-=rt.x,F.y-=rt.y},h.prototype.safeHCoordinateIntersection=function(m,_,C,F){var rt=null;try{rt=Ue.intersection(m,_,C,F)}catch(Dt){if(!(Dt instanceof Me))throw Dt;rt=h.nearestEndpoint(m,_,C,F)}return rt},h.prototype.intersection=function(m,_,C,F){var rt=this.intersectionWithNormalization(m,_,C,F);return this.isInSegmentEnvelopes(rt)||(rt=new B(h.nearestEndpoint(m,_,C,F))),null!==this._precisionModel&&this._precisionModel.makePrecise(rt),rt},h.prototype.smallestInAbsValue=function(m,_,C,F){var rt=m,Dt=Math.abs(rt);return Math.abs(_)<Dt&&(rt=_,Dt=Math.abs(_)),Math.abs(C)<Dt&&(rt=C,Dt=Math.abs(C)),Math.abs(F)<Dt&&(rt=F),rt},h.prototype.checkDD=function(m,_,C,F,rt){var Dt=Bt.intersection(m,_,C,F),Qt=this.isInSegmentEnvelopes(Dt);Xe.out.println("DD in env = "+Qt+"  --------------------- "+Dt),rt.distance(Dt)>1e-4&&Xe.out.println("Distance = "+rt.distance(Dt))},h.prototype.intersectionWithNormalization=function(m,_,C,F){var rt=new B(m),Dt=new B(_),Qt=new B(C),fe=new B(F),ke=new B;this.normalizeToEnvCentre(rt,Dt,Qt,fe,ke);var Ge=this.safeHCoordinateIntersection(rt,Dt,Qt,fe);return Ge.x+=ke.x,Ge.y+=ke.y,Ge},h.prototype.computeCollinearIntersection=function(m,_,C,F){var rt=De.intersects(m,_,C),Dt=De.intersects(m,_,F),Qt=De.intersects(C,F,m),fe=De.intersects(C,F,_);return rt&&Dt?(this._intPt[0]=C,this._intPt[1]=F,l.COLLINEAR_INTERSECTION):Qt&&fe?(this._intPt[0]=m,this._intPt[1]=_,l.COLLINEAR_INTERSECTION):rt&&Qt?(this._intPt[0]=C,this._intPt[1]=m,!C.equals(m)||Dt||fe?l.COLLINEAR_INTERSECTION:l.POINT_INTERSECTION):rt&&fe?(this._intPt[0]=C,this._intPt[1]=_,!C.equals(_)||Dt||Qt?l.COLLINEAR_INTERSECTION:l.POINT_INTERSECTION):Dt&&Qt?(this._intPt[0]=F,this._intPt[1]=m,!F.equals(m)||rt||fe?l.COLLINEAR_INTERSECTION:l.POINT_INTERSECTION):Dt&&fe?(this._intPt[0]=F,this._intPt[1]=_,!F.equals(_)||rt||Qt?l.COLLINEAR_INTERSECTION:l.POINT_INTERSECTION):l.NO_INTERSECTION},h.prototype.normalizeToEnvCentre=function(m,_,C,F,rt){var Dt=m.x<_.x?m.x:_.x,Qt=m.y<_.y?m.y:_.y,fe=m.x>_.x?m.x:_.x,ke=m.y>_.y?m.y:_.y,Ge=C.x<F.x?C.x:F.x,_n=C.y<F.y?C.y:F.y,Sn=C.x>F.x?C.x:F.x,Un=C.y>F.y?C.y:F.y,Ji=((Qt>_n?Qt:_n)+(ke<Un?ke:Un))/2;rt.x=((Dt>Ge?Dt:Ge)+(fe<Sn?fe:Sn))/2,rt.y=Ji,m.x-=rt.x,m.y-=rt.y,_.x-=rt.x,_.y-=rt.y,C.x-=rt.x,C.y-=rt.y,F.x-=rt.x,F.y-=rt.y},h.prototype.computeIntersect=function(m,_,C,F){if(this._isProper=!1,!De.intersects(m,_,C,F))return l.NO_INTERSECTION;var rt=yn.orientationIndex(m,_,C),Dt=yn.orientationIndex(m,_,F);if(rt>0&&Dt>0||rt<0&&Dt<0)return l.NO_INTERSECTION;var Qt=yn.orientationIndex(C,F,m),fe=yn.orientationIndex(C,F,_);return Qt>0&&fe>0||Qt<0&&fe<0?l.NO_INTERSECTION:0===rt&&0===Dt&&0===Qt&&0===fe?this.computeCollinearIntersection(m,_,C,F):(0===rt||0===Dt||0===Qt||0===fe?(this._isProper=!1,m.equals2D(C)||m.equals2D(F)?this._intPt[0]=m:_.equals2D(C)||_.equals2D(F)?this._intPt[0]=_:0===rt?this._intPt[0]=new B(C):0===Dt?this._intPt[0]=new B(F):0===Qt?this._intPt[0]=new B(m):0===fe&&(this._intPt[0]=new B(_))):(this._isProper=!0,this._intPt[0]=this.intersection(m,_,C,F)),l.POINT_INTERSECTION)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.nearestEndpoint=function(m,_,C,F){var rt=m,Dt=yn.distancePointLine(m,C,F),Qt=yn.distancePointLine(_,C,F);return Qt<Dt&&(Dt=Qt,rt=_),(Qt=yn.distancePointLine(C,m,_))<Dt&&(Dt=Qt,rt=C),(Qt=yn.distancePointLine(F,m,_))<Dt&&(Dt=Qt,rt=F),rt},h}(Yn),to=function(){};to.prototype.interfaces_=function(){return[]},to.prototype.getClass=function(){return to},to.orientationIndex=function(l,h,m){return to.signOfDet2x2(h.x-l.x,h.y-l.y,m.x-h.x,m.y-h.y)},to.signOfDet2x2=function(l,h,m,_){var C=null,F=null,rt=null;if(C=1,0===l||0===_)return 0===h||0===m?0:h>0?m>0?-C:C:m>0?C:-C;if(0===h||0===m)return _>0?l>0?C:-C:l>0?-C:C;if(h>0?_>0?h<=_||(C=-C,F=l,l=m,m=F,F=h,h=_,_=F):h<=-_?(C=-C,m=-m,_=-_):(F=l,l=-m,m=F,F=h,h=-_,_=F):_>0?-h<=_?(C=-C,l=-l,h=-h):(F=-l,l=m,m=F,F=-h,h=_,_=F):h>=_?(l=-l,h=-h,m=-m,_=-_):(C=-C,F=-l,l=-m,m=F,F=-h,h=-_,_=F),l>0){if(!(m>0&&l<=m))return C}else{if(m>0||!(l>=m))return-C;C=-C,l=-l,m=-m}for(;;){if((_-=(rt=Math.floor(m/l))*h)<0)return-C;if(_>h)return C;if(l>(m-=rt*l)+m){if(h<_+_)return C}else{if(h>_+_)return-C;m=l-m,_=h-_,C=-C}if(0===_)return 0===m?0:-C;if(0===m||(l-=(rt=Math.floor(l/m))*m,(h-=rt*_)<0))return C;if(h>_)return-C;if(m>l+l){if(_<h+h)return-C}else{if(_>h+h)return C;l=m-l,h=_-h,C=-C}if(0===h)return 0===l?0:C;if(0===l)return-C}};var ii=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1,this._p=arguments[0]};ii.prototype.countSegment=function(l,h){if(l.x<this._p.x&&h.x<this._p.x)return null;if(this._p.x===h.x&&this._p.y===h.y)return this._isPointOnSegment=!0,null;if(l.y===this._p.y&&h.y===this._p.y){var m=l.x,_=h.x;return m>_&&(m=h.x,_=l.x),this._p.x>=m&&this._p.x<=_&&(this._isPointOnSegment=!0),null}if(l.y>this._p.y&&h.y<=this._p.y||h.y>this._p.y&&l.y<=this._p.y){var F=l.y-this._p.y,Dt=h.y-this._p.y,Qt=to.signOfDet2x2(l.x-this._p.x,F,h.x-this._p.x,Dt);if(0===Qt)return this._isPointOnSegment=!0,null;Dt<F&&(Qt=-Qt),Qt>0&&this._crossingCount++}},ii.prototype.isPointInPolygon=function(){return this.getLocation()!==nt.EXTERIOR},ii.prototype.getLocation=function(){return this._isPointOnSegment?nt.BOUNDARY:this._crossingCount%2==1?nt.INTERIOR:nt.EXTERIOR},ii.prototype.isOnSegment=function(){return this._isPointOnSegment},ii.prototype.interfaces_=function(){return[]},ii.prototype.getClass=function(){return ii},ii.locatePointInRing=function(){if(arguments[0]instanceof B&&O(arguments[1],jt)){for(var h=arguments[1],m=new ii(arguments[0]),_=new B,C=new B,F=1;F<h.size();F++)if(h.getCoordinate(F,_),h.getCoordinate(F-1,C),m.countSegment(_,C),m.isOnSegment())return m.getLocation();return m.getLocation()}if(arguments[0]instanceof B&&arguments[1]instanceof Array){for(var Dt=arguments[1],Qt=new ii(arguments[0]),fe=1;fe<Dt.length;fe++)if(Qt.countSegment(Dt[fe],Dt[fe-1]),Qt.isOnSegment())return Qt.getLocation();return Qt.getLocation()}};var yn=function(){},Qo={CLOCKWISE:{configurable:!0},RIGHT:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},LEFT:{configurable:!0},COLLINEAR:{configurable:!0},STRAIGHT:{configurable:!0}};yn.prototype.interfaces_=function(){return[]},yn.prototype.getClass=function(){return yn},yn.orientationIndex=function(l,h,m){return Bt.orientationIndex(l,h,m)},yn.signedArea=function(){if(arguments[0]instanceof Array){var l=arguments[0];if(l.length<3)return 0;for(var h=0,m=l[0].x,_=1;_<l.length-1;_++)h+=(l[_].x-m)*(l[_-1].y-l[_+1].y);return h/2}if(O(arguments[0],jt)){var rt=arguments[0],Dt=rt.size();if(Dt<3)return 0;var Qt=new B,fe=new B,ke=new B;rt.getCoordinate(0,fe),rt.getCoordinate(1,ke);var Ge=fe.x;ke.x-=Ge;for(var _n=0,Sn=1;Sn<Dt-1;Sn++)Qt.y=fe.y,fe.x=ke.x,fe.y=ke.y,rt.getCoordinate(Sn+1,ke),ke.x-=Ge,_n+=fe.x*(Qt.y-ke.y);return _n/2}},yn.distanceLineLine=function(l,h,m,_){if(l.equals(h))return yn.distancePointLine(l,m,_);if(m.equals(_))return yn.distancePointLine(_,l,h);var C=!1;if(De.intersects(l,h,m,_)){var F=(h.x-l.x)*(_.y-m.y)-(h.y-l.y)*(_.x-m.x);if(0===F)C=!0;else{var Dt=((l.y-m.y)*(h.x-l.x)-(l.x-m.x)*(h.y-l.y))/F,Qt=((l.y-m.y)*(_.x-m.x)-(l.x-m.x)*(_.y-m.y))/F;(Qt<0||Qt>1||Dt<0||Dt>1)&&(C=!0)}}else C=!0;return C?Ct.min(yn.distancePointLine(l,m,_),yn.distancePointLine(h,m,_),yn.distancePointLine(m,l,h),yn.distancePointLine(_,l,h)):0},yn.isPointInRing=function(l,h){return yn.locatePointInRing(l,h)!==nt.EXTERIOR},yn.computeLength=function(l){var h=l.size();if(h<=1)return 0;var m=0,_=new B;l.getCoordinate(0,_);for(var C=_.x,F=_.y,rt=1;rt<h;rt++){l.getCoordinate(rt,_);var Dt=_.x,Qt=_.y,fe=Dt-C,ke=Qt-F;m+=Math.sqrt(fe*fe+ke*ke),C=Dt,F=Qt}return m},yn.isCCW=function(l){var h=l.length-1;if(h<3)throw new dt("Ring has fewer than 4 points, so orientation cannot be determined");for(var m=l[0],_=0,C=1;C<=h;C++){var F=l[C];F.y>m.y&&(m=F,_=C)}var rt=_;do{(rt-=1)<0&&(rt=h)}while(l[rt].equals2D(m)&&rt!==_);var Dt=_;do{Dt=(Dt+1)%h}while(l[Dt].equals2D(m)&&Dt!==_);var Qt=l[rt],fe=l[Dt];if(Qt.equals2D(m)||fe.equals2D(m)||Qt.equals2D(fe))return!1;var ke=yn.computeOrientation(Qt,m,fe);return 0===ke?Qt.x>fe.x:ke>0},yn.locatePointInRing=function(l,h){return ii.locatePointInRing(l,h)},yn.distancePointLinePerpendicular=function(l,h,m){var _=(m.x-h.x)*(m.x-h.x)+(m.y-h.y)*(m.y-h.y);return Math.abs(((h.y-l.y)*(m.x-h.x)-(h.x-l.x)*(m.y-h.y))/_)*Math.sqrt(_)},yn.computeOrientation=function(l,h,m){return yn.orientationIndex(l,h,m)},yn.distancePointLine=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1];if(0===h.length)throw new dt("Line array must contain at least one vertex");for(var m=l.distance(h[0]),_=0;_<h.length-1;_++){var C=yn.distancePointLine(l,h[_],h[_+1]);C<m&&(m=C)}return m}if(3===arguments.length){var F=arguments[0],rt=arguments[1],Dt=arguments[2];if(rt.x===Dt.x&&rt.y===Dt.y)return F.distance(rt);var Qt=(Dt.x-rt.x)*(Dt.x-rt.x)+(Dt.y-rt.y)*(Dt.y-rt.y),fe=((F.x-rt.x)*(Dt.x-rt.x)+(F.y-rt.y)*(Dt.y-rt.y))/Qt;return fe<=0?F.distance(rt):fe>=1?F.distance(Dt):Math.abs(((rt.y-F.y)*(Dt.x-rt.x)-(rt.x-F.x)*(Dt.y-rt.y))/Qt)*Math.sqrt(Qt)}},yn.isOnLine=function(l,h){for(var m=new di,_=1;_<h.length;_++)if(m.computeIntersection(l,h[_-1],h[_]),m.hasIntersection())return!0;return!1},Qo.CLOCKWISE.get=function(){return-1},Qo.RIGHT.get=function(){return yn.CLOCKWISE},Qo.COUNTERCLOCKWISE.get=function(){return 1},Qo.LEFT.get=function(){return yn.COUNTERCLOCKWISE},Qo.COLLINEAR.get=function(){return 0},Qo.STRAIGHT.get=function(){return yn.COLLINEAR},Object.defineProperties(yn,Qo);var Eo=function(){};Eo.prototype.filter=function(l){},Eo.prototype.interfaces_=function(){return[]},Eo.prototype.getClass=function(){return Eo};var Hn=function(){var l=arguments[0];this._envelope=null,this._factory=null,this._SRID=null,this._userData=null,this._factory=l,this._SRID=l.getSRID()},Hs={serialVersionUID:{configurable:!0},SORTINDEX_POINT:{configurable:!0},SORTINDEX_MULTIPOINT:{configurable:!0},SORTINDEX_LINESTRING:{configurable:!0},SORTINDEX_LINEARRING:{configurable:!0},SORTINDEX_MULTILINESTRING:{configurable:!0},SORTINDEX_POLYGON:{configurable:!0},SORTINDEX_MULTIPOLYGON:{configurable:!0},SORTINDEX_GEOMETRYCOLLECTION:{configurable:!0},geometryChangedFilter:{configurable:!0}};Hn.prototype.isGeometryCollection=function(){return this.getSortIndex()===Hn.SORTINDEX_GEOMETRYCOLLECTION},Hn.prototype.getFactory=function(){return this._factory},Hn.prototype.getGeometryN=function(l){return this},Hn.prototype.getArea=function(){return 0},Hn.prototype.isRectangle=function(){return!1},Hn.prototype.equals=function(){if(arguments[0]instanceof Hn){var l=arguments[0];return null!==l&&this.equalsTopo(l)}if(arguments[0]instanceof Object){var h=arguments[0];return h instanceof Hn&&this.equalsExact(h)}},Hn.prototype.equalsExact=function(l){return this===l||this.equalsExact(l,0)},Hn.prototype.geometryChanged=function(){this.apply(Hn.geometryChangedFilter)},Hn.prototype.geometryChangedAction=function(){this._envelope=null},Hn.prototype.equalsNorm=function(l){return null!==l&&this.norm().equalsExact(l.norm())},Hn.prototype.getLength=function(){return 0},Hn.prototype.getNumGeometries=function(){return 1},Hn.prototype.compareTo=function(){if(1===arguments.length){var l=arguments[0],h=l;return this.getSortIndex()!==h.getSortIndex()?this.getSortIndex()-h.getSortIndex():this.isEmpty()&&h.isEmpty()?0:this.isEmpty()?-1:h.isEmpty()?1:this.compareToSameClass(l)}if(2===arguments.length){var m=arguments[0],_=arguments[1];return this.getSortIndex()!==m.getSortIndex()?this.getSortIndex()-m.getSortIndex():this.isEmpty()&&m.isEmpty()?0:this.isEmpty()?-1:m.isEmpty()?1:this.compareToSameClass(m,_)}},Hn.prototype.getUserData=function(){return this._userData},Hn.prototype.getSRID=function(){return this._SRID},Hn.prototype.getEnvelope=function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},Hn.prototype.checkNotGeometryCollection=function(l){if(l.getSortIndex()===Hn.SORTINDEX_GEOMETRYCOLLECTION)throw new dt("This method does not support GeometryCollection arguments")},Hn.prototype.equal=function(l,h,m){return 0===m?l.equals(h):l.distance(h)<=m},Hn.prototype.norm=function(){var l=this.copy();return l.normalize(),l},Hn.prototype.getPrecisionModel=function(){return this._factory.getPrecisionModel()},Hn.prototype.getEnvelopeInternal=function(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new De(this._envelope)},Hn.prototype.setSRID=function(l){this._SRID=l},Hn.prototype.setUserData=function(l){this._userData=l},Hn.prototype.compare=function(l,h){for(var m=l.iterator(),_=h.iterator();m.hasNext()&&_.hasNext();){var C=m.next(),F=_.next(),rt=C.compareTo(F);if(0!==rt)return rt}return m.hasNext()?1:_.hasNext()?-1:0},Hn.prototype.hashCode=function(){return this.getEnvelopeInternal().hashCode()},Hn.prototype.isGeometryCollectionOrDerived=function(){return this.getSortIndex()===Hn.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===Hn.SORTINDEX_MULTIPOINT||this.getSortIndex()===Hn.SORTINDEX_MULTILINESTRING||this.getSortIndex()===Hn.SORTINDEX_MULTIPOLYGON},Hn.prototype.interfaces_=function(){return[ft,Q,$]},Hn.prototype.getClass=function(){return Hn},Hn.hasNonEmptyElements=function(l){for(var h=0;h<l.length;h++)if(!l[h].isEmpty())return!0;return!1},Hn.hasNullElements=function(l){for(var h=0;h<l.length;h++)if(null===l[h])return!0;return!1},Hs.serialVersionUID.get=function(){return 0x799ea46522854c00},Hs.SORTINDEX_POINT.get=function(){return 0},Hs.SORTINDEX_MULTIPOINT.get=function(){return 1},Hs.SORTINDEX_LINESTRING.get=function(){return 2},Hs.SORTINDEX_LINEARRING.get=function(){return 3},Hs.SORTINDEX_MULTILINESTRING.get=function(){return 4},Hs.SORTINDEX_POLYGON.get=function(){return 5},Hs.SORTINDEX_MULTIPOLYGON.get=function(){return 6},Hs.SORTINDEX_GEOMETRYCOLLECTION.get=function(){return 7},Hs.geometryChangedFilter.get=function(){return Ce},Object.defineProperties(Hn,Hs);var Ce=function(){};Ce.interfaces_=function(){return[Eo]},Ce.filter=function(l){l.geometryChangedAction()};var Et=function(){};Et.prototype.filter=function(l){},Et.prototype.interfaces_=function(){return[]},Et.prototype.getClass=function(){return Et};var Rt=function(){},te={Mod2BoundaryNodeRule:{configurable:!0},EndPointBoundaryNodeRule:{configurable:!0},MultiValentEndPointBoundaryNodeRule:{configurable:!0},MonoValentEndPointBoundaryNodeRule:{configurable:!0},MOD2_BOUNDARY_RULE:{configurable:!0},ENDPOINT_BOUNDARY_RULE:{configurable:!0},MULTIVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},MONOVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},OGC_SFS_BOUNDARY_RULE:{configurable:!0}};Rt.prototype.isInBoundary=function(l){},Rt.prototype.interfaces_=function(){return[]},Rt.prototype.getClass=function(){return Rt},te.Mod2BoundaryNodeRule.get=function(){return oe},te.EndPointBoundaryNodeRule.get=function(){return ie},te.MultiValentEndPointBoundaryNodeRule.get=function(){return ze},te.MonoValentEndPointBoundaryNodeRule.get=function(){return Oe},te.MOD2_BOUNDARY_RULE.get=function(){return new oe},te.ENDPOINT_BOUNDARY_RULE.get=function(){return new ie},te.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new ze},te.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new Oe},te.OGC_SFS_BOUNDARY_RULE.get=function(){return Rt.MOD2_BOUNDARY_RULE},Object.defineProperties(Rt,te);var oe=function(){};oe.prototype.isInBoundary=function(l){return l%2==1},oe.prototype.interfaces_=function(){return[Rt]},oe.prototype.getClass=function(){return oe};var ie=function(){};ie.prototype.isInBoundary=function(l){return l>0},ie.prototype.interfaces_=function(){return[Rt]},ie.prototype.getClass=function(){return ie};var ze=function(){};ze.prototype.isInBoundary=function(l){return l>1},ze.prototype.interfaces_=function(){return[Rt]},ze.prototype.getClass=function(){return ze};var Oe=function(){};Oe.prototype.isInBoundary=function(l){return 1===l},Oe.prototype.interfaces_=function(){return[Rt]},Oe.prototype.getClass=function(){return Oe};var je=function(){};je.prototype.add=function(){},je.prototype.addAll=function(){},je.prototype.isEmpty=function(){},je.prototype.iterator=function(){},je.prototype.size=function(){},je.prototype.toArray=function(){},je.prototype.remove=function(){},(V.prototype=new Error).name="IndexOutOfBoundsException";var Xt=function(){};Xt.prototype.hasNext=function(){},Xt.prototype.next=function(){},Xt.prototype.remove=function(){};var En=function(l){function h(){l.apply(this,arguments)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.get=function(){},h.prototype.set=function(){},h.prototype.isEmpty=function(){},h}(je);(H.prototype=new Error).name="NoSuchElementException";var ue=function(l){function h(){l.call(this),this.array_=[],arguments[0]instanceof je&&this.addAll(arguments[0])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.ensureCapacity=function(){},h.prototype.interfaces_=function(){return[l,je]},h.prototype.add=function(m){return 1===arguments.length?this.array_.push(m):this.array_.splice(arguments[0],arguments[1]),!0},h.prototype.clear=function(){this.array_=[]},h.prototype.addAll=function(m){for(var _=m.iterator();_.hasNext();)this.add(_.next());return!0},h.prototype.set=function(m,_){var C=this.array_[m];return this.array_[m]=_,C},h.prototype.iterator=function(){return new en(this)},h.prototype.get=function(m){if(m<0||m>=this.size())throw new V;return this.array_[m]},h.prototype.isEmpty=function(){return 0===this.array_.length},h.prototype.size=function(){return this.array_.length},h.prototype.toArray=function(){for(var m=[],_=0,C=this.array_.length;_<C;_++)m.push(this.array_[_]);return m},h.prototype.remove=function(m){for(var _=!1,C=0,F=this.array_.length;C<F;C++)if(this.array_[C]===m){this.array_.splice(C,1),_=!0;break}return _},h}(En),en=function(l){function h(m){l.call(this),this.arrayList_=m,this.position_=0}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new H;return this.arrayList_.get(this.position_++)},h.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},h.prototype.set=function(m){return this.arrayList_.set(this.position_-1,m)},h.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))},h}(Xt),mn=function(l){function h(){if(l.call(this),0!==arguments.length)if(1===arguments.length){var _=arguments[0];this.ensureCapacity(_.length),this.add(_,!0)}else if(2===arguments.length){var C=arguments[0],F=arguments[1];this.ensureCapacity(C.length),this.add(C,F)}}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={coordArrayType:{configurable:!0}};return m.coordArrayType.get=function(){return new Array(0).fill(null)},h.prototype.getCoordinate=function(_){return this.get(_)},h.prototype.addAll=function(){if(2===arguments.length){for(var C=arguments[1],F=!1,rt=arguments[0].iterator();rt.hasNext();)this.add(rt.next(),C),F=!0;return F}return l.prototype.addAll.apply(this,arguments)},h.prototype.clone=function(){for(var _=l.prototype.clone.call(this),C=0;C<this.size();C++)_.add(C,this.get(C).copy());return _},h.prototype.toCoordinateArray=function(){return this.toArray(h.coordArrayType)},h.prototype.add=function(){if(1===arguments.length)l.prototype.add.call(this,arguments[0]);else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1])return this.add(arguments[0],arguments[1],!0),!0;if(arguments[0]instanceof B&&"boolean"==typeof arguments[1]){var rt=arguments[0];if(!arguments[1]&&this.size()>=1&&this.get(this.size()-1).equals2D(rt))return null;l.prototype.add.call(this,rt)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1])return this.add(arguments[0],arguments[1]),!0}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var fe=arguments[0],ke=arguments[1];if(arguments[2])for(var Ge=0;Ge<fe.length;Ge++)this.add(fe[Ge],ke);else for(var _n=fe.length-1;_n>=0;_n--)this.add(fe[_n],ke);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof B){var Sn=arguments[0],Un=arguments[1];if(!arguments[2]){var ur=this.size();if(ur>0&&(Sn>0&&this.get(Sn-1).equals2D(Un)||Sn<ur&&this.get(Sn).equals2D(Un)))return null}l.prototype.add.call(this,Sn,Un)}}else if(4===arguments.length){var Ji=arguments[0],To=arguments[1],$a=arguments[2],ml=arguments[3],Xl=1;$a>ml&&(Xl=-1);for(var uf=$a;uf!==ml;uf+=Xl)this.add(Ji[uf],To);return!0}},h.prototype.closeRing=function(){this.size()>0&&this.add(new B(this.get(0)),!1)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},Object.defineProperties(h,m),h}(ue),un=function(){},tr={ForwardComparator:{configurable:!0},BidirectionalComparator:{configurable:!0},coordArrayType:{configurable:!0}};tr.ForwardComparator.get=function(){return dr},tr.BidirectionalComparator.get=function(){return zn},tr.coordArrayType.get=function(){return new Array(0).fill(null)},un.prototype.interfaces_=function(){return[]},un.prototype.getClass=function(){return un},un.isRing=function(l){return!(l.length<4||!l[0].equals2D(l[l.length-1]))},un.ptNotInList=function(l,h){for(var m=0;m<l.length;m++){var _=l[m];if(un.indexOf(_,h)<0)return _}return null},un.scroll=function(l,h){var m=un.indexOf(h,l);if(m<0)return null;var _=new Array(l.length).fill(null);Xe.arraycopy(l,m,_,0,l.length-m),Xe.arraycopy(l,0,_,l.length-m,m),Xe.arraycopy(_,0,l,0,l.length)},un.equals=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1];if(l===h)return!0;if(null===l||null===h||l.length!==h.length)return!1;for(var m=0;m<l.length;m++)if(!l[m].equals(h[m]))return!1;return!0}if(3===arguments.length){var _=arguments[0],C=arguments[1],F=arguments[2];if(_===C)return!0;if(null===_||null===C||_.length!==C.length)return!1;for(var rt=0;rt<_.length;rt++)if(0!==F.compare(_[rt],C[rt]))return!1;return!0}},un.intersection=function(l,h){for(var m=new mn,_=0;_<l.length;_++)h.intersects(l[_])&&m.add(l[_],!0);return m.toCoordinateArray()},un.hasRepeatedPoints=function(l){for(var h=1;h<l.length;h++)if(l[h-1].equals(l[h]))return!0;return!1},un.removeRepeatedPoints=function(l){return un.hasRepeatedPoints(l)?new mn(l,!1).toCoordinateArray():l},un.reverse=function(l){for(var h=l.length-1,m=Math.trunc(h/2),_=0;_<=m;_++){var C=l[_];l[_]=l[h-_],l[h-_]=C}},un.removeNull=function(l){for(var h=0,m=0;m<l.length;m++)null!==l[m]&&h++;var _=new Array(h).fill(null);if(0===h)return _;for(var C=0,F=0;F<l.length;F++)null!==l[F]&&(_[C++]=l[F]);return _},un.copyDeep=function(){if(1===arguments.length){for(var l=arguments[0],h=new Array(l.length).fill(null),m=0;m<l.length;m++)h[m]=new B(l[m]);return h}if(5===arguments.length)for(var _=arguments[0],C=arguments[1],F=arguments[2],rt=arguments[3],Dt=arguments[4],Qt=0;Qt<Dt;Qt++)F[rt+Qt]=new B(_[C+Qt])},un.isEqualReversed=function(l,h){for(var m=0;m<l.length;m++)if(0!==l[m].compareTo(h[l.length-m-1]))return!1;return!0},un.envelope=function(l){for(var h=new De,m=0;m<l.length;m++)h.expandToInclude(l[m]);return h},un.toCoordinateArray=function(l){return l.toArray(un.coordArrayType)},un.atLeastNCoordinatesOrNothing=function(l,h){return h.length>=l?h:[]},un.indexOf=function(l,h){for(var m=0;m<h.length;m++)if(l.equals(h[m]))return m;return-1},un.increasingDirection=function(l){for(var h=0;h<Math.trunc(l.length/2);h++){var _=l[h].compareTo(l[l.length-1-h]);if(0!==_)return _}return 1},un.compare=function(l,h){for(var m=0;m<l.length&&m<h.length;){var _=l[m].compareTo(h[m]);if(0!==_)return _;m++}return m<h.length?-1:m<l.length?1:0},un.minCoordinate=function(l){for(var h=null,m=0;m<l.length;m++)(null===h||h.compareTo(l[m])>0)&&(h=l[m]);return h},un.extract=function(l,h,m){h=Ct.clamp(h,0,l.length);var _=(m=Ct.clamp(m,-1,l.length))-h+1;m<0&&(_=0),h>=l.length&&(_=0),m<h&&(_=0);var C=new Array(_).fill(null);if(0===_)return C;for(var F=0,rt=h;rt<=m;rt++)C[F++]=l[rt];return C},Object.defineProperties(un,tr);var dr=function(){};dr.prototype.compare=function(l,h){return un.compare(l,h)},dr.prototype.interfaces_=function(){return[pt]},dr.prototype.getClass=function(){return dr};var zn=function(){};zn.prototype.compare=function(l,h){var m=l,_=h;if(m.length<_.length)return-1;if(m.length>_.length)return 1;if(0===m.length)return 0;var C=un.compare(m,_);return un.isEqualReversed(m,_)?0:C},zn.prototype.OLDcompare=function(l,h){var m=l,_=h;if(m.length<_.length)return-1;if(m.length>_.length)return 1;if(0===m.length)return 0;for(var C=un.increasingDirection(m),F=un.increasingDirection(_),rt=C>0?0:m.length-1,Dt=F>0?0:m.length-1,Qt=0;Qt<m.length;Qt++){var fe=m[rt].compareTo(_[Dt]);if(0!==fe)return fe;rt+=C,Dt+=F}return 0},zn.prototype.interfaces_=function(){return[pt]},zn.prototype.getClass=function(){return zn};var vn=function(){};vn.prototype.get=function(){},vn.prototype.put=function(){},vn.prototype.size=function(){},vn.prototype.values=function(){},vn.prototype.entrySet=function(){};var sr=function(l){function h(){l.apply(this,arguments)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h}(vn);(q.prototype=new Error).name="OperationNotSupported",(Y.prototype=new je).contains=function(){};var Jr=function(l){function h(){l.call(this),this.array_=[],arguments[0]instanceof je&&this.addAll(arguments[0])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.contains=function(m){for(var _=0,C=this.array_.length;_<C;_++)if(this.array_[_]===m)return!0;return!1},h.prototype.add=function(m){return!this.contains(m)&&(this.array_.push(m),!0)},h.prototype.addAll=function(m){for(var _=m.iterator();_.hasNext();)this.add(_.next());return!0},h.prototype.remove=function(m){throw new Error},h.prototype.size=function(){return this.array_.length},h.prototype.isEmpty=function(){return 0===this.array_.length},h.prototype.toArray=function(){for(var m=[],_=0,C=this.array_.length;_<C;_++)m.push(this.array_[_]);return m},h.prototype.iterator=function(){return new Qn(this)},h}(Y),Qn=function(l){function h(m){l.call(this),this.hashSet_=m,this.position_=0}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new H;return this.hashSet_.array_[this.position_++]},h.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},h.prototype.remove=function(){throw new q},h}(Xt),wr=0;(Z.prototype=new sr).get=function(l){for(var h=this.root_;null!==h;){var m=l.compareTo(h.key);if(m<0)h=h.left;else{if(!(m>0))return h.value;h=h.right}}return null},Z.prototype.put=function(l,h){if(null===this.root_)return this.root_={key:l,value:h,left:null,right:null,parent:null,color:wr,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var m,_,C=this.root_;do{if(m=C,(_=l.compareTo(C.key))<0)C=C.left;else{if(!(_>0)){var F=C.value;return C.value=h,F}C=C.right}}while(null!==C);var rt={key:l,left:null,right:null,value:h,parent:m,color:wr,getValue:function(){return this.value},getKey:function(){return this.key}};return _<0?m.left=rt:m.right=rt,this.fixAfterInsertion(rt),this.size_++,null},Z.prototype.fixAfterInsertion=function(l){for(l.color=1;null!=l&&l!==this.root_&&1===l.parent.color;)if(W(l)===A(W(W(l)))){var h=X(W(W(l)));1===R(h)?(k(W(l),wr),k(h,wr),k(W(W(l)),1),l=W(W(l))):(l===X(W(l))&&(l=W(l),this.rotateLeft(l)),k(W(l),wr),k(W(W(l)),1),this.rotateRight(W(W(l))))}else{var m=A(W(W(l)));1===R(m)?(k(W(l),wr),k(m,wr),k(W(W(l)),1),l=W(W(l))):(l===A(W(l))&&(l=W(l),this.rotateRight(l)),k(W(l),wr),k(W(W(l)),1),this.rotateLeft(W(W(l))))}this.root_.color=wr},Z.prototype.values=function(){var l=new ue,h=this.getFirstEntry();if(null!==h)for(l.add(h.value);null!==(h=Z.successor(h));)l.add(h.value);return l},Z.prototype.entrySet=function(){var l=new Jr,h=this.getFirstEntry();if(null!==h)for(l.add(h);null!==(h=Z.successor(h));)l.add(h);return l},Z.prototype.rotateLeft=function(l){if(null!=l){var h=l.right;l.right=h.left,null!=h.left&&(h.left.parent=l),h.parent=l.parent,null===l.parent?this.root_=h:l.parent.left===l?l.parent.left=h:l.parent.right=h,h.left=l,l.parent=h}},Z.prototype.rotateRight=function(l){if(null!=l){var h=l.left;l.left=h.right,null!=h.right&&(h.right.parent=l),h.parent=l.parent,null===l.parent?this.root_=h:l.parent.right===l?l.parent.right=h:l.parent.left=h,h.right=l,l.parent=h}},Z.prototype.getFirstEntry=function(){var l=this.root_;if(null!=l)for(;null!=l.left;)l=l.left;return l},Z.successor=function(l){if(null===l)return null;if(null!==l.right){for(var h=l.right;null!==h.left;)h=h.left;return h}for(var m=l.parent,_=l;null!==m&&_===m.right;)_=m,m=m.parent;return m},Z.prototype.size=function(){return this.size_};var Dn=function(){};Dn.prototype.interfaces_=function(){return[]},Dn.prototype.getClass=function(){return Dn},G.prototype=new Y,(it.prototype=new G).contains=function(l){for(var h=0,m=this.array_.length;h<m;h++)if(0===this.array_[h].compareTo(l))return!0;return!1},it.prototype.add=function(l){if(this.contains(l))return!1;for(var h=0,m=this.array_.length;h<m;h++)if(1===this.array_[h].compareTo(l))return this.array_.splice(h,0,l),!0;return this.array_.push(l),!0},it.prototype.addAll=function(l){for(var h=l.iterator();h.hasNext();)this.add(h.next());return!0},it.prototype.remove=function(l){throw new q},it.prototype.size=function(){return this.array_.length},it.prototype.isEmpty=function(){return 0===this.array_.length},it.prototype.toArray=function(){for(var l=[],h=0,m=this.array_.length;h<m;h++)l.push(this.array_[h]);return l},it.prototype.iterator=function(){return new si(this)};var si=function(l){this.treeSet_=l,this.position_=0};si.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new H;return this.treeSet_.array_[this.position_++]},si.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},si.prototype.remove=function(){throw new q};var Rr=function(){};Rr.sort=function(){var l,h,m,C=arguments[0];if(1===arguments.length)C.sort(function(rt,Dt){return rt.compareTo(Dt)});else if(2===arguments.length)m=arguments[1],C.sort(function(rt,Dt){return m.compare(rt,Dt)});else if(3===arguments.length){(h=C.slice(arguments[1],arguments[2])).sort();var F=C.slice(0,arguments[1]).concat(h,C.slice(arguments[2],C.length));for(C.splice(0,C.length),l=0;l<F.length;l++)C.push(F[l])}else if(4===arguments.length)for(h=C.slice(arguments[1],arguments[2]),m=arguments[3],h.sort(function(rt,Dt){return m.compare(rt,Dt)}),F=C.slice(0,arguments[1]).concat(h,C.slice(arguments[2],C.length)),C.splice(0,C.length),l=0;l<F.length;l++)C.push(F[l])},Rr.asList=function(l){for(var h=new ue,m=0,_=l.length;m<_;m++)h.add(l[m]);return h};var er=function(){},Zi={P:{configurable:!0},L:{configurable:!0},A:{configurable:!0},FALSE:{configurable:!0},TRUE:{configurable:!0},DONTCARE:{configurable:!0},SYM_FALSE:{configurable:!0},SYM_TRUE:{configurable:!0},SYM_DONTCARE:{configurable:!0},SYM_P:{configurable:!0},SYM_L:{configurable:!0},SYM_A:{configurable:!0}};Zi.P.get=function(){return 0},Zi.L.get=function(){return 1},Zi.A.get=function(){return 2},Zi.FALSE.get=function(){return-1},Zi.TRUE.get=function(){return-2},Zi.DONTCARE.get=function(){return-3},Zi.SYM_FALSE.get=function(){return"F"},Zi.SYM_TRUE.get=function(){return"T"},Zi.SYM_DONTCARE.get=function(){return"*"},Zi.SYM_P.get=function(){return"0"},Zi.SYM_L.get=function(){return"1"},Zi.SYM_A.get=function(){return"2"},er.prototype.interfaces_=function(){return[]},er.prototype.getClass=function(){return er},er.toDimensionSymbol=function(l){switch(l){case er.FALSE:return er.SYM_FALSE;case er.TRUE:return er.SYM_TRUE;case er.DONTCARE:return er.SYM_DONTCARE;case er.P:return er.SYM_P;case er.L:return er.SYM_L;case er.A:return er.SYM_A}throw new dt("Unknown dimension value: "+l)},er.toDimensionValue=function(l){switch(Mt.toUpperCase(l)){case er.SYM_FALSE:return er.FALSE;case er.SYM_TRUE:return er.TRUE;case er.SYM_DONTCARE:return er.DONTCARE;case er.SYM_P:return er.P;case er.SYM_L:return er.L;case er.SYM_A:return er.A}throw new dt("Unknown dimension symbol: "+l)},Object.defineProperties(er,Zi);var fi=function(){};fi.prototype.filter=function(l){},fi.prototype.interfaces_=function(){return[]},fi.prototype.getClass=function(){return fi};var oi=function(){};oi.prototype.filter=function(l,h){},oi.prototype.isDone=function(){},oi.prototype.isGeometryChanged=function(){},oi.prototype.interfaces_=function(){return[]},oi.prototype.getClass=function(){return oi};var zr=function(l){function h(_,C){if(l.call(this,C),this._geometries=_||[],l.hasNullElements(this._geometries))throw new dt("geometries must not contain null elements")}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){for(var _=new De,C=0;C<this._geometries.length;C++)_.expandToInclude(this._geometries[C].getEnvelopeInternal());return _},h.prototype.getGeometryN=function(_){return this._geometries[_]},h.prototype.getSortIndex=function(){return l.SORTINDEX_GEOMETRYCOLLECTION},h.prototype.getCoordinates=function(){for(var _=new Array(this.getNumPoints()).fill(null),C=-1,F=0;F<this._geometries.length;F++)for(var rt=this._geometries[F].getCoordinates(),Dt=0;Dt<rt.length;Dt++)_[++C]=rt[Dt];return _},h.prototype.getArea=function(){for(var _=0,C=0;C<this._geometries.length;C++)_+=this._geometries[C].getArea();return _},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];if(!this.isEquivalentClass(_))return!1;var F=_;if(this._geometries.length!==F._geometries.length)return!1;for(var rt=0;rt<this._geometries.length;rt++)if(!this._geometries[rt].equalsExact(F._geometries[rt],C))return!1;return!0}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){for(var _=0;_<this._geometries.length;_++)this._geometries[_].normalize();Rr.sort(this._geometries)},h.prototype.getCoordinate=function(){return this.isEmpty()?null:this._geometries[0].getCoordinate()},h.prototype.getBoundaryDimension=function(){for(var _=er.FALSE,C=0;C<this._geometries.length;C++)_=Math.max(_,this._geometries[C].getBoundaryDimension());return _},h.prototype.getDimension=function(){for(var _=er.FALSE,C=0;C<this._geometries.length;C++)_=Math.max(_,this._geometries[C].getDimension());return _},h.prototype.getLength=function(){for(var _=0,C=0;C<this._geometries.length;C++)_+=this._geometries[C].getLength();return _},h.prototype.getNumPoints=function(){for(var _=0,C=0;C<this._geometries.length;C++)_+=this._geometries[C].getNumPoints();return _},h.prototype.getNumGeometries=function(){return this._geometries.length},h.prototype.reverse=function(){for(var C=new Array(this._geometries.length).fill(null),F=0;F<this._geometries.length;F++)C[F]=this._geometries[F].reverse();return this.getFactory().createGeometryCollection(C)},h.prototype.compareToSameClass=function(){if(1===arguments.length){var _=arguments[0],C=new it(Rr.asList(this._geometries)),F=new it(Rr.asList(_._geometries));return this.compare(C,F)}if(2===arguments.length){for(var Dt=arguments[1],Qt=arguments[0],fe=this.getNumGeometries(),ke=Qt.getNumGeometries(),Ge=0;Ge<fe&&Ge<ke;){var _n=this.getGeometryN(Ge),Sn=Qt.getGeometryN(Ge),Un=_n.compareToSameClass(Sn,Dt);if(0!==Un)return Un;Ge++}return Ge<fe?1:Ge<ke?-1:0}},h.prototype.apply=function(){if(O(arguments[0],Et))for(var _=arguments[0],C=0;C<this._geometries.length;C++)this._geometries[C].apply(_);else if(O(arguments[0],oi)){var F=arguments[0];if(0===this._geometries.length)return null;for(var rt=0;rt<this._geometries.length&&(this._geometries[rt].apply(F),!F.isDone());rt++);F.isGeometryChanged()&&this.geometryChanged()}else if(O(arguments[0],fi)){var Dt=arguments[0];Dt.filter(this);for(var Qt=0;Qt<this._geometries.length;Qt++)this._geometries[Qt].apply(Dt)}else if(O(arguments[0],Eo)){var fe=arguments[0];fe.filter(this);for(var ke=0;ke<this._geometries.length;ke++)this._geometries[ke].apply(fe)}},h.prototype.getBoundary=function(){return this.checkNotGeometryCollection(this),Nn.shouldNeverReachHere(),null},h.prototype.clone=function(){var _=l.prototype.clone.call(this);_._geometries=new Array(this._geometries.length).fill(null);for(var C=0;C<this._geometries.length;C++)_._geometries[C]=this._geometries[C].clone();return _},h.prototype.getGeometryType=function(){return"GeometryCollection"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),C=0;C<_.length;C++)_[C]=this._geometries[C].copy();return new h(_,this._factory)},h.prototype.isEmpty=function(){for(var _=0;_<this._geometries.length;_++)if(!this._geometries[_].isEmpty())return!1;return!0},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return-0x4f07bcb1f857d800},Object.defineProperties(h,m),h}(Hn),js=function(l){function h(){l.apply(this,arguments)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Hn.SORTINDEX_MULTILINESTRING},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];return!!this.isEquivalentClass(_)&&l.prototype.equalsExact.call(this,_,C)}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return this.isClosed()?er.FALSE:0},h.prototype.isClosed=function(){if(this.isEmpty())return!1;for(var _=0;_<this._geometries.length;_++)if(!this._geometries[_].isClosed())return!1;return!0},h.prototype.getDimension=function(){return 1},h.prototype.reverse=function(){for(var _=this._geometries.length,C=new Array(_).fill(null),F=0;F<this._geometries.length;F++)C[_-1-F]=this._geometries[F].reverse();return this.getFactory().createMultiLineString(C)},h.prototype.getBoundary=function(){return new ho(this).getBoundary()},h.prototype.getGeometryType=function(){return"MultiLineString"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),C=0;C<_.length;C++)_[C]=this._geometries[C].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[Dn]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return 0x7155d2ab4afa8000},Object.defineProperties(h,m),h}(zr),ho=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){var l=arguments[0],h=Rt.MOD2_BOUNDARY_RULE;this._geom=l,this._geomFact=l.getFactory(),this._bnRule=h}else if(2===arguments.length){var m=arguments[0],_=arguments[1];this._geom=m,this._geomFact=m.getFactory(),this._bnRule=_}};ho.prototype.boundaryMultiLineString=function(l){if(this._geom.isEmpty())return this.getEmptyMultiPoint();var h=this.computeBoundaryCoordinates(l);return 1===h.length?this._geomFact.createPoint(h[0]):this._geomFact.createMultiPointFromCoords(h)},ho.prototype.getBoundary=function(){return this._geom instanceof Vr?this.boundaryLineString(this._geom):this._geom instanceof js?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()},ho.prototype.boundaryLineString=function(l){return this._geom.isEmpty()?this.getEmptyMultiPoint():l.isClosed()?this._bnRule.isInBoundary(2)?l.getStartPoint():this._geomFact.createMultiPoint():this._geomFact.createMultiPoint([l.getStartPoint(),l.getEndPoint()])},ho.prototype.getEmptyMultiPoint=function(){return this._geomFact.createMultiPoint()},ho.prototype.computeBoundaryCoordinates=function(l){var h=new ue;this._endpointMap=new Z;for(var m=0;m<l.getNumGeometries();m++){var _=l.getGeometryN(m);0!==_.getNumPoints()&&(this.addEndpoint(_.getCoordinateN(0)),this.addEndpoint(_.getCoordinateN(_.getNumPoints()-1)))}for(var C=this._endpointMap.entrySet().iterator();C.hasNext();){var F=C.next(),rt=F.getValue().count;this._bnRule.isInBoundary(rt)&&h.add(F.getKey())}return un.toCoordinateArray(h)},ho.prototype.addEndpoint=function(l){var h=this._endpointMap.get(l);null===h&&(h=new Es,this._endpointMap.put(l,h)),h.count++},ho.prototype.interfaces_=function(){return[]},ho.prototype.getClass=function(){return ho},ho.getBoundary=function(){return 1===arguments.length?new ho(arguments[0]).getBoundary():2===arguments.length?new ho(arguments[0],arguments[1]).getBoundary():void 0};var Es=function(){this.count=null};Es.prototype.interfaces_=function(){return[]},Es.prototype.getClass=function(){return Es};var Ks=function(){},Ss={NEWLINE:{configurable:!0},SIMPLE_ORDINATE_FORMAT:{configurable:!0}};Ks.prototype.interfaces_=function(){return[]},Ks.prototype.getClass=function(){return Ks},Ks.chars=function(l,h){for(var m=new Array(h).fill(null),_=0;_<h;_++)m[_]=l;return String(m)},Ks.getStackTrace=function(){if(1===arguments.length){var l=arguments[0],h=new function(){},m=new function(){}(h);return l.printStackTrace(m),h.toString()}if(2===arguments.length){for(var C=arguments[1],F="",rt=new function(){}(new function(){}(Ks.getStackTrace(arguments[0]))),Dt=0;Dt<C;Dt++)try{F+=rt.readLine()+Ks.NEWLINE}catch(Qt){if(!(Qt instanceof bt))throw Qt;Nn.shouldNeverReachHere()}return F}},Ks.split=function(l,h){for(var m=h.length,_=new ue,C=""+l,F=C.indexOf(h);F>=0;){var rt=C.substring(0,F);_.add(rt),F=(C=C.substring(F+m)).indexOf(h)}C.length>0&&_.add(C);for(var Dt=new Array(_.size()).fill(null),Qt=0;Qt<Dt.length;Qt++)Dt[Qt]=_.get(Qt);return Dt},Ks.toString=function(){if(1===arguments.length)return Ks.SIMPLE_ORDINATE_FORMAT.format(arguments[0])},Ks.spaces=function(l){return Ks.chars(" ",l)},Ss.NEWLINE.get=function(){return Xe.getProperty("line.separator")},Ss.SIMPLE_ORDINATE_FORMAT.get=function(){return new function(){}("0.#")},Object.defineProperties(Ks,Ss);var ti=function(){};ti.prototype.interfaces_=function(){return[]},ti.prototype.getClass=function(){return ti},ti.copyCoord=function(l,h,m,_){for(var C=Math.min(l.getDimension(),m.getDimension()),F=0;F<C;F++)m.setOrdinate(_,F,l.getOrdinate(h,F))},ti.isRing=function(l){var h=l.size();return 0===h||!(h<=3)&&l.getOrdinate(0,jt.X)===l.getOrdinate(h-1,jt.X)&&l.getOrdinate(0,jt.Y)===l.getOrdinate(h-1,jt.Y)},ti.isEqual=function(l,h){var m=l.size();if(m!==h.size())return!1;for(var _=Math.min(l.getDimension(),h.getDimension()),C=0;C<m;C++)for(var F=0;F<_;F++){var rt=l.getOrdinate(C,F),Dt=h.getOrdinate(C,F);if(!(l.getOrdinate(C,F)===h.getOrdinate(C,F)||lt.isNaN(rt)&&lt.isNaN(Dt)))return!1}return!0},ti.extend=function(l,h,m){var _=l.create(m,h.getDimension()),C=h.size();if(ti.copy(h,0,_,0,C),C>0)for(var F=C;F<m;F++)ti.copy(h,C-1,_,F,1);return _},ti.reverse=function(l){for(var h=l.size()-1,m=Math.trunc(h/2),_=0;_<=m;_++)ti.swap(l,_,h-_)},ti.swap=function(l,h,m){if(h===m)return null;for(var _=0;_<l.getDimension();_++){var C=l.getOrdinate(h,_);l.setOrdinate(h,_,l.getOrdinate(m,_)),l.setOrdinate(m,_,C)}},ti.copy=function(l,h,m,_,C){for(var F=0;F<C;F++)ti.copyCoord(l,h+F,m,_+F)},ti.toString=function(){if(1===arguments.length){var l=arguments[0],h=l.size();if(0===h)return"()";var m=l.getDimension(),_=new vt;_.append("(");for(var C=0;C<h;C++){C>0&&_.append(" ");for(var F=0;F<m;F++)F>0&&_.append(","),_.append(Ks.toString(l.getOrdinate(C,F)))}return _.append(")"),_.toString()}},ti.ensureValidRing=function(l,h){var m=h.size();return 0===m?h:m<=3?ti.createClosedRing(l,h,4):h.getOrdinate(0,jt.X)===h.getOrdinate(m-1,jt.X)&&h.getOrdinate(0,jt.Y)===h.getOrdinate(m-1,jt.Y)?h:ti.createClosedRing(l,h,m+1)},ti.createClosedRing=function(l,h,m){var _=l.create(m,h.getDimension()),C=h.size();ti.copy(h,0,_,0,C);for(var F=C;F<m;F++)ti.copy(h,0,_,F,1);return _};var Vr=function(l){function h(_,C){l.call(this,C),this._points=null,this.init(_)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){return this.isEmpty()?new De:this._points.expandEnvelope(new De)},h.prototype.isRing=function(){return this.isClosed()&&this.isSimple()},h.prototype.getSortIndex=function(){return l.SORTINDEX_LINESTRING},h.prototype.getCoordinates=function(){return this._points.toCoordinateArray()},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];if(!this.isEquivalentClass(_))return!1;var F=_;if(this._points.size()!==F._points.size())return!1;for(var rt=0;rt<this._points.size();rt++)if(!this.equal(this._points.getCoordinate(rt),F._points.getCoordinate(rt),C))return!1;return!0}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){for(var _=0;_<Math.trunc(this._points.size()/2);_++){var C=this._points.size()-1-_;if(!this._points.getCoordinate(_).equals(this._points.getCoordinate(C)))return this._points.getCoordinate(_).compareTo(this._points.getCoordinate(C))>0&&ti.reverse(this._points),null}},h.prototype.getCoordinate=function(){return this.isEmpty()?null:this._points.getCoordinate(0)},h.prototype.getBoundaryDimension=function(){return this.isClosed()?er.FALSE:0},h.prototype.isClosed=function(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},h.prototype.getEndPoint=function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},h.prototype.getDimension=function(){return 1},h.prototype.getLength=function(){return yn.computeLength(this._points)},h.prototype.getNumPoints=function(){return this._points.size()},h.prototype.reverse=function(){var _=this._points.copy();return ti.reverse(_),this.getFactory().createLineString(_)},h.prototype.compareToSameClass=function(){if(1===arguments.length){for(var _=arguments[0],C=0,F=0;C<this._points.size()&&F<_._points.size();){var rt=this._points.getCoordinate(C).compareTo(_._points.getCoordinate(F));if(0!==rt)return rt;C++,F++}return C<this._points.size()?1:F<_._points.size()?-1:0}if(2===arguments.length)return arguments[1].compare(this._points,arguments[0]._points)},h.prototype.apply=function(){if(O(arguments[0],Et))for(var _=arguments[0],C=0;C<this._points.size();C++)_.filter(this._points.getCoordinate(C));else if(O(arguments[0],oi)){var F=arguments[0];if(0===this._points.size())return null;for(var rt=0;rt<this._points.size()&&(F.filter(this._points,rt),!F.isDone());rt++);F.isGeometryChanged()&&this.geometryChanged()}else(O(arguments[0],fi)||O(arguments[0],Eo))&&arguments[0].filter(this)},h.prototype.getBoundary=function(){return new ho(this).getBoundary()},h.prototype.isEquivalentClass=function(_){return _ instanceof h},h.prototype.clone=function(){var _=l.prototype.clone.call(this);return _._points=this._points.clone(),_},h.prototype.getCoordinateN=function(_){return this._points.getCoordinate(_)},h.prototype.getGeometryType=function(){return"LineString"},h.prototype.copy=function(){return new h(this._points.copy(),this._factory)},h.prototype.getCoordinateSequence=function(){return this._points},h.prototype.isEmpty=function(){return 0===this._points.size()},h.prototype.init=function(_){if(null===_&&(_=this.getFactory().getCoordinateSequenceFactory().create([])),1===_.size())throw new dt("Invalid number of points in LineString (found "+_.size()+" - must be 0 or >= 2)");this._points=_},h.prototype.isCoordinate=function(_){for(var C=0;C<this._points.size();C++)if(this._points.getCoordinate(C).equals(_))return!0;return!1},h.prototype.getStartPoint=function(){return this.isEmpty()?null:this.getPointN(0)},h.prototype.getPointN=function(_){return this.getFactory().createPoint(this._points.getCoordinate(_))},h.prototype.interfaces_=function(){return[Dn]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return 0x2b2b51ba435c8e00},Object.defineProperties(h,m),h}(Hn),Co=function(){};Co.prototype.interfaces_=function(){return[]},Co.prototype.getClass=function(){return Co};var Ls=function(l){function h(_,C){l.call(this,C),this._coordinates=_||null,this.init(this._coordinates)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){if(this.isEmpty())return new De;var _=new De;return _.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),_},h.prototype.getSortIndex=function(){return l.SORTINDEX_POINT},h.prototype.getCoordinates=function(){return this.isEmpty()?[]:[this.getCoordinate()]},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];return!!this.isEquivalentClass(_)&&(!(!this.isEmpty()||!_.isEmpty())||this.isEmpty()===_.isEmpty()&&this.equal(_.getCoordinate(),this.getCoordinate(),C))}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){},h.prototype.getCoordinate=function(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null},h.prototype.getBoundaryDimension=function(){return er.FALSE},h.prototype.getDimension=function(){return 0},h.prototype.getNumPoints=function(){return this.isEmpty()?0:1},h.prototype.reverse=function(){return this.copy()},h.prototype.getX=function(){if(null===this.getCoordinate())throw new Error("getX called on empty Point");return this.getCoordinate().x},h.prototype.compareToSameClass=function(){if(1===arguments.length){var _=arguments[0];return this.getCoordinate().compareTo(_.getCoordinate())}if(2===arguments.length)return arguments[1].compare(this._coordinates,arguments[0]._coordinates)},h.prototype.apply=function(){if(O(arguments[0],Et)){var _=arguments[0];if(this.isEmpty())return null;_.filter(this.getCoordinate())}else if(O(arguments[0],oi)){var C=arguments[0];if(this.isEmpty())return null;C.filter(this._coordinates,0),C.isGeometryChanged()&&this.geometryChanged()}else(O(arguments[0],fi)||O(arguments[0],Eo))&&arguments[0].filter(this)},h.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},h.prototype.clone=function(){var _=l.prototype.clone.call(this);return _._coordinates=this._coordinates.clone(),_},h.prototype.getGeometryType=function(){return"Point"},h.prototype.copy=function(){return new h(this._coordinates.copy(),this._factory)},h.prototype.getCoordinateSequence=function(){return this._coordinates},h.prototype.getY=function(){if(null===this.getCoordinate())throw new Error("getY called on empty Point");return this.getCoordinate().y},h.prototype.isEmpty=function(){return 0===this._coordinates.size()},h.prototype.init=function(_){null===_&&(_=this.getFactory().getCoordinateSequenceFactory().create([])),Nn.isTrue(_.size()<=1),this._coordinates=_},h.prototype.isSimple=function(){return!0},h.prototype.interfaces_=function(){return[Co]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return 0x44077bad161cbc00},Object.defineProperties(h,m),h}(Hn),Pa=function(){};Pa.prototype.interfaces_=function(){return[]},Pa.prototype.getClass=function(){return Pa};var rs=function(l){function h(_,C,F){if(l.call(this,F),this._shell=null,this._holes=null,null===_&&(_=this.getFactory().createLinearRing()),null===C&&(C=[]),l.hasNullElements(C))throw new dt("holes must not contain null elements");if(_.isEmpty()&&l.hasNonEmptyElements(C))throw new dt("shell is empty but holes are not");this._shell=_,this._holes=C}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){return this._shell.getEnvelopeInternal()},h.prototype.getSortIndex=function(){return l.SORTINDEX_POLYGON},h.prototype.getCoordinates=function(){if(this.isEmpty())return[];for(var _=new Array(this.getNumPoints()).fill(null),C=-1,F=this._shell.getCoordinates(),rt=0;rt<F.length;rt++)_[++C]=F[rt];for(var Dt=0;Dt<this._holes.length;Dt++)for(var Qt=this._holes[Dt].getCoordinates(),fe=0;fe<Qt.length;fe++)_[++C]=Qt[fe];return _},h.prototype.getArea=function(){var _=0;_+=Math.abs(yn.signedArea(this._shell.getCoordinateSequence()));for(var C=0;C<this._holes.length;C++)_-=Math.abs(yn.signedArea(this._holes[C].getCoordinateSequence()));return _},h.prototype.isRectangle=function(){if(0!==this.getNumInteriorRing()||null===this._shell||5!==this._shell.getNumPoints())return!1;for(var _=this._shell.getCoordinateSequence(),C=this.getEnvelopeInternal(),F=0;F<5;F++){var rt=_.getX(F);if(rt!==C.getMinX()&&rt!==C.getMaxX())return!1;var Dt=_.getY(F);if(Dt!==C.getMinY()&&Dt!==C.getMaxY())return!1}for(var Qt=_.getX(0),fe=_.getY(0),ke=1;ke<=4;ke++){var Ge=_.getX(ke),_n=_.getY(ke);if(Ge!==Qt==(_n!==fe))return!1;Qt=Ge,fe=_n}return!0},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];if(!this.isEquivalentClass(_))return!1;var F=_;if(!this._shell.equalsExact(F._shell,C)||this._holes.length!==F._holes.length)return!1;for(var Qt=0;Qt<this._holes.length;Qt++)if(!this._holes[Qt].equalsExact(F._holes[Qt],C))return!1;return!0}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){if(0===arguments.length){this.normalize(this._shell,!0);for(var _=0;_<this._holes.length;_++)this.normalize(this._holes[_],!1);Rr.sort(this._holes)}else if(2===arguments.length){var C=arguments[0],F=arguments[1];if(C.isEmpty())return null;var rt=new Array(C.getCoordinates().length-1).fill(null);Xe.arraycopy(C.getCoordinates(),0,rt,0,rt.length);var Dt=un.minCoordinate(C.getCoordinates());un.scroll(rt,Dt),Xe.arraycopy(rt,0,C.getCoordinates(),0,rt.length),C.getCoordinates()[rt.length]=rt[0],yn.isCCW(C.getCoordinates())===F&&un.reverse(C.getCoordinates())}},h.prototype.getCoordinate=function(){return this._shell.getCoordinate()},h.prototype.getNumInteriorRing=function(){return this._holes.length},h.prototype.getBoundaryDimension=function(){return 1},h.prototype.getDimension=function(){return 2},h.prototype.getLength=function(){var _=0;_+=this._shell.getLength();for(var C=0;C<this._holes.length;C++)_+=this._holes[C].getLength();return _},h.prototype.getNumPoints=function(){for(var _=this._shell.getNumPoints(),C=0;C<this._holes.length;C++)_+=this._holes[C].getNumPoints();return _},h.prototype.reverse=function(){var _=this.copy();_._shell=this._shell.copy().reverse(),_._holes=new Array(this._holes.length).fill(null);for(var C=0;C<this._holes.length;C++)_._holes[C]=this._holes[C].copy().reverse();return _},h.prototype.convexHull=function(){return this.getExteriorRing().convexHull()},h.prototype.compareToSameClass=function(){if(1===arguments.length)return this._shell.compareToSameClass(arguments[0]._shell);if(2===arguments.length){var Dt=arguments[1],Qt=arguments[0],Ge=this._shell.compareToSameClass(Qt._shell,Dt);if(0!==Ge)return Ge;for(var _n=this.getNumInteriorRing(),Sn=Qt.getNumInteriorRing(),Un=0;Un<_n&&Un<Sn;){var ur=this.getInteriorRingN(Un),Ji=Qt.getInteriorRingN(Un),To=ur.compareToSameClass(Ji,Dt);if(0!==To)return To;Un++}return Un<_n?1:Un<Sn?-1:0}},h.prototype.apply=function(_){if(O(_,Et)){this._shell.apply(_);for(var C=0;C<this._holes.length;C++)this._holes[C].apply(_)}else if(O(_,oi)){if(this._shell.apply(_),!_.isDone())for(var F=0;F<this._holes.length&&(this._holes[F].apply(_),!_.isDone());F++);_.isGeometryChanged()&&this.geometryChanged()}else if(O(_,fi))_.filter(this);else if(O(_,Eo)){_.filter(this),this._shell.apply(_);for(var rt=0;rt<this._holes.length;rt++)this._holes[rt].apply(_)}},h.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var _=new Array(this._holes.length+1).fill(null);_[0]=this._shell;for(var C=0;C<this._holes.length;C++)_[C+1]=this._holes[C];return _.length<=1?this.getFactory().createLinearRing(_[0].getCoordinateSequence()):this.getFactory().createMultiLineString(_)},h.prototype.clone=function(){var _=l.prototype.clone.call(this);_._shell=this._shell.clone(),_._holes=new Array(this._holes.length).fill(null);for(var C=0;C<this._holes.length;C++)_._holes[C]=this._holes[C].clone();return _},h.prototype.getGeometryType=function(){return"Polygon"},h.prototype.copy=function(){for(var _=this._shell.copy(),C=new Array(this._holes.length).fill(null),F=0;F<C.length;F++)C[F]=this._holes[F].copy();return new h(_,C,this._factory)},h.prototype.getExteriorRing=function(){return this._shell},h.prototype.isEmpty=function(){return this._shell.isEmpty()},h.prototype.getInteriorRingN=function(_){return this._holes[_]},h.prototype.interfaces_=function(){return[Pa]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return-0x307ffefd8dc97200},Object.defineProperties(h,m),h}(Hn),Oa=function(l){function h(){l.apply(this,arguments)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Hn.SORTINDEX_MULTIPOINT},h.prototype.isValid=function(){return!0},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];return!!this.isEquivalentClass(_)&&l.prototype.equalsExact.call(this,_,C)}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.getCoordinate=function(){return 1===arguments.length?this._geometries[arguments[0]].getCoordinate():l.prototype.getCoordinate.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return er.FALSE},h.prototype.getDimension=function(){return 0},h.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},h.prototype.getGeometryType=function(){return"MultiPoint"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),C=0;C<_.length;C++)_[C]=this._geometries[C].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[Co]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return-0x6fb1ed4162e0fc00},Object.defineProperties(h,m),h}(zr),eo=function(l){function h(_,C){_ instanceof B&&C instanceof nr&&(_=C.getCoordinateSequenceFactory().create(_)),l.call(this,_,C),this.validateConstruction()}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={MINIMUM_VALID_SIZE:{configurable:!0},serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Hn.SORTINDEX_LINEARRING},h.prototype.getBoundaryDimension=function(){return er.FALSE},h.prototype.isClosed=function(){return!!this.isEmpty()||l.prototype.isClosed.call(this)},h.prototype.reverse=function(){var _=this._points.copy();return ti.reverse(_),this.getFactory().createLinearRing(_)},h.prototype.validateConstruction=function(){if(!this.isEmpty()&&!l.prototype.isClosed.call(this))throw new dt("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<h.MINIMUM_VALID_SIZE)throw new dt("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},h.prototype.getGeometryType=function(){return"LinearRing"},h.prototype.copy=function(){return new h(this._points.copy(),this._factory)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},m.MINIMUM_VALID_SIZE.get=function(){return 4},m.serialVersionUID.get=function(){return-0x3b229e262367a600},Object.defineProperties(h,m),h}(Vr),wo=function(l){function h(){l.apply(this,arguments)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Hn.SORTINDEX_MULTIPOLYGON},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];return!!this.isEquivalentClass(_)&&l.prototype.equalsExact.call(this,_,C)}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return 1},h.prototype.getDimension=function(){return 2},h.prototype.reverse=function(){for(var C=new Array(this._geometries.length).fill(null),F=0;F<this._geometries.length;F++)C[F]=this._geometries[F].reverse();return this.getFactory().createMultiPolygon(C)},h.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var _=new ue,C=0;C<this._geometries.length;C++)for(var F=this._geometries[C].getBoundary(),rt=0;rt<F.getNumGeometries();rt++)_.add(F.getGeometryN(rt));var Dt=new Array(_.size()).fill(null);return this.getFactory().createMultiLineString(_.toArray(Dt))},h.prototype.getGeometryType=function(){return"MultiPolygon"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),C=0;C<_.length;C++)_[C]=this._geometries[C].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[Pa]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return-0x7a5aa1369171980},Object.defineProperties(h,m),h}(zr),ys=function(l){this._factory=l||null,this._isUserDataCopied=!1},Wa={NoOpGeometryOperation:{configurable:!0},CoordinateOperation:{configurable:!0},CoordinateSequenceOperation:{configurable:!0}};ys.prototype.setCopyUserData=function(l){this._isUserDataCopied=l},ys.prototype.edit=function(l,h){if(null===l)return null;var m=this.editInternal(l,h);return this._isUserDataCopied&&m.setUserData(l.getUserData()),m},ys.prototype.editInternal=function(l,h){return null===this._factory&&(this._factory=l.getFactory()),l instanceof zr?this.editGeometryCollection(l,h):l instanceof rs?this.editPolygon(l,h):l instanceof Ls||l instanceof Vr?h.edit(l,this._factory):(Nn.shouldNeverReachHere("Unsupported Geometry class: "+l.getClass().getName()),null)},ys.prototype.editGeometryCollection=function(l,h){for(var m=h.edit(l,this._factory),_=new ue,C=0;C<m.getNumGeometries();C++){var F=this.edit(m.getGeometryN(C),h);null===F||F.isEmpty()||_.add(F)}return m.getClass()===Oa?this._factory.createMultiPoint(_.toArray([])):m.getClass()===js?this._factory.createMultiLineString(_.toArray([])):m.getClass()===wo?this._factory.createMultiPolygon(_.toArray([])):this._factory.createGeometryCollection(_.toArray([]))},ys.prototype.editPolygon=function(l,h){var m=h.edit(l,this._factory);if(null===m&&(m=this._factory.createPolygon(null)),m.isEmpty())return m;var _=this.edit(m.getExteriorRing(),h);if(null===_||_.isEmpty())return this._factory.createPolygon();for(var C=new ue,F=0;F<m.getNumInteriorRing();F++){var rt=this.edit(m.getInteriorRingN(F),h);null===rt||rt.isEmpty()||C.add(rt)}return this._factory.createPolygon(_,C.toArray([]))},ys.prototype.interfaces_=function(){return[]},ys.prototype.getClass=function(){return ys},ys.GeometryEditorOperation=function(){},Wa.NoOpGeometryOperation.get=function(){return bu},Wa.CoordinateOperation.get=function(){return Ra},Wa.CoordinateSequenceOperation.get=function(){return $r},Object.defineProperties(ys,Wa);var bu=function(){};bu.prototype.edit=function(l,h){return l},bu.prototype.interfaces_=function(){return[ys.GeometryEditorOperation]},bu.prototype.getClass=function(){return bu};var Ra=function(){};Ra.prototype.edit=function(l,h){var m=this.editCoordinates(l.getCoordinates(),l);return null===m?l:l instanceof eo?h.createLinearRing(m):l instanceof Vr?h.createLineString(m):l instanceof Ls?m.length>0?h.createPoint(m[0]):h.createPoint():l},Ra.prototype.interfaces_=function(){return[ys.GeometryEditorOperation]},Ra.prototype.getClass=function(){return Ra};var $r=function(){};$r.prototype.edit=function(l,h){return l instanceof eo?h.createLinearRing(this.edit(l.getCoordinateSequence(),l)):l instanceof Vr?h.createLineString(this.edit(l.getCoordinateSequence(),l)):l instanceof Ls?h.createPoint(this.edit(l.getCoordinateSequence(),l)):l},$r.prototype.interfaces_=function(){return[ys.GeometryEditorOperation]},$r.prototype.getClass=function(){return $r};var pr=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array)this._coordinates=arguments[0],this._dimension=3;else if(Number.isInteger(arguments[0])){var l=arguments[0];this._coordinates=new Array(l).fill(null);for(var h=0;h<l;h++)this._coordinates[h]=new B}else if(O(arguments[0],jt)){var m=arguments[0];if(null===m)return this._coordinates=new Array(0).fill(null),null;this._dimension=m.getDimension(),this._coordinates=new Array(m.size()).fill(null);for(var _=0;_<this._coordinates.length;_++)this._coordinates[_]=m.getCoordinateCopy(_)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var C=arguments[0],F=arguments[1];this._coordinates=C,this._dimension=F,null===C&&(this._coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var rt=arguments[0],Dt=arguments[1];this._coordinates=new Array(rt).fill(null),this._dimension=Dt;for(var Qt=0;Qt<rt;Qt++)this._coordinates[Qt]=new B}},fu={serialVersionUID:{configurable:!0}};pr.prototype.setOrdinate=function(l,h,m){switch(h){case jt.X:this._coordinates[l].x=m;break;case jt.Y:this._coordinates[l].y=m;break;case jt.Z:this._coordinates[l].z=m;break;default:throw new dt("invalid ordinateIndex")}},pr.prototype.size=function(){return this._coordinates.length},pr.prototype.getOrdinate=function(l,h){switch(h){case jt.X:return this._coordinates[l].x;case jt.Y:return this._coordinates[l].y;case jt.Z:return this._coordinates[l].z}return lt.NaN},pr.prototype.getCoordinate=function(){if(1===arguments.length)return this._coordinates[arguments[0]];if(2===arguments.length){var h=arguments[0],m=arguments[1];m.x=this._coordinates[h].x,m.y=this._coordinates[h].y,m.z=this._coordinates[h].z}},pr.prototype.getCoordinateCopy=function(l){return new B(this._coordinates[l])},pr.prototype.getDimension=function(){return this._dimension},pr.prototype.getX=function(l){return this._coordinates[l].x},pr.prototype.clone=function(){for(var l=new Array(this.size()).fill(null),h=0;h<this._coordinates.length;h++)l[h]=this._coordinates[h].clone();return new pr(l,this._dimension)},pr.prototype.expandEnvelope=function(l){for(var h=0;h<this._coordinates.length;h++)l.expandToInclude(this._coordinates[h]);return l},pr.prototype.copy=function(){for(var l=new Array(this.size()).fill(null),h=0;h<this._coordinates.length;h++)l[h]=this._coordinates[h].copy();return new pr(l,this._dimension)},pr.prototype.toString=function(){if(this._coordinates.length>0){var l=new vt(17*this._coordinates.length);l.append("("),l.append(this._coordinates[0]);for(var h=1;h<this._coordinates.length;h++)l.append(", "),l.append(this._coordinates[h]);return l.append(")"),l.toString()}return"()"},pr.prototype.getY=function(l){return this._coordinates[l].y},pr.prototype.toCoordinateArray=function(){return this._coordinates},pr.prototype.interfaces_=function(){return[jt,$]},pr.prototype.getClass=function(){return pr},fu.serialVersionUID.get=function(){return-0xcb44a778db18e00},Object.defineProperties(pr,fu);var Xs=function(){},Ga={serialVersionUID:{configurable:!0},instanceObject:{configurable:!0}};Xs.prototype.readResolve=function(){return Xs.instance()},Xs.prototype.create=function(){if(1===arguments.length){if(arguments[0]instanceof Array)return new pr(arguments[0]);if(O(arguments[0],jt))return new pr(arguments[0])}else if(2===arguments.length){var m=arguments[0],_=arguments[1];return _>3&&(_=3),_<2?new pr(m):new pr(m,_)}},Xs.prototype.interfaces_=function(){return[at,$]},Xs.prototype.getClass=function(){return Xs},Xs.instance=function(){return Xs.instanceObject},Ga.serialVersionUID.get=function(){return-0x38e49fa6cf6f2e00},Ga.instanceObject.get=function(){return new Xs},Object.defineProperties(Xs,Ga);var ss=function(l){function h(){l.call(this),this.map_=new Map}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.get=function(m){return this.map_.get(m)||null},h.prototype.put=function(m,_){return this.map_.set(m,_),_},h.prototype.values=function(){for(var m=new ue,_=this.map_.values(),C=_.next();!C.done;)m.add(C.value),C=_.next();return m},h.prototype.entrySet=function(){var m=new Jr;return this.map_.entries().forEach(function(_){return m.add(_)}),m},h.prototype.size=function(){return this.map_.size()},h}(vn),An=function l(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=l.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof qn){var h=arguments[0];this._modelType=h,h===l.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var m=arguments[0];this._modelType=l.FIXED,this.setScale(m)}else if(arguments[0]instanceof l){var _=arguments[0];this._modelType=_._modelType,this._scale=_._scale}},jr={serialVersionUID:{configurable:!0},maximumPreciseValue:{configurable:!0}};An.prototype.equals=function(l){return l instanceof An&&this._modelType===l._modelType&&this._scale===l._scale},An.prototype.compareTo=function(l){var h=l,m=this.getMaximumSignificantDigits(),_=h.getMaximumSignificantDigits();return new xt(m).compareTo(new xt(_))},An.prototype.getScale=function(){return this._scale},An.prototype.isFloating=function(){return this._modelType===An.FLOATING||this._modelType===An.FLOATING_SINGLE},An.prototype.getType=function(){return this._modelType},An.prototype.toString=function(){var l="UNKNOWN";return this._modelType===An.FLOATING?l="Floating":this._modelType===An.FLOATING_SINGLE?l="Floating-Single":this._modelType===An.FIXED&&(l="Fixed (Scale="+this.getScale()+")"),l},An.prototype.makePrecise=function(){if("number"==typeof arguments[0]){var l=arguments[0];return lt.isNaN(l)||this._modelType===An.FLOATING_SINGLE?l:this._modelType===An.FIXED?Math.round(l*this._scale)/this._scale:l}if(arguments[0]instanceof B){var h=arguments[0];if(this._modelType===An.FLOATING)return null;h.x=this.makePrecise(h.x),h.y=this.makePrecise(h.y)}},An.prototype.getMaximumSignificantDigits=function(){var l=16;return this._modelType===An.FLOATING?l=16:this._modelType===An.FLOATING_SINGLE?l=6:this._modelType===An.FIXED&&(l=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),l},An.prototype.setScale=function(l){this._scale=Math.abs(l)},An.prototype.interfaces_=function(){return[$,Q]},An.prototype.getClass=function(){return An},An.mostPrecise=function(l,h){return l.compareTo(h)>=0?l:h},jr.serialVersionUID.get=function(){return 0x6bee6404e9a25c00},jr.maximumPreciseValue.get=function(){return 9007199254740992},Object.defineProperties(An,jr);var qn=function l(h){this._name=h||null,l.nameToTypeMap.put(h,this)},ga={serialVersionUID:{configurable:!0},nameToTypeMap:{configurable:!0}};qn.prototype.readResolve=function(){return qn.nameToTypeMap.get(this._name)},qn.prototype.toString=function(){return this._name},qn.prototype.interfaces_=function(){return[$]},qn.prototype.getClass=function(){return qn},ga.serialVersionUID.get=function(){return-552860263173159e4},ga.nameToTypeMap.get=function(){return new ss},Object.defineProperties(qn,ga),An.Type=qn,An.FIXED=new qn("FIXED"),An.FLOATING=new qn("FLOATING"),An.FLOATING_SINGLE=new qn("FLOATING SINGLE");var nr=function l(){this._precisionModel=new An,this._SRID=0,this._coordinateSequenceFactory=l.getDefaultCoordinateSequenceFactory(),0===arguments.length||(1===arguments.length?O(arguments[0],at)?this._coordinateSequenceFactory=arguments[0]:arguments[0]instanceof An&&(this._precisionModel=arguments[0]):2===arguments.length?(this._precisionModel=arguments[0],this._SRID=arguments[1]):3===arguments.length&&(this._precisionModel=arguments[0],this._SRID=arguments[1],this._coordinateSequenceFactory=arguments[2]))},bo={serialVersionUID:{configurable:!0}};nr.prototype.toGeometry=function(l){return l.isNull()?this.createPoint(null):l.getMinX()===l.getMaxX()&&l.getMinY()===l.getMaxY()?this.createPoint(new B(l.getMinX(),l.getMinY())):l.getMinX()===l.getMaxX()||l.getMinY()===l.getMaxY()?this.createLineString([new B(l.getMinX(),l.getMinY()),new B(l.getMaxX(),l.getMaxY())]):this.createPolygon(this.createLinearRing([new B(l.getMinX(),l.getMinY()),new B(l.getMinX(),l.getMaxY()),new B(l.getMaxX(),l.getMaxY()),new B(l.getMaxX(),l.getMinY()),new B(l.getMinX(),l.getMinY())]),null)},nr.prototype.createLineString=function(l){return l?l instanceof Array?new Vr(this.getCoordinateSequenceFactory().create(l),this):O(l,jt)?new Vr(l,this):void 0:new Vr(this.getCoordinateSequenceFactory().create([]),this)},nr.prototype.createMultiLineString=function(){return 0===arguments.length?new js(null,this):1===arguments.length?new js(arguments[0],this):void 0},nr.prototype.buildGeometry=function(l){for(var h=null,m=!1,_=!1,C=l.iterator();C.hasNext();){var F=C.next(),rt=F.getClass();null===h&&(h=rt),rt!==h&&(m=!0),F.isGeometryCollectionOrDerived()&&(_=!0)}if(null===h)return this.createGeometryCollection();if(m||_)return this.createGeometryCollection(nr.toGeometryArray(l));var Dt=l.iterator().next();if(l.size()>1){if(Dt instanceof rs)return this.createMultiPolygon(nr.toPolygonArray(l));if(Dt instanceof Vr)return this.createMultiLineString(nr.toLineStringArray(l));if(Dt instanceof Ls)return this.createMultiPoint(nr.toPointArray(l));Nn.shouldNeverReachHere("Unhandled class: "+Dt.getClass().getName())}return Dt},nr.prototype.createMultiPointFromCoords=function(l){return this.createMultiPoint(null!==l?this.getCoordinateSequenceFactory().create(l):null)},nr.prototype.createPoint=function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof B){var l=arguments[0];return this.createPoint(null!==l?this.getCoordinateSequenceFactory().create([l]):null)}if(O(arguments[0],jt))return new Ls(arguments[0],this)}},nr.prototype.getCoordinateSequenceFactory=function(){return this._coordinateSequenceFactory},nr.prototype.createPolygon=function(){if(0===arguments.length)return new rs(null,null,this);if(1===arguments.length){if(O(arguments[0],jt))return this.createPolygon(this.createLinearRing(arguments[0]));if(arguments[0]instanceof Array)return this.createPolygon(this.createLinearRing(arguments[0]));if(arguments[0]instanceof eo)return this.createPolygon(arguments[0],null)}else if(2===arguments.length)return new rs(arguments[0],arguments[1],this)},nr.prototype.getSRID=function(){return this._SRID},nr.prototype.createGeometryCollection=function(){return 0===arguments.length?new zr(null,this):1===arguments.length?new zr(arguments[0],this):void 0},nr.prototype.createGeometry=function(l){return new ys(this).edit(l,{edit:function(){if(2===arguments.length)return this._coordinateSequenceFactory.create(arguments[0])}})},nr.prototype.getPrecisionModel=function(){return this._precisionModel},nr.prototype.createLinearRing=function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var l=arguments[0];return this.createLinearRing(null!==l?this.getCoordinateSequenceFactory().create(l):null)}if(O(arguments[0],jt))return new eo(arguments[0],this)}},nr.prototype.createMultiPolygon=function(){return 0===arguments.length?new wo(null,this):1===arguments.length?new wo(arguments[0],this):void 0},nr.prototype.createMultiPoint=function(){if(0===arguments.length)return new Oa(null,this);if(1===arguments.length){if(arguments[0]instanceof Array)return new Oa(arguments[0],this);if(arguments[0]instanceof Array){var h=arguments[0];return this.createMultiPoint(null!==h?this.getCoordinateSequenceFactory().create(h):null)}if(O(arguments[0],jt)){var m=arguments[0];if(null===m)return this.createMultiPoint(new Array(0).fill(null));for(var _=new Array(m.size()).fill(null),C=0;C<m.size();C++){var F=this.getCoordinateSequenceFactory().create(1,m.getDimension());ti.copy(m,C,F,0,1),_[C]=this.createPoint(F)}return this.createMultiPoint(_)}}},nr.prototype.interfaces_=function(){return[$]},nr.prototype.getClass=function(){return nr},nr.toMultiPolygonArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},nr.toGeometryArray=function(l){if(null===l)return null;var h=new Array(l.size()).fill(null);return l.toArray(h)},nr.getDefaultCoordinateSequenceFactory=function(){return Xs.instance()},nr.toMultiLineStringArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},nr.toLineStringArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},nr.toMultiPointArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},nr.toLinearRingArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},nr.toPointArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},nr.toPolygonArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},nr.createPointFromInternalCoord=function(l,h){return h.getPrecisionModel().makePrecise(l),h.getFactory().createPoint(l)},bo.serialVersionUID.get=function(){return-0x5ea75f2051eeb400},Object.defineProperties(nr,bo);var Yu=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"],ya=function(l){this.geometryFactory=l||new nr};ya.prototype.read=function(l){var h,m=(h="string"==typeof l?JSON.parse(l):l).type;if(!Xn[m])throw new Error("Unknown GeoJSON type: "+h.type);return-1!==Yu.indexOf(m)?Xn[m].apply(this,[h.coordinates]):Xn[m].apply(this,"GeometryCollection"===m?[h.geometries]:[h])},ya.prototype.write=function(l){var h=l.getGeometryType();if(!Cs[h])throw new Error("Geometry is not supported");return Cs[h].apply(this,[l])};var Xn={Feature:function(l){var h={};for(var m in l)h[m]=l[m];if(l.geometry){if(!Xn[l.geometry.type])throw new Error("Unknown GeoJSON type: "+l.type);h.geometry=this.read(l.geometry)}return l.bbox&&(h.bbox=Xn.bbox.apply(this,[l.bbox])),h},FeatureCollection:function(l){var h={};if(l.features){h.features=[];for(var m=0;m<l.features.length;++m)h.features.push(this.read(l.features[m]))}return l.bbox&&(h.bbox=this.parse.bbox.apply(this,[l.bbox])),h},coordinates:function(l){for(var h=[],m=0;m<l.length;++m){var _=l[m];h.push(new B(_[0],_[1]))}return h},bbox:function(l){return this.geometryFactory.createLinearRing([new B(l[0],l[1]),new B(l[2],l[1]),new B(l[2],l[3]),new B(l[0],l[3]),new B(l[0],l[1])])},Point:function(l){var h=new B(l[0],l[1]);return this.geometryFactory.createPoint(h)},MultiPoint:function(l){for(var h=[],m=0;m<l.length;++m)h.push(Xn.Point.apply(this,[l[m]]));return this.geometryFactory.createMultiPoint(h)},LineString:function(l){var h=Xn.coordinates.apply(this,[l]);return this.geometryFactory.createLineString(h)},MultiLineString:function(l){for(var h=[],m=0;m<l.length;++m)h.push(Xn.LineString.apply(this,[l[m]]));return this.geometryFactory.createMultiLineString(h)},Polygon:function(l){for(var h=Xn.coordinates.apply(this,[l[0]]),m=this.geometryFactory.createLinearRing(h),_=[],C=1;C<l.length;++C){var rt=Xn.coordinates.apply(this,[l[C]]),Dt=this.geometryFactory.createLinearRing(rt);_.push(Dt)}return this.geometryFactory.createPolygon(m,_)},MultiPolygon:function(l){for(var h=[],m=0;m<l.length;++m)h.push(Xn.Polygon.apply(this,[l[m]]));return this.geometryFactory.createMultiPolygon(h)},GeometryCollection:function(l){for(var h=[],m=0;m<l.length;++m)h.push(this.read(l[m]));return this.geometryFactory.createGeometryCollection(h)}},Cs={coordinate:function(l){return[l.x,l.y]},Point:function(l){return{type:"Point",coordinates:Cs.coordinate.apply(this,[l.getCoordinate()])}},MultiPoint:function(l){for(var h=[],m=0;m<l._geometries.length;++m){var C=Cs.Point.apply(this,[l._geometries[m]]);h.push(C.coordinates)}return{type:"MultiPoint",coordinates:h}},LineString:function(l){for(var h=[],m=l.getCoordinates(),_=0;_<m.length;++_)h.push(Cs.coordinate.apply(this,[m[_]]));return{type:"LineString",coordinates:h}},MultiLineString:function(l){for(var h=[],m=0;m<l._geometries.length;++m){var C=Cs.LineString.apply(this,[l._geometries[m]]);h.push(C.coordinates)}return{type:"MultiLineString",coordinates:h}},Polygon:function(l){var h=[],m=Cs.LineString.apply(this,[l._shell]);h.push(m.coordinates);for(var _=0;_<l._holes.length;++_){var F=Cs.LineString.apply(this,[l._holes[_]]);h.push(F.coordinates)}return{type:"Polygon",coordinates:h}},MultiPolygon:function(l){for(var h=[],m=0;m<l._geometries.length;++m){var C=Cs.Polygon.apply(this,[l._geometries[m]]);h.push(C.coordinates)}return{type:"MultiPolygon",coordinates:h}},GeometryCollection:function(l){for(var h=[],m=0;m<l._geometries.length;++m){var _=l._geometries[m],C=_.getGeometryType();h.push(Cs[C].apply(this,[_]))}return{type:"GeometryCollection",geometries:h}}},Yi=function(l){this.geometryFactory=l||new nr,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new ya(this.geometryFactory)};Yi.prototype.read=function(l){var h=this.parser.read(l);return this.precisionModel.getType()===An.FIXED&&this.reducePrecision(h),h},Yi.prototype.reducePrecision=function(l){var h,m;if(l.coordinate)this.precisionModel.makePrecise(l.coordinate);else if(l.points)for(h=0,m=l.points.length;h<m;h++)this.precisionModel.makePrecise(l.points[h]);else if(l.geometries)for(h=0,m=l.geometries.length;h<m;h++)this.reducePrecision(l.geometries[h])};var La=function(){this.parser=new ya(this.geometryFactory)};La.prototype.write=function(l){return this.parser.write(l)};var an=function(){},ei={ON:{configurable:!0},LEFT:{configurable:!0},RIGHT:{configurable:!0}};an.prototype.interfaces_=function(){return[]},an.prototype.getClass=function(){return an},an.opposite=function(l){return l===an.LEFT?an.RIGHT:l===an.RIGHT?an.LEFT:l},ei.ON.get=function(){return 0},ei.LEFT.get=function(){return 1},ei.RIGHT.get=function(){return 2},Object.defineProperties(an,ei),(K.prototype=new Error).name="EmptyStackException",(st.prototype=new En).add=function(l){return this.array_.push(l),!0},st.prototype.get=function(l){if(l<0||l>=this.size())throw new Error;return this.array_[l]},st.prototype.push=function(l){return this.array_.push(l),l},st.prototype.pop=function(l){if(0===this.array_.length)throw new K;return this.array_.pop()},st.prototype.peek=function(){if(0===this.array_.length)throw new K;return this.array_[this.array_.length-1]},st.prototype.empty=function(){return 0===this.array_.length},st.prototype.isEmpty=function(){return this.empty()},st.prototype.search=function(l){return this.array_.indexOf(l)},st.prototype.size=function(){return this.array_.length},st.prototype.toArray=function(){for(var l=[],h=0,m=this.array_.length;h<m;h++)l.push(this.array_[h]);return l};var Fn=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null};Fn.prototype.getCoordinate=function(){return this._minCoord},Fn.prototype.getRightmostSide=function(l,h){var m=this.getRightmostSideOfSegment(l,h);return m<0&&(m=this.getRightmostSideOfSegment(l,h-1)),m<0&&(this._minCoord=null,this.checkForRightmostCoordinate(l)),m},Fn.prototype.findRightmostEdgeAtVertex=function(){var l=this._minDe.getEdge().getCoordinates();Nn.isTrue(this._minIndex>0&&this._minIndex<l.length,"rightmost point expected to be interior vertex of edge");var h=l[this._minIndex-1],m=l[this._minIndex+1],_=yn.computeOrientation(this._minCoord,m,h),C=!1;(h.y<this._minCoord.y&&m.y<this._minCoord.y&&_===yn.COUNTERCLOCKWISE||h.y>this._minCoord.y&&m.y>this._minCoord.y&&_===yn.CLOCKWISE)&&(C=!0),C&&(this._minIndex=this._minIndex-1)},Fn.prototype.getRightmostSideOfSegment=function(l,h){var m=l.getEdge().getCoordinates();if(h<0||h+1>=m.length||m[h].y===m[h+1].y)return-1;var _=an.LEFT;return m[h].y<m[h+1].y&&(_=an.RIGHT),_},Fn.prototype.getEdge=function(){return this._orientedDe},Fn.prototype.checkForRightmostCoordinate=function(l){for(var h=l.getEdge().getCoordinates(),m=0;m<h.length-1;m++)(null===this._minCoord||h[m].x>this._minCoord.x)&&(this._minDe=l,this._minIndex=m,this._minCoord=h[m])},Fn.prototype.findRightmostEdgeAtNode=function(){var l=this._minDe.getNode().getEdges();this._minDe=l.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)},Fn.prototype.findEdge=function(l){for(var h=l.iterator();h.hasNext();){var m=h.next();m.isForward()&&this.checkForRightmostCoordinate(m)}Nn.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===an.LEFT&&(this._orientedDe=this._minDe.getSym())},Fn.prototype.interfaces_=function(){return[]},Fn.prototype.getClass=function(){return Fn};var Ds=function(l){function h(m,_){l.call(this,h.msgWithCoord(m,_)),this.pt=_?new B(_):null,this.name="TopologyException"}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.getCoordinate=function(){return this.pt},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.msgWithCoord=function(m,_){return _?m:m+" [ "+_+" ]"},h}(Gn),Io=function(){this.array_=[]};Io.prototype.addLast=function(l){this.array_.push(l)},Io.prototype.removeFirst=function(){return this.array_.shift()},Io.prototype.isEmpty=function(){return 0===this.array_.length};var ks=function(){this._finder=null,this._dirEdgeList=new ue,this._nodes=new ue,this._rightMostCoord=null,this._env=null,this._finder=new Fn};ks.prototype.clearVisitedEdges=function(){for(var l=this._dirEdgeList.iterator();l.hasNext();)l.next().setVisited(!1)},ks.prototype.getRightmostCoordinate=function(){return this._rightMostCoord},ks.prototype.computeNodeDepth=function(l){for(var h=null,m=l.getEdges().iterator();m.hasNext();){var _=m.next();if(_.isVisited()||_.getSym().isVisited()){h=_;break}}if(null===h)throw new Ds("unable to find edge to compute depths at "+l.getCoordinate());l.getEdges().computeDepths(h);for(var C=l.getEdges().iterator();C.hasNext();){var F=C.next();F.setVisited(!0),this.copySymDepths(F)}},ks.prototype.computeDepth=function(l){this.clearVisitedEdges();var h=this._finder.getEdge();h.setEdgeDepths(an.RIGHT,l),this.copySymDepths(h),this.computeDepths(h)},ks.prototype.create=function(l){this.addReachable(l),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()},ks.prototype.findResultEdges=function(){for(var l=this._dirEdgeList.iterator();l.hasNext();){var h=l.next();h.getDepth(an.RIGHT)>=1&&h.getDepth(an.LEFT)<=0&&!h.isInteriorAreaEdge()&&h.setInResult(!0)}},ks.prototype.computeDepths=function(l){var h=new Jr,m=new Io,_=l.getNode();for(m.addLast(_),h.add(_),l.setVisited(!0);!m.isEmpty();){var C=m.removeFirst();h.add(C),this.computeNodeDepth(C);for(var F=C.getEdges().iterator();F.hasNext();){var rt=F.next().getSym();if(!rt.isVisited()){var Dt=rt.getNode();h.contains(Dt)||(m.addLast(Dt),h.add(Dt))}}}},ks.prototype.compareTo=function(l){return this._rightMostCoord.x<l._rightMostCoord.x?-1:this._rightMostCoord.x>l._rightMostCoord.x?1:0},ks.prototype.getEnvelope=function(){if(null===this._env){for(var l=new De,h=this._dirEdgeList.iterator();h.hasNext();)for(var m=h.next().getEdge().getCoordinates(),_=0;_<m.length-1;_++)l.expandToInclude(m[_]);this._env=l}return this._env},ks.prototype.addReachable=function(l){var h=new st;for(h.add(l);!h.empty();){var m=h.pop();this.add(m,h)}},ks.prototype.copySymDepths=function(l){var h=l.getSym();h.setDepth(an.LEFT,l.getDepth(an.RIGHT)),h.setDepth(an.RIGHT,l.getDepth(an.LEFT))},ks.prototype.add=function(l,h){l.setVisited(!0),this._nodes.add(l);for(var m=l.getEdges().iterator();m.hasNext();){var _=m.next();this._dirEdgeList.add(_);var C=_.getSym().getNode();C.isVisited()||h.push(C)}},ks.prototype.getNodes=function(){return this._nodes},ks.prototype.getDirectedEdges=function(){return this._dirEdgeList},ks.prototype.interfaces_=function(){return[Q]},ks.prototype.getClass=function(){return ks};var Ur=function l(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array)this.init(arguments[0].length);else if(Number.isInteger(arguments[0])){var m=arguments[0];this.init(1),this.location[an.ON]=m}else if(arguments[0]instanceof l){var _=arguments[0];if(this.init(_.location.length),null!==_)for(var C=0;C<this.location.length;C++)this.location[C]=_.location[C]}}else if(3===arguments.length){var F=arguments[0],rt=arguments[1],Dt=arguments[2];this.init(3),this.location[an.ON]=F,this.location[an.LEFT]=rt,this.location[an.RIGHT]=Dt}};Ur.prototype.setAllLocations=function(l){for(var h=0;h<this.location.length;h++)this.location[h]=l},Ur.prototype.isNull=function(){for(var l=0;l<this.location.length;l++)if(this.location[l]!==nt.NONE)return!1;return!0},Ur.prototype.setAllLocationsIfNull=function(l){for(var h=0;h<this.location.length;h++)this.location[h]===nt.NONE&&(this.location[h]=l)},Ur.prototype.isLine=function(){return 1===this.location.length},Ur.prototype.merge=function(l){if(l.location.length>this.location.length){var h=new Array(3).fill(null);h[an.ON]=this.location[an.ON],h[an.LEFT]=nt.NONE,h[an.RIGHT]=nt.NONE,this.location=h}for(var m=0;m<this.location.length;m++)this.location[m]===nt.NONE&&m<l.location.length&&(this.location[m]=l.location[m])},Ur.prototype.getLocations=function(){return this.location},Ur.prototype.flip=function(){if(this.location.length<=1)return null;var l=this.location[an.LEFT];this.location[an.LEFT]=this.location[an.RIGHT],this.location[an.RIGHT]=l},Ur.prototype.toString=function(){var l=new vt;return this.location.length>1&&l.append(nt.toLocationSymbol(this.location[an.LEFT])),l.append(nt.toLocationSymbol(this.location[an.ON])),this.location.length>1&&l.append(nt.toLocationSymbol(this.location[an.RIGHT])),l.toString()},Ur.prototype.setLocations=function(l,h,m){this.location[an.ON]=l,this.location[an.LEFT]=h,this.location[an.RIGHT]=m},Ur.prototype.get=function(l){return l<this.location.length?this.location[l]:nt.NONE},Ur.prototype.isArea=function(){return this.location.length>1},Ur.prototype.isAnyNull=function(){for(var l=0;l<this.location.length;l++)if(this.location[l]===nt.NONE)return!0;return!1},Ur.prototype.setLocation=function(){1===arguments.length?this.setLocation(an.ON,arguments[0]):2===arguments.length&&(this.location[arguments[0]]=arguments[1])},Ur.prototype.init=function(l){this.location=new Array(l).fill(null),this.setAllLocations(nt.NONE)},Ur.prototype.isEqualOnSide=function(l,h){return this.location[h]===l.location[h]},Ur.prototype.allPositionsEqual=function(l){for(var h=0;h<this.location.length;h++)if(this.location[h]!==l)return!1;return!0},Ur.prototype.interfaces_=function(){return[]},Ur.prototype.getClass=function(){return Ur};var We=function l(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var h=arguments[0];this.elt[0]=new Ur(h),this.elt[1]=new Ur(h)}else if(arguments[0]instanceof l){var m=arguments[0];this.elt[0]=new Ur(m.elt[0]),this.elt[1]=new Ur(m.elt[1])}}else if(2===arguments.length){var _=arguments[0],C=arguments[1];this.elt[0]=new Ur(nt.NONE),this.elt[1]=new Ur(nt.NONE),this.elt[_].setLocation(C)}else if(3===arguments.length){var F=arguments[0],rt=arguments[1],Dt=arguments[2];this.elt[0]=new Ur(F,rt,Dt),this.elt[1]=new Ur(F,rt,Dt)}else if(4===arguments.length){var Qt=arguments[0],fe=arguments[1],ke=arguments[2],Ge=arguments[3];this.elt[0]=new Ur(nt.NONE,nt.NONE,nt.NONE),this.elt[1]=new Ur(nt.NONE,nt.NONE,nt.NONE),this.elt[Qt].setLocations(fe,ke,Ge)}};We.prototype.getGeometryCount=function(){var l=0;return this.elt[0].isNull()||l++,this.elt[1].isNull()||l++,l},We.prototype.setAllLocations=function(l,h){this.elt[l].setAllLocations(h)},We.prototype.isNull=function(l){return this.elt[l].isNull()},We.prototype.setAllLocationsIfNull=function(){if(1===arguments.length){var l=arguments[0];this.setAllLocationsIfNull(0,l),this.setAllLocationsIfNull(1,l)}else 2===arguments.length&&this.elt[arguments[0]].setAllLocationsIfNull(arguments[1])},We.prototype.isLine=function(l){return this.elt[l].isLine()},We.prototype.merge=function(l){for(var h=0;h<2;h++)null===this.elt[h]&&null!==l.elt[h]?this.elt[h]=new Ur(l.elt[h]):this.elt[h].merge(l.elt[h])},We.prototype.flip=function(){this.elt[0].flip(),this.elt[1].flip()},We.prototype.getLocation=function(){return 1===arguments.length?this.elt[arguments[0]].get(an.ON):2===arguments.length?this.elt[arguments[0]].get(arguments[1]):void 0},We.prototype.toString=function(){var l=new vt;return null!==this.elt[0]&&(l.append("A:"),l.append(this.elt[0].toString())),null!==this.elt[1]&&(l.append(" B:"),l.append(this.elt[1].toString())),l.toString()},We.prototype.isArea=function(){return 0===arguments.length?this.elt[0].isArea()||this.elt[1].isArea():1===arguments.length?this.elt[arguments[0]].isArea():void 0},We.prototype.isAnyNull=function(l){return this.elt[l].isAnyNull()},We.prototype.setLocation=function(){2===arguments.length?this.elt[arguments[0]].setLocation(an.ON,arguments[1]):3===arguments.length&&this.elt[arguments[0]].setLocation(arguments[1],arguments[2])},We.prototype.isEqualOnSide=function(l,h){return this.elt[0].isEqualOnSide(l.elt[0],h)&&this.elt[1].isEqualOnSide(l.elt[1],h)},We.prototype.allPositionsEqual=function(l,h){return this.elt[l].allPositionsEqual(h)},We.prototype.toLine=function(l){this.elt[l].isArea()&&(this.elt[l]=new Ur(this.elt[l].location[0]))},We.prototype.interfaces_=function(){return[]},We.prototype.getClass=function(){return We},We.toLineLabel=function(l){for(var h=new We(nt.NONE),m=0;m<2;m++)h.setLocation(m,l.getLocation(m));return h};var Kr=function(){this._startDe=null,this._maxNodeDegree=-1,this._edges=new ue,this._pts=new ue,this._label=new We(nt.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new ue,this._geometryFactory=null;var l=arguments[0];this._geometryFactory=arguments[1],this.computePoints(l),this.computeRing()};Kr.prototype.computeRing=function(){if(null!==this._ring)return null;for(var l=new Array(this._pts.size()).fill(null),h=0;h<this._pts.size();h++)l[h]=this._pts.get(h);this._ring=this._geometryFactory.createLinearRing(l),this._isHole=yn.isCCW(this._ring.getCoordinates())},Kr.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},Kr.prototype.computePoints=function(l){this._startDe=l;var h=l,m=!0;do{if(null===h)throw new Ds("Found null DirectedEdge");if(h.getEdgeRing()===this)throw new Ds("Directed Edge visited twice during ring-building at "+h.getCoordinate());this._edges.add(h);var _=h.getLabel();Nn.isTrue(_.isArea()),this.mergeLabel(_),this.addPoints(h.getEdge(),h.isForward(),m),m=!1,this.setEdgeRing(h,this),h=this.getNext(h)}while(h!==this._startDe)},Kr.prototype.getLinearRing=function(){return this._ring},Kr.prototype.getCoordinate=function(l){return this._pts.get(l)},Kr.prototype.computeMaxNodeDegree=function(){this._maxNodeDegree=0;var l=this._startDe;do{var h=l.getNode().getEdges().getOutgoingDegree(this);h>this._maxNodeDegree&&(this._maxNodeDegree=h),l=this.getNext(l)}while(l!==this._startDe);this._maxNodeDegree*=2},Kr.prototype.addPoints=function(l,h,m){var _=l.getCoordinates();if(h){var C=1;m&&(C=0);for(var F=C;F<_.length;F++)this._pts.add(_[F])}else{var rt=_.length-2;m&&(rt=_.length-1);for(var Dt=rt;Dt>=0;Dt--)this._pts.add(_[Dt])}},Kr.prototype.isHole=function(){return this._isHole},Kr.prototype.setInResult=function(){var l=this._startDe;do{l.getEdge().setInResult(!0),l=l.getNext()}while(l!==this._startDe)},Kr.prototype.containsPoint=function(l){var h=this.getLinearRing();if(!h.getEnvelopeInternal().contains(l)||!yn.isPointInRing(l,h.getCoordinates()))return!1;for(var m=this._holes.iterator();m.hasNext();)if(m.next().containsPoint(l))return!1;return!0},Kr.prototype.addHole=function(l){this._holes.add(l)},Kr.prototype.isShell=function(){return null===this._shell},Kr.prototype.getLabel=function(){return this._label},Kr.prototype.getEdges=function(){return this._edges},Kr.prototype.getMaxNodeDegree=function(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree},Kr.prototype.getShell=function(){return this._shell},Kr.prototype.mergeLabel=function(){if(1===arguments.length){var l=arguments[0];this.mergeLabel(l,0),this.mergeLabel(l,1)}else if(2===arguments.length){var m=arguments[1],_=arguments[0].getLocation(m,an.RIGHT);if(_===nt.NONE)return null;if(this._label.getLocation(m)===nt.NONE)return this._label.setLocation(m,_),null}},Kr.prototype.setShell=function(l){this._shell=l,null!==l&&l.addHole(this)},Kr.prototype.toPolygon=function(l){for(var h=new Array(this._holes.size()).fill(null),m=0;m<this._holes.size();m++)h[m]=this._holes.get(m).getLinearRing();return l.createPolygon(this.getLinearRing(),h)},Kr.prototype.interfaces_=function(){return[]},Kr.prototype.getClass=function(){return Kr};var mr=function(l){function h(){l.call(this,arguments[0],arguments[1])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.setEdgeRing=function(m,_){m.setMinEdgeRing(_)},h.prototype.getNext=function(m){return m.getNextMin()},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Kr),ai=function(l){function h(){l.call(this,arguments[0],arguments[1])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.buildMinimalRings=function(){var m=new ue,_=this._startDe;do{if(null===_.getMinEdgeRing()){var C=new mr(_,this._geometryFactory);m.add(C)}_=_.getNext()}while(_!==this._startDe);return m},h.prototype.setEdgeRing=function(m,_){m.setEdgeRing(_)},h.prototype.linkDirectedEdgesForMinimalEdgeRings=function(){var m=this._startDe;do{m.getNode().getEdges().linkMinimalDirectedEdges(this),m=m.getNext()}while(m!==this._startDe)},h.prototype.getNext=function(m){return m.getNext()},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Kr),Kn=function(){this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0!==arguments.length&&1===arguments.length&&(this._label=arguments[0])};Kn.prototype.setVisited=function(l){this._isVisited=l},Kn.prototype.setInResult=function(l){this._isInResult=l},Kn.prototype.isCovered=function(){return this._isCovered},Kn.prototype.isCoveredSet=function(){return this._isCoveredSet},Kn.prototype.setLabel=function(l){this._label=l},Kn.prototype.getLabel=function(){return this._label},Kn.prototype.setCovered=function(l){this._isCovered=l,this._isCoveredSet=!0},Kn.prototype.updateIM=function(l){Nn.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(l)},Kn.prototype.isInResult=function(){return this._isInResult},Kn.prototype.isVisited=function(){return this._isVisited},Kn.prototype.interfaces_=function(){return[]},Kn.prototype.getClass=function(){return Kn};var Pr=function(l){function h(){l.call(this),this._coord=null,this._edges=null;var _=arguments[1];this._coord=arguments[0],this._edges=_,this._label=new We(0,nt.NONE)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.isIncidentEdgeInResult=function(){for(var m=this.getEdges().getEdges().iterator();m.hasNext();)if(m.next().getEdge().isInResult())return!0;return!1},h.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},h.prototype.getCoordinate=function(){return this._coord},h.prototype.print=function(m){m.println("node "+this._coord+" lbl: "+this._label)},h.prototype.computeIM=function(m){},h.prototype.computeMergedLocation=function(m,_){var C=nt.NONE;if(C=this._label.getLocation(_),!m.isNull(_)){var F=m.getLocation(_);C!==nt.BOUNDARY&&(C=F)}return C},h.prototype.setLabel=function(){if(2!==arguments.length)return l.prototype.setLabel.apply(this,arguments);var m=arguments[0],_=arguments[1];null===this._label?this._label=new We(m,_):this._label.setLocation(m,_)},h.prototype.getEdges=function(){return this._edges},h.prototype.mergeLabel=function(){if(arguments[0]instanceof h)this.mergeLabel(arguments[0]._label);else if(arguments[0]instanceof We)for(var _=arguments[0],C=0;C<2;C++){var F=this.computeMergedLocation(_,C);this._label.getLocation(C)===nt.NONE&&this._label.setLocation(C,F)}},h.prototype.add=function(m){this._edges.insert(m),m.setNode(this)},h.prototype.setLabelBoundary=function(m){if(null===this._label)return null;var _=nt.NONE;null!==this._label&&(_=this._label.getLocation(m)),this._label.setLocation(m,_===nt.BOUNDARY?nt.INTERIOR:nt.BOUNDARY)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Kn),br=function(){this.nodeMap=new Z,this.nodeFact=null,this.nodeFact=arguments[0]};br.prototype.find=function(l){return this.nodeMap.get(l)},br.prototype.addNode=function(){if(arguments[0]instanceof B){var l=arguments[0],h=this.nodeMap.get(l);return null===h&&(h=this.nodeFact.createNode(l),this.nodeMap.put(l,h)),h}if(arguments[0]instanceof Pr){var m=arguments[0],_=this.nodeMap.get(m.getCoordinate());return null===_?(this.nodeMap.put(m.getCoordinate(),m),m):(_.mergeLabel(m),_)}},br.prototype.print=function(l){for(var h=this.iterator();h.hasNext();)h.next().print(l)},br.prototype.iterator=function(){return this.nodeMap.values().iterator()},br.prototype.values=function(){return this.nodeMap.values()},br.prototype.getBoundaryNodes=function(l){for(var h=new ue,m=this.iterator();m.hasNext();){var _=m.next();_.getLabel().getLocation(l)===nt.BOUNDARY&&h.add(_)}return h},br.prototype.add=function(l){var h=l.getCoordinate();this.addNode(h).add(l)},br.prototype.interfaces_=function(){return[]},br.prototype.getClass=function(){return br};var Wr=function(){},Ts={NE:{configurable:!0},NW:{configurable:!0},SW:{configurable:!0},SE:{configurable:!0}};Wr.prototype.interfaces_=function(){return[]},Wr.prototype.getClass=function(){return Wr},Wr.isNorthern=function(l){return l===Wr.NE||l===Wr.NW},Wr.isOpposite=function(l,h){return l!==h&&(l-h+4)%4==2},Wr.commonHalfPlane=function(l,h){if(l===h)return l;if((l-h+4)%4==2)return-1;var m=l<h?l:h;return 0===m&&3===(l>h?l:h)?3:m},Wr.isInHalfPlane=function(l,h){return h===Wr.SE?l===Wr.SE||l===Wr.SW:l===h||l===h+1},Wr.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var l=arguments[0],h=arguments[1];if(0===l&&0===h)throw new dt("Cannot compute the quadrant for point ( "+l+", "+h+" )");return l>=0?h>=0?Wr.NE:Wr.SE:h>=0?Wr.NW:Wr.SW}if(arguments[0]instanceof B&&arguments[1]instanceof B){var m=arguments[0],_=arguments[1];if(_.x===m.x&&_.y===m.y)throw new dt("Cannot compute the quadrant for two identical points "+m);return _.x>=m.x?_.y>=m.y?Wr.NE:Wr.SE:_.y>=m.y?Wr.NW:Wr.SW}},Ts.NE.get=function(){return 0},Ts.NW.get=function(){return 1},Ts.SW.get=function(){return 2},Ts.SE.get=function(){return 3},Object.defineProperties(Wr,Ts);var os=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length)this._edge=arguments[0];else if(3===arguments.length){var m=arguments[1],_=arguments[2];this._edge=arguments[0],this.init(m,_),this._label=null}else if(4===arguments.length){var F=arguments[1],rt=arguments[2],Dt=arguments[3];this._edge=arguments[0],this.init(F,rt),this._label=Dt}};os.prototype.compareDirection=function(l){return this._dx===l._dx&&this._dy===l._dy?0:this._quadrant>l._quadrant?1:this._quadrant<l._quadrant?-1:yn.computeOrientation(l._p0,l._p1,this._p1)},os.prototype.getDy=function(){return this._dy},os.prototype.getCoordinate=function(){return this._p0},os.prototype.setNode=function(l){this._node=l},os.prototype.print=function(l){var h=Math.atan2(this._dy,this._dx),m=this.getClass().getName(),_=m.lastIndexOf("."),C=m.substring(_+1);l.print("  "+C+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+h+"   "+this._label)},os.prototype.compareTo=function(l){return this.compareDirection(l)},os.prototype.getDirectedCoordinate=function(){return this._p1},os.prototype.getDx=function(){return this._dx},os.prototype.getLabel=function(){return this._label},os.prototype.getEdge=function(){return this._edge},os.prototype.getQuadrant=function(){return this._quadrant},os.prototype.getNode=function(){return this._node},os.prototype.toString=function(){var l=Math.atan2(this._dy,this._dx),h=this.getClass().getName(),m=h.lastIndexOf(".");return"  "+h.substring(m+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+l+"   "+this._label},os.prototype.computeLabel=function(l){},os.prototype.init=function(l,h){this._p0=l,this._p1=h,this._dx=h.x-l.x,this._dy=h.y-l.y,this._quadrant=Wr.quadrant(this._dx,this._dy),Nn.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")},os.prototype.interfaces_=function(){return[Q]},os.prototype.getClass=function(){return os};var Iu=function(l){function h(){var m=arguments[0],_=arguments[1];if(l.call(this,m),this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999],this._isForward=_,_)this.init(m.getCoordinate(0),m.getCoordinate(1));else{var C=m.getNumPoints()-1;this.init(m.getCoordinate(C),m.getCoordinate(C-1))}this.computeDirectedLabel()}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.getNextMin=function(){return this._nextMin},h.prototype.getDepth=function(m){return this._depth[m]},h.prototype.setVisited=function(m){this._isVisited=m},h.prototype.computeDirectedLabel=function(){this._label=new We(this._edge.getLabel()),this._isForward||this._label.flip()},h.prototype.getNext=function(){return this._next},h.prototype.setDepth=function(m,_){if(-999!==this._depth[m]&&this._depth[m]!==_)throw new Ds("assigned depths do not match",this.getCoordinate());this._depth[m]=_},h.prototype.isInteriorAreaEdge=function(){for(var m=!0,_=0;_<2;_++)this._label.isArea(_)&&this._label.getLocation(_,an.LEFT)===nt.INTERIOR&&this._label.getLocation(_,an.RIGHT)===nt.INTERIOR||(m=!1);return m},h.prototype.setNextMin=function(m){this._nextMin=m},h.prototype.print=function(m){l.prototype.print.call(this,m),m.print(" "+this._depth[an.LEFT]+"/"+this._depth[an.RIGHT]),m.print(" ("+this.getDepthDelta()+")"),this._isInResult&&m.print(" inResult")},h.prototype.setMinEdgeRing=function(m){this._minEdgeRing=m},h.prototype.isLineEdge=function(){var m=this._label.isLine(0)||this._label.isLine(1),_=!this._label.isArea(0)||this._label.allPositionsEqual(0,nt.EXTERIOR),C=!this._label.isArea(1)||this._label.allPositionsEqual(1,nt.EXTERIOR);return m&&_&&C},h.prototype.setEdgeRing=function(m){this._edgeRing=m},h.prototype.getMinEdgeRing=function(){return this._minEdgeRing},h.prototype.getDepthDelta=function(){var m=this._edge.getDepthDelta();return this._isForward||(m=-m),m},h.prototype.setInResult=function(m){this._isInResult=m},h.prototype.getSym=function(){return this._sym},h.prototype.isForward=function(){return this._isForward},h.prototype.getEdge=function(){return this._edge},h.prototype.printEdge=function(m){this.print(m),m.print(" "),this._isForward?this._edge.print(m):this._edge.printReverse(m)},h.prototype.setSym=function(m){this._sym=m},h.prototype.setVisitedEdge=function(m){this.setVisited(m),this._sym.setVisited(m)},h.prototype.setEdgeDepths=function(m,_){var C=this.getEdge().getDepthDelta();this._isForward||(C=-C);var F=1;m===an.LEFT&&(F=-1);var rt=an.opposite(m),Dt=_+C*F;this.setDepth(m,_),this.setDepth(rt,Dt)},h.prototype.getEdgeRing=function(){return this._edgeRing},h.prototype.isInResult=function(){return this._isInResult},h.prototype.setNext=function(m){this._next=m},h.prototype.isVisited=function(){return this._isVisited},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.depthFactor=function(m,_){return m===nt.EXTERIOR&&_===nt.INTERIOR?1:m===nt.INTERIOR&&_===nt.EXTERIOR?-1:0},h}(os),$o=function(){};$o.prototype.createNode=function(l){return new Pr(l,null)},$o.prototype.interfaces_=function(){return[]},$o.prototype.getClass=function(){return $o};var Or=function(){this._edges=new ue,this._nodes=null,this._edgeEndList=new ue,0===arguments.length?this._nodes=new br(new $o):1===arguments.length&&(this._nodes=new br(arguments[0]))};Or.prototype.printEdges=function(l){l.println("Edges:");for(var h=0;h<this._edges.size();h++){l.println("edge "+h+":");var m=this._edges.get(h);m.print(l),m.eiList.print(l)}},Or.prototype.find=function(l){return this._nodes.find(l)},Or.prototype.addNode=function(){return arguments[0]instanceof Pr||arguments[0]instanceof B?this._nodes.addNode(arguments[0]):void 0},Or.prototype.getNodeIterator=function(){return this._nodes.iterator()},Or.prototype.linkResultDirectedEdges=function(){for(var l=this._nodes.iterator();l.hasNext();)l.next().getEdges().linkResultDirectedEdges()},Or.prototype.debugPrintln=function(l){Xe.out.println(l)},Or.prototype.isBoundaryNode=function(l,h){var m=this._nodes.find(h);if(null===m)return!1;var _=m.getLabel();return null!==_&&_.getLocation(l)===nt.BOUNDARY},Or.prototype.linkAllDirectedEdges=function(){for(var l=this._nodes.iterator();l.hasNext();)l.next().getEdges().linkAllDirectedEdges()},Or.prototype.matchInSameDirection=function(l,h,m,_){return!!l.equals(m)&&yn.computeOrientation(l,h,_)===yn.COLLINEAR&&Wr.quadrant(l,h)===Wr.quadrant(m,_)},Or.prototype.getEdgeEnds=function(){return this._edgeEndList},Or.prototype.debugPrint=function(l){Xe.out.print(l)},Or.prototype.getEdgeIterator=function(){return this._edges.iterator()},Or.prototype.findEdgeInSameDirection=function(l,h){for(var m=0;m<this._edges.size();m++){var _=this._edges.get(m),C=_.getCoordinates();if(this.matchInSameDirection(l,h,C[0],C[1])||this.matchInSameDirection(l,h,C[C.length-1],C[C.length-2]))return _}return null},Or.prototype.insertEdge=function(l){this._edges.add(l)},Or.prototype.findEdgeEnd=function(l){for(var h=this.getEdgeEnds().iterator();h.hasNext();){var m=h.next();if(m.getEdge()===l)return m}return null},Or.prototype.addEdges=function(l){for(var h=l.iterator();h.hasNext();){var m=h.next();this._edges.add(m);var _=new Iu(m,!0),C=new Iu(m,!1);_.setSym(C),C.setSym(_),this.add(_),this.add(C)}},Or.prototype.add=function(l){this._nodes.add(l),this._edgeEndList.add(l)},Or.prototype.getNodes=function(){return this._nodes.values()},Or.prototype.findEdge=function(l,h){for(var m=0;m<this._edges.size();m++){var _=this._edges.get(m),C=_.getCoordinates();if(l.equals(C[0])&&h.equals(C[1]))return _}return null},Or.prototype.interfaces_=function(){return[]},Or.prototype.getClass=function(){return Or},Or.linkResultDirectedEdges=function(l){for(var h=l.iterator();h.hasNext();)h.next().getEdges().linkResultDirectedEdges()};var as=function(){this._geometryFactory=null,this._shellList=new ue,this._geometryFactory=arguments[0]};as.prototype.sortShellsAndHoles=function(l,h,m){for(var _=l.iterator();_.hasNext();){var C=_.next();C.isHole()?m.add(C):h.add(C)}},as.prototype.computePolygons=function(l){for(var h=new ue,m=l.iterator();m.hasNext();){var _=m.next().toPolygon(this._geometryFactory);h.add(_)}return h},as.prototype.placeFreeHoles=function(l,h){for(var m=h.iterator();m.hasNext();){var _=m.next();if(null===_.getShell()){var C=this.findEdgeRingContaining(_,l);if(null===C)throw new Ds("unable to assign hole to a shell",_.getCoordinate(0));_.setShell(C)}}},as.prototype.buildMinimalEdgeRings=function(l,h,m){for(var _=new ue,C=l.iterator();C.hasNext();){var F=C.next();if(F.getMaxNodeDegree()>2){F.linkDirectedEdgesForMinimalEdgeRings();var rt=F.buildMinimalRings(),Dt=this.findShell(rt);null!==Dt?(this.placePolygonHoles(Dt,rt),h.add(Dt)):m.addAll(rt)}else _.add(F)}return _},as.prototype.containsPoint=function(l){for(var h=this._shellList.iterator();h.hasNext();)if(h.next().containsPoint(l))return!0;return!1},as.prototype.buildMaximalEdgeRings=function(l){for(var h=new ue,m=l.iterator();m.hasNext();){var _=m.next();if(_.isInResult()&&_.getLabel().isArea()&&null===_.getEdgeRing()){var C=new ai(_,this._geometryFactory);h.add(C),C.setInResult()}}return h},as.prototype.placePolygonHoles=function(l,h){for(var m=h.iterator();m.hasNext();){var _=m.next();_.isHole()&&_.setShell(l)}},as.prototype.getPolygons=function(){return this.computePolygons(this._shellList)},as.prototype.findEdgeRingContaining=function(l,h){for(var m=l.getLinearRing(),_=m.getEnvelopeInternal(),C=m.getCoordinateN(0),F=null,rt=null,Dt=h.iterator();Dt.hasNext();){var Qt=Dt.next(),fe=Qt.getLinearRing(),ke=fe.getEnvelopeInternal();null!==F&&(rt=F.getLinearRing().getEnvelopeInternal());var Ge=!1;ke.contains(_)&&yn.isPointInRing(C,fe.getCoordinates())&&(Ge=!0),Ge&&(null===F||rt.contains(ke))&&(F=Qt)}return F},as.prototype.findShell=function(l){for(var h=0,m=null,_=l.iterator();_.hasNext();){var C=_.next();C.isHole()||(m=C,h++)}return Nn.isTrue(h<=1,"found two shells in MinimalEdgeRing list"),m},as.prototype.add=function(){if(1===arguments.length){var l=arguments[0];this.add(l.getEdgeEnds(),l.getNodes())}else if(2===arguments.length){var h=arguments[0];Or.linkResultDirectedEdges(arguments[1]);var _=this.buildMaximalEdgeRings(h),C=new ue,F=this.buildMinimalEdgeRings(_,this._shellList,C);this.sortShellsAndHoles(F,this._shellList,C),this.placeFreeHoles(this._shellList,C)}},as.prototype.interfaces_=function(){return[]},as.prototype.getClass=function(){return as};var _e=function(){};_e.prototype.getBounds=function(){},_e.prototype.interfaces_=function(){return[]},_e.prototype.getClass=function(){return _e};var z=function(){this._bounds=null,this._item=null;var h=arguments[1];this._bounds=arguments[0],this._item=h};z.prototype.getItem=function(){return this._item},z.prototype.getBounds=function(){return this._bounds},z.prototype.interfaces_=function(){return[_e,$]},z.prototype.getClass=function(){return z};var I=function(){this._size=null,this._items=null,this._size=0,this._items=new ue,this._items.add(null)};I.prototype.poll=function(){if(this.isEmpty())return null;var l=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),l},I.prototype.size=function(){return this._size},I.prototype.reorder=function(l){for(var h=null,m=this._items.get(l);2*l<=this._size&&((h=2*l)!==this._size&&this._items.get(h+1).compareTo(this._items.get(h))<0&&h++,this._items.get(h).compareTo(m)<0);l=h)this._items.set(l,this._items.get(h));this._items.set(l,m)},I.prototype.clear=function(){this._size=0,this._items.clear()},I.prototype.isEmpty=function(){return 0===this._size},I.prototype.add=function(l){this._items.add(null),this._size+=1;var h=this._size;for(this._items.set(0,l);l.compareTo(this._items.get(Math.trunc(h/2)))<0;h/=2)this._items.set(h,this._items.get(Math.trunc(h/2)));this._items.set(h,l)},I.prototype.interfaces_=function(){return[]},I.prototype.getClass=function(){return I};var M=function(){};M.prototype.visitItem=function(l){},M.prototype.interfaces_=function(){return[]},M.prototype.getClass=function(){return M};var tt=function(){};tt.prototype.insert=function(l,h){},tt.prototype.remove=function(l,h){},tt.prototype.query=function(){},tt.prototype.interfaces_=function(){return[]},tt.prototype.getClass=function(){return tt};var wt=function(){this._childBoundables=new ue,this._bounds=null,this._level=null,0!==arguments.length&&1===arguments.length&&(this._level=arguments[0])},At={serialVersionUID:{configurable:!0}};wt.prototype.getLevel=function(){return this._level},wt.prototype.size=function(){return this._childBoundables.size()},wt.prototype.getChildBoundables=function(){return this._childBoundables},wt.prototype.addChildBoundable=function(l){Nn.isTrue(null===this._bounds),this._childBoundables.add(l)},wt.prototype.isEmpty=function(){return this._childBoundables.isEmpty()},wt.prototype.getBounds=function(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds},wt.prototype.interfaces_=function(){return[_e,$]},wt.prototype.getClass=function(){return wt},At.serialVersionUID.get=function(){return 0x5a1e55ec41369800},Object.defineProperties(wt,At);var Yt=function(){};Yt.reverseOrder=function(){return{compare:function(l,h){return h.compareTo(l)}}},Yt.min=function(l){return Yt.sort(l),l.get(0)},Yt.sort=function(l,h){var m=l.toArray();h?Rr.sort(m,h):Rr.sort(m);for(var _=l.iterator(),C=0,F=m.length;C<F;C++)_.next(),_.set(m[C])},Yt.singletonList=function(l){var h=new ue;return h.add(l),h};var kt=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;var h=arguments[1],m=arguments[2];this._boundable1=arguments[0],this._boundable2=h,this._itemDistance=m,this._distance=this.distance()};kt.prototype.expandToQueue=function(l,h){var m=kt.isComposite(this._boundable1),_=kt.isComposite(this._boundable2);if(m&&_)return kt.area(this._boundable1)>kt.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,l,h),null):(this.expand(this._boundable2,this._boundable1,l,h),null);if(m)return this.expand(this._boundable1,this._boundable2,l,h),null;if(_)return this.expand(this._boundable2,this._boundable1,l,h),null;throw new dt("neither boundable is composite")},kt.prototype.isLeaves=function(){return!(kt.isComposite(this._boundable1)||kt.isComposite(this._boundable2))},kt.prototype.compareTo=function(l){return this._distance<l._distance?-1:this._distance>l._distance?1:0},kt.prototype.expand=function(l,h,m,_){for(var C=l.getChildBoundables().iterator();C.hasNext();){var F=C.next(),rt=new kt(F,h,this._itemDistance);rt.getDistance()<_&&m.add(rt)}},kt.prototype.getBoundable=function(l){return 0===l?this._boundable1:this._boundable2},kt.prototype.getDistance=function(){return this._distance},kt.prototype.distance=function(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())},kt.prototype.interfaces_=function(){return[Q]},kt.prototype.getClass=function(){return kt},kt.area=function(l){return l.getBounds().getArea()},kt.isComposite=function(l){return l instanceof wt};var ae=function l(){if(this._root=null,this._built=!1,this._itemBoundables=new ue,this._nodeCapacity=null,0===arguments.length)this._nodeCapacity=l.DEFAULT_NODE_CAPACITY;else if(1===arguments.length){var m=arguments[0];Nn.isTrue(m>1,"Node capacity must be greater than 1"),this._nodeCapacity=m}},nn={IntersectsOp:{configurable:!0},serialVersionUID:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};ae.prototype.getNodeCapacity=function(){return this._nodeCapacity},ae.prototype.lastNode=function(l){return l.get(l.size()-1)},ae.prototype.size=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){for(var l=0,h=arguments[0].getChildBoundables().iterator();h.hasNext();){var m=h.next();m instanceof wt?l+=this.size(m):m instanceof z&&(l+=1)}return l}},ae.prototype.removeItem=function(l,h){for(var m=null,_=l.getChildBoundables().iterator();_.hasNext();){var C=_.next();C instanceof z&&C.getItem()===h&&(m=C)}return null!==m&&(l.getChildBoundables().remove(m),!0)},ae.prototype.itemsTree=function(){if(0===arguments.length){this.build();var l=this.itemsTree(this._root);return null===l?new ue:l}if(1===arguments.length){for(var h=arguments[0],m=new ue,_=h.getChildBoundables().iterator();_.hasNext();){var C=_.next();if(C instanceof wt){var F=this.itemsTree(C);null!==F&&m.add(F)}else C instanceof z?m.add(C.getItem()):Nn.shouldNeverReachHere()}return m.size()<=0?null:m}},ae.prototype.insert=function(l,h){Nn.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new z(l,h))},ae.prototype.boundablesAtLevel=function(){if(1===arguments.length){var l=arguments[0],h=new ue;return this.boundablesAtLevel(l,this._root,h),h}if(3===arguments.length){var m=arguments[0],_=arguments[1],C=arguments[2];if(Nn.isTrue(m>-2),_.getLevel()===m)return C.add(_),null;for(var F=_.getChildBoundables().iterator();F.hasNext();){var rt=F.next();rt instanceof wt?this.boundablesAtLevel(m,rt,C):(Nn.isTrue(rt instanceof z),-1===m&&C.add(rt))}return null}},ae.prototype.query=function(){if(1===arguments.length){var l=arguments[0];this.build();var h=new ue;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),l)&&this.query(l,this._root,h),h}if(2===arguments.length){var m=arguments[0],_=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),m)&&this.query(m,this._root,_)}else if(3===arguments.length)if(O(arguments[2],M)&&arguments[0]instanceof Object&&arguments[1]instanceof wt)for(var C=arguments[0],rt=arguments[2],Dt=arguments[1].getChildBoundables(),Qt=0;Qt<Dt.size();Qt++){var fe=Dt.get(Qt);this.getIntersectsOp().intersects(fe.getBounds(),C)&&(fe instanceof wt?this.query(C,fe,rt):fe instanceof z?rt.visitItem(fe.getItem()):Nn.shouldNeverReachHere())}else if(O(arguments[2],En)&&arguments[0]instanceof Object&&arguments[1]instanceof wt)for(var ke=arguments[0],_n=arguments[2],Sn=arguments[1].getChildBoundables(),Un=0;Un<Sn.size();Un++){var ur=Sn.get(Un);this.getIntersectsOp().intersects(ur.getBounds(),ke)&&(ur instanceof wt?this.query(ke,ur,_n):ur instanceof z?_n.add(ur.getItem()):Nn.shouldNeverReachHere())}},ae.prototype.build=function(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0},ae.prototype.getRoot=function(){return this.build(),this._root},ae.prototype.remove=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),l)&&this.remove(l,this._root,h)}if(3===arguments.length){var m=arguments[0],_=arguments[1],C=arguments[2],F=this.removeItem(_,C);if(F)return!0;for(var rt=null,Dt=_.getChildBoundables().iterator();Dt.hasNext();){var Qt=Dt.next();if(this.getIntersectsOp().intersects(Qt.getBounds(),m)&&Qt instanceof wt&&(F=this.remove(m,Qt,C))){rt=Qt;break}}return null!==rt&&rt.getChildBoundables().isEmpty()&&_.getChildBoundables().remove(rt),F}},ae.prototype.createHigherLevels=function(l,h){Nn.isTrue(!l.isEmpty());var m=this.createParentBoundables(l,h+1);return 1===m.size()?m.get(0):this.createHigherLevels(m,h+1)},ae.prototype.depth=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){for(var l=0,h=arguments[0].getChildBoundables().iterator();h.hasNext();){var m=h.next();if(m instanceof wt){var _=this.depth(m);_>l&&(l=_)}}return l+1}},ae.prototype.createParentBoundables=function(l,h){Nn.isTrue(!l.isEmpty());var m=new ue;m.add(this.createNode(h));var _=new ue(l);Yt.sort(_,this.getComparator());for(var C=_.iterator();C.hasNext();){var F=C.next();this.lastNode(m).getChildBoundables().size()===this.getNodeCapacity()&&m.add(this.createNode(h)),this.lastNode(m).addChildBoundable(F)}return m},ae.prototype.isEmpty=function(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()},ae.prototype.interfaces_=function(){return[$]},ae.prototype.getClass=function(){return ae},ae.compareDoubles=function(l,h){return l>h?1:l<h?-1:0},nn.IntersectsOp.get=function(){return Ye},nn.serialVersionUID.get=function(){return-0x35ef64c82d4c5400},nn.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(ae,nn);var Ye=function(){},$e=function(){};$e.prototype.distance=function(l,h){},$e.prototype.interfaces_=function(){return[]},$e.prototype.getClass=function(){return $e};var Cn=function(l){function h(_){l.call(this,_=_||h.DEFAULT_NODE_CAPACITY)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={STRtreeNode:{configurable:!0},serialVersionUID:{configurable:!0},xComparator:{configurable:!0},yComparator:{configurable:!0},intersectsOp:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};return h.prototype.createParentBoundablesFromVerticalSlices=function(_,C){Nn.isTrue(_.length>0);for(var F=new ue,rt=0;rt<_.length;rt++)F.addAll(this.createParentBoundablesFromVerticalSlice(_[rt],C));return F},h.prototype.createNode=function(_){return new $n(_)},h.prototype.size=function(){return 0===arguments.length?l.prototype.size.call(this):l.prototype.size.apply(this,arguments)},h.prototype.insert=function(){if(2!==arguments.length)return l.prototype.insert.apply(this,arguments);var _=arguments[0],C=arguments[1];if(_.isNull())return null;l.prototype.insert.call(this,_,C)},h.prototype.getIntersectsOp=function(){return h.intersectsOp},h.prototype.verticalSlices=function(_,C){for(var F=Math.trunc(Math.ceil(_.size()/C)),rt=new Array(C).fill(null),Dt=_.iterator(),Qt=0;Qt<C;Qt++){rt[Qt]=new ue;for(var fe=0;Dt.hasNext()&&fe<F;){var ke=Dt.next();rt[Qt].add(ke),fe++}}return rt},h.prototype.query=function(){if(1===arguments.length)return l.prototype.query.call(this,arguments[0]);2===arguments.length?l.prototype.query.call(this,arguments[0],arguments[1]):3===arguments.length&&(O(arguments[2],M)&&arguments[0]instanceof Object&&arguments[1]instanceof wt||O(arguments[2],En)&&arguments[0]instanceof Object&&arguments[1]instanceof wt)&&l.prototype.query.call(this,arguments[0],arguments[1],arguments[2])},h.prototype.getComparator=function(){return h.yComparator},h.prototype.createParentBoundablesFromVerticalSlice=function(_,C){return l.prototype.createParentBoundables.call(this,_,C)},h.prototype.remove=function(){return 2===arguments.length?l.prototype.remove.call(this,arguments[0],arguments[1]):l.prototype.remove.apply(this,arguments)},h.prototype.depth=function(){return 0===arguments.length?l.prototype.depth.call(this):l.prototype.depth.apply(this,arguments)},h.prototype.createParentBoundables=function(_,C){Nn.isTrue(!_.isEmpty());var F=Math.trunc(Math.ceil(_.size()/this.getNodeCapacity())),rt=new ue(_);Yt.sort(rt,h.xComparator);var Dt=this.verticalSlices(rt,Math.trunc(Math.ceil(Math.sqrt(F))));return this.createParentBoundablesFromVerticalSlices(Dt,C)},h.prototype.nearestNeighbour=function(){if(1===arguments.length){if(O(arguments[0],$e)){var _=arguments[0],C=new kt(this.getRoot(),this.getRoot(),_);return this.nearestNeighbour(C)}if(arguments[0]instanceof kt)return this.nearestNeighbour(arguments[0],lt.POSITIVE_INFINITY)}else if(2===arguments.length){if(arguments[0]instanceof h&&O(arguments[1],$e)){var rt=arguments[0],Dt=arguments[1],Qt=new kt(this.getRoot(),rt.getRoot(),Dt);return this.nearestNeighbour(Qt)}if(arguments[0]instanceof kt&&"number"==typeof arguments[1]){var fe=arguments[0],ke=arguments[1],Ge=null,_n=new I;for(_n.add(fe);!_n.isEmpty()&&ke>0;){var Sn=_n.poll(),Un=Sn.getDistance();if(Un>=ke)break;Sn.isLeaves()?(ke=Un,Ge=Sn):Sn.expandToQueue(_n,ke)}return[Ge.getBoundable(0).getItem(),Ge.getBoundable(1).getItem()]}}else if(3===arguments.length){var To=arguments[2],$a=new z(arguments[0],arguments[1]),ml=new kt(this.getRoot(),$a,To);return this.nearestNeighbour(ml)[0]}},h.prototype.interfaces_=function(){return[tt,$]},h.prototype.getClass=function(){return h},h.centreX=function(_){return h.avg(_.getMinX(),_.getMaxX())},h.avg=function(_,C){return(_+C)/2},h.centreY=function(_){return h.avg(_.getMinY(),_.getMaxY())},m.STRtreeNode.get=function(){return $n},m.serialVersionUID.get=function(){return 0x39920f7d5f261e0},m.xComparator.get=function(){return{interfaces_:function(){return[pt]},compare:function(_,C){return l.compareDoubles(h.centreX(_.getBounds()),h.centreX(C.getBounds()))}}},m.yComparator.get=function(){return{interfaces_:function(){return[pt]},compare:function(_,C){return l.compareDoubles(h.centreY(_.getBounds()),h.centreY(C.getBounds()))}}},m.intersectsOp.get=function(){return{interfaces_:function(){return[l.IntersectsOp]},intersects:function(_,C){return _.intersects(C)}}},m.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(h,m),h}(ae),$n=function(l){function h(){l.call(this,arguments[0])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.computeBounds=function(){for(var m=null,_=this.getChildBoundables().iterator();_.hasNext();){var C=_.next();null===m?m=new De(C.getBounds()):m.expandToInclude(C.getBounds())}return m},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(wt),Vn=function(){};Vn.prototype.interfaces_=function(){return[]},Vn.prototype.getClass=function(){return Vn},Vn.relativeSign=function(l,h){return l<h?-1:l>h?1:0},Vn.compare=function(l,h,m){if(h.equals2D(m))return 0;var _=Vn.relativeSign(h.x,m.x),C=Vn.relativeSign(h.y,m.y);switch(l){case 0:return Vn.compareValue(_,C);case 1:return Vn.compareValue(C,_);case 2:return Vn.compareValue(C,-_);case 3:return Vn.compareValue(-_,C);case 4:return Vn.compareValue(-_,-C);case 5:return Vn.compareValue(-C,-_);case 6:return Vn.compareValue(-C,_);case 7:return Vn.compareValue(_,-C)}return Nn.shouldNeverReachHere("invalid octant value"),0},Vn.compareValue=function(l,h){return l<0?-1:l>0?1:h<0?-1:h>0?1:0};var vr=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;var l=arguments[0],h=arguments[1],m=arguments[2],_=arguments[3];this._segString=l,this.coord=new B(h),this.segmentIndex=m,this._segmentOctant=_,this._isInterior=!h.equals2D(l.getCoordinate(m))};vr.prototype.getCoordinate=function(){return this.coord},vr.prototype.print=function(l){l.print(this.coord),l.print(" seg # = "+this.segmentIndex)},vr.prototype.compareTo=function(l){var h=l;return this.segmentIndex<h.segmentIndex?-1:this.segmentIndex>h.segmentIndex?1:this.coord.equals2D(h.coord)?0:Vn.compare(this._segmentOctant,this.coord,h.coord)},vr.prototype.isEndPoint=function(l){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===l},vr.prototype.isInterior=function(){return this._isInterior},vr.prototype.interfaces_=function(){return[Q]},vr.prototype.getClass=function(){return vr};var wn=function(){this._nodeMap=new Z,this._edge=null,this._edge=arguments[0]};wn.prototype.getSplitCoordinates=function(){var l=new mn;this.addEndpoints();for(var h=this.iterator(),m=h.next();h.hasNext();){var _=h.next();this.addEdgeCoordinates(m,_,l),m=_}return l.toCoordinateArray()},wn.prototype.addCollapsedNodes=function(){var l=new ue;this.findCollapsesFromInsertedNodes(l),this.findCollapsesFromExistingVertices(l);for(var h=l.iterator();h.hasNext();){var m=h.next().intValue();this.add(this._edge.getCoordinate(m),m)}},wn.prototype.print=function(l){l.println("Intersections:");for(var h=this.iterator();h.hasNext();)h.next().print(l)},wn.prototype.findCollapsesFromExistingVertices=function(l){for(var h=0;h<this._edge.size()-2;h++){var m=this._edge.getCoordinate(h),_=this._edge.getCoordinate(h+2);m.equals2D(_)&&l.add(new xt(h+1))}},wn.prototype.addEdgeCoordinates=function(l,h,m){var _=this._edge.getCoordinate(h.segmentIndex),C=h.isInterior()||!h.coord.equals2D(_);m.add(new B(l.coord),!1);for(var F=l.segmentIndex+1;F<=h.segmentIndex;F++)m.add(this._edge.getCoordinate(F));C&&m.add(new B(h.coord))},wn.prototype.iterator=function(){return this._nodeMap.values().iterator()},wn.prototype.addSplitEdges=function(l){this.addEndpoints(),this.addCollapsedNodes();for(var h=this.iterator(),m=h.next();h.hasNext();){var _=h.next(),C=this.createSplitEdge(m,_);l.add(C),m=_}},wn.prototype.findCollapseIndex=function(l,h,m){if(!l.coord.equals2D(h.coord))return!1;var _=h.segmentIndex-l.segmentIndex;return h.isInterior()||_--,1===_&&(m[0]=l.segmentIndex+1,!0)},wn.prototype.findCollapsesFromInsertedNodes=function(l){for(var h=new Array(1).fill(null),m=this.iterator(),_=m.next();m.hasNext();){var C=m.next();this.findCollapseIndex(_,C,h)&&l.add(new xt(h[0])),_=C}},wn.prototype.getEdge=function(){return this._edge},wn.prototype.addEndpoints=function(){var l=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(l),l)},wn.prototype.createSplitEdge=function(l,h){var m=h.segmentIndex-l.segmentIndex+2,_=this._edge.getCoordinate(h.segmentIndex),C=h.isInterior()||!h.coord.equals2D(_);C||m--;var F=new Array(m).fill(null),rt=0;F[rt++]=new B(l.coord);for(var Dt=l.segmentIndex+1;Dt<=h.segmentIndex;Dt++)F[rt++]=this._edge.getCoordinate(Dt);return C&&(F[rt]=new B(h.coord)),new Xr(F,this._edge.getData())},wn.prototype.add=function(l,h){var m=new vr(this._edge,l,h,this._edge.getSegmentOctant(h)),_=this._nodeMap.get(m);return null!==_?(Nn.isTrue(_.coord.equals2D(l),"Found equal nodes with different coordinates"),_):(this._nodeMap.put(m,m),m)},wn.prototype.checkSplitEdgesCorrectness=function(l){var h=this._edge.getCoordinates(),m=l.get(0).getCoordinate(0);if(!m.equals2D(h[0]))throw new Gn("bad split edge start point at "+m);var _=l.get(l.size()-1).getCoordinates(),C=_[_.length-1];if(!C.equals2D(h[h.length-1]))throw new Gn("bad split edge end point at "+C)},wn.prototype.interfaces_=function(){return[]},wn.prototype.getClass=function(){return wn};var _r=function(){};_r.prototype.interfaces_=function(){return[]},_r.prototype.getClass=function(){return _r},_r.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var l=arguments[0],h=arguments[1];if(0===l&&0===h)throw new dt("Cannot compute the octant for point ( "+l+", "+h+" )");var m=Math.abs(l),_=Math.abs(h);return l>=0?h>=0?m>=_?0:1:m>=_?7:6:h>=0?m>=_?3:2:m>=_?4:5}if(arguments[0]instanceof B&&arguments[1]instanceof B){var C=arguments[0],F=arguments[1],rt=F.x-C.x,Dt=F.y-C.y;if(0===rt&&0===Dt)throw new dt("Cannot compute the octant for two identical points "+C);return _r.octant(rt,Dt)}};var ni=function(){};ni.prototype.getCoordinates=function(){},ni.prototype.size=function(){},ni.prototype.getCoordinate=function(l){},ni.prototype.isClosed=function(){},ni.prototype.setData=function(l){},ni.prototype.getData=function(){},ni.prototype.interfaces_=function(){return[]},ni.prototype.getClass=function(){return ni};var Zs=function(){};Zs.prototype.addIntersection=function(l,h){},Zs.prototype.interfaces_=function(){return[ni]},Zs.prototype.getClass=function(){return Zs};var Xr=function(){this._nodeList=new wn(this),this._pts=null,this._data=null;var h=arguments[1];this._pts=arguments[0],this._data=h};Xr.prototype.getCoordinates=function(){return this._pts},Xr.prototype.size=function(){return this._pts.length},Xr.prototype.getCoordinate=function(l){return this._pts[l]},Xr.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},Xr.prototype.getSegmentOctant=function(l){return l===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(l),this.getCoordinate(l+1))},Xr.prototype.setData=function(l){this._data=l},Xr.prototype.safeOctant=function(l,h){return l.equals2D(h)?0:_r.octant(l,h)},Xr.prototype.getData=function(){return this._data},Xr.prototype.addIntersection=function(){if(2===arguments.length)this.addIntersectionNode(arguments[0],arguments[1]);else if(4===arguments.length){var _=arguments[1],F=new B(arguments[0].getIntersection(arguments[3]));this.addIntersection(F,_)}},Xr.prototype.toString=function(){return Je.toLineString(new pr(this._pts))},Xr.prototype.getNodeList=function(){return this._nodeList},Xr.prototype.addIntersectionNode=function(l,h){var m=h,_=m+1;return _<this._pts.length&&l.equals2D(this._pts[_])&&(m=_),this._nodeList.add(l,m)},Xr.prototype.addIntersections=function(l,h,m){for(var _=0;_<l.getIntersectionNum();_++)this.addIntersection(l,h,m,_)},Xr.prototype.interfaces_=function(){return[Zs]},Xr.prototype.getClass=function(){return Xr},Xr.getNodedSubstrings=function(){if(1===arguments.length){var l=arguments[0],h=new ue;return Xr.getNodedSubstrings(l,h),h}if(2===arguments.length)for(var _=arguments[1],C=arguments[0].iterator();C.hasNext();)C.next().getNodeList().addSplitEdges(_)};var tn=function(){if(this.p0=null,this.p1=null,0===arguments.length)this.p0=new B,this.p1=new B;else if(1===arguments.length){var l=arguments[0];this.p0=new B(l.p0),this.p1=new B(l.p1)}else if(2===arguments.length)this.p0=arguments[0],this.p1=arguments[1];else if(4===arguments.length){var _=arguments[2],C=arguments[3];this.p0=new B(arguments[0],arguments[1]),this.p1=new B(_,C)}},Su={serialVersionUID:{configurable:!0}};tn.prototype.minX=function(){return Math.min(this.p0.x,this.p1.x)},tn.prototype.orientationIndex=function(){if(arguments[0]instanceof tn){var l=arguments[0],h=yn.orientationIndex(this.p0,this.p1,l.p0),m=yn.orientationIndex(this.p0,this.p1,l.p1);return h>=0&&m>=0||h<=0&&m<=0?Math.max(h,m):0}if(arguments[0]instanceof B)return yn.orientationIndex(this.p0,this.p1,arguments[0])},tn.prototype.toGeometry=function(l){return l.createLineString([this.p0,this.p1])},tn.prototype.isVertical=function(){return this.p0.x===this.p1.x},tn.prototype.equals=function(l){if(!(l instanceof tn))return!1;var h=l;return this.p0.equals(h.p0)&&this.p1.equals(h.p1)},tn.prototype.intersection=function(l){var h=new di;return h.computeIntersection(this.p0,this.p1,l.p0,l.p1),h.hasIntersection()?h.getIntersection(0):null},tn.prototype.project=function(){if(arguments[0]instanceof B){var l=arguments[0];if(l.equals(this.p0)||l.equals(this.p1))return new B(l);var h=this.projectionFactor(l),m=new B;return m.x=this.p0.x+h*(this.p1.x-this.p0.x),m.y=this.p0.y+h*(this.p1.y-this.p0.y),m}if(arguments[0]instanceof tn){var _=arguments[0],C=this.projectionFactor(_.p0),F=this.projectionFactor(_.p1);if(C>=1&&F>=1||C<=0&&F<=0)return null;var rt=this.project(_.p0);C<0&&(rt=this.p0),C>1&&(rt=this.p1);var Dt=this.project(_.p1);return F<0&&(Dt=this.p0),F>1&&(Dt=this.p1),new tn(rt,Dt)}},tn.prototype.normalize=function(){this.p1.compareTo(this.p0)<0&&this.reverse()},tn.prototype.angle=function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},tn.prototype.getCoordinate=function(l){return 0===l?this.p0:this.p1},tn.prototype.distancePerpendicular=function(l){return yn.distancePointLinePerpendicular(l,this.p0,this.p1)},tn.prototype.minY=function(){return Math.min(this.p0.y,this.p1.y)},tn.prototype.midPoint=function(){return tn.midPoint(this.p0,this.p1)},tn.prototype.projectionFactor=function(l){if(l.equals(this.p0))return 0;if(l.equals(this.p1))return 1;var h=this.p1.x-this.p0.x,m=this.p1.y-this.p0.y,_=h*h+m*m;return _<=0?lt.NaN:((l.x-this.p0.x)*h+(l.y-this.p0.y)*m)/_},tn.prototype.closestPoints=function(l){var h=this.intersection(l);if(null!==h)return[h,h];var m=new Array(2).fill(null),_=lt.MAX_VALUE,C=null,F=this.closestPoint(l.p0);_=F.distance(l.p0),m[0]=F,m[1]=l.p0;var rt=this.closestPoint(l.p1);(C=rt.distance(l.p1))<_&&(_=C,m[0]=rt,m[1]=l.p1);var Dt=l.closestPoint(this.p0);(C=Dt.distance(this.p0))<_&&(_=C,m[0]=this.p0,m[1]=Dt);var Qt=l.closestPoint(this.p1);return(C=Qt.distance(this.p1))<_&&(_=C,m[0]=this.p1,m[1]=Qt),m},tn.prototype.closestPoint=function(l){var h=this.projectionFactor(l);return h>0&&h<1?this.project(l):this.p0.distance(l)<this.p1.distance(l)?this.p0:this.p1},tn.prototype.maxX=function(){return Math.max(this.p0.x,this.p1.x)},tn.prototype.getLength=function(){return this.p0.distance(this.p1)},tn.prototype.compareTo=function(l){var h=l,m=this.p0.compareTo(h.p0);return 0!==m?m:this.p1.compareTo(h.p1)},tn.prototype.reverse=function(){var l=this.p0;this.p0=this.p1,this.p1=l},tn.prototype.equalsTopo=function(l){return this.p0.equals(l.p0)&&(this.p1.equals(l.p1)||this.p0.equals(l.p1))&&this.p1.equals(l.p0)},tn.prototype.lineIntersection=function(l){try{return Ue.intersection(this.p0,this.p1,l.p0,l.p1)}catch(h){if(!(h instanceof Me))throw h}return null},tn.prototype.maxY=function(){return Math.max(this.p0.y,this.p1.y)},tn.prototype.pointAlongOffset=function(l,h){var m=this.p0.x+l*(this.p1.x-this.p0.x),_=this.p0.y+l*(this.p1.y-this.p0.y),C=this.p1.x-this.p0.x,F=this.p1.y-this.p0.y,rt=Math.sqrt(C*C+F*F),Dt=0,Qt=0;if(0!==h){if(rt<=0)throw new Error("Cannot compute offset from zero-length line segment");Dt=h*C/rt,Qt=h*F/rt}return new B(m-Qt,_+Dt)},tn.prototype.setCoordinates=function(){if(1===arguments.length){var l=arguments[0];this.setCoordinates(l.p0,l.p1)}else if(2===arguments.length){var h=arguments[0],m=arguments[1];this.p0.x=h.x,this.p0.y=h.y,this.p1.x=m.x,this.p1.y=m.y}},tn.prototype.segmentFraction=function(l){var h=this.projectionFactor(l);return h<0?h=0:(h>1||lt.isNaN(h))&&(h=1),h},tn.prototype.toString=function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},tn.prototype.isHorizontal=function(){return this.p0.y===this.p1.y},tn.prototype.distance=function(){if(arguments[0]instanceof tn){var l=arguments[0];return yn.distanceLineLine(this.p0,this.p1,l.p0,l.p1)}if(arguments[0]instanceof B)return yn.distancePointLine(arguments[0],this.p0,this.p1)},tn.prototype.pointAlong=function(l){var h=new B;return h.x=this.p0.x+l*(this.p1.x-this.p0.x),h.y=this.p0.y+l*(this.p1.y-this.p0.y),h},tn.prototype.hashCode=function(){var l=lt.doubleToLongBits(this.p0.x);l^=31*lt.doubleToLongBits(this.p0.y);var h=Math.trunc(l)^Math.trunc(l>>32),m=lt.doubleToLongBits(this.p1.x);return m^=31*lt.doubleToLongBits(this.p1.y),h^Math.trunc(m)^Math.trunc(m>>32)},tn.prototype.interfaces_=function(){return[Q,$]},tn.prototype.getClass=function(){return tn},tn.midPoint=function(l,h){return new B((l.x+h.x)/2,(l.y+h.y)/2)},Su.serialVersionUID.get=function(){return 0x2d2172135f411c00},Object.defineProperties(tn,Su);var xr=function(){this.tempEnv1=new De,this.tempEnv2=new De,this._overlapSeg1=new tn,this._overlapSeg2=new tn};xr.prototype.overlap=function(){if(2!==arguments.length&&4===arguments.length){var m=arguments[2],_=arguments[3];arguments[0].getLineSegment(arguments[1],this._overlapSeg1),m.getLineSegment(_,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}},xr.prototype.interfaces_=function(){return[]},xr.prototype.getClass=function(){return xr};var qi=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;var h=arguments[1],m=arguments[2],_=arguments[3];this._pts=arguments[0],this._start=h,this._end=m,this._context=_};qi.prototype.getLineSegment=function(l,h){h.p0=this._pts[l],h.p1=this._pts[l+1]},qi.prototype.computeSelect=function(l,h,m,_){if(_.tempEnv1.init(this._pts[h],this._pts[m]),m-h==1)return _.select(this,h),null;if(!l.intersects(_.tempEnv1))return null;var rt=Math.trunc((h+m)/2);h<rt&&this.computeSelect(l,h,rt,_),rt<m&&this.computeSelect(l,rt,m,_)},qi.prototype.getCoordinates=function(){for(var l=new Array(this._end-this._start+1).fill(null),h=0,m=this._start;m<=this._end;m++)l[h++]=this._pts[m];return l},qi.prototype.computeOverlaps=function(l,h){this.computeOverlapsInternal(this._start,this._end,l,l._start,l._end,h)},qi.prototype.setId=function(l){this._id=l},qi.prototype.select=function(l,h){this.computeSelect(l,this._start,this._end,h)},qi.prototype.getEnvelope=function(){return null===this._env&&(this._env=new De(this._pts[this._start],this._pts[this._end])),this._env},qi.prototype.getEndIndex=function(){return this._end},qi.prototype.getStartIndex=function(){return this._start},qi.prototype.getContext=function(){return this._context},qi.prototype.getId=function(){return this._id},qi.prototype.computeOverlapsInternal=function(l,h,m,_,C,F){var rt=this._pts[l],Dt=this._pts[h],Qt=m._pts[_],fe=m._pts[C];if(h-l==1&&C-_==1)return F.overlap(this,l,m,_),null;if(F.tempEnv1.init(rt,Dt),F.tempEnv2.init(Qt,fe),!F.tempEnv1.intersects(F.tempEnv2))return null;var ke=Math.trunc((l+h)/2),Ge=Math.trunc((_+C)/2);l<ke&&(_<Ge&&this.computeOverlapsInternal(l,ke,m,_,Ge,F),Ge<C&&this.computeOverlapsInternal(l,ke,m,Ge,C,F)),ke<h&&(_<Ge&&this.computeOverlapsInternal(ke,h,m,_,Ge,F),Ge<C&&this.computeOverlapsInternal(ke,h,m,Ge,C,F))},qi.prototype.interfaces_=function(){return[]},qi.prototype.getClass=function(){return qi};var fo=function(){};fo.prototype.interfaces_=function(){return[]},fo.prototype.getClass=function(){return fo},fo.getChainStartIndices=function(l){var h=0,m=new ue;m.add(new xt(h));do{var _=fo.findChainEnd(l,h);m.add(new xt(_)),h=_}while(h<l.length-1);return fo.toIntArray(m)},fo.findChainEnd=function(l,h){for(var m=h;m<l.length-1&&l[m].equals2D(l[m+1]);)m++;if(m>=l.length-1)return l.length-1;for(var _=Wr.quadrant(l[m],l[m+1]),C=h+1;C<l.length&&(l[C-1].equals2D(l[C])||Wr.quadrant(l[C-1],l[C])===_);)C++;return C-1},fo.getChains=function(){if(1===arguments.length)return fo.getChains(arguments[0],null);if(2===arguments.length){for(var h=arguments[0],m=arguments[1],_=new ue,C=fo.getChainStartIndices(h),F=0;F<C.length-1;F++){var rt=new qi(h,C[F],C[F+1],m);_.add(rt)}return _}},fo.toIntArray=function(l){for(var h=new Array(l.size()).fill(null),m=0;m<h.length;m++)h[m]=l.get(m).intValue();return h};var vs=function(){};vs.prototype.computeNodes=function(l){},vs.prototype.getNodedSubstrings=function(){},vs.prototype.interfaces_=function(){return[]},vs.prototype.getClass=function(){return vs};var ku=function(){this._segInt=null,0!==arguments.length&&1===arguments.length&&this.setSegmentIntersector(arguments[0])};ku.prototype.setSegmentIntersector=function(l){this._segInt=l},ku.prototype.interfaces_=function(){return[vs]},ku.prototype.getClass=function(){return ku};var Rc=function(l){function h(_){_?l.call(this,_):l.call(this),this._monoChains=new ue,this._index=new Cn,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={SegmentOverlapAction:{configurable:!0}};return h.prototype.getMonotoneChains=function(){return this._monoChains},h.prototype.getNodedSubstrings=function(){return Xr.getNodedSubstrings(this._nodedSegStrings)},h.prototype.getIndex=function(){return this._index},h.prototype.add=function(_){for(var C=fo.getChains(_.getCoordinates(),_).iterator();C.hasNext();){var F=C.next();F.setId(this._idCounter++),this._index.insert(F.getEnvelope(),F),this._monoChains.add(F)}},h.prototype.computeNodes=function(_){this._nodedSegStrings=_;for(var C=_.iterator();C.hasNext();)this.add(C.next());this.intersectChains()},h.prototype.intersectChains=function(){for(var _=new us(this._segInt),C=this._monoChains.iterator();C.hasNext();)for(var F=C.next(),rt=this._index.query(F.getEnvelope()).iterator();rt.hasNext();){var Dt=rt.next();if(Dt.getId()>F.getId()&&(F.computeOverlaps(Dt,_),this._nOverlaps++),this._segInt.isDone())return null}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},m.SegmentOverlapAction.get=function(){return us},Object.defineProperties(h,m),h}(ku),us=function(l){function h(){l.call(this),this._si=null,this._si=arguments[0]}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.overlap=function(){if(4!==arguments.length)return l.prototype.overlap.apply(this,arguments);var _=arguments[1],C=arguments[2],F=arguments[3],rt=arguments[0].getContext(),Dt=C.getContext();this._si.processIntersections(rt,_,Dt,F)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(xr),Zr=function l(){if(this._quadrantSegments=l.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=l.CAP_ROUND,this._joinStyle=l.JOIN_ROUND,this._mitreLimit=l.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=l.DEFAULT_SIMPLIFY_FACTOR,0!==arguments.length)if(1===arguments.length)this.setQuadrantSegments(arguments[0]);else if(2===arguments.length){var _=arguments[1];this.setQuadrantSegments(arguments[0]),this.setEndCapStyle(_)}else if(4===arguments.length){var F=arguments[1],rt=arguments[2],Dt=arguments[3];this.setQuadrantSegments(arguments[0]),this.setEndCapStyle(F),this.setJoinStyle(rt),this.setMitreLimit(Dt)}},nu={CAP_ROUND:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},JOIN_ROUND:{configurable:!0},JOIN_MITRE:{configurable:!0},JOIN_BEVEL:{configurable:!0},DEFAULT_QUADRANT_SEGMENTS:{configurable:!0},DEFAULT_MITRE_LIMIT:{configurable:!0},DEFAULT_SIMPLIFY_FACTOR:{configurable:!0}};Zr.prototype.getEndCapStyle=function(){return this._endCapStyle},Zr.prototype.isSingleSided=function(){return this._isSingleSided},Zr.prototype.setQuadrantSegments=function(l){this._quadrantSegments=l,0===this._quadrantSegments&&(this._joinStyle=Zr.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=Zr.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),l<=0&&(this._quadrantSegments=1),this._joinStyle!==Zr.JOIN_ROUND&&(this._quadrantSegments=Zr.DEFAULT_QUADRANT_SEGMENTS)},Zr.prototype.getJoinStyle=function(){return this._joinStyle},Zr.prototype.setJoinStyle=function(l){this._joinStyle=l},Zr.prototype.setSimplifyFactor=function(l){this._simplifyFactor=l<0?0:l},Zr.prototype.getSimplifyFactor=function(){return this._simplifyFactor},Zr.prototype.getQuadrantSegments=function(){return this._quadrantSegments},Zr.prototype.setEndCapStyle=function(l){this._endCapStyle=l},Zr.prototype.getMitreLimit=function(){return this._mitreLimit},Zr.prototype.setMitreLimit=function(l){this._mitreLimit=l},Zr.prototype.setSingleSided=function(l){this._isSingleSided=l},Zr.prototype.interfaces_=function(){return[]},Zr.prototype.getClass=function(){return Zr},Zr.bufferDistanceError=function(l){var h=Math.PI/2/l;return 1-Math.cos(h/2)},nu.CAP_ROUND.get=function(){return 1},nu.CAP_FLAT.get=function(){return 2},nu.CAP_SQUARE.get=function(){return 3},nu.JOIN_ROUND.get=function(){return 1},nu.JOIN_MITRE.get=function(){return 2},nu.JOIN_BEVEL.get=function(){return 3},nu.DEFAULT_QUADRANT_SEGMENTS.get=function(){return 8},nu.DEFAULT_MITRE_LIMIT.get=function(){return 5},nu.DEFAULT_SIMPLIFY_FACTOR.get=function(){return.01},Object.defineProperties(Zr,nu);var In=function(l){this._distanceTol=null,this._isDeleted=null,this._angleOrientation=yn.COUNTERCLOCKWISE,this._inputLine=l||null},pu={INIT:{configurable:!0},DELETE:{configurable:!0},KEEP:{configurable:!0},NUM_PTS_TO_CHECK:{configurable:!0}};In.prototype.isDeletable=function(l,h,m,_){var C=this._inputLine[l],F=this._inputLine[h],rt=this._inputLine[m];return!!this.isConcave(C,F,rt)&&!!this.isShallow(C,F,rt,_)&&this.isShallowSampled(C,F,l,m,_)},In.prototype.deleteShallowConcavities=function(){for(var l=1,h=this.findNextNonDeletedIndex(l),m=this.findNextNonDeletedIndex(h),_=!1;m<this._inputLine.length;){var C=!1;this.isDeletable(l,h,m,this._distanceTol)&&(this._isDeleted[h]=In.DELETE,C=!0,_=!0),h=this.findNextNonDeletedIndex(l=C?m:h),m=this.findNextNonDeletedIndex(h)}return _},In.prototype.isShallowConcavity=function(l,h,m,_){return yn.computeOrientation(l,h,m)===this._angleOrientation&&yn.distancePointLine(h,l,m)<_},In.prototype.isShallowSampled=function(l,h,m,_,C){var F=Math.trunc((_-m)/In.NUM_PTS_TO_CHECK);F<=0&&(F=1);for(var rt=m;rt<_;rt+=F)if(!this.isShallow(l,h,this._inputLine[rt],C))return!1;return!0},In.prototype.isConcave=function(l,h,m){return yn.computeOrientation(l,h,m)===this._angleOrientation},In.prototype.simplify=function(l){this._distanceTol=Math.abs(l),l<0&&(this._angleOrientation=yn.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);var h=!1;do{h=this.deleteShallowConcavities()}while(h);return this.collapseLine()},In.prototype.findNextNonDeletedIndex=function(l){for(var h=l+1;h<this._inputLine.length&&this._isDeleted[h]===In.DELETE;)h++;return h},In.prototype.isShallow=function(l,h,m,_){return yn.distancePointLine(h,l,m)<_},In.prototype.collapseLine=function(){for(var l=new mn,h=0;h<this._inputLine.length;h++)this._isDeleted[h]!==In.DELETE&&l.add(this._inputLine[h]);return l.toCoordinateArray()},In.prototype.interfaces_=function(){return[]},In.prototype.getClass=function(){return In},In.simplify=function(l,h){return new In(l).simplify(h)},pu.INIT.get=function(){return 0},pu.DELETE.get=function(){return 1},pu.KEEP.get=function(){return 1},pu.NUM_PTS_TO_CHECK.get=function(){return 10},Object.defineProperties(In,pu);var Bo=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new ue},Hl={COORDINATE_ARRAY_TYPE:{configurable:!0}};Bo.prototype.getCoordinates=function(){return this._ptList.toArray(Bo.COORDINATE_ARRAY_TYPE)},Bo.prototype.setPrecisionModel=function(l){this._precisionModel=l},Bo.prototype.addPt=function(l){var h=new B(l);if(this._precisionModel.makePrecise(h),this.isRedundant(h))return null;this._ptList.add(h)},Bo.prototype.revere=function(){},Bo.prototype.addPts=function(l,h){if(h)for(var m=0;m<l.length;m++)this.addPt(l[m]);else for(var _=l.length-1;_>=0;_--)this.addPt(l[_])},Bo.prototype.isRedundant=function(l){if(this._ptList.size()<1)return!1;var h=this._ptList.get(this._ptList.size()-1);return l.distance(h)<this._minimimVertexDistance},Bo.prototype.toString=function(){return(new nr).createLineString(this.getCoordinates()).toString()},Bo.prototype.closeRing=function(){if(this._ptList.size()<1)return null;var l=new B(this._ptList.get(0)),h=this._ptList.get(this._ptList.size()-1);if(l.equals(h))return null;this._ptList.add(l)},Bo.prototype.setMinimumVertexDistance=function(l){this._minimimVertexDistance=l},Bo.prototype.interfaces_=function(){return[]},Bo.prototype.getClass=function(){return Bo},Hl.COORDINATE_ARRAY_TYPE.get=function(){return new Array(0).fill(null)},Object.defineProperties(Bo,Hl);var Ir=function(){},mu={PI_TIMES_2:{configurable:!0},PI_OVER_2:{configurable:!0},PI_OVER_4:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},CLOCKWISE:{configurable:!0},NONE:{configurable:!0}};Ir.prototype.interfaces_=function(){return[]},Ir.prototype.getClass=function(){return Ir},Ir.toDegrees=function(l){return 180*l/Math.PI},Ir.normalize=function(l){for(;l>Math.PI;)l-=Ir.PI_TIMES_2;for(;l<=-Math.PI;)l+=Ir.PI_TIMES_2;return l},Ir.angle=function(){if(1===arguments.length){var l=arguments[0];return Math.atan2(l.y,l.x)}if(2===arguments.length){var h=arguments[0],m=arguments[1];return Math.atan2(m.y-h.y,m.x-h.x)}},Ir.isAcute=function(l,h,m){return(l.x-h.x)*(m.x-h.x)+(l.y-h.y)*(m.y-h.y)>0},Ir.isObtuse=function(l,h,m){return(l.x-h.x)*(m.x-h.x)+(l.y-h.y)*(m.y-h.y)<0},Ir.interiorAngle=function(l,h,m){var _=Ir.angle(h,l),C=Ir.angle(h,m);return Math.abs(C-_)},Ir.normalizePositive=function(l){if(l<0){for(;l<0;)l+=Ir.PI_TIMES_2;l>=Ir.PI_TIMES_2&&(l=0)}else{for(;l>=Ir.PI_TIMES_2;)l-=Ir.PI_TIMES_2;l<0&&(l=0)}return l},Ir.angleBetween=function(l,h,m){var _=Ir.angle(h,l),C=Ir.angle(h,m);return Ir.diff(_,C)},Ir.diff=function(l,h){var m=null;return(m=l<h?h-l:l-h)>Math.PI&&(m=2*Math.PI-m),m},Ir.toRadians=function(l){return l*Math.PI/180},Ir.getTurn=function(l,h){var m=Math.sin(h-l);return m>0?Ir.COUNTERCLOCKWISE:m<0?Ir.CLOCKWISE:Ir.NONE},Ir.angleBetweenOriented=function(l,h,m){var _=Ir.angle(h,l),C=Ir.angle(h,m)-_;return C<=-Math.PI?C+Ir.PI_TIMES_2:C>Math.PI?C-Ir.PI_TIMES_2:C},mu.PI_TIMES_2.get=function(){return 2*Math.PI},mu.PI_OVER_2.get=function(){return Math.PI/2},mu.PI_OVER_4.get=function(){return Math.PI/4},mu.COUNTERCLOCKWISE.get=function(){return yn.COUNTERCLOCKWISE},mu.CLOCKWISE.get=function(){return yn.CLOCKWISE},mu.NONE.get=function(){return yn.COLLINEAR},Object.defineProperties(Ir,mu);var Gr=function l(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new tn,this._seg1=new tn,this._offset0=new tn,this._offset1=new tn,this._side=0,this._hasNarrowConcaveAngle=!1;var m=arguments[1],_=arguments[2];this._precisionModel=arguments[0],this._bufParams=m,this._li=new di,this._filletAngleQuantum=Math.PI/2/m.getQuadrantSegments(),m.getQuadrantSegments()>=8&&m.getJoinStyle()===Zr.JOIN_ROUND&&(this._closingSegLengthFactor=l.MAX_CLOSING_SEG_LEN_FACTOR),this.init(_)},qu={OFFSET_SEGMENT_SEPARATION_FACTOR:{configurable:!0},INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},CURVE_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},MAX_CLOSING_SEG_LEN_FACTOR:{configurable:!0}};Gr.prototype.addNextSegment=function(l,h){if(this._s0=this._s1,this._s1=this._s2,this._s2=l,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;var m=yn.computeOrientation(this._s0,this._s1,this._s2),_=m===yn.CLOCKWISE&&this._side===an.LEFT||m===yn.COUNTERCLOCKWISE&&this._side===an.RIGHT;0===m?this.addCollinear(h):_?this.addOutsideTurn(m,h):this.addInsideTurn(m,h)},Gr.prototype.addLineEndCap=function(l,h){var m=new tn(l,h),_=new tn;this.computeOffsetSegment(m,an.LEFT,this._distance,_);var C=new tn;this.computeOffsetSegment(m,an.RIGHT,this._distance,C);var Dt=Math.atan2(h.y-l.y,h.x-l.x);switch(this._bufParams.getEndCapStyle()){case Zr.CAP_ROUND:this._segList.addPt(_.p1),this.addFilletArc(h,Dt+Math.PI/2,Dt-Math.PI/2,yn.CLOCKWISE,this._distance),this._segList.addPt(C.p1);break;case Zr.CAP_FLAT:this._segList.addPt(_.p1),this._segList.addPt(C.p1);break;case Zr.CAP_SQUARE:var Qt=new B;Qt.x=Math.abs(this._distance)*Math.cos(Dt),Qt.y=Math.abs(this._distance)*Math.sin(Dt);var fe=new B(_.p1.x+Qt.x,_.p1.y+Qt.y),ke=new B(C.p1.x+Qt.x,C.p1.y+Qt.y);this._segList.addPt(fe),this._segList.addPt(ke)}},Gr.prototype.getCoordinates=function(){return this._segList.getCoordinates()},Gr.prototype.addMitreJoin=function(l,h,m,_){var C=!0,F=null;try{F=Ue.intersection(h.p0,h.p1,m.p0,m.p1),(_<=0?1:F.distance(l)/Math.abs(_))>this._bufParams.getMitreLimit()&&(C=!1)}catch(rt){if(!(rt instanceof Me))throw rt;F=new B(0,0),C=!1}C?this._segList.addPt(F):this.addLimitedMitreJoin(h,m,_,this._bufParams.getMitreLimit())},Gr.prototype.addFilletCorner=function(l,h,m,_,C){var Dt=Math.atan2(h.y-l.y,h.x-l.x),ke=Math.atan2(m.y-l.y,m.x-l.x);_===yn.CLOCKWISE?Dt<=ke&&(Dt+=2*Math.PI):Dt>=ke&&(Dt-=2*Math.PI),this._segList.addPt(h),this.addFilletArc(l,Dt,ke,_,C),this._segList.addPt(m)},Gr.prototype.addOutsideTurn=function(l,h){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*Gr.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===Zr.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===Zr.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(h&&this._segList.addPt(this._offset0.p1),this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,l,this._distance),this._segList.addPt(this._offset1.p0))},Gr.prototype.createSquare=function(l){this._segList.addPt(new B(l.x+this._distance,l.y+this._distance)),this._segList.addPt(new B(l.x+this._distance,l.y-this._distance)),this._segList.addPt(new B(l.x-this._distance,l.y-this._distance)),this._segList.addPt(new B(l.x-this._distance,l.y+this._distance)),this._segList.closeRing()},Gr.prototype.addSegments=function(l,h){this._segList.addPts(l,h)},Gr.prototype.addFirstSegment=function(){this._segList.addPt(this._offset1.p0)},Gr.prototype.addLastSegment=function(){this._segList.addPt(this._offset1.p1)},Gr.prototype.initSideSegments=function(l,h,m){this._s1=l,this._s2=h,this._side=m,this._seg1.setCoordinates(l,h),this.computeOffsetSegment(this._seg1,m,this._distance,this._offset1)},Gr.prototype.addLimitedMitreJoin=function(l,h,m,_){var C=this._seg0.p1,F=Ir.angle(C,this._seg0.p0),rt=Ir.angleBetweenOriented(this._seg0.p0,C,this._seg1.p1)/2,Dt=Ir.normalize(F+rt),Qt=Ir.normalize(Dt+Math.PI),fe=_*m,ke=m-fe*Math.abs(Math.sin(rt)),Ge=C.x+fe*Math.cos(Qt),_n=C.y+fe*Math.sin(Qt),Sn=new B(Ge,_n),Un=new tn(C,Sn),ur=Un.pointAlongOffset(1,ke),Ji=Un.pointAlongOffset(1,-ke);this._side===an.LEFT?(this._segList.addPt(ur),this._segList.addPt(Ji)):(this._segList.addPt(Ji),this._segList.addPt(ur))},Gr.prototype.computeOffsetSegment=function(l,h,m,_){var C=h===an.LEFT?1:-1,F=l.p1.x-l.p0.x,rt=l.p1.y-l.p0.y,Dt=Math.sqrt(F*F+rt*rt),Qt=C*m*F/Dt,fe=C*m*rt/Dt;_.p0.x=l.p0.x-fe,_.p0.y=l.p0.y+Qt,_.p1.x=l.p1.x-fe,_.p1.y=l.p1.y+Qt},Gr.prototype.addFilletArc=function(l,h,m,_,C){var F=_===yn.CLOCKWISE?-1:1,rt=Math.abs(h-m),Dt=Math.trunc(rt/this._filletAngleQuantum+.5);if(Dt<1)return null;for(var Qt=rt/Dt,fe=0,ke=new B;fe<rt;){var Ge=h+F*fe;ke.x=l.x+C*Math.cos(Ge),ke.y=l.y+C*Math.sin(Ge),this._segList.addPt(ke),fe+=Qt}},Gr.prototype.addInsideTurn=function(l,h){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*Gr.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){var m=new B((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(m);var _=new B((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(_)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}},Gr.prototype.createCircle=function(l){var h=new B(l.x+this._distance,l.y);this._segList.addPt(h),this.addFilletArc(l,0,2*Math.PI,-1,this._distance),this._segList.closeRing()},Gr.prototype.addBevelJoin=function(l,h){this._segList.addPt(l.p1),this._segList.addPt(h.p0)},Gr.prototype.init=function(l){this._distance=l,this._maxCurveSegmentError=l*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new Bo,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(l*Gr.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},Gr.prototype.addCollinear=function(l){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===Zr.JOIN_BEVEL||this._bufParams.getJoinStyle()===Zr.JOIN_MITRE?(l&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,yn.CLOCKWISE,this._distance))},Gr.prototype.closeRing=function(){this._segList.closeRing()},Gr.prototype.hasNarrowConcaveAngle=function(){return this._hasNarrowConcaveAngle},Gr.prototype.interfaces_=function(){return[]},Gr.prototype.getClass=function(){return Gr},qu.OFFSET_SEGMENT_SEPARATION_FACTOR.get=function(){return.001},qu.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return.001},qu.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return 1e-6},qu.MAX_CLOSING_SEG_LEN_FACTOR.get=function(){return 80},Object.defineProperties(Gr,qu);var he=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;var h=arguments[1];this._precisionModel=arguments[0],this._bufParams=h};he.prototype.getOffsetCurve=function(l,h){if(this._distance=h,0===h)return null;var m=h<0,_=Math.abs(h),C=this.getSegGen(_);l.length<=1?this.computePointCurve(l[0],C):this.computeOffsetCurve(l,m,C);var F=C.getCoordinates();return m&&un.reverse(F),F},he.prototype.computeSingleSidedBufferCurve=function(l,h,m){var _=this.simplifyTolerance(this._distance);if(h){m.addSegments(l,!0);var C=In.simplify(l,-_),F=C.length-1;m.initSideSegments(C[F],C[F-1],an.LEFT),m.addFirstSegment();for(var rt=F-2;rt>=0;rt--)m.addNextSegment(C[rt],!0)}else{m.addSegments(l,!1);var Dt=In.simplify(l,_),Qt=Dt.length-1;m.initSideSegments(Dt[0],Dt[1],an.LEFT),m.addFirstSegment();for(var fe=2;fe<=Qt;fe++)m.addNextSegment(Dt[fe],!0)}m.addLastSegment(),m.closeRing()},he.prototype.computeRingBufferCurve=function(l,h,m){var _=this.simplifyTolerance(this._distance);h===an.RIGHT&&(_=-_);var C=In.simplify(l,_),F=C.length-1;m.initSideSegments(C[F-1],C[0],h);for(var rt=1;rt<=F;rt++)m.addNextSegment(C[rt],1!==rt);m.closeRing()},he.prototype.computeLineBufferCurve=function(l,h){var m=this.simplifyTolerance(this._distance),_=In.simplify(l,m),C=_.length-1;h.initSideSegments(_[0],_[1],an.LEFT);for(var F=2;F<=C;F++)h.addNextSegment(_[F],!0);h.addLastSegment(),h.addLineEndCap(_[C-1],_[C]);var rt=In.simplify(l,-m),Dt=rt.length-1;h.initSideSegments(rt[Dt],rt[Dt-1],an.LEFT);for(var Qt=Dt-2;Qt>=0;Qt--)h.addNextSegment(rt[Qt],!0);h.addLastSegment(),h.addLineEndCap(rt[1],rt[0]),h.closeRing()},he.prototype.computePointCurve=function(l,h){switch(this._bufParams.getEndCapStyle()){case Zr.CAP_ROUND:h.createCircle(l);break;case Zr.CAP_SQUARE:h.createSquare(l)}},he.prototype.getLineCurve=function(l,h){if(this._distance=h,h<0&&!this._bufParams.isSingleSided()||0===h)return null;var m=Math.abs(h),_=this.getSegGen(m);return l.length<=1?this.computePointCurve(l[0],_):this._bufParams.isSingleSided()?this.computeSingleSidedBufferCurve(l,h<0,_):this.computeLineBufferCurve(l,_),_.getCoordinates()},he.prototype.getBufferParameters=function(){return this._bufParams},he.prototype.simplifyTolerance=function(l){return l*this._bufParams.getSimplifyFactor()},he.prototype.getRingCurve=function(l,h,m){if(this._distance=m,l.length<=2)return this.getLineCurve(l,m);if(0===m)return he.copyCoordinates(l);var _=this.getSegGen(m);return this.computeRingBufferCurve(l,h,_),_.getCoordinates()},he.prototype.computeOffsetCurve=function(l,h,m){var _=this.simplifyTolerance(this._distance);if(h){var C=In.simplify(l,-_),F=C.length-1;m.initSideSegments(C[F],C[F-1],an.LEFT),m.addFirstSegment();for(var rt=F-2;rt>=0;rt--)m.addNextSegment(C[rt],!0)}else{var Dt=In.simplify(l,_),Qt=Dt.length-1;m.initSideSegments(Dt[0],Dt[1],an.LEFT),m.addFirstSegment();for(var fe=2;fe<=Qt;fe++)m.addNextSegment(Dt[fe],!0)}m.addLastSegment()},he.prototype.getSegGen=function(l){return new Gr(this._precisionModel,this._bufParams,l)},he.prototype.interfaces_=function(){return[]},he.prototype.getClass=function(){return he},he.copyCoordinates=function(l){for(var h=new Array(l.length).fill(null),m=0;m<h.length;m++)h[m]=new B(l[m]);return h};var zo=function(){this._subgraphs=null,this._seg=new tn,this._cga=new yn,this._subgraphs=arguments[0]},jl={DepthSegment:{configurable:!0}};zo.prototype.findStabbedSegments=function(){if(1===arguments.length){for(var l=arguments[0],h=new ue,m=this._subgraphs.iterator();m.hasNext();){var _=m.next(),C=_.getEnvelope();l.y<C.getMinY()||l.y>C.getMaxY()||this.findStabbedSegments(l,_.getDirectedEdges(),h)}return h}if(3===arguments.length)if(O(arguments[2],En)&&arguments[0]instanceof B&&arguments[1]instanceof Iu){for(var F=arguments[0],rt=arguments[1],Dt=arguments[2],Qt=rt.getEdge().getCoordinates(),fe=0;fe<Qt.length-1;fe++)if(this._seg.p0=Qt[fe],this._seg.p1=Qt[fe+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),!(Math.max(this._seg.p0.x,this._seg.p1.x)<F.x||this._seg.isHorizontal()||F.y<this._seg.p0.y||F.y>this._seg.p1.y||yn.computeOrientation(this._seg.p0,this._seg.p1,F)===yn.RIGHT)){var ke=rt.getDepth(an.LEFT);this._seg.p0.equals(Qt[fe])||(ke=rt.getDepth(an.RIGHT));var Ge=new Fu(this._seg,ke);Dt.add(Ge)}}else if(O(arguments[2],En)&&arguments[0]instanceof B&&O(arguments[1],En))for(var _n=arguments[0],Un=arguments[2],ur=arguments[1].iterator();ur.hasNext();){var Ji=ur.next();Ji.isForward()&&this.findStabbedSegments(_n,Ji,Un)}},zo.prototype.getDepth=function(l){var h=this.findStabbedSegments(l);return 0===h.size()?0:Yt.min(h)._leftDepth},zo.prototype.interfaces_=function(){return[]},zo.prototype.getClass=function(){return zo},jl.DepthSegment.get=function(){return Fu},Object.defineProperties(zo,jl);var Fu=function(){this._upwardSeg=null,this._leftDepth=null;var h=arguments[1];this._upwardSeg=new tn(arguments[0]),this._leftDepth=h};Fu.prototype.compareTo=function(l){var h=l;if(this._upwardSeg.minX()>=h._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=h._upwardSeg.minX())return-1;var m=this._upwardSeg.orientationIndex(h._upwardSeg);return 0!==m||0!=(m=-1*h._upwardSeg.orientationIndex(this._upwardSeg))?m:this._upwardSeg.compareTo(h._upwardSeg)},Fu.prototype.compareX=function(l,h){var m=l.p0.compareTo(h.p0);return 0!==m?m:l.p1.compareTo(h.p1)},Fu.prototype.toString=function(){return this._upwardSeg.toString()},Fu.prototype.interfaces_=function(){return[Q]},Fu.prototype.getClass=function(){return Fu};var Br=function(l,h,m){this.p0=l||null,this.p1=h||null,this.p2=m||null};Br.prototype.area=function(){return Br.area(this.p0,this.p1,this.p2)},Br.prototype.signedArea=function(){return Br.signedArea(this.p0,this.p1,this.p2)},Br.prototype.interpolateZ=function(l){if(null===l)throw new dt("Supplied point is null.");return Br.interpolateZ(l,this.p0,this.p1,this.p2)},Br.prototype.longestSideLength=function(){return Br.longestSideLength(this.p0,this.p1,this.p2)},Br.prototype.isAcute=function(){return Br.isAcute(this.p0,this.p1,this.p2)},Br.prototype.circumcentre=function(){return Br.circumcentre(this.p0,this.p1,this.p2)},Br.prototype.area3D=function(){return Br.area3D(this.p0,this.p1,this.p2)},Br.prototype.centroid=function(){return Br.centroid(this.p0,this.p1,this.p2)},Br.prototype.inCentre=function(){return Br.inCentre(this.p0,this.p1,this.p2)},Br.prototype.interfaces_=function(){return[]},Br.prototype.getClass=function(){return Br},Br.area=function(l,h,m){return Math.abs(((m.x-l.x)*(h.y-l.y)-(h.x-l.x)*(m.y-l.y))/2)},Br.signedArea=function(l,h,m){return((m.x-l.x)*(h.y-l.y)-(h.x-l.x)*(m.y-l.y))/2},Br.det=function(l,h,m,_){return l*_-h*m},Br.interpolateZ=function(l,h,m,_){var C=h.x,F=h.y,rt=m.x-C,Dt=_.x-C,Qt=m.y-F,fe=_.y-F,ke=rt*fe-Dt*Qt,Ge=l.x-C,_n=l.y-F;return h.z+(fe*Ge-Dt*_n)/ke*(m.z-h.z)+(-Qt*Ge+rt*_n)/ke*(_.z-h.z)},Br.longestSideLength=function(l,h,m){var _=l.distance(h),C=h.distance(m),F=m.distance(l),rt=_;return C>rt&&(rt=C),F>rt&&(rt=F),rt},Br.isAcute=function(l,h,m){return!!Ir.isAcute(l,h,m)&&!!Ir.isAcute(h,m,l)&&!!Ir.isAcute(m,l,h)},Br.circumcentre=function(l,h,m){var _=m.x,C=m.y,F=l.x-_,rt=l.y-C,Dt=h.x-_,Qt=h.y-C,fe=2*Br.det(F,rt,Dt,Qt),ke=Br.det(rt,F*F+rt*rt,Qt,Dt*Dt+Qt*Qt),Ge=Br.det(F,F*F+rt*rt,Dt,Dt*Dt+Qt*Qt);return new B(_-ke/fe,C+Ge/fe)},Br.perpendicularBisector=function(l,h){var m=h.x-l.x,_=h.y-l.y,C=new Ue(l.x+m/2,l.y+_/2,1),F=new Ue(l.x-_+m/2,l.y+m+_/2,1);return new Ue(C,F)},Br.angleBisector=function(l,h,m){var _=h.distance(l),C=_/(_+h.distance(m));return new B(l.x+C*(m.x-l.x),l.y+C*(m.y-l.y))},Br.area3D=function(l,h,m){var _=h.x-l.x,C=h.y-l.y,F=h.z-l.z,rt=m.x-l.x,Dt=m.y-l.y,Qt=m.z-l.z,fe=C*Qt-F*Dt,ke=F*rt-_*Qt,Ge=_*Dt-C*rt;return Math.sqrt(fe*fe+ke*ke+Ge*Ge)/2},Br.centroid=function(l,h,m){return new B((l.x+h.x+m.x)/3,(l.y+h.y+m.y)/3)},Br.inCentre=function(l,h,m){var _=h.distance(m),C=l.distance(m),F=l.distance(h),rt=_+C+F;return new B((_*l.x+C*h.x+F*m.x)/rt,(_*l.y+C*h.y+F*m.y)/rt)};var es=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new ue;var h=arguments[1],m=arguments[2];this._inputGeom=arguments[0],this._distance=h,this._curveBuilder=m};es.prototype.addPoint=function(l){if(this._distance<=0)return null;var h=l.getCoordinates(),m=this._curveBuilder.getLineCurve(h,this._distance);this.addCurve(m,nt.EXTERIOR,nt.INTERIOR)},es.prototype.addPolygon=function(l){var h=this._distance,m=an.LEFT;this._distance<0&&(h=-this._distance,m=an.RIGHT);var _=l.getExteriorRing(),C=un.removeRepeatedPoints(_.getCoordinates());if(this._distance<0&&this.isErodedCompletely(_,this._distance)||this._distance<=0&&C.length<3)return null;this.addPolygonRing(C,h,m,nt.EXTERIOR,nt.INTERIOR);for(var F=0;F<l.getNumInteriorRing();F++){var rt=l.getInteriorRingN(F),Dt=un.removeRepeatedPoints(rt.getCoordinates());this._distance>0&&this.isErodedCompletely(rt,-this._distance)||this.addPolygonRing(Dt,h,an.opposite(m),nt.INTERIOR,nt.EXTERIOR)}},es.prototype.isTriangleErodedCompletely=function(l,h){var m=new Br(l[0],l[1],l[2]),_=m.inCentre();return yn.distancePointLine(_,m.p0,m.p1)<Math.abs(h)},es.prototype.addLineString=function(l){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;var h=un.removeRepeatedPoints(l.getCoordinates()),m=this._curveBuilder.getLineCurve(h,this._distance);this.addCurve(m,nt.EXTERIOR,nt.INTERIOR)},es.prototype.addCurve=function(l,h,m){if(null===l||l.length<2)return null;var _=new Xr(l,new We(0,nt.BOUNDARY,h,m));this._curveList.add(_)},es.prototype.getCurves=function(){return this.add(this._inputGeom),this._curveList},es.prototype.addPolygonRing=function(l,h,m,_,C){if(0===h&&l.length<eo.MINIMUM_VALID_SIZE)return null;var F=_,rt=C;l.length>=eo.MINIMUM_VALID_SIZE&&yn.isCCW(l)&&(F=C,rt=_,m=an.opposite(m));var Dt=this._curveBuilder.getRingCurve(l,m,h);this.addCurve(Dt,F,rt)},es.prototype.add=function(l){if(l.isEmpty())return null;l instanceof rs?this.addPolygon(l):l instanceof Vr?this.addLineString(l):l instanceof Ls?this.addPoint(l):(l instanceof Oa||l instanceof js||l instanceof wo||l instanceof zr)&&this.addCollection(l)},es.prototype.isErodedCompletely=function(l,h){var m=l.getCoordinates();if(m.length<4)return h<0;if(4===m.length)return this.isTriangleErodedCompletely(m,h);var _=l.getEnvelopeInternal(),C=Math.min(_.getHeight(),_.getWidth());return h<0&&2*Math.abs(h)>C},es.prototype.addCollection=function(l){for(var h=0;h<l.getNumGeometries();h++){var m=l.getGeometryN(h);this.add(m)}},es.prototype.interfaces_=function(){return[]},es.prototype.getClass=function(){return es};var ru=function(){};ru.prototype.locate=function(l){},ru.prototype.interfaces_=function(){return[]},ru.prototype.getClass=function(){return ru};var iu=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;var l=arguments[0];this._parent=l,this._atStart=!0,this._index=0,this._max=l.getNumGeometries()};iu.prototype.next=function(){if(this._atStart)return this._atStart=!1,iu.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new H;var l=this._parent.getGeometryN(this._index++);return l instanceof zr?(this._subcollectionIterator=new iu(l),this._subcollectionIterator.next()):l},iu.prototype.remove=function(){throw new Error(this.getClass().getName())},iu.prototype.hasNext=function(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)},iu.prototype.interfaces_=function(){return[Xt]},iu.prototype.getClass=function(){return iu},iu.isAtomic=function(l){return!(l instanceof zr)};var ls=function(){this._geom=null,this._geom=arguments[0]};ls.prototype.locate=function(l){return ls.locate(l,this._geom)},ls.prototype.interfaces_=function(){return[ru]},ls.prototype.getClass=function(){return ls},ls.isPointInRing=function(l,h){return!!h.getEnvelopeInternal().intersects(l)&&yn.isPointInRing(l,h.getCoordinates())},ls.containsPointInPolygon=function(l,h){if(h.isEmpty())return!1;var m=h.getExteriorRing();if(!ls.isPointInRing(l,m))return!1;for(var _=0;_<h.getNumInteriorRing();_++){var C=h.getInteriorRingN(_);if(ls.isPointInRing(l,C))return!1}return!0},ls.containsPoint=function(l,h){if(h instanceof rs)return ls.containsPointInPolygon(l,h);if(h instanceof zr)for(var m=new iu(h);m.hasNext();){var _=m.next();if(_!==h&&ls.containsPoint(l,_))return!0}return!1},ls.locate=function(l,h){return h.isEmpty()?nt.EXTERIOR:ls.containsPoint(l,h)?nt.INTERIOR:nt.EXTERIOR};var Fs=function(){this._edgeMap=new Z,this._edgeList=null,this._ptInAreaLocation=[nt.NONE,nt.NONE]};Fs.prototype.getNextCW=function(l){this.getEdges();var h=this._edgeList.indexOf(l),m=h-1;return 0===h&&(m=this._edgeList.size()-1),this._edgeList.get(m)},Fs.prototype.propagateSideLabels=function(l){for(var h=nt.NONE,m=this.iterator();m.hasNext();){var _=m.next().getLabel();_.isArea(l)&&_.getLocation(l,an.LEFT)!==nt.NONE&&(h=_.getLocation(l,an.LEFT))}if(h===nt.NONE)return null;for(var C=h,F=this.iterator();F.hasNext();){var rt=F.next(),Dt=rt.getLabel();if(Dt.getLocation(l,an.ON)===nt.NONE&&Dt.setLocation(l,an.ON,C),Dt.isArea(l)){var Qt=Dt.getLocation(l,an.LEFT),fe=Dt.getLocation(l,an.RIGHT);if(fe!==nt.NONE){if(fe!==C)throw new Ds("side location conflict",rt.getCoordinate());Qt===nt.NONE&&Nn.shouldNeverReachHere("found single null side (at "+rt.getCoordinate()+")"),C=Qt}else Nn.isTrue(Dt.getLocation(l,an.LEFT)===nt.NONE,"found single null side"),Dt.setLocation(l,an.RIGHT,C),Dt.setLocation(l,an.LEFT,C)}}},Fs.prototype.getCoordinate=function(){var l=this.iterator();return l.hasNext()?l.next().getCoordinate():null},Fs.prototype.print=function(l){Xe.out.println("EdgeEndStar:   "+this.getCoordinate());for(var h=this.iterator();h.hasNext();)h.next().print(l)},Fs.prototype.isAreaLabelsConsistent=function(l){return this.computeEdgeEndLabels(l.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},Fs.prototype.checkAreaLabelsConsistent=function(l){var h=this.getEdges();if(h.size()<=0)return!0;var m=h.size()-1,_=h.get(m).getLabel().getLocation(l,an.LEFT);Nn.isTrue(_!==nt.NONE,"Found unlabelled area edge");for(var C=_,F=this.iterator();F.hasNext();){var rt=F.next().getLabel();Nn.isTrue(rt.isArea(l),"Found non-area edge");var Dt=rt.getLocation(l,an.LEFT),Qt=rt.getLocation(l,an.RIGHT);if(Dt===Qt||Qt!==C)return!1;C=Dt}return!0},Fs.prototype.findIndex=function(l){this.iterator();for(var h=0;h<this._edgeList.size();h++)if(this._edgeList.get(h)===l)return h;return-1},Fs.prototype.iterator=function(){return this.getEdges().iterator()},Fs.prototype.getEdges=function(){return null===this._edgeList&&(this._edgeList=new ue(this._edgeMap.values())),this._edgeList},Fs.prototype.getLocation=function(l,h,m){return this._ptInAreaLocation[l]===nt.NONE&&(this._ptInAreaLocation[l]=ls.locate(h,m[l].getGeometry())),this._ptInAreaLocation[l]},Fs.prototype.toString=function(){var l=new vt;l.append("EdgeEndStar:   "+this.getCoordinate()),l.append("\n");for(var h=this.iterator();h.hasNext();){var m=h.next();l.append(m),l.append("\n")}return l.toString()},Fs.prototype.computeEdgeEndLabels=function(l){for(var h=this.iterator();h.hasNext();)h.next().computeLabel(l)},Fs.prototype.computeLabelling=function(l){this.computeEdgeEndLabels(l[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var h=[!1,!1],m=this.iterator();m.hasNext();)for(var _=m.next().getLabel(),C=0;C<2;C++)_.isLine(C)&&_.getLocation(C)===nt.BOUNDARY&&(h[C]=!0);for(var F=this.iterator();F.hasNext();)for(var rt=F.next(),Dt=rt.getLabel(),Qt=0;Qt<2;Qt++)if(Dt.isAnyNull(Qt)){var fe=nt.NONE;if(h[Qt])fe=nt.EXTERIOR;else{var ke=rt.getCoordinate();fe=this.getLocation(Qt,ke,l)}Dt.setAllLocationsIfNull(Qt,fe)}},Fs.prototype.getDegree=function(){return this._edgeMap.size()},Fs.prototype.insertEdgeEnd=function(l,h){this._edgeMap.put(l,h),this._edgeList=null},Fs.prototype.interfaces_=function(){return[]},Fs.prototype.getClass=function(){return Fs};var va=function(l){function h(){l.call(this),this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.linkResultDirectedEdges=function(){this.getResultAreaEdges();for(var m=null,_=null,C=this._SCANNING_FOR_INCOMING,F=0;F<this._resultAreaEdgeList.size();F++){var rt=this._resultAreaEdgeList.get(F),Dt=rt.getSym();if(rt.getLabel().isArea())switch(null===m&&rt.isInResult()&&(m=rt),C){case this._SCANNING_FOR_INCOMING:if(!Dt.isInResult())continue;_=Dt,C=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!rt.isInResult())continue;_.setNext(rt),C=this._SCANNING_FOR_INCOMING}}if(C===this._LINKING_TO_OUTGOING){if(null===m)throw new Ds("no outgoing dirEdge found",this.getCoordinate());Nn.isTrue(m.isInResult(),"unable to link last incoming dirEdge"),_.setNext(m)}},h.prototype.insert=function(m){this.insertEdgeEnd(m,m)},h.prototype.getRightmostEdge=function(){var m=this.getEdges(),_=m.size();if(_<1)return null;var C=m.get(0);if(1===_)return C;var F=m.get(_-1),rt=C.getQuadrant(),Dt=F.getQuadrant();return Wr.isNorthern(rt)&&Wr.isNorthern(Dt)?C:Wr.isNorthern(rt)||Wr.isNorthern(Dt)?0!==C.getDy()?C:0!==F.getDy()?F:(Nn.shouldNeverReachHere("found two horizontal edges incident on node"),null):F},h.prototype.print=function(m){Xe.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var _=this.iterator();_.hasNext();){var C=_.next();m.print("out "),C.print(m),m.println(),m.print("in "),C.getSym().print(m),m.println()}},h.prototype.getResultAreaEdges=function(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new ue;for(var m=this.iterator();m.hasNext();){var _=m.next();(_.isInResult()||_.getSym().isInResult())&&this._resultAreaEdgeList.add(_)}return this._resultAreaEdgeList},h.prototype.updateLabelling=function(m){for(var _=this.iterator();_.hasNext();){var C=_.next().getLabel();C.setAllLocationsIfNull(0,m.getLocation(0)),C.setAllLocationsIfNull(1,m.getLocation(1))}},h.prototype.linkAllDirectedEdges=function(){this.getEdges();for(var m=null,_=null,C=this._edgeList.size()-1;C>=0;C--){var F=this._edgeList.get(C),rt=F.getSym();null===_&&(_=rt),null!==m&&rt.setNext(m),m=F}_.setNext(m)},h.prototype.computeDepths=function(){if(1===arguments.length){var m=arguments[0],_=this.findIndex(m),C=m.getDepth(an.LEFT),F=m.getDepth(an.RIGHT),rt=this.computeDepths(_+1,this._edgeList.size(),C);if(this.computeDepths(0,_,rt)!==F)throw new Ds("depth mismatch at "+m.getCoordinate())}else if(3===arguments.length){for(var Qt=arguments[1],fe=arguments[2],ke=arguments[0];ke<Qt;ke++){var Ge=this._edgeList.get(ke);Ge.setEdgeDepths(an.RIGHT,fe),fe=Ge.getDepth(an.LEFT)}return fe}},h.prototype.mergeSymLabels=function(){for(var m=this.iterator();m.hasNext();){var _=m.next();_.getLabel().merge(_.getSym().getLabel())}},h.prototype.linkMinimalDirectedEdges=function(m){for(var _=null,C=null,F=this._SCANNING_FOR_INCOMING,rt=this._resultAreaEdgeList.size()-1;rt>=0;rt--){var Dt=this._resultAreaEdgeList.get(rt),Qt=Dt.getSym();switch(null===_&&Dt.getEdgeRing()===m&&(_=Dt),F){case this._SCANNING_FOR_INCOMING:if(Qt.getEdgeRing()!==m)continue;C=Qt,F=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(Dt.getEdgeRing()!==m)continue;C.setNextMin(Dt),F=this._SCANNING_FOR_INCOMING}}F===this._LINKING_TO_OUTGOING&&(Nn.isTrue(null!==_,"found null for first outgoing dirEdge"),Nn.isTrue(_.getEdgeRing()===m,"unable to link last incoming dirEdge"),C.setNextMin(_))},h.prototype.getOutgoingDegree=function(){if(0===arguments.length){for(var m=0,_=this.iterator();_.hasNext();)_.next().isInResult()&&m++;return m}if(1===arguments.length){for(var C=arguments[0],F=0,rt=this.iterator();rt.hasNext();)rt.next().getEdgeRing()===C&&F++;return F}},h.prototype.getLabel=function(){return this._label},h.prototype.findCoveredLineEdges=function(){for(var m=nt.NONE,_=this.iterator();_.hasNext();){var C=_.next(),F=C.getSym();if(!C.isLineEdge()){if(C.isInResult()){m=nt.INTERIOR;break}if(F.isInResult()){m=nt.EXTERIOR;break}}}if(m===nt.NONE)return null;for(var rt=m,Dt=this.iterator();Dt.hasNext();){var Qt=Dt.next(),fe=Qt.getSym();Qt.isLineEdge()?Qt.getEdge().setCovered(rt===nt.INTERIOR):(Qt.isInResult()&&(rt=nt.EXTERIOR),fe.isInResult()&&(rt=nt.INTERIOR))}},h.prototype.computeLabelling=function(m){l.prototype.computeLabelling.call(this,m),this._label=new We(nt.NONE);for(var _=this.iterator();_.hasNext();)for(var C=_.next().getEdge().getLabel(),F=0;F<2;F++){var rt=C.getLocation(F);rt!==nt.INTERIOR&&rt!==nt.BOUNDARY||this._label.setLocation(F,nt.INTERIOR)}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Fs),Vo=function(l){function h(){l.apply(this,arguments)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.createNode=function(m){return new Pr(m,new va)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}($o),_a=function l(){this._pts=null,this._orientation=null;var h=arguments[0];this._pts=h,this._orientation=l.orientation(h)};_a.prototype.compareTo=function(l){return _a.compareOriented(this._pts,this._orientation,l._pts,l._orientation)},_a.prototype.interfaces_=function(){return[Q]},_a.prototype.getClass=function(){return _a},_a.orientation=function(l){return 1===un.increasingDirection(l)},_a.compareOriented=function(l,h,m,_){for(var C=h?1:-1,F=_?1:-1,rt=h?l.length:-1,Dt=_?m.length:-1,Qt=h?0:l.length-1,fe=_?0:m.length-1;;){var ke=l[Qt].compareTo(m[fe]);if(0!==ke)return ke;var Ge=(Qt+=C)===rt,_n=(fe+=F)===Dt;if(Ge&&!_n)return-1;if(!Ge&&_n)return 1;if(Ge&&_n)return 0}};var po=function(){this._edges=new ue,this._ocaMap=new Z};po.prototype.print=function(l){l.print("MULTILINESTRING ( ");for(var h=0;h<this._edges.size();h++){var m=this._edges.get(h);h>0&&l.print(","),l.print("(");for(var _=m.getCoordinates(),C=0;C<_.length;C++)C>0&&l.print(","),l.print(_[C].x+" "+_[C].y);l.println(")")}l.print(")  ")},po.prototype.addAll=function(l){for(var h=l.iterator();h.hasNext();)this.add(h.next())},po.prototype.findEdgeIndex=function(l){for(var h=0;h<this._edges.size();h++)if(this._edges.get(h).equals(l))return h;return-1},po.prototype.iterator=function(){return this._edges.iterator()},po.prototype.getEdges=function(){return this._edges},po.prototype.get=function(l){return this._edges.get(l)},po.prototype.findEqualEdge=function(l){var h=new _a(l.getCoordinates());return this._ocaMap.get(h)},po.prototype.add=function(l){this._edges.add(l);var h=new _a(l.getCoordinates());this._ocaMap.put(h,l)},po.prototype.interfaces_=function(){return[]},po.prototype.getClass=function(){return po};var Jo=function(){};Jo.prototype.processIntersections=function(l,h,m,_){},Jo.prototype.isDone=function(){},Jo.prototype.interfaces_=function(){return[]},Jo.prototype.getClass=function(){return Jo};var Wn=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0,this._li=arguments[0]};Wn.prototype.isTrivialIntersection=function(l,h,m,_){if(l===m&&1===this._li.getIntersectionNum()){if(Wn.isAdjacentSegments(h,_))return!0;if(l.isClosed()){var C=l.size()-1;if(0===h&&_===C||0===_&&h===C)return!0}}return!1},Wn.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},Wn.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},Wn.prototype.getLineIntersector=function(){return this._li},Wn.prototype.hasProperIntersection=function(){return this._hasProper},Wn.prototype.processIntersections=function(l,h,m,_){if(l===m&&h===_)return null;this.numTests++;var C=l.getCoordinates()[h],F=l.getCoordinates()[h+1],rt=m.getCoordinates()[_],Dt=m.getCoordinates()[_+1];this._li.computeIntersection(C,F,rt,Dt),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(l,h,m,_)||(this._hasIntersection=!0,l.addIntersections(this._li,h,0),m.addIntersections(this._li,_,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))},Wn.prototype.hasIntersection=function(){return this._hasIntersection},Wn.prototype.isDone=function(){return!1},Wn.prototype.hasInteriorIntersection=function(){return this._hasInterior},Wn.prototype.interfaces_=function(){return[Jo]},Wn.prototype.getClass=function(){return Wn},Wn.isAdjacentSegments=function(l,h){return 1===Math.abs(l-h)};var Mo=function(){this.coord=null,this.segmentIndex=null,this.dist=null;var h=arguments[1],m=arguments[2];this.coord=new B(arguments[0]),this.segmentIndex=h,this.dist=m};Mo.prototype.getSegmentIndex=function(){return this.segmentIndex},Mo.prototype.getCoordinate=function(){return this.coord},Mo.prototype.print=function(l){l.print(this.coord),l.print(" seg # = "+this.segmentIndex),l.println(" dist = "+this.dist)},Mo.prototype.compareTo=function(l){return this.compare(l.segmentIndex,l.dist)},Mo.prototype.isEndPoint=function(l){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===l},Mo.prototype.toString=function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},Mo.prototype.getDistance=function(){return this.dist},Mo.prototype.compare=function(l,h){return this.segmentIndex<l?-1:this.segmentIndex>l?1:this.dist<h?-1:this.dist>h?1:0},Mo.prototype.interfaces_=function(){return[Q]},Mo.prototype.getClass=function(){return Mo};var Mn=function(){this._nodeMap=new Z,this.edge=null,this.edge=arguments[0]};Mn.prototype.print=function(l){l.println("Intersections:");for(var h=this.iterator();h.hasNext();)h.next().print(l)},Mn.prototype.iterator=function(){return this._nodeMap.values().iterator()},Mn.prototype.addSplitEdges=function(l){this.addEndpoints();for(var h=this.iterator(),m=h.next();h.hasNext();){var _=h.next(),C=this.createSplitEdge(m,_);l.add(C),m=_}},Mn.prototype.addEndpoints=function(){var l=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[l],l,0)},Mn.prototype.createSplitEdge=function(l,h){var m=h.segmentIndex-l.segmentIndex+2,C=h.dist>0||!h.coord.equals2D(this.edge.pts[h.segmentIndex]);C||m--;var F=new Array(m).fill(null),rt=0;F[rt++]=new B(l.coord);for(var Dt=l.segmentIndex+1;Dt<=h.segmentIndex;Dt++)F[rt++]=this.edge.pts[Dt];return C&&(F[rt]=h.coord),new su(F,new We(this.edge._label))},Mn.prototype.add=function(l,h,m){var _=new Mo(l,h,m),C=this._nodeMap.get(_);return null!==C?C:(this._nodeMap.put(_,_),_)},Mn.prototype.isIntersection=function(l){for(var h=this.iterator();h.hasNext();)if(h.next().coord.equals(l))return!0;return!1},Mn.prototype.interfaces_=function(){return[]},Mn.prototype.getClass=function(){return Mn};var la=function(){};la.prototype.getChainStartIndices=function(l){var h=0,m=new ue;m.add(new xt(h));do{var _=this.findChainEnd(l,h);m.add(new xt(_)),h=_}while(h<l.length-1);return la.toIntArray(m)},la.prototype.findChainEnd=function(l,h){for(var m=Wr.quadrant(l[h],l[h+1]),_=h+1;_<l.length&&Wr.quadrant(l[_-1],l[_])===m;)_++;return _-1},la.prototype.interfaces_=function(){return[]},la.prototype.getClass=function(){return la},la.toIntArray=function(l){for(var h=new Array(l.size()).fill(null),m=0;m<h.length;m++)h[m]=l.get(m).intValue();return h};var xa=function(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new De,this.env2=new De;var l=arguments[0];this.e=l,this.pts=l.getCoordinates();var h=new la;this.startIndex=h.getChainStartIndices(this.pts)};xa.prototype.getCoordinates=function(){return this.pts},xa.prototype.getMaxX=function(l){var h=this.pts[this.startIndex[l]].x,m=this.pts[this.startIndex[l+1]].x;return h>m?h:m},xa.prototype.getMinX=function(l){var h=this.pts[this.startIndex[l]].x,m=this.pts[this.startIndex[l+1]].x;return h<m?h:m},xa.prototype.computeIntersectsForChain=function(){if(4===arguments.length){var l=arguments[0],h=arguments[1],m=arguments[2];this.computeIntersectsForChain(this.startIndex[l],this.startIndex[l+1],h,h.startIndex[m],h.startIndex[m+1],arguments[3])}else if(6===arguments.length){var C=arguments[0],F=arguments[1],rt=arguments[2],Dt=arguments[3],Qt=arguments[4],fe=arguments[5],ke=this.pts[C],Ge=this.pts[F],_n=rt.pts[Dt],Sn=rt.pts[Qt];if(F-C==1&&Qt-Dt==1)return fe.addIntersections(this.e,C,rt.e,Dt),null;if(this.env1.init(ke,Ge),this.env2.init(_n,Sn),!this.env1.intersects(this.env2))return null;var Un=Math.trunc((C+F)/2),ur=Math.trunc((Dt+Qt)/2);C<Un&&(Dt<ur&&this.computeIntersectsForChain(C,Un,rt,Dt,ur,fe),ur<Qt&&this.computeIntersectsForChain(C,Un,rt,ur,Qt,fe)),Un<F&&(Dt<ur&&this.computeIntersectsForChain(Un,F,rt,Dt,ur,fe),ur<Qt&&this.computeIntersectsForChain(Un,F,rt,ur,Qt,fe))}},xa.prototype.getStartIndexes=function(){return this.startIndex},xa.prototype.computeIntersects=function(l,h){for(var m=0;m<this.startIndex.length-1;m++)for(var _=0;_<l.startIndex.length-1;_++)this.computeIntersectsForChain(m,l,_,h)},xa.prototype.interfaces_=function(){return[]},xa.prototype.getClass=function(){return xa};var cs=function l(){this._depth=Array(2).fill().map(function(){return Array(3)});for(var h=0;h<2;h++)for(var m=0;m<3;m++)this._depth[h][m]=l.NULL_VALUE},mo={NULL_VALUE:{configurable:!0}};cs.prototype.getDepth=function(l,h){return this._depth[l][h]},cs.prototype.setDepth=function(l,h,m){this._depth[l][h]=m},cs.prototype.isNull=function(){if(0===arguments.length){for(var l=0;l<2;l++)for(var h=0;h<3;h++)if(this._depth[l][h]!==cs.NULL_VALUE)return!1;return!0}return 1===arguments.length?this._depth[arguments[0]][1]===cs.NULL_VALUE:2===arguments.length?this._depth[arguments[0]][arguments[1]]===cs.NULL_VALUE:void 0},cs.prototype.normalize=function(){for(var l=0;l<2;l++)if(!this.isNull(l)){var h=this._depth[l][1];this._depth[l][2]<h&&(h=this._depth[l][2]),h<0&&(h=0);for(var m=1;m<3;m++){var _=0;this._depth[l][m]>h&&(_=1),this._depth[l][m]=_}}},cs.prototype.getDelta=function(l){return this._depth[l][an.RIGHT]-this._depth[l][an.LEFT]},cs.prototype.getLocation=function(l,h){return this._depth[l][h]<=0?nt.EXTERIOR:nt.INTERIOR},cs.prototype.toString=function(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]},cs.prototype.add=function(){if(1===arguments.length)for(var l=arguments[0],h=0;h<2;h++)for(var m=1;m<3;m++){var _=l.getLocation(h,m);_!==nt.EXTERIOR&&_!==nt.INTERIOR||(this.isNull(h,m)?this._depth[h][m]=cs.depthAtLocation(_):this._depth[h][m]+=cs.depthAtLocation(_))}else 3===arguments.length&&arguments[2]===nt.INTERIOR&&this._depth[arguments[0]][arguments[1]]++},cs.prototype.interfaces_=function(){return[]},cs.prototype.getClass=function(){return cs},cs.depthAtLocation=function(l){return l===nt.EXTERIOR?0:l===nt.INTERIOR?1:cs.NULL_VALUE},mo.NULL_VALUE.get=function(){return-1},Object.defineProperties(cs,mo);var su=function(l){function h(){if(l.call(this),this.pts=null,this._env=null,this.eiList=new Mn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new cs,this._depthDelta=0,1===arguments.length)h.call(this,arguments[0],null);else if(2===arguments.length){var C=arguments[1];this.pts=arguments[0],this._label=C}}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.getDepth=function(){return this._depth},h.prototype.getCollapsedEdge=function(){var m=new Array(2).fill(null);return m[0]=this.pts[0],m[1]=this.pts[1],new h(m,We.toLineLabel(this._label))},h.prototype.isIsolated=function(){return this._isIsolated},h.prototype.getCoordinates=function(){return this.pts},h.prototype.setIsolated=function(m){this._isIsolated=m},h.prototype.setName=function(m){this._name=m},h.prototype.equals=function(m){if(!(m instanceof h))return!1;var _=m;if(this.pts.length!==_.pts.length)return!1;for(var C=!0,F=!0,rt=this.pts.length,Dt=0;Dt<this.pts.length;Dt++)if(this.pts[Dt].equals2D(_.pts[Dt])||(C=!1),this.pts[Dt].equals2D(_.pts[--rt])||(F=!1),!C&&!F)return!1;return!0},h.prototype.getCoordinate=function(){return 0===arguments.length?this.pts.length>0?this.pts[0]:null:1===arguments.length?this.pts[arguments[0]]:void 0},h.prototype.print=function(m){m.print("edge "+this._name+": "),m.print("LINESTRING (");for(var _=0;_<this.pts.length;_++)_>0&&m.print(","),m.print(this.pts[_].x+" "+this.pts[_].y);m.print(")  "+this._label+" "+this._depthDelta)},h.prototype.computeIM=function(m){h.updateIM(this._label,m)},h.prototype.isCollapsed=function(){return!!this._label.isArea()&&3===this.pts.length&&!!this.pts[0].equals(this.pts[2])},h.prototype.isClosed=function(){return this.pts[0].equals(this.pts[this.pts.length-1])},h.prototype.getMaximumSegmentIndex=function(){return this.pts.length-1},h.prototype.getDepthDelta=function(){return this._depthDelta},h.prototype.getNumPoints=function(){return this.pts.length},h.prototype.printReverse=function(m){m.print("edge "+this._name+": ");for(var _=this.pts.length-1;_>=0;_--)m.print(this.pts[_]+" ");m.println("")},h.prototype.getMonotoneChainEdge=function(){return null===this._mce&&(this._mce=new xa(this)),this._mce},h.prototype.getEnvelope=function(){if(null===this._env){this._env=new De;for(var m=0;m<this.pts.length;m++)this._env.expandToInclude(this.pts[m])}return this._env},h.prototype.addIntersection=function(m,_,C,F){var rt=new B(m.getIntersection(F)),Dt=_,Qt=m.getEdgeDistance(C,F),fe=Dt+1;fe<this.pts.length&&rt.equals2D(this.pts[fe])&&(Dt=fe,Qt=0),this.eiList.add(rt,Dt,Qt)},h.prototype.toString=function(){var m=new vt;m.append("edge "+this._name+": "),m.append("LINESTRING (");for(var _=0;_<this.pts.length;_++)_>0&&m.append(","),m.append(this.pts[_].x+" "+this.pts[_].y);return m.append(")  "+this._label+" "+this._depthDelta),m.toString()},h.prototype.isPointwiseEqual=function(m){if(this.pts.length!==m.pts.length)return!1;for(var _=0;_<this.pts.length;_++)if(!this.pts[_].equals2D(m.pts[_]))return!1;return!0},h.prototype.setDepthDelta=function(m){this._depthDelta=m},h.prototype.getEdgeIntersectionList=function(){return this.eiList},h.prototype.addIntersections=function(m,_,C){for(var F=0;F<m.getIntersectionNum();F++)this.addIntersection(m,_,C,F)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.updateIM=function(){if(2!==arguments.length)return l.prototype.updateIM.apply(this,arguments);var m=arguments[0],_=arguments[1];_.setAtLeastIfValid(m.getLocation(0,an.ON),m.getLocation(1,an.ON),1),m.isArea()&&(_.setAtLeastIfValid(m.getLocation(0,an.LEFT),m.getLocation(1,an.LEFT),2),_.setAtLeastIfValid(m.getLocation(0,an.RIGHT),m.getLocation(1,an.RIGHT),2))},h}(Kn),Ys=function(l){this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new po,this._bufParams=l||null};Ys.prototype.setWorkingPrecisionModel=function(l){this._workingPrecisionModel=l},Ys.prototype.insertUniqueEdge=function(l){var h=this._edgeList.findEqualEdge(l);if(null!==h){var m=h.getLabel(),_=l.getLabel();h.isPointwiseEqual(l)||(_=new We(l.getLabel())).flip(),m.merge(_);var C=Ys.depthDelta(_),F=h.getDepthDelta()+C;h.setDepthDelta(F)}else this._edgeList.add(l),l.setDepthDelta(Ys.depthDelta(l.getLabel()))},Ys.prototype.buildSubgraphs=function(l,h){for(var m=new ue,_=l.iterator();_.hasNext();){var C=_.next(),F=C.getRightmostCoordinate(),rt=new zo(m).getDepth(F);C.computeDepth(rt),C.findResultEdges(),m.add(C),h.add(C.getDirectedEdges(),C.getNodes())}},Ys.prototype.createSubgraphs=function(l){for(var h=new ue,m=l.getNodes().iterator();m.hasNext();){var _=m.next();if(!_.isVisited()){var C=new ks;C.create(_),h.add(C)}}return Yt.sort(h,Yt.reverseOrder()),h},Ys.prototype.createEmptyResultGeometry=function(){return this._geomFact.createPolygon()},Ys.prototype.getNoder=function(l){if(null!==this._workingNoder)return this._workingNoder;var h=new Rc,m=new di;return m.setPrecisionModel(l),h.setSegmentIntersector(new Wn(m)),h},Ys.prototype.buffer=function(l,h){var m=this._workingPrecisionModel;null===m&&(m=l.getPrecisionModel()),this._geomFact=l.getFactory();var _=new he(m,this._bufParams),C=new es(l,h,_).getCurves();if(C.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(C,m),this._graph=new Or(new Vo),this._graph.addEdges(this._edgeList.getEdges());var F=this.createSubgraphs(this._graph),rt=new as(this._geomFact);this.buildSubgraphs(F,rt);var Dt=rt.getPolygons();return Dt.size()<=0?this.createEmptyResultGeometry():this._geomFact.buildGeometry(Dt)},Ys.prototype.computeNodedEdges=function(l,h){var m=this.getNoder(h);m.computeNodes(l);for(var _=m.getNodedSubstrings().iterator();_.hasNext();){var C=_.next(),F=C.getCoordinates();if(2!==F.length||!F[0].equals2D(F[1])){var rt=C.getData(),Dt=new su(C.getCoordinates(),new We(rt));this.insertUniqueEdge(Dt)}}},Ys.prototype.setNoder=function(l){this._workingNoder=l},Ys.prototype.interfaces_=function(){return[]},Ys.prototype.getClass=function(){return Ys},Ys.depthDelta=function(l){var h=l.getLocation(0,an.LEFT),m=l.getLocation(0,an.RIGHT);return h===nt.INTERIOR&&m===nt.EXTERIOR?1:h===nt.EXTERIOR&&m===nt.INTERIOR?-1:0},Ys.convertSegStrings=function(l){for(var h=new nr,m=new ue;l.hasNext();){var _=l.next(),C=h.createLineString(_.getCoordinates());m.add(C)}return h.buildGeometry(m)};var $s=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){var h=arguments[1];this._noder=arguments[0],this._scaleFactor=h,this._offsetX=0,this._offsetY=0,this._isScaled=!this.isIntegerPrecision()}else if(4===arguments.length){var _=arguments[1],C=arguments[2],F=arguments[3];this._noder=arguments[0],this._scaleFactor=_,this._offsetX=C,this._offsetY=F,this._isScaled=!this.isIntegerPrecision()}};$s.prototype.rescale=function(){if(O(arguments[0],je))for(var l=arguments[0].iterator();l.hasNext();){var h=l.next();this.rescale(h.getCoordinates())}else if(arguments[0]instanceof Array){for(var m=arguments[0],_=0;_<m.length;_++)m[_].x=m[_].x/this._scaleFactor+this._offsetX,m[_].y=m[_].y/this._scaleFactor+this._offsetY;2===m.length&&m[0].equals2D(m[1])&&Xe.out.println(m)}},$s.prototype.scale=function(){if(O(arguments[0],je)){for(var l=arguments[0],h=new ue,m=l.iterator();m.hasNext();){var _=m.next();h.add(new Xr(this.scale(_.getCoordinates()),_.getData()))}return h}if(arguments[0]instanceof Array){for(var C=arguments[0],F=new Array(C.length).fill(null),rt=0;rt<C.length;rt++)F[rt]=new B(Math.round((C[rt].x-this._offsetX)*this._scaleFactor),Math.round((C[rt].y-this._offsetY)*this._scaleFactor),C[rt].z);return un.removeRepeatedPoints(F)}},$s.prototype.isIntegerPrecision=function(){return 1===this._scaleFactor},$s.prototype.getNodedSubstrings=function(){var l=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(l),l},$s.prototype.computeNodes=function(l){var h=l;this._isScaled&&(h=this.scale(l)),this._noder.computeNodes(h)},$s.prototype.interfaces_=function(){return[vs]},$s.prototype.getClass=function(){return $s};var Uo=function(){this._li=new di,this._segStrings=null,this._segStrings=arguments[0]},Ea={fact:{configurable:!0}};Uo.prototype.checkEndPtVertexIntersections=function(){if(0===arguments.length)for(var l=this._segStrings.iterator();l.hasNext();){var h=l.next().getCoordinates();this.checkEndPtVertexIntersections(h[0],this._segStrings),this.checkEndPtVertexIntersections(h[h.length-1],this._segStrings)}else if(2===arguments.length)for(var m=arguments[0],_=arguments[1].iterator();_.hasNext();)for(var C=_.next().getCoordinates(),F=1;F<C.length-1;F++)if(C[F].equals(m))throw new Gn("found endpt/interior pt intersection at index "+F+" :pt "+m)},Uo.prototype.checkInteriorIntersections=function(){if(0===arguments.length)for(var l=this._segStrings.iterator();l.hasNext();)for(var h=l.next(),m=this._segStrings.iterator();m.hasNext();){var _=m.next();this.checkInteriorIntersections(h,_)}else if(2===arguments.length)for(var C=arguments[0],F=arguments[1],rt=C.getCoordinates(),Dt=F.getCoordinates(),Qt=0;Qt<rt.length-1;Qt++)for(var fe=0;fe<Dt.length-1;fe++)this.checkInteriorIntersections(C,Qt,F,fe);else if(4===arguments.length){var ke=arguments[0],Ge=arguments[1],_n=arguments[2],Sn=arguments[3];if(ke===_n&&Ge===Sn)return null;var Un=ke.getCoordinates()[Ge],ur=ke.getCoordinates()[Ge+1],Ji=_n.getCoordinates()[Sn],To=_n.getCoordinates()[Sn+1];if(this._li.computeIntersection(Un,ur,Ji,To),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,Un,ur)||this.hasInteriorIntersection(this._li,Ji,To)))throw new Gn("found non-noded intersection at "+Un+"-"+ur+" and "+Ji+"-"+To)}},Uo.prototype.checkValid=function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},Uo.prototype.checkCollapses=function(){if(0===arguments.length)for(var l=this._segStrings.iterator();l.hasNext();){var h=l.next();this.checkCollapses(h)}else if(1===arguments.length)for(var m=arguments[0].getCoordinates(),_=0;_<m.length-2;_++)this.checkCollapse(m[_],m[_+1],m[_+2])},Uo.prototype.hasInteriorIntersection=function(l,h,m){for(var _=0;_<l.getIntersectionNum();_++){var C=l.getIntersection(_);if(!C.equals(h)&&!C.equals(m))return!0}return!1},Uo.prototype.checkCollapse=function(l,h,m){if(l.equals(m))throw new Gn("found non-noded collapse at "+Uo.fact.createLineString([l,h,m]))},Uo.prototype.interfaces_=function(){return[]},Uo.prototype.getClass=function(){return Uo},Ea.fact.get=function(){return new nr},Object.defineProperties(Uo,Ea);var mi=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;var l=arguments[0],h=arguments[1],m=arguments[2];if(this._originalPt=l,this._pt=l,this._scaleFactor=h,this._li=m,h<=0)throw new dt("Scale factor must be non-zero");1!==h&&(this._pt=new B(this.scale(l.x),this.scale(l.y)),this._p0Scaled=new B,this._p1Scaled=new B),this.initCorners(this._pt)},yi={SAFE_ENV_EXPANSION_FACTOR:{configurable:!0}};mi.prototype.intersectsScaled=function(l,h){var m=Math.min(l.x,h.x),_=Math.max(l.x,h.x),C=Math.min(l.y,h.y),F=Math.max(l.y,h.y),rt=this._maxx<m||this._minx>_||this._maxy<C||this._miny>F;if(rt)return!1;var Dt=this.intersectsToleranceSquare(l,h);return Nn.isTrue(!(rt&&Dt),"Found bad envelope test"),Dt},mi.prototype.initCorners=function(l){this._minx=l.x-.5,this._maxx=l.x+.5,this._miny=l.y-.5,this._maxy=l.y+.5,this._corner[0]=new B(this._maxx,this._maxy),this._corner[1]=new B(this._minx,this._maxy),this._corner[2]=new B(this._minx,this._miny),this._corner[3]=new B(this._maxx,this._miny)},mi.prototype.intersects=function(l,h){return 1===this._scaleFactor?this.intersectsScaled(l,h):(this.copyScaled(l,this._p0Scaled),this.copyScaled(h,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))},mi.prototype.scale=function(l){return Math.round(l*this._scaleFactor)},mi.prototype.getCoordinate=function(){return this._originalPt},mi.prototype.copyScaled=function(l,h){h.x=this.scale(l.x),h.y=this.scale(l.y)},mi.prototype.getSafeEnvelope=function(){if(null===this._safeEnv){var l=mi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new De(this._originalPt.x-l,this._originalPt.x+l,this._originalPt.y-l,this._originalPt.y+l)}return this._safeEnv},mi.prototype.intersectsPixelClosure=function(l,h){return this._li.computeIntersection(l,h,this._corner[0],this._corner[1]),!!(this._li.hasIntersection()||(this._li.computeIntersection(l,h,this._corner[1],this._corner[2]),this._li.hasIntersection()||(this._li.computeIntersection(l,h,this._corner[2],this._corner[3]),this._li.hasIntersection()||(this._li.computeIntersection(l,h,this._corner[3],this._corner[0]),this._li.hasIntersection()))))},mi.prototype.intersectsToleranceSquare=function(l,h){var m=!1,_=!1;return this._li.computeIntersection(l,h,this._corner[0],this._corner[1]),!!(this._li.isProper()||(this._li.computeIntersection(l,h,this._corner[1],this._corner[2]),this._li.isProper()||(this._li.hasIntersection()&&(m=!0),this._li.computeIntersection(l,h,this._corner[2],this._corner[3]),this._li.isProper()||(this._li.hasIntersection()&&(_=!0),this._li.computeIntersection(l,h,this._corner[3],this._corner[0]),this._li.isProper()||m&&_||l.equals(this._pt)||h.equals(this._pt)))))},mi.prototype.addSnappedNode=function(l,h){var m=l.getCoordinate(h),_=l.getCoordinate(h+1);return!!this.intersects(m,_)&&(l.addIntersection(this.getCoordinate(),h),!0)},mi.prototype.interfaces_=function(){return[]},mi.prototype.getClass=function(){return mi},yi.SAFE_ENV_EXPANSION_FACTOR.get=function(){return.75},Object.defineProperties(mi,yi);var ka=function(){this.tempEnv1=new De,this.selectedSegment=new tn};ka.prototype.select=function(){1!==arguments.length&&2===arguments.length&&(arguments[0].getLineSegment(arguments[1],this.selectedSegment),this.select(this.selectedSegment))},ka.prototype.interfaces_=function(){return[]},ka.prototype.getClass=function(){return ka};var Du=function(){this._index=null,this._index=arguments[0]},Ha={HotPixelSnapAction:{configurable:!0}};Du.prototype.snap=function(){if(1===arguments.length)return this.snap(arguments[0],null,-1);if(3===arguments.length){var h=arguments[0],m=arguments[1],_=arguments[2],C=h.getSafeEnvelope(),F=new pl(h,m,_);return this._index.query(C,{interfaces_:function(){return[M]},visitItem:function(rt){rt.select(C,F)}}),F.isNodeAdded()}},Du.prototype.interfaces_=function(){return[]},Du.prototype.getClass=function(){return Du},Ha.HotPixelSnapAction.get=function(){return pl},Object.defineProperties(Du,Ha);var pl=function(l){function h(){l.call(this),this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;var _=arguments[1],C=arguments[2];this._hotPixel=arguments[0],this._parentEdge=_,this._hotPixelVertexIndex=C}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.isNodeAdded=function(){return this._isNodeAdded},h.prototype.select=function(){if(2!==arguments.length)return l.prototype.select.apply(this,arguments);var _=arguments[1],C=arguments[0].getContext();if(null!==this._parentEdge&&C===this._parentEdge&&_===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(C,_)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(ka),ta=function(){this._li=null,this._interiorIntersections=null,this._li=arguments[0],this._interiorIntersections=new ue};ta.prototype.processIntersections=function(l,h,m,_){if(l===m&&h===_)return null;var C=l.getCoordinates()[h],F=l.getCoordinates()[h+1],rt=m.getCoordinates()[_],Dt=m.getCoordinates()[_+1];if(this._li.computeIntersection(C,F,rt,Dt),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(var Qt=0;Qt<this._li.getIntersectionNum();Qt++)this._interiorIntersections.add(this._li.getIntersection(Qt));l.addIntersections(this._li,h,0),m.addIntersections(this._li,_,1)}},ta.prototype.isDone=function(){return!1},ta.prototype.getInteriorIntersections=function(){return this._interiorIntersections},ta.prototype.interfaces_=function(){return[Jo]},ta.prototype.getClass=function(){return ta};var Wo=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;var l=arguments[0];this._pm=l,this._li=new di,this._li.setPrecisionModel(l),this._scaleFactor=l.getScale()};Wo.prototype.checkCorrectness=function(l){var h=Xr.getNodedSubstrings(l),m=new Uo(h);try{m.checkValid()}catch(_){if(!(_ instanceof be))throw _;_.printStackTrace()}},Wo.prototype.getNodedSubstrings=function(){return Xr.getNodedSubstrings(this._nodedSegStrings)},Wo.prototype.snapRound=function(l,h){var m=this.findInteriorIntersections(l,h);this.computeIntersectionSnaps(m),this.computeVertexSnaps(l)},Wo.prototype.findInteriorIntersections=function(l,h){var m=new ta(h);return this._noder.setSegmentIntersector(m),this._noder.computeNodes(l),m.getInteriorIntersections()},Wo.prototype.computeVertexSnaps=function(){if(O(arguments[0],je))for(var l=arguments[0].iterator();l.hasNext();){var h=l.next();this.computeVertexSnaps(h)}else if(arguments[0]instanceof Xr)for(var m=arguments[0],_=m.getCoordinates(),C=0;C<_.length;C++){var F=new mi(_[C],this._scaleFactor,this._li);this._pointSnapper.snap(F,m,C)&&m.addIntersection(_[C],C)}},Wo.prototype.computeNodes=function(l){this._nodedSegStrings=l,this._noder=new Rc,this._pointSnapper=new Du(this._noder.getIndex()),this.snapRound(l,this._li)},Wo.prototype.computeIntersectionSnaps=function(l){for(var h=l.iterator();h.hasNext();){var m=h.next(),_=new mi(m,this._scaleFactor,this._li);this._pointSnapper.snap(_)}},Wo.prototype.interfaces_=function(){return[vs]},Wo.prototype.getClass=function(){return Wo};var Ns=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new Zr,this._resultGeometry=null,this._saveException=null,1===arguments.length)this._argGeom=arguments[0];else if(2===arguments.length){var m=arguments[1];this._argGeom=arguments[0],this._bufParams=m}},Tu={CAP_ROUND:{configurable:!0},CAP_BUTT:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},MAX_PRECISION_DIGITS:{configurable:!0}};Ns.prototype.bufferFixedPrecision=function(l){var h=new $s(new Wo(new An(1)),l.getScale()),m=new Ys(this._bufParams);m.setWorkingPrecisionModel(l),m.setNoder(h),this._resultGeometry=m.buffer(this._argGeom,this._distance)},Ns.prototype.bufferReducedPrecision=function(){var l=this;if(0===arguments.length){for(var h=Ns.MAX_PRECISION_DIGITS;h>=0;h--){try{l.bufferReducedPrecision(h)}catch(F){if(!(F instanceof Ds))throw F;l._saveException=F}if(null!==l._resultGeometry)return null}throw this._saveException}if(1===arguments.length){var _=Ns.precisionScaleFactor(this._argGeom,this._distance,arguments[0]),C=new An(_);this.bufferFixedPrecision(C)}},Ns.prototype.computeGeometry=function(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;var l=this._argGeom.getFactory().getPrecisionModel();l.getType()===An.FIXED?this.bufferFixedPrecision(l):this.bufferReducedPrecision()},Ns.prototype.setQuadrantSegments=function(l){this._bufParams.setQuadrantSegments(l)},Ns.prototype.bufferOriginalPrecision=function(){try{var l=new Ys(this._bufParams);this._resultGeometry=l.buffer(this._argGeom,this._distance)}catch(h){if(!(h instanceof Gn))throw h;this._saveException=h}},Ns.prototype.getResultGeometry=function(l){return this._distance=l,this.computeGeometry(),this._resultGeometry},Ns.prototype.setEndCapStyle=function(l){this._bufParams.setEndCapStyle(l)},Ns.prototype.interfaces_=function(){return[]},Ns.prototype.getClass=function(){return Ns},Ns.bufferOp=function(){if(2===arguments.length){var h=arguments[1];return new Ns(arguments[0]).getResultGeometry(h)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Hn&&"number"==typeof arguments[1]){var _=arguments[1],C=arguments[2],F=new Ns(arguments[0]);return F.setQuadrantSegments(C),F.getResultGeometry(_)}if(arguments[2]instanceof Zr&&arguments[0]instanceof Hn&&"number"==typeof arguments[1]){var Dt=arguments[1];return new Ns(arguments[0],arguments[2]).getResultGeometry(Dt)}}else if(4===arguments.length){var ke=arguments[1],Ge=arguments[2],_n=arguments[3],Sn=new Ns(arguments[0]);return Sn.setQuadrantSegments(Ge),Sn.setEndCapStyle(_n),Sn.getResultGeometry(ke)}},Ns.precisionScaleFactor=function(l,h,m){var _=l.getEnvelopeInternal(),C=Ct.max(Math.abs(_.getMaxX()),Math.abs(_.getMaxY()),Math.abs(_.getMinX()),Math.abs(_.getMinY()))+2*(h>0?h:0),F=m-Math.trunc(Math.log(C)/Math.log(10)+1);return Math.pow(10,F)},Tu.CAP_ROUND.get=function(){return Zr.CAP_ROUND},Tu.CAP_BUTT.get=function(){return Zr.CAP_FLAT},Tu.CAP_FLAT.get=function(){return Zr.CAP_FLAT},Tu.CAP_SQUARE.get=function(){return Zr.CAP_SQUARE},Tu.MAX_PRECISION_DIGITS.get=function(){return 12},Object.defineProperties(Ns,Tu);var Bs=function(){this._pt=[new B,new B],this._distance=lt.NaN,this._isNull=!0};Bs.prototype.getCoordinates=function(){return this._pt},Bs.prototype.getCoordinate=function(l){return this._pt[l]},Bs.prototype.setMinimum=function(){if(1===arguments.length){var l=arguments[0];this.setMinimum(l._pt[0],l._pt[1])}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this._isNull)return this.initialize(h,m),null;var _=h.distance(m);_<this._distance&&this.initialize(h,m,_)}},Bs.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var l=arguments[0],h=arguments[1];this._pt[0].setCoordinate(l),this._pt[1].setCoordinate(h),this._distance=l.distance(h),this._isNull=!1}else if(3===arguments.length){var _=arguments[1],C=arguments[2];this._pt[0].setCoordinate(arguments[0]),this._pt[1].setCoordinate(_),this._distance=C,this._isNull=!1}},Bs.prototype.getDistance=function(){return this._distance},Bs.prototype.setMaximum=function(){if(1===arguments.length){var l=arguments[0];this.setMaximum(l._pt[0],l._pt[1])}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this._isNull)return this.initialize(h,m),null;var _=h.distance(m);_>this._distance&&this.initialize(h,m,_)}},Bs.prototype.interfaces_=function(){return[]},Bs.prototype.getClass=function(){return Bs};var Go=function(){};Go.prototype.interfaces_=function(){return[]},Go.prototype.getClass=function(){return Go},Go.computeDistance=function(){if(arguments[2]instanceof Bs&&arguments[0]instanceof Vr&&arguments[1]instanceof B)for(var h=arguments[1],m=arguments[2],_=arguments[0].getCoordinates(),C=new tn,F=0;F<_.length-1;F++){C.setCoordinates(_[F],_[F+1]);var rt=C.closestPoint(h);m.setMinimum(rt,h)}else if(arguments[2]instanceof Bs&&arguments[0]instanceof rs&&arguments[1]instanceof B){var Dt=arguments[0],Qt=arguments[1],fe=arguments[2];Go.computeDistance(Dt.getExteriorRing(),Qt,fe);for(var ke=0;ke<Dt.getNumInteriorRing();ke++)Go.computeDistance(Dt.getInteriorRingN(ke),Qt,fe)}else if(arguments[2]instanceof Bs&&arguments[0]instanceof Hn&&arguments[1]instanceof B){var Ge=arguments[0],_n=arguments[1],Sn=arguments[2];if(Ge instanceof Vr)Go.computeDistance(Ge,_n,Sn);else if(Ge instanceof rs)Go.computeDistance(Ge,_n,Sn);else if(Ge instanceof zr)for(var Un=Ge,ur=0;ur<Un.getNumGeometries();ur++){var Ji=Un.getGeometryN(ur);Go.computeDistance(Ji,_n,Sn)}else Sn.setMinimum(Ge.getCoordinate(),_n)}else if(arguments[2]instanceof Bs&&arguments[0]instanceof tn&&arguments[1]instanceof B){var $a=arguments[1],ml=arguments[2],Xl=arguments[0].closestPoint($a);ml.setMinimum(Xl,$a)}};var Ca=function(l){this._maxPtDist=new Bs,this._inputGeom=l||null},Nu={MaxPointDistanceFilter:{configurable:!0},MaxMidpointDistanceFilter:{configurable:!0}};Ca.prototype.computeMaxMidpointDistance=function(l){var h=new ja(this._inputGeom);l.apply(h),this._maxPtDist.setMaximum(h.getMaxPointDistance())},Ca.prototype.computeMaxVertexDistance=function(l){var h=new gu(this._inputGeom);l.apply(h),this._maxPtDist.setMaximum(h.getMaxPointDistance())},Ca.prototype.findDistance=function(l){return this.computeMaxVertexDistance(l),this.computeMaxMidpointDistance(l),this._maxPtDist.getDistance()},Ca.prototype.getDistancePoints=function(){return this._maxPtDist},Ca.prototype.interfaces_=function(){return[]},Ca.prototype.getClass=function(){return Ca},Nu.MaxPointDistanceFilter.get=function(){return gu},Nu.MaxMidpointDistanceFilter.get=function(){return ja},Object.defineProperties(Ca,Nu);var gu=function(l){this._maxPtDist=new Bs,this._minPtDist=new Bs,this._geom=l||null};gu.prototype.filter=function(l){this._minPtDist.initialize(),Go.computeDistance(this._geom,l,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},gu.prototype.getMaxPointDistance=function(){return this._maxPtDist},gu.prototype.interfaces_=function(){return[Et]},gu.prototype.getClass=function(){return gu};var ja=function(l){this._maxPtDist=new Bs,this._minPtDist=new Bs,this._geom=l||null};ja.prototype.filter=function(l,h){if(0===h)return null;var m=l.getCoordinate(h-1),_=l.getCoordinate(h),C=new B((m.x+_.x)/2,(m.y+_.y)/2);this._minPtDist.initialize(),Go.computeDistance(this._geom,C,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},ja.prototype.isDone=function(){return!1},ja.prototype.isGeometryChanged=function(){return!1},ja.prototype.getMaxPointDistance=function(){return this._maxPtDist},ja.prototype.interfaces_=function(){return[oi]},ja.prototype.getClass=function(){return ja};var wa=function(l){this._comps=l||null};wa.prototype.filter=function(l){l instanceof rs&&this._comps.add(l)},wa.prototype.interfaces_=function(){return[fi]},wa.prototype.getClass=function(){return wa},wa.getPolygons=function(){if(1===arguments.length)return wa.getPolygons(arguments[0],new ue);if(2===arguments.length){var h=arguments[0],m=arguments[1];return h instanceof rs?m.add(h):h instanceof zr&&h.apply(new wa(m)),m}};var qs=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length)this._lines=arguments[0];else if(2===arguments.length){var m=arguments[1];this._lines=arguments[0],this._isForcedToLineString=m}};qs.prototype.filter=function(l){if(this._isForcedToLineString&&l instanceof eo){var h=l.getFactory().createLineString(l.getCoordinateSequence());return this._lines.add(h),null}l instanceof Vr&&this._lines.add(l)},qs.prototype.setForceToLineString=function(l){this._isForcedToLineString=l},qs.prototype.interfaces_=function(){return[Eo]},qs.prototype.getClass=function(){return qs},qs.getGeometry=function(){if(1===arguments.length){var l=arguments[0];return l.getFactory().buildGeometry(qs.getLines(l))}if(2===arguments.length){var h=arguments[0],m=arguments[1];return h.getFactory().buildGeometry(qs.getLines(h,m))}},qs.getLines=function(){if(1===arguments.length)return qs.getLines(arguments[0],!1);if(2===arguments.length){if(O(arguments[0],je)&&O(arguments[1],je)){for(var m=arguments[1],_=arguments[0].iterator();_.hasNext();){var C=_.next();qs.getLines(C,m)}return m}if(arguments[0]instanceof Hn&&"boolean"==typeof arguments[1]){var F=arguments[0],rt=arguments[1],Dt=new ue;return F.apply(new qs(Dt,rt)),Dt}if(arguments[0]instanceof Hn&&O(arguments[1],je)){var Qt=arguments[0],fe=arguments[1];return Qt instanceof Vr?fe.add(Qt):Qt.apply(new qs(fe)),fe}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&O(arguments[0],je)&&O(arguments[1],je)){for(var Ge=arguments[1],_n=arguments[2],Sn=arguments[0].iterator();Sn.hasNext();){var Un=Sn.next();qs.getLines(Un,Ge,_n)}return Ge}if("boolean"==typeof arguments[2]&&arguments[0]instanceof Hn&&O(arguments[1],je)){var Ji=arguments[1];return arguments[0].apply(new qs(Ji,arguments[2])),Ji}}};var ea=function(){if(this._boundaryRule=Rt.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0!==arguments.length&&1===arguments.length){var l=arguments[0];if(null===l)throw new dt("Rule must be non-null");this._boundaryRule=l}};ea.prototype.locateInternal=function(){if(arguments[0]instanceof B&&arguments[1]instanceof rs){var l=arguments[0],h=arguments[1];if(h.isEmpty())return nt.EXTERIOR;var m=h.getExteriorRing(),_=this.locateInPolygonRing(l,m);if(_===nt.EXTERIOR)return nt.EXTERIOR;if(_===nt.BOUNDARY)return nt.BOUNDARY;for(var C=0;C<h.getNumInteriorRing();C++){var F=h.getInteriorRingN(C),rt=this.locateInPolygonRing(l,F);if(rt===nt.INTERIOR)return nt.EXTERIOR;if(rt===nt.BOUNDARY)return nt.BOUNDARY}return nt.INTERIOR}if(arguments[0]instanceof B&&arguments[1]instanceof Vr){var Dt=arguments[0],Qt=arguments[1];if(!Qt.getEnvelopeInternal().intersects(Dt))return nt.EXTERIOR;var fe=Qt.getCoordinates();return Qt.isClosed()||!Dt.equals(fe[0])&&!Dt.equals(fe[fe.length-1])?yn.isOnLine(Dt,fe)?nt.INTERIOR:nt.EXTERIOR:nt.BOUNDARY}if(arguments[0]instanceof B&&arguments[1]instanceof Ls){var ke=arguments[0];return arguments[1].getCoordinate().equals2D(ke)?nt.INTERIOR:nt.EXTERIOR}},ea.prototype.locateInPolygonRing=function(l,h){return h.getEnvelopeInternal().intersects(l)?yn.locatePointInRing(l,h.getCoordinates()):nt.EXTERIOR},ea.prototype.intersects=function(l,h){return this.locate(l,h)!==nt.EXTERIOR},ea.prototype.updateLocationInfo=function(l){l===nt.INTERIOR&&(this._isIn=!0),l===nt.BOUNDARY&&this._numBoundaries++},ea.prototype.computeLocation=function(l,h){if(h instanceof Ls&&this.updateLocationInfo(this.locateInternal(l,h)),h instanceof Vr)this.updateLocationInfo(this.locateInternal(l,h));else if(h instanceof rs)this.updateLocationInfo(this.locateInternal(l,h));else if(h instanceof js)for(var m=h,_=0;_<m.getNumGeometries();_++){var C=m.getGeometryN(_);this.updateLocationInfo(this.locateInternal(l,C))}else if(h instanceof wo)for(var F=h,rt=0;rt<F.getNumGeometries();rt++){var Dt=F.getGeometryN(rt);this.updateLocationInfo(this.locateInternal(l,Dt))}else if(h instanceof zr)for(var Qt=new iu(h);Qt.hasNext();){var fe=Qt.next();fe!==h&&this.computeLocation(l,fe)}},ea.prototype.locate=function(l,h){return h.isEmpty()?nt.EXTERIOR:h instanceof Vr||h instanceof rs?this.locateInternal(l,h):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(l,h),this._boundaryRule.isInBoundary(this._numBoundaries)?nt.BOUNDARY:this._numBoundaries>0||this._isIn?nt.INTERIOR:nt.EXTERIOR)},ea.prototype.interfaces_=function(){return[]},ea.prototype.getClass=function(){return ea};var go=function l(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length)l.call(this,arguments[0],l.INSIDE_AREA,arguments[1]);else if(3===arguments.length){var C=arguments[1],F=arguments[2];this._component=arguments[0],this._segIndex=C,this._pt=F}},Fa={INSIDE_AREA:{configurable:!0}};go.prototype.isInsideArea=function(){return this._segIndex===go.INSIDE_AREA},go.prototype.getCoordinate=function(){return this._pt},go.prototype.getGeometryComponent=function(){return this._component},go.prototype.getSegmentIndex=function(){return this._segIndex},go.prototype.interfaces_=function(){return[]},go.prototype.getClass=function(){return go},Fa.INSIDE_AREA.get=function(){return-1},Object.defineProperties(go,Fa);var yu=function(l){this._pts=l||null};yu.prototype.filter=function(l){l instanceof Ls&&this._pts.add(l)},yu.prototype.interfaces_=function(){return[fi]},yu.prototype.getClass=function(){return yu},yu.getPoints=function(){if(1===arguments.length){var l=arguments[0];return l instanceof Ls?Yt.singletonList(l):yu.getPoints(l,new ue)}if(2===arguments.length){var h=arguments[0],m=arguments[1];return h instanceof Ls?m.add(h):h instanceof zr&&h.apply(new yu(m)),m}};var So=function(){this._locations=null,this._locations=arguments[0]};So.prototype.filter=function(l){(l instanceof Ls||l instanceof Vr||l instanceof rs)&&this._locations.add(new go(l,0,l.getCoordinate()))},So.prototype.interfaces_=function(){return[fi]},So.prototype.getClass=function(){return So},So.getLocations=function(l){var h=new ue;return l.apply(new So(h)),h};var hs=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new ea,this._minDistanceLocation=null,this._minDistance=lt.MAX_VALUE,2===arguments.length)this._geom=[arguments[0],arguments[1]],this._terminateDistance=0;else if(3===arguments.length){var m=arguments[0],_=arguments[1],C=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=m,this._geom[1]=_,this._terminateDistance=C}};hs.prototype.computeContainmentDistance=function(){if(0===arguments.length){var l=new Array(2).fill(null);if(this.computeContainmentDistance(0,l),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,l)}else if(2===arguments.length){var h=arguments[0],m=arguments[1],_=1-h,C=wa.getPolygons(this._geom[h]);if(C.size()>0){var F=So.getLocations(this._geom[_]);if(this.computeContainmentDistance(F,C,m),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[_]=m[0],this._minDistanceLocation[h]=m[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&O(arguments[0],En)&&O(arguments[1],En)){for(var rt=arguments[0],Dt=arguments[1],Qt=arguments[2],fe=0;fe<rt.size();fe++)for(var ke=rt.get(fe),Ge=0;Ge<Dt.size();Ge++)if(this.computeContainmentDistance(ke,Dt.get(Ge),Qt),this._minDistance<=this._terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof go&&arguments[1]instanceof rs){var _n=arguments[0],Sn=arguments[1],Un=arguments[2],ur=_n.getCoordinate();if(nt.EXTERIOR!==this._ptLocator.locate(ur,Sn))return this._minDistance=0,Un[0]=_n,Un[1]=new go(Sn,ur),null}},hs.prototype.computeMinDistanceLinesPoints=function(l,h,m){for(var _=0;_<l.size();_++)for(var C=l.get(_),F=0;F<h.size();F++){var rt=h.get(F);if(this.computeMinDistance(C,rt,m),this._minDistance<=this._terminateDistance)return null}},hs.prototype.computeFacetDistance=function(){var l=new Array(2).fill(null),h=qs.getLines(this._geom[0]),m=qs.getLines(this._geom[1]),_=yu.getPoints(this._geom[0]),C=yu.getPoints(this._geom[1]);return this.computeMinDistanceLines(h,m,l),this.updateMinDistance(l,!1),this._minDistance<=this._terminateDistance?null:(l[0]=null,l[1]=null,this.computeMinDistanceLinesPoints(h,C,l),this.updateMinDistance(l,!1),this._minDistance<=this._terminateDistance?null:(l[0]=null,l[1]=null,this.computeMinDistanceLinesPoints(m,_,l),this.updateMinDistance(l,!0),this._minDistance<=this._terminateDistance?null:(l[0]=null,l[1]=null,this.computeMinDistancePoints(_,C,l),void this.updateMinDistance(l,!1))))},hs.prototype.nearestLocations=function(){return this.computeMinDistance(),this._minDistanceLocation},hs.prototype.updateMinDistance=function(l,h){if(null===l[0])return null;h?(this._minDistanceLocation[0]=l[1],this._minDistanceLocation[1]=l[0]):(this._minDistanceLocation[0]=l[0],this._minDistanceLocation[1]=l[1])},hs.prototype.nearestPoints=function(){return this.computeMinDistance(),[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]},hs.prototype.computeMinDistance=function(){if(0===arguments.length){if(null!==this._minDistanceLocation||(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance))return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Vr&&arguments[1]instanceof Ls){var l=arguments[0],h=arguments[1],m=arguments[2];if(l.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this._minDistance)return null;for(var _=l.getCoordinates(),C=h.getCoordinate(),F=0;F<_.length-1;F++){var rt=yn.distancePointLine(C,_[F],_[F+1]);if(rt<this._minDistance){this._minDistance=rt;var Dt=new tn(_[F],_[F+1]).closestPoint(C);m[0]=new go(l,F,Dt),m[1]=new go(h,0,C)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Vr&&arguments[1]instanceof Vr){var Qt=arguments[0],fe=arguments[1],ke=arguments[2];if(Qt.getEnvelopeInternal().distance(fe.getEnvelopeInternal())>this._minDistance)return null;for(var Ge=Qt.getCoordinates(),_n=fe.getCoordinates(),Sn=0;Sn<Ge.length-1;Sn++)for(var Un=0;Un<_n.length-1;Un++){var ur=yn.distanceLineLine(Ge[Sn],Ge[Sn+1],_n[Un],_n[Un+1]);if(ur<this._minDistance){this._minDistance=ur;var Ji=new tn(Ge[Sn],Ge[Sn+1]),To=new tn(_n[Un],_n[Un+1]),$a=Ji.closestPoints(To);ke[0]=new go(Qt,Sn,$a[0]),ke[1]=new go(fe,Un,$a[1])}if(this._minDistance<=this._terminateDistance)return null}}},hs.prototype.computeMinDistancePoints=function(l,h,m){for(var _=0;_<l.size();_++)for(var C=l.get(_),F=0;F<h.size();F++){var rt=h.get(F),Dt=C.getCoordinate().distance(rt.getCoordinate());if(Dt<this._minDistance&&(this._minDistance=Dt,m[0]=new go(C,0,C.getCoordinate()),m[1]=new go(rt,0,rt.getCoordinate())),this._minDistance<=this._terminateDistance)return null}},hs.prototype.distance=function(){if(null===this._geom[0]||null===this._geom[1])throw new dt("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)},hs.prototype.computeMinDistanceLines=function(l,h,m){for(var _=0;_<l.size();_++)for(var C=l.get(_),F=0;F<h.size();F++){var rt=h.get(F);if(this.computeMinDistance(C,rt,m),this._minDistance<=this._terminateDistance)return null}},hs.prototype.interfaces_=function(){return[]},hs.prototype.getClass=function(){return hs},hs.distance=function(l,h){return new hs(l,h).distance()},hs.isWithinDistance=function(l,h,m){return new hs(l,h,m).distance()<=m},hs.nearestPoints=function(l,h){return new hs(l,h).nearestPoints()};var Do=function(){this._pt=[new B,new B],this._distance=lt.NaN,this._isNull=!0};Do.prototype.getCoordinates=function(){return this._pt},Do.prototype.getCoordinate=function(l){return this._pt[l]},Do.prototype.setMinimum=function(){if(1===arguments.length){var l=arguments[0];this.setMinimum(l._pt[0],l._pt[1])}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this._isNull)return this.initialize(h,m),null;var _=h.distance(m);_<this._distance&&this.initialize(h,m,_)}},Do.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var l=arguments[0],h=arguments[1];this._pt[0].setCoordinate(l),this._pt[1].setCoordinate(h),this._distance=l.distance(h),this._isNull=!1}else if(3===arguments.length){var _=arguments[1],C=arguments[2];this._pt[0].setCoordinate(arguments[0]),this._pt[1].setCoordinate(_),this._distance=C,this._isNull=!1}},Do.prototype.toString=function(){return Je.toLineString(this._pt[0],this._pt[1])},Do.prototype.getDistance=function(){return this._distance},Do.prototype.setMaximum=function(){if(1===arguments.length){var l=arguments[0];this.setMaximum(l._pt[0],l._pt[1])}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this._isNull)return this.initialize(h,m),null;var _=h.distance(m);_>this._distance&&this.initialize(h,m,_)}},Do.prototype.interfaces_=function(){return[]},Do.prototype.getClass=function(){return Do};var ca=function(){};ca.prototype.interfaces_=function(){return[]},ca.prototype.getClass=function(){return ca},ca.computeDistance=function(){if(arguments[2]instanceof Do&&arguments[0]instanceof Vr&&arguments[1]instanceof B)for(var l=arguments[0],h=arguments[1],m=arguments[2],_=new tn,C=l.getCoordinates(),F=0;F<C.length-1;F++){_.setCoordinates(C[F],C[F+1]);var rt=_.closestPoint(h);m.setMinimum(rt,h)}else if(arguments[2]instanceof Do&&arguments[0]instanceof rs&&arguments[1]instanceof B){var Dt=arguments[0],Qt=arguments[1],fe=arguments[2];ca.computeDistance(Dt.getExteriorRing(),Qt,fe);for(var ke=0;ke<Dt.getNumInteriorRing();ke++)ca.computeDistance(Dt.getInteriorRingN(ke),Qt,fe)}else if(arguments[2]instanceof Do&&arguments[0]instanceof Hn&&arguments[1]instanceof B){var Ge=arguments[0],_n=arguments[1],Sn=arguments[2];if(Ge instanceof Vr)ca.computeDistance(Ge,_n,Sn);else if(Ge instanceof rs)ca.computeDistance(Ge,_n,Sn);else if(Ge instanceof zr)for(var Un=Ge,ur=0;ur<Un.getNumGeometries();ur++){var Ji=Un.getGeometryN(ur);ca.computeDistance(Ji,_n,Sn)}else Sn.setMinimum(Ge.getCoordinate(),_n)}else if(arguments[2]instanceof Do&&arguments[0]instanceof tn&&arguments[1]instanceof B){var $a=arguments[1],ml=arguments[2],Xl=arguments[0].closestPoint($a);ml.setMinimum(Xl,$a)}};var ns=function(){this._g0=null,this._g1=null,this._ptDist=new Do,this._densifyFrac=0;var h=arguments[1];this._g0=arguments[0],this._g1=h},Il={MaxPointDistanceFilter:{configurable:!0},MaxDensifiedByFractionDistanceFilter:{configurable:!0}};ns.prototype.getCoordinates=function(){return this._ptDist.getCoordinates()},ns.prototype.setDensifyFraction=function(l){if(l>1||l<=0)throw new dt("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=l},ns.prototype.compute=function(l,h){this.computeOrientedDistance(l,h,this._ptDist),this.computeOrientedDistance(h,l,this._ptDist)},ns.prototype.distance=function(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()},ns.prototype.computeOrientedDistance=function(l,h,m){var _=new Au(h);if(l.apply(_),m.setMaximum(_.getMaxPointDistance()),this._densifyFrac>0){var C=new Ho(h,this._densifyFrac);l.apply(C),m.setMaximum(C.getMaxPointDistance())}},ns.prototype.orientedDistance=function(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()},ns.prototype.interfaces_=function(){return[]},ns.prototype.getClass=function(){return ns},ns.distance=function(){if(2===arguments.length)return new ns(arguments[0],arguments[1]).distance();if(3===arguments.length){var C=arguments[2],F=new ns(arguments[0],arguments[1]);return F.setDensifyFraction(C),F.distance()}},Il.MaxPointDistanceFilter.get=function(){return Au},Il.MaxDensifiedByFractionDistanceFilter.get=function(){return Ho},Object.defineProperties(ns,Il);var Au=function(){this._maxPtDist=new Do,this._minPtDist=new Do,this._euclideanDist=new ca,this._geom=null,this._geom=arguments[0]};Au.prototype.filter=function(l){this._minPtDist.initialize(),ca.computeDistance(this._geom,l,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},Au.prototype.getMaxPointDistance=function(){return this._maxPtDist},Au.prototype.interfaces_=function(){return[Et]},Au.prototype.getClass=function(){return Au};var Ho=function(){this._maxPtDist=new Do,this._minPtDist=new Do,this._geom=null,this._numSubSegs=0;var h=arguments[1];this._geom=arguments[0],this._numSubSegs=Math.trunc(Math.round(1/h))};Ho.prototype.filter=function(l,h){if(0===h)return null;for(var m=l.getCoordinate(h-1),_=l.getCoordinate(h),C=(_.x-m.x)/this._numSubSegs,F=(_.y-m.y)/this._numSubSegs,rt=0;rt<this._numSubSegs;rt++){var fe=new B(m.x+rt*C,m.y+rt*F);this._minPtDist.initialize(),ca.computeDistance(this._geom,fe,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}},Ho.prototype.isDone=function(){return!1},Ho.prototype.isGeometryChanged=function(){return!1},Ho.prototype.getMaxPointDistance=function(){return this._maxPtDist},Ho.prototype.interfaces_=function(){return[oi]},Ho.prototype.getClass=function(){return Ho};var ds=function(l,h,m){this._minValidDistance=null,this._maxValidDistance=null,this._minDistanceFound=null,this._maxDistanceFound=null,this._isValid=!0,this._errMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=l||null,this._bufDistance=h||null,this._result=m||null},ha={VERBOSE:{configurable:!0},MAX_DISTANCE_DIFF_FRAC:{configurable:!0}};ds.prototype.checkMaximumDistance=function(l,h,m){var _=new ns(h,l);if(_.setDensifyFraction(.25),this._maxDistanceFound=_.orientedDistance(),this._maxDistanceFound>m){this._isValid=!1;var C=_.getCoordinates();this._errorLocation=C[1],this._errorIndicator=l.getFactory().createLineString(C),this._errMsg="Distance between buffer curve and input is too large ("+this._maxDistanceFound+" at "+Je.toLineString(C[0],C[1])+")"}},ds.prototype.isValid=function(){var l=Math.abs(this._bufDistance),h=ds.MAX_DISTANCE_DIFF_FRAC*l;return this._minValidDistance=l-h,this._maxValidDistance=l+h,!(!this._input.isEmpty()&&!this._result.isEmpty())||(this._bufDistance>0?this.checkPositiveValid():this.checkNegativeValid(),ds.VERBOSE&&Xe.out.println("Min Dist= "+this._minDistanceFound+"  err= "+(1-this._minDistanceFound/this._bufDistance)+"  Max Dist= "+this._maxDistanceFound+"  err= "+(this._maxDistanceFound/this._bufDistance-1)),this._isValid)},ds.prototype.checkNegativeValid=function(){if(!(this._input instanceof rs||this._input instanceof wo||this._input instanceof zr))return null;var l=this.getPolygonLines(this._input);if(this.checkMinimumDistance(l,this._result,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(l,this._result,this._maxValidDistance)},ds.prototype.getErrorIndicator=function(){return this._errorIndicator},ds.prototype.checkMinimumDistance=function(l,h,m){var _=new hs(l,h,m);if(this._minDistanceFound=_.distance(),this._minDistanceFound<m){this._isValid=!1;var C=_.nearestPoints();this._errorLocation=_.nearestPoints()[1],this._errorIndicator=l.getFactory().createLineString(C),this._errMsg="Distance between buffer curve and input is too small ("+this._minDistanceFound+" at "+Je.toLineString(C[0],C[1])+" )"}},ds.prototype.checkPositiveValid=function(){var l=this._result.getBoundary();if(this.checkMinimumDistance(this._input,l,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(this._input,l,this._maxValidDistance)},ds.prototype.getErrorLocation=function(){return this._errorLocation},ds.prototype.getPolygonLines=function(l){for(var h=new ue,m=new qs(h),_=wa.getPolygons(l).iterator();_.hasNext();)_.next().apply(m);return l.getFactory().buildGeometry(h)},ds.prototype.getErrorMessage=function(){return this._errMsg},ds.prototype.interfaces_=function(){return[]},ds.prototype.getClass=function(){return ds},ha.VERBOSE.get=function(){return!1},ha.MAX_DISTANCE_DIFF_FRAC.get=function(){return.012},Object.defineProperties(ds,ha);var no=function(l,h,m){this._isValid=!0,this._errorMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=l||null,this._distance=h||null,this._result=m||null},Kl={VERBOSE:{configurable:!0},MAX_ENV_DIFF_FRAC:{configurable:!0}};no.prototype.isValid=function(){return this.checkPolygonal(),this._isValid?(this.checkExpectedEmpty(),this._isValid?(this.checkEnvelope(),this._isValid?(this.checkArea(),this._isValid?(this.checkDistance(),this._isValid):this._isValid):this._isValid):this._isValid):this._isValid},no.prototype.checkEnvelope=function(){if(this._distance<0)return null;var l=this._distance*no.MAX_ENV_DIFF_FRAC;0===l&&(l=.001);var h=new De(this._input.getEnvelopeInternal());h.expandBy(this._distance);var m=new De(this._result.getEnvelopeInternal());m.expandBy(l),m.contains(h)||(this._isValid=!1,this._errorMsg="Buffer envelope is incorrect",this._errorIndicator=this._input.getFactory().toGeometry(m)),this.report("Envelope")},no.prototype.checkDistance=function(){var l=new ds(this._input,this._distance,this._result);l.isValid()||(this._isValid=!1,this._errorMsg=l.getErrorMessage(),this._errorLocation=l.getErrorLocation(),this._errorIndicator=l.getErrorIndicator()),this.report("Distance")},no.prototype.checkArea=function(){var l=this._input.getArea(),h=this._result.getArea();this._distance>0&&l>h&&(this._isValid=!1,this._errorMsg="Area of positive buffer is smaller than input",this._errorIndicator=this._result),this._distance<0&&l<h&&(this._isValid=!1,this._errorMsg="Area of negative buffer is larger than input",this._errorIndicator=this._result),this.report("Area")},no.prototype.checkPolygonal=function(){this._result instanceof rs||this._result instanceof wo||(this._isValid=!1),this._errorMsg="Result is not polygonal",this._errorIndicator=this._result,this.report("Polygonal")},no.prototype.getErrorIndicator=function(){return this._errorIndicator},no.prototype.getErrorLocation=function(){return this._errorLocation},no.prototype.checkExpectedEmpty=function(){return this._input.getDimension()>=2||this._distance>0?null:(this._result.isEmpty()||(this._isValid=!1,this._errorMsg="Result is non-empty",this._errorIndicator=this._result),void this.report("ExpectedEmpty"))},no.prototype.report=function(l){if(!no.VERBOSE)return null;Xe.out.println("Check "+l+": "+(this._isValid?"passed":"FAILED"))},no.prototype.getErrorMessage=function(){return this._errorMsg},no.prototype.interfaces_=function(){return[]},no.prototype.getClass=function(){return no},no.isValidMsg=function(l,h,m){var _=new no(l,h,m);return _.isValid()?null:_.getErrorMessage()},no.isValid=function(l,h,m){return!!new no(l,h,m).isValid()},Kl.VERBOSE.get=function(){return!1},Kl.MAX_ENV_DIFF_FRAC.get=function(){return.012},Object.defineProperties(no,Kl);var Ka=function(){this._pts=null,this._data=null;var h=arguments[1];this._pts=arguments[0],this._data=h};Ka.prototype.getCoordinates=function(){return this._pts},Ka.prototype.size=function(){return this._pts.length},Ka.prototype.getCoordinate=function(l){return this._pts[l]},Ka.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},Ka.prototype.getSegmentOctant=function(l){return l===this._pts.length-1?-1:_r.octant(this.getCoordinate(l),this.getCoordinate(l+1))},Ka.prototype.setData=function(l){this._data=l},Ka.prototype.getData=function(){return this._data},Ka.prototype.toString=function(){return Je.toLineString(new pr(this._pts))},Ka.prototype.interfaces_=function(){return[ni]},Ka.prototype.getClass=function(){return Ka};var Yr=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new ue,this._intersectionCount=0,this._keepIntersections=!0,this._li=arguments[0],this._interiorIntersection=null};Yr.prototype.getInteriorIntersection=function(){return this._interiorIntersection},Yr.prototype.setCheckEndSegmentsOnly=function(l){this._isCheckEndSegmentsOnly=l},Yr.prototype.getIntersectionSegments=function(){return this._intSegments},Yr.prototype.count=function(){return this._intersectionCount},Yr.prototype.getIntersections=function(){return this._intersections},Yr.prototype.setFindAllIntersections=function(l){this._findAllIntersections=l},Yr.prototype.setKeepIntersections=function(l){this._keepIntersections=l},Yr.prototype.processIntersections=function(l,h,m,_){if(!this._findAllIntersections&&this.hasIntersection()||l===m&&h===_||this._isCheckEndSegmentsOnly&&!this.isEndSegment(l,h)&&!this.isEndSegment(m,_))return null;var C=l.getCoordinates()[h],F=l.getCoordinates()[h+1],rt=m.getCoordinates()[_],Dt=m.getCoordinates()[_+1];this._li.computeIntersection(C,F,rt,Dt),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=C,this._intSegments[1]=F,this._intSegments[2]=rt,this._intSegments[3]=Dt,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)},Yr.prototype.isEndSegment=function(l,h){return 0===h||h>=l.size()-2},Yr.prototype.hasIntersection=function(){return null!==this._interiorIntersection},Yr.prototype.isDone=function(){return!this._findAllIntersections&&null!==this._interiorIntersection},Yr.prototype.interfaces_=function(){return[Jo]},Yr.prototype.getClass=function(){return Yr},Yr.createAllIntersectionsFinder=function(l){var h=new Yr(l);return h.setFindAllIntersections(!0),h},Yr.createAnyIntersectionFinder=function(l){return new Yr(l)},Yr.createIntersectionCounter=function(l){var h=new Yr(l);return h.setFindAllIntersections(!0),h.setKeepIntersections(!1),h};var da=function(){this._li=new di,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0,this._segStrings=arguments[0]};da.prototype.execute=function(){if(null!==this._segInt)return null;this.checkInteriorIntersections()},da.prototype.getIntersections=function(){return this._segInt.getIntersections()},da.prototype.isValid=function(){return this.execute(),this._isValid},da.prototype.setFindAllIntersections=function(l){this._findAllIntersections=l},da.prototype.checkInteriorIntersections=function(){this._isValid=!0,this._segInt=new Yr(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);var l=new Rc;if(l.setSegmentIntersector(this._segInt),l.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null},da.prototype.checkValid=function(){if(this.execute(),!this._isValid)throw new Ds(this.getErrorMessage(),this._segInt.getInteriorIntersection())},da.prototype.getErrorMessage=function(){if(this._isValid)return"no intersections found";var l=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Je.toLineString(l[0],l[1])+" and "+Je.toLineString(l[2],l[3])},da.prototype.interfaces_=function(){return[]},da.prototype.getClass=function(){return da},da.computeIntersections=function(l){var h=new da(l);return h.setFindAllIntersections(!0),h.isValid(),h.getIntersections()};var vu=function l(){this._nv=null,this._nv=new da(l.toSegmentStrings(arguments[0]))};vu.prototype.checkValid=function(){this._nv.checkValid()},vu.prototype.interfaces_=function(){return[]},vu.prototype.getClass=function(){return vu},vu.toSegmentStrings=function(l){for(var h=new ue,m=l.iterator();m.hasNext();){var _=m.next();h.add(new Ka(_.getCoordinates(),_))}return h},vu.checkValid=function(l){new vu(l).checkValid()};var or=function(l){this._mapOp=l};or.prototype.map=function(l){for(var h=new ue,m=0;m<l.getNumGeometries();m++){var _=this._mapOp.map(l.getGeometryN(m));_.isEmpty()||h.add(_)}return l.getFactory().createGeometryCollection(nr.toGeometryArray(h))},or.prototype.interfaces_=function(){return[]},or.prototype.getClass=function(){return or},or.map=function(l,h){return new or(h).map(l)};var ws=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new ue,this._resultLineList=new ue;var h=arguments[1],m=arguments[2];this._op=arguments[0],this._geometryFactory=h,this._ptLocator=m};ws.prototype.collectLines=function(l){for(var h=this._op.getGraph().getEdgeEnds().iterator();h.hasNext();){var m=h.next();this.collectLineEdge(m,l,this._lineEdgesList),this.collectBoundaryTouchEdge(m,l,this._lineEdgesList)}},ws.prototype.labelIsolatedLine=function(l,h){var m=this._ptLocator.locate(l.getCoordinate(),this._op.getArgGeometry(h));l.getLabel().setLocation(h,m)},ws.prototype.build=function(l){return this.findCoveredLineEdges(),this.collectLines(l),this.buildLines(l),this._resultLineList},ws.prototype.collectLineEdge=function(l,h,m){var _=l.getLabel(),C=l.getEdge();l.isLineEdge()&&(l.isVisited()||!cr.isResultOfOp(_,h)||C.isCovered()||(m.add(C),l.setVisitedEdge(!0)))},ws.prototype.findCoveredLineEdges=function(){for(var l=this._op.getGraph().getNodes().iterator();l.hasNext();)l.next().getEdges().findCoveredLineEdges();for(var h=this._op.getGraph().getEdgeEnds().iterator();h.hasNext();){var m=h.next(),_=m.getEdge();if(m.isLineEdge()&&!_.isCoveredSet()){var C=this._op.isCoveredByA(m.getCoordinate());_.setCovered(C)}}},ws.prototype.labelIsolatedLines=function(l){for(var h=l.iterator();h.hasNext();){var m=h.next(),_=m.getLabel();m.isIsolated()&&(_.isNull(0)?this.labelIsolatedLine(m,0):this.labelIsolatedLine(m,1))}},ws.prototype.buildLines=function(l){for(var h=this._lineEdgesList.iterator();h.hasNext();){var m=h.next(),_=this._geometryFactory.createLineString(m.getCoordinates());this._resultLineList.add(_),m.setInResult(!0)}},ws.prototype.collectBoundaryTouchEdge=function(l,h,m){var _=l.getLabel();return l.isLineEdge()||l.isVisited()||l.isInteriorAreaEdge()||l.getEdge().isInResult()?null:(Nn.isTrue(!(l.isInResult()||l.getSym().isInResult())||!l.getEdge().isInResult()),void(cr.isResultOfOp(_,h)&&h===cr.INTERSECTION&&(m.add(l.getEdge()),l.setVisitedEdge(!0))))},ws.prototype.interfaces_=function(){return[]},ws.prototype.getClass=function(){return ws};var Tr=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new ue;var h=arguments[1];this._op=arguments[0],this._geometryFactory=h};Tr.prototype.filterCoveredNodeToPoint=function(l){var h=l.getCoordinate();if(!this._op.isCoveredByLA(h)){var m=this._geometryFactory.createPoint(h);this._resultPointList.add(m)}},Tr.prototype.extractNonCoveredResultNodes=function(l){for(var h=this._op.getGraph().getNodes().iterator();h.hasNext();){var m=h.next();if(!(m.isInResult()||m.isIncidentEdgeInResult()||0!==m.getEdges().getDegree()&&l!==cr.INTERSECTION)){var _=m.getLabel();cr.isResultOfOp(_,l)&&this.filterCoveredNodeToPoint(m)}}},Tr.prototype.build=function(l){return this.extractNonCoveredResultNodes(l),this._resultPointList},Tr.prototype.interfaces_=function(){return[]},Tr.prototype.getClass=function(){return Tr};var ri=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};ri.prototype.transformPoint=function(l,h){return this._factory.createPoint(this.transformCoordinates(l.getCoordinateSequence(),l))},ri.prototype.transformPolygon=function(l,h){var m=!0,_=this.transformLinearRing(l.getExteriorRing(),l);null!==_&&_ instanceof eo&&!_.isEmpty()||(m=!1);for(var C=new ue,F=0;F<l.getNumInteriorRing();F++){var rt=this.transformLinearRing(l.getInteriorRingN(F),l);null===rt||rt.isEmpty()||(rt instanceof eo||(m=!1),C.add(rt))}if(m)return this._factory.createPolygon(_,C.toArray([]));var Dt=new ue;return null!==_&&Dt.add(_),Dt.addAll(C),this._factory.buildGeometry(Dt)},ri.prototype.createCoordinateSequence=function(l){return this._factory.getCoordinateSequenceFactory().create(l)},ri.prototype.getInputGeometry=function(){return this._inputGeom},ri.prototype.transformMultiLineString=function(l,h){for(var m=new ue,_=0;_<l.getNumGeometries();_++){var C=this.transformLineString(l.getGeometryN(_),l);null!==C&&(C.isEmpty()||m.add(C))}return this._factory.buildGeometry(m)},ri.prototype.transformCoordinates=function(l,h){return this.copy(l)},ri.prototype.transformLineString=function(l,h){return this._factory.createLineString(this.transformCoordinates(l.getCoordinateSequence(),l))},ri.prototype.transformMultiPoint=function(l,h){for(var m=new ue,_=0;_<l.getNumGeometries();_++){var C=this.transformPoint(l.getGeometryN(_),l);null!==C&&(C.isEmpty()||m.add(C))}return this._factory.buildGeometry(m)},ri.prototype.transformMultiPolygon=function(l,h){for(var m=new ue,_=0;_<l.getNumGeometries();_++){var C=this.transformPolygon(l.getGeometryN(_),l);null!==C&&(C.isEmpty()||m.add(C))}return this._factory.buildGeometry(m)},ri.prototype.copy=function(l){return l.copy()},ri.prototype.transformGeometryCollection=function(l,h){for(var m=new ue,_=0;_<l.getNumGeometries();_++){var C=this.transform(l.getGeometryN(_));null!==C&&(this._pruneEmptyGeometry&&C.isEmpty()||m.add(C))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(nr.toGeometryArray(m)):this._factory.buildGeometry(m)},ri.prototype.transform=function(l){if(this._inputGeom=l,this._factory=l.getFactory(),l instanceof Ls)return this.transformPoint(l,null);if(l instanceof Oa)return this.transformMultiPoint(l,null);if(l instanceof eo)return this.transformLinearRing(l,null);if(l instanceof Vr)return this.transformLineString(l,null);if(l instanceof js)return this.transformMultiLineString(l,null);if(l instanceof rs)return this.transformPolygon(l,null);if(l instanceof wo)return this.transformMultiPolygon(l,null);if(l instanceof zr)return this.transformGeometryCollection(l,null);throw new dt("Unknown Geometry subtype: "+l.getClass().getName())},ri.prototype.transformLinearRing=function(l,h){var m=this.transformCoordinates(l.getCoordinateSequence(),l);if(null===m)return this._factory.createLinearRing(null);var _=m.size();return _>0&&_<4&&!this._preserveType?this._factory.createLineString(m):this._factory.createLinearRing(m)},ri.prototype.interfaces_=function(){return[]},ri.prototype.getClass=function(){return ri};var fs=function l(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new tn,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Vr&&"number"==typeof arguments[1]){var m=arguments[1];l.call(this,arguments[0].getCoordinates(),m)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var _=arguments[0],C=arguments[1];this._srcPts=_,this._isClosed=l.isClosed(_),this._snapTolerance=C}};fs.prototype.snapVertices=function(l,h){for(var m=this._isClosed?l.size()-1:l.size(),_=0;_<m;_++){var C=l.get(_),F=this.findSnapForVertex(C,h);null!==F&&(l.set(_,new B(F)),0===_&&this._isClosed&&l.set(l.size()-1,new B(F)))}},fs.prototype.findSnapForVertex=function(l,h){for(var m=0;m<h.length;m++){if(l.equals2D(h[m]))return null;if(l.distance(h[m])<this._snapTolerance)return h[m]}return null},fs.prototype.snapTo=function(l){var h=new mn(this._srcPts);return this.snapVertices(h,l),this.snapSegments(h,l),h.toCoordinateArray()},fs.prototype.snapSegments=function(l,h){if(0===h.length)return null;var m=h.length;h[0].equals2D(h[h.length-1])&&(m=h.length-1);for(var _=0;_<m;_++){var C=h[_],F=this.findSegmentIndexToSnap(C,l);F>=0&&l.add(F+1,new B(C),!1)}},fs.prototype.findSegmentIndexToSnap=function(l,h){for(var m=lt.MAX_VALUE,_=-1,C=0;C<h.size()-1;C++){if(this._seg.p0=h.get(C),this._seg.p1=h.get(C+1),this._seg.p0.equals2D(l)||this._seg.p1.equals2D(l)){if(this._allowSnappingToSourceVertices)continue;return-1}var F=this._seg.distance(l);F<this._snapTolerance&&F<m&&(m=F,_=C)}return _},fs.prototype.setAllowSnappingToSourceVertices=function(l){this._allowSnappingToSourceVertices=l},fs.prototype.interfaces_=function(){return[]},fs.prototype.getClass=function(){return fs},fs.isClosed=function(l){return!(l.length<=1)&&l[0].equals2D(l[l.length-1])};var gt=function(l){this._srcGeom=l||null},ct={SNAP_PRECISION_FACTOR:{configurable:!0}};gt.prototype.snapTo=function(l,h){var m=this.extractTargetCoordinates(l);return new _t(h,m).transform(this._srcGeom)},gt.prototype.snapToSelf=function(l,h){var m=this.extractTargetCoordinates(this._srcGeom),_=new _t(l,m,!0).transform(this._srcGeom),C=_;return h&&O(C,Pa)&&(C=_.buffer(0)),C},gt.prototype.computeSnapTolerance=function(l){return this.computeMinimumSegmentLength(l)/10},gt.prototype.extractTargetCoordinates=function(l){for(var h=new it,m=l.getCoordinates(),_=0;_<m.length;_++)h.add(m[_]);return h.toArray(new Array(0).fill(null))},gt.prototype.computeMinimumSegmentLength=function(l){for(var h=lt.MAX_VALUE,m=0;m<l.length-1;m++){var _=l[m].distance(l[m+1]);_<h&&(h=_)}return h},gt.prototype.interfaces_=function(){return[]},gt.prototype.getClass=function(){return gt},gt.snap=function(l,h,m){var _=new Array(2).fill(null),C=new gt(l);_[0]=C.snapTo(h,m);var F=new gt(h);return _[1]=F.snapTo(_[0],m),_},gt.computeOverlaySnapTolerance=function(){if(1===arguments.length){var l=arguments[0],h=gt.computeSizeBasedSnapTolerance(l),m=l.getPrecisionModel();if(m.getType()===An.FIXED){var _=1/m.getScale()*2/1.415;_>h&&(h=_)}return h}if(2===arguments.length){var F=arguments[1];return Math.min(gt.computeOverlaySnapTolerance(arguments[0]),gt.computeOverlaySnapTolerance(F))}},gt.computeSizeBasedSnapTolerance=function(l){var h=l.getEnvelopeInternal();return Math.min(h.getHeight(),h.getWidth())*gt.SNAP_PRECISION_FACTOR},gt.snapToSelf=function(l,h,m){return new gt(l).snapToSelf(h,m)},ct.SNAP_PRECISION_FACTOR.get=function(){return 1e-9},Object.defineProperties(gt,ct);var _t=function(l){function h(m,_,C){l.call(this),this._snapTolerance=m||null,this._snapPts=_||null,this._isSelfSnap=void 0!==C&&C}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.snapLine=function(m,_){var C=new fs(m,this._snapTolerance);return C.setAllowSnappingToSourceVertices(this._isSelfSnap),C.snapTo(_)},h.prototype.transformCoordinates=function(m,_){var C=m.toCoordinateArray(),F=this.snapLine(C,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(F)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(ri),Nt=function(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=0,this._commonSignExp=null};Nt.prototype.getCommon=function(){return lt.longBitsToDouble(this._commonBits)},Nt.prototype.add=function(l){var h=lt.doubleToLongBits(l);return this._isFirst?(this._commonBits=h,this._commonSignExp=Nt.signExpBits(this._commonBits),this._isFirst=!1,null):Nt.signExpBits(h)!==this._commonSignExp?(this._commonBits=0,null):(this._commonMantissaBitsCount=Nt.numCommonMostSigMantissaBits(this._commonBits,h),void(this._commonBits=Nt.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))))},Nt.prototype.toString=function(){if(1===arguments.length){var l=arguments[0],h=lt.longBitsToDouble(l),m="0000000000000000000000000000000000000000000000000000000000000000"+lt.toBinaryString(l),_=m.substring(m.length-64);return _.substring(0,1)+"  "+_.substring(1,12)+"(exp) "+_.substring(12)+" [ "+h+" ]"}},Nt.prototype.interfaces_=function(){return[]},Nt.prototype.getClass=function(){return Nt},Nt.getBit=function(l,h){return l&1<<h?1:0},Nt.signExpBits=function(l){return l>>52},Nt.zeroLowerBits=function(l,h){return l&~((1<<h)-1)},Nt.numCommonMostSigMantissaBits=function(l,h){for(var m=0,_=52;_>=0;_--){if(Nt.getBit(l,_)!==Nt.getBit(h,_))return m;m++}return 52};var Kt=function(){this._commonCoord=null,this._ccFilter=new Ee},de={CommonCoordinateFilter:{configurable:!0},Translater:{configurable:!0}};Kt.prototype.addCommonBits=function(l){var h=new Te(this._commonCoord);l.apply(h),l.geometryChanged()},Kt.prototype.removeCommonBits=function(l){if(0===this._commonCoord.x&&0===this._commonCoord.y)return l;var h=new B(this._commonCoord);h.x=-h.x,h.y=-h.y;var m=new Te(h);return l.apply(m),l.geometryChanged(),l},Kt.prototype.getCommonCoordinate=function(){return this._commonCoord},Kt.prototype.add=function(l){l.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()},Kt.prototype.interfaces_=function(){return[]},Kt.prototype.getClass=function(){return Kt},de.CommonCoordinateFilter.get=function(){return Ee},de.Translater.get=function(){return Te},Object.defineProperties(Kt,de);var Ee=function(){this._commonBitsX=new Nt,this._commonBitsY=new Nt};Ee.prototype.filter=function(l){this._commonBitsX.add(l.x),this._commonBitsY.add(l.y)},Ee.prototype.getCommonCoordinate=function(){return new B(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())},Ee.prototype.interfaces_=function(){return[Et]},Ee.prototype.getClass=function(){return Ee};var Te=function(){this.trans=null,this.trans=arguments[0]};Te.prototype.filter=function(l,h){var m=l.getOrdinate(h,0)+this.trans.x,_=l.getOrdinate(h,1)+this.trans.y;l.setOrdinate(h,0,m),l.setOrdinate(h,1,_)},Te.prototype.isDone=function(){return!1},Te.prototype.isGeometryChanged=function(){return!0},Te.prototype.interfaces_=function(){return[oi]},Te.prototype.getClass=function(){return Te};var xe=function(l,h){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null,this._geom[0]=l,this._geom[1]=h,this.computeSnapTolerance()};xe.prototype.selfSnap=function(l){return new gt(l).snapTo(l,this._snapTolerance)},xe.prototype.removeCommonBits=function(l){this._cbr=new Kt,this._cbr.add(l[0]),this._cbr.add(l[1]);var h=new Array(2).fill(null);return h[0]=this._cbr.removeCommonBits(l[0].copy()),h[1]=this._cbr.removeCommonBits(l[1].copy()),h},xe.prototype.prepareResult=function(l){return this._cbr.addCommonBits(l),l},xe.prototype.getResultGeometry=function(l){var h=this.snap(this._geom),m=cr.overlayOp(h[0],h[1],l);return this.prepareResult(m)},xe.prototype.checkValid=function(l){l.isValid()||Xe.out.println("Snapped geometry is invalid")},xe.prototype.computeSnapTolerance=function(){this._snapTolerance=gt.computeOverlaySnapTolerance(this._geom[0],this._geom[1])},xe.prototype.snap=function(l){var h=this.removeCommonBits(l);return gt.snap(h[0],h[1],this._snapTolerance)},xe.prototype.interfaces_=function(){return[]},xe.prototype.getClass=function(){return xe},xe.overlayOp=function(l,h,m){return new xe(l,h).getResultGeometry(m)},xe.union=function(l,h){return xe.overlayOp(l,h,cr.UNION)},xe.intersection=function(l,h){return xe.overlayOp(l,h,cr.INTERSECTION)},xe.symDifference=function(l,h){return xe.overlayOp(l,h,cr.SYMDIFFERENCE)},xe.difference=function(l,h){return xe.overlayOp(l,h,cr.DIFFERENCE)};var Pe=function(l,h){this._geom=new Array(2).fill(null),this._geom[0]=l,this._geom[1]=h};Pe.prototype.getResultGeometry=function(l){var h=null,m=!1,_=null;try{h=cr.overlayOp(this._geom[0],this._geom[1],l),m=!0}catch(C){if(!(C instanceof Gn))throw C;_=C}if(!m)try{h=xe.overlayOp(this._geom[0],this._geom[1],l)}catch(C){throw C instanceof Gn?_:C}return h},Pe.prototype.interfaces_=function(){return[]},Pe.prototype.getClass=function(){return Pe},Pe.overlayOp=function(l,h,m){return new Pe(l,h).getResultGeometry(m)},Pe.union=function(l,h){return Pe.overlayOp(l,h,cr.UNION)},Pe.intersection=function(l,h){return Pe.overlayOp(l,h,cr.INTERSECTION)},Pe.symDifference=function(l,h){return Pe.overlayOp(l,h,cr.SYMDIFFERENCE)},Pe.difference=function(l,h){return Pe.overlayOp(l,h,cr.DIFFERENCE)};var fn=function(){this.mce=null,this.chainIndex=null;var h=arguments[1];this.mce=arguments[0],this.chainIndex=h};fn.prototype.computeIntersections=function(l,h){this.mce.computeIntersectsForChain(this.chainIndex,l.mce,l.chainIndex,h)},fn.prototype.interfaces_=function(){return[]},fn.prototype.getClass=function(){return fn};var f=function l(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){var h=arguments[0],m=arguments[1];this._eventType=l.DELETE,this._xValue=h,this._insertEvent=m}else if(3===arguments.length){var _=arguments[0],C=arguments[1],F=arguments[2];this._eventType=l.INSERT,this._label=_,this._xValue=C,this._obj=F}},E={INSERT:{configurable:!0},DELETE:{configurable:!0}};f.prototype.isDelete=function(){return this._eventType===f.DELETE},f.prototype.setDeleteEventIndex=function(l){this._deleteEventIndex=l},f.prototype.getObject=function(){return this._obj},f.prototype.compareTo=function(l){return this._xValue<l._xValue?-1:this._xValue>l._xValue?1:this._eventType<l._eventType?-1:this._eventType>l._eventType?1:0},f.prototype.getInsertEvent=function(){return this._insertEvent},f.prototype.isInsert=function(){return this._eventType===f.INSERT},f.prototype.isSameLabel=function(l){return null!==this._label&&this._label===l._label},f.prototype.getDeleteEventIndex=function(){return this._deleteEventIndex},f.prototype.interfaces_=function(){return[Q]},f.prototype.getClass=function(){return f},E.INSERT.get=function(){return 1},E.DELETE.get=function(){return 2},Object.defineProperties(f,E);var D=function(){};D.prototype.interfaces_=function(){return[]},D.prototype.getClass=function(){return D};var j=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;var h=arguments[1],m=arguments[2];this._li=arguments[0],this._includeProper=h,this._recordIsolated=m};j.prototype.isTrivialIntersection=function(l,h,m,_){if(l===m&&1===this._li.getIntersectionNum()){if(j.isAdjacentSegments(h,_))return!0;if(l.isClosed()){var C=l.getNumPoints()-1;if(0===h&&_===C||0===_&&h===C)return!0}}return!1},j.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},j.prototype.setIsDoneIfProperInt=function(l){this._isDoneWhenProperInt=l},j.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},j.prototype.isBoundaryPointInternal=function(l,h){for(var m=h.iterator();m.hasNext();){var _=m.next().getCoordinate();if(l.isIntersection(_))return!0}return!1},j.prototype.hasProperIntersection=function(){return this._hasProper},j.prototype.hasIntersection=function(){return this._hasIntersection},j.prototype.isDone=function(){return this._isDone},j.prototype.isBoundaryPoint=function(l,h){return!(null===h||!this.isBoundaryPointInternal(l,h[0])&&!this.isBoundaryPointInternal(l,h[1]))},j.prototype.setBoundaryNodes=function(l,h){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=l,this._bdyNodes[1]=h},j.prototype.addIntersections=function(l,h,m,_){if(l===m&&h===_)return null;this.numTests++;var C=l.getCoordinates()[h],F=l.getCoordinates()[h+1],rt=m.getCoordinates()[_],Dt=m.getCoordinates()[_+1];this._li.computeIntersection(C,F,rt,Dt),this._li.hasIntersection()&&(this._recordIsolated&&(l.setIsolated(!1),m.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(l,h,m,_)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(l.addIntersections(this._li,h,0),m.addIntersections(this._li,_,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))},j.prototype.interfaces_=function(){return[]},j.prototype.getClass=function(){return j},j.isAdjacentSegments=function(l,h){return 1===Math.abs(l-h)};var mt=function(l){function h(){l.call(this),this.events=new ue,this.nOverlaps=null}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.prepareEvents=function(){Yt.sort(this.events);for(var m=0;m<this.events.size();m++){var _=this.events.get(m);_.isDelete()&&_.getInsertEvent().setDeleteEventIndex(m)}},h.prototype.computeIntersections=function(){if(1===arguments.length){var m=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var _=0;_<this.events.size();_++){var C=this.events.get(_);if(C.isInsert()&&this.processOverlaps(_,C.getDeleteEventIndex(),C,m),m.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof j&&O(arguments[0],En)&&O(arguments[1],En)){var F=arguments[0],rt=arguments[1],Dt=arguments[2];this.addEdges(F,F),this.addEdges(rt,rt),this.computeIntersections(Dt)}else if("boolean"==typeof arguments[2]&&O(arguments[0],En)&&arguments[1]instanceof j){var Qt=arguments[0],fe=arguments[1];arguments[2]?this.addEdges(Qt,null):this.addEdges(Qt),this.computeIntersections(fe)}},h.prototype.addEdge=function(m,_){for(var C=m.getMonotoneChainEdge(),F=C.getStartIndexes(),rt=0;rt<F.length-1;rt++){var Dt=new fn(C,rt),Qt=new f(_,C.getMinX(rt),Dt);this.events.add(Qt),this.events.add(new f(C.getMaxX(rt),Qt))}},h.prototype.processOverlaps=function(m,_,C,F){for(var rt=C.getObject(),Dt=m;Dt<_;Dt++){var Qt=this.events.get(Dt);if(Qt.isInsert()){var fe=Qt.getObject();C.isSameLabel(Qt)||(rt.computeIntersections(fe,F),this.nOverlaps++)}}},h.prototype.addEdges=function(){if(1===arguments.length)for(var m=arguments[0].iterator();m.hasNext();){var _=m.next();this.addEdge(_,_)}else if(2===arguments.length)for(var F=arguments[1],rt=arguments[0].iterator();rt.hasNext();){var Dt=rt.next();this.addEdge(Dt,F)}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(D),Ft=function(){this._min=lt.POSITIVE_INFINITY,this._max=lt.NEGATIVE_INFINITY},ce={NodeComparator:{configurable:!0}};Ft.prototype.getMin=function(){return this._min},Ft.prototype.intersects=function(l,h){return!(this._min>h||this._max<l)},Ft.prototype.getMax=function(){return this._max},Ft.prototype.toString=function(){return Je.toLineString(new B(this._min,0),new B(this._max,0))},Ft.prototype.interfaces_=function(){return[]},Ft.prototype.getClass=function(){return Ft},ce.NodeComparator.get=function(){return ye},Object.defineProperties(Ft,ce);var ye=function(){};ye.prototype.compare=function(l,h){var C=(l._min+l._max)/2,F=(h._min+h._max)/2;return C<F?-1:C>F?1:0},ye.prototype.interfaces_=function(){return[pt]},ye.prototype.getClass=function(){return ye};var Ve=function(l){function h(){l.call(this),this._item=null;var _=arguments[1],C=arguments[2];this._min=arguments[0],this._max=_,this._item=C}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.query=function(m,_,C){if(!this.intersects(m,_))return null;C.visitItem(this._item)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Ft),sn=function(l){function h(){l.call(this),this._node1=null,this._node2=null;var _=arguments[1];this._node1=arguments[0],this._node2=_,this.buildExtent(this._node1,this._node2)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.buildExtent=function(m,_){this._min=Math.min(m._min,_._min),this._max=Math.max(m._max,_._max)},h.prototype.query=function(m,_,C){if(!this.intersects(m,_))return null;null!==this._node1&&this._node1.query(m,_,C),null!==this._node2&&this._node2.query(m,_,C)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Ft),bn=function(){this._leaves=new ue,this._root=null,this._level=0};bn.prototype.buildTree=function(){Yt.sort(this._leaves,new Ft.NodeComparator);for(var l=this._leaves,h=null,m=new ue;;){if(this.buildLevel(l,m),1===m.size())return m.get(0);h=l,l=m,m=h}},bn.prototype.insert=function(l,h,m){if(null!==this._root)throw new Error("Index cannot be added to once it has been queried");this._leaves.add(new Ve(l,h,m))},bn.prototype.query=function(l,h,m){this.init(),this._root.query(l,h,m)},bn.prototype.buildRoot=function(){if(null!==this._root)return null;this._root=this.buildTree()},bn.prototype.printNode=function(l){Xe.out.println(Je.toLineString(new B(l._min,this._level),new B(l._max,this._level)))},bn.prototype.init=function(){if(null!==this._root)return null;this.buildRoot()},bn.prototype.buildLevel=function(l,h){this._level++,h.clear();for(var m=0;m<l.size();m+=2){var _=l.get(m);if(null===(m+1<l.size()?l.get(m):null))h.add(_);else{var C=new sn(l.get(m),l.get(m+1));h.add(C)}}},bn.prototype.interfaces_=function(){return[]},bn.prototype.getClass=function(){return bn};var Pn=function(){this._items=new ue};Pn.prototype.visitItem=function(l){this._items.add(l)},Pn.prototype.getItems=function(){return this._items},Pn.prototype.interfaces_=function(){return[M]},Pn.prototype.getClass=function(){return Pn};var Nr=function(){this._index=null;var l=arguments[0];if(!O(l,Pa))throw new dt("Argument must be Polygonal");this._index=new ro(l)},yo={SegmentVisitor:{configurable:!0},IntervalIndexedGeometry:{configurable:!0}};Nr.prototype.locate=function(l){var h=new ii(l),m=new Qi(h);return this._index.query(l.y,l.y,m),h.getLocation()},Nr.prototype.interfaces_=function(){return[ru]},Nr.prototype.getClass=function(){return Nr},yo.SegmentVisitor.get=function(){return Qi},yo.IntervalIndexedGeometry.get=function(){return ro},Object.defineProperties(Nr,yo);var Qi=function(){this._counter=null,this._counter=arguments[0]};Qi.prototype.visitItem=function(l){var h=l;this._counter.countSegment(h.getCoordinate(0),h.getCoordinate(1))},Qi.prototype.interfaces_=function(){return[M]},Qi.prototype.getClass=function(){return Qi};var ro=function(){this._index=new bn,this.init(arguments[0])};ro.prototype.init=function(l){for(var h=qs.getLines(l).iterator();h.hasNext();){var m=h.next().getCoordinates();this.addLine(m)}},ro.prototype.addLine=function(l){for(var h=1;h<l.length;h++){var m=new tn(l[h-1],l[h]),_=Math.min(m.p0.y,m.p1.y),C=Math.max(m.p0.y,m.p1.y);this._index.insert(_,C,m)}},ro.prototype.query=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1],m=new Pn;return this._index.query(l,h,m),m.getItems()}3===arguments.length&&this._index.query(arguments[0],arguments[1],arguments[2])},ro.prototype.interfaces_=function(){return[]},ro.prototype.getClass=function(){return ro};var jo=function(l){function h(){if(l.call(this),this._parentGeom=null,this._lineEdgeMap=new ss,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new ea,2===arguments.length){var _=arguments[1],C=Rt.OGC_SFS_BOUNDARY_RULE;this._argIndex=arguments[0],this._parentGeom=_,this._boundaryNodeRule=C,null!==_&&this.add(_)}else if(3===arguments.length){var rt=arguments[1],Dt=arguments[2];this._argIndex=arguments[0],this._parentGeom=rt,this._boundaryNodeRule=Dt,null!==rt&&this.add(rt)}}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.insertBoundaryPoint=function(m,_){var C=this._nodes.addNode(_).getLabel(),F=1;C.getLocation(m,an.ON)===nt.BOUNDARY&&F++;var rt=h.determineBoundary(this._boundaryNodeRule,F);C.setLocation(m,rt)},h.prototype.computeSelfNodes=function(){if(2===arguments.length)return this.computeSelfNodes(arguments[0],arguments[1],!1);if(3===arguments.length){var F=arguments[1],rt=arguments[2],Dt=new j(arguments[0],!0,!1);return Dt.setIsDoneIfProperInt(rt),this.createEdgeSetIntersector().computeIntersections(this._edges,Dt,F||!(this._parentGeom instanceof eo||this._parentGeom instanceof rs||this._parentGeom instanceof wo)),this.addSelfIntersectionNodes(this._argIndex),Dt}},h.prototype.computeSplitEdges=function(m){for(var _=this._edges.iterator();_.hasNext();)_.next().eiList.addSplitEdges(m)},h.prototype.computeEdgeIntersections=function(m,_,C){var F=new j(_,C,!0);return F.setBoundaryNodes(this.getBoundaryNodes(),m.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,m._edges,F),F},h.prototype.getGeometry=function(){return this._parentGeom},h.prototype.getBoundaryNodeRule=function(){return this._boundaryNodeRule},h.prototype.hasTooFewPoints=function(){return this._hasTooFewPoints},h.prototype.addPoint=function(){if(arguments[0]instanceof Ls){var m=arguments[0].getCoordinate();this.insertPoint(this._argIndex,m,nt.INTERIOR)}else arguments[0]instanceof B&&this.insertPoint(this._argIndex,arguments[0],nt.INTERIOR)},h.prototype.addPolygon=function(m){this.addPolygonRing(m.getExteriorRing(),nt.EXTERIOR,nt.INTERIOR);for(var _=0;_<m.getNumInteriorRing();_++){var C=m.getInteriorRingN(_);this.addPolygonRing(C,nt.INTERIOR,nt.EXTERIOR)}},h.prototype.addEdge=function(m){this.insertEdge(m);var _=m.getCoordinates();this.insertPoint(this._argIndex,_[0],nt.BOUNDARY),this.insertPoint(this._argIndex,_[_.length-1],nt.BOUNDARY)},h.prototype.addLineString=function(m){var _=un.removeRepeatedPoints(m.getCoordinates());if(_.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=_[0],null;var C=new su(_,new We(this._argIndex,nt.INTERIOR));this._lineEdgeMap.put(m,C),this.insertEdge(C),Nn.isTrue(_.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,_[0]),this.insertBoundaryPoint(this._argIndex,_[_.length-1])},h.prototype.getInvalidPoint=function(){return this._invalidPoint},h.prototype.getBoundaryPoints=function(){for(var m=this.getBoundaryNodes(),_=new Array(m.size()).fill(null),C=0,F=m.iterator();F.hasNext();){var rt=F.next();_[C++]=rt.getCoordinate().copy()}return _},h.prototype.getBoundaryNodes=function(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes},h.prototype.addSelfIntersectionNode=function(m,_,C){if(this.isBoundaryNode(m,_))return null;C===nt.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(m,_):this.insertPoint(m,_,C)},h.prototype.addPolygonRing=function(m,_,C){if(m.isEmpty())return null;var F=un.removeRepeatedPoints(m.getCoordinates());if(F.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=F[0],null;var rt=_,Dt=C;yn.isCCW(F)&&(rt=C,Dt=_);var Qt=new su(F,new We(this._argIndex,nt.BOUNDARY,rt,Dt));this._lineEdgeMap.put(m,Qt),this.insertEdge(Qt),this.insertPoint(this._argIndex,F[0],nt.BOUNDARY)},h.prototype.insertPoint=function(m,_,C){var F=this._nodes.addNode(_),rt=F.getLabel();null===rt?F._label=new We(m,C):rt.setLocation(m,C)},h.prototype.createEdgeSetIntersector=function(){return new mt},h.prototype.addSelfIntersectionNodes=function(m){for(var _=this._edges.iterator();_.hasNext();)for(var C=_.next(),F=C.getLabel().getLocation(m),rt=C.eiList.iterator();rt.hasNext();){var Dt=rt.next();this.addSelfIntersectionNode(m,Dt.coord,F)}},h.prototype.add=function(){if(1!==arguments.length)return l.prototype.add.apply(this,arguments);var m=arguments[0];if(m.isEmpty())return null;if(m instanceof wo&&(this._useBoundaryDeterminationRule=!1),m instanceof rs)this.addPolygon(m);else if(m instanceof Vr)this.addLineString(m);else if(m instanceof Ls)this.addPoint(m);else if(m instanceof Oa)this.addCollection(m);else if(m instanceof js)this.addCollection(m);else if(m instanceof wo)this.addCollection(m);else{if(!(m instanceof zr))throw new Error(m.getClass().getName());this.addCollection(m)}},h.prototype.addCollection=function(m){for(var _=0;_<m.getNumGeometries();_++){var C=m.getGeometryN(_);this.add(C)}},h.prototype.locate=function(m){return O(this._parentGeom,Pa)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new Nr(this._parentGeom)),this._areaPtLocator.locate(m)):this._ptLocator.locate(m,this._parentGeom)},h.prototype.findEdge=function(){return 1===arguments.length?this._lineEdgeMap.get(arguments[0]):l.prototype.findEdge.apply(this,arguments)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.determineBoundary=function(m,_){return m.isInBoundary(_)?nt.BOUNDARY:nt.INTERIOR},h}(Or),na=function(){if(this._li=new di,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){var l=arguments[0];this.setComputationPrecision(l.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new jo(0,l)}else if(2===arguments.length){var h=arguments[0],m=arguments[1],_=Rt.OGC_SFS_BOUNDARY_RULE;h.getPrecisionModel().compareTo(m.getPrecisionModel())>=0?this.setComputationPrecision(h.getPrecisionModel()):this.setComputationPrecision(m.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new jo(0,h,_),this._arg[1]=new jo(1,m,_)}else if(3===arguments.length){var C=arguments[0],F=arguments[1],rt=arguments[2];C.getPrecisionModel().compareTo(F.getPrecisionModel())>=0?this.setComputationPrecision(C.getPrecisionModel()):this.setComputationPrecision(F.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new jo(0,C,rt),this._arg[1]=new jo(1,F,rt)}};na.prototype.getArgGeometry=function(l){return this._arg[l].getGeometry()},na.prototype.setComputationPrecision=function(l){this._resultPrecisionModel=l,this._li.setPrecisionModel(this._resultPrecisionModel)},na.prototype.interfaces_=function(){return[]},na.prototype.getClass=function(){return na};var fa=function(){};fa.prototype.interfaces_=function(){return[]},fa.prototype.getClass=function(){return fa},fa.map=function(){if(arguments[0]instanceof Hn&&O(arguments[1],fa.MapOp)){for(var l=arguments[0],h=arguments[1],m=new ue,_=0;_<l.getNumGeometries();_++){var C=h.map(l.getGeometryN(_));null!==C&&m.add(C)}return l.getFactory().buildGeometry(m)}if(O(arguments[0],je)&&O(arguments[1],fa.MapOp)){for(var F=arguments[0],rt=arguments[1],Dt=new ue,Qt=F.iterator();Qt.hasNext();){var fe=Qt.next(),ke=rt.map(fe);null!==ke&&Dt.add(ke)}return Dt}},fa.MapOp=function(){};var cr=function(l){function h(){var m=arguments[0];l.call(this,m,arguments[1]),this._ptLocator=new ea,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new po,this._resultPolyList=new ue,this._resultLineList=new ue,this._resultPointList=new ue,this._graph=new Or(new Vo),this._geomFact=m.getFactory()}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.insertUniqueEdge=function(m){var _=this._edgeList.findEqualEdge(m);if(null!==_){var C=_.getLabel(),F=m.getLabel();_.isPointwiseEqual(m)||(F=new We(m.getLabel())).flip();var rt=_.getDepth();rt.isNull()&&rt.add(C),rt.add(F),C.merge(F)}else this._edgeList.add(m)},h.prototype.getGraph=function(){return this._graph},h.prototype.cancelDuplicateResultEdges=function(){for(var m=this._graph.getEdgeEnds().iterator();m.hasNext();){var _=m.next(),C=_.getSym();_.isInResult()&&C.isInResult()&&(_.setInResult(!1),C.setInResult(!1))}},h.prototype.isCoveredByLA=function(m){return!!this.isCovered(m,this._resultLineList)||!!this.isCovered(m,this._resultPolyList)},h.prototype.computeGeometry=function(m,_,C,F){var rt=new ue;return rt.addAll(m),rt.addAll(_),rt.addAll(C),rt.isEmpty()?h.createEmptyResult(F,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(rt)},h.prototype.mergeSymLabels=function(){for(var m=this._graph.getNodes().iterator();m.hasNext();)m.next().getEdges().mergeSymLabels()},h.prototype.isCovered=function(m,_){for(var C=_.iterator();C.hasNext();){var F=C.next();if(this._ptLocator.locate(m,F)!==nt.EXTERIOR)return!0}return!1},h.prototype.replaceCollapsedEdges=function(){for(var m=new ue,_=this._edgeList.iterator();_.hasNext();){var C=_.next();C.isCollapsed()&&(_.remove(),m.add(C.getCollapsedEdge()))}this._edgeList.addAll(m)},h.prototype.updateNodeLabelling=function(){for(var m=this._graph.getNodes().iterator();m.hasNext();){var _=m.next(),C=_.getEdges().getLabel();_.getLabel().merge(C)}},h.prototype.getResultGeometry=function(m){return this.computeOverlay(m),this._resultGeom},h.prototype.insertUniqueEdges=function(m){for(var _=m.iterator();_.hasNext();){var C=_.next();this.insertUniqueEdge(C)}},h.prototype.computeOverlay=function(m){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);var _=new ue;this._arg[0].computeSplitEdges(_),this._arg[1].computeSplitEdges(_),this.insertUniqueEdges(_),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),vu.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(m),this.cancelDuplicateResultEdges();var C=new as(this._geomFact);C.add(this._graph),this._resultPolyList=C.getPolygons();var F=new ws(this,this._geomFact,this._ptLocator);this._resultLineList=F.build(m);var rt=new Tr(this,this._geomFact,this._ptLocator);this._resultPointList=rt.build(m),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,m)},h.prototype.labelIncompleteNode=function(m,_){var C=this._ptLocator.locate(m.getCoordinate(),this._arg[_].getGeometry());m.getLabel().setLocation(_,C)},h.prototype.copyPoints=function(m){for(var _=this._arg[m].getNodeIterator();_.hasNext();){var C=_.next();this._graph.addNode(C.getCoordinate()).setLabel(m,C.getLabel().getLocation(m))}},h.prototype.findResultAreaEdges=function(m){for(var _=this._graph.getEdgeEnds().iterator();_.hasNext();){var C=_.next(),F=C.getLabel();F.isArea()&&!C.isInteriorAreaEdge()&&h.isResultOfOp(F.getLocation(0,an.RIGHT),F.getLocation(1,an.RIGHT),m)&&C.setInResult(!0)}},h.prototype.computeLabelsFromDepths=function(){for(var m=this._edgeList.iterator();m.hasNext();){var _=m.next(),C=_.getLabel(),F=_.getDepth();if(!F.isNull()){F.normalize();for(var rt=0;rt<2;rt++)C.isNull(rt)||!C.isArea()||F.isNull(rt)||(0===F.getDelta(rt)?C.toLine(rt):(Nn.isTrue(!F.isNull(rt,an.LEFT),"depth of LEFT side has not been initialized"),C.setLocation(rt,an.LEFT,F.getLocation(rt,an.LEFT)),Nn.isTrue(!F.isNull(rt,an.RIGHT),"depth of RIGHT side has not been initialized"),C.setLocation(rt,an.RIGHT,F.getLocation(rt,an.RIGHT))))}}},h.prototype.computeLabelling=function(){for(var m=this._graph.getNodes().iterator();m.hasNext();)m.next().getEdges().computeLabelling(this._arg);this.mergeSymLabels(),this.updateNodeLabelling()},h.prototype.labelIncompleteNodes=function(){for(var m=this._graph.getNodes().iterator();m.hasNext();){var _=m.next(),C=_.getLabel();_.isIsolated()&&(C.isNull(0)?this.labelIncompleteNode(_,0):this.labelIncompleteNode(_,1)),_.getEdges().updateLabelling(C)}},h.prototype.isCoveredByA=function(m){return!!this.isCovered(m,this._resultPolyList)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(na);cr.overlayOp=function(l,h,m){return new cr(l,h).getResultGeometry(m)},cr.intersection=function(l,h){if(l.isEmpty()||h.isEmpty())return cr.createEmptyResult(cr.INTERSECTION,l,h,l.getFactory());if(l.isGeometryCollection()){var m=h;return or.map(l,{interfaces_:function(){return[fa.MapOp]},map:function(_){return _.intersection(m)}})}return l.checkNotGeometryCollection(l),l.checkNotGeometryCollection(h),Pe.overlayOp(l,h,cr.INTERSECTION)},cr.symDifference=function(l,h){if(l.isEmpty()||h.isEmpty()){if(l.isEmpty()&&h.isEmpty())return cr.createEmptyResult(cr.SYMDIFFERENCE,l,h,l.getFactory());if(l.isEmpty())return h.copy();if(h.isEmpty())return l.copy()}return l.checkNotGeometryCollection(l),l.checkNotGeometryCollection(h),Pe.overlayOp(l,h,cr.SYMDIFFERENCE)},cr.resultDimension=function(l,h,m){var _=h.getDimension(),C=m.getDimension(),F=-1;switch(l){case cr.INTERSECTION:F=Math.min(_,C);break;case cr.UNION:F=Math.max(_,C);break;case cr.DIFFERENCE:F=_;break;case cr.SYMDIFFERENCE:F=Math.max(_,C)}return F},cr.createEmptyResult=function(l,h,m,_){var C=null;switch(cr.resultDimension(l,h,m)){case-1:C=_.createGeometryCollection(new Array(0).fill(null));break;case 0:C=_.createPoint();break;case 1:C=_.createLineString();break;case 2:C=_.createPolygon()}return C},cr.difference=function(l,h){return l.isEmpty()?cr.createEmptyResult(cr.DIFFERENCE,l,h,l.getFactory()):h.isEmpty()?l.copy():(l.checkNotGeometryCollection(l),l.checkNotGeometryCollection(h),Pe.overlayOp(l,h,cr.DIFFERENCE))},cr.isResultOfOp=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1],m=l.getLocation(0),_=l.getLocation(1);return cr.isResultOfOp(m,_,h)}if(3===arguments.length){var C=arguments[0],F=arguments[1];switch(C===nt.BOUNDARY&&(C=nt.INTERIOR),F===nt.BOUNDARY&&(F=nt.INTERIOR),arguments[2]){case cr.INTERSECTION:return C===nt.INTERIOR&&F===nt.INTERIOR;case cr.UNION:return C===nt.INTERIOR||F===nt.INTERIOR;case cr.DIFFERENCE:return C===nt.INTERIOR&&F!==nt.INTERIOR;case cr.SYMDIFFERENCE:return C===nt.INTERIOR&&F!==nt.INTERIOR||C!==nt.INTERIOR&&F===nt.INTERIOR}return!1}},cr.INTERSECTION=1,cr.UNION=2,cr.DIFFERENCE=3,cr.SYMDIFFERENCE=4;var ou=function(){this._g=null,this._boundaryDistanceTolerance=null,this._linework=null,this._ptLocator=new ea,this._seg=new tn;var l=arguments[0],h=arguments[1];this._g=l,this._boundaryDistanceTolerance=h,this._linework=this.extractLinework(l)};ou.prototype.isWithinToleranceOfBoundary=function(l){for(var h=0;h<this._linework.getNumGeometries();h++)for(var m=this._linework.getGeometryN(h).getCoordinateSequence(),_=0;_<m.size()-1;_++)if(m.getCoordinate(_,this._seg.p0),m.getCoordinate(_+1,this._seg.p1),this._seg.distance(l)<=this._boundaryDistanceTolerance)return!0;return!1},ou.prototype.getLocation=function(l){return this.isWithinToleranceOfBoundary(l)?nt.BOUNDARY:this._ptLocator.locate(l,this._g)},ou.prototype.extractLinework=function(l){var h=new Lr;l.apply(h);var m=h.getLinework(),_=nr.toLineStringArray(m);return l.getFactory().createMultiLineString(_)},ou.prototype.interfaces_=function(){return[]},ou.prototype.getClass=function(){return ou};var Lr=function(){this._linework=null,this._linework=new ue};Lr.prototype.getLinework=function(){return this._linework},Lr.prototype.filter=function(l){if(l instanceof rs){var h=l;this._linework.add(h.getExteriorRing());for(var m=0;m<h.getNumInteriorRing();m++)this._linework.add(h.getInteriorRingN(m))}},Lr.prototype.interfaces_=function(){return[fi]},Lr.prototype.getClass=function(){return Lr};var Sl=function(){this._g=null,this._doLeft=!0,this._doRight=!0,this._g=arguments[0]};Sl.prototype.extractPoints=function(l,h,m){for(var _=l.getCoordinates(),C=0;C<_.length-1;C++)this.computeOffsetPoints(_[C],_[C+1],h,m)},Sl.prototype.setSidesToGenerate=function(l,h){this._doLeft=l,this._doRight=h},Sl.prototype.getPoints=function(l){for(var h=new ue,m=qs.getLines(this._g).iterator();m.hasNext();){var _=m.next();this.extractPoints(_,l,h)}return h},Sl.prototype.computeOffsetPoints=function(l,h,m,_){var C=h.x-l.x,F=h.y-l.y,rt=Math.sqrt(C*C+F*F),Dt=m*C/rt,Qt=m*F/rt,fe=(h.x+l.x)/2,ke=(h.y+l.y)/2;if(this._doLeft){var Ge=new B(fe-Qt,ke+Dt);_.add(Ge)}if(this._doRight){var _n=new B(fe+Qt,ke-Dt);_.add(_n)}},Sl.prototype.interfaces_=function(){return[]},Sl.prototype.getClass=function(){return Sl};var Qs=function l(){this._geom=null,this._locFinder=null,this._location=new Array(3).fill(null),this._invalidLocation=null,this._boundaryDistanceTolerance=l.TOLERANCE,this._testCoords=new ue;var h=arguments[0],m=arguments[1],_=arguments[2];this._boundaryDistanceTolerance=l.computeBoundaryDistanceTolerance(h,m),this._geom=[h,m,_],this._locFinder=[new ou(this._geom[0],this._boundaryDistanceTolerance),new ou(this._geom[1],this._boundaryDistanceTolerance),new ou(this._geom[2],this._boundaryDistanceTolerance)]},As={TOLERANCE:{configurable:!0}};Qs.prototype.reportResult=function(l,h,m){Xe.out.println("Overlay result invalid - A:"+nt.toLocationSymbol(h[0])+" B:"+nt.toLocationSymbol(h[1])+" expected:"+(m?"i":"e")+" actual:"+nt.toLocationSymbol(h[2]))},Qs.prototype.isValid=function(l){return this.addTestPts(this._geom[0]),this.addTestPts(this._geom[1]),this.checkValid(l)},Qs.prototype.checkValid=function(){if(1===arguments.length){for(var l=arguments[0],h=0;h<this._testCoords.size();h++){var m=this._testCoords.get(h);if(!this.checkValid(l,m))return this._invalidLocation=m,!1}return!0}if(2===arguments.length){var _=arguments[0],C=arguments[1];return this._location[0]=this._locFinder[0].getLocation(C),this._location[1]=this._locFinder[1].getLocation(C),this._location[2]=this._locFinder[2].getLocation(C),!!Qs.hasLocation(this._location,nt.BOUNDARY)||this.isValidResult(_,this._location)}},Qs.prototype.addTestPts=function(l){var h=new Sl(l);this._testCoords.addAll(h.getPoints(5*this._boundaryDistanceTolerance))},Qs.prototype.isValidResult=function(l,h){var m=cr.isResultOfOp(h[0],h[1],l),_=!(m^h[2]===nt.INTERIOR);return _||this.reportResult(l,h,m),_},Qs.prototype.getInvalidLocation=function(){return this._invalidLocation},Qs.prototype.interfaces_=function(){return[]},Qs.prototype.getClass=function(){return Qs},Qs.hasLocation=function(l,h){for(var m=0;m<3;m++)if(l[m]===h)return!0;return!1},Qs.computeBoundaryDistanceTolerance=function(l,h){return Math.min(gt.computeSizeBasedSnapTolerance(l),gt.computeSizeBasedSnapTolerance(h))},Qs.isValid=function(l,h,m,_){return new Qs(l,h,_).isValid(m)},As.TOLERANCE.get=function(){return 1e-6},Object.defineProperties(Qs,As);var bs=function l(h){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null,this._geomFactory=l.extractFactory(h),this._inputGeoms=h};bs.prototype.extractElements=function(l,h){if(null===l)return null;for(var m=0;m<l.getNumGeometries();m++){var _=l.getGeometryN(m);this._skipEmpty&&_.isEmpty()||h.add(_)}},bs.prototype.combine=function(){for(var l=new ue,h=this._inputGeoms.iterator();h.hasNext();){var m=h.next();this.extractElements(m,l)}return 0===l.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection(null):null:this._geomFactory.buildGeometry(l)},bs.prototype.interfaces_=function(){return[]},bs.prototype.getClass=function(){return bs},bs.combine=function(){return 1===arguments.length?new bs(arguments[0]).combine():2===arguments.length?new bs(bs.createList(arguments[0],arguments[1])).combine():3===arguments.length?new bs(bs.createList(arguments[0],arguments[1],arguments[2])).combine():void 0},bs.extractFactory=function(l){return l.isEmpty()?null:l.iterator().next().getFactory()},bs.createList=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1],m=new ue;return m.add(l),m.add(h),m}if(3===arguments.length){var _=arguments[0],C=arguments[1],F=arguments[2],rt=new ue;return rt.add(_),rt.add(C),rt.add(F),rt}};var Is=function(){this._inputPolys=null,this._geomFactory=null,this._inputPolys=arguments[0],null===this._inputPolys&&(this._inputPolys=new ue)},ra={STRTREE_NODE_CAPACITY:{configurable:!0}};Is.prototype.reduceToGeometries=function(l){for(var h=new ue,m=l.iterator();m.hasNext();){var _=m.next(),C=null;O(_,En)?C=this.unionTree(_):_ instanceof Hn&&(C=_),h.add(C)}return h},Is.prototype.extractByEnvelope=function(l,h,m){for(var _=new ue,C=0;C<h.getNumGeometries();C++){var F=h.getGeometryN(C);F.getEnvelopeInternal().intersects(l)?_.add(F):m.add(F)}return this._geomFactory.buildGeometry(_)},Is.prototype.unionOptimized=function(l,h){var m=l.getEnvelopeInternal(),_=h.getEnvelopeInternal();if(!m.intersects(_))return bs.combine(l,h);if(l.getNumGeometries()<=1&&h.getNumGeometries()<=1)return this.unionActual(l,h);var C=m.intersection(_);return this.unionUsingEnvelopeIntersection(l,h,C)},Is.prototype.union=function(){if(null===this._inputPolys)throw new Error("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();for(var l=new Cn(Is.STRTREE_NODE_CAPACITY),h=this._inputPolys.iterator();h.hasNext();){var m=h.next();l.insert(m.getEnvelopeInternal(),m)}this._inputPolys=null;var _=l.itemsTree();return this.unionTree(_)},Is.prototype.binaryUnion=function(){if(1===arguments.length){var l=arguments[0];return this.binaryUnion(l,0,l.size())}if(3===arguments.length){var h=arguments[0],m=arguments[1],_=arguments[2];if(_-m<=1){var C=Is.getGeometry(h,m);return this.unionSafe(C,null)}if(_-m==2)return this.unionSafe(Is.getGeometry(h,m),Is.getGeometry(h,m+1));var F=Math.trunc((_+m)/2),rt=this.binaryUnion(h,m,F),Dt=this.binaryUnion(h,F,_);return this.unionSafe(rt,Dt)}},Is.prototype.repeatedUnion=function(l){for(var h=null,m=l.iterator();m.hasNext();){var _=m.next();h=null===h?_.copy():h.union(_)}return h},Is.prototype.unionSafe=function(l,h){return null===l&&null===h?null:null===l?h.copy():null===h?l.copy():this.unionOptimized(l,h)},Is.prototype.unionActual=function(l,h){return Is.restrictToPolygons(l.union(h))},Is.prototype.unionTree=function(l){var h=this.reduceToGeometries(l);return this.binaryUnion(h)},Is.prototype.unionUsingEnvelopeIntersection=function(l,h,m){var _=new ue,C=this.extractByEnvelope(m,l,_),F=this.extractByEnvelope(m,h,_),rt=this.unionActual(C,F);return _.add(rt),bs.combine(_)},Is.prototype.bufferUnion=function(){if(1===arguments.length){var l=arguments[0];return l.get(0).getFactory().buildGeometry(l).buffer(0)}if(2===arguments.length){var h=arguments[0],m=arguments[1];return h.getFactory().createGeometryCollection([h,m]).buffer(0)}},Is.prototype.interfaces_=function(){return[]},Is.prototype.getClass=function(){return Is},Is.restrictToPolygons=function(l){if(O(l,Pa))return l;var h=wa.getPolygons(l);return 1===h.size()?h.get(0):l.getFactory().createMultiPolygon(nr.toPolygonArray(h))},Is.getGeometry=function(l,h){return h>=l.size()?null:l.get(h)},Is.union=function(l){return new Is(l).union()},ra.STRTREE_NODE_CAPACITY.get=function(){return 4},Object.defineProperties(Is,ra);var Qu=function(){};Qu.prototype.interfaces_=function(){return[]},Qu.prototype.getClass=function(){return Qu},Qu.union=function(l,h){if(l.isEmpty()||h.isEmpty()){if(l.isEmpty()&&h.isEmpty())return cr.createEmptyResult(cr.UNION,l,h,l.getFactory());if(l.isEmpty())return h.copy();if(h.isEmpty())return l.copy()}return l.checkNotGeometryCollection(l),l.checkNotGeometryCollection(h),Pe.overlayOp(l,h,cr.UNION)},y.GeoJSONReader=Yi,y.GeoJSONWriter=La,y.OverlayOp=cr,y.UnionOp=Qu,y.BufferOp=Ns,Object.defineProperty(y,"__esModule",{value:!0})}(ut)},5410:()=>{},8628:()=>{},1601:()=>{},7792:()=>{},4977:()=>{},5042:()=>{},7156:Lt=>{function ut($,V,H,q,Y,R,W){try{var k=$[R](W),A=k.value}catch(X){return void H(X)}k.done?V(A):Promise.resolve(A).then(q,Y)}Lt.exports=function y($){return function(){var V=this,H=arguments;return new Promise(function(q,Y){var R=$.apply(V,H);function W(A){ut(R,q,Y,W,k,"next",A)}function k(A){ut(R,q,Y,W,k,"throw",A)}W(void 0)})}},Lt.exports.__esModule=!0,Lt.exports.default=Lt.exports},5861:(Lt,ut,y)=>{"use strict";function $(H,q,Y,R,W,k,A){try{var X=H[k](A),Z=X.value}catch(G){return void Y(G)}X.done?q(Z):Promise.resolve(Z).then(R,W)}function V(H){return function(){var q=this,Y=arguments;return new Promise(function(R,W){var k=H.apply(q,Y);function A(Z){$(k,R,W,A,X,"next",Z)}function X(Z){$(k,R,W,A,X,"throw",Z)}A(void 0)})}}y.d(ut,{Z:()=>V})}},Lt=>{Lt(Lt.s=1205)}]);