(self.webpackChunkmap_fog_style=self.webpackChunkmap_fog_style||[]).push([[179],{1324:(Lt,ut,y)=>{"use strict";var $={};function V(t){return"function"==typeof t}function H(t){const e=t(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}y.r($),y.d($,{addImpl:()=>VB,bincountImpl:()=>HI,bincountReduceImpl:()=>KB,bitwiseAndImpl:()=>XB,castImpl:()=>zB,ceilImpl:()=>ZB,concatImpl:()=>YB,equalImpl:()=>JB,expImpl:()=>e3,expm1Impl:()=>r3,floorImpl:()=>o3,gatherNdImpl:()=>a3,gatherV2Impl:()=>u3,greaterEqualImpl:()=>c3,greaterImpl:()=>l3,lessEqualImpl:()=>d3,lessImpl:()=>h3,linSpaceImpl:()=>f3,logImpl:()=>p3,maxImpl:()=>m3,maximumImpl:()=>y3,minimumImpl:()=>v3,multiplyImpl:()=>jI,negImpl:()=>x3,notEqualImpl:()=>E3,prodImpl:()=>I3,raggedGatherImpl:()=>D3,raggedRangeImpl:()=>N3,raggedTensorToTensorImpl:()=>P3,rangeImpl:()=>O3,rsqrtImpl:()=>R3,scatterImpl:()=>Xd,sigmoidImpl:()=>Out,simpleAbsImpl:()=>WB,sliceImpl:()=>jB,sparseFillEmptyRowsImpl:()=>k3,sparseReshapeImpl:()=>F3,sparseSegmentReductionImpl:()=>qI,sqrtImpl:()=>upt,staticRegexReplaceImpl:()=>$3,stridedSliceImpl:()=>B3,stringNGramsImpl:()=>z3,stringSplitImpl:()=>V3,stringToHashBucketFastImpl:()=>U3,subImpl:()=>i3,tileImpl:()=>W3,topKImpl:()=>H3,transposeImpl:()=>WI,uniqueImpl:()=>K3});const Q=H(t=>function(e){t(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,i)=>`${i+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function Y(t,n){if(t){const e=t.indexOf(n);0<=e&&t.splice(e,1)}}class R{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const s of e)s.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(V(r))try{r()}catch(s){n=s instanceof Q?s.errors:[s]}const{_finalizers:i}=this;if(i){this._finalizers=null;for(const s of i)try{A(s)}catch(o){n=n??[],o instanceof Q?n=[...n,...o.errors]:n.push(o)}}if(n)throw new Q(n)}}add(n){var e;if(n&&n!==this)if(this.closed)A(n);else{if(n instanceof R){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(n)}}_hasParent(n){const{_parentage:e}=this;return e===n||Array.isArray(e)&&e.includes(n)}_addParent(n){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(n),e):e?[e,n]:n}_removeParent(n){const{_parentage:e}=this;e===n?this._parentage=null:Array.isArray(e)&&Y(e,n)}remove(n){const{_finalizers:e}=this;e&&Y(e,n),n instanceof R&&n._removeParent(this)}}R.EMPTY=(()=>{const t=new R;return t.closed=!0,t})();const W=R.EMPTY;function k(t){return t instanceof R||t&&"closed"in t&&V(t.remove)&&V(t.add)&&V(t.unsubscribe)}function A(t){V(t)?t():t.unsubscribe()}const X={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Z={setTimeout(t,n,...e){const{delegate:r}=Z;return r?.setTimeout?r.setTimeout(t,n,...e):setTimeout(t,n,...e)},clearTimeout(t){const{delegate:n}=Z;return(n?.clearTimeout||clearTimeout)(t)},delegate:void 0};function G(t){Z.setTimeout(()=>{const{onUnhandledError:n}=X;if(!n)throw t;n(t)})}function it(){}const wt=et("C",void 0,void 0);function et(t,n,e){return{kind:t,value:n,error:e}}let dt=null;function lt(t){if(X.useDeprecatedSynchronousErrorHandling){const n=!dt;if(n&&(dt={errorThrown:!1,error:null}),t(),n){const{errorThrown:e,error:r}=dt;if(dt=null,e)throw r}}else t()}class q extends R{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,k(n)&&n.add(this)):this.destination=Gt}static create(n,e,r){return new ot(n,e,r)}next(n){this.isStopped?nt(function st(t){return et("N",t,void 0)}(n),this):this._next(n)}error(n){this.isStopped?nt(function K(t){return et("E",void 0,t)}(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?nt(wt,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const ft=Function.prototype.bind;function pt(t,n){return ft.call(t,n)}class B{constructor(n){this.partialObserver=n}next(n){const{partialObserver:e}=this;if(e.next)try{e.next(n)}catch(r){P(r)}}error(n){const{partialObserver:e}=this;if(e.error)try{e.error(n)}catch(r){P(r)}else P(n)}complete(){const{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(e){P(e)}}}class ot extends q{constructor(n,e,r){let i;if(super(),V(n)||!n)i={next:n??void 0,error:e??void 0,complete:r??void 0};else{let s;this&&X.useDeprecatedNextContext?(s=Object.create(n),s.unsubscribe=()=>this.unsubscribe(),i={next:n.next&&pt(n.next,s),error:n.error&&pt(n.error,s),complete:n.complete&&pt(n.complete,s)}):i=n}this.destination=new B(i)}}function P(t){X.useDeprecatedSynchronousErrorHandling?function St(t){X.useDeprecatedSynchronousErrorHandling&&dt&&(dt.errorThrown=!0,dt.error=t)}(t):G(t)}function nt(t,n){const{onStoppedNotification:e}=X;e&&Z.setTimeout(()=>e(t,n))}const Gt={closed:!0,next:it,error:function at(t){throw t},complete:it},O="function"==typeof Symbol&&Symbol.observable||"@@observable";function Ct(t){return t}function vt(t){return 0===t.length?Ct:1===t.length?t[0]:function(e){return t.reduce((r,i)=>i(r),e)}}let xt=(()=>{class t{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,i){const s=function re(t){return t&&t instanceof q||function It(t){return t&&V(t.next)&&V(t.error)&&V(t.complete)}(t)&&k(t)}(e)?e:new ot(e,r,i);return lt(()=>{const{operator:o,source:a}=this;s.add(o?o.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=Mt(r))((i,s)=>{const o=new ot({next:a=>{try{e(a)}catch(u){s(u),o.unsubscribe()}},error:s,complete:i});this.subscribe(o)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[O](){return this}pipe(...e){return vt(e)(this)}toPromise(e){return new(e=Mt(e))((r,i)=>{let s;this.subscribe(o=>s=o,o=>i(o),()=>r(s))})}}return t.create=n=>new t(n),t})();function Mt(t){var n;return null!==(n=t??X.Promise)&&void 0!==n?n:Promise}const Bt=H(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let ee=(()=>{class t extends xt{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new jt(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new Bt}next(e){lt(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){lt(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){lt(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:i,observers:s}=this;return r||i?W:(this.currentObservers=null,s.push(e),new R(()=>{this.currentObservers=null,Y(s,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:i,isStopped:s}=this;r?e.error(i):s&&e.complete()}asObservable(){const e=new xt;return e.source=this,e}}return t.create=(n,e)=>new jt(n,e),t})();class jt extends ee{constructor(n,e){super(),this.destination=n,this.source=e}next(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,n)}error(n){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,n)}complete(){var n,e;null===(e=null===(n=this.destination)||void 0===n?void 0:n.complete)||void 0===e||e.call(n)}_subscribe(n){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(n))&&void 0!==r?r:W}}function se(t){return V(t?.lift)}function we(t){return n=>{if(se(n))return n.lift(function(e){try{return t(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function Me(t,n,e,r,i){return new Xe(t,n,e,r,i)}class Xe extends q{constructor(n,e,r,i,s,o){super(n),this.onFinalize=s,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(u){n.error(u)}}:super._next,this._error=i?function(a){try{i(a)}catch(u){n.error(u)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(n=this.onFinalize)||void 0===n||n.call(this))}}}function Ue(t,n){return we((e,r)=>{let i=0;e.subscribe(Me(r,s=>{r.next(t.call(n,s,i++))}))})}function Ce(t){return this instanceof Ce?(this.v=t,this):new Ce(t)}function te(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t=function yn(t){var n="function"==typeof Symbol&&Symbol.iterator,e=n&&t[n],r=0;if(e)return e.call(t);if(t&&"number"==typeof t.length)return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(s){e[s]=t[s]&&function(o){return new Promise(function(a,u){!function i(s,o,a,u){Promise.resolve(u).then(function(c){s({value:c,done:a})},o)}(a,u,(o=t[s](o)).done,o.value)})}}}"function"==typeof SuppressedError&&SuppressedError;const ir=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function dr(t){return V(t?.then)}function zn(t){return V(t[O])}function _n(t){return Symbol.asyncIterator&&V(t?.[Symbol.asyncIterator])}function sr(t){return new TypeError(`You provided ${null!==t&&"object"==typeof t?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const qn=function Jr(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function br(t){return V(t?.[qn])}function Dn(t){return function Et(t,n,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,r=e.apply(t,n||[]),s=[];return i={},o("next"),o("throw"),o("return"),i[Symbol.asyncIterator]=function(){return this},i;function o(v){r[v]&&(i[v]=function(x){return new Promise(function(b,w){s.push([v,x,b,w])>1||a(v,x)})})}function a(v,x){try{!function u(v){v.value instanceof Ce?Promise.resolve(v.value.v).then(c,d):p(s[0][2],v)}(r[v](x))}catch(b){p(s[0][3],b)}}function c(v){a("next",v)}function d(v){a("throw",v)}function p(v,x){v(x),s.shift(),s.length&&a(s[0][0],s[0][1])}}(this,arguments,function*(){const e=t.getReader();try{for(;;){const{value:r,done:i}=yield Ce(e.read());if(i)return yield Ce(void 0);yield yield Ce(r)}}finally{e.releaseLock()}})}function si(t){return V(t?.getReader)}function kr(t){if(t instanceof xt)return t;if(null!=t){if(zn(t))return function tr(t){return new xt(n=>{const e=t[O]();if(V(e.subscribe))return e.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(t);if(ir(t))return function Zi(t){return new xt(n=>{for(let e=0;e<t.length&&!n.closed;e++)n.next(t[e]);n.complete()})}(t);if(dr(t))return function fi(t){return new xt(n=>{t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,G)})}(t);if(_n(t))return zr(t);if(br(t))return function oi(t){return new xt(n=>{for(const e of t)if(n.next(e),n.closed)return;n.complete()})}(t);if(si(t))return function js(t){return zr(Dn(t))}(t)}throw sr(t)}function zr(t){return new xt(n=>{(function ho(t,n){var e,r,i,s;return function hi(t,n,e,r){return new(e||(e=Promise))(function(s,o){function a(d){try{c(r.next(d))}catch(p){o(p)}}function u(d){try{c(r.throw(d))}catch(p){o(p)}}function c(d){d.done?s(d.value):function i(s){return s instanceof e?s:new e(function(o){o(s)})}(d.value).then(a,u)}c((r=r.apply(t,n||[])).next())})}(this,void 0,void 0,function*(){try{for(e=te(t);!(r=yield e.next()).done;)if(n.next(r.value),n.closed)return}catch(o){i={error:o}}finally{try{r&&!r.done&&(s=e.return)&&(yield s.call(e))}finally{if(i)throw i.error}}n.complete()})})(t,n).catch(e=>n.error(e))})}function Es(t,n,e,r=0,i=!1){const s=n.schedule(function(){e(),i?t.add(this.schedule(null,r)):this.unsubscribe()},r);if(t.add(s),!i)return s}function Rs(t,n,e=1/0){return V(n)?Rs((r,i)=>Ue((s,o)=>n(r,s,i,o))(kr(t(r,i))),e):("number"==typeof n&&(e=n),we((r,i)=>function Ks(t,n,e,r,i,s,o,a){const u=[];let c=0,d=0,p=!1;const v=()=>{p&&!u.length&&!c&&n.complete()},x=w=>c<r?b(w):u.push(w),b=w=>{s&&n.next(w),c++;let T=!1;kr(e(w,d++)).subscribe(Me(n,N=>{i?.(N),s?x(N):n.next(N)},()=>{T=!0},void 0,()=>{if(T)try{for(c--;u.length&&c<r;){const N=u.shift();o?Es(n,o,()=>b(N)):b(N)}v()}catch(N){n.error(N)}}))};return t.subscribe(Me(n,x,()=>{p=!0,v()})),()=>{a?.()}}(r,i,t,e)))}function ti(t=1/0){return Rs(Ct,t)}const Vr=new xt(t=>t.complete());function rs(t){return t[t.length-1]}function Pa(t){return V(rs(t))?t.pop():void 0}function eo(t){return function Ma(t){return t&&V(t.schedule)}(rs(t))?t.pop():void 0}function gs(t,n=0){return we((e,r)=>{e.subscribe(Me(r,i=>Es(r,t,()=>r.next(i),n),()=>Es(r,t,()=>r.complete(),n),i=>Es(r,t,()=>r.error(i),n)))})}function Ua(t,n=0){return we((e,r)=>{r.add(t.schedule(()=>e.subscribe(r),n))})}function du(t,n){if(!t)throw new Error("Iterable cannot be null");return new xt(e=>{Es(e,n,()=>{const r=t[Symbol.asyncIterator]();Es(e,n,()=>{r.next().then(i=>{i.done?e.complete():e.next(i.value)})},0,!0)})})}function ys(t,n){return n?function Wa(t,n){if(null!=t){if(zn(t))return function bu(t,n){return kr(t).pipe(Ua(n),gs(n))}(t,n);if(ir(t))return function $r(t,n){return new xt(e=>{let r=0;return n.schedule(function(){r===t.length?e.complete():(e.next(t[r++]),e.closed||this.schedule())})})}(t,n);if(dr(t))return function Oa(t,n){return kr(t).pipe(Ua(n),gs(n))}(t,n);if(_n(t))return du(t,n);if(br(t))return function pr(t,n){return new xt(e=>{let r;return Es(e,n,()=>{r=t[qn](),Es(e,n,()=>{let i,s;try{({value:i,done:s}=r.next())}catch(o){return void e.error(o)}s?e.complete():e.next(i)},0,!0)}),()=>V(r?.return)&&r.return()})}(t,n);if(si(t))return function Xs(t,n){return du(Dn(t),n)}(t,n)}throw sr(t)}(t,n):kr(t)}class Gr extends ee{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){const e=super._subscribe(n);return!e.closed&&n.next(this._value),e}getValue(){const{hasError:n,thrownError:e,_value:r}=this;if(n)throw e;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}}function Qn(...t){return ys(t,eo(t))}function ma(t={}){const{connector:n=(()=>new ee),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:i=!0}=t;return s=>{let o,a,u,c=0,d=!1,p=!1;const v=()=>{a?.unsubscribe(),a=void 0},x=()=>{v(),o=u=void 0,d=p=!1},b=()=>{const w=o;x(),w?.unsubscribe()};return we((w,T)=>{c++,!p&&!d&&v();const N=u=u??n();T.add(()=>{c--,0===c&&!p&&!d&&(a=er(b,i))}),N.subscribe(T),!o&&c>0&&(o=new ot({next:S=>N.next(S),error:S=>{p=!0,v(),a=er(x,e,S),N.error(S)},complete:()=>{d=!0,v(),a=er(x,r),N.complete()}}),kr(w).subscribe(o))})(s)}}function er(t,n,...e){if(!0===n)return void t();if(!1===n)return;const r=new ot({next:()=>{r.unsubscribe(),t()}});return kr(n(...e)).subscribe(r)}function bo(t,n){return we((e,r)=>{let i=null,s=0,o=!1;const a=()=>o&&!i&&r.complete();e.subscribe(Me(r,u=>{i?.unsubscribe();let c=0;const d=s++;kr(t(u,d)).subscribe(i=Me(r,p=>r.next(n?n(u,p,d,c++):p),()=>{i=null,a()}))},()=>{o=!0,a()}))})}function ga(t,n){return t===n}function Xn(t){for(let n in t)if(t[n]===Xn)return n;throw Error("Could not find renamed property on target object.")}function Cs(t,n){for(const e in n)n.hasOwnProperty(e)&&!t.hasOwnProperty(e)&&(t[e]=n[e])}function Yi(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(Yi).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const n=t.toString();if(null==n)return""+n;const e=n.indexOf("\n");return-1===e?n:n.substring(0,e)}function Ra(t,n){return null==t||""===t?null===n?"":n:null==n||""===n?t:t+" "+n}const an=Xn({__forward_ref__:Xn});function ei(t){return t.__forward_ref__=ei,t.toString=function(){return Yi(this())},t}function Fn(t){return Ss(t)?t():t}function Ss(t){return"function"==typeof t&&t.hasOwnProperty(an)&&t.__forward_ref__===ei}function wo(t){return t&&!!t.\u0275providers}class We extends Error{constructor(n,e){super(function Kr(t,n){return`NG0${Math.abs(t)}${n?": "+n:""}`}(n,e)),this.code=n}}function mr(t){return"string"==typeof t?t:null==t?"":String(t)}function Wr(t,n){throw new We(-201,!1)}function Yt(t,n){null==t&&function kt(t,n,e,r){throw new Error(`ASSERTION ERROR: ${t}`+(null==r?"":` [Expected=> ${e} ${r} ${n} <=Actual]`))}(n,t,null,"!=")}function $e(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function $n(t){return{providers:t.providers||[],imports:t.imports||[]}}function Vn(t){return bn(t,Zs)||bn(t,tn)}function bn(t,n){return t.hasOwnProperty(n)?t[n]:null}function ni(t){return t&&(t.hasOwnProperty(Xr)||t.hasOwnProperty(Iu))?t[Xr]:null}const Zs=Xn({\u0275prov:Xn}),Xr=Xn({\u0275inj:Xn}),tn=Xn({ngInjectableDef:Xn}),Iu=Xn({ngInjectorDef:Xn});var xr=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}(xr||{});let Qi;function vs(t){const n=Qi;return Qi=t,n}function Lu(t,n,e){const r=Vn(t);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&xr.Optional?null:void 0!==n?n:void Wr(Yi(t))}const as=globalThis;class In{constructor(n,e){this._desc=n,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=$e({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}const Br={},es="__NG_DI_FLAG__",nu="ngTempTokenPath",us=/\n/gm,ya="__source";let zo;function po(t){const n=zo;return zo=t,n}function qo(t,n=xr.Default){if(void 0===zo)throw new We(-203,!1);return null===zo?Lu(t,void 0,n):zo.get(t,n&xr.Optional?null:void 0,n)}function Hn(t,n=xr.Default){return(function fo(){return Qi}()||qo)(Fn(t),n)}function Mn(t,n=xr.Default){return Hn(t,ua(n))}function ua(t){return typeof t>"u"||"number"==typeof t?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function _a(t){const n=[];for(let e=0;e<t.length;e++){const r=Fn(t[e]);if(Array.isArray(r)){if(0===r.length)throw new We(900,!1);let i,s=xr.Default;for(let o=0;o<r.length;o++){const a=r[o],u=mo(a);"number"==typeof u?-1===u?i=a.token:s|=u:i=a}n.push(Hn(i,s))}else n.push(Hn(r))}return n}function ls(t,n){return t[es]=n,t.prototype[es]=n,t}function mo(t){return t[es]}function $s(t){return{toString:t}.toString()}var Vo=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}(Vo||{}),xa=function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}(xa||{});const mi={},yi=[],La=Xn({\u0275cmp:Xn}),Su=Xn({\u0275dir:Xn}),Ga=Xn({\u0275pipe:Xn}),pl=Xn({\u0275mod:Xn}),Jo=Xn({\u0275fac:Xn}),Uo=Xn({__NG_ELEMENT_ID__:Xn}),Ts=Xn({__NG_ENV_ID__:Xn});function Du(t,n,e){let r=t.length;for(;;){const i=t.indexOf(n,e);if(-1===i)return i;if(0===i||t.charCodeAt(i-1)<=32){const s=n.length;if(i+s===r||t.charCodeAt(i+s)<=32)return i}e=i+1}}function Bs(t,n,e){let r=0;for(;r<e.length;){const i=e[r];if("number"==typeof i){if(0!==i)break;r++;const s=e[r++],o=e[r++],a=e[r++];t.setAttribute(n,o,a,s)}else{const s=i,o=e[++r];Ea(s)?t.setProperty(n,s,o):t.setAttribute(n,s,o),r++}}return r}function Wo(t){return 3===t||4===t||6===t}function Ea(t){return 64===t.charCodeAt(0)}function Tu(t,n){if(null!==n&&0!==n.length)if(null===t||0===t.length)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){const i=n[r];"number"==typeof i?e=i:0===e||mu(t,e,i,null,-1===e||2===e?n[++r]:null)}}return t}function mu(t,n,e,r,i){let s=0,o=t.length;if(-1===n)o=-1;else for(;s<t.length;){const a=t[s++];if("number"==typeof a){if(a===n){o=-1;break}if(a>n){o=s-1;break}}}for(;s<t.length;){const a=t[s];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==i&&(t[s+1]=i));if(r===t[s+1])return void(t[s+2]=i)}s++,null!==r&&s++,null!==i&&s++}-1!==o&&(t.splice(o,0,n),s=o+1),t.splice(s++,0,e),null!==r&&t.splice(s++,0,r),null!==i&&t.splice(s++,0,i)}const Ha="ng-template";function Ca(t,n,e){let r=0,i=!0;for(;r<t.length;){let s=t[r++];if("string"==typeof s&&i){const o=t[r++];if(e&&"class"===s&&-1!==Du(o.toLowerCase(),n,0))return!0}else{if(1===s){for(;r<t.length&&"string"==typeof(s=t[r++]);)if(s.toLowerCase()===n)return!0;return!1}"number"==typeof s&&(i=!1)}}return!1}function Qs(t){return 4===t.type&&t.value!==Ha}function ta(t,n,e){return n===(4!==t.type||e?t.value:Ha)}function go(t,n,e){let r=4;const i=t.attrs||[],s=function So(t){for(let n=0;n<t.length;n++)if(Wo(t[n]))return n;return t.length}(i);let o=!1;for(let a=0;a<n.length;a++){const u=n[a];if("number"!=typeof u){if(!o)if(4&r){if(r=2|1&r,""!==u&&!ta(t,u,e)||""===u&&1===n.length){if(ka(r))return!1;o=!0}}else{const c=8&r?u:n[++a];if(8&r&&null!==t.attrs){if(!Ca(t.attrs,c,e)){if(ka(r))return!1;o=!0}continue}const p=gu(8&r?"class":u,i,Qs(t),e);if(-1===p){if(ka(r))return!1;o=!0;continue}if(""!==c){let v;v=p>s?"":i[p+1].toLowerCase();const x=8&r?v:null;if(x&&-1!==Du(x,c,0)||2&r&&c!==v){if(ka(r))return!1;o=!0}}}}else{if(!o&&!ka(r)&&!ka(u))return!1;if(o&&ka(u))continue;o=!1,r=u|1&r}}return ka(r)||o}function ka(t){return 0==(1&t)}function gu(t,n,e,r){if(null===n)return-1;let i=0;if(r||!e){let s=!1;for(;i<n.length;){const o=n[i];if(o===t)return i;if(3===o||6===o)s=!0;else{if(1===o||2===o){let a=n[++i];for(;"string"==typeof a;)a=n[++i];continue}if(4===o)break;if(0===o){i+=4;continue}}i+=s?1:2}return-1}return function la(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){const r=t[e];if("number"==typeof r)return-1;if(r===n)return e;e++}return-1}(n,t)}function Io(t,n,e=!1){for(let r=0;r<n.length;r++)if(go(t,n[r],e))return!0;return!1}function wl(t,n){return t?":not("+n.trim()+")":n}function Nu(t){let n=t[0],e=1,r=2,i="",s=!1;for(;e<t.length;){let o=t[e];if("string"==typeof o)if(2&r){const a=t[++e];i+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?i+="."+o:4&r&&(i+=" "+o);else""!==i&&!ka(o)&&(n+=wl(s,i),i=""),r=o,s=s||!ka(r);e++}return""!==i&&(n+=wl(s,i)),n}function ca(t){return $s(()=>{const n=_t(t),e={...n,decls:t.decls,vars:t.vars,template:t.template,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,onPush:t.changeDetection===Vo.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&t.dependencies||null,getStandaloneInjector:null,signals:t.signals??!1,data:t.data||{},encapsulation:t.encapsulation||xa.Emulated,styles:t.styles||yi,_:null,schemas:t.schemas||null,tView:null,id:""};Nt(e);const r=t.dependencies;return e.directiveDefs=Kt(r,!1),e.pipeDefs=Kt(r,!0),e.id=function Ee(t){let n=0;const e=[t.selectors,t.ngContentSelectors,t.hostVars,t.hostAttrs,t.consts,t.vars,t.decls,t.encapsulation,t.standalone,t.signals,t.exportAs,JSON.stringify(t.inputs),JSON.stringify(t.outputs),Object.getOwnPropertyNames(t.type.prototype),!!t.contentQueries,!!t.viewQuery].join("|");for(const i of e)n=Math.imul(31,n)+i.charCodeAt(0)<<0;return n+=2147483648,"c"+n}(e),e})}function jl(t){return Tr(t)||ri(t)}function ja(t){return null!==t}function Yr(t){return $s(()=>({type:t.type,bootstrap:t.bootstrap||yi,declarations:t.declarations||yi,imports:t.imports||yi,exports:t.exports||yi,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function yu(t,n){if(null==t)return mi;const e={};for(const r in t)if(t.hasOwnProperty(r)){let i=t[r],s=i;Array.isArray(i)&&(s=i[1],i=i[0]),e[i]=r,n&&(n[i]=s)}return e}function or(t){return $s(()=>{const n=_t(t);return Nt(n),n})}function bs(t){return{type:t.type,name:t.name,factory:null,pure:!1!==t.pure,standalone:!0===t.standalone,onDestroy:t.type.prototype.ngOnDestroy||null}}function Tr(t){return t[La]||null}function ri(t){return t[Su]||null}function ds(t){return t[Ga]||null}function ct(t,n){const e=t[pl]||null;if(!e&&!0===n)throw new Error(`Type ${Yi(t)} does not have '\u0275mod' property.`);return e}function _t(t){const n={};return{type:t.type,providersResolver:null,factory:null,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:n,inputTransforms:null,inputConfig:t.inputs||mi,exportAs:t.exportAs||null,standalone:!0===t.standalone,signals:!0===t.signals,selectors:t.selectors||yi,viewQuery:t.viewQuery||null,features:t.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:yu(t.inputs,n),outputs:yu(t.outputs)}}function Nt(t){t.features?.forEach(n=>n(t))}function Kt(t,n){if(!t)return null;const e=n?ds:jl;return()=>("function"==typeof t?t():t).map(r=>e(r)).filter(ja)}const Te=0,xe=1,Pe=2,fn=3,f=4,E=5,D=6,j=7,mt=8,Ft=9,ce=10,ye=11,Ve=12,sn=13,wn=14,Pn=15,Nr=16,yo=17,qi=18,ro=19,Ho=20,ea=21,da=22,cr=23,su=24,Rr=25,qs=1,Ns=2,ws=7,na=9,l=11;function m(t){return Array.isArray(t)&&"object"==typeof t[qs]}function _(t){return Array.isArray(t)&&!0===t[qs]}function C(t){return 0!=(4&t.flags)}function F(t){return t.componentOffset>-1}function rt(t){return 1==(1&t.flags)}function Dt(t){return!!t.template}function qt(t){return 0!=(512&t[Pe])}function oh(t,n){return t.hasOwnProperty(Jo)?t[Jo]:null}let $a=null,sf=!1;function gl(t){const n=$a;return $a=t,n}const ay={version:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{}};function af(t){if(!gd(t)||t.dirty){if(!t.producerMustRecompute(t)&&!hy(t))return void(t.dirty=!1);t.producerRecomputeValue(t),t.dirty=!1}}function cy(t){t.dirty=!0,function ly(t){if(void 0===t.liveConsumerNode)return;const n=sf;sf=!0;try{for(const e of t.liveConsumerNode)e.dirty||cy(e)}finally{sf=n}}(t),t.consumerMarkedDirty?.(t)}function jp(t){return t&&(t.nextProducerIndex=0),gl(t)}function Kp(t,n){if(gl(n),t&&void 0!==t.producerNode&&void 0!==t.producerIndexOfThis&&void 0!==t.producerLastReadVersion){if(gd(t))for(let e=t.nextProducerIndex;e<t.producerNode.length;e++)uf(t.producerNode[e],t.producerIndexOfThis[e]);for(;t.producerNode.length>t.nextProducerIndex;)t.producerNode.pop(),t.producerLastReadVersion.pop(),t.producerIndexOfThis.pop()}}function hy(t){Ah(t);for(let n=0;n<t.producerNode.length;n++){const e=t.producerNode[n],r=t.producerLastReadVersion[n];if(r!==e.version||(af(e),r!==e.version))return!0}return!1}function dy(t){if(Ah(t),gd(t))for(let n=0;n<t.producerNode.length;n++)uf(t.producerNode[n],t.producerIndexOfThis[n]);t.producerNode.length=t.producerLastReadVersion.length=t.producerIndexOfThis.length=0,t.liveConsumerNode&&(t.liveConsumerNode.length=t.liveConsumerIndexOfThis.length=0)}function uf(t,n){if(function py(t){t.liveConsumerNode??=[],t.liveConsumerIndexOfThis??=[]}(t),Ah(t),1===t.liveConsumerNode.length)for(let r=0;r<t.producerNode.length;r++)uf(t.producerNode[r],t.producerIndexOfThis[r]);const e=t.liveConsumerNode.length-1;if(t.liveConsumerNode[n]=t.liveConsumerNode[e],t.liveConsumerIndexOfThis[n]=t.liveConsumerIndexOfThis[e],t.liveConsumerNode.length--,t.liveConsumerIndexOfThis.length--,n<t.liveConsumerNode.length){const r=t.liveConsumerIndexOfThis[n],i=t.liveConsumerNode[n];Ah(i),i.producerIndexOfThis[r]=n}}function gd(t){return t.consumerIsAlwaysLive||(t?.liveConsumerNode?.length??0)>0}function Ah(t){t.producerNode??=[],t.producerIndexOfThis??=[],t.producerLastReadVersion??=[]}let Xl=null;const vy=()=>{},O1=(()=>({...ay,consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!1,consumerMarkedDirty:t=>{t.schedule(t.ref)},hasRun:!1,cleanupFn:vy}))();class R1{constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function yl(){return _y}function _y(t){return t.type.prototype.ngOnChanges&&(t.setInput=k1),L1}function L1(){const t=Ey(this),n=t?.current;if(n){const e=t.previous;if(e===mi)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function k1(t,n,e,r){const i=this.declaredInputs[e],s=Ey(t)||function F1(t,n){return t[xy]=n}(t,{previous:mi,current:null}),o=s.current||(s.current={}),a=s.previous,u=a[i];o[i]=new R1(u&&u.currentValue,n,a===mi),t[r]=n}yl.ngInherit=!0;const xy="__ngSimpleChanges__";function Ey(t){return t[xy]||null}const Zl=function(t,n,e){};function vo(t){for(;Array.isArray(t);)t=t[Te];return t}function lf(t,n){return vo(n[t])}function Fu(t,n){return vo(n[t.index])}function wy(t,n){return t.data[n]}function tl(t,n){const e=n[t];return m(e)?e:e[Te]}function Lc(t,n){return null==n?null:t[n]}function Ht(t){t[yo]=0}function Vt(t){1024&t[Pe]||(t[Pe]|=1024,Ut(t,1))}function $t(t){1024&t[Pe]&&(t[Pe]&=-1025,Ut(t,-1))}function Ut(t,n){let e=t[fn];if(null===e)return;e[E]+=n;let r=e;for(e=e[fn];null!==e&&(1===n&&1===r[E]||-1===n&&0===r[E]);)e[E]+=n,r=e,e=e[fn]}const Qt={lFrame:RS(null),bindingsEnabled:!0,skipHydrationRootTNode:null};function nr(){return Qt.bindingsEnabled}function Qe(){return Qt.lFrame.lView}function Lr(){return Qt.lFrame.tView}function bi(){let t=Mo();for(;null!==t&&64===t.type;)t=t.parent;return t}function Mo(){return Qt.lFrame.currentTNode}function ps(t,n){const e=Qt.lFrame;e.currentTNode=t,e.isParent=n}function Po(){return Qt.lFrame.isParent}function Tl(){return Qt.lFrame.bindingIndex++}function pV(t,n){const e=Qt.lFrame;e.bindingIndex=e.bindingRootIndex=t,W1(n)}function W1(t){Qt.lFrame.currentDirectiveIndex=t}function MS(){return Qt.lFrame.currentQueryIndex}function H1(t){Qt.lFrame.currentQueryIndex=t}function gV(t){const n=t[xe];return 2===n.type?n.declTNode:1===n.type?t[D]:null}function PS(t,n,e){if(e&xr.SkipSelf){let i=n,s=t;for(;!(i=i.parent,null!==i||e&xr.Host||(i=gV(s),null===i||(s=s[wn],10&i.type))););if(null===i)return!1;n=i,t=s}const r=Qt.lFrame=OS();return r.currentTNode=n,r.lView=t,!0}function j1(t){const n=OS(),e=t[xe];Qt.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function OS(){const t=Qt.lFrame,n=null===t?null:t.child;return null===n?RS(t):n}function RS(t){const n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=n),n}function LS(){const t=Qt.lFrame;return Qt.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const kS=LS;function K1(){const t=LS();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function nl(){return Qt.lFrame.selectedIndex}function yd(t){Qt.lFrame.selectedIndex=t}let $S=!0;function Iy(){return $S}function Ph(t){$S=t}function Sy(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){const s=t.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:u,ngAfterViewChecked:c,ngOnDestroy:d}=s;o&&(t.contentHooks??=[]).push(-e,o),a&&((t.contentHooks??=[]).push(e,a),(t.contentCheckHooks??=[]).push(e,a)),u&&(t.viewHooks??=[]).push(-e,u),c&&((t.viewHooks??=[]).push(e,c),(t.viewCheckHooks??=[]).push(e,c)),null!=d&&(t.destroyHooks??=[]).push(e,d)}}function Dy(t,n,e){BS(t,n,3,e)}function Ty(t,n,e,r){(3&t[Pe])===e&&BS(t,n,e,r)}function X1(t,n){let e=t[Pe];(3&e)===n&&(e&=8191,e+=1,t[Pe]=e)}function BS(t,n,e,r){const s=r??-1,o=n.length-1;let a=0;for(let u=void 0!==r?65535&t[yo]:0;u<o;u++)if("number"==typeof n[u+1]){if(a=n[u],null!=r&&a>=r)break}else n[u]<0&&(t[yo]+=65536),(a<s||-1==s)&&(wV(t,e,n,u),t[yo]=(4294901760&t[yo])+u+2),u++}function zS(t,n){Zl(4,t,n);const e=gl(null);try{n.call(t)}finally{gl(e),Zl(5,t,n)}}function wV(t,n,e,r){const i=e[r]<0,s=e[r+1],a=t[i?-e[r]:e[r]];i?t[Pe]>>13<t[yo]>>16&&(3&t[Pe])===n&&(t[Pe]+=8192,zS(a,s)):zS(a,s)}const cf=-1;class qp{constructor(n,e,r){this.factory=n,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function Y1(t){return t!==cf}function Jp(t){return 32767&t}function tm(t,n){let e=function TV(t){return t>>16}(t),r=n;for(;e>0;)r=r[wn],e--;return r}let Q1=!0;function Ny(t){const n=Q1;return Q1=t,n}const VS=255,US=5;let NV=0;const kc={};function Ay(t,n){const e=WS(t,n);if(-1!==e)return e;const r=n[xe];r.firstCreatePass&&(t.injectorIndex=n.length,q1(r.data,t),q1(n,null),q1(r.blueprint,null));const i=My(t,n),s=t.injectorIndex;if(Y1(i)){const o=Jp(i),a=tm(i,n),u=a[xe].data;for(let c=0;c<8;c++)n[s+c]=a[o+c]|u[o+c]}return n[s+8]=i,s}function q1(t,n){t.push(0,0,0,0,0,0,0,0,n)}function WS(t,n){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===n[t.injectorIndex+8]?-1:t.injectorIndex}function My(t,n){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let e=0,r=null,i=n;for(;null!==i;){if(r=YS(i),null===r)return cf;if(e++,i=i[wn],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return cf}function J1(t,n,e){!function AV(t,n,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(Uo)&&(r=e[Uo]),null==r&&(r=e[Uo]=NV++);const i=r&VS;n.data[t+(i>>US)]|=1<<i}(t,n,e)}function GS(t,n,e){if(e&xr.Optional||void 0!==t)return t;Wr()}function HS(t,n,e,r){if(e&xr.Optional&&void 0===r&&(r=null),!(e&(xr.Self|xr.Host))){const i=t[Ft],s=vs(void 0);try{return i?i.get(n,r,e&xr.Optional):Lu(n,r,e&xr.Optional)}finally{vs(s)}}return GS(r,0,e)}function jS(t,n,e,r=xr.Default,i){if(null!==t){if(2048&n[Pe]&&!(r&xr.Self)){const o=function kV(t,n,e,r,i){let s=t,o=n;for(;null!==s&&null!==o&&2048&o[Pe]&&!(512&o[Pe]);){const a=KS(s,o,e,r|xr.Self,kc);if(a!==kc)return a;let u=s.parent;if(!u){const c=o[Ho];if(c){const d=c.get(e,kc,r);if(d!==kc)return d}u=YS(o),o=o[wn]}s=u}return i}(t,n,e,r,kc);if(o!==kc)return o}const s=KS(t,n,e,r,kc);if(s!==kc)return s}return HS(n,e,r,i)}function KS(t,n,e,r,i){const s=function OV(t){if("string"==typeof t)return t.charCodeAt(0)||0;const n=t.hasOwnProperty(Uo)?t[Uo]:void 0;return"number"==typeof n?n>=0?n&VS:LV:n}(e);if("function"==typeof s){if(!PS(n,t,r))return r&xr.Host?GS(i,0,r):HS(n,e,r,i);try{let o;if(o=s(r),null!=o||r&xr.Optional)return o;Wr()}finally{kS()}}else if("number"==typeof s){let o=null,a=WS(t,n),u=cf,c=r&xr.Host?n[Pn][D]:null;for((-1===a||r&xr.SkipSelf)&&(u=-1===a?My(t,n):n[a+8],u!==cf&&ZS(r,!1)?(o=n[xe],a=Jp(u),n=tm(u,n)):a=-1);-1!==a;){const d=n[xe];if(XS(s,a,d.data)){const p=PV(a,n,e,o,r,c);if(p!==kc)return p}u=n[a+8],u!==cf&&ZS(r,n[xe].data[a+8]===c)&&XS(s,a,n)?(o=d,a=Jp(u),n=tm(u,n)):a=-1}}return i}function PV(t,n,e,r,i,s){const o=n[xe],a=o.data[t+8],d=Py(a,o,e,null==r?F(a)&&Q1:r!=o&&0!=(3&a.type),i&xr.Host&&s===a);return null!==d?vd(n,o,d,a):kc}function Py(t,n,e,r,i){const s=t.providerIndexes,o=n.data,a=1048575&s,u=t.directiveStart,d=s>>20,v=i?a+d:t.directiveEnd;for(let x=r?a:a+d;x<v;x++){const b=o[x];if(x<u&&e===b||x>=u&&b.type===e)return x}if(i){const x=o[u];if(x&&Dt(x)&&x.type===e)return u}return null}function vd(t,n,e,r){let i=t[e];const s=n.data;if(function IV(t){return t instanceof qp}(i)){const o=i;o.resolving&&function Kn(t,n){const e=n?`. Dependency path: ${n.join(" > ")} > ${t}`:"";throw new We(-200,`Circular dependency in DI detected for ${t}${e}`)}(function ai(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():mr(t)}(s[e]));const a=Ny(o.canSeeViewProviders);o.resolving=!0;const c=o.injectImpl?vs(o.injectImpl):null;PS(t,r,xr.Default);try{i=t[e]=o.factory(void 0,s,t,r),n.firstCreatePass&&e>=r.directiveStart&&function bV(t,n,e){const{ngOnChanges:r,ngOnInit:i,ngDoCheck:s}=n.type.prototype;if(r){const o=_y(n);(e.preOrderHooks??=[]).push(t,o),(e.preOrderCheckHooks??=[]).push(t,o)}i&&(e.preOrderHooks??=[]).push(0-t,i),s&&((e.preOrderHooks??=[]).push(t,s),(e.preOrderCheckHooks??=[]).push(t,s))}(e,s[e],n)}finally{null!==c&&vs(c),Ny(a),o.resolving=!1,kS()}}return i}function XS(t,n,e){return!!(e[n+(t>>US)]&1<<t)}function ZS(t,n){return!(t&xr.Self||t&xr.Host&&n)}class rl{constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return jS(this._tNode,this._lView,n,ua(r),e)}}function LV(){return new rl(bi(),Qe())}function Au(t){return $s(()=>{const n=t.prototype.constructor,e=n[Jo]||tx(n),r=Object.prototype;let i=Object.getPrototypeOf(t.prototype).constructor;for(;i&&i!==r;){const s=i[Jo]||tx(i);if(s&&s!==e)return s;i=Object.getPrototypeOf(i)}return s=>new s})}function tx(t){return Ss(t)?()=>{const n=tx(Fn(t));return n&&n()}:oh(t)}function YS(t){const n=t[xe],e=n.type;return 2===e?n.declTNode:1===e?t[D]:null}const df="__parameters__";function pf(t,n,e){return $s(()=>{const r=function ex(t){return function(...e){if(t){const r=t(...e);for(const i in r)this[i]=r[i]}}}(n);function i(...s){if(this instanceof i)return r.apply(this,s),this;const o=new i(...s);return a.annotation=o,a;function a(u,c,d){const p=u.hasOwnProperty(df)?u[df]:Object.defineProperty(u,df,{value:[]})[df];for(;p.length<=d;)p.push(null);return(p[d]=p[d]||[]).push(o),u}}return e&&(i.prototype=Object.create(e.prototype)),i.prototype.ngMetadataName=t,i.annotationCls=i,i})}function gf(t,n){t.forEach(e=>Array.isArray(e)?gf(e,n):n(e))}function qS(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function Ry(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}function Nl(t,n,e){let r=yf(t,n);return r>=0?t[1|r]=e:(r=~r,function WV(t,n,e,r){let i=t.length;if(i==n)t.push(e,r);else if(1===i)t.push(r,t[0]),t[0]=e;else{for(i--,t.push(t[i-1],t[i]);i>n;)t[i]=t[i-2],i--;t[n]=e,t[n+1]=r}}(t,r,n,e)),r}function nx(t,n){const e=yf(t,n);if(e>=0)return t[1|e]}function yf(t,n){return function JS(t,n,e){let r=0,i=t.length>>e;for(;i!==r;){const s=r+(i-r>>1),o=t[s<<e];if(n===o)return s<<e;o>n?i=s:r=s+1}return~(i<<e)}(t,n,1)}const ky=ls(pf("Optional"),8),Fy=ls(pf("SkipSelf"),4);function Uy(t){return 128==(128&t.flags)}var Oh=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}(Oh||{});const ax=new Map;let fU=0;const lx="__ngContext__";function Bu(t,n){m(n)?(t[lx]=n[ro],function mU(t){ax.set(t[ro],t)}(n)):t[lx]=n}let cx;function hx(t,n){return cx(t,n)}function om(t){const n=t[fn];return _(n)?n[fn]:n}function _D(t){return ED(t[Ve])}function xD(t){return ED(t[f])}function ED(t){for(;null!==t&&!_(t);)t=t[f];return t}function xf(t,n,e,r,i){if(null!=r){let s,o=!1;_(r)?s=r:m(r)&&(o=!0,r=r[Te]);const a=vo(r);0===t&&null!==e?null==i?ID(n,e,a):_d(n,e,a,i||null,!0):1===t&&null!==e?_d(n,e,a,i||null,!0):2===t?function Zy(t,n,e){const r=Ky(t,n);r&&function RU(t,n,e,r){t.removeChild(n,e,r)}(t,r,n,e)}(n,a,o):3===t&&n.destroyNode(a),null!=s&&function FU(t,n,e,r,i){const s=e[ws];s!==vo(e)&&xf(n,t,r,s,i);for(let a=l;a<e.length;a++){const u=e[a];um(u[xe],u,t,n,r,s)}}(n,t,s,e,i)}}function Hy(t,n,e){return t.createElement(n,e)}function bD(t,n){const e=t[na],r=e.indexOf(n);$t(n),e.splice(r,1)}function jy(t,n){if(t.length<=l)return;const e=l+n,r=t[e];if(r){const i=r[Nr];null!==i&&i!==t&&bD(i,r),n>0&&(t[e-1][f]=r[f]);const s=Ry(t,l+n);!function SU(t,n){um(t,n,n[ye],2,null,null),n[Te]=null,n[D]=null}(r[xe],r);const o=s[qi];null!==o&&o.detachView(s[xe]),r[fn]=null,r[f]=null,r[Pe]&=-129}return r}function fx(t,n){if(!(256&n[Pe])){const e=n[ye];n[cr]&&dy(n[cr]),n[su]&&dy(n[su]),e.destroyNode&&um(t,n,e,3,null,null),function NU(t){let n=t[Ve];if(!n)return px(t[xe],t);for(;n;){let e=null;if(m(n))e=n[Ve];else{const r=n[l];r&&(e=r)}if(!e){for(;n&&!n[f]&&n!==t;)m(n)&&px(n[xe],n),n=n[fn];null===n&&(n=t),m(n)&&px(n[xe],n),e=n&&n[f]}n=e}}(n)}}function px(t,n){if(!(256&n[Pe])){n[Pe]&=-129,n[Pe]|=256,function OU(t,n){let e;if(null!=t&&null!=(e=t.destroyHooks))for(let r=0;r<e.length;r+=2){const i=n[e[r]];if(!(i instanceof qp)){const s=e[r+1];if(Array.isArray(s))for(let o=0;o<s.length;o+=2){const a=i[s[o]],u=s[o+1];Zl(4,a,u);try{u.call(a)}finally{Zl(5,a,u)}}else{Zl(4,i,s);try{s.call(i)}finally{Zl(5,i,s)}}}}}(t,n),function PU(t,n){const e=t.cleanup,r=n[j];if(null!==e)for(let s=0;s<e.length-1;s+=2)if("string"==typeof e[s]){const o=e[s+3];o>=0?r[o]():r[-o].unsubscribe(),s+=2}else e[s].call(r[e[s+1]]);null!==r&&(n[j]=null);const i=n[ea];if(null!==i){n[ea]=null;for(let s=0;s<i.length;s++)(0,i[s])()}}(t,n),1===n[xe].type&&n[ye].destroy();const e=n[Nr];if(null!==e&&_(n[fn])){e!==n[fn]&&bD(e,n);const r=n[qi];null!==r&&r.detachView(t)}!function gU(t){ax.delete(t[ro])}(n)}}function mx(t,n,e){return function wD(t,n,e){let r=n;for(;null!==r&&40&r.type;)r=(n=r).parent;if(null===r)return e[Te];{const{componentOffset:i}=r;if(i>-1){const{encapsulation:s}=t.data[r.directiveStart+i];if(s===xa.None||s===xa.Emulated)return null}return Fu(r,e)}}(t,n.parent,e)}function _d(t,n,e,r,i){t.insertBefore(n,e,r,i)}function ID(t,n,e){t.appendChild(n,e)}function SD(t,n,e,r,i){null!==r?_d(t,n,e,r,i):ID(t,n,e)}function Ky(t,n){return t.parentNode(n)}let gx,xx,ND=function TD(t,n,e){return 40&t.type?Fu(t,e):null};function Xy(t,n,e,r){const i=mx(t,r,n),s=n[ye],a=function DD(t,n,e){return ND(t,n,e)}(r.parent||n[D],r,n);if(null!=i)if(Array.isArray(e))for(let u=0;u<e.length;u++)SD(s,i,e[u],a,!1);else SD(s,i,e,a,!1);void 0!==gx&&gx(s,r,n,e,i)}function am(t,n){if(null!==n){const e=n.type;if(3&e)return Fu(n,t);if(4&e)return yx(-1,t[n.index]);if(8&e){const r=n.child;if(null!==r)return am(t,r);{const i=t[n.index];return _(i)?yx(-1,i):vo(i)}}if(32&e)return hx(n,t)()||vo(t[n.index]);{const r=MD(t,n);return null!==r?Array.isArray(r)?r[0]:am(om(t[Pn]),r):am(t,n.next)}}return null}function MD(t,n){return null!==n?t[Pn][D].projection[n.projection]:null}function yx(t,n){const e=l+t+1;if(e<n.length){const r=n[e],i=r[xe].firstChild;if(null!==i)return am(r,i)}return n[ws]}function vx(t,n,e,r,i,s,o){for(;null!=e;){const a=r[e.index],u=e.type;if(o&&0===n&&(a&&Bu(vo(a),r),e.flags|=2),32!=(32&e.flags))if(8&u)vx(t,n,e.child,r,i,s,!1),xf(n,t,i,a,s);else if(32&u){const c=hx(e,r);let d;for(;d=c();)xf(n,t,i,d,s);xf(n,t,i,a,s)}else 16&u?OD(t,n,r,e,i,s):xf(n,t,i,a,s);e=o?e.projectionNext:e.next}}function um(t,n,e,r,i,s){vx(e,r,t.firstChild,n,i,s,!1)}function OD(t,n,e,r,i,s){const o=e[Pn],u=o[D].projection[r.projection];if(Array.isArray(u))for(let c=0;c<u.length;c++)xf(n,t,i,u[c],s);else{let c=u;const d=o[fn];Uy(r)&&(c.flags|=128),vx(t,n,c,d,i,s,!0)}}function RD(t,n,e){""===e?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function LD(t,n,e){const{mergedAttrs:r,classes:i,styles:s}=e;null!==r&&Bs(t,n,r),null!==i&&RD(t,n,i),null!==s&&function BU(t,n,e){t.setAttribute(n,"style",e)}(t,n,s)}class BD{constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}const dm=new In("ENVIRONMENT_INITIALIZER"),ZD=new In("INJECTOR",-1),YD=new In("INJECTOR_DEF_TYPES");class Sx{get(n,e=Br){if(e===Br){const r=new Error(`NullInjectorError: No provider for ${Yi(n)}!`);throw r.name="NullInjectorError",r}return e}}function d4(...t){return{\u0275providers:qD(0,t),\u0275fromNgModule:!0}}function qD(t,...n){const e=[],r=new Set;let i;const s=o=>{e.push(o)};return gf(n,o=>{const a=o;Jy(a,s,[],r)&&(i||=[],i.push(a))}),void 0!==i&&JD(i,s),e}function JD(t,n){for(let e=0;e<t.length;e++){const{ngModule:r,providers:i}=t[e];Dx(i,s=>{n(s,r)})}}function Jy(t,n,e,r){if(!(t=Fn(t)))return!1;let i=null,s=ni(t);const o=!s&&Tr(t);if(s||o){if(o&&!o.standalone)return!1;i=t}else{const u=t.ngModule;if(s=ni(u),!s)return!1;i=u}const a=r.has(i);if(o){if(a)return!1;if(r.add(i),o.dependencies){const u="function"==typeof o.dependencies?o.dependencies():o.dependencies;for(const c of u)Jy(c,n,e,r)}}else{if(!s)return!1;{if(null!=s.imports&&!a){let c;r.add(i);try{gf(s.imports,d=>{Jy(d,n,e,r)&&(c||=[],c.push(d))})}finally{}void 0!==c&&JD(c,n)}if(!a){const c=oh(i)||(()=>new i);n({provide:i,useFactory:c,deps:yi},i),n({provide:YD,useValue:i,multi:!0},i),n({provide:dm,useValue:()=>Hn(i),multi:!0},i)}const u=s.providers;if(null!=u&&!a){const c=t;Dx(u,d=>{n(d,c)})}}}return i!==t&&void 0!==t.providers}function Dx(t,n){for(let e of t)wo(e)&&(e=e.\u0275providers),Array.isArray(e)?Dx(e,n):n(e)}const f4=Xn({provide:String,useValue:Xn});function Tx(t){return null!==t&&"object"==typeof t&&f4 in t}function xd(t){return"function"==typeof t}const Nx=new In("Set Injector scope."),t0={},m4={};let Ax;function e0(){return void 0===Ax&&(Ax=new Sx),Ax}class Ql{}class wf extends Ql{get destroyed(){return this._destroyed}constructor(n,e,r,i){super(),this.parent=e,this.source=r,this.scopes=i,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,Px(n,o=>this.processProvider(o)),this.records.set(ZD,If(void 0,this)),i.has("environment")&&this.records.set(Ql,If(void 0,this));const s=this.records.get(Nx);null!=s&&"string"==typeof s.value&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(YD.multi,yi,xr.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const e of this._ngOnDestroyHooks)e.ngOnDestroy();const n=this._onDestroyHooks;this._onDestroyHooks=[];for(const e of n)e()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear()}}onDestroy(n){return this.assertNotDestroyed(),this._onDestroyHooks.push(n),()=>this.removeOnDestroy(n)}runInContext(n){this.assertNotDestroyed();const e=po(this),r=vs(void 0);try{return n()}finally{po(e),vs(r)}}get(n,e=Br,r=xr.Default){if(this.assertNotDestroyed(),n.hasOwnProperty(Ts))return n[Ts](this);r=ua(r);const s=po(this),o=vs(void 0);try{if(!(r&xr.SkipSelf)){let u=this.records.get(n);if(void 0===u){const c=function x4(t){return"function"==typeof t||"object"==typeof t&&t instanceof In}(n)&&Vn(n);u=c&&this.injectableDefInScope(c)?If(Mx(n),t0):null,this.records.set(n,u)}if(null!=u)return this.hydrate(n,u)}return(r&xr.Self?e0():this.parent).get(n,e=r&xr.Optional&&e===Br?null:e)}catch(a){if("NullInjectorError"===a.name){if((a[nu]=a[nu]||[]).unshift(Yi(n)),s)throw a;return function iu(t,n,e,r){const i=t[nu];throw n[ya]&&i.unshift(n[ya]),t.message=function Ys(t,n,e,r=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.slice(2):t;let i=Yi(n);if(Array.isArray(n))i=n.map(Yi).join(" -> ");else if("object"==typeof n){let s=[];for(let o in n)if(n.hasOwnProperty(o)){let a=n[o];s.push(o+":"+("string"==typeof a?JSON.stringify(a):Yi(a)))}i=`{${s.join(", ")}}`}return`${e}${r?"("+r+")":""}[${i}]: ${t.replace(us,"\n  ")}`}("\n"+t.message,i,e,r),t.ngTokenPath=i,t[nu]=null,t}(a,n,"R3InjectorError",this.source)}throw a}finally{vs(o),po(s)}}resolveInjectorInitializers(){const n=po(this),e=vs(void 0);try{const i=this.get(dm.multi,yi,xr.Self);for(const s of i)s()}finally{po(n),vs(e)}}toString(){const n=[],e=this.records;for(const r of e.keys())n.push(Yi(r));return`R3Injector[${n.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new We(205,!1)}processProvider(n){let e=xd(n=Fn(n))?n:Fn(n&&n.provide);const r=function y4(t){return Tx(t)?If(void 0,t.useValue):If(nT(t),t0)}(n);if(xd(n)||!0!==n.multi)this.records.get(e);else{let i=this.records.get(e);i||(i=If(void 0,t0,!0),i.factory=()=>_a(i.multi),this.records.set(e,i)),e=n,i.multi.push(n)}this.records.set(e,r)}hydrate(n,e){return e.value===t0&&(e.value=m4,e.value=e.factory()),"object"==typeof e.value&&e.value&&function _4(t){return null!==t&&"object"==typeof t&&"function"==typeof t.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(n){if(!n.providedIn)return!1;const e=Fn(n.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(n){const e=this._onDestroyHooks.indexOf(n);-1!==e&&this._onDestroyHooks.splice(e,1)}}function Mx(t){const n=Vn(t),e=null!==n?n.factory:oh(t);if(null!==e)return e;if(t instanceof In)throw new We(204,!1);if(t instanceof Function)return function g4(t){const n=t.length;if(n>0)throw function rm(t,n){const e=[];for(let r=0;r<t;r++)e.push(n);return e}(n,"?"),new We(204,!1);const e=function _r(t){return t&&(t[Zs]||t[tn])||null}(t);return null!==e?()=>e.factory(t):()=>new t}(t);throw new We(204,!1)}function nT(t,n,e){let r;if(xd(t)){const i=Fn(t);return oh(i)||Mx(i)}if(Tx(t))r=()=>Fn(t.useValue);else if(function eT(t){return!(!t||!t.useFactory)}(t))r=()=>t.useFactory(..._a(t.deps||[]));else if(function tT(t){return!(!t||!t.useExisting)}(t))r=()=>Hn(Fn(t.useExisting));else{const i=Fn(t&&(t.useClass||t.provide));if(!function v4(t){return!!t.deps}(t))return oh(i)||Mx(i);r=()=>new i(..._a(t.deps))}return r}function If(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function Px(t,n){for(const e of t)Array.isArray(e)?Px(e,n):e&&wo(e)?Px(e.\u0275providers,n):n(e)}const n0=new In("AppId",{providedIn:"root",factory:()=>E4}),E4="ng",rT=new In("Platform Initializer"),Sf=new In("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),iT=new In("CSP nonce",{providedIn:"root",factory:()=>function Cf(){if(void 0!==xx)return xx;if(typeof document<"u")return document;throw new We(210,!1)}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});let sT=(t,n,e)=>null;function zx(t,n,e=!1){return sT(t,n,e)}class M4{}class uT{}class O4{resolveComponentFactory(n){throw function P4(t){const n=Error(`No component factory found for ${Yi(t)}.`);return n.ngComponent=t,n}(n)}}let l0=(()=>{class t{static#t=this.NULL=new O4}return t})();function R4(){return Nf(bi(),Qe())}function Nf(t,n){return new Al(Fu(t,n))}let Al=(()=>{class t{constructor(e){this.nativeElement=e}static#t=this.__NG_ELEMENT_ID__=R4}return t})();function L4(t){return t instanceof Al?t.nativeElement:t}class cT{}let lh=(()=>{class t{constructor(){this.destroyNode=null}static#t=this.__NG_ELEMENT_ID__=()=>function k4(){const t=Qe(),e=tl(bi().index,t);return(m(e)?e:t)[ye]}()}return t})(),F4=(()=>{class t{static#t=this.\u0275prov=$e({token:t,providedIn:"root",factory:()=>null})}return t})();class mm{constructor(n){this.full=n,this.major=n.split(".")[0],this.minor=n.split(".")[1],this.patch=n.split(".").slice(2).join(".")}}const $4=new mm("16.2.12"),Wx={};function pT(t,n=null,e=null,r){const i=mT(t,n,e,r);return i.resolveInjectorInitializers(),i}function mT(t,n=null,e=null,r,i=new Set){const s=[e||yi,d4(t)];return r=r||("object"==typeof t?void 0:Yi(t)),new wf(s,n||e0(),r||null,i)}let Ml=(()=>{class t{static#t=this.THROW_IF_NOT_FOUND=Br;static#e=this.NULL=new Sx;static create(e,r){if(Array.isArray(e))return pT({name:""},r,e,"");{const i=e.name??"";return pT({name:i},e.parent,e.providers,i)}}static#n=this.\u0275prov=$e({token:t,providedIn:"any",factory:()=>Hn(ZD)});static#r=this.__NG_ELEMENT_ID__=-1}return t})();function Hx(t){return t.ngOriginalError}class ch{constructor(){this._console=console}handleError(n){const e=this._findOriginalError(n);this._console.error("ERROR",n),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(n){let e=n&&Hx(n);for(;e&&Hx(e);)e=Hx(e);return e||null}}function Kx(t){return n=>{setTimeout(t,void 0,n)}}const Ia=class H4 extends ee{constructor(n=!1){super(),this.__isAsync=n}emit(n){super.next(n)}subscribe(n,e,r){let i=n,s=e||(()=>null),o=r;if(n&&"object"==typeof n){const u=n;i=u.next?.bind(u),s=u.error?.bind(u),o=u.complete?.bind(u)}this.__isAsync&&(s=Kx(s),i&&(i=Kx(i)),o&&(o=Kx(o)));const a=super.subscribe({next:i,error:s,complete:o});return n instanceof R&&n.add(a),a}};function yT(...t){}class Oo{constructor({enableLongStackTrace:n=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Ia(!1),this.onMicrotaskEmpty=new Ia(!1),this.onStable=new Ia(!1),this.onError=new Ia(!1),typeof Zone>"u")throw new We(908,!1);Zone.assertZonePatched();const i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),n&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!r&&e,i.shouldCoalesceRunChangeDetection=r,i.lastRequestAnimationFrameId=-1,i.nativeRequestAnimationFrame=function j4(){const t="function"==typeof as.requestAnimationFrame;let n=as[t?"requestAnimationFrame":"setTimeout"],e=as[t?"cancelAnimationFrame":"clearTimeout"];if(typeof Zone<"u"&&n&&e){const r=n[Zone.__symbol__("OriginalDelegate")];r&&(n=r);const i=e[Zone.__symbol__("OriginalDelegate")];i&&(e=i)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function Z4(t){const n=()=>{!function X4(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(as,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,Zx(t),t.isCheckStableRunning=!0,Xx(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),Zx(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,i,s,o,a)=>{if(function Q4(t){return!(!Array.isArray(t)||1!==t.length)&&!0===t[0].data?.__ignore_ng_zone__}(a))return e.invokeTask(i,s,o,a);try{return vT(t),e.invokeTask(i,s,o,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===s.type||t.shouldCoalesceRunChangeDetection)&&n(),_T(t)}},onInvoke:(e,r,i,s,o,a,u)=>{try{return vT(t),e.invoke(i,s,o,a,u)}finally{t.shouldCoalesceRunChangeDetection&&n(),_T(t)}},onHasTask:(e,r,i,s)=>{e.hasTask(i,s),r===i&&("microTask"==s.change?(t._hasPendingMicrotasks=s.microTask,Zx(t),Xx(t)):"macroTask"==s.change&&(t.hasPendingMacrotasks=s.macroTask))},onHandleError:(e,r,i,s)=>(e.handleError(i,s),t.runOutsideAngular(()=>t.onError.emit(s)),!1)})}(i)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Oo.isInAngularZone())throw new We(909,!1)}static assertNotInAngularZone(){if(Oo.isInAngularZone())throw new We(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,i){const s=this._inner,o=s.scheduleEventTask("NgZoneEvent: "+i,n,K4,yT,yT);try{return s.runTask(o,e,r)}finally{s.cancelTask(o)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}}const K4={};function Xx(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function Zx(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function vT(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function _T(t){t._nesting--,Xx(t)}class Y4{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Ia,this.onMicrotaskEmpty=new Ia,this.onStable=new Ia,this.onError=new Ia}run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,i){return n.apply(e,r)}}const xT=new In("",{providedIn:"root",factory:ET});function ET(){const t=Mn(Oo);let n=!0;return function An(...t){const n=eo(t),e=function Co(t,n){return"number"==typeof rs(t)?t.pop():n}(t,1/0),r=t;return r.length?1===r.length?kr(r[0]):ti(e)(ys(r,n)):Vr}(new xt(i=>{n=t.isStable&&!t.hasPendingMacrotasks&&!t.hasPendingMicrotasks,t.runOutsideAngular(()=>{i.next(n),i.complete()})}),new xt(i=>{let s;t.runOutsideAngular(()=>{s=t.onStable.subscribe(()=>{Oo.assertNotInAngularZone(),queueMicrotask(()=>{!n&&!t.hasPendingMacrotasks&&!t.hasPendingMicrotasks&&(n=!0,i.next(!0))})})});const o=t.onUnstable.subscribe(()=>{Oo.assertInAngularZone(),n&&(n=!1,t.runOutsideAngular(()=>{i.next(!1)}))});return()=>{s.unsubscribe(),o.unsubscribe()}}).pipe(ma()))}function hh(t){return t instanceof Function?t():t}let Yx=(()=>{class t{constructor(){this.renderDepth=0,this.handler=null}begin(){this.handler?.validateBegin(),this.renderDepth++}end(){this.renderDepth--,0===this.renderDepth&&this.handler?.execute()}ngOnDestroy(){this.handler?.destroy(),this.handler=null}static#t=this.\u0275prov=$e({token:t,providedIn:"root",factory:()=>new t})}return t})();function gm(t){for(;t;){t[Pe]|=64;const n=om(t);if(qt(t)&&!n)return t;t=n}return null}const ST=new In("",{providedIn:"root",factory:()=>!1});let h0=null;function AT(t,n){return t[n]??OT()}function MT(t,n){const e=OT();e.producerNode?.length&&(t[n]=h0,e.lView=t,h0=PT())}const aW={...ay,consumerIsAlwaysLive:!0,consumerMarkedDirty:t=>{gm(t.lView)},lView:null};function PT(){return Object.create(aW)}function OT(){return h0??=PT(),h0}const ui={};function Lh(t){RT(Lr(),Qe(),nl()+t,!1)}function RT(t,n,e,r){if(!r)if(3==(3&n[Pe])){const s=t.preOrderCheckHooks;null!==s&&Dy(n,s,e)}else{const s=t.preOrderHooks;null!==s&&Ty(n,s,0,e)}yd(e)}function vn(t,n=xr.Default){const e=Qe();return null===e?Hn(t,n):jS(bi(),e,Fn(t),n)}function d0(t,n,e,r,i,s,o,a,u,c,d){const p=n.blueprint.slice();return p[Te]=i,p[Pe]=140|r,(null!==c||t&&2048&t[Pe])&&(p[Pe]|=2048),Ht(p),p[fn]=p[wn]=t,p[mt]=e,p[ce]=o||t&&t[ce],p[ye]=a||t&&t[ye],p[Ft]=u||t&&t[Ft]||null,p[D]=s,p[ro]=function pU(){return fU++}(),p[da]=d,p[Ho]=c,p[Pn]=2==n.type?t[Pn]:p,p}function Pf(t,n,e,r,i){let s=t.data[n];if(null===s)s=function Qx(t,n,e,r,i){const s=Mo(),o=Po(),u=t.data[n]=function mW(t,n,e,r,i,s){let o=n?n.injectorIndex:-1,a=0;return function fr(){return null!==Qt.skipHydrationRootTNode}()&&(a|=128),{type:e,index:r,insertBeforeIndex:null,injectorIndex:o,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:i,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?s:s&&s.parent,e,n,r,i);return null===t.firstChild&&(t.firstChild=u),null!==s&&(o?null==s.child&&null!==u.parent&&(s.child=u):null===s.next&&(s.next=u,u.prev=s)),u}(t,n,e,r,i),function fV(){return Qt.lFrame.inI18n}()&&(s.flags|=32);else if(64&s.type){s.type=e,s.value=r,s.attrs=i;const o=function zs(){const t=Qt.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}();s.injectorIndex=null===o?-1:o.injectorIndex}return ps(s,!0),s}function ym(t,n,e,r){if(0===e)return-1;const i=n.length;for(let s=0;s<e;s++)n.push(r),t.blueprint.push(r),t.data.push(null);return i}function kT(t,n,e,r,i){const s=AT(n,cr),o=nl(),a=2&r;try{yd(-1),a&&n.length>Rr&&RT(t,n,Rr,!1),Zl(a?2:0,i);const c=a?s:null,d=jp(c);try{null!==c&&(c.dirty=!1),e(r,i)}finally{Kp(c,d)}}finally{a&&null===n[cr]&&MT(n,cr),yd(o),Zl(a?3:1,i)}}function qx(t,n,e){if(C(n)){const r=gl(null);try{const s=n.directiveEnd;for(let o=n.directiveStart;o<s;o++){const a=t.data[o];a.contentQueries&&a.contentQueries(1,e[o],o)}}finally{gl(r)}}}function FT(t){const n=t.tView;return null===n||n.incompleteFirstPass?t.tView=eE(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts,t.id):n}function eE(t,n,e,r,i,s,o,a,u,c,d){const p=Rr+r,v=p+i,x=function lW(t,n){const e=[];for(let r=0;r<n;r++)e.push(r<t?null:ui);return e}(p,v),b="function"==typeof c?c():c;return x[xe]={type:t,blueprint:x,template:e,queries:null,viewQuery:a,declTNode:n,data:x.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:v,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof s?s():s,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:u,consts:b,incompleteFirstPass:!1,ssrId:d}}let $T=t=>null;function BT(t,n,e,r){for(let i in t)if(t.hasOwnProperty(i)){e=null===e?{}:e;const s=t[i];null===r?zT(e,n,i,s):r.hasOwnProperty(i)&&zT(e,n,r[i],s)}return e}function zT(t,n,e,r){t.hasOwnProperty(e)?t[e].push(n,r):t[e]=[n,r]}function VT(t,n,e,r,i,s){for(let c=0;c<r.length;c++)J1(Ay(e,n),t,r[c].type);!function DW(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}(e,t.data.length,r.length);for(let c=0;c<r.length;c++){const d=r[c];d.providersResolver&&d.providersResolver(d)}let o=!1,a=!1,u=ym(t,n,r.length,null);for(let c=0;c<r.length;c++){const d=r[c];e.mergedAttrs=Tu(e.mergedAttrs,d.hostAttrs),TW(t,e,n,u,d),SW(u,d,i),null!==d.contentQueries&&(e.flags|=4),(null!==d.hostBindings||null!==d.hostAttrs||0!==d.hostVars)&&(e.flags|=64);const p=d.type.prototype;!o&&(p.ngOnChanges||p.ngOnInit||p.ngDoCheck)&&((t.preOrderHooks??=[]).push(e.index),o=!0),!a&&(p.ngOnChanges||p.ngDoCheck)&&((t.preOrderCheckHooks??=[]).push(e.index),a=!0),u++}!function gW(t,n,e){const i=n.directiveEnd,s=t.data,o=n.attrs,a=[];let u=null,c=null;for(let d=n.directiveStart;d<i;d++){const p=s[d],v=e?e.get(p):null,b=v?v.outputs:null;u=BT(p.inputs,d,u,v?v.inputs:null),c=BT(p.outputs,d,c,b);const w=null===u||null===o||Qs(n)?null:MW(u,d,o);a.push(w)}null!==u&&(u.hasOwnProperty("class")&&(n.flags|=8),u.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=u,n.outputs=c}(t,e,s)}function UT(t,n,e){const r=e.directiveStart,i=e.directiveEnd,s=e.index,o=function mV(){return Qt.lFrame.currentDirectiveIndex}();try{yd(s);for(let a=r;a<i;a++){const u=t.data[a],c=n[a];W1(a),(null!==u.hostBindings||0!==u.hostVars||null!==u.hostAttrs)&&bW(u,c)}}finally{yd(-1),W1(o)}}function bW(t,n){null!==t.hostBindings&&t.hostBindings(1,n)}function rE(t,n,e){n.componentOffset=e,(t.components??=[]).push(n.index)}function SW(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;Dt(n)&&(e[""]=t)}}function TW(t,n,e,r,i){t.data[r]=i;const s=i.factory||(i.factory=oh(i.type)),o=new qp(s,Dt(i),vn);t.blueprint[r]=o,e[r]=o,function xW(t,n,e,r,i){const s=i.hostBindings;if(s){let o=t.hostBindingOpCodes;null===o&&(o=t.hostBindingOpCodes=[]);const a=~n.index;(function EW(t){let n=t.length;for(;n>0;){const e=t[--n];if("number"==typeof e&&e<0)return e}return 0})(o)!=a&&o.push(a),o.push(e,r,s)}}(t,n,r,ym(t,e,i.hostVars,ui),i)}function AW(t,n,e,r,i,s){const o=s[n];if(null!==o)for(let a=0;a<o.length;)WT(r,e,o[a++],o[a++],o[a++])}function WT(t,n,e,r,i){const s=gl(null);try{const o=t.inputTransforms;null!==o&&o.hasOwnProperty(r)&&(i=o[r].call(n,i)),null!==t.setInput?t.setInput(n,i,e,r):n[r]=i}finally{gl(s)}}function MW(t,n,e){let r=null,i=0;for(;i<e.length;){const s=e[i];if(0!==s)if(5!==s){if("number"==typeof s)break;if(t.hasOwnProperty(s)){null===r&&(r=[]);const o=t[s];for(let a=0;a<o.length;a+=2)if(o[a]===n){r.push(s,o[a+1],e[i+1]);break}}i+=2}else i+=2;else i+=4}return r}function HT(t,n){const e=t.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r+1];if(-1!==s){const o=t.data[s];H1(e[r]),o.contentQueries(2,n[s],s)}}}function f0(t,n){return t[Ve]?t[sn][f]=n:t[Ve]=n,t[sn]=n,n}function sE(t,n,e){H1(0);const r=gl(null);try{n(t,e)}finally{gl(r)}}function jT(t){return t[j]||(t[j]=[])}function KT(t){return t.cleanup||(t.cleanup=[])}function ZT(t,n){const e=t[Ft],r=e?e.get(ch,null):null;r&&r.handleError(n)}function oE(t,n,e,r,i){for(let s=0;s<e.length;){const o=e[s++],a=e[s++];WT(t.data[o],n[o],r,a,i)}}function PW(t,n){const e=tl(n,t),r=e[xe];!function OW(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])}(r,e);const i=e[Te];null!==i&&null===e[da]&&(e[da]=zx(i,e[Ft])),aE(r,e,e[mt])}function aE(t,n,e){j1(n);try{const r=t.viewQuery;null!==r&&sE(1,r,e);const i=t.template;null!==i&&kT(t,n,i,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&HT(t,n),t.staticViewQueries&&sE(2,t.viewQuery,e);const s=t.components;null!==s&&function RW(t,n){for(let e=0;e<n.length;e++)PW(t,n[e])}(n,s)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[Pe]&=-5,K1()}}let YT=(()=>{class t{constructor(){this.all=new Set,this.queue=new Map}create(e,r,i){const s=typeof Zone>"u"?null:Zone.current,o=function P1(t,n,e){const r=Object.create(O1);e&&(r.consumerAllowSignalWrites=!0),r.fn=t,r.schedule=n;const i=o=>{r.cleanupFn=o};return r.ref={notify:()=>cy(r),run:()=>{if(r.dirty=!1,r.hasRun&&!hy(r))return;r.hasRun=!0;const o=jp(r);try{r.cleanupFn(),r.cleanupFn=vy,r.fn(i)}finally{Kp(r,o)}},cleanup:()=>r.cleanupFn()},r.ref}(e,c=>{this.all.has(c)&&this.queue.set(c,s)},i);let a;this.all.add(o),o.notify();const u=()=>{o.cleanup(),a?.(),this.all.delete(o),this.queue.delete(o)};return a=r?.onDestroy(u),{destroy:u}}flush(){if(0!==this.queue.size)for(const[e,r]of this.queue)this.queue.delete(e),r?r.run(()=>e.run()):e.run()}get isQueueEmpty(){return 0===this.queue.size}static#t=this.\u0275prov=$e({token:t,providedIn:"root",factory:()=>new t})}return t})();function p0(t,n,e){let r=e?t.styles:null,i=e?t.classes:null,s=0;if(null!==n)for(let o=0;o<n.length;o++){const a=n[o];"number"==typeof a?s=a:1==s?i=Ra(i,a):2==s&&(r=Ra(r,a+": "+n[++o]+";"))}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=i:t.classesWithoutHost=i}function vm(t,n,e,r,i=!1){for(;null!==e;){const s=n[e.index];null!==s&&r.push(vo(s)),_(s)&&QT(s,r);const o=e.type;if(8&o)vm(t,n,e.child,r);else if(32&o){const a=hx(e,n);let u;for(;u=a();)r.push(u)}else if(16&o){const a=MD(n,e);if(Array.isArray(a))r.push(...a);else{const u=om(n[Pn]);vm(u[xe],u,a,r,!0)}}e=i?e.projectionNext:e.next}return r}function QT(t,n){for(let e=l;e<t.length;e++){const r=t[e],i=r[xe].firstChild;null!==i&&vm(r[xe],r,i,n)}t[ws]!==t[Te]&&n.push(t[ws])}function m0(t,n,e,r=!0){const i=n[ce],s=i.rendererFactory,o=i.afterRenderEventManager;s.begin?.(),o?.begin();try{qT(t,n,t.template,e)}catch(u){throw r&&ZT(n,u),u}finally{s.end?.(),i.effectManager?.flush(),o?.end()}}function qT(t,n,e,r){const i=n[Pe];if(256!=(256&i)){n[ce].effectManager?.flush(),j1(n);try{Ht(n),function ah(t){return Qt.lFrame.bindingIndex=t}(t.bindingStartIndex),null!==e&&kT(t,n,e,2,r);const o=3==(3&i);if(o){const c=t.preOrderCheckHooks;null!==c&&Dy(n,c,null)}else{const c=t.preOrderHooks;null!==c&&Ty(n,c,0,null),X1(n,0)}if(function FW(t){for(let n=_D(t);null!==n;n=xD(n)){if(!n[Ns])continue;const e=n[na];for(let r=0;r<e.length;r++){Vt(e[r])}}}(n),JT(n,2),null!==t.contentQueries&&HT(t,n),o){const c=t.contentCheckHooks;null!==c&&Dy(n,c)}else{const c=t.contentHooks;null!==c&&Ty(n,c,1),X1(n,1)}!function uW(t,n){const e=t.hostBindingOpCodes;if(null===e)return;const r=AT(n,su);try{for(let i=0;i<e.length;i++){const s=e[i];if(s<0)yd(~s);else{const o=s,a=e[++i],u=e[++i];pV(a,o),r.dirty=!1;const c=jp(r);try{u(2,n[o])}finally{Kp(r,c)}}}}finally{null===n[su]&&MT(n,su),yd(-1)}}(t,n);const a=t.components;null!==a&&eN(n,a,0);const u=t.viewQuery;if(null!==u&&sE(2,u,r),o){const c=t.viewCheckHooks;null!==c&&Dy(n,c)}else{const c=t.viewHooks;null!==c&&Ty(n,c,2),X1(n,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),n[Pe]&=-73,$t(n)}finally{K1()}}}function JT(t,n){for(let e=_D(t);null!==e;e=xD(e))for(let r=l;r<e.length;r++)tN(e[r],n)}function $W(t,n,e){tN(tl(n,t),e)}function tN(t,n){if(!function V1(t){return 128==(128&t[Pe])}(t))return;const e=t[xe],r=t[Pe];if(80&r&&0===n||1024&r||2===n)qT(e,t,e.template,t[mt]);else if(t[E]>0){JT(t,1);const i=e.components;null!==i&&eN(t,i,1)}}function eN(t,n,e){for(let r=0;r<n.length;r++)$W(t,n[r],e)}class _m{get rootNodes(){const n=this._lView,e=n[xe];return vm(e,n,e.firstChild,[])}constructor(n,e){this._lView=n,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[mt]}set context(n){this._lView[mt]=n}get destroyed(){return 256==(256&this._lView[Pe])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const n=this._lView[fn];if(_(n)){const e=n[8],r=e?e.indexOf(this):-1;r>-1&&(jy(n,r),Ry(e,r))}this._attachedToViewContainer=!1}fx(this._lView[xe],this._lView)}onDestroy(n){!function Zt(t,n){if(256==(256&t[Pe]))throw new We(911,!1);null===t[ea]&&(t[ea]=[]),t[ea].push(n)}(this._lView,n)}markForCheck(){gm(this._cdRefInjectingView||this._lView)}detach(){this._lView[Pe]&=-129}reattach(){this._lView[Pe]|=128}detectChanges(){m0(this._lView[xe],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new We(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function TU(t,n){um(t,n,n[ye],2,null,null)}(this._lView[xe],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new We(902,!1);this._appRef=n}}class BW extends _m{constructor(n){super(n),this._view=n}detectChanges(){const n=this._view;m0(n[xe],n,n[mt],!1)}checkNoChanges(){}get context(){return null}}class nN extends l0{constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){const e=Tr(n);return new xm(e,this.ngModule)}}function rN(t){const n=[];for(let e in t)t.hasOwnProperty(e)&&n.push({propName:t[e],templateName:e});return n}class VW{constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){r=ua(r);const i=this.injector.get(n,Wx,r);return i!==Wx||e===Wx?i:this.parentInjector.get(n,e,r)}}class xm extends uT{get inputs(){const n=this.componentDef,e=n.inputTransforms,r=rN(n.inputs);if(null!==e)for(const i of r)e.hasOwnProperty(i.propName)&&(i.transform=e[i.propName]);return r}get outputs(){return rN(this.componentDef.outputs)}constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=function Go(t){return t.map(Nu).join(",")}(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!e}create(n,e,r,i){let s=(i=i||this.ngModule)instanceof Ql?i:i?.injector;s&&null!==this.componentDef.getStandaloneInjector&&(s=this.componentDef.getStandaloneInjector(s)||s);const o=s?new VW(n,s):n,a=o.get(cT,null);if(null===a)throw new We(407,!1);const p={rendererFactory:a,sanitizer:o.get(F4,null),effectManager:o.get(YT,null),afterRenderEventManager:o.get(Yx,null)},v=a.createRenderer(null,this.componentDef),x=this.componentDef.selectors[0][0]||"div",b=r?function cW(t,n,e,r){const s=r.get(ST,!1)||e===xa.ShadowDom,o=t.selectRootElement(n,s);return function hW(t){$T(t)}(o),o}(v,r,this.componentDef.encapsulation,o):Hy(v,x,function zW(t){const n=t.toLowerCase();return"svg"===n?"svg":"math"===n?"math":null}(x)),N=this.componentDef.signals?4608:this.componentDef.onPush?576:528;let S=null;null!==b&&(S=zx(b,o,!0));const U=eE(0,null,null,1,0,null,null,null,null,null,null),J=d0(null,U,null,N,null,null,p,v,o,null,S);let ht,Tt;j1(J);try{const Pt=this.componentDef;let zt,Ot=null;Pt.findHostDirectiveDefs?(zt=[],Ot=new Map,Pt.findHostDirectiveDefs(Pt,zt,Ot),zt.push(Pt)):zt=[Pt];const le=function WW(t,n){const e=t[xe],r=Rr;return t[r]=n,Pf(e,r,2,"#host",null)}(J,b),ge=function GW(t,n,e,r,i,s,o){const a=i[xe];!function HW(t,n,e,r){for(const i of t)n.mergedAttrs=Tu(n.mergedAttrs,i.hostAttrs);null!==n.mergedAttrs&&(p0(n,n.mergedAttrs,!0),null!==e&&LD(r,e,n))}(r,t,n,o);let u=null;null!==n&&(u=zx(n,i[Ft]));const c=s.rendererFactory.createRenderer(n,e);let d=16;e.signals?d=4096:e.onPush&&(d=64);const p=d0(i,FT(e),null,d,i[t.index],t,s,c,null,null,u);return a.firstCreatePass&&rE(a,t,r.length-1),f0(i,p),i[t.index]=p}(le,b,Pt,zt,J,p,v);Tt=wy(U,Rr),b&&function KW(t,n,e,r){if(r)Bs(t,e,["ng-version",$4.full]);else{const{attrs:i,classes:s}=function hs(t){const n=[],e=[];let r=1,i=2;for(;r<t.length;){let s=t[r];if("string"==typeof s)2===i?""!==s&&n.push(s,t[++r]):8===i&&e.push(s);else{if(!ka(i))break;i=s}r++}return{attrs:n,classes:e}}(n.selectors[0]);i&&Bs(t,e,i),s&&s.length>0&&RD(t,e,s.join(" "))}}(v,Pt,b,r),void 0!==e&&function XW(t,n,e){const r=t.projection=[];for(let i=0;i<n.length;i++){const s=e[i];r.push(null!=s?Array.from(s):null)}}(Tt,this.ngContentSelectors,e),ht=function jW(t,n,e,r,i,s){const o=bi(),a=i[xe],u=Fu(o,i);VT(a,i,o,e,null,r);for(let d=0;d<e.length;d++)Bu(vd(i,a,o.directiveStart+d,o),i);UT(a,i,o),u&&Bu(u,i);const c=vd(i,a,o.directiveStart+o.componentOffset,o);if(t[mt]=i[mt]=c,null!==s)for(const d of s)d(c,n);return qx(a,o,t),c}(ge,Pt,zt,Ot,J,[ZW]),aE(U,J,null)}finally{K1()}return new UW(this.componentType,ht,Nf(Tt,J),J,Tt)}}class UW extends M4{constructor(n,e,r,i,s){super(),this.location=r,this._rootLView=i,this._tNode=s,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new BW(i),this.componentType=n}setInput(n,e){const r=this._tNode.inputs;let i;if(null!==r&&(i=r[n])){if(this.previousInputValues??=new Map,this.previousInputValues.has(n)&&Object.is(this.previousInputValues.get(n),e))return;const s=this._rootLView;oE(s[xe],s,i,n,e),this.previousInputValues.set(n,e),gm(tl(this._tNode.index,s))}}get injector(){return new rl(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}}function ZW(){const t=bi();Sy(Qe()[xe],t)}function so(t){let n=function iN(t){return Object.getPrototypeOf(t.prototype).constructor}(t.type),e=!0;const r=[t];for(;n;){let i;if(Dt(t))i=n.\u0275cmp||n.\u0275dir;else{if(n.\u0275cmp)throw new We(903,!1);i=n.\u0275dir}if(i){if(e){r.push(i);const o=t;o.inputs=g0(t.inputs),o.inputTransforms=g0(t.inputTransforms),o.declaredInputs=g0(t.declaredInputs),o.outputs=g0(t.outputs);const a=i.hostBindings;a&&JW(t,a);const u=i.viewQuery,c=i.contentQueries;if(u&&QW(t,u),c&&qW(t,c),Cs(t.inputs,i.inputs),Cs(t.declaredInputs,i.declaredInputs),Cs(t.outputs,i.outputs),null!==i.inputTransforms&&(null===o.inputTransforms&&(o.inputTransforms={}),Cs(o.inputTransforms,i.inputTransforms)),Dt(i)&&i.data.animation){const d=t.data;d.animation=(d.animation||[]).concat(i.data.animation)}}const s=i.features;if(s)for(let o=0;o<s.length;o++){const a=s[o];a&&a.ngInherit&&a(t),a===so&&(e=!1)}}n=Object.getPrototypeOf(n)}!function YW(t){let n=0,e=null;for(let r=t.length-1;r>=0;r--){const i=t[r];i.hostVars=n+=i.hostVars,i.hostAttrs=Tu(i.hostAttrs,e=Tu(e,i.hostAttrs))}}(r)}function g0(t){return t===mi?{}:t===yi?[]:t}function QW(t,n){const e=t.viewQuery;t.viewQuery=e?(r,i)=>{n(r,i),e(r,i)}:n}function qW(t,n){const e=t.contentQueries;t.contentQueries=e?(r,i,s)=>{n(r,i,s),e(r,i,s)}:n}function JW(t,n){const e=t.hostBindings;t.hostBindings=e?(r,i)=>{n(r,i),e(r,i)}:n}function zu(t,n,e){return!Object.is(t[n],e)&&(t[n]=e,!0)}function Uf(t,n,e){const r=Qe();return zu(r,Tl(),n)&&function Pl(t,n,e,r,i,s,o,a){const u=Fu(n,e);let d,c=n.inputs;!a&&null!=c&&(d=c[r])?(oE(t,e,d,r,i),F(n)&&function vW(t,n){const e=tl(n,t);16&e[Pe]||(e[Pe]|=64)}(e,n.index)):3&n.type&&(r=function yW(t){return"class"===t?"className":"for"===t?"htmlFor":"formaction"===t?"formAction":"innerHtml"===t?"innerHTML":"readonly"===t?"readOnly":"tabindex"===t?"tabIndex":t}(r),i=null!=o?o(i,n.value||"",r):i,s.setProperty(u,r,i))}(Lr(),function fa(){const t=Qt.lFrame;return wy(t.tView,t.selectedIndex)}(),r,t,n,r[ye],e,!1),Uf}function pE(t,n,e,r,i){const o=i?"class":"style";oE(t,e,n.inputs[o],o,r)}function Ka(t,n,e,r){const i=Qe(),s=Lr(),o=Rr+t,a=i[ye],u=s.firstCreatePass?function AG(t,n,e,r,i,s){const o=n.consts,u=Pf(n,t,2,r,Lc(o,i));return function nE(t,n,e,r){if(nr()){const i=null===r?null:{"":-1},s=function wW(t,n){const e=t.directiveRegistry;let r=null,i=null;if(e)for(let s=0;s<e.length;s++){const o=e[s];if(Io(n,o.selectors,!1))if(r||(r=[]),Dt(o))if(null!==o.findHostDirectiveDefs){const a=[];i=i||new Map,o.findHostDirectiveDefs(o,a,i),r.unshift(...a,o),rE(t,n,a.length)}else r.unshift(o),rE(t,n,0);else i=i||new Map,o.findHostDirectiveDefs?.(o,r,i),r.push(o)}return null===r?null:[r,i]}(t,e);let o,a;null===s?o=a=null:[o,a]=s,null!==o&&VT(t,n,e,o,i,a),i&&function IW(t,n,e){if(n){const r=t.localNames=[];for(let i=0;i<n.length;i+=2){const s=e[n[i+1]];if(null==s)throw new We(-301,!1);r.push(n[i],s)}}}(e,r,i)}e.mergedAttrs=Tu(e.mergedAttrs,e.attrs)}(n,e,u,Lc(o,s)),null!==u.attrs&&p0(u,u.attrs,!1),null!==u.mergedAttrs&&p0(u,u.mergedAttrs,!0),null!==n.queries&&n.queries.elementStart(n,u),u}(o,s,i,n,e,r):s.data[o],c=bN(s,i,u,a,n,t);i[o]=c;const d=rt(u);return ps(u,!0),LD(a,c,u),32!=(32&u.flags)&&Iy()&&Xy(s,i,c,u),0===function He(){return Qt.lFrame.elementDepthCount}()&&Bu(c,i),function ln(){Qt.lFrame.elementDepthCount++}(),d&&(function Jx(t,n,e){nr()&&(function CW(t,n,e,r){const i=e.directiveStart,s=e.directiveEnd;F(e)&&function NW(t,n,e){const r=Fu(n,t),i=FT(e);let o=16;e.signals?o=4096:e.onPush&&(o=64);const a=f0(t,d0(t,i,null,o,r,n,null,t[ce].rendererFactory.createRenderer(r,e),null,null,null));t[n.index]=a}(n,e,t.data[i+e.componentOffset]),t.firstCreatePass||Ay(e,n),Bu(r,n);const o=e.initialInputs;for(let a=i;a<s;a++){const u=t.data[a],c=vd(n,t,a,e);Bu(c,n),null!==o&&AW(0,a-i,c,u,0,o),Dt(u)&&(tl(e.index,n)[mt]=vd(n,t,a,e))}}(t,n,e,Fu(e,n)),64==(64&e.flags)&&UT(t,n,e))}(s,i,u),qx(s,u,i)),null!==r&&function tE(t,n,e=Fu){const r=n.localNames;if(null!==r){let i=n.index+1;for(let s=0;s<r.length;s+=2){const o=r[s+1],a=-1===o?e(n,t):t[o];t[i++]=a}}}(i,u),Ka}function Xa(){let t=bi();Po()?function $u(){Qt.lFrame.isParent=!1}():(t=t.parent,ps(t,!1));const n=t;(function vi(t){return Qt.skipHydrationRootTNode===t})(n)&&function ou(){Qt.skipHydrationRootTNode=null}(),function hn(){Qt.lFrame.elementDepthCount--}();const e=Lr();return e.firstCreatePass&&(Sy(e,t),C(t)&&e.queries.elementEnd(t)),null!=n.classesWithoutHost&&function SV(t){return 0!=(8&t.flags)}(n)&&pE(e,n,Qe(),n.classesWithoutHost,!0),null!=n.stylesWithoutHost&&function DV(t){return 0!=(16&t.flags)}(n)&&pE(e,n,Qe(),n.stylesWithoutHost,!1),Xa}function vu(t,n,e,r){return Ka(t,n,e,r),Xa(),vu}let bN=(t,n,e,r,i,s)=>(Ph(!0),Hy(r,i,function FS(){return Qt.lFrame.currentNamespace}()));function Im(t){return!!t&&"function"==typeof t.then}function SN(t){return!!t&&"function"==typeof t.subscribe}function _u(t,n,e,r){const i=Qe(),s=Lr(),o=bi();return function TN(t,n,e,r,i,s,o){const a=rt(r),c=t.firstCreatePass&&KT(t),d=n[mt],p=jT(n);let v=!0;if(3&r.type||o){const w=Fu(r,n),T=o?o(w):w,N=p.length,S=o?J=>o(vo(J[r.index])):r.index;let U=null;if(!o&&a&&(U=function FG(t,n,e,r){const i=t.cleanup;if(null!=i)for(let s=0;s<i.length-1;s+=2){const o=i[s];if(o===e&&i[s+1]===r){const a=n[j],u=i[s+2];return a.length>u?a[u]:null}"string"==typeof o&&(s+=2)}return null}(t,n,i,r.index)),null!==U)(U.__ngLastListenerFn__||U).__ngNextListenerFn__=s,U.__ngLastListenerFn__=s,v=!1;else{s=AN(r,n,d,s,!1);const J=e.listen(T,i,s);p.push(s,J),c&&c.push(i,S,N,N+1)}}else s=AN(r,n,d,s,!1);const x=r.outputs;let b;if(v&&null!==x&&(b=x[i])){const w=b.length;if(w)for(let T=0;T<w;T+=2){const ht=n[b[T]][b[T+1]].subscribe(s),Tt=p.length;p.push(s,ht),c&&c.push(i,r.index,Tt,-(Tt+1))}}}(s,i,i[ye],o,t,n,r),_u}function NN(t,n,e,r){try{return Zl(6,n,e),!1!==e(r)}catch(i){return ZT(t,i),!1}finally{Zl(7,n,e)}}function AN(t,n,e,r,i){return function s(o){if(o===Function)return r;gm(t.componentOffset>-1?tl(t.index,n):n);let u=NN(n,e,r,o),c=s.__ngNextListenerFn__;for(;c;)u=NN(n,e,c,o)&&u,c=c.__ngNextListenerFn__;return i&&!1===u&&o.preventDefault(),u}}function C0(t,n){return t<<17|n<<2}function kh(t){return t>>17&32767}function vE(t){return 2|t}function Cd(t){return(131068&t)>>2}function _E(t,n){return-131069&t|n<<2}function xE(t){return 1|t}function zN(t,n,e,r,i){const s=t[e+1],o=null===n;let a=r?kh(s):Cd(s),u=!1;for(;0!==a&&(!1===u||o);){const d=t[a+1];KG(t[a],n)&&(u=!0,t[a+1]=r?xE(d):vE(d)),a=r?kh(d):Cd(d)}u&&(t[e+1]=r?vE(s):xE(s))}function KG(t,n){return null===t||null==n||(Array.isArray(t)?t[1]:t)===n||!(!Array.isArray(t)||"string"!=typeof n)&&yf(t,n)>=0}function b0(t,n){return function mc(t,n,e,r){const i=Qe(),s=Lr(),o=function pc(t){const n=Qt.lFrame,e=n.bindingIndex;return n.bindingIndex=n.bindingIndex+t,e}(2);s.firstUpdatePass&&function ZN(t,n,e,r){const i=t.data;if(null===i[e+1]){const s=i[nl()],o=function XN(t,n){return n>=t.expandoStartIndex}(t,e);(function JN(t,n){return 0!=(t.flags&(n?8:16))})(s,r)&&null===n&&!o&&(n=!1),n=function n5(t,n,e,r){const i=function G1(t){const n=Qt.lFrame.currentDirectiveIndex;return-1===n?null:t[n]}(t);let s=r?n.residualClasses:n.residualStyles;if(null===i)0===(r?n.classBindings:n.styleBindings)&&(e=Sm(e=EE(null,t,n,e,r),n.attrs,r),s=null);else{const o=n.directiveStylingLast;if(-1===o||t[o]!==i)if(e=EE(i,t,n,e,r),null===s){let u=function r5(t,n,e){const r=e?n.classBindings:n.styleBindings;if(0!==Cd(r))return t[kh(r)]}(t,n,r);void 0!==u&&Array.isArray(u)&&(u=EE(null,t,n,u[1],r),u=Sm(u,n.attrs,r),function i5(t,n,e,r){t[kh(e?n.classBindings:n.styleBindings)]=r}(t,n,r,u))}else s=function s5(t,n,e){let r;const i=n.directiveEnd;for(let s=1+n.directiveStylingLast;s<i;s++)r=Sm(r,t[s].hostAttrs,e);return Sm(r,n.attrs,e)}(t,n,r)}return void 0!==s&&(r?n.residualClasses=s:n.residualStyles=s),e}(i,s,n,r),function HG(t,n,e,r,i,s){let o=s?n.classBindings:n.styleBindings,a=kh(o),u=Cd(o);t[r]=e;let d,c=!1;if(Array.isArray(e)?(d=e[1],(null===d||yf(e,d)>0)&&(c=!0)):d=e,i)if(0!==u){const v=kh(t[a+1]);t[r+1]=C0(v,a),0!==v&&(t[v+1]=_E(t[v+1],r)),t[a+1]=function WG(t,n){return 131071&t|n<<17}(t[a+1],r)}else t[r+1]=C0(a,0),0!==a&&(t[a+1]=_E(t[a+1],r)),a=r;else t[r+1]=C0(u,0),0===a?a=r:t[u+1]=_E(t[u+1],r),u=r;c&&(t[r+1]=vE(t[r+1])),zN(t,d,r,!0),zN(t,d,r,!1),function jG(t,n,e,r,i){const s=i?t.residualClasses:t.residualStyles;null!=s&&"string"==typeof n&&yf(s,n)>=0&&(e[r+1]=xE(e[r+1]))}(n,d,t,r,s),o=C0(a,u),s?n.classBindings=o:n.styleBindings=o}(i,s,n,e,o,r)}}(s,t,o,r),n!==ui&&zu(i,o,n)&&function QN(t,n,e,r,i,s,o,a){if(!(3&n.type))return;const u=t.data,c=u[a+1],d=function GG(t){return 1==(1&t)}(c)?qN(u,n,e,i,Cd(c),o):void 0;w0(d)||(w0(s)||function UG(t){return 2==(2&t)}(c)&&(s=qN(u,null,e,i,a,o)),function $U(t,n,e,r,i){if(n)i?t.addClass(e,r):t.removeClass(e,r);else{let s=-1===r.indexOf("-")?void 0:Oh.DashCase;null==i?t.removeStyle(e,r,s):("string"==typeof i&&i.endsWith("!important")&&(i=i.slice(0,-10),s|=Oh.Important),t.setStyle(e,r,i,s))}}(r,o,lf(nl(),e),i,s))}(s,s.data[nl()],i,i[ye],t,i[o+1]=function l5(t,n){return null==t||""===t||("string"==typeof n?t+=n:"object"==typeof t&&(t=Yi(function Rh(t){return t instanceof BD?t.changingThisBreaksApplicationSecurity:t}(t)))),t}(n,e),r,o)}(t,n,null,!0),b0}function EE(t,n,e,r,i){let s=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(s=n[a],r=Sm(r,s.hostAttrs,i),s!==t);)a++;return null!==t&&(e.directiveStylingLast=a),r}function Sm(t,n,e){const r=e?1:2;let i=-1;if(null!==n)for(let s=0;s<n.length;s++){const o=n[s];"number"==typeof o?i=o:i===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),Nl(t,o,!!e||n[++s]))}return void 0===t?null:t}function qN(t,n,e,r,i,s){const o=null===n;let a;for(;i>0;){const u=t[i],c=Array.isArray(u),d=c?u[1]:u,p=null===d;let v=e[i+1];v===ui&&(v=p?yi:void 0);let x=p?nx(v,r):d===r?v:void 0;if(c&&!w0(x)&&(x=nx(u,r)),w0(x)&&(a=x,o))return a;const b=t[i+1];i=o?kh(b):Cd(b)}if(null!==n){let u=s?n.residualClasses:n.residualStyles;null!=u&&(a=nx(u,r))}return a}function w0(t){return void 0!==t}function Jl(t,n=""){const e=Qe(),r=Lr(),i=t+Rr,s=r.firstCreatePass?Pf(r,i,1,n,null):r.data[i],o=tA(r,e,s,n,t);e[i]=o,Iy()&&Xy(r,e,o,s),ps(s,!1)}let tA=(t,n,e,r,i)=>(Ph(!0),function Gy(t,n){return t.createText(n)}(n[ye],r));function CE(t){return Dm("",t,""),CE}function Dm(t,n,e){const r=Qe(),i=function Rf(t,n,e,r){return zu(t,Tl(),e)?n+mr(e)+r:ui}(r,t,n,e);return i!==ui&&function dh(t,n,e){const r=lf(n,t);!function CD(t,n,e){t.setValue(n,e)}(t[ye],r,e)}(r,nl(),i),Dm}const bd=void 0;var M5=["en",[["a","p"],["AM","PM"],bd],[["AM","PM"],bd,bd],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],bd,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],bd,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",bd,"{1} 'at' {0}",bd],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function A5(t){const e=Math.floor(Math.abs(t)),r=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===r?1:5}];let Gf={};function il(t){const n=function P5(t){return t.toLowerCase().replace(/_/g,"-")}(t);let e=EA(n);if(e)return e;const r=n.split("-")[0];if(e=EA(r),e)return e;if("en"===r)return M5;throw new We(701,!1)}function EA(t){return t in Gf||(Gf[t]=as.ng&&as.ng.common&&as.ng.common.locales&&as.ng.common.locales[t]),Gf[t]}var Ro=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}(Ro||{});const Hf="en-US";let CA=Hf;function IE(t,n,e,r,i){if(t=Fn(t),Array.isArray(t))for(let s=0;s<t.length;s++)IE(t[s],n,e,r,i);else{const s=Lr(),o=Qe(),a=bi();let u=xd(t)?t:Fn(t.provide);const c=nT(t),d=1048575&a.providerIndexes,p=a.directiveStart,v=a.providerIndexes>>20;if(xd(t)||!t.multi){const x=new qp(c,i,vn),b=DE(u,n,i?d:d+v,p);-1===b?(J1(Ay(a,o),s,u),SE(s,t,n.length),n.push(u),a.directiveStart++,a.directiveEnd++,i&&(a.providerIndexes+=1048576),e.push(x),o.push(x)):(e[b]=x,o[b]=x)}else{const x=DE(u,n,d+v,p),b=DE(u,n,d,d+v),T=b>=0&&e[b];if(i&&!T||!i&&!(x>=0&&e[x])){J1(Ay(a,o),s,u);const N=function A6(t,n,e,r,i){const s=new qp(t,e,vn);return s.multi=[],s.index=n,s.componentProviders=0,KA(s,i,r&&!e),s}(i?N6:T6,e.length,i,r,c);!i&&T&&(e[b].providerFactory=N),SE(s,t,n.length,0),n.push(u),a.directiveStart++,a.directiveEnd++,i&&(a.providerIndexes+=1048576),e.push(N),o.push(N)}else SE(s,t,x>-1?x:b,KA(e[i?b:x],c,!i&&r));!i&&r&&T&&e[b].componentProviders++}}}function SE(t,n,e,r){const i=xd(n),s=function p4(t){return!!t.useClass}(n);if(i||s){const u=(s?Fn(n.useClass):n).prototype.ngOnDestroy;if(u){const c=t.destroyHooks||(t.destroyHooks=[]);if(!i&&n.multi){const d=c.indexOf(e);-1===d?c.push(e,[r,u]):c[d+1].push(r,u)}else c.push(e,u)}}}function KA(t,n,e){return e&&t.componentProviders++,t.multi.push(n)-1}function DE(t,n,e,r){for(let i=e;i<r;i++)if(n[i]===t)return i;return-1}function T6(t,n,e,r){return TE(this.multi,[])}function N6(t,n,e,r){const i=this.multi;let s;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=vd(e,e[xe],this.providerFactory.index,r);s=a.slice(0,o),TE(i,s);for(let u=o;u<a.length;u++)s.push(a[u])}else s=[],TE(i,s);return s}function TE(t,n){for(let e=0;e<t.length;e++)n.push((0,t[e])());return n}function ra(t,n=[]){return e=>{e.providersResolver=(r,i)=>function D6(t,n,e){const r=Lr();if(r.firstCreatePass){const i=Dt(t);IE(e,r.data,r.blueprint,i,!0),IE(n,r.data,r.blueprint,i,!1)}}(r,i?i(t):t,n)}}class wd{}class XA{}class NE extends wd{constructor(n,e,r){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new nN(this);const i=ct(n);this._bootstrapComponents=hh(i.bootstrap),this._r3Injector=mT(n,e,[{provide:wd,useValue:this},{provide:l0,useValue:this.componentFactoryResolver},...r],Yi(n),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(n)}get injector(){return this._r3Injector}destroy(){const n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}}class AE extends XA{constructor(n){super(),this.moduleType=n}create(n){return new NE(this.moduleType,n,[])}}class ZA extends wd{constructor(n){super(),this.componentFactoryResolver=new nN(this),this.instance=null;const e=new wf([...n.providers,{provide:wd,useValue:this},{provide:l0,useValue:this.componentFactoryResolver}],n.parent||e0(),n.debugName,new Set(["environment"]));this.injector=e,n.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}}function ME(t,n,e=null){return new ZA({providers:t,parent:n,debugName:e,runEnvironmentInitializers:!0}).injector}let O6=(()=>{class t{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e)){const r=qD(0,e.type),i=r.length>0?ME([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e,i)}return this.cachedInjectors.get(e)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}static#t=this.\u0275prov=$e({token:t,providedIn:"environment",factory:()=>new t(Hn(Ql))})}return t})();function YA(t){t.getStandaloneInjector=n=>n.get(O6).getOrCreateStandaloneInjector(t)}function iM(t,n,e,r,i,s,o){const a=n+e;return function Ed(t,n,e,r){const i=zu(t,n,e);return zu(t,n+1,r)||i}(t,a,i,s)?function $c(t,n,e){return t[n]=e}(t,a+2,o?r.call(o,i,s):r(i,s)):function Om(t,n){const e=t[n];return e===ui?void 0:e}(t,a+2)}function lM(t,n,e,r){const i=t+Rr,s=Qe(),o=function Mh(t,n){return t[n]}(s,i);return function Rm(t,n){return t[xe].data[n].pure}(s,i)?iM(s,function wa(){const t=Qt.lFrame;let n=t.bindingRootIndex;return-1===n&&(n=t.bindingRootIndex=t.tView.bindingStartIndex),n}(),n,o.transform,e,r,o):o.transform(e,r)}function rH(){return this._results[Symbol.iterator]()}class OE{static#t=Symbol.iterator;get changes(){return this._changes||(this._changes=new Ia)}constructor(n=!1){this._emitDistinctChangesOnly=n,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=OE.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=rH)}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){const r=this;r.dirty=!1;const i=function Yl(t){return t.flat(Number.POSITIVE_INFINITY)}(n);(this._changesDetected=!function VV(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let i=t[r],s=n[r];if(e&&(i=e(i),s=e(s)),s!==i)return!1}return!0}(r._results,i,e))&&(r._results=i,r.length=i.length,r.last=i[this.length-1],r.first=i[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}function sH(t,n,e,r=!0){const i=n[xe];if(function AU(t,n,e,r){const i=l+r,s=e.length;r>0&&(e[i-1][f]=n),r<s-l?(n[f]=e[i],qS(e,l+r,n)):(e.push(n),n[f]=null),n[fn]=e;const o=n[Nr];null!==o&&e!==o&&function MU(t,n){const e=t[na];n[Pn]!==n[fn][fn][Pn]&&(t[Ns]=!0),null===e?t[na]=[n]:e.push(n)}(o,n);const a=n[qi];null!==a&&a.insertView(t),n[Pe]|=128}(i,n,t,e),r){const s=yx(e,t),o=n[ye],a=Ky(o,t[ws]);null!==a&&function DU(t,n,e,r,i,s){r[Te]=i,r[D]=n,um(t,r,e,1,i,s)}(i,t[D],o,n,a,s)}}let fh=(()=>{class t{static#t=this.__NG_ELEMENT_ID__=uH}return t})();const oH=fh,aH=class extends oH{constructor(n,e,r){super(),this._declarationLView=n,this._declarationTContainer=e,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(n,e){return this.createEmbeddedViewImpl(n,e)}createEmbeddedViewImpl(n,e,r){const i=function iH(t,n,e,r){const i=n.tView,a=d0(t,i,e,4096&t[Pe]?4096:16,null,n,null,null,null,r?.injector??null,r?.hydrationInfo??null);a[Nr]=t[n.index];const c=t[qi];return null!==c&&(a[qi]=c.createEmbeddedView(i)),aE(i,a,e),a}(this._declarationLView,this._declarationTContainer,n,{injector:e,hydrationInfo:r});return new _m(i)}};function uH(){return N0(bi(),Qe())}function N0(t,n){return 4&t.type?new aH(n,t,Nf(t,n)):null}let yc=(()=>{class t{static#t=this.__NG_ELEMENT_ID__=pH}return t})();function pH(){return gM(bi(),Qe())}const mH=yc,pM=class extends mH{constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return Nf(this._hostTNode,this._hostLView)}get injector(){return new rl(this._hostTNode,this._hostLView)}get parentInjector(){const n=My(this._hostTNode,this._hostLView);if(Y1(n)){const e=tm(n,this._hostLView),r=Jp(n);return new rl(e[xe].data[r+8],e)}return new rl(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){const e=mM(this._lContainer);return null!==e&&e[n]||null}get length(){return this._lContainer.length-l}createEmbeddedView(n,e,r){let i,s;"number"==typeof r?i=r:null!=r&&(i=r.index,s=r.injector);const a=n.createEmbeddedViewImpl(e||{},s,null);return this.insertImpl(a,i,false),a}createComponent(n,e,r,i,s){const o=n&&!function nm(t){return"function"==typeof t}(n);let a;if(o)a=e;else{const w=e||{};a=w.index,r=w.injector,i=w.projectableNodes,s=w.environmentInjector||w.ngModuleRef}const u=o?n:new xm(Tr(n)),c=r||this.parentInjector;if(!s&&null==u.ngModule){const T=(o?c:this.parentInjector).get(Ql,null);T&&(s=T)}Tr(u.componentType??{});const x=u.create(c,i,null,s);return this.insertImpl(x.hostView,a,false),x}insert(n,e){return this.insertImpl(n,e,!1)}insertImpl(n,e,r){const i=n._lView;if(function U1(t){return _(t[fn])}(i)){const u=this.indexOf(n);if(-1!==u)this.detach(u);else{const c=i[fn],d=new pM(c,c[D],c[fn]);d.detach(d.indexOf(n))}}const o=this._adjustIndex(e),a=this._lContainer;return sH(a,i,o,!r),n.attachToViewContainerRef(),qS(RE(a),o,n),n}move(n,e){return this.insert(n,e)}indexOf(n){const e=mM(this._lContainer);return null!==e?e.indexOf(n):-1}remove(n){const e=this._adjustIndex(n,-1),r=jy(this._lContainer,e);r&&(Ry(RE(this._lContainer),e),fx(r[xe],r))}detach(n){const e=this._adjustIndex(n,-1),r=jy(this._lContainer,e);return r&&null!=Ry(RE(this._lContainer),e)?new _m(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function mM(t){return t[8]}function RE(t){return t[8]||(t[8]=[])}function gM(t,n){let e;const r=n[t.index];return _(r)?e=r:(e=function GT(t,n,e,r){return[t,!0,!1,n,null,0,r,e,null,null,null]}(r,n,null,t),n[t.index]=e,f0(n,e)),yM(e,n,t,r),new pM(e,t,n)}let yM=function vM(t,n,e,r){if(t[ws])return;let i;i=8&e.type?vo(r):function gH(t,n){const e=t[ye],r=e.createComment(""),i=Fu(n,t);return _d(e,Ky(e,i),r,function LU(t,n){return t.nextSibling(n)}(e,i),!1),r}(n,e),t[ws]=i};class LE{constructor(n){this.queryList=n,this.matches=null}clone(){return new LE(this.queryList)}setDirty(){this.queryList.setDirty()}}class kE{constructor(n=[]){this.queries=n}createEmbeddedView(n){const e=n.queries;if(null!==e){const r=null!==n.contentQueries?n.contentQueries[0]:e.length,i=[];for(let s=0;s<r;s++){const o=e.getByIndex(s);i.push(this.queries[o.indexInDeclarationView].clone())}return new kE(i)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)null!==wM(n,e).matches&&this.queries[e].setDirty()}}class _M{constructor(n,e,r=null){this.predicate=n,this.flags=e,this.read=r}}class FE{constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){const i=null!==e?e.length:0,s=this.getByIndex(r).embeddedTView(n,i);s&&(s.indexInDeclarationView=r,null!==e?e.push(s):e=[s])}return null!==e?new FE(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}}class $E{constructor(n,e=-1){this.metadata=n,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new $E(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=n.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let i=0;i<r.length;i++){const s=r[i];this.matchTNodeWithReadOption(n,e,_H(e,s)),this.matchTNodeWithReadOption(n,e,Py(e,n,s,!1,!1))}else r===fh?4&e.type&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,Py(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(null!==r){const i=this.metadata.read;if(null!==i)if(i===Al||i===yc||i===fh&&4&e.type)this.addMatch(e.index,-2);else{const s=Py(e,n,i,!1,!1);null!==s&&this.addMatch(e.index,s)}else this.addMatch(e.index,r)}}addMatch(n,e){null===this.matches?this.matches=[n,e]:this.matches.push(n,e)}}function _H(t,n){const e=t.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1];return null}function EH(t,n,e,r){return-1===e?function xH(t,n){return 11&t.type?Nf(t,n):4&t.type?N0(t,n):null}(n,t):-2===e?function CH(t,n,e){return e===Al?Nf(n,t):e===fh?N0(n,t):e===yc?gM(n,t):void 0}(t,n,r):vd(t,t[xe],e,n)}function xM(t,n,e,r){const i=n[qi].queries[r];if(null===i.matches){const s=t.data,o=e.matches,a=[];for(let u=0;u<o.length;u+=2){const c=o[u];a.push(c<0?null:EH(n,s[c],o[u+1],e.metadata.read))}i.matches=a}return i.matches}function BE(t,n,e,r){const i=t.queries.getByIndex(e),s=i.matches;if(null!==s){const o=xM(t,n,i,e);for(let a=0;a<s.length;a+=2){const u=s[a];if(u>0)r.push(o[a/2]);else{const c=s[a+1],d=n[-u];for(let p=l;p<d.length;p++){const v=d[p];v[Nr]===v[fn]&&BE(v[xe],v,c,r)}if(null!==d[na]){const p=d[na];for(let v=0;v<p.length;v++){const x=p[v];BE(x[xe],x,c,r)}}}}}return r}function M0(t){const n=Qe(),e=Lr(),r=MS();H1(r+1);const i=wM(e,r);if(t.dirty&&function z1(t){return 4==(4&t[Pe])}(n)===(2==(2&i.metadata.flags))){if(null===i.matches)t.reset([]);else{const s=i.crossesNgTemplate?BE(e,n,r,[]):xM(e,n,i,r);t.reset(s,L4),t.notifyOnChanges()}return!0}return!1}function zE(t,n,e){const r=Lr();r.firstCreatePass&&(function bM(t,n,e){null===t.queries&&(t.queries=new FE),t.queries.track(new $E(n,e))}(r,new _M(t,n,e),-1),2==(2&n)&&(r.staticViewQueries=!0)),function CM(t,n,e){const r=new OE(4==(4&e));(function pW(t,n,e,r){const i=jT(n);i.push(e),t.firstCreatePass&&KT(t).push(r,i.length-1)})(t,n,r,r.destroy),null===n[qi]&&(n[qi]=new kE),n[qi].queries.push(new LE(r))}(r,Qe(),n)}function P0(){return function bH(t,n){return t[qi].queries[n].queryList}(Qe(),MS())}function wM(t,n){return t.queries.getByIndex(n)}const jE=new In("Application Initializer");let KE=(()=>{class t{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,r)=>{this.resolve=e,this.reject=r}),this.appInits=Mn(jE,{optional:!0})??[]}runInitializers(){if(this.initialized)return;const e=[];for(const i of this.appInits){const s=i();if(Im(s))e.push(s);else if(SN(s)){const o=new Promise((a,u)=>{s.subscribe({complete:a,error:u})});e.push(o)}}const r=()=>{this.done=!0,this.resolve()};Promise.all(e).then(()=>{r()}).catch(i=>{this.reject(i)}),0===e.length&&r(),this.initialized=!0}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),VM=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"platform"})}return t})();const ph=new In("LocaleId",{providedIn:"root",factory:()=>Mn(ph,xr.Optional|xr.SkipSelf)||function jH(){return typeof $localize<"u"&&$localize.locale||Hf}()});let UM=(()=>{class t{constructor(){this.taskId=0,this.pendingTasks=new Set,this.hasPendingTasks=new Gr(!1)}add(){this.hasPendingTasks.next(!0);const e=this.taskId++;return this.pendingTasks.add(e),e}remove(e){this.pendingTasks.delete(e),0===this.pendingTasks.size&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks.next(!1)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();class ZH{constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}}let WM=(()=>{class t{compileModuleSync(e){return new AE(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),s=hh(ct(e).declarations).reduce((o,a)=>{const u=Tr(a);return u&&o.push(new xm(u)),o},[]);return new ZH(r,s)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();const KM=new In(""),L0=new In("");let qE,YE=(()=>{class t{constructor(e,r,i){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,qE||(function y8(t){qE=t}(i),i.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Oo.assertNotInAngularZone(),queueMicrotask(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())queueMicrotask(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,i){let s=-1;r&&r>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==s),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:s,updateCb:i})}whenStable(e,r,i){if(i&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,i),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,i){return[]}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(Oo),Hn(QE),Hn(L0))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})(),QE=(()=>{class t{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return qE?.findTestabilityInTree(this,e,r)??null}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"platform"})}return t})(),Fh=null;const XM=new In("AllowMultipleToken"),JE=new In("PlatformDestroyListeners"),tC=new In("appBootstrapListener");class YM{constructor(n,e){this.name=n,this.token=e}}function qM(t,n,e=[]){const r=`Platform: ${n}`,i=new In(r);return(s=[])=>{let o=eC();if(!o||o.injector.get(XM,!1)){const a=[...e,...s,{provide:i,useValue:!0}];t?t(a):function x8(t){if(Fh&&!Fh.get(XM,!1))throw new We(400,!1);(function ZM(){!function D1(t){Xl=t}(()=>{throw new We(600,!1)})})(),Fh=t;const n=t.get(tP);(function QM(t){t.get(rT,null)?.forEach(e=>e())})(t)}(function JM(t=[],n){return Ml.create({name:n,providers:[{provide:Nx,useValue:"platform"},{provide:JE,useValue:new Set([()=>Fh=null])},...t]})}(a,r))}return function C8(t){const n=eC();if(!n)throw new We(401,!1);return n}()}}function eC(){return Fh?.get(tP)??null}let tP=(()=>{class t{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const i=function b8(t="zone.js",n){return"noop"===t?new Y4:"zone.js"===t?new Oo(n):t}(r?.ngZone,function eP(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:t?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:t?.runCoalescing??!1}}({eventCoalescing:r?.ngZoneEventCoalescing,runCoalescing:r?.ngZoneRunCoalescing}));return i.run(()=>{const s=function P6(t,n,e){return new NE(t,n,e)}(e.moduleType,this.injector,function oP(t){return[{provide:Oo,useFactory:t},{provide:dm,multi:!0,useFactory:()=>{const n=Mn(I8,{optional:!0});return()=>n.initialize()}},{provide:sP,useFactory:w8},{provide:xT,useFactory:ET}]}(()=>i)),o=s.injector.get(ch,null);return i.runOutsideAngular(()=>{const a=i.onError.subscribe({next:u=>{o.handleError(u)}});s.onDestroy(()=>{k0(this._modules,s),a.unsubscribe()})}),function nP(t,n,e){try{const r=e();return Im(r)?r.catch(i=>{throw n.runOutsideAngular(()=>t.handleError(i)),i}):r}catch(r){throw n.runOutsideAngular(()=>t.handleError(r)),r}}(o,i,()=>{const a=s.injector.get(KE);return a.runInitializers(),a.donePromise.then(()=>(function bA(t){Yt(t,"Expected localeId to be defined"),"string"==typeof t&&(CA=t.toLowerCase().replace(/_/g,"-"))}(s.injector.get(ph,Hf)||Hf),this._moduleDoBootstrap(s),s))})})}bootstrapModule(e,r=[]){const i=rP({},r);return function v8(t,n,e){const r=new AE(e);return Promise.resolve(r)}(0,0,e).then(s=>this.bootstrapModuleFactory(s,i))}_moduleDoBootstrap(e){const r=e.injector.get(Xf);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(i=>r.bootstrap(i));else{if(!e.instance.ngDoBootstrap)throw new We(-403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new We(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(JE,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(Ml))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"platform"})}return t})();function rP(t,n){return Array.isArray(n)?n.reduce(rP,t):{...t,...n}}let Xf=(()=>{class t{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=Mn(sP),this.zoneIsStable=Mn(xT),this.componentTypes=[],this.components=[],this.isStable=Mn(UM).hasPendingTasks.pipe(bo(e=>e?Qn(!1):this.zoneIsStable),function Yu(t,n=Ct){return t=t??ga,we((e,r)=>{let i,s=!0;e.subscribe(Me(r,o=>{const a=n(o);(s||!t(i,a))&&(s=!1,i=a,r.next(o))}))})}(),ma()),this._injector=Mn(Ql)}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const i=e instanceof uT;if(!this._injector.get(KE).done)throw!i&&function gt(t){const n=Tr(t)||ri(t)||ds(t);return null!==n&&n.standalone}(e),new We(405,!1);let o;o=i?e:this._injector.get(l0).resolveComponentFactory(e),this.componentTypes.push(o.componentType);const a=function _8(t){return t.isBoundToModule}(o)?void 0:this._injector.get(wd),c=o.create(Ml.NULL,[],r||o.selector,a),d=c.location.nativeElement,p=c.injector.get(KM,null);return p?.registerApplication(d),c.onDestroy(()=>{this.detachView(c.hostView),k0(this.components,c),p?.unregisterApplication(d)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new We(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this.internalErrorHandler(e)}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;k0(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const r=this._injector.get(tC,[]);r.push(...this._bootstrapListeners),r.forEach(i=>i(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>k0(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new We(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function k0(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}const sP=new In("",{providedIn:"root",factory:()=>Mn(ch).handleError.bind(void 0)});function w8(){const t=Mn(Oo),n=Mn(ch);return e=>t.runOutsideAngular(()=>n.handleError(e))}let I8=(()=>{class t{constructor(){this.zone=Mn(Oo),this.applicationRef=Mn(Xf)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();let F0=(()=>{class t{static#t=this.__NG_ELEMENT_ID__=D8}return t})();function D8(t){return function T8(t,n,e){if(F(t)&&!e){const r=tl(t.index,n);return new _m(r,r)}return 47&t.type?new _m(n[Pn],n):null}(bi(),Qe(),16==(16&t))}const V8=qM(null,"core",[]);let U8=(()=>{class t{constructor(e){}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(Xf))};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({})}return t})();let aC=null;function $h(){return aC}class nj{}const tc=new In("DocumentToken");let uC=(()=>{class t{historyGo(e){throw new Error("Not implemented")}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(ij)},providedIn:"platform"})}return t})();const rj=new In("Location Initialized");let ij=(()=>{class t extends uC{constructor(){super(),this._doc=Mn(tc),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return $h().getBaseHref(this._doc)}onPopState(e){const r=$h().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=$h().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,i){this._history.pushState(e,r,i)}replaceState(e,r,i){this._history.replaceState(e,r,i)}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return new t},providedIn:"platform"})}return t})();function lC(t,n){if(0==t.length)return n;if(0==n.length)return t;let e=0;return t.endsWith("/")&&e++,n.startsWith("/")&&e++,2==e?t+n.substring(1):1==e?t+n:t+"/"+n}function wP(t){const n=t.match(/#|\?|$/),e=n&&n.index||t.length;return t.slice(0,e-("/"===t[e-1]?1:0))+t.slice(e)}function mh(t){return t&&"?"!==t[0]?"?"+t:t}let Sd=(()=>{class t{historyGo(e){throw new Error("Not implemented")}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(SP)},providedIn:"root"})}return t})();const IP=new In("appBaseHref");let SP=(()=>{class t extends Sd{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Mn(tc).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return lC(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+mh(this._platformLocation.search),i=this._platformLocation.hash;return i&&e?`${r}${i}`:r}pushState(e,r,i,s){const o=this.prepareExternalUrl(i+mh(s));this._platformLocation.pushState(e,r,o)}replaceState(e,r,i,s){const o=this.prepareExternalUrl(i+mh(s));this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(uC),Hn(IP,8))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),sj=(()=>{class t extends Sd{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=lC(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,i,s){let o=this.prepareExternalUrl(i+mh(s));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,r,o)}replaceState(e,r,i,s){let o=this.prepareExternalUrl(i+mh(s));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(uC),Hn(IP,8))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})(),cC=(()=>{class t{constructor(e){this._subject=new Ia,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._basePath=function uj(t){if(new RegExp("^(https?:)?//").test(t)){const[,e]=t.split(/\/\/[^\/]+/);return e}return t}(wP(DP(r))),this._locationStrategy.onPopState(i=>{this._subject.emit({url:this.path(!0),pop:!0,state:i.state,type:i.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+mh(r))}normalize(e){return t.stripTrailingSlash(function aj(t,n){if(!t||!n.startsWith(t))return n;const e=n.substring(t.length);return""===e||["/",";","?","#"].includes(e[0])?e:n}(this._basePath,DP(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",i=null){this._locationStrategy.pushState(i,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+mh(r)),i)}replaceState(e,r="",i=null){this._locationStrategy.replaceState(i,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+mh(r)),i)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(i=>i(e,r))}subscribe(e,r,i){return this._subject.subscribe({next:e,error:r,complete:i})}static#t=this.normalizeQueryParams=mh;static#e=this.joinWithSlash=lC;static#n=this.stripTrailingSlash=wP;static#r=this.\u0275fac=function(r){return new(r||t)(Hn(Sd))};static#i=this.\u0275prov=$e({token:t,factory:function(){return function oj(){return new cC(Hn(Sd))}()},providedIn:"root"})}return t})();function DP(t){return t.replace(/\/index.html$/,"")}var U0=function(t){return t[t.Decimal=0]="Decimal",t[t.Percent=1]="Percent",t[t.Currency=2]="Currency",t[t.Scientific=3]="Scientific",t}(U0||{}),Ba=function(t){return t[t.Decimal=0]="Decimal",t[t.Group=1]="Group",t[t.List=2]="List",t[t.PercentSign=3]="PercentSign",t[t.PlusSign=4]="PlusSign",t[t.MinusSign=5]="MinusSign",t[t.Exponential=6]="Exponential",t[t.SuperscriptingExponent=7]="SuperscriptingExponent",t[t.PerMille=8]="PerMille",t[t.Infinity=9]="Infinity",t[t.NaN=10]="NaN",t[t.TimeSeparator=11]="TimeSeparator",t[t.CurrencyDecimal=12]="CurrencyDecimal",t[t.CurrencyGroup=13]="CurrencyGroup",t}(Ba||{});function ec(t,n){const e=il(t),r=e[Ro.NumberSymbols][n];if(typeof r>"u"){if(n===Ba.CurrencyDecimal)return e[Ro.NumberSymbols][Ba.Decimal];if(n===Ba.CurrencyGroup)return e[Ro.NumberSymbols][Ba.Group]}return r}const Lj=/^(\d+)?\.((\d+)(-(\d+))?)?$/;function vC(t){const n=parseInt(t);if(isNaN(n))throw new Error("Invalid integer literal when parsing "+t);return n}let UP=(()=>{class t{constructor(e){this._locale=e}transform(e,r,i){if(!function bC(t){return!(null==t||""===t||t!=t)}(e))return null;i=i||this._locale;try{return function Vj(t,n,e){return function gC(t,n,e,r,i,s,o=!1){let a="",u=!1;if(isFinite(t)){let c=function Wj(t){let r,i,s,o,a,n=Math.abs(t)+"",e=0;for((i=n.indexOf("."))>-1&&(n=n.replace(".","")),(s=n.search(/e/i))>0?(i<0&&(i=s),i+=+n.slice(s+1),n=n.substring(0,s)):i<0&&(i=n.length),s=0;"0"===n.charAt(s);s++);if(s===(a=n.length))r=[0],i=1;else{for(a--;"0"===n.charAt(a);)a--;for(i-=s,r=[],o=0;s<=a;s++,o++)r[o]=Number(n.charAt(s))}return i>22&&(r=r.splice(0,21),e=i-1,i=1),{digits:r,exponent:e,integerLen:i}}(t);o&&(c=function Uj(t){if(0===t.digits[0])return t;const n=t.digits.length-t.integerLen;return t.exponent?t.exponent+=2:(0===n?t.digits.push(0,0):1===n&&t.digits.push(0),t.integerLen+=2),t}(c));let d=n.minInt,p=n.minFrac,v=n.maxFrac;if(s){const S=s.match(Lj);if(null===S)throw new Error(`${s} is not a valid digit info`);const U=S[1],J=S[3],ht=S[5];null!=U&&(d=vC(U)),null!=J&&(p=vC(J)),null!=ht?v=vC(ht):null!=J&&p>v&&(v=p)}!function Gj(t,n,e){if(n>e)throw new Error(`The minimum number of digits after fraction (${n}) is higher than the maximum (${e}).`);let r=t.digits,i=r.length-t.integerLen;const s=Math.min(Math.max(n,i),e);let o=s+t.integerLen,a=r[o];if(o>0){r.splice(Math.max(t.integerLen,o));for(let p=o;p<r.length;p++)r[p]=0}else{i=Math.max(0,i),t.integerLen=1,r.length=Math.max(1,o=s+1),r[0]=0;for(let p=1;p<o;p++)r[p]=0}if(a>=5)if(o-1<0){for(let p=0;p>o;p--)r.unshift(0),t.integerLen++;r.unshift(1),t.integerLen++}else r[o-1]++;for(;i<Math.max(0,s);i++)r.push(0);let u=0!==s;const c=n+t.integerLen,d=r.reduceRight(function(p,v,x,b){return b[x]=(v+=p)<10?v:v-10,u&&(0===b[x]&&x>=c?b.pop():u=!1),v>=10?1:0},0);d&&(r.unshift(d),t.integerLen++)}(c,p,v);let x=c.digits,b=c.integerLen;const w=c.exponent;let T=[];for(u=x.every(S=>!S);b<d;b++)x.unshift(0);for(;b<0;b++)x.unshift(0);b>0?T=x.splice(b,x.length):(T=x,x=[0]);const N=[];for(x.length>=n.lgSize&&N.unshift(x.splice(-n.lgSize,x.length).join(""));x.length>n.gSize;)N.unshift(x.splice(-n.gSize,x.length).join(""));x.length&&N.unshift(x.join("")),a=N.join(ec(e,r)),T.length&&(a+=ec(e,i)+T.join("")),w&&(a+=ec(e,Ba.Exponential)+"+"+w)}else a=ec(e,Ba.Infinity);return a=t<0&&!u?n.negPre+a+n.negSuf:n.posPre+a+n.posSuf,a}(t,function yC(t,n="-"){const e={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},r=t.split(";"),i=r[0],s=r[1],o=-1!==i.indexOf(".")?i.split("."):[i.substring(0,i.lastIndexOf("0")+1),i.substring(i.lastIndexOf("0")+1)],a=o[0],u=o[1]||"";e.posPre=a.substring(0,a.indexOf("#"));for(let d=0;d<u.length;d++){const p=u.charAt(d);"0"===p?e.minFrac=e.maxFrac=d+1:"#"===p?e.maxFrac=d+1:e.posSuf+=p}const c=a.split(",");if(e.gSize=c[1]?c[1].length:0,e.lgSize=c[2]||c[1]?(c[2]||c[1]).length:0,s){const d=i.length-e.posPre.length-e.posSuf.length,p=s.indexOf("#");e.negPre=s.substring(0,p).replace(/'/g,""),e.negSuf=s.slice(p+d).replace(/'/g,"")}else e.negPre=n+e.posPre,e.negSuf=e.posSuf;return e}(function hC(t,n){return il(t)[Ro.NumberFormats][n]}(n,U0.Decimal),ec(n,Ba.MinusSign)),n,Ba.Group,Ba.Decimal,e)}(function wC(t){if("string"==typeof t&&!isNaN(Number(t)-parseFloat(t)))return Number(t);if("number"!=typeof t)throw new Error(`${t} is not a number`);return t}(e),i,r)}catch(s){throw function _c(t,n){return new We(2100,!1)}()}}static#t=this.\u0275fac=function(r){return new(r||t)(vn(ph,16))};static#e=this.\u0275pipe=bs({name:"number",type:t,pure:!0,standalone:!0})}return t})();let CK=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({})}return t})();function GP(t){return"server"===t}let SK=(()=>{class t{static#t=this.\u0275prov=$e({token:t,providedIn:"root",factory:()=>new DK(Hn(tc),window)})}return t})();class DK{constructor(n,e){this.document=n,this.window=e,this.offset=()=>[0,0]}setOffset(n){this.offset=Array.isArray(n)?()=>n:n}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(n){this.supportsScrolling()&&this.window.scrollTo(n[0],n[1])}scrollToAnchor(n){if(!this.supportsScrolling())return;const e=function TK(t,n){const e=t.getElementById(n)||t.getElementsByName(n)[0];if(e)return e;if("function"==typeof t.createTreeWalker&&t.body&&"function"==typeof t.body.attachShadow){const r=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let i=r.currentNode;for(;i;){const s=i.shadowRoot;if(s){const o=s.getElementById(n)||s.querySelector(`[name="${n}"]`);if(o)return o}i=r.nextNode()}}return null}(this.document,n);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(n){this.supportsScrolling()&&(this.window.history.scrollRestoration=n)}scrollToElement(n){const e=n.getBoundingClientRect(),r=e.left+this.window.pageXOffset,i=e.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(r-s[0],i-s[1])}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}class qK extends nj{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class DC extends qK{static makeCurrent(){!function ej(t){aC||(aC=t)}(new DC)}onAndCancel(n,e,r){return n.addEventListener(e,r),()=>{n.removeEventListener(e,r)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.parentNode&&n.parentNode.removeChild(n)}createElement(n,e){return(e=e||this.getDefaultDocument()).createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return"window"===e?window:"document"===e?n:"body"===e?n.body:null}getBaseHref(n){const e=function JK(){return Vm=Vm||document.querySelector("base"),Vm?Vm.getAttribute("href"):null}();return null==e?null:function t9(t){tv=tv||document.createElement("a"),tv.setAttribute("href",t);const n=tv.pathname;return"/"===n.charAt(0)?n:`/${n}`}(e)}resetBaseElement(){Vm=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return function jj(t,n){n=encodeURIComponent(n);for(const e of t.split(";")){const r=e.indexOf("="),[i,s]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(i.trim()===n)return decodeURIComponent(s)}return null}(document.cookie,n)}}let tv,Vm=null,n9=(()=>{class t{build(){return new XMLHttpRequest}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();const TC=new In("EventManagerPlugins");let ZP=(()=>{class t{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(i=>{i.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,i){return this._findPluginFor(r).addEventListener(e,r,i)}getZone(){return this._zone}_findPluginFor(e){let r=this._eventNameToPlugin.get(e);if(r)return r;if(r=this._plugins.find(s=>s.supports(e)),!r)throw new We(5101,!1);return this._eventNameToPlugin.set(e,r),r}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(TC),Hn(Oo))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();class YP{constructor(n){this._doc=n}}const NC="ng-app-id";let QP=(()=>{class t{constructor(e,r,i,s={}){this.doc=e,this.appId=r,this.nonce=i,this.platformId=s,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=GP(s),this.resetHostNodes()}addStyles(e){for(const r of e)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(e){for(const r of e)this.changeUsageCount(r,-1)<=0&&this.onStyleRemoved(r)}ngOnDestroy(){const e=this.styleNodesInDOM;e&&(e.forEach(r=>r.remove()),e.clear());for(const r of this.getAllStyles())this.onStyleRemoved(r);this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(e){for(const r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){const r=this.styleRef;r.get(e)?.elements?.forEach(i=>i.remove()),r.delete(e)}collectServerRenderedStyles(){const e=this.doc.head?.querySelectorAll(`style[${NC}="${this.appId}"]`);if(e?.length){const r=new Map;return e.forEach(i=>{null!=i.textContent&&r.set(i.textContent,i)}),r}return null}changeUsageCount(e,r){const i=this.styleRef;if(i.has(e)){const s=i.get(e);return s.usage+=r,s.usage}return i.set(e,{usage:r,elements:[]}),r}getStyleElement(e,r){const i=this.styleNodesInDOM,s=i?.get(r);if(s?.parentNode===e)return i.delete(r),s.removeAttribute(NC),s;{const o=this.doc.createElement("style");return this.nonce&&o.setAttribute("nonce",this.nonce),o.textContent=r,this.platformIsServer&&o.setAttribute(NC,this.appId),o}}addStyleToHost(e,r){const i=this.getStyleElement(e,r);e.appendChild(i);const s=this.styleRef,o=s.get(r)?.elements;o?o.push(i):s.set(r,{elements:[i],usage:1})}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(tc),Hn(n0),Hn(iT,8),Hn(Sf))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();const AC={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},MC=/%COMP%/g,o9=new In("RemoveStylesOnCompDestroy",{providedIn:"root",factory:()=>!1});function JP(t,n){return n.map(e=>e.replace(MC,t))}let tO=(()=>{class t{constructor(e,r,i,s,o,a,u,c=null){this.eventManager=e,this.sharedStylesHost=r,this.appId=i,this.removeStylesOnCompDestroy=s,this.doc=o,this.platformId=a,this.ngZone=u,this.nonce=c,this.rendererByCompId=new Map,this.platformIsServer=GP(a),this.defaultRenderer=new PC(e,o,u,this.platformIsServer)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===xa.ShadowDom&&(r={...r,encapsulation:xa.Emulated});const i=this.getOrCreateRenderer(e,r);return i instanceof nO?i.applyToHost(e):i instanceof OC&&i.applyStyles(),i}getOrCreateRenderer(e,r){const i=this.rendererByCompId;let s=i.get(r.id);if(!s){const o=this.doc,a=this.ngZone,u=this.eventManager,c=this.sharedStylesHost,d=this.removeStylesOnCompDestroy,p=this.platformIsServer;switch(r.encapsulation){case xa.Emulated:s=new nO(u,c,r,this.appId,d,o,a,p);break;case xa.ShadowDom:return new c9(u,c,e,r,o,a,this.nonce,p);default:s=new OC(u,c,r,d,o,a,p)}i.set(r.id,s)}return s}ngOnDestroy(){this.rendererByCompId.clear()}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(ZP),Hn(QP),Hn(n0),Hn(o9),Hn(tc),Hn(Sf),Hn(Oo),Hn(iT))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();class PC{constructor(n,e,r,i){this.eventManager=n,this.doc=e,this.ngZone=r,this.platformIsServer=i,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(n,e){return e?this.doc.createElementNS(AC[e]||e,n):this.doc.createElement(n)}createComment(n){return this.doc.createComment(n)}createText(n){return this.doc.createTextNode(n)}appendChild(n,e){(eO(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(eO(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){n&&n.removeChild(e)}selectRootElement(n,e){let r="string"==typeof n?this.doc.querySelector(n):n;if(!r)throw new We(-5104,!1);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,i){if(i){e=i+":"+e;const s=AC[i];s?n.setAttributeNS(s,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){const i=AC[r];i?n.removeAttributeNS(i,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,i){i&(Oh.DashCase|Oh.Important)?n.style.setProperty(e,r,i&Oh.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&Oh.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n[e]=r}setValue(n,e){n.nodeValue=e}listen(n,e,r){if("string"==typeof n&&!(n=$h().getGlobalEventTarget(this.doc,n)))throw new Error(`Unsupported event target ${n} for event ${e}`);return this.eventManager.addEventListener(n,e,this.decoratePreventDefault(r))}decoratePreventDefault(n){return e=>{if("__ngUnwrap__"===e)return n;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>n(e)):n(e))&&e.preventDefault()}}}function eO(t){return"TEMPLATE"===t.tagName&&void 0!==t.content}class c9 extends PC{constructor(n,e,r,i,s,o,a,u){super(n,s,o,u),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const c=JP(i.id,i.styles);for(const d of c){const p=document.createElement("style");a&&p.setAttribute("nonce",a),p.textContent=d,this.shadowRoot.appendChild(p)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(this.nodeOrShadowRoot(n),e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class OC extends PC{constructor(n,e,r,i,s,o,a,u){super(n,s,o,a),this.sharedStylesHost=e,this.removeStylesOnCompDestroy=i,this.styles=u?JP(u,r.styles):r.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles)}destroy(){this.removeStylesOnCompDestroy&&this.sharedStylesHost.removeStyles(this.styles)}}class nO extends OC{constructor(n,e,r,i,s,o,a,u){const c=i+"-"+r.id;super(n,e,r,s,o,a,u,c),this.contentAttr=function a9(t){return"_ngcontent-%COMP%".replace(MC,t)}(c),this.hostAttr=function u9(t){return"_nghost-%COMP%".replace(MC,t)}(c)}applyToHost(n){this.applyStyles(),this.setAttribute(n,this.hostAttr,"")}createElement(n,e){const r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}}let h9=(()=>{class t extends YP{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,i){return e.addEventListener(r,i,!1),()=>this.removeEventListener(e,r,i)}removeEventListener(e,r,i){return e.removeEventListener(r,i)}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(tc))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();const rO=["alt","control","meta","shift"],d9={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},f9={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let p9=(()=>{class t extends YP{constructor(e){super(e)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,r,i){const s=t.parseEventName(r),o=t.eventCallback(s.fullKey,i,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>$h().onAndCancel(e,s.domEventName,o))}static parseEventName(e){const r=e.toLowerCase().split("."),i=r.shift();if(0===r.length||"keydown"!==i&&"keyup"!==i)return null;const s=t._normalizeKey(r.pop());let o="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),o="code."),rO.forEach(c=>{const d=r.indexOf(c);d>-1&&(r.splice(d,1),o+=c+".")}),o+=s,0!=r.length||0===s.length)return null;const u={};return u.domEventName=i,u.fullKey=o,u}static matchEventFullKeyCode(e,r){let i=d9[e.key]||e.key,s="";return r.indexOf("code.")>-1&&(i=e.code,s="code."),!(null==i||!i)&&(i=i.toLowerCase()," "===i?i="space":"."===i&&(i="dot"),rO.forEach(o=>{o!==i&&(0,f9[o])(e)&&(s+=o+".")}),s+=i,s===r)}static eventCallback(e,r,i){return s=>{t.matchEventFullKeyCode(s,e)&&i.runGuarded(()=>r(s))}}static _normalizeKey(e){return"esc"===e?"escape":e}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(tc))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();const v9=qM(V8,"browser",[{provide:Sf,useValue:"browser"},{provide:rT,useValue:function m9(){DC.makeCurrent()},multi:!0},{provide:tc,useFactory:function y9(){return function WU(t){xx=t}(document),document},deps:[]}]),_9=new In(""),oO=[{provide:L0,useClass:class e9{addToWindow(n){as.getAngularTestability=(r,i=!0)=>{const s=n.findTestabilityInTree(r,i);if(null==s)throw new We(5103,!1);return s},as.getAllAngularTestabilities=()=>n.getAllTestabilities(),as.getAllAngularRootElements=()=>n.getAllRootElements(),as.frameworkStabilizers||(as.frameworkStabilizers=[]),as.frameworkStabilizers.push(r=>{const i=as.getAllAngularTestabilities();let s=i.length,o=!1;const a=function(u){o=o||u,s--,0==s&&r(o)};i.forEach(u=>{u.whenStable(a)})})}findTestabilityInTree(n,e,r){return null==e?null:n.getTestability(e)??(r?$h().isShadowRoot(e)?this.findTestabilityInTree(n,e.host,!0):this.findTestabilityInTree(n,e.parentElement,!0):null)}},deps:[]},{provide:KM,useClass:YE,deps:[Oo,QE,L0]},{provide:YE,useClass:YE,deps:[Oo,QE,L0]}],aO=[{provide:Nx,useValue:"root"},{provide:ch,useFactory:function g9(){return new ch},deps:[]},{provide:TC,useClass:h9,multi:!0,deps:[tc,Oo,Sf]},{provide:TC,useClass:p9,multi:!0,deps:[tc]},tO,QP,ZP,{provide:cT,useExisting:tO},{provide:class NK{},useClass:n9,deps:[]},[]];let x9=(()=>{class t{constructor(e){}static withServerTransition(e){return{ngModule:t,providers:[{provide:n0,useValue:e.appId}]}}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(_9,12))};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({providers:[...aO,...oO],imports:[CK,U8]})}return t})(),uO=(()=>{class t{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(tc))};static#e=this.\u0275prov=$e({token:t,factory:function(r){let i=null;return i=r?new r:function C9(){return new uO(Hn(tc))}(),i},providedIn:"root"})}return t})();typeof window<"u"&&window;const{isArray:T9}=Array,{getPrototypeOf:N9,prototype:A9,keys:M9}=Object;function dO(t){if(1===t.length){const n=t[0];if(T9(n))return{args:n,keys:null};if(function P9(t){return t&&"object"==typeof t&&N9(t)===A9}(n)){const e=M9(n);return{args:e.map(r=>n[r]),keys:e}}}return{args:t,keys:null}}const{isArray:O9}=Array;function fO(t){return Ue(n=>function R9(t,n){return O9(n)?t(...n):t(n)}(t,n))}function pO(t,n){return t.reduce((e,r,i)=>(e[r]=n[i],e),{})}function LC(...t){const n=eo(t),e=Pa(t),{args:r,keys:i}=dO(t);if(0===r.length)return ys([],n);const s=new xt(function L9(t,n,e=Ct){return r=>{mO(n,()=>{const{length:i}=t,s=new Array(i);let o=i,a=i;for(let u=0;u<i;u++)mO(n,()=>{const c=ys(t[u],n);let d=!1;c.subscribe(Me(r,p=>{s[u]=p,d||(d=!0,a--),a||r.next(e(s.slice()))},()=>{--o||r.complete()}))},r)},r)}}(r,n,i?o=>pO(i,o):Ct));return e?s.pipe(fO(e)):s}function mO(t,n,e){t?Es(e,t,n):n()}const ev=H(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"});function kC(...t){return function k9(){return ti(1)}()(ys(t,eo(t)))}function gO(t){return new xt(n=>{kr(t()).subscribe(n)})}function Um(t,n){const e=V(t)?t:()=>t,r=i=>i.error(e());return new xt(n?i=>n.schedule(r,0,i):r)}function FC(){return we((t,n)=>{let e=null;t._refCount++;const r=Me(n,void 0,void 0,void 0,()=>{if(!t||t._refCount<=0||0<--t._refCount)return void(e=null);const i=t._connection,s=e;e=null,i&&(!s||i===s)&&i.unsubscribe(),n.unsubscribe()});t.subscribe(r),r.closed||(e=t.connect())})}class yO extends xt{constructor(n,e){super(),this.source=n,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,se(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){const n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new R;const e=this.getSubject();n.add(this.source.subscribe(Me(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=R.EMPTY)}return n}refCount(){return FC()(this)}}function Qf(t){return t<=0?()=>Vr:we((n,e)=>{let r=0;n.subscribe(Me(e,i=>{++r<=t&&(e.next(i),t<=r&&e.complete())}))})}function zh(t,n){return we((e,r)=>{let i=0;e.subscribe(Me(r,s=>t.call(n,s,i++)&&r.next(s)))})}function nv(t){return we((n,e)=>{let r=!1;n.subscribe(Me(e,i=>{r=!0,e.next(i)},()=>{r||e.next(t),e.complete()}))})}function vO(t=$9){return we((n,e)=>{let r=!1;n.subscribe(Me(e,i=>{r=!0,e.next(i)},()=>r?e.complete():e.error(t())))})}function $9(){return new ev}function Dd(t,n){const e=arguments.length>=2;return r=>r.pipe(t?zh((i,s)=>t(i,s,r)):Ct,Qf(1),e?nv(n):vO(()=>new ev))}function Wm(t,n){return V(n)?Rs(t,n,1):Rs(t,1)}function Vu(t,n,e){const r=V(t)||n||e?{next:t,error:n,complete:e}:t;return r?we((i,s)=>{var o;null===(o=r.subscribe)||void 0===o||o.call(r);let a=!0;i.subscribe(Me(s,u=>{var c;null===(c=r.next)||void 0===c||c.call(r,u),s.next(u)},()=>{var u;a=!1,null===(u=r.complete)||void 0===u||u.call(r),s.complete()},u=>{var c;a=!1,null===(c=r.error)||void 0===c||c.call(r,u),s.error(u)},()=>{var u,c;a&&(null===(u=r.unsubscribe)||void 0===u||u.call(r)),null===(c=r.finalize)||void 0===c||c.call(r)}))}):Ct}function Td(t){return we((n,e)=>{let s,r=null,i=!1;r=n.subscribe(Me(e,void 0,void 0,o=>{s=kr(t(o,Td(t)(n))),r?(r.unsubscribe(),r=null,s.subscribe(e)):i=!0})),i&&(r.unsubscribe(),r=null,s.subscribe(e))})}function $C(t){return t<=0?()=>Vr:we((n,e)=>{let r=[];n.subscribe(Me(e,i=>{r.push(i),t<r.length&&r.shift()},()=>{for(const i of r)e.next(i);e.complete()},void 0,()=>{r=null}))})}function BC(t){return we((n,e)=>{try{n.subscribe(e)}finally{e.add(t)}})}const gi="primary",Gm=Symbol("RouteTitle");class G9{constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function qf(t){return new G9(t)}function H9(t,n,e){const r=e.path.split("/");if(r.length>t.length||"full"===e.pathMatch&&(n.hasChildren()||r.length<t.length))return null;const i={};for(let s=0;s<r.length;s++){const o=r[s],a=t[s];if(o.startsWith(":"))i[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:t.slice(0,r.length),posParams:i}}function Uc(t,n){const e=t?Object.keys(t):void 0,r=n?Object.keys(n):void 0;if(!e||!r||e.length!=r.length)return!1;let i;for(let s=0;s<e.length;s++)if(i=e[s],!_O(t[i],n[i]))return!1;return!0}function _O(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;const e=[...t].sort(),r=[...n].sort();return e.every((i,s)=>r[s]===i)}return t===n}function xO(t){return t.length>0?t[t.length-1]:null}function Vh(t){return function D9(t){return!!t&&(t instanceof xt||V(t.lift)&&V(t.subscribe))}(t)?t:Im(t)?ys(Promise.resolve(t)):Qn(t)}const K9={exact:function bO(t,n,e){if(!Nd(t.segments,n.segments)||!rv(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children)if(!t.children[r]||!bO(t.children[r],n.children[r],e))return!1;return!0},subset:wO},EO={exact:function X9(t,n){return Uc(t,n)},subset:function Z9(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>_O(t[e],n[e]))},ignored:()=>!0};function CO(t,n,e){return K9[e.paths](t.root,n.root,e.matrixParams)&&EO[e.queryParams](t.queryParams,n.queryParams)&&!("exact"===e.fragment&&t.fragment!==n.fragment)}function wO(t,n,e){return IO(t,n,n.segments,e)}function IO(t,n,e,r){if(t.segments.length>e.length){const i=t.segments.slice(0,e.length);return!(!Nd(i,e)||n.hasChildren()||!rv(i,e,r))}if(t.segments.length===e.length){if(!Nd(t.segments,e)||!rv(t.segments,e,r))return!1;for(const i in n.children)if(!t.children[i]||!wO(t.children[i],n.children[i],r))return!1;return!0}{const i=e.slice(0,t.segments.length),s=e.slice(t.segments.length);return!!(Nd(t.segments,i)&&rv(t.segments,i,r)&&t.children[gi])&&IO(t.children[gi],n,s,r)}}function rv(t,n,e){return n.every((r,i)=>EO[e](t[i].parameters,r.parameters))}class Jf{constructor(n=new oo([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=qf(this.queryParams)),this._queryParamMap}toString(){return q9.serialize(this)}}class oo{constructor(n,e){this.segments=n,this.children=e,this.parent=null,Object.values(e).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return iv(this)}}class Hm{constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=qf(this.parameters)),this._parameterMap}toString(){return TO(this)}}function Nd(t,n){return t.length===n.length&&t.every((e,r)=>e.path===n[r].path)}let jm=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return new zC},providedIn:"root"})}return t})();class zC{parse(n){const e=new l7(n);return new Jf(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){const e=`/${Km(n.root,!0)}`,r=function e7(t){const n=Object.keys(t).map(e=>{const r=t[e];return Array.isArray(r)?r.map(i=>`${sv(e)}=${sv(i)}`).join("&"):`${sv(e)}=${sv(r)}`}).filter(e=>!!e);return n.length?`?${n.join("&")}`:""}(n.queryParams);return`${e}${r}${"string"==typeof n.fragment?`#${function J9(t){return encodeURI(t)}(n.fragment)}`:""}`}}const q9=new zC;function iv(t){return t.segments.map(n=>TO(n)).join("/")}function Km(t,n){if(!t.hasChildren())return iv(t);if(n){const e=t.children[gi]?Km(t.children[gi],!1):"",r=[];return Object.entries(t.children).forEach(([i,s])=>{i!==gi&&r.push(`${i}:${Km(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function Q9(t,n){let e=[];return Object.entries(t.children).forEach(([r,i])=>{r===gi&&(e=e.concat(n(i,r)))}),Object.entries(t.children).forEach(([r,i])=>{r!==gi&&(e=e.concat(n(i,r)))}),e}(t,(r,i)=>i===gi?[Km(t.children[gi],!1)]:[`${i}:${Km(r,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children[gi]?`${iv(t)}/${e[0]}`:`${iv(t)}/(${e.join("//")})`}}function SO(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function sv(t){return SO(t).replace(/%3B/gi,";")}function VC(t){return SO(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function ov(t){return decodeURIComponent(t)}function DO(t){return ov(t.replace(/\+/g,"%20"))}function TO(t){return`${VC(t.path)}${function t7(t){return Object.keys(t).map(n=>`;${VC(n)}=${VC(t[n])}`).join("")}(t.parameters)}`}const n7=/^[^\/()?;#]+/;function UC(t){const n=t.match(n7);return n?n[0]:""}const r7=/^[^\/()?;=#]+/,s7=/^[^=?&#]+/,a7=/^[^&#]+/;class l7{constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new oo([],{}):new oo([],this.parseChildren())}parseQueryParams(){const n={};if(this.consumeOptional("?"))do{this.parseQueryParam(n)}while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(e).length>0)&&(r[gi]=new oo(n,e)),r}parseSegment(){const n=UC(this.remaining);if(""===n&&this.peekStartsWith(";"))throw new We(4009,!1);return this.capture(n),new Hm(ov(n),this.parseMatrixParams())}parseMatrixParams(){const n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){const e=function i7(t){const n=t.match(r7);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=UC(this.remaining);i&&(r=i,this.capture(r))}n[ov(e)]=ov(r)}parseQueryParam(n){const e=function o7(t){const n=t.match(s7);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const o=function u7(t){const n=t.match(a7);return n?n[0]:""}(this.remaining);o&&(r=o,this.capture(r))}const i=DO(e),s=DO(r);if(n.hasOwnProperty(i)){let o=n[i];Array.isArray(o)||(o=[o],n[i]=o),o.push(s)}else n[i]=s}parseParens(n){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=UC(this.remaining),i=this.remaining[r.length];if("/"!==i&&")"!==i&&";"!==i)throw new We(4010,!1);let s;r.indexOf(":")>-1?(s=r.slice(0,r.indexOf(":")),this.capture(s),this.capture(":")):n&&(s=gi);const o=this.parseChildren();e[s]=1===Object.keys(o).length?o[gi]:new oo([],o),this.consumeOptional("//")}return e}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return!!this.peekStartsWith(n)&&(this.remaining=this.remaining.substring(n.length),!0)}capture(n){if(!this.consumeOptional(n))throw new We(4011,!1)}}function NO(t){return t.segments.length>0?new oo([],{[gi]:t}):t}function AO(t){const n={};for(const r of Object.keys(t.children)){const s=AO(t.children[r]);if(r===gi&&0===s.segments.length&&s.hasChildren())for(const[o,a]of Object.entries(s.children))n[o]=a;else(s.segments.length>0||s.hasChildren())&&(n[r]=s)}return function c7(t){if(1===t.numberOfChildren&&t.children[gi]){const n=t.children[gi];return new oo(t.segments.concat(n.segments),n.children)}return t}(new oo(t.segments,n))}function Ad(t){return t instanceof Jf}function MO(t){let n;const i=NO(function e(s){const o={};for(const u of s.children){const c=e(u);o[u.outlet]=c}const a=new oo(s.url,o);return s===t&&(n=a),a}(t.root));return n??i}function PO(t,n,e,r){let i=t;for(;i.parent;)i=i.parent;if(0===n.length)return WC(i,i,i,e,r);const s=function d7(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new RO(!0,0,t);let n=0,e=!1;const r=t.reduce((i,s,o)=>{if("object"==typeof s&&null!=s){if(s.outlets){const a={};return Object.entries(s.outlets).forEach(([u,c])=>{a[u]="string"==typeof c?c.split("/"):c}),[...i,{outlets:a}]}if(s.segmentPath)return[...i,s.segmentPath]}return"string"!=typeof s?[...i,s]:0===o?(s.split("/").forEach((a,u)=>{0==u&&"."===a||(0==u&&""===a?e=!0:".."===a?n++:""!=a&&i.push(a))}),i):[...i,s]},[]);return new RO(e,n,r)}(n);if(s.toRoot())return WC(i,i,new oo([],{}),e,r);const o=function f7(t,n,e){if(t.isAbsolute)return new uv(n,!0,0);if(!e)return new uv(n,!1,NaN);if(null===e.parent)return new uv(e,!0,0);const r=av(t.commands[0])?0:1;return function p7(t,n,e){let r=t,i=n,s=e;for(;s>i;){if(s-=i,r=r.parent,!r)throw new We(4005,!1);i=r.segments.length}return new uv(r,!1,i-s)}(e,e.segments.length-1+r,t.numberOfDoubleDots)}(s,i,t),a=o.processChildren?Zm(o.segmentGroup,o.index,s.commands):LO(o.segmentGroup,o.index,s.commands);return WC(i,o.segmentGroup,a,e,r)}function av(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function Xm(t){return"object"==typeof t&&null!=t&&t.outlets}function WC(t,n,e,r,i){let o,s={};r&&Object.entries(r).forEach(([u,c])=>{s[u]=Array.isArray(c)?c.map(d=>`${d}`):`${c}`}),o=t===n?e:OO(t,n,e);const a=NO(AO(o));return new Jf(a,s,i)}function OO(t,n,e){const r={};return Object.entries(t.children).forEach(([i,s])=>{r[i]=s===n?e:OO(s,n,e)}),new oo(t.segments,r)}class RO{constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&av(r[0]))throw new We(4003,!1);const i=r.find(Xm);if(i&&i!==xO(r))throw new We(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class uv{constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}}function LO(t,n,e){if(t||(t=new oo([],{})),0===t.segments.length&&t.hasChildren())return Zm(t,n,e);const r=function g7(t,n,e){let r=0,i=n;const s={match:!1,pathIndex:0,commandIndex:0};for(;i<t.segments.length;){if(r>=e.length)return s;const o=t.segments[i],a=e[r];if(Xm(a))break;const u=`${a}`,c=r<e.length-1?e[r+1]:null;if(i>0&&void 0===u)break;if(u&&c&&"object"==typeof c&&void 0===c.outlets){if(!FO(u,c,o))return s;r+=2}else{if(!FO(u,{},o))return s;r++}i++}return{match:!0,pathIndex:i,commandIndex:r}}(t,n,e),i=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const s=new oo(t.segments.slice(0,r.pathIndex),{});return s.children[gi]=new oo(t.segments.slice(r.pathIndex),t.children),Zm(s,0,i)}return r.match&&0===i.length?new oo(t.segments,{}):r.match&&!t.hasChildren()?GC(t,n,e):r.match?Zm(t,0,i):GC(t,n,e)}function Zm(t,n,e){if(0===e.length)return new oo(t.segments,{});{const r=function m7(t){return Xm(t[0])?t[0].outlets:{[gi]:t}}(e),i={};if(Object.keys(r).some(s=>s!==gi)&&t.children[gi]&&1===t.numberOfChildren&&0===t.children[gi].segments.length){const s=Zm(t.children[gi],n,e);return new oo(t.segments,s.children)}return Object.entries(r).forEach(([s,o])=>{"string"==typeof o&&(o=[o]),null!==o&&(i[s]=LO(t.children[s],n,o))}),Object.entries(t.children).forEach(([s,o])=>{void 0===r[s]&&(i[s]=o)}),new oo(t.segments,i)}}function GC(t,n,e){const r=t.segments.slice(0,n);let i=0;for(;i<e.length;){const s=e[i];if(Xm(s)){const u=y7(s.outlets);return new oo(r,u)}if(0===i&&av(e[0])){r.push(new Hm(t.segments[n].path,kO(e[0]))),i++;continue}const o=Xm(s)?s.outlets[gi]:`${s}`,a=i<e.length-1?e[i+1]:null;o&&a&&av(a)?(r.push(new Hm(o,kO(a))),i+=2):(r.push(new Hm(o,{})),i++)}return new oo(r,{})}function y7(t){const n={};return Object.entries(t).forEach(([e,r])=>{"string"==typeof r&&(r=[r]),null!==r&&(n[e]=GC(new oo([],{}),0,r))}),n}function kO(t){const n={};return Object.entries(t).forEach(([e,r])=>n[e]=`${r}`),n}function FO(t,n,e){return t==e.path&&Uc(n,e.parameters)}const Ym="imperative";class Wc{constructor(n,e){this.id=n,this.url=e}}class lv extends Wc{constructor(n,e,r="imperative",i=null){super(n,e),this.type=0,this.navigationTrigger=r,this.restoredState=i}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Uh extends Wc{constructor(n,e,r){super(n,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Qm extends Wc{constructor(n,e,r,i){super(n,e),this.reason=r,this.code=i,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class tp extends Wc{constructor(n,e,r,i){super(n,e),this.reason=r,this.code=i,this.type=16}}class cv extends Wc{constructor(n,e,r,i){super(n,e),this.error=r,this.target=i,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class $O extends Wc{constructor(n,e,r,i){super(n,e),this.urlAfterRedirects=r,this.state=i,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class v7 extends Wc{constructor(n,e,r,i){super(n,e),this.urlAfterRedirects=r,this.state=i,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class _7 extends Wc{constructor(n,e,r,i,s){super(n,e),this.urlAfterRedirects=r,this.state=i,this.shouldActivate=s,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class x7 extends Wc{constructor(n,e,r,i){super(n,e),this.urlAfterRedirects=r,this.state=i,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class E7 extends Wc{constructor(n,e,r,i){super(n,e),this.urlAfterRedirects=r,this.state=i,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class C7{constructor(n){this.route=n,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class b7{constructor(n){this.route=n,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class w7{constructor(n){this.snapshot=n,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class I7{constructor(n){this.snapshot=n,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class S7{constructor(n){this.snapshot=n,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class D7{constructor(n){this.snapshot=n,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class BO{constructor(n,e,r){this.routerEvent=n,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class HC{}class jC{constructor(n){this.url=n}}class T7{constructor(){this.outlet=null,this.route=null,this.injector=null,this.children=new qm,this.attachRef=null}}let qm=(()=>{class t{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const i=this.getOrCreateContext(e);i.outlet=r,this.contexts.set(e,i)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new T7,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();class zO{constructor(n){this._root=n}get root(){return this._root.value}parent(n){const e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){const e=KC(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){const e=KC(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){const e=XC(n,this._root);return e.length<2?[]:e[e.length-2].children.map(i=>i.value).filter(i=>i!==n)}pathFromRoot(n){return XC(n,this._root).map(e=>e.value)}}function KC(t,n){if(t===n.value)return n;for(const e of n.children){const r=KC(t,e);if(r)return r}return null}function XC(t,n){if(t===n.value)return[n];for(const e of n.children){const r=XC(t,e);if(r.length)return r.unshift(n),r}return[]}class vh{constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}}function ep(t){const n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}class VO extends zO{constructor(n,e){super(n),this.snapshot=e,ZC(this,n)}toString(){return this.snapshot.toString()}}function UO(t,n){const e=function N7(t,n){const o=new hv([],{},{},"",{},gi,n,null,{});return new GO("",new vh(o,[]))}(0,n),r=new Gr([new Hm("",{})]),i=new Gr({}),s=new Gr({}),o=new Gr({}),a=new Gr(""),u=new np(r,i,o,a,s,gi,n,e.root);return u.snapshot=e.root,new VO(new vh(u,[]),e)}class np{constructor(n,e,r,i,s,o,a,u){this.urlSubject=n,this.paramsSubject=e,this.queryParamsSubject=r,this.fragmentSubject=i,this.dataSubject=s,this.outlet=o,this.component=a,this._futureSnapshot=u,this.title=this.dataSubject?.pipe(Ue(c=>c[Gm]))??Qn(void 0),this.url=n,this.params=e,this.queryParams=r,this.fragment=i,this.data=s}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Ue(n=>qf(n)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Ue(n=>qf(n)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function WO(t,n="emptyOnly"){const e=t.pathFromRoot;let r=0;if("always"!==n)for(r=e.length-1;r>=1;){const i=e[r],s=e[r-1];if(i.routeConfig&&""===i.routeConfig.path)r--;else{if(s.component)break;r--}}return function A7(t){return t.reduce((n,e)=>({params:{...n.params,...e.params},data:{...n.data,...e.data},resolve:{...e.data,...n.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class hv{get title(){return this.data?.[Gm]}constructor(n,e,r,i,s,o,a,u,c){this.url=n,this.params=e,this.queryParams=r,this.fragment=i,this.data=s,this.outlet=o,this.component=a,this.routeConfig=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=qf(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=qf(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class GO extends zO{constructor(n,e){super(e),this.url=n,ZC(this,e)}toString(){return HO(this._root)}}function ZC(t,n){n.value._routerState=t,n.children.forEach(e=>ZC(t,e))}function HO(t){const n=t.children.length>0?` { ${t.children.map(HO).join(", ")} } `:"";return`${t.value}${n}`}function YC(t){if(t.snapshot){const n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,Uc(n.queryParams,e.queryParams)||t.queryParamsSubject.next(e.queryParams),n.fragment!==e.fragment&&t.fragmentSubject.next(e.fragment),Uc(n.params,e.params)||t.paramsSubject.next(e.params),function j9(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!Uc(t[e],n[e]))return!1;return!0}(n.url,e.url)||t.urlSubject.next(e.url),Uc(n.data,e.data)||t.dataSubject.next(e.data)}else t.snapshot=t._futureSnapshot,t.dataSubject.next(t._futureSnapshot.data)}function QC(t,n){const e=Uc(t.params,n.params)&&function Y9(t,n){return Nd(t,n)&&t.every((e,r)=>Uc(e.parameters,n[r].parameters))}(t.url,n.url);return e&&!(!t.parent!=!n.parent)&&(!t.parent||QC(t.parent,n.parent))}let jO=(()=>{class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=gi,this.activateEvents=new Ia,this.deactivateEvents=new Ia,this.attachEvents=new Ia,this.detachEvents=new Ia,this.parentContexts=Mn(qm),this.location=Mn(yc),this.changeDetector=Mn(F0),this.environmentInjector=Mn(Ql),this.inputBinder=Mn(dv,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:i}=e.name;if(r)return;this.isTrackedInParentContexts(i)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(i)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new We(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new We(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new We(4012,!1);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new We(4013,!1);this._activatedRoute=e;const i=this.location,o=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,u=new M7(e,a,i.injector);this.activated=i.createComponent(o,{index:i.length,injector:u,environmentInjector:r??this.environmentInjector}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275dir=or({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[yl]})}return t})();class M7{constructor(n,e,r){this.route=n,this.childContexts=e,this.parent=r}get(n,e){return n===np?this.route:n===qm?this.childContexts:this.parent.get(n,e)}}const dv=new In("");let KO=(()=>{class t{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(e){this.unsubscribeFromRouteData(e),this.subscribeToRouteData(e)}unsubscribeFromRouteData(e){this.outletDataSubscriptions.get(e)?.unsubscribe(),this.outletDataSubscriptions.delete(e)}subscribeToRouteData(e){const{activatedRoute:r}=e,i=LC([r.queryParams,r.params,r.data]).pipe(bo(([s,o,a],u)=>(a={...s,...o,...a},0===u?Qn(a):Promise.resolve(a)))).subscribe(s=>{if(!e.isActivated||!e.activatedComponentRef||e.activatedRoute!==r||null===r.component)return void this.unsubscribeFromRouteData(e);const o=function tj(t){const n=Tr(t);if(!n)return null;const e=new xm(n);return{get selector(){return e.selector},get type(){return e.componentType},get inputs(){return e.inputs},get outputs(){return e.outputs},get ngContentSelectors(){return e.ngContentSelectors},get isStandalone(){return n.standalone},get isSignal(){return n.signals}}}(r.component);if(o)for(const{templateName:a}of o.inputs)e.activatedComponentRef.setInput(a,s[a]);else this.unsubscribeFromRouteData(e)});this.outletDataSubscriptions.set(e,i)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();function Jm(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=n.value;const i=function O7(t,n,e){return n.children.map(r=>{for(const i of e.children)if(t.shouldReuseRoute(r.value,i.value.snapshot))return Jm(t,r,i);return Jm(t,r)})}(t,n,e);return new vh(r,i)}{if(t.shouldAttach(n.value)){const s=t.retrieve(n.value);if(null!==s){const o=s.route;return o.value._futureSnapshot=n.value,o.children=n.children.map(a=>Jm(t,a)),o}}const r=function R7(t){return new np(new Gr(t.url),new Gr(t.params),new Gr(t.queryParams),new Gr(t.fragment),new Gr(t.data),t.outlet,t.component,t)}(n.value),i=n.children.map(s=>Jm(t,s));return new vh(r,i)}}const qC="ngNavigationCancelingError";function XO(t,n){const{redirectTo:e,navigationBehaviorOptions:r}=Ad(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,i=ZO(!1,0,n);return i.url=e,i.navigationBehaviorOptions=r,i}function ZO(t,n,e){const r=new Error("NavigationCancelingError: "+(t||""));return r[qC]=!0,r.cancellationCode=n,e&&(r.url=e),r}function YO(t){return t&&t[qC]}let QO=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275cmp=ca({type:t,selectors:[["ng-component"]],standalone:!0,features:[YA],decls:1,vars:0,template:function(r,i){1&r&&vu(0,"router-outlet")},dependencies:[jO],encapsulation:2})}return t})();function JC(t){const n=t.children&&t.children.map(JC),e=n?{...t,children:n}:{...t};return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==gi&&(e.component=QO),e}function xc(t){return t.outlet||gi}function tg(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let n=t.parent;n;n=n.parent){const e=n.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class U7{constructor(n,e,r,i,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=i,this.inputBindingEnabled=s}activate(n){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),YC(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){const i=ep(e);n.children.forEach(s=>{const o=s.value.outlet;this.deactivateRoutes(s,i[o],r),delete i[o]}),Object.values(i).forEach(s=>{this.deactivateRouteAndItsChildren(s,r)})}deactivateRoutes(n,e,r){const i=n.value,s=e?e.value:null;if(i===s)if(i.component){const o=r.getContext(i.outlet);o&&this.deactivateChildRoutes(n,e,o.children)}else this.deactivateChildRoutes(n,e,r);else s&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){const r=e.getContext(n.value.outlet),i=r&&n.value.component?r.children:e,s=ep(n);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],i);if(r&&r.outlet){const o=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:o,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){const r=e.getContext(n.value.outlet),i=r&&n.value.component?r.children:e,s=ep(n);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],i);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(n,e,r){const i=ep(e);n.children.forEach(s=>{this.activateRoutes(s,i[s.value.outlet],r),this.forwardEvent(new D7(s.value.snapshot))}),n.children.length&&this.forwardEvent(new I7(n.value.snapshot))}activateRoutes(n,e,r){const i=n.value,s=e?e.value:null;if(YC(i),i===s)if(i.component){const o=r.getOrCreateContext(i.outlet);this.activateChildRoutes(n,e,o.children)}else this.activateChildRoutes(n,e,r);else if(i.component){const o=r.getOrCreateContext(i.outlet);if(this.routeReuseStrategy.shouldAttach(i.snapshot)){const a=this.routeReuseStrategy.retrieve(i.snapshot);this.routeReuseStrategy.store(i.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),YC(a.route.value),this.activateChildRoutes(n,null,o.children)}else{const a=tg(i.snapshot);o.attachRef=null,o.route=i,o.injector=a,o.outlet&&o.outlet.activateWith(i,o.injector),this.activateChildRoutes(n,null,o.children)}}else this.activateChildRoutes(n,null,r)}}class qO{constructor(n){this.path=n,this.route=this.path[this.path.length-1]}}class fv{constructor(n,e){this.component=n,this.route=e}}function W7(t,n,e){const r=t._root;return eg(r,n?n._root:null,e,[r.value])}function rp(t,n){const e=Symbol(),r=n.get(t,e);return r===e?"function"!=typeof t||function vr(t){return null!==Vn(t)}(t)?n.get(t):t:r}function eg(t,n,e,r,i={canDeactivateChecks:[],canActivateChecks:[]}){const s=ep(n);return t.children.forEach(o=>{(function H7(t,n,e,r,i={canDeactivateChecks:[],canActivateChecks:[]}){const s=t.value,o=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(o&&s.routeConfig===o.routeConfig){const u=function j7(t,n,e){if("function"==typeof e)return e(t,n);switch(e){case"pathParamsChange":return!Nd(t.url,n.url);case"pathParamsOrQueryParamsChange":return!Nd(t.url,n.url)||!Uc(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!QC(t,n)||!Uc(t.queryParams,n.queryParams);default:return!QC(t,n)}}(o,s,s.routeConfig.runGuardsAndResolvers);u?i.canActivateChecks.push(new qO(r)):(s.data=o.data,s._resolvedData=o._resolvedData),eg(t,n,s.component?a?a.children:null:e,r,i),u&&a&&a.outlet&&a.outlet.isActivated&&i.canDeactivateChecks.push(new fv(a.outlet.component,o))}else o&&ng(n,a,i),i.canActivateChecks.push(new qO(r)),eg(t,null,s.component?a?a.children:null:e,r,i)})(o,s[o.value.outlet],e,r.concat([o.value]),i),delete s[o.value.outlet]}),Object.entries(s).forEach(([o,a])=>ng(a,e.getContext(o),i)),i}function ng(t,n,e){const r=ep(t),i=t.value;Object.entries(r).forEach(([s,o])=>{ng(o,i.component?n?n.children.getContext(s):null:n,e)}),e.canDeactivateChecks.push(new fv(i.component&&n&&n.outlet&&n.outlet.isActivated?n.outlet.component:null,i))}function rg(t){return"function"==typeof t}function JO(t){return t instanceof ev||"EmptyError"===t?.name}const pv=Symbol("INITIAL_VALUE");function ip(){return bo(t=>LC(t.map(n=>n.pipe(Qf(1),function F9(...t){const n=eo(t);return we((e,r)=>{(n?kC(t,e,n):kC(t,e)).subscribe(r)})}(pv)))).pipe(Ue(n=>{for(const e of n)if(!0!==e){if(e===pv)return pv;if(!1===e||e instanceof Jf)return e}return!0}),zh(n=>n!==pv),Qf(1)))}function tR(t){return function yt(...t){return vt(t)}(Vu(n=>{if(Ad(n))throw XO(0,n)}),Ue(n=>!0===n))}class mv{constructor(n){this.segmentGroup=n||null}}class eR{constructor(n){this.urlTree=n}}function sp(t){return Um(new mv(t))}function nR(t){return Um(new eR(t))}class dX{constructor(n,e){this.urlSerializer=n,this.urlTree=e}noMatchError(n){return new We(4002,!1)}lineralizeSegments(n,e){let r=[],i=e.root;for(;;){if(r=r.concat(i.segments),0===i.numberOfChildren)return Qn(r);if(i.numberOfChildren>1||!i.children[gi])return Um(new We(4e3,!1));i=i.children[gi]}}applyRedirectCommands(n,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),n,r)}applyRedirectCreateUrlTree(n,e,r,i){const s=this.createSegmentGroup(n,e.root,r,i);return new Jf(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){const r={};return Object.entries(n).forEach(([i,s])=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[i]=e[a]}else r[i]=s}),r}createSegmentGroup(n,e,r,i){const s=this.createSegments(n,e.segments,r,i);let o={};return Object.entries(e.children).forEach(([a,u])=>{o[a]=this.createSegmentGroup(n,u,r,i)}),new oo(s,o)}createSegments(n,e,r,i){return e.map(s=>s.path.startsWith(":")?this.findPosParam(n,s,i):this.findOrReturn(s,r))}findPosParam(n,e,r){const i=r[e.path.substring(1)];if(!i)throw new We(4001,!1);return i}findOrReturn(n,e){let r=0;for(const i of e){if(i.path===n.path)return e.splice(r),i;r++}return n}}const tb={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function fX(t,n,e,r,i){const s=eb(t,n,e);return s.matched?(r=function k7(t,n){return t.providers&&!t._injector&&(t._injector=ME(t.providers,n,`Route: ${t.path}`)),t._injector??n}(n,r),function lX(t,n,e,r){const i=n.canMatch;return i&&0!==i.length?Qn(i.map(o=>{const a=rp(o,t);return Vh(function q7(t){return t&&rg(t.canMatch)}(a)?a.canMatch(n,e):t.runInContext(()=>a(n,e)))})).pipe(ip(),tR()):Qn(!0)}(r,n,e).pipe(Ue(o=>!0===o?s:{...tb}))):Qn(s)}function eb(t,n,e){if(""===n.path)return"full"===n.pathMatch&&(t.hasChildren()||e.length>0)?{...tb}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const i=(n.matcher||H9)(e,t,n);if(!i)return{...tb};const s={};Object.entries(i.posParams??{}).forEach(([a,u])=>{s[a]=u.path});const o=i.consumed.length>0?{...s,...i.consumed[i.consumed.length-1].parameters}:s;return{matched:!0,consumedSegments:i.consumed,remainingSegments:e.slice(i.consumed.length),parameters:o,positionalParamSegments:i.posParams??{}}}function rR(t,n,e,r){return e.length>0&&function gX(t,n,e){return e.some(r=>gv(t,n,r)&&xc(r)!==gi)}(t,e,r)?{segmentGroup:new oo(n,mX(r,new oo(e,t.children))),slicedSegments:[]}:0===e.length&&function yX(t,n,e){return e.some(r=>gv(t,n,r))}(t,e,r)?{segmentGroup:new oo(t.segments,pX(t,0,e,r,t.children)),slicedSegments:e}:{segmentGroup:new oo(t.segments,t.children),slicedSegments:e}}function pX(t,n,e,r,i){const s={};for(const o of r)if(gv(t,e,o)&&!i[xc(o)]){const a=new oo([],{});s[xc(o)]=a}return{...i,...s}}function mX(t,n){const e={};e[gi]=n;for(const r of t)if(""===r.path&&xc(r)!==gi){const i=new oo([],{});e[xc(r)]=i}return e}function gv(t,n,e){return(!(t.hasChildren()||n.length>0)||"full"!==e.pathMatch)&&""===e.path}class EX{constructor(n,e,r,i,s,o,a){this.injector=n,this.configLoader=e,this.rootComponentType=r,this.config=i,this.urlTree=s,this.paramsInheritanceStrategy=o,this.urlSerializer=a,this.allowRedirects=!0,this.applyRedirects=new dX(this.urlSerializer,this.urlTree)}noMatchError(n){return new We(4002,!1)}recognize(){const n=rR(this.urlTree.root,[],[],this.config).segmentGroup;return this.processSegmentGroup(this.injector,this.config,n,gi).pipe(Td(e=>{if(e instanceof eR)return this.allowRedirects=!1,this.urlTree=e.urlTree,this.match(e.urlTree);throw e instanceof mv?this.noMatchError(e):e}),Ue(e=>{const r=new hv([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},gi,this.rootComponentType,null,{}),i=new vh(r,e),s=new GO("",i),o=function h7(t,n,e=null,r=null){return PO(MO(t),n,e,r)}(r,[],this.urlTree.queryParams,this.urlTree.fragment);return o.queryParams=this.urlTree.queryParams,s.url=this.urlSerializer.serialize(o),this.inheritParamsAndData(s._root),{state:s,tree:o}}))}match(n){return this.processSegmentGroup(this.injector,this.config,n.root,gi).pipe(Td(r=>{throw r instanceof mv?this.noMatchError(r):r}))}inheritParamsAndData(n){const e=n.value,r=WO(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),n.children.forEach(i=>this.inheritParamsAndData(i))}processSegmentGroup(n,e,r,i){return 0===r.segments.length&&r.hasChildren()?this.processChildren(n,e,r):this.processSegment(n,e,r,r.segments,i,!0)}processChildren(n,e,r){const i=[];for(const s of Object.keys(r.children))"primary"===s?i.unshift(s):i.push(s);return ys(i).pipe(Wm(s=>{const o=r.children[s],a=function z7(t,n){const e=t.filter(r=>xc(r)===n);return e.push(...t.filter(r=>xc(r)!==n)),e}(e,s);return this.processSegmentGroup(n,a,o,s)}),function z9(t,n){return we(function B9(t,n,e,r,i){return(s,o)=>{let a=e,u=n,c=0;s.subscribe(Me(o,d=>{const p=c++;u=a?t(u,d,p):(a=!0,d),r&&o.next(u)},i&&(()=>{a&&o.next(u),o.complete()})))}}(t,n,arguments.length>=2,!0))}((s,o)=>(s.push(...o),s)),nv(null),function V9(t,n){const e=arguments.length>=2;return r=>r.pipe(t?zh((i,s)=>t(i,s,r)):Ct,$C(1),e?nv(n):vO(()=>new ev))}(),Rs(s=>{if(null===s)return sp(r);const o=iR(s);return function CX(t){t.sort((n,e)=>n.value.outlet===gi?-1:e.value.outlet===gi?1:n.value.outlet.localeCompare(e.value.outlet))}(o),Qn(o)}))}processSegment(n,e,r,i,s,o){return ys(e).pipe(Wm(a=>this.processSegmentAgainstRoute(a._injector??n,e,a,r,i,s,o).pipe(Td(u=>{if(u instanceof mv)return Qn(null);throw u}))),Dd(a=>!!a),Td(a=>{if(JO(a))return function _X(t,n,e){return 0===n.length&&!t.children[e]}(r,i,s)?Qn([]):sp(r);throw a}))}processSegmentAgainstRoute(n,e,r,i,s,o,a){return function vX(t,n,e,r){return!!(xc(t)===r||r!==gi&&gv(n,e,t))&&("**"===t.path||eb(n,t,e).matched)}(r,i,s,o)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(n,i,r,s,o,a):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(n,i,e,r,s,o):sp(i):sp(i)}expandSegmentAgainstRouteUsingRedirect(n,e,r,i,s,o){return"**"===i.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(n,r,i,o):this.expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,i,s,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(n,e,r,i){const s=this.applyRedirects.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?nR(s):this.applyRedirects.lineralizeSegments(r,s).pipe(Rs(o=>{const a=new oo(o,{});return this.processSegment(n,e,a,o,i,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,i,s,o){const{matched:a,consumedSegments:u,remainingSegments:c,positionalParamSegments:d}=eb(e,i,s);if(!a)return sp(e);const p=this.applyRedirects.applyRedirectCommands(u,i.redirectTo,d);return i.redirectTo.startsWith("/")?nR(p):this.applyRedirects.lineralizeSegments(i,p).pipe(Rs(v=>this.processSegment(n,r,e,v.concat(c),o,!1)))}matchSegmentAgainstRoute(n,e,r,i,s,o){let a;if("**"===r.path){const u=i.length>0?xO(i).parameters:{};a=Qn({snapshot:new hv(i,u,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,sR(r),xc(r),r.component??r._loadedComponent??null,r,oR(r)),consumedSegments:[],remainingSegments:[]}),e.children={}}else a=fX(e,r,i,n).pipe(Ue(({matched:u,consumedSegments:c,remainingSegments:d,parameters:p})=>u?{snapshot:new hv(c,p,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,sR(r),xc(r),r.component??r._loadedComponent??null,r,oR(r)),consumedSegments:c,remainingSegments:d}:null));return a.pipe(bo(u=>null===u?sp(e):this.getChildConfig(n=r._injector??n,r,i).pipe(bo(({routes:c})=>{const d=r._loadedInjector??n,{snapshot:p,consumedSegments:v,remainingSegments:x}=u,{segmentGroup:b,slicedSegments:w}=rR(e,v,x,c);if(0===w.length&&b.hasChildren())return this.processChildren(d,c,b).pipe(Ue(N=>null===N?null:[new vh(p,N)]));if(0===c.length&&0===w.length)return Qn([new vh(p,[])]);const T=xc(r)===s;return this.processSegment(d,c,b,w,T?gi:s,!0).pipe(Ue(N=>[new vh(p,N)]))}))))}getChildConfig(n,e,r){return e.children?Qn({routes:e.children,injector:n}):e.loadChildren?void 0!==e._loadedRoutes?Qn({routes:e._loadedRoutes,injector:e._loadedInjector}):function uX(t,n,e,r){const i=n.canLoad;return void 0===i||0===i.length?Qn(!0):Qn(i.map(o=>{const a=rp(o,t);return Vh(function X7(t){return t&&rg(t.canLoad)}(a)?a.canLoad(n,e):t.runInContext(()=>a(n,e)))})).pipe(ip(),tR())}(n,e,r).pipe(Rs(i=>i?this.configLoader.loadChildren(n,e).pipe(Vu(s=>{e._loadedRoutes=s.routes,e._loadedInjector=s.injector})):function hX(t){return Um(ZO(!1,3))}())):Qn({routes:[],injector:n})}}function bX(t){const n=t.value.routeConfig;return n&&""===n.path}function iR(t){const n=[],e=new Set;for(const r of t){if(!bX(r)){n.push(r);continue}const i=n.find(s=>r.value.routeConfig===s.value.routeConfig);void 0!==i?(i.children.push(...r.children),e.add(i)):n.push(r)}for(const r of e){const i=iR(r.children);n.push(new vh(r.value,i))}return n.filter(r=>!e.has(r))}function sR(t){return t.data||{}}function oR(t){return t.resolve||{}}function aR(t){return"string"==typeof t.title||null===t.title}function nb(t){return bo(n=>{const e=t(n);return e?ys(e).pipe(Ue(()=>n)):Qn(n)})}const op=new In("ROUTES");let rb=(()=>{class t{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=Mn(WM)}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return Qn(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=Vh(e.loadComponent()).pipe(Ue(uR),Vu(s=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=s}),BC(()=>{this.componentLoaders.delete(e)})),i=new yO(r,()=>new ee).pipe(FC());return this.componentLoaders.set(e,i),i}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Qn({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const s=function AX(t,n,e,r){return Vh(t.loadChildren()).pipe(Ue(uR),Rs(i=>i instanceof XA||Array.isArray(i)?Qn(i):ys(n.compileModuleAsync(i))),Ue(i=>{r&&r(t);let s,o,a=!1;return Array.isArray(i)?(o=i,!0):(s=i.create(e).injector,o=s.get(op,[],{optional:!0,self:!0}).flat()),{routes:o.map(JC),injector:s}}))}(r,this.compiler,e,this.onLoadEndListener).pipe(BC(()=>{this.childrenLoaders.delete(r)})),o=new yO(s,()=>new ee).pipe(FC());return this.childrenLoaders.set(r,o),o}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function uR(t){return function MX(t){return t&&"object"==typeof t&&"default"in t}(t)?t.default:t}let yv=(()=>{class t{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.currentTransition=null,this.lastSuccessfulNavigation=null,this.events=new ee,this.transitionAbortSubject=new ee,this.configLoader=Mn(rb),this.environmentInjector=Mn(Ql),this.urlSerializer=Mn(jm),this.rootContexts=Mn(qm),this.inputBindingEnabled=null!==Mn(dv,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>Qn(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=i=>this.events.next(new b7(i)),this.configLoader.onLoadStartListener=i=>this.events.next(new C7(i))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:r})}setupNavigations(e,r,i){return this.transitions=new Gr({id:0,currentUrlTree:r,currentRawUrl:r,currentBrowserUrl:r,extractedUrl:e.urlHandlingStrategy.extract(r),urlAfterRedirects:e.urlHandlingStrategy.extract(r),rawUrl:r,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:Ym,restoredState:null,currentSnapshot:i.snapshot,targetSnapshot:null,currentRouterState:i,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(zh(s=>0!==s.id),Ue(s=>({...s,extractedUrl:e.urlHandlingStrategy.extract(s.rawUrl)})),bo(s=>{this.currentTransition=s;let o=!1,a=!1;return Qn(s).pipe(Vu(u=>{this.currentNavigation={id:u.id,initialUrl:u.rawUrl,extractedUrl:u.extractedUrl,trigger:u.source,extras:u.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),bo(u=>{const c=u.currentBrowserUrl.toString(),d=!e.navigated||u.extractedUrl.toString()!==c||c!==u.currentUrlTree.toString();if(!d&&"reload"!==(u.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const v="";return this.events.next(new tp(u.id,this.urlSerializer.serialize(u.rawUrl),v,0)),u.resolve(null),Vr}if(e.urlHandlingStrategy.shouldProcessUrl(u.rawUrl))return Qn(u).pipe(bo(v=>{const x=this.transitions?.getValue();return this.events.next(new lv(v.id,this.urlSerializer.serialize(v.extractedUrl),v.source,v.restoredState)),x!==this.transitions?.getValue()?Vr:Promise.resolve(v)}),function wX(t,n,e,r,i,s){return Rs(o=>function xX(t,n,e,r,i,s,o="emptyOnly"){return new EX(t,n,e,r,i,o,s).recognize()}(t,n,e,r,o.extractedUrl,i,s).pipe(Ue(({state:a,tree:u})=>({...o,targetSnapshot:a,urlAfterRedirects:u}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),Vu(v=>{s.targetSnapshot=v.targetSnapshot,s.urlAfterRedirects=v.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:v.urlAfterRedirects};const x=new $O(v.id,this.urlSerializer.serialize(v.extractedUrl),this.urlSerializer.serialize(v.urlAfterRedirects),v.targetSnapshot);this.events.next(x)}));if(d&&e.urlHandlingStrategy.shouldProcessUrl(u.currentRawUrl)){const{id:v,extractedUrl:x,source:b,restoredState:w,extras:T}=u,N=new lv(v,this.urlSerializer.serialize(x),b,w);this.events.next(N);const S=UO(0,this.rootComponentType).snapshot;return this.currentTransition=s={...u,targetSnapshot:S,urlAfterRedirects:x,extras:{...T,skipLocationChange:!1,replaceUrl:!1}},Qn(s)}{const v="";return this.events.next(new tp(u.id,this.urlSerializer.serialize(u.extractedUrl),v,1)),u.resolve(null),Vr}}),Vu(u=>{const c=new v7(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}),Ue(u=>(this.currentTransition=s={...u,guards:W7(u.targetSnapshot,u.currentSnapshot,this.rootContexts)},s)),function tX(t,n){return Rs(e=>{const{targetSnapshot:r,currentSnapshot:i,guards:{canActivateChecks:s,canDeactivateChecks:o}}=e;return 0===o.length&&0===s.length?Qn({...e,guardsResult:!0}):function eX(t,n,e,r){return ys(t).pipe(Rs(i=>function aX(t,n,e,r,i){const s=n&&n.routeConfig?n.routeConfig.canDeactivate:null;return s&&0!==s.length?Qn(s.map(a=>{const u=tg(n)??i,c=rp(a,u);return Vh(function Q7(t){return t&&rg(t.canDeactivate)}(c)?c.canDeactivate(t,n,e,r):u.runInContext(()=>c(t,n,e,r))).pipe(Dd())})).pipe(ip()):Qn(!0)}(i.component,i.route,e,n,r)),Dd(i=>!0!==i,!0))}(o,r,i,t).pipe(Rs(a=>a&&function K7(t){return"boolean"==typeof t}(a)?function nX(t,n,e,r){return ys(n).pipe(Wm(i=>kC(function iX(t,n){return null!==t&&n&&n(new w7(t)),Qn(!0)}(i.route.parent,r),function rX(t,n){return null!==t&&n&&n(new S7(t)),Qn(!0)}(i.route,r),function oX(t,n,e){const r=n[n.length-1],s=n.slice(0,n.length-1).reverse().map(o=>function G7(t){const n=t.routeConfig?t.routeConfig.canActivateChild:null;return n&&0!==n.length?{node:t,guards:n}:null}(o)).filter(o=>null!==o).map(o=>gO(()=>Qn(o.guards.map(u=>{const c=tg(o.node)??e,d=rp(u,c);return Vh(function Y7(t){return t&&rg(t.canActivateChild)}(d)?d.canActivateChild(r,t):c.runInContext(()=>d(r,t))).pipe(Dd())})).pipe(ip())));return Qn(s).pipe(ip())}(t,i.path,e),function sX(t,n,e){const r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||0===r.length)return Qn(!0);const i=r.map(s=>gO(()=>{const o=tg(n)??e,a=rp(s,o);return Vh(function Z7(t){return t&&rg(t.canActivate)}(a)?a.canActivate(n,t):o.runInContext(()=>a(n,t))).pipe(Dd())}));return Qn(i).pipe(ip())}(t,i.route,e))),Dd(i=>!0!==i,!0))}(r,s,t,n):Qn(a)),Ue(a=>({...e,guardsResult:a})))})}(this.environmentInjector,u=>this.events.next(u)),Vu(u=>{if(s.guardsResult=u.guardsResult,Ad(u.guardsResult))throw XO(0,u.guardsResult);const c=new _7(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot,!!u.guardsResult);this.events.next(c)}),zh(u=>!!u.guardsResult||(this.cancelNavigationTransition(u,"",3),!1)),nb(u=>{if(u.guards.canActivateChecks.length)return Qn(u).pipe(Vu(c=>{const d=new x7(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(d)}),bo(c=>{let d=!1;return Qn(c).pipe(function IX(t,n){return Rs(e=>{const{targetSnapshot:r,guards:{canActivateChecks:i}}=e;if(!i.length)return Qn(e);let s=0;return ys(i).pipe(Wm(o=>function SX(t,n,e,r){const i=t.routeConfig,s=t._resolve;return void 0!==i?.title&&!aR(i)&&(s[Gm]=i.title),function DX(t,n,e,r){const i=function TX(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}(t);if(0===i.length)return Qn({});const s={};return ys(i).pipe(Rs(o=>function NX(t,n,e,r){const i=tg(n)??r,s=rp(t,i);return Vh(s.resolve?s.resolve(n,e):i.runInContext(()=>s(n,e)))}(t[o],n,e,r).pipe(Dd(),Vu(a=>{s[o]=a}))),$C(1),function U9(t){return Ue(()=>t)}(s),Td(o=>JO(o)?Vr:Um(o)))}(s,t,n,r).pipe(Ue(o=>(t._resolvedData=o,t.data=WO(t,e).resolve,i&&aR(i)&&(t.data[Gm]=i.title),null)))}(o.route,r,t,n)),Vu(()=>s++),$C(1),Rs(o=>s===i.length?Qn(e):Vr))})}(e.paramsInheritanceStrategy,this.environmentInjector),Vu({next:()=>d=!0,complete:()=>{d||this.cancelNavigationTransition(c,"",2)}}))}),Vu(c=>{const d=new E7(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(d)}))}),nb(u=>{const c=d=>{const p=[];d.routeConfig?.loadComponent&&!d.routeConfig._loadedComponent&&p.push(this.configLoader.loadComponent(d.routeConfig).pipe(Vu(v=>{d.component=v}),Ue(()=>{})));for(const v of d.children)p.push(...c(v));return p};return LC(c(u.targetSnapshot.root)).pipe(nv(),Qf(1))}),nb(()=>this.afterPreactivation()),Ue(u=>{const c=function P7(t,n,e){const r=Jm(t,n._root,e?e._root:void 0);return new VO(r,n)}(e.routeReuseStrategy,u.targetSnapshot,u.currentRouterState);return this.currentTransition=s={...u,targetRouterState:c},s}),Vu(()=>{this.events.next(new HC)}),((t,n,e,r)=>Ue(i=>(new U7(n,i.targetRouterState,i.currentRouterState,e,r).activate(t),i)))(this.rootContexts,e.routeReuseStrategy,u=>this.events.next(u),this.inputBindingEnabled),Qf(1),Vu({next:u=>{o=!0,this.lastSuccessfulNavigation=this.currentNavigation,this.events.next(new Uh(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects))),e.titleStrategy?.updateTitle(u.targetRouterState.snapshot),u.resolve(!0)},complete:()=>{o=!0}}),function W9(t){return we((n,e)=>{kr(t).subscribe(Me(e,()=>e.complete(),it)),!e.closed&&n.subscribe(e)})}(this.transitionAbortSubject.pipe(Vu(u=>{throw u}))),BC(()=>{o||a||this.cancelNavigationTransition(s,"",1),this.currentNavigation?.id===s.id&&(this.currentNavigation=null)}),Td(u=>{if(a=!0,YO(u))this.events.next(new Qm(s.id,this.urlSerializer.serialize(s.extractedUrl),u.message,u.cancellationCode)),function L7(t){return YO(t)&&Ad(t.url)}(u)?this.events.next(new jC(u.url)):s.resolve(!1);else{this.events.next(new cv(s.id,this.urlSerializer.serialize(s.extractedUrl),u,s.targetSnapshot??void 0));try{s.resolve(e.errorHandler(u))}catch(c){s.reject(c)}}return Vr}))}))}cancelNavigationTransition(e,r,i){const s=new Qm(e.id,this.urlSerializer.serialize(e.extractedUrl),r,i);this.events.next(s),e.resolve(!1)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function lR(t){return t!==Ym}let cR=(()=>{class t{buildTitle(e){let r,i=e.root;for(;void 0!==i;)r=this.getResolvedTitleForRoute(i)??r,i=i.children.find(s=>s.outlet===gi);return r}getResolvedTitleForRoute(e){return e.data[Gm]}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(PX)},providedIn:"root"})}return t})(),PX=(()=>{class t extends cR{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(uO))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),OX=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(LX)},providedIn:"root"})}return t})();class RX{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}}let LX=(()=>{class t extends RX{static#t=this.\u0275fac=function(){let e;return function(i){return(e||(e=Au(t)))(i||t)}}();static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();const vv=new In("",{providedIn:"root",factory:()=>({})});let kX=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:function(){return Mn(FX)},providedIn:"root"})}return t})(),FX=(()=>{class t{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();var ig=function(t){return t[t.COMPLETE=0]="COMPLETE",t[t.FAILED=1]="FAILED",t[t.REDIRECTING=2]="REDIRECTING",t}(ig||{});function hR(t,n){t.events.pipe(zh(e=>e instanceof Uh||e instanceof Qm||e instanceof cv||e instanceof tp),Ue(e=>e instanceof Uh||e instanceof tp?ig.COMPLETE:e instanceof Qm&&(0===e.code||1===e.code)?ig.REDIRECTING:ig.FAILED),zh(e=>e!==ig.REDIRECTING),Qf(1)).subscribe(()=>{n()})}function $X(t){throw t}function BX(t,n,e){return n.parse("/")}const zX={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},VX={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let rc=(()=>{class t{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){return"computed"!==this.canceledNavigationResolution?this.currentPageId:this.location.getState()?.\u0275routerPageId??this.currentPageId}get events(){return this._events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=Mn(VM),this.isNgZoneEnabled=!1,this._events=new ee,this.options=Mn(vv,{optional:!0})||{},this.pendingTasks=Mn(UM),this.errorHandler=this.options.errorHandler||$X,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||BX,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=Mn(kX),this.routeReuseStrategy=Mn(OX),this.titleStrategy=Mn(cR),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=Mn(op,{optional:!0})?.flat()??[],this.navigationTransitions=Mn(yv),this.urlSerializer=Mn(jm),this.location=Mn(cC),this.componentInputBindingEnabled=!!Mn(dv,{optional:!0}),this.eventsSubscription=new R,this.isNgZoneEnabled=Mn(Oo)instanceof Oo&&Oo.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new Jf,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=UO(0,null),this.navigationTransitions.setupNavigations(this,this.currentUrlTree,this.routerState).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)}),this.subscribeToNavigationEvents()}subscribeToNavigationEvents(){const e=this.navigationTransitions.events.subscribe(r=>{try{const{currentTransition:i}=this.navigationTransitions;if(null===i)return void(dR(r)&&this._events.next(r));if(r instanceof lv)lR(i.source)&&(this.browserUrlTree=i.extractedUrl);else if(r instanceof tp)this.rawUrlTree=i.rawUrl;else if(r instanceof $O){if("eager"===this.urlUpdateStrategy){if(!i.extras.skipLocationChange){const s=this.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl);this.setBrowserUrl(s,i)}this.browserUrlTree=i.urlAfterRedirects}}else if(r instanceof HC)this.currentUrlTree=i.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl),this.routerState=i.targetRouterState,"deferred"===this.urlUpdateStrategy&&(i.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,i),this.browserUrlTree=i.urlAfterRedirects);else if(r instanceof Qm)0!==r.code&&1!==r.code&&(this.navigated=!0),(3===r.code||2===r.code)&&this.restoreHistory(i);else if(r instanceof jC){const s=this.urlHandlingStrategy.merge(r.url,i.currentRawUrl),o={skipLocationChange:i.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||lR(i.source)};this.scheduleNavigation(s,Ym,null,o,{resolve:i.resolve,reject:i.reject,promise:i.promise})}r instanceof cv&&this.restoreHistory(i,!0),r instanceof Uh&&(this.navigated=!0),dR(r)&&this._events.next(r)}catch(i){this.navigationTransitions.transitionAbortSubject.next(i)}});this.eventsSubscription.add(e)}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),Ym,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,r,e.state)},0)}))}navigateToSyncWithBrowser(e,r,i){const s={replaceUrl:!0},o=i?.navigationId?i:null;if(i){const u={...i};delete u.navigationId,delete u.\u0275routerPageId,0!==Object.keys(u).length&&(s.state=u)}const a=this.parseUrl(e);this.scheduleNavigation(a,r,o,s)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(e){this.config=e.map(JC),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(e,r={}){const{relativeTo:i,queryParams:s,fragment:o,queryParamsHandling:a,preserveFragment:u}=r,c=u?this.currentUrlTree.fragment:o;let p,d=null;switch(a){case"merge":d={...this.currentUrlTree.queryParams,...s};break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=s||null}null!==d&&(d=this.removeEmptyProps(d));try{p=MO(i?i.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof e[0]||!e[0].startsWith("/"))&&(e=[]),p=this.currentUrlTree.root}return PO(p,e,d,c??null)}navigateByUrl(e,r={skipLocationChange:!1}){const i=Ad(e)?e:this.parseUrl(e),s=this.urlHandlingStrategy.merge(i,this.rawUrlTree);return this.scheduleNavigation(s,Ym,null,r)}navigate(e,r={skipLocationChange:!1}){return function UX(t){for(let n=0;n<t.length;n++)if(null==t[n])throw new We(4008,!1)}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(i){r=this.malformedUriErrorHandler(i,this.urlSerializer,e)}return r}isActive(e,r){let i;if(i=!0===r?{...zX}:!1===r?{...VX}:r,Ad(e))return CO(this.currentUrlTree,e,i);const s=this.parseUrl(e);return CO(this.currentUrlTree,s,i)}removeEmptyProps(e){return Object.keys(e).reduce((r,i)=>{const s=e[i];return null!=s&&(r[i]=s),r},{})}scheduleNavigation(e,r,i,s,o){if(this.disposed)return Promise.resolve(!1);let a,u,c;o?(a=o.resolve,u=o.reject,c=o.promise):c=new Promise((p,v)=>{a=p,u=v});const d=this.pendingTasks.add();return hR(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(d))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:i,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,currentBrowserUrl:this.browserUrlTree,rawUrl:e,extras:s,resolve:a,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(p=>Promise.reject(p))}setBrowserUrl(e,r){const i=this.urlSerializer.serialize(e);if(this.location.isCurrentPathEqualTo(i)||r.extras.replaceUrl){const o={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(i,"",o)}else{const s={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId+1)};this.location.go(i,"",s)}}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-this.browserPageId;0!==s?this.location.historyGo(s):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function dR(t){return!(t instanceof HC||t instanceof jC)}class fR{}let HX=(()=>{class t{constructor(e,r,i,s,o){this.router=e,this.injector=i,this.preloadingStrategy=s,this.loader=o}setUpPreloading(){this.subscription=this.router.events.pipe(zh(e=>e instanceof Uh),Wm(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const i=[];for(const s of r){s.providers&&!s._injector&&(s._injector=ME(s.providers,e,`Route: ${s.path}`));const o=s._injector??e,a=s._loadedInjector??o;(s.loadChildren&&!s._loadedRoutes&&void 0===s.canLoad||s.loadComponent&&!s._loadedComponent)&&i.push(this.preloadConfig(o,s)),(s.children||s._loadedRoutes)&&i.push(this.processRoutes(a,s.children??s._loadedRoutes))}return ys(i).pipe(ti())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let i;i=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):Qn(null);const s=i.pipe(Rs(o=>null===o?Qn(void 0):(r._loadedRoutes=o.routes,r._loadedInjector=o.injector,this.processRoutes(o.injector??e,o.routes))));return r.loadComponent&&!r._loadedComponent?ys([s,this.loader.loadComponent(r)]).pipe(ti()):s})}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(rc),Hn(WM),Hn(Ql),Hn(fR),Hn(rb))};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();const sb=new In("");let pR=(()=>{class t{constructor(e,r,i,s,o={}){this.urlSerializer=e,this.transitions=r,this.viewportScroller=i,this.zone=s,this.options=o,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},o.scrollPositionRestoration=o.scrollPositionRestoration||"disabled",o.anchorScrolling=o.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof lv?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Uh?(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment)):e instanceof tp&&0===e.code&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof BO&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new BO(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}static#t=this.\u0275fac=function(r){!function LT(){throw new Error("invalid")}()};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac})}return t})();function _h(t,n){return{\u0275kind:t,\u0275providers:n}}function gR(){const t=Mn(Ml);return n=>{const e=t.get(Xf);if(n!==e.components[0])return;const r=t.get(rc),i=t.get(yR);1===t.get(ob)&&r.initialNavigation(),t.get(vR,null,xr.Optional)?.setUpPreloading(),t.get(sb,null,xr.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),i.closed||(i.next(),i.complete(),i.unsubscribe())}}const yR=new In("",{factory:()=>new ee}),ob=new In("",{providedIn:"root",factory:()=>1}),vR=new In("");function ZX(t){return _h(0,[{provide:vR,useExisting:HX},{provide:fR,useExisting:t}])}const _R=new In("ROUTER_FORROOT_GUARD"),QX=[cC,{provide:jm,useClass:zC},rc,qm,{provide:np,useFactory:function mR(t){return t.routerState.root},deps:[rc]},rb,[]];function qX(){return new YM("Router",rc)}let xR=(()=>{class t{constructor(e){}static forRoot(e,r){return{ngModule:t,providers:[QX,[],{provide:op,multi:!0,useValue:e},{provide:_R,useFactory:nZ,deps:[[rc,new ky,new Fy]]},{provide:vv,useValue:r||{}},r?.useHash?{provide:Sd,useClass:sj}:{provide:Sd,useClass:SP},{provide:sb,useFactory:()=>{const t=Mn(SK),n=Mn(Oo),e=Mn(vv),r=Mn(yv),i=Mn(jm);return e.scrollOffset&&t.setOffset(e.scrollOffset),new pR(i,r,t,n,e)}},r?.preloadingStrategy?ZX(r.preloadingStrategy).\u0275providers:[],{provide:YM,multi:!0,useFactory:qX},r?.initialNavigation?rZ(r):[],r?.bindToComponentInputs?_h(8,[KO,{provide:dv,useExisting:KO}]).\u0275providers:[],[{provide:ER,useFactory:gR},{provide:tC,multi:!0,useExisting:ER}]]}}static forChild(e){return{ngModule:t,providers:[{provide:op,multi:!0,useValue:e}]}}static#t=this.\u0275fac=function(r){return new(r||t)(Hn(_R,8))};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({})}return t})();function nZ(t){return"guarded"}function rZ(t){return["disabled"===t.initialNavigation?_h(3,[{provide:jE,multi:!0,useFactory:()=>{const n=Mn(rc);return()=>{n.setUpLocationChangeListener()}}},{provide:ob,useValue:2}]).\u0275providers:[],"enabledBlocking"===t.initialNavigation?_h(2,[{provide:ob,useValue:0},{provide:jE,multi:!0,deps:[Ml],useFactory:n=>{const e=n.get(rj,Promise.resolve());return()=>e.then(()=>new Promise(r=>{const i=n.get(rc),s=n.get(yR);hR(i,()=>{r(!0)}),n.get(yv).afterPreactivation=()=>(r(!0),s.closed?Qn(void 0):s),i.initialNavigation()}))}}]).\u0275providers:[]]}const ER=new In(""),sZ=[];let oZ=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({imports:[xR.forRoot(sZ),xR]})}return t})();var Uu=y(8433),Wu=(y(3727),6371008.8),CR={centimeters:100*Wu,centimetres:100*Wu,degrees:Wu/111325,feet:3.28084*Wu,inches:39.37*Wu,kilometers:Wu/1e3,kilometres:Wu/1e3,meters:Wu,metres:Wu,miles:Wu/1609.344,millimeters:1e3*Wu,millimetres:1e3*Wu,nauticalmiles:Wu/1852,radians:1,yards:1.0936*Wu};function Gc(t,n,e){void 0===e&&(e={});var r={type:"Feature"};return(0===e.id||e.id)&&(r.id=e.id),e.bbox&&(r.bbox=e.bbox),r.properties=n||{},r.geometry=t,r}function ap(t,n,e){if(void 0===e&&(e={}),!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!ub(t[0])||!ub(t[1]))throw new Error("coordinates must contain numbers");return Gc({type:"Point",coordinates:t},n,e)}function sg(t,n,e){void 0===e&&(e={});for(var r=0,i=t;r<i.length;r++){var s=i[r];if(s.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var o=0;o<s[s.length-1].length;o++)if(s[s.length-1][o]!==s[0][o])throw new Error("First and last Position are not equivalent.")}return Gc({type:"Polygon",coordinates:t},n,e)}function _v(t,n,e){if(void 0===e&&(e={}),t.length<2)throw new Error("coordinates must be an array of two or more positions");return Gc({type:"LineString",coordinates:t},n,e)}function up(t,n){void 0===n&&(n={});var e={type:"FeatureCollection"};return n.id&&(e.id=n.id),n.bbox&&(e.bbox=n.bbox),e.features=t,e}function ub(t){return!isNaN(t)&&null!==t&&!Array.isArray(t)}function og(t,n,e){if(null!==t)for(var r,i,s,o,a,u,c,v,d=0,p=0,x=t.type,b="FeatureCollection"===x,w="Feature"===x,T=b?t.features.length:1,N=0;N<T;N++){a=(v=!!(c=b?t.features[N].geometry:w?t.geometry:t)&&"GeometryCollection"===c.type)?c.geometries.length:1;for(var S=0;S<a;S++){var U=0,J=0;if(null!==(o=v?c.geometries[S]:c)){u=o.coordinates;var ht=o.type;switch(d=!e||"Polygon"!==ht&&"MultiPolygon"!==ht?0:1,ht){case null:break;case"Point":if(!1===n(u,p,N,U,J))return!1;p++,U++;break;case"LineString":case"MultiPoint":for(r=0;r<u.length;r++){if(!1===n(u[r],p,N,U,J))return!1;p++,"MultiPoint"===ht&&U++}"LineString"===ht&&U++;break;case"Polygon":case"MultiLineString":for(r=0;r<u.length;r++){for(i=0;i<u[r].length-d;i++){if(!1===n(u[r][i],p,N,U,J))return!1;p++}"MultiLineString"===ht&&U++,"Polygon"===ht&&J++}"Polygon"===ht&&U++;break;case"MultiPolygon":for(r=0;r<u.length;r++){for(J=0,i=0;i<u[r].length;i++){for(s=0;s<u[r][i].length-d;s++){if(!1===n(u[r][i][s],p,N,U,J))return!1;p++}J++}U++}break;case"GeometryCollection":for(r=0;r<o.geometries.length;r++)if(!1===og(o.geometries[r],n,e))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function lb(t,n){if("Feature"===t.type)n(t,0);else if("FeatureCollection"===t.type)for(var e=0;e<t.features.length&&!1!==n(t.features[e],e);e++);}function xv(t,n){var e,r,i,s,o,a,u,c,d,p,v=0,x="FeatureCollection"===t.type,b="Feature"===t.type,w=x?t.features.length:1;for(e=0;e<w;e++){for(c=x?t.features[e].properties:b?t.properties:{},d=x?t.features[e].bbox:b?t.bbox:void 0,p=x?t.features[e].id:b?t.id:void 0,o=(u=!!(a=x?t.features[e].geometry:b?t.geometry:t)&&"GeometryCollection"===a.type)?a.geometries.length:1,i=0;i<o;i++)if(null!==(s=u?a.geometries[i]:a))switch(s.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===n(s,v,c,d,p))return!1;break;case"GeometryCollection":for(r=0;r<s.geometries.length;r++)if(!1===n(s.geometries[r],v,c,d,p))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===n(null,v,c,d,p))return!1;v++}}function cb(t){var n=[1/0,1/0,-1/0,-1/0];return og(t,function(e){n[0]>e[0]&&(n[0]=e[0]),n[1]>e[1]&&(n[1]=e[1]),n[2]<e[0]&&(n[2]=e[0]),n[3]<e[1]&&(n[3]=e[1])}),n}cb.default=cb;const SR=cb;function db(t,n,e){if(void 0===e&&(e={}),!t)throw new Error("point is required");if(!n)throw new Error("polygon is required");var r=function mZ(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if("Feature"===t.type&&null!==t.geometry&&"Point"===t.geometry.type)return t.geometry.coordinates;if("Point"===t.type)return t.coordinates}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return t;throw new Error("coord must be GeoJSON Point or an Array of numbers")}(t),i=function vZ(t){return"Feature"===t.type?t.geometry:t}(n),s=i.type,o=n.bbox,a=i.coordinates;if(o&&!1===function TZ(t,n){return n[0]<=t[0]&&n[1]<=t[1]&&n[2]>=t[0]&&n[3]>=t[1]}(r,o))return!1;"Polygon"===s&&(a=[a]);for(var u=!1,c=0;c<a.length&&!u;c++)if(AR(r,a[c][0],e.ignoreBoundary)){for(var d=!1,p=1;p<a[c].length&&!d;)AR(r,a[c][p],!e.ignoreBoundary)&&(d=!0),p++;d||(u=!0)}return u}function AR(t,n,e){var r=!1;n[0][0]===n[n.length-1][0]&&n[0][1]===n[n.length-1][1]&&(n=n.slice(0,n.length-1));for(var i=0,s=n.length-1;i<n.length;s=i++){var o=n[i][0],a=n[i][1],u=n[s][0],c=n[s][1];if(t[1]*(o-u)+a*(u-t[0])+c*(t[0]-o)==0&&(o-t[0])*(u-t[0])<=0&&(a-t[1])*(c-t[1])<=0)return!e;a>t[1]!=c>t[1]&&t[0]<(u-o)*(t[1]-a)/(c-a)+o&&(r=!r)}return r}y(4772),y(3664);var PR=new ArrayBuffer(16);new Float64Array(PR),new Uint32Array(PR),y(7861),function(){function t(n){this.points=n.points||[],this.duration=n.duration||1e4,this.sharpness=n.sharpness||.85,this.centers=[],this.controls=[],this.stepLength=n.stepLength||60,this.length=this.points.length,this.delay=0;for(var e=0;e<this.length;e++)this.points[e].z=this.points[e].z||0;for(e=0;e<this.length-1;e++){var r=this.points[e],i=this.points[e+1];this.centers.push({x:(r.x+i.x)/2,y:(r.y+i.y)/2,z:(r.z+i.z)/2})}for(this.controls.push([this.points[0],this.points[0]]),e=0;e<this.centers.length-1;e++){var s=this.points[e+1].x-(this.centers[e].x+this.centers[e+1].x)/2,o=this.points[e+1].y-(this.centers[e].y+this.centers[e+1].y)/2,a=this.points[e+1].z-(this.centers[e].y+this.centers[e+1].z)/2;this.controls.push([{x:(1-this.sharpness)*this.points[e+1].x+this.sharpness*(this.centers[e].x+s),y:(1-this.sharpness)*this.points[e+1].y+this.sharpness*(this.centers[e].y+o),z:(1-this.sharpness)*this.points[e+1].z+this.sharpness*(this.centers[e].z+a)},{x:(1-this.sharpness)*this.points[e+1].x+this.sharpness*(this.centers[e+1].x+s),y:(1-this.sharpness)*this.points[e+1].y+this.sharpness*(this.centers[e+1].y+o),z:(1-this.sharpness)*this.points[e+1].z+this.sharpness*(this.centers[e+1].z+a)}])}return this.controls.push([this.points[this.length-1],this.points[this.length-1]]),this.steps=this.cacheSteps(this.stepLength),this}t.prototype.cacheSteps=function(n){var e=[],r=this.pos(0);e.push(0);for(var i=0;i<this.duration;i+=10){var s=this.pos(i);Math.sqrt((s.x-r.x)*(s.x-r.x)+(s.y-r.y)*(s.y-r.y)+(s.z-r.z)*(s.z-r.z))>n&&(e.push(i),r=s)}return e},t.prototype.vector=function(n){var e=this.pos(n+10),r=this.pos(n-10);return{angle:180*Math.atan2(e.y-r.y,e.x-r.x)/3.14,speed:Math.sqrt((r.x-e.x)*(r.x-e.x)+(r.y-e.y)*(r.y-e.y)+(r.z-e.z)*(r.z-e.z))}},t.prototype.pos=function(n){var e=n-this.delay;e<0&&(e=0),e>this.duration&&(e=this.duration-1);var r=e/this.duration;if(r>=1)return this.points[this.length-1];var i=Math.floor((this.points.length-1)*r);return function GZ(t,n,e,r,i){var s=function HZ(t){var n=t*t;return[n*t,3*n*(1-t),3*t*(1-t)*(1-t),(1-t)*(1-t)*(1-t)]}(t);return{x:i.x*s[0]+r.x*s[1]+e.x*s[2]+n.x*s[3],y:i.y*s[0]+r.y*s[1]+e.y*s[2]+n.y*s[3],z:i.z*s[0]+r.z*s[1]+e.z*s[2]+n.z*s[3]}}((this.length-1)*r-i,this.points[i],this.controls[i][1],this.controls[i+1][0],this.points[i+1])}}();y(9145),y(5665);var UR=6378137;function vb(t){return function dZ(t,n,e){var r=e;return xv(t,function(i,s,o,a,u){r=0===s&&void 0===e?i:n(r,i,s,o,a,u)}),r}(t,function(n,e){return n+function cY(t){var e,n=0;switch(t.type){case"Polygon":return WR(t.coordinates);case"MultiPolygon":for(e=0;e<t.coordinates.length;e++)n+=WR(t.coordinates[e]);return n;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0}return 0}(e)},0)}function WR(t){var n=0;if(t&&t.length>0){n+=Math.abs(GR(t[0]));for(var e=1;e<t.length;e++)n-=Math.abs(GR(t[e]))}return n}function GR(t){var n,e,i,s,o,a,u=0,c=t.length;if(c>2){for(a=0;a<c;a++)a===c-2?(i=c-2,s=c-1,o=0):a===c-1?(i=c-1,s=0,o=1):(i=a,s=a+1,o=a+2),n=t[i],e=t[s],u+=(_b(t[o][0])-_b(n[0]))*Math.sin(_b(e[1]));u=u*UR*UR/2}return u}function _b(t){return t*Math.PI/180}var ZR=Math.PI/180,YR=180/Math.PI,lg=function(t,n){this.lon=t,this.lat=n,this.x=ZR*t,this.y=ZR*n};lg.prototype.view=function(){return String(this.lon).slice(0,4)+","+String(this.lat).slice(0,4)},lg.prototype.antipode=function(){return new lg(this.lon<0?180+this.lon:-1*(180-this.lon),-1*this.lat)};var QR=function(){this.coords=[],this.length=0};QR.prototype.move_to=function(t){this.length++,this.coords.push(t)};var xb=function(t){this.properties=t||{},this.geometries=[]};xb.prototype.json=function(){if(this.geometries.length<=0)return{geometry:{type:"LineString",coordinates:null},type:"Feature",properties:this.properties};if(1===this.geometries.length)return{geometry:{type:"LineString",coordinates:this.geometries[0].coords},type:"Feature",properties:this.properties};for(var t=[],n=0;n<this.geometries.length;n++)t.push(this.geometries[n].coords);return{geometry:{type:"MultiLineString",coordinates:t},type:"Feature",properties:this.properties}},xb.prototype.wkt=function(){for(var t="",n="LINESTRING(",e=function(s){n+=s[0]+" "+s[1]+","},r=0;r<this.geometries.length;r++){if(0===this.geometries[r].coords.length)return"LINESTRING(empty)";this.geometries[r].coords.forEach(e),t+=n.substring(0,n.length-1)+")"}return t};var Eb=function(t,n,e){if(!t||void 0===t.x||void 0===t.y)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");if(!n||void 0===n.x||void 0===n.y)throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");this.start=new lg(t.x,t.y),this.end=new lg(n.x,n.y),this.properties=e||{};var r=this.start.x-this.end.x,s=Math.pow(Math.sin((this.start.y-this.end.y)/2),2)+Math.cos(this.start.y)*Math.cos(this.end.y)*Math.pow(Math.sin(r/2),2);if(this.g=2*Math.asin(Math.sqrt(s)),this.g===Math.PI)throw new Error("it appears "+t.view()+" and "+n.view()+" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");if(isNaN(this.g))throw new Error("could not calculate great circle between "+t+" and "+n)};Eb.prototype.interpolate=function(t){var n=Math.sin((1-t)*this.g)/Math.sin(this.g),e=Math.sin(t*this.g)/Math.sin(this.g),r=n*Math.cos(this.start.y)*Math.cos(this.start.x)+e*Math.cos(this.end.y)*Math.cos(this.end.x),i=n*Math.cos(this.start.y)*Math.sin(this.start.x)+e*Math.cos(this.end.y)*Math.sin(this.end.x),s=n*Math.sin(this.start.y)+e*Math.sin(this.end.y),o=YR*Math.atan2(s,Math.sqrt(Math.pow(r,2)+Math.pow(i,2)));return[YR*Math.atan2(i,r),o]},Eb.prototype.Arc=function(t,n){var e=[];if(!t||t<=2)e.push([this.start.lon,this.start.lat]),e.push([this.end.lon,this.end.lat]);else for(var r=1/(t-1),i=0;i<t;++i){var o=this.interpolate(r*i);e.push(o)}for(var a=!1,u=0,c=n&&n.offset?n.offset:10,d=180-c,p=-180+c,v=360-c,x=1;x<e.length;++x){var b=e[x-1][0],w=e[x][0],T=Math.abs(w-b);T>v&&(w>d&&b<p||b>d&&w<p)?a=!0:T>u&&(u=T)}var N=[];if(a&&u<c){var S=[];N.push(S);for(var U=0;U<e.length;++U){var J=parseFloat(e[U][0]);if(U>0&&Math.abs(J-e[U-1][0])>v){var ht=parseFloat(e[U-1][0]),Tt=parseFloat(e[U-1][1]),Pt=parseFloat(e[U][0]),zt=parseFloat(e[U][1]);if(ht>-180&&ht<p&&180===Pt&&U+1<e.length&&e[U-1][0]>-180&&e[U-1][0]<p){S.push([-180,e[U][1]]),U++,S.push([e[U][0],e[U][1]]);continue}if(ht>d&&ht<180&&-180===Pt&&U+1<e.length&&e[U-1][0]>d&&e[U-1][0]<180){S.push([180,e[U][1]]),U++,S.push([e[U][0],e[U][1]]);continue}if(ht<p&&Pt>d){var Ot=ht;ht=Pt,Pt=Ot;var le=Tt;Tt=zt,zt=le}if(ht>d&&Pt<p&&(Pt+=360),ht<=180&&Pt>=180&&ht<Pt){var ge=(180-ht)/(Pt-ht),Ae=ge*zt+(1-ge)*Tt;S.push([e[U-1][0]>d?180:-180,Ae]),(S=[]).push([e[U-1][0]>d?-180:180,Ae]),N.push(S)}else N.push(S=[]);S.push([J,e[U][1]])}else S.push([e[U][0],e[U][1]])}}else{var Re=[];N.push(Re);for(var ve=0;ve<e.length;++ve)Re.push([e[ve][0],e[ve][1]])}for(var Ne=new xb(this.properties),Se=0;Se<N.length;++Se){var Ke=new QR;Ne.geometries.push(Ke);for(var Le=N[Se],Be=0;Be<Le.length;++Be)Ke.move_to(Le[Be])}return Ne},y(3970);var wi=[],Ii=[],Si=[],Di=[],Ti=[],Ni=[],Ai=[],Mi=[],Pi=[],Oi=[],Ri=[],Li=[],ki=[],Fi=[],$i=[],Bi=[],zi=[],Vi=[],Ui=[],Wi=[],Gi=[],Hi=[],ji=[],Ki=[];Ai[85]=Oi[85]=-1,Mi[85]=Ri[85]=0,Pi[85]=Li[85]=1,Ui[85]=Hi[85]=1,Wi[85]=ji[85]=0,Gi[85]=Ki[85]=1,wi[85]=Di[85]=0,Ii[85]=Ti[85]=-1,Si[85]=$i[85]=0,Bi[85]=ki[85]=0,zi[85]=Fi[85]=1,Ni[85]=Vi[85]=1,Hi[1]=Hi[169]=0,ji[1]=ji[169]=-1,Ki[1]=Ki[169]=0,ki[1]=ki[169]=-1,Fi[1]=Fi[169]=0,$i[1]=$i[169]=0,Oi[4]=Oi[166]=0,Ri[4]=Ri[166]=-1,Li[4]=Li[166]=1,Bi[4]=Bi[166]=1,zi[4]=zi[166]=0,Vi[4]=Vi[166]=0,Ai[16]=Ai[154]=0,Mi[16]=Mi[154]=1,Pi[16]=Pi[154]=1,Di[16]=Di[154]=1,Ti[16]=Ti[154]=0,Ni[16]=Ni[154]=1,Ui[64]=Ui[106]=0,Wi[64]=Wi[106]=1,Gi[64]=Gi[106]=0,wi[64]=wi[106]=-1,Ii[64]=Ii[106]=0,Si[64]=Si[106]=1,Ui[2]=Ui[168]=0,Wi[2]=Wi[168]=-1,Gi[2]=Gi[168]=1,Hi[2]=Hi[168]=0,ji[2]=ji[168]=-1,Ki[2]=Ki[168]=0,ki[2]=ki[168]=-1,Fi[2]=Fi[168]=0,$i[2]=$i[168]=0,Bi[2]=Bi[168]=-1,zi[2]=zi[168]=0,Vi[2]=Vi[168]=1,Ai[8]=Ai[162]=0,Mi[8]=Mi[162]=-1,Pi[8]=Pi[162]=0,Oi[8]=Oi[162]=0,Ri[8]=Ri[162]=-1,Li[8]=Li[162]=1,ki[8]=ki[162]=1,Fi[8]=Fi[162]=0,$i[8]=$i[162]=1,Bi[8]=Bi[162]=1,zi[8]=zi[162]=0,Vi[8]=Vi[162]=0,Ai[32]=Ai[138]=0,Mi[32]=Mi[138]=1,Pi[32]=Pi[138]=1,Oi[32]=Oi[138]=0,Ri[32]=Ri[138]=1,Li[32]=Li[138]=0,wi[32]=wi[138]=1,Ii[32]=Ii[138]=0,Si[32]=Si[138]=0,Di[32]=Di[138]=1,Ti[32]=Ti[138]=0,Ni[32]=Ni[138]=1,Hi[128]=Hi[42]=0,ji[128]=ji[42]=1,Ki[128]=Ki[42]=1,Ui[128]=Ui[42]=0,Wi[128]=Wi[42]=1,Gi[128]=Gi[42]=0,wi[128]=wi[42]=-1,Ii[128]=Ii[42]=0,Si[128]=Si[42]=1,Di[128]=Di[42]=-1,Ti[128]=Ti[42]=0,Ni[128]=Ni[42]=0,Oi[5]=Oi[165]=-1,Ri[5]=Ri[165]=0,Li[5]=Li[165]=0,Hi[5]=Hi[165]=1,ji[5]=ji[165]=0,Ki[5]=Ki[165]=0,Bi[20]=Bi[150]=0,zi[20]=zi[150]=1,Vi[20]=Vi[150]=1,Di[20]=Di[150]=0,Ti[20]=Ti[150]=-1,Ni[20]=Ni[150]=1,Ai[80]=Ai[90]=-1,Mi[80]=Mi[90]=0,Pi[80]=Pi[90]=1,Ui[80]=Ui[90]=1,Wi[80]=Wi[90]=0,Gi[80]=Gi[90]=1,ki[65]=ki[105]=0,Fi[65]=Fi[105]=1,$i[65]=$i[105]=0,wi[65]=wi[105]=0,Ii[65]=Ii[105]=-1,Si[65]=Si[105]=0,Ai[160]=Ai[10]=-1,Mi[160]=Mi[10]=0,Pi[160]=Pi[10]=1,Oi[160]=Oi[10]=-1,Ri[160]=Ri[10]=0,Li[160]=Li[10]=0,Hi[160]=Hi[10]=1,ji[160]=ji[10]=0,Ki[160]=Ki[10]=0,Ui[160]=Ui[10]=1,Wi[160]=Wi[10]=0,Gi[160]=Gi[10]=1,Bi[130]=Bi[40]=0,zi[130]=zi[40]=1,Vi[130]=Vi[40]=1,ki[130]=ki[40]=0,Fi[130]=Fi[40]=1,$i[130]=$i[40]=0,wi[130]=wi[40]=0,Ii[130]=Ii[40]=-1,Si[130]=Si[40]=0,Di[130]=Di[40]=0,Ti[130]=Ti[40]=-1,Ni[130]=Ni[40]=1,Oi[37]=Oi[133]=0,Ri[37]=Ri[133]=1,Li[37]=Li[133]=1,Hi[37]=Hi[133]=0,ji[37]=ji[133]=1,Ki[37]=Ki[133]=0,wi[37]=wi[133]=-1,Ii[37]=Ii[133]=0,Si[37]=Si[133]=0,Di[37]=Di[133]=1,Ti[37]=Ti[133]=0,Ni[37]=Ni[133]=0,Bi[148]=Bi[22]=-1,zi[148]=zi[22]=0,Vi[148]=Vi[22]=0,Hi[148]=Hi[22]=0,ji[148]=ji[22]=-1,Ki[148]=Ki[22]=1,Ui[148]=Ui[22]=0,Wi[148]=Wi[22]=1,Gi[148]=Gi[22]=1,Di[148]=Di[22]=-1,Ti[148]=Ti[22]=0,Ni[148]=Ni[22]=1,Ai[82]=Ai[88]=0,Mi[82]=Mi[88]=-1,Pi[82]=Pi[88]=1,Bi[82]=Bi[88]=1,zi[82]=zi[88]=0,Vi[82]=Vi[88]=1,ki[82]=ki[88]=-1,Fi[82]=Fi[88]=0,$i[82]=$i[88]=1,Ui[82]=Ui[88]=0,Wi[82]=Wi[88]=-1,Gi[82]=Gi[88]=0,Ai[73]=Ai[97]=0,Mi[73]=Mi[97]=1,Pi[73]=Pi[97]=0,Oi[73]=Oi[97]=0,Ri[73]=Ri[97]=-1,Li[73]=Li[97]=0,ki[73]=ki[97]=1,Fi[73]=Fi[97]=0,$i[73]=$i[97]=0,wi[73]=wi[97]=1,Ii[73]=Ii[97]=0,Si[73]=Si[97]=1,Ai[145]=Ai[25]=0,Mi[145]=Mi[25]=-1,Pi[145]=Pi[25]=0,ki[145]=ki[25]=1,Fi[145]=Fi[25]=0,$i[145]=$i[25]=1,Hi[145]=Hi[25]=0,ji[145]=ji[25]=1,Ki[145]=Ki[25]=1,Di[145]=Di[25]=-1,Ti[145]=Ti[25]=0,Ni[145]=Ni[25]=0,Oi[70]=Oi[100]=0,Ri[70]=Ri[100]=1,Li[70]=Li[100]=0,Bi[70]=Bi[100]=-1,zi[70]=zi[100]=0,Vi[70]=Vi[100]=1,Ui[70]=Ui[100]=0,Wi[70]=Wi[100]=-1,Gi[70]=Gi[100]=1,wi[70]=wi[100]=1,Ii[70]=Ii[100]=0,Si[70]=Si[100]=0,Oi[101]=Oi[69]=0,Ri[101]=Ri[69]=1,Li[101]=Li[69]=0,wi[101]=wi[69]=1,Ii[101]=Ii[69]=0,Si[101]=Si[69]=0,Hi[149]=Hi[21]=0,ji[149]=ji[21]=1,Ki[149]=Ki[21]=1,Di[149]=Di[21]=-1,Ti[149]=Ti[21]=0,Ni[149]=Ni[21]=0,Bi[86]=Bi[84]=-1,zi[86]=zi[84]=0,Vi[86]=Vi[84]=1,Ui[86]=Ui[84]=0,Wi[86]=Wi[84]=-1,Gi[86]=Gi[84]=1,Ai[89]=Ai[81]=0,Mi[89]=Mi[81]=-1,Pi[89]=Pi[81]=0,ki[89]=ki[81]=1,Fi[89]=Fi[81]=0,$i[89]=$i[81]=1,Ai[96]=Ai[74]=0,Mi[96]=Mi[74]=1,Pi[96]=Pi[74]=0,Oi[96]=Oi[74]=-1,Ri[96]=Ri[74]=0,Li[96]=Li[74]=1,Ui[96]=Ui[74]=1,Wi[96]=Wi[74]=0,Gi[96]=Gi[74]=0,wi[96]=wi[74]=1,Ii[96]=Ii[74]=0,Si[96]=Si[74]=1,Ai[24]=Ai[146]=0,Mi[24]=Mi[146]=-1,Pi[24]=Pi[146]=1,Bi[24]=Bi[146]=1,zi[24]=zi[146]=0,Vi[24]=Vi[146]=1,ki[24]=ki[146]=0,Fi[24]=Fi[146]=1,$i[24]=$i[146]=1,Di[24]=Di[146]=0,Ti[24]=Ti[146]=-1,Ni[24]=Ni[146]=0,Oi[6]=Oi[164]=-1,Ri[6]=Ri[164]=0,Li[6]=Li[164]=1,Bi[6]=Bi[164]=-1,zi[6]=zi[164]=0,Vi[6]=Vi[164]=0,Hi[6]=Hi[164]=0,ji[6]=ji[164]=-1,Ki[6]=Ki[164]=1,Ui[6]=Ui[164]=1,Wi[6]=Wi[164]=0,Gi[6]=Gi[164]=0,ki[129]=ki[41]=0,Fi[129]=Fi[41]=1,$i[129]=$i[41]=1,Hi[129]=Hi[41]=0,ji[129]=ji[41]=1,Ki[129]=Ki[41]=0,wi[129]=wi[41]=-1,Ii[129]=Ii[41]=0,Si[129]=Si[41]=0,Di[129]=Di[41]=0,Ti[129]=Ti[41]=-1,Ni[129]=Ni[41]=0,Bi[66]=Bi[104]=0,zi[66]=zi[104]=1,Vi[66]=Vi[104]=0,ki[66]=ki[104]=-1,Fi[66]=Fi[104]=0,$i[66]=$i[104]=1,Ui[66]=Ui[104]=0,Wi[66]=Wi[104]=-1,Gi[66]=Gi[104]=0,wi[66]=wi[104]=0,Ii[66]=Ii[104]=-1,Si[66]=Si[104]=1,Ai[144]=Ai[26]=-1,Mi[144]=Mi[26]=0,Pi[144]=Pi[26]=0,Hi[144]=Hi[26]=1,ji[144]=ji[26]=0,Ki[144]=Ki[26]=1,Ui[144]=Ui[26]=0,Wi[144]=Wi[26]=1,Gi[144]=Gi[26]=1,Di[144]=Di[26]=-1,Ti[144]=Ti[26]=0,Ni[144]=Ni[26]=1,Oi[36]=Oi[134]=0,Ri[36]=Ri[134]=1,Li[36]=Li[134]=1,Bi[36]=Bi[134]=0,zi[36]=zi[134]=1,Vi[36]=Vi[134]=0,wi[36]=wi[134]=0,Ii[36]=Ii[134]=-1,Si[36]=Si[134]=1,Di[36]=Di[134]=1,Ti[36]=Ti[134]=0,Ni[36]=Ni[134]=0,Ai[9]=Ai[161]=-1,Mi[9]=Mi[161]=0,Pi[9]=Pi[161]=0,Oi[9]=Oi[161]=0,Ri[9]=Ri[161]=-1,Li[9]=Li[161]=0,ki[9]=ki[161]=1,Fi[9]=Fi[161]=0,$i[9]=$i[161]=0,Hi[9]=Hi[161]=1,ji[9]=ji[161]=0,Ki[9]=Ki[161]=1,Ai[136]=0,Mi[136]=1,Pi[136]=1,Oi[136]=0,Ri[136]=1,Li[136]=0,Bi[136]=-1,zi[136]=0,Vi[136]=1,ki[136]=-1,Fi[136]=0,$i[136]=0,Hi[136]=0,ji[136]=-1,Ki[136]=0,Ui[136]=0,Wi[136]=-1,Gi[136]=1,wi[136]=1,Ii[136]=0,Si[136]=0,Di[136]=1,Ti[136]=0,Ni[136]=1,Ai[34]=0,Mi[34]=-1,Pi[34]=0,Oi[34]=0,Ri[34]=-1,Li[34]=1,Bi[34]=1,zi[34]=0,Vi[34]=0,ki[34]=1,Fi[34]=0,$i[34]=1,Hi[34]=0,ji[34]=1,Ki[34]=1,Ui[34]=0,Wi[34]=1,Gi[34]=0,wi[34]=-1,Ii[34]=0,Si[34]=1,Di[34]=-1,Ti[34]=0,Ni[34]=0,Ai[35]=0,Mi[35]=1,Pi[35]=1,Oi[35]=0,Ri[35]=-1,Li[35]=1,Bi[35]=1,zi[35]=0,Vi[35]=0,ki[35]=-1,Fi[35]=0,$i[35]=0,Hi[35]=0,ji[35]=-1,Ki[35]=0,Ui[35]=0,Wi[35]=1,Gi[35]=0,wi[35]=-1,Ii[35]=0,Si[35]=1,Di[35]=1,Ti[35]=0,Ni[35]=1,Ai[153]=0,Mi[153]=1,Pi[153]=1,ki[153]=-1,Fi[153]=0,$i[153]=0,Hi[153]=0,ji[153]=-1,Ki[153]=0,Di[153]=1,Ti[153]=0,Ni[153]=1,Oi[102]=0,Ri[102]=-1,Li[102]=1,Bi[102]=1,zi[102]=0,Vi[102]=0,Ui[102]=0,Wi[102]=1,Gi[102]=0,wi[102]=-1,Ii[102]=0,Si[102]=1,Ai[155]=0,Mi[155]=-1,Pi[155]=0,ki[155]=1,Fi[155]=0,$i[155]=1,Hi[155]=0,ji[155]=1,Ki[155]=1,Di[155]=-1,Ti[155]=0,Ni[155]=0,Oi[103]=0,Ri[103]=1,Li[103]=0,Bi[103]=-1,zi[103]=0,Vi[103]=1,Ui[103]=0,Wi[103]=-1,Gi[103]=1,wi[103]=1,Ii[103]=0,Si[103]=0,Ai[152]=0,Mi[152]=1,Pi[152]=1,Bi[152]=-1,zi[152]=0,Vi[152]=1,ki[152]=-1,Fi[152]=0,$i[152]=0,Hi[152]=0,ji[152]=-1,Ki[152]=0,Ui[152]=0,Wi[152]=-1,Gi[152]=1,Di[152]=1,Ti[152]=0,Ni[152]=1,Ai[156]=0,Mi[156]=-1,Pi[156]=1,Bi[156]=1,zi[156]=0,Vi[156]=1,ki[156]=-1,Fi[156]=0,$i[156]=0,Hi[156]=0,ji[156]=-1,Ki[156]=0,Ui[156]=0,Wi[156]=1,Gi[156]=1,Di[156]=-1,Ti[156]=0,Ni[156]=1,Ai[137]=0,Mi[137]=1,Pi[137]=1,Oi[137]=0,Ri[137]=1,Li[137]=0,ki[137]=-1,Fi[137]=0,$i[137]=0,Hi[137]=0,ji[137]=-1,Ki[137]=0,wi[137]=1,Ii[137]=0,Si[137]=0,Di[137]=1,Ti[137]=0,Ni[137]=1,Ai[139]=0,Mi[139]=1,Pi[139]=1,Oi[139]=0,Ri[139]=-1,Li[139]=0,ki[139]=1,Fi[139]=0,$i[139]=0,Hi[139]=0,ji[139]=1,Ki[139]=0,wi[139]=-1,Ii[139]=0,Si[139]=0,Di[139]=1,Ti[139]=0,Ni[139]=1,Ai[98]=0,Mi[98]=-1,Pi[98]=0,Oi[98]=0,Ri[98]=-1,Li[98]=1,Bi[98]=1,zi[98]=0,Vi[98]=0,ki[98]=1,Fi[98]=0,$i[98]=1,Ui[98]=0,Wi[98]=1,Gi[98]=0,wi[98]=-1,Ii[98]=0,Si[98]=1,Ai[99]=0,Mi[99]=1,Pi[99]=0,Oi[99]=0,Ri[99]=-1,Li[99]=1,Bi[99]=1,zi[99]=0,Vi[99]=0,ki[99]=-1,Fi[99]=0,$i[99]=1,Ui[99]=0,Wi[99]=-1,Gi[99]=0,wi[99]=1,Ii[99]=0,Si[99]=1,Oi[38]=0,Ri[38]=-1,Li[38]=1,Bi[38]=1,zi[38]=0,Vi[38]=0,Hi[38]=0,ji[38]=1,Ki[38]=1,Ui[38]=0,Wi[38]=1,Gi[38]=0,wi[38]=-1,Ii[38]=0,Si[38]=1,Di[38]=-1,Ti[38]=0,Ni[38]=0,Oi[39]=0,Ri[39]=1,Li[39]=1,Bi[39]=-1,zi[39]=0,Vi[39]=0,Hi[39]=0,ji[39]=-1,Ki[39]=1,Ui[39]=0,Wi[39]=1,Gi[39]=0,wi[39]=-1,Ii[39]=0,Si[39]=1,Di[39]=1,Ti[39]=0,Ni[39]=0;var Ib=function(t){return[[t.bottomleft,0],[0,0],[0,t.leftbottom]]},Sb=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0]]},Db=function(t){return[[t.topright,1],[1,1],[1,t.righttop]]},Tb=function(t){return[[0,t.lefttop],[0,1],[t.topleft,1]]},Nb=function(t){return[[t.bottomright,0],[t.bottomleft,0],[0,t.leftbottom],[0,t.lefttop]]},Ab=function(t){return[[t.bottomright,0],[t.bottomleft,0],[1,t.righttop],[1,t.rightbottom]]},Mb=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.topleft,1],[t.topright,1]]},Pb=function(t){return[[0,t.leftbottom],[0,t.lefttop],[t.topleft,1],[t.topright,1]]},Zn=[],jn=[],gr=[],hr=[],Ar=[],Sr=[],Xi=[],ts=[];hr[1]=Ar[1]=18,hr[169]=Ar[169]=18,gr[4]=jn[4]=12,gr[166]=jn[166]=12,Zn[16]=ts[16]=4,Zn[154]=ts[154]=4,Sr[64]=Xi[64]=22,Sr[106]=Xi[106]=22,gr[2]=Sr[2]=17,hr[2]=Ar[2]=18,gr[168]=Sr[168]=17,hr[168]=Ar[168]=18,Zn[8]=hr[8]=9,jn[8]=gr[8]=12,Zn[162]=hr[162]=9,jn[162]=gr[162]=12,Zn[32]=ts[32]=4,jn[32]=Xi[32]=1,Zn[138]=ts[138]=4,jn[138]=Xi[138]=1,Ar[128]=ts[128]=21,Sr[128]=Xi[128]=22,Ar[42]=ts[42]=21,Sr[42]=Xi[42]=22,jn[5]=Ar[5]=14,jn[165]=Ar[165]=14,gr[20]=ts[20]=6,gr[150]=ts[150]=6,Zn[80]=Sr[80]=11,Zn[90]=Sr[90]=11,hr[65]=Xi[65]=3,hr[105]=Xi[105]=3,Zn[160]=Sr[160]=11,jn[160]=Ar[160]=14,Zn[10]=Sr[10]=11,jn[10]=Ar[10]=14,gr[130]=ts[130]=6,hr[130]=Xi[130]=3,gr[40]=ts[40]=6,hr[40]=Xi[40]=3,jn[101]=Xi[101]=1,jn[69]=Xi[69]=1,Ar[149]=ts[149]=21,Ar[21]=ts[21]=21,gr[86]=Sr[86]=17,gr[84]=Sr[84]=17,Zn[89]=hr[89]=9,Zn[81]=hr[81]=9,Zn[96]=Xi[96]=0,jn[96]=Sr[96]=15,Zn[74]=Xi[74]=0,jn[74]=Sr[74]=15,Zn[24]=gr[24]=8,hr[24]=ts[24]=7,Zn[146]=gr[146]=8,hr[146]=ts[146]=7,jn[6]=Sr[6]=15,gr[6]=Ar[6]=16,jn[164]=Sr[164]=15,gr[164]=Ar[164]=16,hr[129]=ts[129]=7,Ar[129]=Xi[129]=20,hr[41]=ts[41]=7,Ar[41]=Xi[41]=20,gr[66]=Xi[66]=2,hr[66]=Sr[66]=19,gr[104]=Xi[104]=2,hr[104]=Sr[104]=19,Zn[144]=Ar[144]=10,Sr[144]=ts[144]=23,Zn[26]=Ar[26]=10,Sr[26]=ts[26]=23,jn[36]=ts[36]=5,gr[36]=Xi[36]=2,jn[134]=ts[134]=5,gr[134]=Xi[134]=2,Zn[9]=Ar[9]=10,jn[9]=hr[9]=13,Zn[161]=Ar[161]=10,jn[161]=hr[161]=13,jn[37]=ts[37]=5,Ar[37]=Xi[37]=20,jn[133]=ts[133]=5,Ar[133]=Xi[133]=20,gr[148]=Ar[148]=16,Sr[148]=ts[148]=23,gr[22]=Ar[22]=16,Sr[22]=ts[22]=23,Zn[82]=gr[82]=8,hr[82]=Sr[82]=19,Zn[88]=gr[88]=8,hr[88]=Sr[88]=19,Zn[73]=Xi[73]=0,jn[73]=hr[73]=13,Zn[97]=Xi[97]=0,jn[97]=hr[97]=13,Zn[145]=hr[145]=9,Ar[145]=ts[145]=21,Zn[25]=hr[25]=9,Ar[25]=ts[25]=21,jn[70]=Xi[70]=1,gr[70]=Sr[70]=17,jn[100]=Xi[100]=1,gr[100]=Sr[100]=17,Zn[34]=hr[34]=9,jn[34]=gr[34]=12,Ar[34]=ts[34]=21,Sr[34]=Xi[34]=22,Zn[136]=ts[136]=4,jn[136]=Xi[136]=1,gr[136]=Sr[136]=17,hr[136]=Ar[136]=18,Zn[35]=ts[35]=4,jn[35]=gr[35]=12,hr[35]=Ar[35]=18,Sr[35]=Xi[35]=22,Zn[153]=ts[153]=4,hr[153]=Ar[153]=18,jn[102]=gr[102]=12,Sr[102]=Xi[102]=22,Zn[155]=hr[155]=9,Ar[155]=ts[155]=23,jn[103]=Xi[103]=1,gr[103]=Sr[103]=17,Zn[152]=ts[152]=4,gr[152]=Sr[152]=17,hr[152]=Ar[152]=18,Zn[156]=gr[156]=8,hr[156]=Ar[156]=18,Sr[156]=ts[156]=23,Zn[137]=ts[137]=4,jn[137]=Xi[137]=1,hr[137]=Ar[137]=18,Zn[139]=ts[139]=4,jn[139]=hr[139]=13,Ar[139]=Xi[139]=20,Zn[98]=hr[98]=9,jn[98]=gr[98]=12,Sr[98]=Xi[98]=22,Zn[99]=Xi[99]=0,jn[99]=gr[99]=12,hr[99]=Sr[99]=19,jn[38]=gr[38]=12,Ar[38]=ts[38]=21,Sr[38]=Xi[38]=22,jn[39]=ts[39]=5,gr[39]=Ar[39]=16,Sr[39]=Xi[39]=22;var Rn=[];function Lb(t,n,e){return function LQ(t){return(t>0)-(t<0)||+t}((n[0]-t[0])*(e[1]-n[1])-(e[0]-n[0])*(n[1]-t[1]))}function f2(t,n){return n.geometry.coordinates[0].every(function(e){return db(ap(e),t)})}Rn[1]=Rn[169]=Ib,Rn[4]=Rn[166]=Sb,Rn[16]=Rn[154]=Db,Rn[64]=Rn[106]=Tb,Rn[168]=Rn[2]=Nb,Rn[162]=Rn[8]=Ab,Rn[138]=Rn[32]=Mb,Rn[42]=Rn[128]=Pb,Rn[5]=Rn[165]=function(t){return[[0,0],[0,t.leftbottom],[1,t.rightbottom],[1,0]]},Rn[20]=Rn[150]=function(t){return[[1,0],[t.bottomright,0],[t.topright,1],[1,1]]},Rn[80]=Rn[90]=function(t){return[[1,1],[1,t.righttop],[0,t.lefttop],[0,1]]},Rn[65]=Rn[105]=function(t){return[[t.bottomleft,0],[0,0],[0,1],[t.topleft,1]]},Rn[160]=Rn[10]=function(t){return[[1,t.righttop],[1,t.rightbottom],[0,t.leftbottom],[0,t.lefttop]]},Rn[130]=Rn[40]=function(t){return[[t.topleft,1],[t.topright,1],[t.bottomright,0],[t.bottomleft,0]]},Rn[85]=function(){return[[0,0],[0,1],[1,1],[1,0]]},Rn[101]=Rn[69]=function(t){return[[1,t.rightbottom],[1,0],[0,0],[0,1],[t.topleft,1]]},Rn[149]=Rn[21]=function(t){return[[t.topright,1],[1,1],[1,0],[0,0],[0,t.leftbottom]]},Rn[86]=Rn[84]=function(t){return[[1,0],[t.bottomright,0],[0,t.lefttop],[0,1],[1,1]]},Rn[89]=Rn[81]=function(t){return[[1,1],[1,t.righttop],[t.bottomleft,0],[0,0],[0,1]]},Rn[96]=Rn[74]=function(t){return[[1,t.righttop],[1,t.rightbottom],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[24]=Rn[146]=function(t){return[[1,1],[1,t.righttop],[t.bottomright,0],[t.bottomleft,0],[t.topright,1]]},Rn[6]=Rn[164]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[0,t.leftbottom],[0,t.lefttop]]},Rn[129]=Rn[41]=function(t){return[[t.topright,1],[t.bottomleft,0],[0,0],[0,t.leftbottom],[t.topleft,1]]},Rn[66]=Rn[104]=function(t){return[[t.bottomright,0],[t.bottomleft,0],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[144]=Rn[26]=function(t){return[[1,1],[1,t.righttop],[0,t.leftbottom],[0,t.lefttop],[t.topright,1]]},Rn[36]=Rn[134]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[t.topleft,1],[t.topright,1]]},Rn[9]=Rn[161]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomleft,0],[0,0],[0,t.leftbottom]]},Rn[37]=Rn[133]=function(t){return[[1,t.rightbottom],[1,0],[0,0],[0,t.leftbottom],[t.topleft,1],[t.topright,1]]},Rn[148]=Rn[22]=function(t){return[[1,1],[1,0],[t.bottomright,0],[0,t.leftbottom],[0,t.lefttop],[t.topright,1]]},Rn[82]=Rn[88]=function(t){return[[1,1],[1,t.righttop],[t.bottomright,0],[t.bottomleft,0],[0,t.lefttop],[0,1]]},Rn[73]=Rn[97]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomleft,0],[0,0],[0,1],[t.topleft,1]]},Rn[145]=Rn[25]=function(t){return[[1,1],[1,t.righttop],[t.bottomleft,0],[0,0],[0,t.leftbottom],[t.topright,1]]},Rn[70]=Rn[100]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[34]=function(t){return[Pb(t),Ab(t)]},Rn[35]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomright,0],[t.bottomleft,0],[0,t.leftbottom],[0,t.lefttop],[t.topleft,1],[t.topright,1]]},Rn[136]=function(t){return[Mb(t),Nb(t)]},Rn[153]=function(t){return[Db(t),Ib(t)]},Rn[102]=function(t){return[Sb(t),Tb(t)]},Rn[155]=function(t){return[[1,1],[1,t.righttop],[t.bottomleft,0],[0,0],[0,t.leftbottom],[t.topright,1]]},Rn[103]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[152]=function(t){return[Db(t),Nb(t)]},Rn[156]=function(t){return[[1,1],[1,t.righttop],[t.bottomright,0],[t.bottomleft,0],[0,t.leftbottom],[0,t.lefttop],[t.topright,1]]},Rn[137]=function(t){return[Mb(t),Ib(t)]},Rn[139]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomleft,0],[0,0],[0,t.leftbottom],[t.topleft,1],[t.topright,1]]},Rn[98]=function(t){return[Ab(t),Tb(t)]},Rn[99]=function(t){return[[1,t.righttop],[1,t.rightbottom],[t.bottomright,0],[t.bottomleft,0],[0,t.lefttop],[0,1],[t.topleft,1]]},Rn[38]=function(t){return[Sb(t),Pb(t)]},Rn[39]=function(t){return[[1,t.rightbottom],[1,0],[t.bottomright,0],[0,t.leftbottom],[0,t.lefttop],[t.topleft,1],[t.topright,1]]};const p2=function(){function t(n){this.id=t.buildId(n),this.coordinates=n,this.innerEdges=[],this.outerEdges=[],this.outerEdgesSorted=!1}return t.buildId=function(n){return n.join(",")},t.prototype.removeInnerEdge=function(n){this.innerEdges=this.innerEdges.filter(function(e){return e.from.id!==n.from.id})},t.prototype.removeOuterEdge=function(n){this.outerEdges=this.outerEdges.filter(function(e){return e.to.id!==n.to.id})},t.prototype.addOuterEdge=function(n){this.outerEdges.push(n),this.outerEdgesSorted=!1},t.prototype.sortOuterEdges=function(){var n=this;this.outerEdgesSorted||(this.outerEdges.sort(function(e,r){var i=e.to,s=r.to;if(i.coordinates[0]-n.coordinates[0]>=0&&s.coordinates[0]-n.coordinates[0]<0)return 1;if(i.coordinates[0]-n.coordinates[0]<0&&s.coordinates[0]-n.coordinates[0]>=0)return-1;if(i.coordinates[0]-n.coordinates[0]==0&&s.coordinates[0]-n.coordinates[0]==0)return i.coordinates[1]-n.coordinates[1]>=0||s.coordinates[1]-n.coordinates[1]>=0?i.coordinates[1]-s.coordinates[1]:s.coordinates[1]-i.coordinates[1];var o=Lb(n.coordinates,i.coordinates,s.coordinates);return o<0?1:o>0?-1:Math.pow(i.coordinates[0]-n.coordinates[0],2)+Math.pow(i.coordinates[1]-n.coordinates[1],2)-(Math.pow(s.coordinates[0]-n.coordinates[0],2)+Math.pow(s.coordinates[1]-n.coordinates[1],2))}),this.outerEdgesSorted=!0)},t.prototype.getOuterEdges=function(){return this.sortOuterEdges(),this.outerEdges},t.prototype.getOuterEdge=function(n){return this.sortOuterEdges(),this.outerEdges[n]},t.prototype.addInnerEdge=function(n){this.innerEdges.push(n)},t}(),zQ=function(){function t(n,e){this.from=n,this.to=e,this.next=void 0,this.label=void 0,this.symetric=void 0,this.ring=void 0,this.from.addOuterEdge(this),this.to.addInnerEdge(this)}return t.prototype.getSymetric=function(){return this.symetric||(this.symetric=new t(this.to,this.from),this.symetric.symetric=this),this.symetric},t.prototype.deleteEdge=function(){this.from.removeOuterEdge(this),this.to.removeInnerEdge(this)},t.prototype.isEqual=function(n){return this.from.id===n.from.id&&this.to.id===n.to.id},t.prototype.toString=function(){return"Edge { "+this.from.id+" -> "+this.to.id+" }"},t.prototype.toLineString=function(){return _v([this.from.coordinates,this.to.coordinates])},t.prototype.compareTo=function(n){return Lb(n.from.coordinates,n.to.coordinates,this.to.coordinates)},t}(),UQ=function(){function t(){this.edges=[],this.polygon=void 0,this.envelope=void 0}return t.prototype.push=function(n){this.edges.push(n),this.polygon=this.envelope=void 0},t.prototype.get=function(n){return this.edges[n]},Object.defineProperty(t.prototype,"length",{get:function(){return this.edges.length},enumerable:!0,configurable:!0}),t.prototype.forEach=function(n){this.edges.forEach(n)},t.prototype.map=function(n){return this.edges.map(n)},t.prototype.some=function(n){return this.edges.some(n)},t.prototype.isValid=function(){return!0},t.prototype.isHole=function(){var n=this,e=this.edges.reduce(function(o,a,u){return a.from.coordinates[1]>n.edges[o].from.coordinates[1]&&(o=u),o},0),r=(0===e?this.length:e)-1,i=(e+1)%this.length,s=Lb(this.edges[r].from.coordinates,this.edges[e].from.coordinates,this.edges[i].from.coordinates);return 0===s?this.edges[r].from.coordinates[0]>this.edges[i].from.coordinates[0]:s>0},t.prototype.toMultiPoint=function(){return function wR(t,n,e){return void 0===e&&(e={}),Gc({type:"MultiPoint",coordinates:t},n,e)}(this.edges.map(function(n){return n.from.coordinates}))},t.prototype.toPolygon=function(){if(this.polygon)return this.polygon;var n=this.edges.map(function(e){return e.from.coordinates});return n.push(this.edges[0].from.coordinates),this.polygon=sg([n])},t.prototype.getEnvelope=function(){return this.envelope?this.envelope:this.envelope=function XZ(t){return function KZ(t,n){void 0===n&&(n={});var e=Number(t[0]),r=Number(t[1]),i=Number(t[2]),s=Number(t[3]);if(6===t.length)throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");var o=[e,r];return sg([[o,[i,r],[i,s],[e,s],o]],n.properties,{bbox:t,id:n.id})}(SR(t))}(this.toPolygon())},t.findEdgeRingContaining=function(n,e){var i,s,r=n.getEnvelope();return e.forEach(function(o){var a=o.getEnvelope();if(s&&(i=s.getEnvelope()),!function kQ(t,n){var e=t.geometry.coordinates[0].map(function(o){return o[0]}),r=t.geometry.coordinates[0].map(function(o){return o[1]}),i=n.geometry.coordinates[0].map(function(o){return o[0]}),s=n.geometry.coordinates[0].map(function(o){return o[1]});return Math.max.apply(null,e)===Math.max.apply(null,i)&&Math.max.apply(null,r)===Math.max.apply(null,s)&&Math.min.apply(null,e)===Math.min.apply(null,i)&&Math.min.apply(null,r)===Math.min.apply(null,s)}(a,r)&&f2(a,r)){for(var u=n.map(function(b){return b.from.coordinates}),c=void 0,d=function(b){o.some(function(w){return function FQ(t,n){return t[0]===n[0]&&t[1]===n[1]}(b,w.from.coordinates)})||(c=b)},p=0,v=u;p<v.length;p++)d(v[p]);c&&o.inside(ap(c))&&(!s||f2(i,a))&&(s=o)}}),s},t.prototype.inside=function(n){return db(n,this.toPolygon())},t}();function b2(t){for(var n=t,e=[];n.parent;)e.unshift(n),n=n.parent;return e}!function(){function t(){this.edges=[],this.nodes={}}t.fromGeoJson=function(n){!function WQ(t){if(!t)throw new Error("No geojson passed");if("FeatureCollection"!==t.type&&"GeometryCollection"!==t.type&&"MultiLineString"!==t.type&&"LineString"!==t.type&&"Feature"!==t.type)throw new Error("Invalid input type '"+t.type+"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature")}(n);var e=new t;return function Ev(t,n){xv(t,function(e,r,i,s,o){var u,a=null===e?null:e.type;switch(a){case null:case"Point":case"LineString":case"Polygon":return!1!==n(Gc(e,i,{bbox:s,id:o}),r,0)&&void 0}switch(a){case"MultiPoint":u="Point";break;case"MultiLineString":u="LineString";break;case"MultiPolygon":u="Polygon"}for(var c=0;c<e.coordinates.length;c++)if(!1===n(Gc({type:u,coordinates:e.coordinates[c]},i),r,c))return!1})}(n,function(r){(function yZ(t,n,e){if(!t)throw new Error("No feature passed");if(!e)throw new Error(".featureOf() requires a name");if(!t||"Feature"!==t.type||!t.geometry)throw new Error("Invalid input to "+e+", Feature with geometry required");if(!t.geometry||t.geometry.type!==n)throw new Error("Invalid input to "+e+": must be a "+n+", given "+t.geometry.type)})(r,"LineString","Graph::fromGeoJson"),function cZ(t,n,e,r){var i=e;og(t,function(s,o,a,u,c){i=0===o&&void 0===e?s:n(i,s,o,a,u,c)},r)}(r,function(i,s){if(i){var o=e.getNode(i),a=e.getNode(s);e.addEdge(o,a)}return s})}),e},t.prototype.getNode=function(n){var e=p2.buildId(n),r=this.nodes[e];return r||(r=this.nodes[e]=new p2(n)),r},t.prototype.addEdge=function(n,e){var r=new zQ(n,e),i=r.getSymetric();this.edges.push(r),this.edges.push(i)},t.prototype.deleteDangles=function(){var n=this;Object.keys(this.nodes).map(function(e){return n.nodes[e]}).forEach(function(e){return n._removeIfDangle(e)})},t.prototype._removeIfDangle=function(n){var e=this;if(n.innerEdges.length<=1){var r=n.getOuterEdges().map(function(i){return i.to});this.removeNode(n),r.forEach(function(i){return e._removeIfDangle(i)})}},t.prototype.deleteCutEdges=function(){var n=this;this._computeNextCWEdges(),this._findLabeledEdgeRings(),this.edges.forEach(function(e){e.label===e.symetric.label&&(n.removeEdge(e.symetric),n.removeEdge(e))})},t.prototype._computeNextCWEdges=function(n){var e=this;typeof n>"u"?Object.keys(this.nodes).forEach(function(r){return e._computeNextCWEdges(e.nodes[r])}):n.getOuterEdges().forEach(function(r,i){n.getOuterEdge((0===i?n.getOuterEdges().length:i)-1).symetric.next=r})},t.prototype._computeNextCCWEdges=function(n,e){for(var i,s,r=n.getOuterEdges(),o=r.length-1;o>=0;--o){var a=r[o],u=a.symetric,c=void 0,d=void 0;a.label===e&&(c=a),u.label===e&&(d=u),c&&d&&(d&&(s=d),c&&(s&&(s.next=c,s=void 0),i||(i=c)))}s&&(s.next=i)},t.prototype._findLabeledEdgeRings=function(){var n=[],e=0;return this.edges.forEach(function(r){if(!(r.label>=0)){n.push(r);var i=r;do{i.label=e,i=i.next}while(!r.isEqual(i));e++}}),n},t.prototype.getEdgeRings=function(){var n=this;this._computeNextCWEdges(),this.edges.forEach(function(r){r.label=void 0}),this._findLabeledEdgeRings().forEach(function(r){n._findIntersectionNodes(r).forEach(function(i){n._computeNextCCWEdges(i,r.label)})});var e=[];return this.edges.forEach(function(r){r.ring||e.push(n._findEdgeRing(r))}),e},t.prototype._findIntersectionNodes=function(n){var e=[],r=n,i=function(){var s=0;r.from.getOuterEdges().forEach(function(o){o.label===n.label&&++s}),s>1&&e.push(r.from),r=r.next};do{i()}while(!n.isEqual(r));return e},t.prototype._findEdgeRing=function(n){var e=n,r=new UQ;do{r.push(e),e.ring=r,e=e.next}while(!n.isEqual(e));return r},t.prototype.removeNode=function(n){var e=this;n.getOuterEdges().forEach(function(r){return e.removeEdge(r)}),n.innerEdges.forEach(function(r){return e.removeEdge(r)}),delete this.nodes[n.id]},t.prototype.removeEdge=function(n){this.edges=this.edges.filter(function(e){return!e.isEqual(n)}),n.deleteEdge()}}(),y(3198),y(3367),y(3282);var Tv={search:function(t,n,e,r){t.cleanDirty();var i=(r=r||{}).heuristic||Tv.heuristics.manhattan,s=r.closest||!1,o=function sq(){return new w2(function(t){return t.f})}(),a=n;for(n.h=i(n,e),o.push(n);o.size()>0;){var u=o.pop();if(u===e)return b2(u);u.closed=!0;for(var c=t.neighbors(u),d=0,p=c.length;d<p;++d){var v=c[d];if(!v.closed&&!v.isWall()){var x=u.g+v.getCost(u),b=v.visited;(!b||x<v.g)&&(v.visited=!0,v.parent=u,v.h=v.h||i(v,e),v.g=x,v.f=v.g+v.h,t.markDirty(v),s&&(v.h<a.h||v.h===a.h&&v.g<a.g)&&(a=v),b?o.rescoreElement(v):o.push(v))}}}return s?b2(a):[]},heuristics:{manhattan:function(t,n){return Math.abs(n.x-t.x)+Math.abs(n.y-t.y)},diagonal:function(t,n){var r=Math.sqrt(2),i=Math.abs(n.x-t.x),s=Math.abs(n.y-t.y);return 1*(i+s)+(r-2)*Math.min(i,s)}},cleanNode:function(t){t.f=0,t.g=0,t.h=0,t.visited=!1,t.closed=!1,t.parent=null}};function cp(t,n){n=n||{},this.nodes=[],this.diagonal=!!n.diagonal,this.grid=[];for(var e=0;e<t.length;e++){this.grid[e]=[];for(var r=0,i=t[e];r<i.length;r++){var s=new Nv(e,r,i[r]);this.grid[e][r]=s,this.nodes.push(s)}}this.init()}function Nv(t,n,e){this.x=t,this.y=n,this.weight=e}function w2(t){this.content=[],this.scoreFunction=t}function Fb(){this._=null}function Av(t){t.U=t.C=t.L=t.R=t.P=t.N=null}function hg(t,n){var e=n,r=n.R,i=e.U;i?i.L===e?i.L=r:i.R=r:t._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function dg(t,n){var e=n,r=n.L,i=e.U;i?i.L===e?i.L=r:i.R=r:t._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function I2(t){for(;t.L;)t=t.L;return t}cp.prototype.init=function(){this.dirtyNodes=[];for(var t=0;t<this.nodes.length;t++)Tv.cleanNode(this.nodes[t])},cp.prototype.cleanDirty=function(){for(var t=0;t<this.dirtyNodes.length;t++)Tv.cleanNode(this.dirtyNodes[t]);this.dirtyNodes=[]},cp.prototype.markDirty=function(t){this.dirtyNodes.push(t)},cp.prototype.neighbors=function(t){var n=[],e=t.x,r=t.y,i=this.grid;return i[e-1]&&i[e-1][r]&&n.push(i[e-1][r]),i[e+1]&&i[e+1][r]&&n.push(i[e+1][r]),i[e]&&i[e][r-1]&&n.push(i[e][r-1]),i[e]&&i[e][r+1]&&n.push(i[e][r+1]),this.diagonal&&(i[e-1]&&i[e-1][r-1]&&n.push(i[e-1][r-1]),i[e+1]&&i[e+1][r-1]&&n.push(i[e+1][r-1]),i[e-1]&&i[e-1][r+1]&&n.push(i[e-1][r+1]),i[e+1]&&i[e+1][r+1]&&n.push(i[e+1][r+1])),n},cp.prototype.toString=function(){for(var e,r,i,s,t=[],n=this.grid,o=0,a=n.length;o<a;o++){for(e=[],i=0,s=(r=n[o]).length;i<s;i++)e.push(r[i].weight);t.push(e.join(" "))}return t.join("\n")},Nv.prototype.toString=function(){return"["+this.x+" "+this.y+"]"},Nv.prototype.getCost=function(t){return t&&t.x!==this.x&&t.y!==this.y?1.41421*this.weight:this.weight},Nv.prototype.isWall=function(){return 0===this.weight},w2.prototype={push:function(t){this.content.push(t),this.sinkDown(this.content.length-1)},pop:function(){var t=this.content[0],n=this.content.pop();return this.content.length>0&&(this.content[0]=n,this.bubbleUp(0)),t},remove:function(t){var n=this.content.indexOf(t),e=this.content.pop();n!==this.content.length-1&&(this.content[n]=e,this.scoreFunction(e)<this.scoreFunction(t)?this.sinkDown(n):this.bubbleUp(n))},size:function(){return this.content.length},rescoreElement:function(t){this.sinkDown(this.content.indexOf(t))},sinkDown:function(t){for(var n=this.content[t];t>0;){var e=(t+1>>1)-1,r=this.content[e];if(!(this.scoreFunction(n)<this.scoreFunction(r)))break;this.content[e]=n,this.content[t]=r,t=e}},bubbleUp:function(t){for(var n=this.content.length,e=this.content[t],r=this.scoreFunction(e);;){var a,i=t+1<<1,s=i-1,o=null;if(s<n&&(a=this.scoreFunction(this.content[s]))<r&&(o=s),i<n&&this.scoreFunction(this.content[i])<(null===o?r:a)&&(o=i),null===o)break;this.content[t]=this.content[o],this.content[o]=e,t=o}}},Fb.prototype={constructor:Fb,insert:function(t,n){var e,r,i;if(t){if(n.P=t,n.N=t.N,t.N&&(t.N.P=n),t.N=n,t.R){for(t=t.R;t.L;)t=t.L;t.L=n}else t.R=n;e=t}else this._?(t=I2(this._),n.P=null,n.N=t,t.P=t.L=n,e=t):(n.P=n.N=null,this._=n,e=null);for(n.L=n.R=null,n.U=e,n.C=!0,t=n;e&&e.C;)e===(r=e.U).L?(i=r.R)&&i.C?(e.C=i.C=!1,r.C=!0,t=r):(t===e.R&&(hg(this,e),e=(t=e).U),e.C=!1,r.C=!0,dg(this,r)):(i=r.L)&&i.C?(e.C=i.C=!1,r.C=!0,t=r):(t===e.L&&(dg(this,e),e=(t=e).U),e.C=!1,r.C=!0,hg(this,r)),e=t.U;this._.C=!1},remove:function(t){t.N&&(t.N.P=t.P),t.P&&(t.P.N=t.N),t.N=t.P=null;var e,s,o,n=t.U,r=t.L,i=t.R;if(s=r?i?I2(i):r:i,n?n.L===t?n.L=s:n.R=s:this._=s,r&&i?(o=s.C,s.C=t.C,s.L=r,r.U=s,s!==i?(n=s.U,s.U=t.U,n.L=t=s.R,s.R=i,i.U=s):(s.U=n,n=s,t=s.R)):(o=t.C,t=s),t&&(t.U=n),!o){if(t&&t.C)return void(t.C=!1);do{if(t===this._)break;if(t===n.L){if((e=n.R).C&&(e.C=!1,n.C=!0,hg(this,n),e=n.R),e.L&&e.L.C||e.R&&e.R.C){(!e.R||!e.R.C)&&(e.L.C=!1,e.C=!0,dg(this,e),e=n.R),e.C=n.C,n.C=e.R.C=!1,hg(this,n),t=this._;break}}else if((e=n.L).C&&(e.C=!1,n.C=!0,dg(this,n),e=n.L),e.L&&e.L.C||e.R&&e.R.C){(!e.L||!e.L.C)&&(e.R.C=!1,e.C=!0,hg(this,e),e=n.L),e.C=n.C,n.C=e.L.C=!1,dg(this,n),t=this._;break}e.C=!0,t=n,n=n.U}while(!t.C);t&&(t.C=!1)}}};const S2=Fb;function fg(t,n,e,r){var i=[null,null],s=Gu.push(i)-1;return i.left=t,i.right=n,e&&Mv(i,t,n,e),r&&Mv(i,n,t,r),Rl[t.index].halfedges.push(s),Rl[n.index].halfedges.push(s),i}function pg(t,n,e){var r=[n,e];return r.left=t,r}function Mv(t,n,e,r){t[0]||t[1]?t.left===e?t[1]=r:t[0]=r:(t[0]=r,t.left=n,t.right=e)}function aq(t,n,e,r,i){var w,s=t[0],o=t[1],a=s[0],u=s[1],p=0,v=1,x=o[0]-a,b=o[1]-u;if(w=n-a,x||!(w>0)){if(w/=x,x<0){if(w<p)return;w<v&&(v=w)}else if(x>0){if(w>v)return;w>p&&(p=w)}if(w=r-a,x||!(w<0)){if(w/=x,x<0){if(w>v)return;w>p&&(p=w)}else if(x>0){if(w<p)return;w<v&&(v=w)}if(w=e-u,b||!(w>0)){if(w/=b,b<0){if(w<p)return;w<v&&(v=w)}else if(b>0){if(w>v)return;w>p&&(p=w)}if(w=i-u,b||!(w<0)){if(w/=b,b<0){if(w>v)return;w>p&&(p=w)}else if(b>0){if(w<p)return;w<v&&(v=w)}return!(p>0)&&!(v<1)||(p>0&&(t[0]=[a+p*x,u+p*b]),v<1&&(t[1]=[a+v*x,u+v*b])),!0}}}}}function uq(t,n,e,r,i){var s=t[1];if(s)return!0;var w,T,o=t[0],a=t.left,u=t.right,c=a[0],d=a[1],p=u[0],v=u[1],x=(c+p)/2;if(v===d){if(x<n||x>=r)return;if(c>p){if(o){if(o[1]>=i)return}else o=[x,e];s=[x,i]}else{if(o){if(o[1]<e)return}else o=[x,i];s=[x,e]}}else if(T=(d+v)/2-(w=(c-p)/(v-d))*x,w<-1||w>1)if(c>p){if(o){if(o[1]>=i)return}else o=[(e-T)/w,e];s=[(i-T)/w,i]}else{if(o){if(o[1]<e)return}else o=[(i-T)/w,i];s=[(e-T)/w,e]}else if(d<v){if(o){if(o[0]>=r)return}else o=[n,w*n+T];s=[r,w*r+T]}else{if(o){if(o[0]<n)return}else o=[r,w*r+T];s=[n,w*n+T]}return t[0]=o,t[1]=s,!0}function hq(t,n){var e=t.site,r=n.left,i=n.right;return e===i&&(i=r,r=e),i?Math.atan2(i[1]-r[1],i[0]-r[0]):(e===r?(r=n[1],i=n[0]):(r=n[0],i=n[1]),Math.atan2(r[0]-i[0],i[1]-r[1]))}function D2(t,n){return n[+(n.left!==t.site)]}function dq(t,n){return n[+(n.left===t.site)]}var $b,T2=[];function mq(){Av(this),this.x=this.y=this.arc=this.site=this.cy=null}function hp(t){var n=t.P,e=t.N;if(n&&e){var r=n.site,i=t.site,s=e.site;if(r!==s){var o=i[0],a=i[1],u=r[0]-o,c=r[1]-a,d=s[0]-o,p=s[1]-a,v=2*(u*p-c*d);if(!(v>=-xq)){var x=u*u+c*c,b=d*d+p*p,w=(p*x-c*b)/v,T=(u*b-d*x)/v,N=T2.pop()||new mq;N.arc=t,N.site=i,N.x=w+o,N.y=(N.cy=T+a)+Math.sqrt(w*w+T*T),t.circle=N;for(var S=null,U=mg._;U;)if(N.y<U.y||N.y===U.y&&N.x<=U.x){if(!U.L){S=U.P;break}U=U.L}else{if(!U.R){S=U;break}U=U.R}mg.insert(S,N),S||($b=N)}}}}function dp(t){var n=t.circle;n&&(n.P||($b=n.N),mg.remove(n),T2.push(n),Av(n),t.circle=null)}var N2=[];function gq(){Av(this),this.edge=this.site=this.circle=null}function A2(t){var n=N2.pop()||new gq;return n.site=t,n}function Bb(t){dp(t),fp.remove(t),N2.push(t),Av(t)}function yq(t){var n=t.circle,e=n.x,r=n.cy,i=[e,r],s=t.P,o=t.N,a=[t];Bb(t);for(var u=s;u.circle&&Math.abs(e-u.circle.x)<ia&&Math.abs(r-u.circle.cy)<ia;)s=u.P,a.unshift(u),Bb(u),u=s;a.unshift(u),dp(u);for(var c=o;c.circle&&Math.abs(e-c.circle.x)<ia&&Math.abs(r-c.circle.cy)<ia;)o=c.N,a.push(c),Bb(c),c=o;a.push(c),dp(c);var p,d=a.length;for(p=1;p<d;++p)Mv((c=a[p]).edge,(u=a[p-1]).site,c.site,i);(c=a[d-1]).edge=fg((u=a[0]).site,c.site,null,i),hp(u),hp(c)}function vq(t){for(var r,i,s,o,n=t[0],e=t[1],a=fp._;a;)if((s=M2(a,e)-n)>ia)a=a.L;else{if(!((o=n-_q(a,e))>ia)){s>-ia?(r=a.P,i=a):o>-ia?(r=a,i=a.N):r=i=a;break}if(!a.R){r=a;break}a=a.R}!function cq(t){Rl[t.index]={site:t,halfedges:[]}}(t);var u=A2(t);if(fp.insert(r,u),r||i){if(r===i)return dp(r),i=A2(r.site),fp.insert(u,i),u.edge=i.edge=fg(r.site,u.site),hp(r),void hp(i);if(!i)return void(u.edge=fg(r.site,u.site));dp(r),dp(i);var c=r.site,d=c[0],p=c[1],v=t[0]-d,x=t[1]-p,b=i.site,w=b[0]-d,T=b[1]-p,N=2*(v*T-x*w),S=v*v+x*x,U=w*w+T*T,J=[(T*S-x*U)/N+d,(v*U-w*S)/N+p];Mv(i.edge,c,b,J),u.edge=fg(c,t,null,J),i.edge=fg(t,b,null,J),hp(r),hp(i)}}function M2(t,n){var e=t.site,r=e[0],i=e[1],s=i-n;if(!s)return r;var o=t.P;if(!o)return-1/0;var a=(e=o.site)[0],u=e[1],c=u-n;if(!c)return a;var d=a-r,p=1/s-1/c,v=d/c;return p?(-v+Math.sqrt(v*v-2*p*(d*d/(-2*c)-u+c/2+i-s/2)))/p+r:(r+a)/2}function _q(t,n){var e=t.N;if(e)return M2(e,n);var r=t.site;return r[1]===n?r[0]:1/0}var fp,Rl,mg,Gu,ia=1e-6,xq=1e-12;function Eq(t,n,e){return(t[0]-e[0])*(n[1]-t[1])-(t[0]-n[0])*(e[1]-t[1])}function Cq(t,n){return n[1]-t[1]||n[0]-t[0]}function P2(t,n){var r,i,s,e=t.sort(Cq).pop();for(Gu=[],Rl=new Array(t.length),fp=new S2,mg=new S2;;)if(s=$b,e&&(!s||e[1]<s.y||e[1]===s.y&&e[0]<s.x))(e[0]!==r||e[1]!==i)&&(vq(e),r=e[0],i=e[1]),e=t.pop();else{if(!s)break;yq(s.arc)}if(function fq(){for(var e,r,i,s,t=0,n=Rl.length;t<n;++t)if((e=Rl[t])&&(s=(r=e.halfedges).length)){var o=new Array(s),a=new Array(s);for(i=0;i<s;++i)o[i]=i,a[i]=hq(e,Gu[r[i]]);for(o.sort(function(u,c){return a[c]-a[u]}),i=0;i<s;++i)a[i]=r[o[i]];for(i=0;i<s;++i)r[i]=a[i]}}(),n){var o=+n[0][0],a=+n[0][1],u=+n[1][0],c=+n[1][1];(function lq(t,n,e,r){for(var s,i=Gu.length;i--;)uq(s=Gu[i],t,n,e,r)&&aq(s,t,n,e,r)&&(Math.abs(s[0][0]-s[1][0])>ia||Math.abs(s[0][1]-s[1][1])>ia)||delete Gu[i]})(o,a,u,c),function pq(t,n,e,r){var s,o,a,u,c,d,p,v,x,b,w,T,i=Rl.length,N=!0;for(s=0;s<i;++s)if(o=Rl[s]){for(a=o.site,u=(c=o.halfedges).length;u--;)Gu[c[u]]||c.splice(u,1);for(u=0,d=c.length;u<d;)w=(b=dq(o,Gu[c[u]]))[0],T=b[1],v=(p=D2(o,Gu[c[++u%d]]))[0],x=p[1],(Math.abs(w-v)>ia||Math.abs(T-x)>ia)&&(c.splice(u,0,Gu.push(pg(a,b,Math.abs(w-t)<ia&&r-T>ia?[t,Math.abs(v-t)<ia?x:r]:Math.abs(T-r)<ia&&e-w>ia?[Math.abs(x-r)<ia?v:e,r]:Math.abs(w-e)<ia&&T-n>ia?[e,Math.abs(v-e)<ia?x:n]:Math.abs(T-n)<ia&&w-t>ia?[Math.abs(x-n)<ia?v:t,n]:null))-1),++d);d&&(N=!1)}if(N){var S,U,J,ht=1/0;for(s=0,N=null;s<i;++s)(o=Rl[s])&&(J=(S=(a=o.site)[0]-t)*S+(U=a[1]-n)*U)<ht&&(ht=J,N=o);if(N){var Tt=[t,n],Pt=[t,r],zt=[e,r],Ot=[e,n];N.halfedges.push(Gu.push(pg(a=N.site,Tt,Pt))-1,Gu.push(pg(a,Pt,zt))-1,Gu.push(pg(a,zt,Ot))-1,Gu.push(pg(a,Ot,Tt))-1)}}for(s=0;s<i;++s)(o=Rl[s])&&(o.halfedges.length||delete Rl[s])}(o,a,u,c)}this.edges=Gu,this.cells=Rl,fp=mg=Gu=Rl=null}P2.prototype={constructor:P2,polygons:function(){var t=this.edges;return this.cells.map(function(n){var e=n.halfedges.map(function(r){return D2(n,t[r])});return e.data=n.site.data,e})},triangles:function(){var t=[],n=this.edges;return this.cells.forEach(function(e,r){if(a=(s=e.halfedges).length)for(var s,a,u,i=e.site,o=-1,c=n[s[a-1]],d=c.left===i?c.right:c.left;++o<a;)u=d,d=(c=n[s[o]]).left===i?c.right:c.left,u&&d&&r<u.index&&r<d.index&&Eq(i,u,d)<0&&t.push([i.data,u.data,d.data])}),t},links:function(){return this.edges.filter(function(t){return t.right}).map(function(t){return{source:t.left.data,target:t.right.data}})},find:function(t,n,e){for(var i,a,r=this,s=r._found||0,o=r.cells.length;!(a=r.cells[s]);)if(++s>=o)return null;var u=t-a.site[0],c=n-a.site[1],d=u*u+c*c;do{a=r.cells[i=s],s=null,a.halfedges.forEach(function(p){var v=r.edges[p],x=v.left;if(x!==a.site&&x||(x=v.right)){var b=t-x[0],w=n-x[1],T=b*b+w*w;T<d&&(d=T,s=x.index)}})}while(null!==s);return r._found=i,null==e||d<=e*e?a.site:null}},y(8464);var Vb=y(4855);function Wh(){return new Pv}function Pv(){this.reset()}Pv.prototype={constructor:Pv,reset:function(){this.s=this.t=0},add:function(t){W2(Ov,t,this.t),W2(this,Ov.s,this.s),this.s?this.t+=Ov.t:this.s=Ov.t},valueOf:function(){return this.s}};var Ov=new Pv;function W2(t,n,e){var r=t.s=n+e,i=r-n;t.t=n-(r-i)+(e-i)}var Ws=1e-6,Ms=Math.PI,El=Ms/2,Rv=Ms/4,Ll=2*Ms,Ec=180/Ms,_s=Ms/180,sa=Math.abs,gg=Math.atan,xh=Math.atan2,li=Math.cos,Qr=(Math,Math,Math,Math,Math,Math.sin),sc=(Math,Math.sqrt);Math;function K2(t){return t>1?0:t<-1?Ms:Math.acos(t)}function Eh(t){return t>1?El:t<-1?-El:Math.asin(t)}function pa(){}function Lv(t,n){t&&Z2.hasOwnProperty(t.type)&&Z2[t.type](t,n)}var X2={Feature:function(t,n){Lv(t.geometry,n)},FeatureCollection:function(t,n){for(var e=t.features,r=-1,i=e.length;++r<i;)Lv(e[r].geometry,n)}},Z2={Sphere:function(t,n){n.sphere()},Point:function(t,n){n.point((t=t.coordinates)[0],t[1],t[2])},MultiPoint:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)n.point((t=e[r])[0],t[1],t[2])},LineString:function(t,n){Ub(t.coordinates,n,0)},MultiLineString:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)Ub(e[r],n,0)},Polygon:function(t,n){Y2(t.coordinates,n)},MultiPolygon:function(t,n){for(var e=t.coordinates,r=-1,i=e.length;++r<i;)Y2(e[r],n)},GeometryCollection:function(t,n){for(var e=t.geometries,r=-1,i=e.length;++r<i;)Lv(e[r],n)}};function Ub(t,n,e){var s,r=-1,i=t.length-e;for(n.lineStart();++r<i;)n.point((s=t[r])[0],s[1],s[2]);n.lineEnd()}function Y2(t,n){var e=-1,r=t.length;for(n.polygonStart();++e<r;)Ub(t[e],n,1);n.polygonEnd()}function $v(t){return[xh(t[1],t[0]),Eh(t[2])]}function Pd(t){var n=t[0],e=t[1],r=li(e);return[r*li(n),r*Qr(n),Qr(e)]}function Bv(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function pp(t,n){return[t[1]*n[2]-t[2]*n[1],t[2]*n[0]-t[0]*n[2],t[0]*n[1]-t[1]*n[0]]}function jb(t,n){t[0]+=n[0],t[1]+=n[1],t[2]+=n[2]}function zv(t,n){return[t[0]*n,t[1]*n,t[2]*n]}function Vv(t){var n=sc(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]/=n,t[1]/=n,t[2]/=n}function fL(t,n){function e(r,i){return r=t(r,i),n(r[0],r[1])}return t.invert&&n.invert&&(e.invert=function(r,i){return(r=n.invert(r,i))&&t.invert(r[0],r[1])}),e}function qb(t,n){return[t>Ms?t-Ll:t<-Ms?t+Ll:t,n]}function mL(t){return function(n,e){return[(n+=t)>Ms?n-Ll:n<-Ms?n+Ll:n,e]}}function gL(t){var n=mL(t);return n.invert=mL(-t),n}function yL(t,n){var e=li(t),r=Qr(t),i=li(n),s=Qr(n);function o(a,u){var c=li(u),d=li(a)*c,p=Qr(a)*c,v=Qr(u),x=v*e+d*r;return[xh(p*i-x*s,d*e-v*r),Eh(x*i+p*s)]}return o.invert=function(a,u){var c=li(u),d=li(a)*c,p=Qr(a)*c,v=Qr(u),x=v*i-p*s;return[xh(p*i+v*s,d*e+x*r),Eh(x*e-d*r)]},o}function _L(t,n){(n=Pd(n))[0]-=t,Vv(n);var e=K2(-n[1]);return((-n[2]<0?-e:e)+Ll-Ws)%Ll}function xL(){var n,t=[];return{point:function(e,r){n.push([e,r])},lineStart:function(){t.push(n=[])},lineEnd:pa,rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))},result:function(){var e=t;return t=[],n=null,e}}}function Zv(t,n){return sa(t[0]-n[0])<Ws&&sa(t[1]-n[1])<Ws}function Yv(t,n,e,r){this.x=t,this.z=n,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function EL(t,n,e,r,i){var a,u,s=[],o=[];if(t.forEach(function(b){if(!((w=b.length-1)<=0)){var w,S,T=b[0],N=b[w];if(Zv(T,N)){for(i.lineStart(),a=0;a<w;++a)i.point((T=b[a])[0],T[1]);return void i.lineEnd()}s.push(S=new Yv(T,b,null,!0)),o.push(S.o=new Yv(T,null,S,!1)),s.push(S=new Yv(N,b,null,!1)),o.push(S.o=new Yv(N,null,S,!0))}}),s.length){for(o.sort(n),CL(s),CL(o),a=0,u=o.length;a<u;++a)o[a].e=e=!e;for(var d,p,c=s[0];;){for(var v=c,x=!0;v.v;)if((v=v.n)===c)return;d=v.z,i.lineStart();do{if(v.v=v.o.v=!0,v.e){if(x)for(a=0,u=d.length;a<u;++a)i.point((p=d[a])[0],p[1]);else r(v.x,v.n.x,1,i);v=v.n}else{if(x)for(a=(d=v.p.z).length-1;a>=0;--a)i.point((p=d[a])[0],p[1]);else r(v.x,v.p.x,-1,i);v=v.p}d=(v=v.o).z,x=!x}while(!v.v);i.lineEnd()}}}function CL(t){if(n=t.length){for(var n,i,e=0,r=t[0];++e<n;)r.n=i=t[e],i.p=r,r=i;r.n=i=t[0],i.p=r}}function bL(t,n){return t<n?-1:t>n?1:t>=n?0:NaN}function SL(t){for(var e,s,o,n=t.length,r=-1,i=0;++r<n;)i+=t[r].length;for(s=new Array(i);--n>=0;)for(e=(o=t[n]).length;--e>=0;)s[--i]=o[e];return s}Wh(),Wh(),Wh(),qb.invert=qb,function Xq(t){1===t.length&&(t=function Zq(t){return function(n,e){return bL(t(n),e)}}(t))}(bL),Math.sqrt(50),Math.sqrt(10),Math.sqrt(2);var xg=1e9,Qv=-xg;var nw=Wh();Wh(),Wh(),Wh();var yp=1/0,n_=yp,Eg=-yp,r_=Eg;const zL={point:function lJ(t,n){t<yp&&(yp=t),t>Eg&&(Eg=t),n<n_&&(n_=n),n>r_&&(r_=n)},lineStart:pa,lineEnd:pa,polygonStart:pa,polygonEnd:pa,result:function(){var t=[[yp,n_],[Eg,r_]];return Eg=r_=-(n_=yp=1/0),t}};function YL(t,n,e,r){return function(i,s){var p,v,x,o=n(s),a=i.invert(r[0],r[1]),u=xL(),c=n(u),d=!1,b={point:w,lineStart:N,lineEnd:S,polygonStart:function(){b.point=U,b.lineStart=J,b.lineEnd=ht,v=[],p=[]},polygonEnd:function(){b.point=w,b.lineStart=N,b.lineEnd=S,v=SL(v);var Tt=function TL(t,n){var e=n[0],r=n[1],i=[Qr(e),-li(e),0],s=0,o=0;nw.reset();for(var a=0,u=t.length;a<u;++a)if(d=(c=t[a]).length)for(var c,d,p=c[d-1],v=p[0],x=p[1]/2+Rv,b=Qr(x),w=li(x),T=0;T<d;++T,v=S,b=J,w=ht,p=N){var N=c[T],S=N[0],U=N[1]/2+Rv,J=Qr(U),ht=li(U),Tt=S-v,Pt=Tt>=0?1:-1,zt=Pt*Tt,Ot=zt>Ms,le=b*J;if(nw.add(xh(le*Pt*Qr(zt),w*ht+le*li(zt))),s+=Ot?Tt+Pt*Ll:Tt,Ot^v>=e^S>=e){var ge=pp(Pd(p),Pd(N));Vv(ge);var Ae=pp(i,ge);Vv(Ae);var Re=(Ot^Tt>=0?-1:1)*Eh(Ae[2]);(r>Re||r===Re&&(ge[0]||ge[1]))&&(o+=Ot^Tt>=0?1:-1)}}return(s<-Ws||s<Ws&&nw<-Ws)^1&o}(p,a);v.length?(d||(s.polygonStart(),d=!0),EL(v,_J,Tt,e,s)):Tt&&(d||(s.polygonStart(),d=!0),s.lineStart(),e(null,null,1,s),s.lineEnd()),d&&(s.polygonEnd(),d=!1),v=p=null},sphere:function(){s.polygonStart(),s.lineStart(),e(null,null,1,s),s.lineEnd(),s.polygonEnd()}};function w(Tt,Pt){var zt=i(Tt,Pt);t(Tt=zt[0],Pt=zt[1])&&s.point(Tt,Pt)}function T(Tt,Pt){var zt=i(Tt,Pt);o.point(zt[0],zt[1])}function N(){b.point=T,o.lineStart()}function S(){b.point=w,o.lineEnd()}function U(Tt,Pt){x.push([Tt,Pt]);var zt=i(Tt,Pt);c.point(zt[0],zt[1])}function J(){c.lineStart(),x=[]}function ht(){U(x[0][0],x[0][1]),c.lineEnd();var zt,le,ge,Ae,Tt=c.clean(),Pt=u.result(),Ot=Pt.length;if(x.pop(),p.push(x),x=null,Ot){if(1&Tt){if((le=(ge=Pt[0]).length-1)>0){for(d||(s.polygonStart(),d=!0),s.lineStart(),zt=0;zt<le;++zt)s.point((Ae=ge[zt])[0],Ae[1]);s.lineEnd()}return}Ot>1&&2&Tt&&Pt.push(Pt.pop().concat(Pt.shift())),v.push(Pt.filter(vJ))}}return b}}function vJ(t){return t.length>1}function _J(t,n){return((t=t.x)[0]<0?t[1]-El-Ws:El-t[1])-((n=n.x)[0]<0?n[1]-El-Ws:El-n[1])}Wh(),function ZL(t){return"m0,"+t+"a"+t+","+t+" 0 1,1 0,"+-2*t+"a"+t+","+t+" 0 1,1 0,"+2*t+"z"}(4.5);const QL=YL(function(){return!0},function xJ(t){var i,n=NaN,e=NaN,r=NaN;return{lineStart:function(){t.lineStart(),i=1},point:function(s,o){var a=s>0?Ms:-Ms,u=sa(s-n);sa(u-Ms)<Ws?(t.point(n,e=(e+o)/2>0?El:-El),t.point(r,e),t.lineEnd(),t.lineStart(),t.point(a,e),t.point(s,e),i=0):r!==a&&u>=Ms&&(sa(n-r)<Ws&&(n-=r*Ws),sa(s-a)<Ws&&(s-=a*Ws),e=function EJ(t,n,e,r){var i,s,o=Qr(t-e);return sa(o)>Ws?gg((Qr(n)*(s=li(r))*Qr(e)-Qr(r)*(i=li(n))*Qr(t))/(i*s*o)):(n+r)/2}(n,e,s,o),t.point(r,e),t.lineEnd(),t.lineStart(),t.point(a,e),i=0),t.point(n=s,e=o),r=a},lineEnd:function(){t.lineEnd(),n=e=NaN},clean:function(){return 2-i}}},function CJ(t,n,e,r){var i;if(null==t)r.point(-Ms,i=e*El),r.point(0,i),r.point(Ms,i),r.point(Ms,0),r.point(Ms,-i),r.point(0,-i),r.point(-Ms,-i),r.point(-Ms,0),r.point(-Ms,i);else if(sa(t[0]-n[0])>Ws){var s=t[0]<n[0]?Ms:-Ms;r.point(-s,i=e*s/2),r.point(0,i),r.point(s,i)}else r.point(n[0],n[1])},[-Ms,-El]);function qL(t){return t}function yw(t){return function(n){var e=new vw;for(var r in t)e[r]=t[r];return e.stream=n,e}}function vw(){}function JL(t,n,e){var r=n[1][0]-n[0][0],i=n[1][1]-n[0][1],s=t.clipExtent&&t.clipExtent();t.scale(150).translate([0,0]),null!=s&&t.clipExtent(null),function Q2(t,n){t&&X2.hasOwnProperty(t.type)?X2[t.type](t,n):Lv(t,n)}(e,t.stream(zL));var o=zL.result(),a=Math.min(r/(o[1][0]-o[0][0]),i/(o[1][1]-o[0][1])),u=+n[0][0]+(r-a*(o[1][0]+o[0][0]))/2,c=+n[0][1]+(i-a*(o[1][1]+o[0][1]))/2;return null!=s&&t.clipExtent(s),t.scale(150*a).translate([u,c])}vw.prototype={constructor:vw,point:function(t,n){this.stream.point(t,n)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};var tk=16,IJ=li(30*_s);function ek(t,n){return+n?function DJ(t,n){function e(r,i,s,o,a,u,c,d,p,v,x,b,w,T){var N=c-r,S=d-i,U=N*N+S*S;if(U>4*n&&w--){var J=o+v,ht=a+x,Tt=u+b,Pt=sc(J*J+ht*ht+Tt*Tt),zt=Eh(Tt/=Pt),Ot=sa(sa(Tt)-1)<Ws||sa(s-p)<Ws?(s+p)/2:xh(ht,J),le=t(Ot,zt),ge=le[0],Ae=le[1],Re=ge-r,ve=Ae-i,Ne=S*Re-N*ve;(Ne*Ne/U>n||sa((N*Re+S*ve)/U-.5)>.3||o*v+a*x+u*b<IJ)&&(e(r,i,s,o,a,u,ge,Ae,Ot,J/=Pt,ht/=Pt,Tt,w,T),T.point(ge,Ae),e(ge,Ae,Ot,J,ht,Tt,c,d,p,v,x,b,w,T))}}return function(r){var i,s,o,a,u,c,d,p,v,x,b,w,T={point:N,lineStart:S,lineEnd:J,polygonStart:function(){r.polygonStart(),T.lineStart=ht},polygonEnd:function(){r.polygonEnd(),T.lineStart=S}};function N(zt,Ot){zt=t(zt,Ot),r.point(zt[0],zt[1])}function S(){p=NaN,T.point=U,r.lineStart()}function U(zt,Ot){var le=Pd([zt,Ot]),ge=t(zt,Ot);e(p,v,d,x,b,w,p=ge[0],v=ge[1],d=zt,x=le[0],b=le[1],w=le[2],tk,r),r.point(p,v)}function J(){T.point=N,r.lineEnd()}function ht(){S(),T.point=Tt,T.lineEnd=Pt}function Tt(zt,Ot){U(i=zt,Ot),s=p,o=v,a=x,u=b,c=w,T.point=U}function Pt(){e(p,v,d,x,b,w,s,o,i,a,u,c,tk,r),T.lineEnd=J,J()}return T}}(t,n):function SJ(t){return yw({point:function(n,e){n=t(n,e),this.stream.point(n[0],n[1])}})}(t)}var TJ=yw({point:function(t,n){this.stream.point(t*_s,n*_s)}});function NJ(t){return function AJ(t){var n,s,o,v,x,N,S,U,Pt,zt,e=150,r=480,i=250,a=0,u=0,c=0,d=0,p=0,b=null,w=QL,T=null,J=qL,ht=.5,Tt=ek(ge,ht);function Ot(ve){return[(ve=x(ve[0]*_s,ve[1]*_s))[0]*e+s,o-ve[1]*e]}function le(ve){return(ve=x.invert((ve[0]-s)/e,(o-ve[1])/e))&&[ve[0]*Ec,ve[1]*Ec]}function ge(ve,Ne){return[(ve=n(ve,Ne))[0]*e+s,o-ve[1]*e]}function Ae(){x=fL(v=function pL(t,n,e){return(t%=Ll)?n||e?fL(gL(t),yL(n,e)):gL(t):n||e?yL(n,e):qb}(c,d,p),n);var ve=n(a,u);return s=r-ve[0]*e,o=i+ve[1]*e,Re()}function Re(){return Pt=zt=null,Ot}return Ot.stream=function(ve){return Pt&&zt===ve?Pt:Pt=TJ(w(v,Tt(J(zt=ve))))},Ot.clipAngle=function(ve){return arguments.length?(w=+ve?function bJ(t,n){var e=li(t),r=e>0,i=sa(e)>Ws;function o(d,p){return li(d)*li(p)>e}function u(d,p,v){var w=[1,0,0],T=pp(Pd(d),Pd(p)),N=Bv(T,T),S=T[0],U=N-S*S;if(!U)return!v&&d;var J=e*N/U,ht=-e*S/U,Tt=pp(w,T),Pt=zv(w,J);jb(Pt,zv(T,ht));var Ot=Tt,le=Bv(Pt,Ot),ge=Bv(Ot,Ot),Ae=le*le-ge*(Bv(Pt,Pt)-1);if(!(Ae<0)){var Re=sc(Ae),ve=zv(Ot,(-le-Re)/ge);if(jb(ve,Pt),ve=$v(ve),!v)return ve;var Be,Ne=d[0],Se=p[0],Ke=d[1],Le=p[1];Se<Ne&&(Be=Ne,Ne=Se,Se=Be);var on=Se-Ne,rn=sa(on-Ms)<Ws;if(!rn&&Le<Ke&&(Be=Ke,Ke=Le,Le=Be),rn||on<Ws?rn?Ke+Le>0^ve[1]<(sa(ve[0]-Ne)<Ws?Ke:Le):Ke<=ve[1]&&ve[1]<=Le:on>Ms^(Ne<=ve[0]&&ve[0]<=Se)){var qe=zv(Ot,(-le+Re)/ge);return jb(qe,Pt),[ve,$v(qe)]}}}function c(d,p){var v=r?t:Ms-t,x=0;return d<-v?x|=1:d>v&&(x|=2),p<-v?x|=4:p>v&&(x|=8),x}return YL(o,function a(d){var p,v,x,b,w;return{lineStart:function(){b=x=!1,w=1},point:function(T,N){var U,S=[T,N],J=o(T,N),ht=r?J?0:c(T,N):J?c(T+(T<0?Ms:-Ms),N):0;if(!p&&(b=x=J)&&d.lineStart(),J!==x&&(!(U=u(p,S))||Zv(p,U)||Zv(S,U))&&(S[0]+=Ws,S[1]+=Ws,J=o(S[0],S[1])),J!==x)w=0,J?(d.lineStart(),U=u(S,p),d.point(U[0],U[1])):(U=u(p,S),d.point(U[0],U[1]),d.lineEnd()),p=U;else if(i&&p&&r^J){var Tt;!(ht&v)&&(Tt=u(S,p,!0))&&(w=0,r?(d.lineStart(),d.point(Tt[0][0],Tt[0][1]),d.point(Tt[1][0],Tt[1][1]),d.lineEnd()):(d.point(Tt[1][0],Tt[1][1]),d.lineEnd(),d.lineStart(),d.point(Tt[0][0],Tt[0][1])))}J&&(!p||!Zv(p,S))&&d.point(S[0],S[1]),p=S,x=J,v=ht},lineEnd:function(){x&&d.lineEnd(),p=null},clean:function(){return w|(b&&x)<<1}}},function s(d,p,v,x){!function vL(t,n,e,r,i,s){if(e){var o=li(n),a=Qr(n),u=r*e;null==i?(i=n+r*Ll,s=n-u/2):(i=_L(o,i),s=_L(o,s),(r>0?i<s:i>s)&&(i+=r*Ll));for(var c,d=i;r>0?d>s:d<s;d-=u)c=$v([o,-a*li(d),-a*Qr(d)]),t.point(c[0],c[1])}}(x,t,n,v,d,p)},r?[0,-t]:[-Ms,t-Ms])}(b=ve*_s,6*_s):(b=null,QL),Re()):b*Ec},Ot.clipExtent=function(ve){return arguments.length?(J=null==ve?(T=N=S=U=null,qL):function DL(t,n,e,r){function i(c,d){return t<=c&&c<=e&&n<=d&&d<=r}function s(c,d,p,v){var x=0,b=0;if(null==c||(x=o(c,p))!==(b=o(d,p))||u(c,d)<0^p>0)do{v.point(0===x||3===x?t:e,x>1?r:n)}while((x=(x+p+4)%4)!==b);else v.point(d[0],d[1])}function o(c,d){return sa(c[0]-t)<Ws?d>0?0:3:sa(c[0]-e)<Ws?d>0?2:1:sa(c[1]-n)<Ws?d>0?1:0:d>0?3:2}function a(c,d){return u(c.x,d.x)}function u(c,d){var p=o(c,1),v=o(d,1);return p!==v?p-v:0===p?d[1]-c[1]:1===p?c[0]-d[0]:2===p?c[1]-d[1]:d[0]-c[0]}return function(c){var v,x,b,w,T,N,S,U,J,ht,Tt,d=c,p=xL(),Pt={point:zt,lineStart:function Ae(){Pt.point=ve,x&&x.push(b=[]),ht=!0,J=!1,S=U=NaN},lineEnd:function Re(){v&&(ve(w,T),N&&J&&p.rejoin(),v.push(p.result())),Pt.point=zt,J&&d.lineEnd()},polygonStart:function le(){d=p,v=[],x=[],Tt=!0},polygonEnd:function ge(){var Ne=function Ot(){for(var Ne=0,Se=0,Ke=x.length;Se<Ke;++Se)for(var pn,qe,Le=x[Se],Be=1,on=Le.length,rn=Le[0],gn=rn[0],dn=rn[1];Be<on;++Be)pn=gn,qe=dn,gn=(rn=Le[Be])[0],dn=rn[1],qe<=r?dn>r&&(gn-pn)*(r-qe)>(dn-qe)*(t-pn)&&++Ne:dn<=r&&(gn-pn)*(r-qe)<(dn-qe)*(t-pn)&&--Ne;return Ne}(),Se=Tt&&Ne,Ke=(v=SL(v)).length;(Se||Ke)&&(c.polygonStart(),Se&&(c.lineStart(),s(null,null,1,c),c.lineEnd()),Ke&&EL(v,a,Ne,s,c),c.polygonEnd()),d=c,v=x=b=null}};function zt(Ne,Se){i(Ne,Se)&&d.point(Ne,Se)}function ve(Ne,Se){var Ke=i(Ne,Se);if(x&&b.push([Ne,Se]),ht)w=Ne,T=Se,N=Ke,ht=!1,Ke&&(d.lineStart(),d.point(Ne,Se));else if(Ke&&J)d.point(Ne,Se);else{var Le=[S=Math.max(Qv,Math.min(xg,S)),U=Math.max(Qv,Math.min(xg,U))],Be=[Ne=Math.max(Qv,Math.min(xg,Ne)),Se=Math.max(Qv,Math.min(xg,Se))];!function Kq(t,n,e,r,i,s){var b,o=t[0],a=t[1],d=0,p=1,v=n[0]-o,x=n[1]-a;if(b=e-o,v||!(b>0)){if(b/=v,v<0){if(b<d)return;b<p&&(p=b)}else if(v>0){if(b>p)return;b>d&&(d=b)}if(b=i-o,v||!(b<0)){if(b/=v,v<0){if(b>p)return;b>d&&(d=b)}else if(v>0){if(b<d)return;b<p&&(p=b)}if(b=r-a,x||!(b>0)){if(b/=x,x<0){if(b<d)return;b<p&&(p=b)}else if(x>0){if(b>p)return;b>d&&(d=b)}if(b=s-a,x||!(b<0)){if(b/=x,x<0){if(b>p)return;b>d&&(d=b)}else if(x>0){if(b<d)return;b<p&&(p=b)}return d>0&&(t[0]=o+d*v,t[1]=a+d*x),p<1&&(n[0]=o+p*v,n[1]=a+p*x),!0}}}}}(Le,Be,t,n,e,r)?Ke&&(d.lineStart(),d.point(Ne,Se),Tt=!1):(J||(d.lineStart(),d.point(Le[0],Le[1])),d.point(Be[0],Be[1]),Ke||d.lineEnd(),Tt=!1)}S=Ne,U=Se,J=Ke}return Pt}}(T=+ve[0][0],N=+ve[0][1],S=+ve[1][0],U=+ve[1][1]),Re()):null==T?null:[[T,N],[S,U]]},Ot.scale=function(ve){return arguments.length?(e=+ve,Ae()):e},Ot.translate=function(ve){return arguments.length?(r=+ve[0],i=+ve[1],Ae()):[r,i]},Ot.center=function(ve){return arguments.length?(a=ve[0]%360*_s,u=ve[1]%360*_s,Ae()):[a*Ec,u*Ec]},Ot.rotate=function(ve){return arguments.length?(c=ve[0]%360*_s,d=ve[1]%360*_s,p=ve.length>2?ve[2]%360*_s:0,Ae()):[c*Ec,d*Ec,p*Ec]},Ot.precision=function(ve){return arguments.length?(Tt=ek(ge,ht=ve*ve),Re()):sc(ht)},Ot.fitExtent=function(ve,Ne){return JL(Ot,ve,Ne)},Ot.fitSize=function(ve,Ne){return function wJ(t,n,e){return JL(t,[[0,0],n],e)}(Ot,ve,Ne)},function(){return n=t.apply(this,arguments),Ot.invert=n.invert&&le,Ae()}}(function(){return t})()}function nk(t){return function(n,e){var r=li(n),i=li(e),s=t(r*i);return[s*i*Qr(n),s*Qr(e)]}}function Sg(t){return function(n,e){var r=sc(n*n+e*e),i=t(r),s=Qr(i),o=li(i);return[xh(n*s,r*o),Eh(r&&e*s/r)]}}nk(function(t){return sc(2/(1+t))}).invert=Sg(function(t){return 2*Eh(t/2)});var ik=nk(function(t){return(t=K2(t))&&t/Qr(t)});function xw(t,n){return[t,n]}function u_(t,n,e,r){var i=t.properties||{},s="Feature"===t.type?t.geometry:t;if("GeometryCollection"===s.type){var o=[];return xv(t,function(w){var T=u_(w,n,e,r);T&&o.push(T)}),up(o)}var a=function $J(t){var n=function qZ(t,n){void 0===n&&(n={});var e=SR(t);return ap([(e[0]+e[2])/2,(e[1]+e[3])/2],n.properties,n)}(t).geometry.coordinates,e=[-n[0],-n[1]];return function OJ(){return NJ(ik).scale(79.4188).clipAngle(179.999)}().rotate(e).scale(Wu)}(s),u={type:s.type,coordinates:hk(s.coordinates,a)},d=(new Vb.GeoJSONReader).read(u),p=function IR(t,n){void 0===n&&(n="kilometers");var e=CR[n];if(!e)throw new Error(n+" units is invalid");return t*e}(function ab(t,n){void 0===n&&(n="kilometers");var e=CR[n];if(!e)throw new Error(n+" units is invalid");return t/e}(n,e),"meters"),v=Vb.BufferOp.bufferOp(d,p,r);if(!ck((v=(new Vb.GeoJSONWriter).write(v)).coordinates))return Gc({type:v.type,coordinates:dk(v.coordinates,a)},i)}function ck(t){return Array.isArray(t[0])?ck(t[0]):isNaN(t[0])}function hk(t,n){return"object"!=typeof t[0]?n(t):t.map(function(e){return hk(e,n)})}function dk(t,n){return"object"!=typeof t[0]?n.invert(t):t.map(function(e){return dk(e,n)})}ik.invert=Sg(function(t){return t}),xw.invert=xw,Sg(gg),Sg(Eh),Sg(function(t){return 2*gg(t)});let pk=(()=>{class t{constructor(){this._objectFound=new Gr([]),this.objectFound$=this._objectFound.asObservable()}objectIsFound(e){this._objectFound.next(e)}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275prov=$e({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),mk=(()=>{class t{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=i=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}static#t=this.\u0275fac=function(r){return new(r||t)(vn(lh),vn(Al))};static#e=this.\u0275dir=or({type:t})}return t})(),kd=(()=>{class t extends mk{static#t=this.\u0275fac=function(){let e;return function(i){return(e||(e=Au(t)))(i||t)}}();static#e=this.\u0275dir=or({type:t,features:[so]})}return t})();const Zc=new In("NgValueAccessor"),jJ={provide:Zc,useExisting:ei(()=>l_),multi:!0},XJ=new In("CompositionEventMode");let l_=(()=>{class t extends mk{constructor(e,r,i){super(e,r),this._compositionMode=i,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function KJ(){const t=$h()?$h().getUserAgent():"";return/android (\d+)/.test(t.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}static#t=this.\u0275fac=function(r){return new(r||t)(vn(lh),vn(Al),vn(XJ,8))};static#e=this.\u0275dir=or({type:t,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(r,i){1&r&&_u("input",function(o){return i._handleInput(o.target.value)})("blur",function(){return i.onTouched()})("compositionstart",function(){return i._compositionStart()})("compositionend",function(o){return i._compositionEnd(o.target.value)})},features:[ra([jJ]),so]})}return t})();const Hu=new In("NgValidators"),jh=new In("NgAsyncValidators");function Sk(t){return null!=t}function Dk(t){return Im(t)?ys(t):t}function Tk(t){let n={};return t.forEach(e=>{n=null!=e?{...n,...e}:n}),0===Object.keys(n).length?null:n}function Nk(t,n){return n.map(e=>e(t))}function Ak(t){return t.map(n=>function YJ(t){return!t.validate}(n)?n:e=>n.validate(e))}function Ew(t){return null!=t?function Mk(t){if(!t)return null;const n=t.filter(Sk);return 0==n.length?null:function(e){return Tk(Nk(e,n))}}(Ak(t)):null}function Cw(t){return null!=t?function Pk(t){if(!t)return null;const n=t.filter(Sk);return 0==n.length?null:function(e){return function GJ(...t){const n=Pa(t),{args:e,keys:r}=dO(t),i=new xt(s=>{const{length:o}=e;if(!o)return void s.complete();const a=new Array(o);let u=o,c=o;for(let d=0;d<o;d++){let p=!1;kr(e[d]).subscribe(Me(s,v=>{p||(p=!0,c--),a[d]=v},()=>u--,void 0,()=>{(!u||!p)&&(c||s.next(r?pO(r,a):a),s.complete())}))}});return n?i.pipe(fO(n)):i}(Nk(e,n).map(Dk)).pipe(Ue(Tk))}}(Ak(t)):null}function Ok(t,n){return null===t?[n]:Array.isArray(t)?[...t,n]:[t,n]}function bw(t){return t?Array.isArray(t)?t:[t]:[]}function h_(t,n){return Array.isArray(t)?t.includes(n):t===n}function kk(t,n){const e=bw(n);return bw(t).forEach(i=>{h_(e,i)||e.push(i)}),e}function Fk(t,n){return bw(n).filter(e=>!h_(t,e))}class $k{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(n){this._rawValidators=n||[],this._composedValidatorFn=Ew(this._rawValidators)}_setAsyncValidators(n){this._rawAsyncValidators=n||[],this._composedAsyncValidatorFn=Cw(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(n){this._onDestroyCallbacks.push(n)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(n=>n()),this._onDestroyCallbacks=[]}reset(n=void 0){this.control&&this.control.reset(n)}hasError(n,e){return!!this.control&&this.control.hasError(n,e)}getError(n,e){return this.control?this.control.getError(n,e):null}}class cl extends $k{get formDirective(){return null}get path(){return null}}class Kh extends $k{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class Bk{constructor(n){this._cd=n}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let zk=(()=>{class t extends Bk{constructor(e){super(e)}static#t=this.\u0275fac=function(r){return new(r||t)(vn(Kh,2))};static#e=this.\u0275dir=or({type:t,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(r,i){2&r&&b0("ng-untouched",i.isUntouched)("ng-touched",i.isTouched)("ng-pristine",i.isPristine)("ng-dirty",i.isDirty)("ng-valid",i.isValid)("ng-invalid",i.isInvalid)("ng-pending",i.isPending)},features:[so]})}return t})();const Dg="VALID",f_="INVALID",_p="PENDING",Tg="DISABLED";function p_(t){return null!=t&&!Array.isArray(t)&&"object"==typeof t}class Gk{constructor(n,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(n),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(n){this._rawValidators=this._composedValidatorFn=n}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(n){this._rawAsyncValidators=this._composedAsyncValidatorFn=n}get parent(){return this._parent}get valid(){return this.status===Dg}get invalid(){return this.status===f_}get pending(){return this.status==_p}get disabled(){return this.status===Tg}get enabled(){return this.status!==Tg}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(n){this._assignValidators(n)}setAsyncValidators(n){this._assignAsyncValidators(n)}addValidators(n){this.setValidators(kk(n,this._rawValidators))}addAsyncValidators(n){this.setAsyncValidators(kk(n,this._rawAsyncValidators))}removeValidators(n){this.setValidators(Fk(n,this._rawValidators))}removeAsyncValidators(n){this.setAsyncValidators(Fk(n,this._rawAsyncValidators))}hasValidator(n){return h_(this._rawValidators,n)}hasAsyncValidator(n){return h_(this._rawAsyncValidators,n)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(n={}){this.touched=!0,this._parent&&!n.onlySelf&&this._parent.markAsTouched(n)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(n=>n.markAllAsTouched())}markAsUntouched(n={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!n.onlySelf&&this._parent._updateTouched(n)}markAsDirty(n={}){this.pristine=!1,this._parent&&!n.onlySelf&&this._parent.markAsDirty(n)}markAsPristine(n={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!n.onlySelf&&this._parent._updatePristine(n)}markAsPending(n={}){this.status=_p,!1!==n.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!n.onlySelf&&this._parent.markAsPending(n)}disable(n={}){const e=this._parentMarkedDirty(n.onlySelf);this.status=Tg,this.errors=null,this._forEachChild(r=>{r.disable({...n,onlySelf:!0})}),this._updateValue(),!1!==n.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...n,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(n={}){const e=this._parentMarkedDirty(n.onlySelf);this.status=Dg,this._forEachChild(r=>{r.enable({...n,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent}),this._updateAncestors({...n,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(n){this._parent&&!n.onlySelf&&(this._parent.updateValueAndValidity(n),n.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(n){this._parent=n}getRawValue(){return this.value}updateValueAndValidity(n={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===Dg||this.status===_p)&&this._runAsyncValidator(n.emitEvent)),!1!==n.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!n.onlySelf&&this._parent.updateValueAndValidity(n)}_updateTreeValidity(n={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(n)),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Tg:Dg}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(n){if(this.asyncValidator){this.status=_p,this._hasOwnPendingAsyncValidator=!0;const e=Dk(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:n})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(n,e={}){this.errors=n,this._updateControlsErrors(!1!==e.emitEvent)}get(n){let e=n;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,i)=>r&&r._find(i),this)}getError(n,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[n]:null}hasError(n,e){return!!this.getError(n,e)}get root(){let n=this;for(;n._parent;)n=n._parent;return n}_updateControlsErrors(n){this.status=this._calculateStatus(),n&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(n)}_initObservables(){this.valueChanges=new Ia,this.statusChanges=new Ia}_calculateStatus(){return this._allControlsDisabled()?Tg:this.errors?f_:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(_p)?_p:this._anyControlsHaveStatus(f_)?f_:Dg}_anyControlsHaveStatus(n){return this._anyControls(e=>e.status===n)}_anyControlsDirty(){return this._anyControls(n=>n.dirty)}_anyControlsTouched(){return this._anyControls(n=>n.touched)}_updatePristine(n={}){this.pristine=!this._anyControlsDirty(),this._parent&&!n.onlySelf&&this._parent._updatePristine(n)}_updateTouched(n={}){this.touched=this._anyControlsTouched(),this._parent&&!n.onlySelf&&this._parent._updateTouched(n)}_registerOnCollectionChange(n){this._onCollectionChange=n}_setUpdateStrategy(n){p_(n)&&null!=n.updateOn&&(this._updateOn=n.updateOn)}_parentMarkedDirty(n){return!n&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(n){return null}_assignValidators(n){this._rawValidators=Array.isArray(n)?n.slice():n,this._composedValidatorFn=function ett(t){return Array.isArray(t)?Ew(t):t||null}(this._rawValidators)}_assignAsyncValidators(n){this._rawAsyncValidators=Array.isArray(n)?n.slice():n,this._composedAsyncValidatorFn=function ntt(t){return Array.isArray(t)?Cw(t):t||null}(this._rawAsyncValidators)}}const xp=new In("CallSetDisabledState",{providedIn:"root",factory:()=>m_}),m_="always";function Ng(t,n,e=m_){(function Nw(t,n){const e=function Rk(t){return t._rawValidators}(t);null!==n.validator?t.setValidators(Ok(e,n.validator)):"function"==typeof e&&t.setValidators([e]);const r=function Lk(t){return t._rawAsyncValidators}(t);null!==n.asyncValidator?t.setAsyncValidators(Ok(r,n.asyncValidator)):"function"==typeof r&&t.setAsyncValidators([r]);const i=()=>t.updateValueAndValidity();v_(n._rawValidators,i),v_(n._rawAsyncValidators,i)})(t,n),n.valueAccessor.writeValue(t.value),(t.disabled||"always"===e)&&n.valueAccessor.setDisabledState?.(t.disabled),function stt(t,n){n.valueAccessor.registerOnChange(e=>{t._pendingValue=e,t._pendingChange=!0,t._pendingDirty=!0,"change"===t.updateOn&&Hk(t,n)})}(t,n),function att(t,n){const e=(r,i)=>{n.valueAccessor.writeValue(r),i&&n.viewToModelUpdate(r)};t.registerOnChange(e),n._registerOnDestroy(()=>{t._unregisterOnChange(e)})}(t,n),function ott(t,n){n.valueAccessor.registerOnTouched(()=>{t._pendingTouched=!0,"blur"===t.updateOn&&t._pendingChange&&Hk(t,n),"submit"!==t.updateOn&&t.markAsTouched()})}(t,n),function itt(t,n){if(n.valueAccessor.setDisabledState){const e=r=>{n.valueAccessor.setDisabledState(r)};t.registerOnDisabledChange(e),n._registerOnDestroy(()=>{t._unregisterOnDisabledChange(e)})}}(t,n)}function v_(t,n){t.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(n)})}function Hk(t,n){t._pendingDirty&&t.markAsDirty(),t.setValue(t._pendingValue,{emitModelToViewChange:!1}),n.viewToModelUpdate(t._pendingValue),t._pendingChange=!1}function Xk(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}function Zk(t){return"object"==typeof t&&null!==t&&2===Object.keys(t).length&&"value"in t&&"disabled"in t}const Yk=class extends Gk{constructor(n=null,e,r){super(function Sw(t){return(p_(t)?t.validators:t)||null}(e),function Dw(t,n){return(p_(n)?n.asyncValidators:t)||null}(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(n),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),p_(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=Zk(n)?n.value:n)}setValue(n,e={}){this.value=this._pendingValue=n,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(n,e={}){this.setValue(n,e)}reset(n=this.defaultValue,e={}){this._applyFormState(n),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(n){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(n){this._onChange.push(n)}_unregisterOnChange(n){Xk(this._onChange,n)}registerOnDisabledChange(n){this._onDisabledChange.push(n)}_unregisterOnDisabledChange(n){Xk(this._onDisabledChange,n)}_forEachChild(n){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(n){Zk(n)?(this.value=this._pendingValue=n.value,n.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=n}},mtt={provide:Kh,useExisting:ei(()=>Rw)},Jk=(()=>Promise.resolve())();let Rw=(()=>{class t extends Kh{constructor(e,r,i,s,o,a){super(),this._changeDetectorRef=o,this.callSetDisabledState=a,this.control=new Yk,this._registered=!1,this.name="",this.update=new Ia,this._parent=e,this._setValidators(r),this._setAsyncValidators(i),this.valueAccessor=function Pw(t,n){if(!n)return null;let e,r,i;return Array.isArray(n),n.forEach(s=>{s.constructor===l_?e=s:function ctt(t){return Object.getPrototypeOf(t.constructor)===kd}(s)?r=s:i=s}),i||r||e||null}(0,s)}ngOnChanges(e){if(this._checkForErrors(),!this._registered||"name"in e){if(this._registered&&(this._checkName(),this.formDirective)){const r=e.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in e&&this._updateDisabled(e),function Mw(t,n){if(!t.hasOwnProperty("model"))return!1;const e=t.model;return!!e.isFirstChange()||!Object.is(n,e.currentValue)}(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){Ng(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){Jk.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(e){const r=e.isDisabled.currentValue,i=0!==r&&function Zf(t){return"boolean"==typeof t?t:null!=t&&"false"!==t}(r);Jk.then(()=>{i&&!this.control.disabled?this.control.disable():!i&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(e){return this._parent?function g_(t,n){return[...n.path,t]}(e,this._parent):[e]}static#t=this.\u0275fac=function(r){return new(r||t)(vn(cl,9),vn(Hu,10),vn(jh,10),vn(Zc,10),vn(F0,8),vn(xp,8))};static#e=this.\u0275dir=or({type:t,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[ra([mtt]),so,yl]})}return t})();const ytt={provide:Zc,useExisting:ei(()=>Lw),multi:!0};let Lw=(()=>{class t extends kd{writeValue(e){this.setProperty("value",e??"")}registerOnChange(e){this.onChange=r=>{e(""==r?null:parseFloat(r))}}static#t=this.\u0275fac=function(){let e;return function(i){return(e||(e=Au(t)))(i||t)}}();static#e=this.\u0275dir=or({type:t,selectors:[["input","type","number","formControlName",""],["input","type","number","formControl",""],["input","type","number","ngModel",""]],hostBindings:function(r,i){1&r&&_u("input",function(o){return i.onChange(o.target.value)})("blur",function(){return i.onTouched()})},features:[ra([ytt]),so]})}return t})(),tF=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({})}return t})(),ztt=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({imports:[tF]})}return t})(),Utt=(()=>{class t{static withConfig(e){return{ngModule:t,providers:[{provide:xp,useValue:e.callSetDisabledState??m_}]}}static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t});static#n=this.\u0275inj=$n({imports:[ztt]})}return t})();var Mr=y(5861),g=y(6300),cn=y(4251),_i=y(3062),Jn=y(8737),x_=y(6034);const vF={kernelName:cn.SYM,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,x_.N)((0,_i.p)(e,"float32"),-1))}}};var Va=y(3530),ac=y(5048),ju=y(8661),Ep=y(930),Pu=y(7527),$l=y(1191);const Wtt={kernelName:cn.VGw,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=(0,Pu.h)((0,_i.p)(e,"float32")),i=(0,Ep._)((0,$l.l)((0,ju.i)(1),r));return(0,ac.W)((0,Va.h)(t,i))}}}},Gtt={kernelName:cn.SpW,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=(0,Ep._)((0,$l.l)((0,Pu.h)((0,_i.p)(e,"float32")),1));return(0,Va.h)(t,r)}}}};var ko=y(3239),Dr=y(5715),jo=y(9929);const Htt={kernelName:cn.mm_,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=ko.assertAndGetBroadcastShape(e.shape,r.shape);return{a:()=>{let a=t;const u=ko.getReductionAxes(e.shape,i);return u.length>0&&(a=(0,jo.S)(a,u)),(0,Dr.X)(a,e.shape)},b:()=>{let a=t;const u=ko.getReductionAxes(r.shape,i);return u.length>0&&(a=(0,jo.S)(a,u)),(0,Dr.X)(a,r.shape)}}}},jtt={kernelName:cn.Xze,saveAllInputs:!0,gradFunc:(t,n)=>{const e={};return n.forEach((r,i)=>{e[i]=()=>t.clone()}),e}};var Ta=y(3143);const Ktt={kernelName:cn.sJF,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ta.P)(e)}}},Xtt={kernelName:cn.aJk,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Ta.P)(e)}}},Ztt={kernelName:cn.M2y,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Va.h)(t,(0,Ep._)((0,$l.l)((0,ju.i)(1),(0,Pu.h)((0,_i.p)(e,"float32")))))}}};var bc=y(7066);const Ytt={kernelName:cn.qw7,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=(0,Ep._)((0,bc.I)((0,ju.i)(1),(0,Pu.h)((0,_i.p)(e,"float32"))));return(0,Va.h)(t,r)}}}},Qtt={kernelName:cn.QCc,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,ko.assertAndGetBroadcastShape)(e.shape,r.shape);return{a:()=>{const a=(0,bc.I)((0,Pu.h)(e),(0,Pu.h)(r));let u=(0,Jn.d)(t,(0,Va.h)(r,a));const c=(0,ko.getReductionAxes)(e.shape,i);return c.length>0&&(u=(0,jo.S)(u,c)),(0,Dr.X)(u,e.shape)},b:()=>{const a=(0,bc.I)((0,Pu.h)(e),(0,Pu.h)(r));let u=(0,ac.W)((0,Jn.d)(t,(0,Va.h)(e,a)));const c=(0,ko.getReductionAxes)(r.shape,i);return c.length>0&&(u=(0,jo.S)(u,c)),(0,Dr.X)(u,r.shape)}}}},qtt={kernelName:cn.jMg,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Va.h)(t,(0,bc.I)((0,Pu.h)((0,_i.p)(e,"float32")),1))}}},Jtt={kernelName:cn.Oyi,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Va.h)(t,(0,$l.l)((0,ju.i)(1),(0,Pu.h)((0,_i.p)(e,"float32"))))}}};var wc=y(687),Yc=y(1257),Ps=y(5359),Xh=y(5551),Cp=y(4195);const eet=(0,Cp.op)({avgPool3dGrad_:function tet(t,n,e,r,i,s){const o=(0,Yc._1)(t,"dy","avgPool3dGrad"),a=(0,Yc._1)(n,"input","avgPool3dGrad");let u=o,c=a,d=!1;4===a.rank&&(d=!0,u=(0,Dr.X)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=(0,Dr.X)(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Ps.hu(5===u.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),Ps.hu(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),(0,Xh.m)("avgPool3dGrad",i,s);const x=wc.BV.runKernel(cn.IMb,{dy:u,input:c},{filterSize:e,strides:r,pad:i,dimRoundingMode:s});return d?(0,Dr.X)(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}}),net={kernelName:cn._k9,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:i,strides:s,pad:o,dimRoundingMode:a}=e;return{x:()=>eet(t,r,i,s,o,a)}}},iet=(0,Cp.op)({avgPoolGrad_:function ret(t,n,e,r,i){const s=(0,Yc._1)(t,"dy","avgPoolGrad"),o=(0,Yc._1)(n,"input","avgPoolGrad");Ps.hu(o.rank===s.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`);let a=o,u=s,c=!1;3===o.rank&&(c=!0,a=(0,Dr.X)(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=(0,Dr.X)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Ps.hu(4===u.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),Ps.hu(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const v=wc.BV.runKernel(cn.ROF,{dy:u,input:a},{filterSize:e,strides:r,pad:i});return c?(0,Dr.X)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),set={kernelName:cn.JhU,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{filterSize:i,strides:s,pad:o}=e;return{x:()=>iet(t,r,i,s,o)}}};var wh=y(5592);const oet={kernelName:cn.XLW,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{const[r,i]=n,{transposeA:s,transposeB:o}=e;return s||o?!s&&o?{a:()=>(0,wh.O)(t,i,!1,!1),b:()=>(0,wh.O)(t,r,!0,!1)}:s&&!o?{a:()=>(0,wh.O)(i,t,!1,!0),b:()=>(0,wh.O)(r,t,!1,!1)}:{a:()=>(0,wh.O)(i,t,!0,!0),b:()=>(0,wh.O)(t,r,!0,!0)}:{a:()=>(0,wh.O)(t,i,!1,!0),b:()=>(0,wh.O)(r,t,!0,!1)}}};var _F=y(9619);const aet={kernelName:cn.zws,gradFunc:(t,n,e)=>{const{blockShape:r,crops:i}=e;return{x:()=>(0,_F.f)(t,r,i)}}},uet={kernelName:cn.Ly9,gradFunc:(t,n,e)=>{const i=e.inputShape,s=e.shape,o=Array.from(s);for(let u=i.length-1;u>=0;u--)if(i[u]===s[u])o[u]=1;else if(1!==i[u])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${s}].`);const a=[];for(let u=0;u<o.length;u++)o[u]>1&&a.push(u);return{x:()=>(0,jo.S)(t,a,!0)}}},cet={kernelName:cn.RFZ,gradFunc:t=>({x:()=>t.clone()})},het={kernelName:cn.gJX,gradFunc:t=>({x:()=>(0,Ta.P)(t)})};var E_=y(9886),C_=y(2223),Uw=y(3080),Zh=y(2190);const det={kernelName:cn.xnO,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{clipValueMin:i,clipValueMax:s}=e;return{x:()=>(0,Zh.a)((0,Uw.H)((0,E_.b)(r,i),(0,C_.z)(r,s)),t,(0,Ta.P)(t))}}},fet={kernelName:cn.yj2,inputsToSave:["x"],gradFunc:vF.gradFunc};var xF=y(8874);const pet={kernelName:cn.Eh3,saveAllInputs:!0,gradFunc:(t,n,e)=>{const r=n.map(u=>u.shape),{axis:i}=e,s=(0,Ps.EC)(i,n[0].shape)[0],o=r.map(u=>u[s]);return(0,xF.V)(t,o,s).map(u=>()=>u)}};var EF=y(443),met=y(5743);const get={kernelName:cn.mhS,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,i]=n,{dilations:s,strides:o,pad:a,dataFormat:u}=e;return Ps.hu(Xh.I0(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>(0,met._)(r.shape,t,i,o,a,u),filter:()=>(0,EF.p)(r,t,i.shape,o,a,u)}}};var CF=y(4451);const yet={kernelName:cn.wm,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{const[r,i]=n,{strides:s,pad:o,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>(0,CF.T)(t,i,s,o,a,1,u),filter:()=>(0,EF.p)(t,r,i.shape,s,o,a,u)}}},_et=(0,Cp.op)({conv3DBackpropFilter_:function vet(t,n,e,r,i){let s=t;4===t.rank&&(s=(0,Dr.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=n;return 4===o.rank&&(o=(0,Dr.X)(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),Ps.hu(5===s.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),Ps.hu(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),Ps.hu(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),Ps.hu(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),Ps.hu(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),wc.BV.runKernel(cn.o2y,{x:s,dy:o},{strides:r,pad:i,filterShape:e})}});var xet=y(7022);const Eet={kernelName:cn.x12,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:i,pad:s}=e;Ps.hu((0,Xh.I0)(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=n;return{x:()=>(0,xet._)(o.shape,t,a,i,s),filter:()=>_et(o,t,a.shape,i,s)}}};var bF=y(2438);const Cet={kernelName:cn.mc4,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,ac.W)((0,bF.O)((0,_i.p)(e,"float32"))),t)}}};var wF=y(319);const bet={kernelName:cn.TR1,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,wF.R)((0,_i.p)(e,"float32")),t)}}};var Yh=y(929),IF=y(7157),$d=y(9194);const wet={kernelName:cn.iHb,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:i,exclusive:s,reverse:o}=e;return{x:()=>{const a=(0,Yh.Q3)([i],r.rank);let u=(0,IF.z)(t,i,s,!o);return null!=a&&(u=(0,$d.p)(u,a)),u}}}};var Iet=y(366),Det=y(519);const Tet={kernelName:cn.cie,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:r,strides:i,pad:s,dimRoundingMode:o}=e,a=r??[1,1];Ps.hu(Xh.I0(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[u,c]=n;return Ps.hu(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),Ps.hu(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),Ps.hu(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),Ps.hu(Xh.jT(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),Xh.m("depthwiseConv2d",s,o),{x:()=>(0,Det.v)(u.shape,t,c,i,s,a,o),filter:()=>(0,Iet.z)(u,t,c.shape,i,s,a,o)}}},Net={kernelName:cn.p4S,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[r,i]=n,s={x:r,filter:i,dy:t},o={x:r,filter:i,dy:t};return{x:()=>wc.BV.runKernel(cn.ekb,s,e),filter:()=>wc.BV.runKernel(cn.Vn9,o,e)}}},Aet={kernelName:cn.SX0,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n,r={dy:t,y:e};return{x:()=>wc.BV.runKernel(cn.HEU,r)}}};var Mg=y(5109);const Met={kernelName:cn.Omj,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=(0,Jn.d)((0,Mg.Q)((0,ac.W)((0,Pu.h)(e))),2/Math.sqrt(Math.PI));return{x:()=>(0,Jn.d)(t,r)}}},Pet={kernelName:cn.NEP,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,e)}}},Oet={kernelName:cn.YFo,inputsToSave:["input"],gradFunc:(t,n)=>{const[e]=n;return{input:()=>(0,Dr.X)(t,e.shape)}}},Ret={kernelName:cn.Y0y,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,Mg.Q)(e))}}},Let={kernelName:cn.OR,gradFunc:t=>({x:()=>(0,Ta.P)(t)})},ket={kernelName:cn.jeX,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,ko.assertAndGetBroadcastShape)(e.shape,r.shape);return{a:()=>{const a=(0,Va.h)(t,(0,_i.p)(r,"float32")),u=(0,ko.getReductionAxes)(e.shape,i);return u.length>0?(0,Dr.X)((0,jo.S)(a,u),e.shape):a},b:()=>{let a=(0,Jn.d)(t,(0,_i.p)(e,"float32"));const u=(0,ko.getReductionAxes)(r.shape,i);u.length>0&&(a=(0,Dr.X)((0,jo.S)(a,u),r.shape));const c=(0,Pu.h)(r);return(0,ac.W)((0,Va.h)(a,(0,_i.p)(c,"float32")))}}}};var SF=y(8893),DF=y(2005);const Fet={kernelName:cn.sHE,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{const{varianceEpsilon:r}=e,[i,s,o,a]=n,u=a??(0,ju.i)(1),c=(0,ko.getReductionAxes)(s.shape,i.shape),d=[];if(1===s.rank){for(let J=0;J<i.shape.length-1;++J)d.push(i.shape[J]);d.push(1)}const p=(0,$l.l)(i,s),v=(0,Jn.d)(t,u),x=(0,SF.b)((0,bc.I)(o,(0,ju.i)(r))),b=(0,Jn.d)((0,Jn.d)((0,Jn.d)(x,x),x),(0,ju.i)(-.5));return{x:()=>(0,Dr.X)((0,Jn.d)((0,Jn.d)(t,1===s.rank?(0,DF.G)((0,Dr.X)(x,[1,1,1,s.shape[0]]),d):x),u),i.shape),mean:()=>{let J=(0,Jn.d)((0,Jn.d)(x,(0,ju.i)(-1)),v);return 1===s.rank&&(J=(0,jo.S)(J,c)),(0,Dr.X)(J,s.shape)},variance:()=>{let J=(0,Jn.d)((0,Jn.d)(b,p),v);return 1===s.rank&&(J=(0,jo.S)(J,c)),(0,Dr.X)(J,s.shape)},scale:()=>{const J=(0,Jn.d)(p,x);let ht=(0,Jn.d)(t,J);return 1===s.rank&&(ht=(0,jo.S)(ht,c)),(0,Dr.X)(ht,s.shape)},offset:()=>{let J=t;return 1===s.rank&&(J=(0,jo.S)(J,c)),(0,Dr.X)(J,s.shape)}}}};var Ww=y(7958),TF=y(7715);const $et={kernelName:cn.qi_,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{const[r,i]=n,{axis:s,batchDims:o}=e,a=(0,Ps.EC)(s,r.shape)[0],u=(c,d,p)=>()=>{const v=c.shape,x=d.size,b=v.slice(0,a),w=b.length,T=v.slice(s,v.length).slice(1),N=T.length,S=NF(0,w),U=NF(w+1,w+1+N),J=AF([b,[x],T]),ht=(0,Dr.X)(p,J),Tt=(0,Dr.X)(d,[x]),Pt=AF([[w],S,U]),zt=(0,$d.p)(ht,Pt);let Ot=(0,TF.p)(zt,Tt,c.shape[a]);const le=(0,Yh.LJ)(Pt);return Ot=(0,$d.p)(Ot,le),Ot};if(1===o){const d=r.split(r.shape[0],0);return{x:()=>(0,Ww.k)(d.map((x,b)=>u(x,i.slice(b,1),t.slice(b,1))())).reshape(r.shape),indices:()=>i}}return{x:u(r,i,t),indices:()=>i}}};function NF(t,n){const e=[];for(let r=t;r<n;++r)e.push(r);return e}function AF(t){const n=[];for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r)n.push(t[e][r]);return n}const Bet={kernelName:cn.Acj,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>(0,Ta.P)(e),b:()=>(0,Ta.P)(r)}}},zet={kernelName:cn.iJz,gradFunc:t=>({x:()=>(0,_i.p)(t,"float32")})},Vet={kernelName:cn.avt,gradFunc:t=>({x:()=>(0,Ta.P)(t)})},Uet={kernelName:cn.iWB,gradFunc:t=>({x:()=>(0,Ta.P)(t)})},Wet={kernelName:cn.r7n,gradFunc:t=>({x:()=>(0,Ta.P)(t)})};var bp=y(4803);const Get={kernelName:cn.J$2,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{alpha:i}=e,s=(0,bp.p)(r,0);return{x:()=>(0,Zh.a)(s,t,(0,Jn.d)(t,i))}}},Het={kernelName:cn.kU,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Va.h)(t,(0,bc.I)(e,1))}}},jet={kernelName:cn.ZbH,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Va.h)(t,(0,_i.p)(e,"float32"))}}},Ket={kernelName:cn.qCd,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{axis:i}=e;return{logits:()=>{const o=(0,Mg.Q)(r);return(0,$l.l)(t,(0,Jn.d)((0,jo.S)(t,i,!0),o))}}}},Zet=(0,Cp.op)({localResponseNormalizationBackprop_:function Xet(t,n,e,r=5,i=1,s=1,o=.5){return wc.BV.runKernel(cn.Hhh,{x:t,y:n,dy:e},{depthRadius:r,bias:i,alpha:s,beta:o})}}),Yet={kernelName:cn.eZ0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,i]=n,{depthRadius:s,bias:o,alpha:a,beta:u}=e;return{x:()=>Zet(r,i,t,s,o,a,u)}}};var MF=y(4456);function PF(t,n,e,r){return n.rank<e.rank&&(n=(0,Dr.X)(n,Yh.rv(n.shape,r))),t.rank<e.rank&&(t=(0,Dr.X)(t,Yh.rv(t.shape,r))),{x:()=>(0,Jn.d)(t,(0,_i.p)((0,MF.D)(e,n),t.dtype))}}const OF={kernelName:cn.YoZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{reductionIndices:i}=r,s=n[0],u=PF(t,n[1],s,Ps.EC(i,s.shape));return{x:()=>u.x()}}};var RF=y(2761);const Qet={kernelName:cn.BMI,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>(0,Jn.d)(t,(0,_i.p)((0,E_.b)(e,r),"float32")),b:()=>(0,Jn.d)(t,(0,_i.p)((0,RF.d)(e,r),"float32"))}}},Jet=(0,Cp.op)({maxPool3dGrad_:function qet(t,n,e,r,i,s,o){const a=(0,Yc._1)(t,"dy","maxPool3dGrad"),u=(0,Yc._1)(n,"input","maxPool3dGrad"),c=(0,Yc._1)(e,"output","maxPool3dGrad");let d=a,p=u,v=c,x=!1;4===u.rank&&(x=!0,d=(0,Dr.X)(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=(0,Dr.X)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),v=(0,Dr.X)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Ps.hu(5===d.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),Ps.hu(5===p.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),Ps.hu(5===v.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${v.rank}.`),(0,Xh.m)("maxPool3dGrad",s,o);const T=wc.BV.runKernel(cn.OU7,{dy:d,input:p,output:v},{filterSize:r,strides:i,pad:s,dimRoundingMode:o});return x?(0,Dr.X)(T,[T.shape[1],T.shape[2],T.shape[3],T.shape[4]]):T}}),tnt={kernelName:cn.OAf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,i]=n,{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=e;return{x:()=>Jet(t,r,i,s,o,a,u)}}},nnt=(0,Cp.op)({maxPoolGrad_:function ent(t,n,e,r,i,s,o){const a=(0,Yc._1)(t,"dy","maxPoolGrad"),u=(0,Yc._1)(n,"input","maxPoolGrad"),c=(0,Yc._1)(e,"output","maxPoolGrad");return Ps.hu(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),Ps.hu(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),Ps.hu(4===u.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Xh.m("maxPoolGrad",s,o),wc.BV.runKernel(cn.OV7,{dy:a,input:u,output:c},{filterSize:r,strides:i,pad:s,dimRoundingMode:o})}}),rnt={kernelName:cn.mTV,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r,i]=n,{filterSize:s,strides:o,pad:a}=e;return{x:()=>nnt(t,r,i,s,o,a)}}};var Gw=y(4968);const int={kernelName:cn.q2K,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:i}=e,s=Ps.EC(i,r.shape),a=(0,Yh.kz)(r.shape,s)[1],u=Ps.NA(a);return{x:()=>{const d=r.shape.slice();s.forEach(x=>{d[x]=1});const p=(0,Dr.X)(t,d);return(0,Va.h)((0,Jn.d)(p,(0,Gw.i)(r.shape,"float32")),u)}}}},snt={kernelName:cn.c17,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{const r=e,{axis:i}=r,[s,o]=n,u=PF(t,o,s,Ps.EC(i,s.shape));return{x:()=>u.x()}}},ont={kernelName:cn.q8u,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n;return{a:()=>(0,Jn.d)(t,(0,_i.p)((0,C_.z)(e,r),"float32")),b:()=>(0,Jn.d)(t,(0,_i.p)((0,bp.p)(e,r),"float32"))}}};var Bd=y(8317);const ant={kernelName:cn.jQs,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:i}=e,s=i.map(o=>o[0]);return{x:()=>(0,Bd.t)(t,s,r.shape)}}};var LF=y(8208);const unt={kernelName:cn.Vbg,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,ko.assertAndGetBroadcastShape)(e.shape,r.shape);return{a:()=>{const a=(0,ko.getReductionAxes)(e.shape,i);return a.length>0?(0,Dr.X)((0,jo.S)(t,a),e.shape):t},b:()=>{const a=(0,Jn.d)(t,(0,ac.W)((0,LF.G)((0,Va.h)(e,r)))),u=(0,ko.getReductionAxes)(r.shape,i);return u.length>0?(0,Dr.X)((0,jo.S)(a,u),r.shape):a}}}},lnt={kernelName:cn.wYn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,ko.assertAndGetBroadcastShape)(e.shape,r.shape);return{a:()=>{const a=(0,Jn.d)(t,(0,_i.p)(r,"float32")),u=(0,ko.getReductionAxes)(e.shape,i);return u.length>0?(0,Dr.X)((0,jo.S)(a,u),e.shape):a},b:()=>{const a=(0,Jn.d)(t,(0,_i.p)(e,"float32")),u=(0,ko.getReductionAxes)(r.shape,i);return u.length>0?(0,Dr.X)((0,jo.S)(a,u),r.shape):a}}}},cnt={kernelName:cn.kuV,gradFunc:t=>({x:()=>(0,ac.W)(t)})};var hnt=y(6467);const dnt={kernelName:cn.we_,inputsToSave:["indices"],gradFunc:(t,n)=>{const e=n[0];return{indices:()=>(0,hnt.l)(e.shape,"float32")}}},fnt={kernelName:cn.qWM,gradFunc:t=>({x:()=>(0,Ta.P)(t)})};var kF=y(2219);const pnt={kernelName:cn.QiL,saveAllInputs:!0,gradFunc:(t,n,e)=>{const{axis:r}=e;return(0,kF.H)(t,r).map(s=>()=>s)}},FF={kernelName:cn.lyA,inputsToSave:["x"],gradFunc:(t,n,e)=>{const r=n[0],{paddings:i}=e,s=i.map(o=>o[0]);return{x:()=>(0,Bd.t)(t,s,r.shape)}}};var $F=y(5919),Hw=y(2962);const mnt={kernelName:cn.pe_,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,n)=>{const[e,r,i]=n,s=e,o=r,a=ko.assertAndGetBroadcastShape(s.shape,o.shape);return{a:()=>{const d=(0,_i.p)(o,"float32");let p=(0,Jn.d)(t,(0,Jn.d)(d,(0,Hw.s)(s,(0,$l.l)(d,(0,ju.i)(1)))));const v=ko.getReductionAxes(s.shape,a);return v.length>0&&(p=(0,jo.S)(p,v)),(0,Dr.X)(p,s.shape)},b:()=>{const d=(0,bp.p)(s,0),p=(0,Zh.a)(d,(0,$F.c)(s),(0,Ta.P)(s));let v=(0,Jn.d)(t,(0,Jn.d)(i,p));const x=ko.getReductionAxes(o.shape,a);return x.length>0&&(v=(0,jo.S)(v,x)),(0,Dr.X)(v,o.shape)}}}},gnt={kernelName:cn.o0g,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,bp.p)(e,0);return{x:()=>(0,Zh.a)(i,t,(0,Jn.d)(t,r)),alpha:()=>{let s=(0,Zh.a)(i,(0,Ta.P)(t),(0,Jn.d)(t,e));const o=(0,ko.getReductionAxes)(r.shape,t.shape);return o.length>0&&(s=(0,jo.S)(s,o)),(0,Dr.X)(s,r.shape)}}}};var jw=y(9267);const _nt={kernelName:cn.DlI,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{axis:i}=e;let s=[];return s=null==i?r.shape.map((o,a)=>a):"number"==typeof i?[i]:i,{x:()=>function vnt(t,n,e){const r=t.shape.length,i=r-e.length,s=Yh.Q3(e,r);let o=t;null!=s&&(o=(0,$d.p)(t,s));const a=o.shape.slice(),c=a.splice(r-e.length,e.length).reduce((v,x)=>v*x,1);a.push(c);let p=function ynt(t,n,e){const r=t.shape.slice();r[e]=1;const i=(0,Dr.X)(n,r),s=(0,jw.$)(t,e,!0,!1),o=(0,jw.$)(t,e,!0,!0),a=(0,Jn.d)(s,o);return(0,Jn.d)(i,a)}(o.reshape(a),n,i);if(p=p.reshape(o.shape),null!=s){const v=Yh.LJ(s);p=(0,$d.p)(p,v)}return p}(r,t,s)}}},xnt={kernelName:cn.oHH,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=ko.assertAndGetBroadcastShape(e.shape,r.shape);return{a:()=>{const a=(0,Va.h)(t,(0,_i.p)(r,"float32")),u=ko.getReductionAxes(e.shape,i);return u.length>0?(0,Dr.X)((0,jo.S)(a,u),e.shape):a},b:()=>{let a=(0,Jn.d)(t,(0,_i.p)(e,"float32"));const u=ko.getReductionAxes(r.shape,i);u.length>0&&(a=(0,Dr.X)((0,jo.S)(a,u),r.shape));const c=(0,Pu.h)(r);return(0,ac.W)((0,Va.h)(a,(0,_i.p)(c,"float32")))}}}},Ent={kernelName:cn.$HU,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Va.h)(t,(0,ac.W)((0,Pu.h)(e)))}}},Cnt={kernelName:cn.SbG,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n,r=(0,Jn.d)((0,C_.z)(e,6),(0,x_.N)(e));return{x:()=>(0,Jn.d)(t,(0,_i.p)(r,"float32"))}}},bnt={kernelName:cn.qkr,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,_i.p)((0,x_.N)(e),"float32"))}}},wnt={kernelName:cn.HZH,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Dr.X)(t,e.shape)}}},Int={kernelName:cn._Yw,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,i={dy:t,images:r};return{images:()=>wc.BV.runKernel(cn.zbQ,i,e)}}},Snt={kernelName:cn.dpD,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[r]=n,i={dy:t,images:r};return{images:()=>wc.BV.runKernel(cn.Hmb,i,e)}}};var BF=y(6825);const Dnt={kernelName:cn.mKl,gradFunc:(t,n,e)=>{const{dims:r}=e,i=(0,Ps.EC)(r,t.shape);return{x:()=>(0,BF.G)(t,i)}}},Tnt={kernelName:cn.e07,gradFunc:t=>({x:()=>(0,Ta.P)(t)})},Nnt={kernelName:cn.bV0,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,ac.W)((0,Va.h)(t,(0,Jn.d)((0,Hw.s)(e,1.5),2)))}}};var zF=y(6399);const Ant={kernelName:cn.PhF,inputsToSave:["condition"],gradFunc:(t,n)=>{const[e]=n;return{condition:()=>(0,_i.p)((0,Ta.P)(e),"float32"),t:()=>(0,Jn.d)(t,(0,_i.p)(e,t.dtype)),e:()=>(0,Jn.d)(t,(0,_i.p)((0,zF.h)(e),t.dtype))}}};var VF=y(2152);const Mnt={kernelName:cn.oFR,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const r=(0,bp.p)(e,(0,ju.i)(0)),i=(0,ju.i)(VF.y),s=(0,ju.i)(VF.$),o=(0,Jn.d)(t,s),a=(0,Jn.d)((0,Jn.d)(t,i),(0,Mg.Q)((0,_i.p)(e,"float32")));return(0,Zh.a)(r,o,a)}}}},Pnt={kernelName:cn.a5O,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,Jn.d)(e,(0,$l.l)((0,ju.i)(1),e)))}}},Ont={kernelName:cn.i5y,gradFunc:t=>({x:()=>(0,Ta.P)(t)})};var Kw=y(9018);const Rnt={kernelName:cn.RQH,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,Kw.m)((0,_i.p)(e,"float32")),t)}}};var UF=y(3237);const Lnt={kernelName:cn.wYB,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,UF.f)((0,_i.p)(e,"float32")),t)}}};var WF=y(404),knt=y(2320);const Fnt={kernelName:cn.p2w,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{begin:i,size:s}=e,o=r.shape,[a,u]=(0,knt.parseSliceParams)(r,i,s),c=[];for(let d=0;d<t.rank;d++)c.push([a[d],o[d]-a[d]-u[d]]);return{x:()=>(0,WF.v)(t,c)}}},$nt={kernelName:cn.Gcp,outputsToSave:[!0],gradFunc:(t,n,e)=>{const[r]=n,{dim:i}=e,o=(0,Jn.d)(t,r);return{logits:()=>(0,$l.l)(o,(0,Jn.d)((0,jo.S)(o,[i],!0),r))}}};var GF=y(6139);const Bnt={kernelName:cn.MRv,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,GF.X)(e))}}};var HF=y(2782);const jF={kernelName:cn.TQc,gradFunc:(t,n,e)=>{const{blockShape:r,paddings:i}=e;return{x:()=>(0,HF.E)(t,r,i)}}};var KF=y(4111);const XF={kernelName:cn.L8s,gradFunc:(t,n,e)=>{const{axis:r}=e;return{x:()=>(0,KF.z)(t,r)}}},znt={kernelName:cn.FKq,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Va.h)(t,(0,Jn.d)((0,Ep._)((0,_i.p)(e,"float32")),2))}}},Vnt={kernelName:cn.bK0,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)(t,(0,Jn.d)((0,_i.p)(e,"float32"),2))}}},Unt={kernelName:cn._tC,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=(0,ju.i)(2);return{a:()=>(0,Jn.d)(t,(0,Jn.d)(i,(0,$l.l)(e,r))),b:()=>(0,Jn.d)(t,(0,Jn.d)(i,(0,$l.l)(r,e)))}}},Wnt={kernelName:cn.h8e,gradFunc:t=>({x:()=>(0,Ta.P)(t)})},Gnt={kernelName:cn.Tr8,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,r]=n,i=ko.assertAndGetBroadcastShape(e.shape,r.shape);return{a:()=>{let a=t;const u=ko.getReductionAxes(e.shape,i);return u.length>0&&(a=(0,jo.S)(a,u)),(0,Dr.X)(a,e.shape)},b:()=>{let a=t;const u=ko.getReductionAxes(r.shape,i);return u.length>0&&(a=(0,jo.S)(a,u)),(0,Dr.X)((0,ac.W)(a),r.shape)}}}},Hnt={kernelName:cn.GBy,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,i=r.shape.slice(),{axis:s}=e;(0,Ps.EC)(s,r.shape).forEach(c=>{i[c]=1});const a=(0,Dr.X)(t,i),u=(0,Jn.d)(a,(0,Gw.i)(r.shape,"float32"));return{x:()=>u}}},jnt={kernelName:cn.sEM,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Va.h)(t,(0,Pu.h)((0,Kw.m)(e)))}}},Knt={kernelName:cn.MIZ,outputsToSave:[!0],gradFunc:(t,n)=>{const[e]=n;return{x:()=>(0,Jn.d)((0,$l.l)((0,ju.i)(1),(0,Pu.h)(e)),t)}}},Xnt={kernelName:cn.n9L,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[r]=n,{reps:i}=e;return{x:()=>{let o=(0,Ta.P)(r);if(1===r.rank)for(let a=0;a<i[0];++a)o=(0,bc.I)(o,(0,Bd.t)(t,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)o=(0,bc.I)(o,(0,Bd.t)(t,[a*r.shape[0],u*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)for(let c=0;c<i[2];++c)o=(0,bc.I)(o,(0,Bd.t)(t,[a*r.shape[0],u*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<i[0];++a)for(let u=0;u<i[1];++u)for(let c=0;c<i[2];++c)for(let d=0;d<i[3];++d)o=(0,bc.I)(o,(0,Bd.t)(t,[a*r.shape[0],u*r.shape[1],c*r.shape[2],d*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return o}}}},Znt={kernelName:cn.G3Y,gradFunc:(t,n,e)=>{const r=e,{perm:i}=r,s=Yh.LJ(i);return{x:()=>(0,$d.p)(t,s)}}},Ynt={kernelName:cn.ToN,gradFunc:(t,n,e)=>{const r=e,{axis:i}=r;return{value:()=>(0,Ww.k)(t,i)}}};var ZF=y(7228),YF=y(6117),QF=y(765);const Qnt={kernelName:cn.Qvg,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>function qnt(t,n){const e=(0,QF.g)(n,(0,Ta.P)(n)),r=(0,YF.I)(t,e);let i=(0,E_.b)(n,(0,ju.i)(0,"int32"));const s=r.rank-i.rank;for(let a=0;a<s;++a)i=(0,ZF.d)(i,a+1);i=(0,Uw.H)(i,(0,Gw.i)(r.shape,"bool"));const o=(0,Ta.P)(r);return(0,Zh.a)(i,r,o)}(t,e)}}},Jnt={kernelName:cn.RuY,gradFunc:t=>({x:()=>(0,Ta.P)(t)})};var trt=y(8987);const ert=[vF,Wtt,Gtt,Htt,jtt,Ktt,Xtt,Ztt,Ytt,Qtt,qtt,Jtt,net,set,oet,aet,uet,cet,het,det,fet,pet,yet,get,Eet,Cet,bet,wet,Tet,Net,xnt,Aet,Met,Pet,Oet,Ret,ket,Let,Fet,$et,Bet,zet,Vet,Uet,Wet,Get,Het,jet,Ket,Yet,OF,OF,Qet,tnt,rnt,int,snt,ont,ant,unt,lnt,cnt,dnt,fnt,pnt,FF,FF,mnt,gnt,_nt,Ent,Cnt,bnt,wnt,Int,Snt,Dnt,Tnt,Nnt,Ant,Mnt,Pnt,Ont,Rnt,Lnt,Fnt,$nt,Bnt,jF,jF,XF,XF,znt,Unt,Vnt,Wnt,Gnt,Hnt,jnt,Knt,Xnt,Znt,Ynt,Qnt,Jnt];for(const t of ert)(0,trt.Li)(t);var nrt=y(6989),Ze=y(4945);(0,Ze.t3)().prototype.abs=function(){return this.throwIfDisposed(),(0,nrt.W)(this)};var rrt=y(1184);(0,Ze.t3)().prototype.acos=function(){return this.throwIfDisposed(),(0,rrt.K)(this)};var irt=y(5622);(0,Ze.t3)().prototype.acosh=function(){return this.throwIfDisposed(),(0,irt._)(this)},(0,Ze.t3)().prototype.add=function(t){return this.throwIfDisposed(),(0,bc.I)(this,t)};var srt=y(1862);(0,Ze.t3)().prototype.all=function(t,n){return this.throwIfDisposed(),(0,srt.$)(this,t,n)};var ort=y(876);(0,Ze.t3)().prototype.any=function(t,n){return this.throwIfDisposed(),(0,ort.Y)(this,t,n)};var art=y(5784);(0,Ze.t3)().prototype.argMax=function(t){return this.throwIfDisposed(),(0,art.N)(this,t)};var urt=y(8340);(0,Ze.t3)().prototype.argMin=function(t){return this.throwIfDisposed(),(0,urt.v)(this,t)},(0,Ze.t3)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,Ps.hu)(1===this.size,()=>"The array must have only 1 element."),(0,Dr.X)(this,[])},(0,Ze.t3)().prototype.asType=function(t){return this.throwIfDisposed(),(0,_i.p)(this,t)},(0,Ze.t3)().prototype.as1D=function(){return this.throwIfDisposed(),(0,Dr.X)(this,[this.size])},(0,Ze.t3)().prototype.as2D=function(t,n){return this.throwIfDisposed(),(0,Dr.X)(this,[t,n])},(0,Ze.t3)().prototype.as3D=function(t,n,e){return this.throwIfDisposed(),(0,Dr.X)(this,[t,n,e])},(0,Ze.t3)().prototype.as4D=function(t,n,e,r){return this.throwIfDisposed(),(0,Dr.X)(this,[t,n,e,r])},(0,Ze.t3)().prototype.as5D=function(t,n,e,r,i){return this.throwIfDisposed(),(0,Dr.X)(this,[t,n,e,r,i])};var lrt=y(586);(0,Ze.t3)().prototype.asin=function(){return this.throwIfDisposed(),(0,lrt.Z)(this)};var crt=y(8355);(0,Ze.t3)().prototype.asinh=function(){return this.throwIfDisposed(),(0,crt.V)(this)};var hrt=y(7881);(0,Ze.t3)().prototype.atan=function(){return this.throwIfDisposed(),(0,hrt.z)(this)};var drt=y(5825);(0,Ze.t3)().prototype.atan2=function(t){return this.throwIfDisposed(),(0,drt.f)(this,t)};var frt=y(7932);(0,Ze.t3)().prototype.atanh=function(){return this.throwIfDisposed(),(0,frt.C)(this)};var prt=y(6903);(0,Ze.t3)().prototype.avgPool=function(t,n,e,r){return this.throwIfDisposed(),(0,prt.w)(this,t,n,e,r)},(0,Ze.t3)().prototype.batchToSpaceND=function(t,n){return this.throwIfDisposed(),(0,HF.E)(this,t,n)};var mrt=y(5307);(0,Ze.t3)().prototype.batchNorm=function(t,n,e,r,i){return this.throwIfDisposed(),(0,mrt.t)(this,t,n,e,r,i)};var grt=y(983);(0,Ze.t3)().prototype.broadcastTo=function(t){return this.throwIfDisposed(),(0,grt.U)(this,t)},(0,Ze.t3)().prototype.cast=function(t){return this.throwIfDisposed(),(0,_i.p)(this,t)};var yrt=y(9723);(0,Ze.t3)().prototype.ceil=function(){return this.throwIfDisposed(),(0,yrt.m)(this)};var vrt=y(6672);(0,Ze.t3)().prototype.clipByValue=function(t,n){return this.throwIfDisposed(),(0,vrt.i)(this,t,n)},(0,Ze.t3)().prototype.concat=function(t,n){return this.throwIfDisposed(),t instanceof Ze.es&&(t=[t]),(0,KF.z)([this,...t],n)};var _rt=y(8577);(0,Ze.t3)().prototype.conv1d=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,_rt.P)(this,t,n,e,r,i,s)};var xrt=y(8554);(0,Ze.t3)().prototype.conv2dTranspose=function(t,n,e,r,i){return this.throwIfDisposed(),(0,xrt.b)(this,t,n,e,r,i)},(0,Ze.t3)().prototype.conv2d=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,CF.T)(this,t,n,e,r,i,s)},(0,Ze.t3)().prototype.cos=function(){return this.throwIfDisposed(),(0,Kw.m)(this)},(0,Ze.t3)().prototype.cosh=function(){return this.throwIfDisposed(),(0,UF.f)(this)},(0,Ze.t3)().prototype.cumprod=function(t,n,e){return this.throwIfDisposed(),(0,jw.$)(this,t,n,e)},(0,Ze.t3)().prototype.cumsum=function(t,n,e){return this.throwIfDisposed(),(0,IF.z)(this,t,n,e)};var Ert=y(3961);(0,Ze.t3)().prototype.depthToSpace=function(t,n){return this.throwIfDisposed(),(0,Ert.n)(this,t,n)};var Crt=y(1172);(0,Ze.t3)().prototype.depthwiseConv2d=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,Crt.B)(this,t,n,e,r,i,s)};var brt=y(2395);(0,Ze.t3)().prototype.dilation2d=function(t,n,e,r,i){return this.throwIfDisposed(),(0,brt.W)(this,t,n,e,r,i)};var wrt=y(4373);(0,Ze.t3)().prototype.divNoNan=function(t){return this.throwIfDisposed(),(0,wrt.N)(this,t)},(0,Ze.t3)().prototype.div=function(t){return this.throwIfDisposed(),(0,Va.h)(this,t)};var Irt=y(5106);(0,Ze.t3)().prototype.dot=function(t){return this.throwIfDisposed(),(0,Irt.A)(this,t)};var Srt=y(9529);(0,Ze.t3)().prototype.elu=function(){return this.throwIfDisposed(),(0,Srt.p)(this)},(0,Ze.t3)().prototype.equal=function(t){return this.throwIfDisposed(),(0,MF.D)(this,t)};var Drt=y(4634);(0,Ze.t3)().prototype.erf=function(){return this.throwIfDisposed(),(0,Drt.q)(this)};var Trt=y(4279);(0,Ze.t3)().prototype.euclideanNorm=function(t,n){return this.throwIfDisposed(),(0,Trt.d)(this,t,n)},(0,Ze.t3)().prototype.exp=function(){return this.throwIfDisposed(),(0,Mg.Q)(this)},(0,Ze.t3)().prototype.expandDims=function(t){return this.throwIfDisposed(),(0,ZF.d)(this,t)};var Nrt=y(5748);(0,Ze.t3)().prototype.expm1=function(){return this.throwIfDisposed(),(0,Nrt.t)(this)};var Art=y(9738);(0,Ze.t3)().prototype.fft=function(){return this.throwIfDisposed(),(0,Art.k)(this)},(0,Ze.t3)().prototype.flatten=function(){return this.throwIfDisposed(),(0,Dr.X)(this,[this.size])},(0,Ze.t3)().prototype.floor=function(){return this.throwIfDisposed(),(0,LF.G)(this)};var Mrt=y(1030);(0,Ze.t3)().prototype.floorDiv=function(t){return this.throwIfDisposed(),(0,Mrt.q)(this,t)},(0,Ze.t3)().prototype.gather=function(t,n,e){return this.throwIfDisposed(),(0,YF.I)(this,t,n,e)},(0,Ze.t3)().prototype.greaterEqual=function(t){return this.throwIfDisposed(),(0,E_.b)(this,t)},(0,Ze.t3)().prototype.greater=function(t){return this.throwIfDisposed(),(0,bp.p)(this,t)};var Prt=y(527);(0,Ze.t3)().prototype.ifft=function(){return this.throwIfDisposed(),(0,Prt.S)(this)};var Ort=y(6065);(0,Ze.t3)().prototype.irfft=function(){return this.throwIfDisposed(),(0,Ort.w)(this)};var Rrt=y(8821);(0,Ze.t3)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,Rrt.x)(this)};var Lrt=y(8381);(0,Ze.t3)().prototype.isInf=function(){return this.throwIfDisposed(),(0,Lrt.U)(this)};var krt=y(6483);(0,Ze.t3)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,krt.i)(this)};var Frt=y(9424);(0,Ze.t3)().prototype.leakyRelu=function(t){return this.throwIfDisposed(),(0,Frt.h)(this,t)},(0,Ze.t3)().prototype.lessEqual=function(t){return this.throwIfDisposed(),(0,C_.z)(this,t)},(0,Ze.t3)().prototype.less=function(t){return this.throwIfDisposed(),(0,RF.d)(this,t)};var $rt=y(1523);(0,Ze.t3)().prototype.localResponseNormalization=function(t,n,e,r){return this.throwIfDisposed(),(0,$rt.G)(this,t,n,e,r)};var Brt=y(4034);(0,Ze.t3)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,Brt.e)(this)};var zrt=y(6455);(0,Ze.t3)().prototype.logSoftmax=function(t){return this.throwIfDisposed(),(0,zrt.C)(this,t)};var Vrt=y(6735);(0,Ze.t3)().prototype.logSumExp=function(t,n){return this.throwIfDisposed(),(0,Vrt.l)(this,t,n)},(0,Ze.t3)().prototype.log=function(){return this.throwIfDisposed(),(0,$F.c)(this)};var Urt=y(4088);(0,Ze.t3)().prototype.log1p=function(){return this.throwIfDisposed(),(0,Urt.K)(this)},(0,Ze.t3)().prototype.logicalAnd=function(t){return this.throwIfDisposed(),(0,Uw.H)(this,t)},(0,Ze.t3)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,zF.h)(this)};var Wrt=y(2693);(0,Ze.t3)().prototype.logicalOr=function(t){return this.throwIfDisposed(),(0,Wrt.K)(this,t)};var Grt=y(4574);(0,Ze.t3)().prototype.logicalXor=function(t){return this.throwIfDisposed(),(0,Grt.e)(this,t)},(0,Ze.t3)().prototype.matMul=function(t,n,e){return this.throwIfDisposed(),(0,wh.O)(this,t,n,e)};var Hrt=y(2444);(0,Ze.t3)().prototype.maxPool=function(t,n,e,r){return this.throwIfDisposed(),(0,Hrt._)(this,t,n,e,r)};var jrt=y(3043);(0,Ze.t3)().prototype.max=function(t,n){return this.throwIfDisposed(),(0,jrt.F)(this,t,n)},(0,Ze.t3)().prototype.maximum=function(t){return this.throwIfDisposed(),(0,QF.g)(this,t)};var Krt=y(9357);(0,Ze.t3)().prototype.mean=function(t,n){return this.throwIfDisposed(),(0,Krt.J)(this,t,n)};var Xrt=y(9602);(0,Ze.t3)().prototype.min=function(t,n){return this.throwIfDisposed(),(0,Xrt.V)(this,t,n)};var Zrt=y(2684);(0,Ze.t3)().prototype.minimum=function(t){return this.throwIfDisposed(),(0,Zrt.L)(this,t)};var Yrt=y(4639);(0,Ze.t3)().prototype.mirrorPad=function(t,n){return this.throwIfDisposed(),(0,Yrt.V)(this,t,n)};var Qrt=y(1612);(0,Ze.t3)().prototype.mod=function(t){return this.throwIfDisposed(),(0,Qrt.w)(this,t)},(0,Ze.t3)().prototype.mul=function(t){return this.throwIfDisposed(),(0,Jn.d)(this,t)},(0,Ze.t3)().prototype.neg=function(){return this.throwIfDisposed(),(0,ac.W)(this)};var qrt=y(3717);(0,Ze.t3)().prototype.norm=function(t,n,e){return this.throwIfDisposed(),(0,qrt.K)(this,t,n,e)};var Jrt=y(4015);(0,Ze.t3)().prototype.notEqual=function(t){return this.throwIfDisposed(),(0,Jrt.Q)(this,t)};var tit=y(5618);(0,Ze.t3)().prototype.oneHot=function(t,n=1,e=0){return this.throwIfDisposed(),(0,tit.l)(this,t,n,e)};var eit=y(5034);(0,Ze.t3)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,eit.J)(this)},(0,Ze.t3)().prototype.pad=function(t,n){return this.throwIfDisposed(),(0,WF.v)(this,t,n)};var nit=y(1640);(0,Ze.t3)().prototype.pool=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,nit.d)(this,t,n,e,r,i,s)},(0,Ze.t3)().prototype.pow=function(t){return this.throwIfDisposed(),(0,Hw.s)(this,t)};var rit=y(1584);(0,Ze.t3)().prototype.prelu=function(t){return this.throwIfDisposed(),(0,rit.A)(this,t)};var iit=y(794);(0,Ze.t3)().prototype.prod=function(t,n){return this.throwIfDisposed(),(0,iit.W)(this,t,n)};var sit=y(4831);(0,Ze.t3)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,sit.M)(this)};var oit=y(8586);(0,Ze.t3)().prototype.relu=function(){return this.throwIfDisposed(),(0,oit.U)(this)};var ait=y(4917);(0,Ze.t3)().prototype.relu6=function(){return this.throwIfDisposed(),(0,ait.b)(this)},(0,Ze.t3)().prototype.reshapeAs=function(t){return this.throwIfDisposed(),(0,Dr.X)(this,t.shape)},(0,Ze.t3)().prototype.reshape=function(t){return this.throwIfDisposed(),(0,Dr.X)(this,t)};var uit=y(1265);(0,Ze.t3)().prototype.resizeBilinear=function(t,n,e){return this.throwIfDisposed(),(0,uit.I)(this,t,n,e)};var lit=y(7373);(0,Ze.t3)().prototype.resizeNearestNeighbor=function(t,n,e){return this.throwIfDisposed(),(0,lit.j)(this,t,n,e)},(0,Ze.t3)().prototype.reverse=function(t){return this.throwIfDisposed(),(0,BF.G)(this,t)};var cit=y(1638);(0,Ze.t3)().prototype.rfft=function(){return this.throwIfDisposed(),(0,cit.Q)(this)};var hit=y(1974);(0,Ze.t3)().prototype.round=function(){return this.throwIfDisposed(),(0,hit.N)(this)},(0,Ze.t3)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,SF.b)(this)};var dit=y(9614);(0,Ze.t3)().prototype.selu=function(){return this.throwIfDisposed(),(0,dit.U)(this)};var fit=y(6762);(0,Ze.t3)().prototype.separableConv2d=function(t,n,e,r,i,s){return this.throwIfDisposed(),(0,fit.U)(this,t,n,e,r,i,s)},(0,Ze.t3)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,GF.X)(this)};var pit=y(4058);(0,Ze.t3)().prototype.sign=function(){return this.throwIfDisposed(),(0,pit.X)(this)},(0,Ze.t3)().prototype.sin=function(){return this.throwIfDisposed(),(0,bF.O)(this)},(0,Ze.t3)().prototype.sinh=function(){return this.throwIfDisposed(),(0,wF.R)(this)},(0,Ze.t3)().prototype.slice=function(t,n){return this.throwIfDisposed(),(0,Bd.t)(this,t,n)};var mit=y(8683);(0,Ze.t3)().prototype.softmax=function(t){return this.throwIfDisposed(),(0,mit.X)(this,t)};var git=y(4487);(0,Ze.t3)().prototype.softplus=function(){return this.throwIfDisposed(),(0,git.W)(this)},(0,Ze.t3)().prototype.spaceToBatchND=function(t,n){return this.throwIfDisposed(),(0,_F.f)(this,t,n)},(0,Ze.t3)().prototype.split=function(t,n){return this.throwIfDisposed(),(0,xF.V)(this,t,n)},(0,Ze.t3)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,Ep._)(this)},(0,Ze.t3)().prototype.square=function(){return this.throwIfDisposed(),(0,Pu.h)(this)};var yit=y(9539);(0,Ze.t3)().prototype.squaredDifference=function(t){return this.throwIfDisposed(),(0,yit.$)(this,t)};var vit=y(2494);(0,Ze.t3)().prototype.squeeze=function(t){return this.throwIfDisposed(),(0,vit.L)(this,t)},(0,Ze.t3)().prototype.stack=function(t,n){this.throwIfDisposed();const e=t instanceof Ze.es?[this,t]:[this,...t];return(0,Ww.k)(e,n)},(0,Ze.t3)().prototype.step=function(t){return this.throwIfDisposed(),(0,x_.N)(this,t)};var _it=y(5367);(0,Ze.t3)().prototype.stridedSlice=function(t,n,e,r,i,s,o,a){return this.throwIfDisposed(),(0,_it.N)(this,t,n,e,r,i,s,o,a)},(0,Ze.t3)().prototype.sub=function(t){return this.throwIfDisposed(),(0,$l.l)(this,t)},(0,Ze.t3)().prototype.sum=function(t,n){return this.throwIfDisposed(),(0,jo.S)(this,t,n)};var xit=y(2500);(0,Ze.t3)().prototype.tan=function(){return this.throwIfDisposed(),(0,xit.O)(this)};var Eit=y(5987);(0,Ze.t3)().prototype.tanh=function(){return this.throwIfDisposed(),(0,Eit.A)(this)},(0,Ze.t3)().prototype.tile=function(t){return this.throwIfDisposed(),(0,DF.G)(this,t)},(0,Ze.t3)().prototype.toBool=function(){return this.throwIfDisposed(),(0,_i.p)(this,"bool")},(0,Ze.t3)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,_i.p)(this,"float32")},(0,Ze.t3)().prototype.toInt=function(){return this.throwIfDisposed(),(0,_i.p)(this,"int32")};var Cit=y(4927);(0,Ze.t3)().prototype.topk=function(t,n){return this.throwIfDisposed(),(0,Cit.h)(this,t,n)},(0,Ze.t3)().prototype.transpose=function(t){return this.throwIfDisposed(),(0,$d.p)(this,t)};var bit=y(8130);(0,Ze.t3)().prototype.unique=function(t){return this.throwIfDisposed(),(0,bit.T)(this,t)},(0,Ze.t3)().prototype.unsortedSegmentSum=function(t,n){return this.throwIfDisposed(),(0,TF.p)(this,t,n)},(0,Ze.t3)().prototype.unstack=function(t){return this.throwIfDisposed(),(0,kF.H)(this,t)},(0,Ze.t3)().prototype.where=function(t,n){return this.throwIfDisposed(),(0,Zh.a)(t,this,n)},(0,Ze.t3)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,Ta.P)(this)};class Qc extends Error{constructor(n){super(n),Object.setPrototypeOf(this,Qc.prototype)}}class uc extends Error{constructor(n){super(n),Object.setPrototypeOf(this,uc.prototype)}}class be extends Error{constructor(n){super(n),Object.setPrototypeOf(this,be.prototype)}}class ci extends Error{constructor(n){super(n),Object.setPrototypeOf(this,ci.prototype)}}class Xw extends Error{constructor(n){super(n),Object.setPrototypeOf(this,Xw.prototype)}}class JF{constructor(n){this.maxEntries=n||100,this.cache=new Map}get(n){let e;return this.cache.has(n)&&(e=this.cache.get(n),this.cache.delete(n),this.cache.set(n,e)),e}put(n,e){if(this.cache.has(n))this.cache.delete(n);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(n,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(n){if(n<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${n}.`);if(this.maxEntries>n)for(let e=0;e<this.maxEntries-n;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=n}}function zd(t,n){if(Array.isArray(t)){let e=[];for(let r=0;r<n;r++)e=e.concat(t);return e}{const e=new Array(n);return e.fill(t),e}}function Bl(t,n){if(!t)throw new Xw(n)}function t$(t,n){let e=0;for(const r of t)r===n&&e++;return e}function hl(t){return 1===t.length?t[0]:t}function Gs(t){return Array.isArray(t)?t:[t]}function Ih(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Vd(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(n,e)=>e.toUpperCase())}let lc={};function Zw(t){if(null==t)return null;const n={};return n.className=t.getClassName(),n.config=t.getConfig(),n}function Yw(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(n=>Yw(n));else{const n=Object.keys(t);for(const e of n){const r=t[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?Yw(r):t[e]=r.value)}}}function Pg(t,n={},e={},r="object",i=!1){if("string"==typeof t){let o;if(t in e)o=e[t];else if(t in lc)o=lc[t];else if(o=n[t],null==o)throw new be(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const s=t;if(null==s.className||null==s.config)throw new be(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const o=s.className;let a,u;if(o in e?[a,u]=e[o]:o in lc?[a,u]=lc.className:o in n&&([a,u]=n[o]),null==a)throw new be(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const c={};for(const x of Object.keys(lc))c[x]=lc[x];for(const x of Object.keys(e))c[x]=e[x];s.config.customObjects=c;const p=Object.assign({},lc);for(const x of Object.keys(e))lc[x]=e[x];Yw(s.config);const v=u(a,s.config,e,i);return lc=Object.assign({},p),v}{const c=Object.assign({},lc);for(const p of Object.keys(e))lc[p]=e[p];const d=new a(s.config);return lc=Object.assign({},c),d}}}function b_(t,n){return-1*function wit(t,n){return t<n?-1:t>n?1:0}(t,n)}function Qh(t){if(null==t)return t;const n=[];for(const e of t)-1===n.indexOf(e)&&n.push(e);return n}function Iit(t){if(null==t)throw new be(`Invalid value in obj: ${JSON.stringify(t)}`);for(const n in t)if(t.hasOwnProperty(n))return!1;return!0}function Ud(t,n,e){if(null!=e&&t.indexOf(e)<0)throw new be(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}function Qw(t,n,e=0,r=1/0){return Bl(e>=0),Bl(r>=e),Array.isArray(t)&&t.length>=e&&t.length<=r&&t.every(i=>typeof i===n)}function hu(t,n){Array.isArray(t)?(g.util.assert(t.length>0,()=>`${n} is unexpectedly an empty array.`),t.forEach((e,r)=>hu(e,`element ${r+1} of ${n}`))):g.util.assert(Number.isInteger(t)&&t>0,()=>`Expected ${n} to be a positive integer, but got ${e$(t)}.`)}function e$(t){return null===t?"null":Array.isArray(t)?"["+t.map(n=>e$(n)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function n$(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let Dit=0;function r$(){return Dit++}const w_={};function I_(t=""){return t in w_||(w_[t]=0),w_[t]+=1,t+w_[t].toString()}const Tit=["channelsFirst","channelsLast"],Nit=["nearest","bilinear"],Ait=["valid","same","causal"],Mit=["max","avg"],Pit=["sum","mul","concat","ave"],wp=new Map;function Na(t){Ud(Tit,"DataFormat",t)}function zl(t){Ud(Ait,"PaddingMode",t)}function i$(t){Ud(Mit,"PoolMode",t)}const Og=[];function Wd(t,n){Og.push(t);try{const e=n();return Og.pop(),e}catch(e){throw Og.pop(),e}}function o$(t){if(!u$(t))throw new Error("Not a valid tensor name: '"+t+"'");return function Rit(){return 0===Og.length?"":Og.join("/")+"/"}()+t}function a$(t){if(!u$(t))throw new Error("Not a valid tensor name: '"+t+"'");wp.has(t)||wp.set(t,0);const n=wp.get(t);if(wp.set(t,wp.get(t)+1),n>0){const e=`${t}_${n}`;return wp.set(e,1),e}return t}const Lit=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function u$(t){return!!t.match(Lit)}function kit(t){return t===parseInt(t.toString(),10)}function qh(t,n,e){null==n&&(n=0),null==e&&(e=t.length);let r=1;for(let i=n;i<e;++i)r*=t[i];return r}function Ip(t){if(0===t.length)return Number.NaN;let n=Number.POSITIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e];r<n&&(n=r)}return n}function Jh(t){if(0===t.length)return Number.NaN;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const r=t[e];r>n&&(n=r)}return n}function Ic(t,n){if(n<t)throw new be(`end (${n}) < begin (${t}) is forbidden.`);const e=[];for(let r=t;r<n;++r)e.push(r);return e}let S_;function Ya(){return null==S_&&(S_=(0,g.backend)().epsilon()),S_}function qc(t,n){return g.cast(t,n)}function Rg(t,n=-1){const e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),g.reshape(t,e)}function Gd(t,n,e){return(0,g.tidy)(()=>{switch(t.rank){case 1:return g.slice1d(t,n,e);case 2:return g.slice2d(t,[n,0],[e,t.shape[1]]);case 3:return g.slice3d(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return g.slice4d(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return g.slice(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return g.slice(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new be(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function qw(t,n,e){return(0,g.tidy)(()=>{switch(t.rank){case 1:return g.slice1d(t,n,e);case 2:return g.slice2d(t,[0,n],[t.shape[0],e]);case 3:return g.slice3d(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return g.slice4d(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new be(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function D_(t,n,e,r){return(0,g.tidy)(()=>{switch(t.rank){case 1:return g.slice1d(t,n,e);case 2:switch(r){case 1:return Gd(t,n,e);case 2:return qw(t,n,e);default:throw new be(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Gd(t,n,e);case 2:return g.slice3d(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return qw(t,n,e);default:throw new be(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Gd(t,n,e);case 2:return g.slice4d(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return g.slice4d(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return qw(t,n,e);default:throw new be(`The axis is not within the rank of the tensor ${r}`)}default:throw new be(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Jw(t,n=-1){let e;return n<0&&(e=t[0].rank,n=0!==e?e:0),n===t[0].rank&&(n=-1),g.concat(t,n)}function c$(t,n){switch(t.rank){case 1:return g.concat1d([t,n]);case 2:return g.concat2d([t,n],0);case 3:return g.concat3d([t,n],0);case 4:return g.concat4d([t,n],0);default:throw new be(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function tI(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new be(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return g.tile(t,n)}function T_(t,n=0,e=1,r,i){return g.randomNormal(t,n,e,r,i)}function Jc(t,n,e,r){if(t.rank<2||n.rank<2)throw new ci(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3&&t.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new ci(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${n.shape}`);if(2===t.rank&&2===n.rank)return g.fused.matMul({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?eI(t.rank,r,"channelsLast"):null,activation:e});{const i=t.shape.slice(),s=i.pop();t=g.reshape(t,[-1,s]);const o=n.shape.slice(),a=o.pop(),u=o.pop(),c=[...o,a],d=Array.from({length:n.rank},(b,w)=>0===w?n.rank-2:w<=n.rank-2?w-1:w);n=g.reshape(g.transpose(n,d),[u,-1]);const p=[...i,...c];return g.reshape(g.fused.matMul({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?eI(t.rank,r,"channelsLast"):null,activation:e}),p)}}function h$(t,n,e){return(0,g.tidy)(()=>(n=Array.isArray(n)?(0,g.tensor1d)(n,"int32"):g.cast(n,"int32"),g.gather(t,n,e)))}function Lg(t){return g.mul(t,t)}function eI(t,n,e){const r=n.shape;if(1!==n.rank&&n.rank!==t)throw new be(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===e)return g.reshape(n,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return g.reshape(n,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===e)return g.reshape(n,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return g.reshape(n,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===e)return g.reshape(n,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return g.reshape(n,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return n;throw new be(`Unsupported input rank by biasAdd: ${n.rank}`)}function Dc(t,n,e){return(0,g.tidy)(()=>(null==e&&(e="channelsLast"),Na(e),g.add(t,eI(t.rank,n,e))))}function d$(t,n,e,r){return(0,g.tidy)(()=>g.dropout(t,n,e,r))}function kg(t,n,e=!1){return e?t():n()}const Hit=["fanIn","fanOut","fanAvg"],jit=["normal","uniform","truncatedNormal"];class cc extends g.serialization.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}g.serialization.registerClass((()=>{class t extends cc{apply(e,r){return(0,g.zeros)(e,r)}}return t.className="Zeros",t})());let f$=(()=>{class t extends cc{apply(e,r){return(0,g.ones)(e,r)}}return t.className="Ones",t})();g.serialization.registerClass(f$),g.serialization.registerClass((()=>{class t extends cc{constructor(e){if(super(),"object"!=typeof e)throw new be(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new be(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return(0,g.tidy)(()=>(0,g.mul)((0,g.scalar)(this.value),(0,g.ones)(e,r)))}getConfig(){return{value:this.value}}}return t.className="Constant",t})()),g.serialization.registerClass((()=>{class t extends cc{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return(0,g.randomUniform)(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return t.className="RandomUniform",t})()),g.serialization.registerClass((()=>{class t extends cc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ci(`randomNormal does not support dType ${r}.`);return T_(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="RandomNormal",t})()),g.serialization.registerClass((()=>{class t extends cc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ci(`truncatedNormal does not support dType ${r}.`);return(0,g.truncatedNormal)(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="TruncatedNormal",t})()),g.serialization.registerClass((()=>{class t extends cc{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return(0,g.tidy)(()=>{if(2!==e.length||e[0]!==e[1])throw new be("Identity matrix initializer can only be used for 2D square matrices.");return(0,g.mul)(this.gain,(0,g.eye)(e[0]))})}getConfig(){return{gain:this.gain}}}return t.className="Identity",t})());let Vl=(()=>{class t extends cc{constructor(e){if(super(),e.scale<0)throw new be(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function Kit(t){Ud(Hit,"FanMode",t)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function Xit(t){Ud(jit,"Distribution",t)}(this.distribution),this.seed=e.seed}apply(e,r){const i=function est(t,n="channelsLast"){let e,r;if(Na(n),2===t.length)e=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===n){const i=qh(t,2);e=t[1]*i,r=t[0]*i}else if("channelsLast"===n){const i=qh(t,0,t.length-2);e=t[t.length-2]*i,r=t[t.length-1]*i}}else{const i=qh(t);e=Math.sqrt(i),r=Math.sqrt(i)}return[e,r]}(e),s=i[0],o=i[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(s+o)/2),"normal"===this.distribution){const u=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new ci(`${this.getClassName()} does not support dType ${r}.`);return(0,g.truncatedNormal)(e,0,u,r,this.seed)}{const u=Math.sqrt(3*a);return(0,g.randomUniform)(e,-u,u,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return t.className="VarianceScaling",t})();g.serialization.registerClass(Vl);let p$=(()=>{class t extends Vl{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Vl.className}}return t.className="GlorotUniform",t})();g.serialization.registerClass(p$);let m$=(()=>{class t extends Vl{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Vl.className}}return t.className="GlorotNormal",t})();g.serialization.registerClass(m$);let g$=(()=>{class t extends Vl{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Vl.className}}return t.className="HeNormal",t})();g.serialization.registerClass(g$);let y$=(()=>{class t extends Vl{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Vl.className}}return t.className="HeUniform",t})();g.serialization.registerClass(y$);let v$=(()=>{class t extends Vl{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Vl.className}}return t.className="LeCunNormal",t})();g.serialization.registerClass(v$);let _$=(()=>{class t extends Vl{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Vl.className}}return t.className="LeCunUniform",t})();g.serialization.registerClass(_$);let nst=(()=>{class t extends cc{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return(0,g.tidy)(()=>{if(e.length<2)throw new ci("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const i=g.util.sizeFromShape(e.slice(0,-1)),s=e[e.length-1],o=i*s;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const u=T_([Math.max(s,i),Math.min(s,i)],0,1,r,this.seed),c=g.linalg.qr(u,!1);let d=c[0];const v=c[1].flatten().stridedSlice([0],[Math.min(s,i)*Math.min(s,i)],[Math.min(s,i)+1]);return d=(0,g.mul)(d,v.sign()),i<s&&(d=d.transpose()),(0,g.mul)((0,g.scalar)(this.gain),d.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return t.className="Orthogonal",t})();g.serialization.registerClass(nst);const x$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function E$(t,n={}){return Pg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"initializer")}function oa(t){return Zw(t)}function Ko(t){if("string"==typeof t){const n=t in x$?x$[t]:t;if("GlorotNormal"===n)return new m$;if("GlorotUniform"===n)return new p$;if("HeNormal"===n)return new g$;if("HeUniform"===n)return new y$;if("LeCunNormal"===n)return new v$;if("LeCunUniform"===n)return new _$;{const e={};return e.className=n,e.config={},E$(e)}}return t instanceof cc?t:E$(t)}function nI(t){return Array.isArray(t)&&Array.isArray(t[0])}function N_(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function Fr(t){let n;if(Array.isArray(t)){if(1!==t.length)throw new be(`Expected Tensor length to be 1; got ${t.length}`);n=t[0]}else n=t;return n}function xs(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new be(`Expected exactly 1 Shape; got ${t.length}`)}return t}function A_(t){let n=0;for(const e of t)n+=0===e.shape.length?1:e.shape.reduce((r,i)=>r*i);return n}const C$="Variable";class th{constructor(n,e="float32",r=C$,i=!0,s=null){this.dtype=e??"float32",this.shape=n.shape,this.id=r$(),this.originalName=o$(r=r??C$),this.name=a$(this.originalName),this.trainable_=i,this.constraint=s,this.val=g.variable(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),function rst(t,n){if(t.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}(this.val,n),this.val.id!==n.id&&(this.val.assign(n),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}}function rI(t){return t.map(n=>n.read())}function iI(t){t.forEach(n=>{n[0].write(n[1])})}class Qa{constructor(n){this.dtype=n.dtype,this.shape=n.shape,this.ndim=null!=n.shape?n.shape.length:n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}}class eh{constructor(n,e,r,i,s,o,a){this.dtype=n,this.shape=e,this.sourceLayer=r,this.inputs=i,this.callArgs=s,this.outputTensorIndex=a,this.id=r$(),null!=o&&(this.originalName=o$(o),this.name=a$(this.originalName)),this.rank=e.length}}let ist=0;class M_{constructor(n,e){this.callArgs=e,this.id=ist++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(const r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){const n=[];for(const e of this.inboundLayers)n.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let sst=0;class xi extends g.serialization.Serializable{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=sst++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=n.name;if(!e){const r=this.getClassName();e=Ih(r)+"_"+I_(r)}if(this.name=e,this.trainable_=null==n.trainable||n.trainable,null!=n.inputShape||null!=n.batchInputShape){let r;if(null!=n.batchInputShape)r=n.batchInputShape;else if(null!=n.inputShape){let s=null;null!=n.batchSize&&(s=n.batchSize),r=[s].concat(n.inputShape)}this.batchInputShape=r;let i=n.dtype;null==i&&(i=n.inputDType),null==i&&(i="float32"),this.dtype=i}this.initialWeights=null!=n.weights?n.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,e){return n.name+"_ib-"+e.toString()}getNodeAtIndex(n,e){if(0===this.inboundNodes.length)throw new uc(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=n)throw new be(`Asked to get ${e} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return hl(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return hl(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Qc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Qc(`Layer ${this.name} is not connected, no input to return.`);return hl(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Qc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Qc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return hl(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(e=>e.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){const e=Gs(n);if(null==this.inputSpec||0===this.inputSpec.length)return;const r=Gs(this.inputSpec);if(e.length!==r.length)throw new be(`Layer ${this.name} expects ${r.length} inputs, but it received ${e.length} input tensors. Input received: ${n}`);for(let i=0;i<e.length;i++){const s=e[i],o=r[i];if(null==o)continue;const a=s.rank;if(null!=o.ndim&&a!==o.ndim)throw new be(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(null!=o.maxNDim&&a>o.maxNDim)throw new be(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(null!=o.minNDim&&a<o.minNDim)throw new be(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(null!=o.dtype&&s.dtype!==o.dtype)throw new be(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const u=s.shape;for(const c in o.axes){const d=Number(c),p=o.axes[c];if(null!=p&&-1===[p,null].indexOf(d>=0?u[d]:u[u.length+d]))throw new be(`Input ${i} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${u}.`)}}if(null!=o.shape)for(let u=0;u<o.shape.length;++u){const c=o.shape[u],d=s.shape[u];if(null!=c&&null!=d&&c!==d)throw new be(`Input ${i} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(n,e){return n}invokeCallHook(n,e){null!=this._callHook&&this._callHook(n,e)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,e){e=e||{},this.assertNotDisposed();const r=Gs(n),i=function ust(t){let n=!0;for(const e of Gs(t))if(!(e instanceof eh)){n=!1;break}return n}(n),s=function lst(t){let n=!0;for(const e of Gs(t))if(e instanceof eh){n=!1;break}return n}(n);if(i===s)throw new be("Arguments to apply() must be all SymbolicTensors or all Tensors");return Wd(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);const o=[];for(const a of Gs(n))o.push(a.shape);this.build(hl(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(n),s){let o=this.call(n,e);this.supportsMasking&&this.setMaskMetadata(n,o);const a=Gs(o),u=[];for(let c of a)-1!==r.indexOf(c)&&(c=c.clone()),u.push(c);if(o=hl(u),null!=this.activityRegularizer)throw new ci("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function ost(t){t=Gs(t);const n=[];for(const e of t)n.push(e.shape);return hl(n)}(n),a=this.computeOutputShape(o);let u;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(n)?o[0]:o),u=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((d,p)=>new eh(c,d,this,Gs(n),e,this.name,p)):new eh(c,a,this,Gs(n),e,this.name),this.addInboundNode(n,u,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new ci("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(n){if(null!=this.batchInputShape)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,i)=>{null!=r&&null!=n[i]&&n[i]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Qc(`The layer ${this.name} has never been called and thus has no defined output shape.`);const n=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===n.indexOf(r)&&n.push(r)}if(1===n.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Qc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new uc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return A_(this.weights)}build(n){this.built=!0}getWeights(n=!1){return rI(n?this.trainableWeights:this.weights)}setWeights(n){(0,g.tidy)(()=>{const e=this.weights;if(e.length!==n.length)throw new be(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${e.length} weights. Provided weights: ${n}...`);if(0===e.length)return;const r=[],i=rI(e);for(let s=0;s<i.length;++s){const o=i[s],a=e[s],u=n[s];if(!g.util.arraysEqual(o.shape,u.shape))throw new be(`Layer weight shape ${o.shape} not compatible with provided weight shape ${u.shape}`);r.push([a,u])}iI(r)})}addWeight(n,e,r,i,s,o,a,u){if(-1!==this._addedWeightNames.indexOf(n))throw new be(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(i=null!=u?u():Ko("zeros"));const c=i.apply(e,r),d=new th(c,r,n,o,a);return c.dispose(),null!=s&&this.addLoss(()=>s.apply(d.read())),null==o&&(o=!0),o?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){null==n||Array.isArray(n)&&0===n.length||(n=Gs(n),null!=this._losses&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}setMaskMetadata(n,e,r){if(!this.supportsMasking)return;const i=this.computeMask(n,r),s=Gs(e),o=Gs(i);if(s.length!==o.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let a=0;a<s.length;a++)s[a].kerasMask=o[a]}addInboundNode(n,e,r,i,s,o,a=null){const u=Gs(n);e=Gs(e),r=Gs(r),i=Gs(i),s=N_(s),o=N_(o);const c=[],d=[],p=[];for(const v of u)c.push(v.sourceLayer),d.push(v.nodeIndex),p.push(v.tensorIndex);new M_({outboundLayer:this,inboundLayers:c,nodeIndices:d,tensorIndices:p,inputTensors:u,outputTensors:e,inputMasks:r,outputMasks:i,inputShapes:s,outputShapes:o},a);for(let v=0;v<e.length;v++)e[v].sourceLayer=this,e[v].nodeIndex=this.inboundNodes.length-1,e[v].tensorIndex=v}getConfig(){const n={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(n.batchInputShape=this.batchInputShape),null!=this.dtype&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return 0==--this._refCount&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}}function b$(t,n,e){if((null==n||null!=e&&e>0)&&(n=t.sourceLayer,e=t.nodeIndex),0===n.inboundNodes.length)return[t];{const r=n.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const i=[];for(let s=0;s<r.inboundLayers.length;s++){const c=b$(r.inputTensors[s],r.inboundLayers[s],r.nodeIndices[s]);for(const d of c)-1===i.indexOf(d)&&i.push(d)}return i}}}let P_=(()=>{class t extends xi{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:I_("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new be("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new be("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new be("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const i=e.dtype||"float32";this.batchInputShape=r,this.dtype=i,this.inputSpec=[{shape:r}];const s=new eh(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new M_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new be(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return t.className="InputLayer",t})();g.serialization.registerClass(P_);class td{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof td)for(const e in n.id2Value)this.id2Value[e]=n.id2Value[e],e in n.id2Mask&&(this.id2Mask[e]=n.id2Mask[e]);else{if(null==n)return;for(const e of n)this.add(e.key,e.value)}}add(n,e,r){if(null!=this.id2Value[n.id])throw new be(`Duplicate key: name=${n.name}, id=${n.id}`);return this.id2Value[n.id]=function hst(t,n){if(null==t.dtype||t.dtype===n.dtype)return n;try{return(0,g.cast)(n,t.dtype)}catch{throw new be(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(n,e),this.name2Id[n.name]=n.id,null!=r&&(this.id2Mask[n.id]=r),this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return null!=this.id2Value[n.id]}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof eh){if(null==this.id2Value[n.id])throw new be(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}{const e=this.name2Id[n];if(null==e)throw new be(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[e]}}getMask(n){if(n instanceof eh){if(null==this.id2Value[n.id])throw new be(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}{const e=this.name2Id[n];if(null==e)throw new be(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&(0,g.dispose)(this.id2Mask)}}const O_=new JF,R_=new JF;function Fg(t,n,e,r){const i=null!=e&&e.training,s=Array.isArray(t),o=s?t:[t],a=o.map(b=>b.name),u=[],c=n.names();for(const b of a)-1!==c.indexOf(b)?u.push(n.getValue(b)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const d=a.join(",")+"|"+n.names().sort().join(",");let v,p=O_.get(d);if(null==p){const b=function fst(t,n){g.util.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===t.length){const i=w$(t[0],n);e=i.sorted,r=i.recipientMap}else{const i=new Set;for(const s of t){const{sorted:o,recipientMap:a}=w$(s,n);for(const u of o)i.has(u.name)||(e.push(u),i.add(u.name));for(const u in a)null==r[u]&&(r[u]=new Set),a[u].forEach(c=>r[u].add(c))}}return{sorted:e,recipientCounts:pst(r)}}(o,n);p=b.sorted,v=b.recipientCounts,O_.put(d,p),R_.put(d,v)}v={},i||Object.assign(v,R_.get(d));const x=new td(n);for(let b=0;b<p.length;++b){if(null!=r){const Ot=(0,g.memory)().numTensors;Ot>r.maxNumTensors&&(r.maxNumTensors=Ot),Ot<r.minNumTensors&&(r.minNumTensors=Ot)}const w=p[b],T=w.sourceLayer;if(T instanceof P_)continue;const N=[],S=[],U=[];let J=!1;for(const Ot of w.inputs){const le=x.getValue(Ot),ge=x.getMask(Ot);N.push(le),S.push(ge),null!=ge&&(J=!0),i||(v[Ot.name]--,0===v[Ot.name]&&!n.hasKey(Ot)&&-1===a.indexOf(Ot.name)&&!le.isDisposed&&!0!==Ot.sourceLayer.stateful&&U.push(le))}J&&((e=e||{}).mask=S[0]);const ht=Gs(T.apply(N,e));let Tt=null;T.supportsMasking&&(Tt=T.computeMask(N,S));const Pt=mst(w),zt=Array.isArray(Pt)?Pt:[Pt];for(let Ot=0;Ot<zt.length;++Ot){x.hasKey(zt[Ot])||x.add(zt[Ot],ht[Ot],Array.isArray(Tt)?Tt[0]:Tt);const le=a.indexOf(zt[Ot].name);-1!==le&&(u[le]=ht[Ot])}i||(0,g.dispose)(U)}return x.disposeMasks(),s?u:u[0]}function pst(t){const n={};for(const e in t)n[e]=t[e].size;return n}function w$(t,n){const e=new Set,r=[],i={};for(const a of n.names())e.add(a);const s=[],o=[];for(s.push(t);s.length>0;){const a=s[s.length-1];if(e.has(a.name)){s.pop();continue}const u=o[o.length-1]===s.length-1;if(0===a.inputs.length||u)s.pop(),r.push(a),e.add(a.name),u&&o.pop();else{o.push(s.length-1);for(const c of a.inputs)null==i[c.name]&&(i[c.name]=new Set),i[c.name].add(a.name),!e.has(c.name)&&s.push(c)}}return{sorted:r,recipientMap:i}}function mst(t){let n;if(1===t.sourceLayer.inboundNodes.length)n=t.sourceLayer.output;else{let e=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(const i of t.sourceLayer.inboundNodes[r].outputTensors)if(i.id===t.id){e=r;break}n=t.sourceLayer.getOutputAt(e)}return n}function sI(t,n){return(0,g.tidy)(()=>g.sqrt(g.sum(g.mul(t,t),n,!0)))}(0,g.env)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function dst(t){O_?.setMaxEntries(t),R_?.setMaxEntries(t)});class $g extends g.serialization.Serializable{getConfig(){return{}}}let gst=(()=>{class t extends $g{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,g.tidy)(()=>{const r=sI(e,this.axis),i=g.clipByValue(r,0,this.maxValue);return g.mul(e,g.div(i,g.add(Ya(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return t.className="MaxNorm",t})();g.serialization.registerClass(gst);let yst=(()=>{class t extends $g{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,g.tidy)(()=>g.div(e,g.add(Ya(),sI(e,this.axis))))}getConfig(){return{axis:this.axis}}}return t.className="UnitNorm",t})();g.serialization.registerClass(yst);let vst=(()=>{class t extends $g{apply(e){return g.relu(e)}}return t.className="NonNeg",t})();g.serialization.registerClass(vst);let _st=(()=>{class t extends $g{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,g.tidy)(()=>{const r=sI(e,this.axis),i=g.add(g.mul(this.rate,g.clipByValue(r,this.minValue,this.maxValue)),g.mul(1-this.rate,r));return g.mul(e,g.div(i,g.add(Ya(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return t.className="MinMaxNorm",t})();g.serialization.registerClass(_st);const I$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function qa(t){return Zw(t)}function S$(t,n={}){return Pg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"constraint")}function Ja(t){return null==t?null:"string"==typeof t?S$({className:t in I$?I$[t]:t,config:{}}):t instanceof $g?t:S$(t)}function ed(t){return oI.apply(this,arguments)}function oI(){return(oI=(0,Mr.Z)(function*(t){if(null==t)return;const n=[],e=[],r=[];for(const i in t){const s=t[i];if("number"!=typeof s){const o=s;n.push(o.data()),e.push(i),r.push(o)}}if(n.length>0){const i=yield Promise.all(n);for(let s=0;s<i.length;++s)t[e[s]]=i[s][0];(0,g.dispose)(r)}})).apply(this,arguments)}function D$(t){if(null!=t)for(const n in t){const e=t[n];"number"!=typeof e&&e.dispose()}}class Sp{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,e){return(0,Mr.Z)(function*(){})()}onEpochEnd(n,e){return(0,Mr.Z)(function*(){})()}onBatchBegin(n,e){return(0,Mr.Z)(function*(){})()}onBatchEnd(n,e){return(0,Mr.Z)(function*(){})()}onTrainBegin(n){return(0,Mr.Z)(function*(){})()}onTrainEnd(n){return(0,Mr.Z)(function*(){})()}setModel(n){}}class Cst{constructor(n,e=10){null==n&&(n=[]),this.callbacks=n,this.queueLength=e}append(n){this.callbacks.push(n)}setParams(n){for(const e of this.callbacks)e.setParams(n)}setModel(n){for(const e of this.callbacks)e.setModel(n)}onEpochBegin(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onEpochBegin(n,e)})()}onEpochEnd(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onEpochEnd(n,e)})()}onBatchBegin(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onBatchBegin(n,e)})()}onBatchEnd(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});for(const i of r.callbacks)yield i.onBatchEnd(n,e)})()}onTrainBegin(n){var e=this;return(0,Mr.Z)(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainBegin(n)})()}onTrainEnd(n){var e=this;return(0,Mr.Z)(function*(){null==n&&(n={});for(const r of e.callbacks)yield r.onTrainEnd(n)})()}}class bst extends Sp{constructor(){super()}onEpochBegin(n){var e=this;return(0,Mr.Z)(function*(){e.seen=0,e.totals={}})()}onBatchEnd(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={});const i=null==e.size?0:e.size;r.seen+=i;for(const s in e){const o=e[s];if("number"==typeof o)r.totals.hasOwnProperty(s)||(r.totals[s]=0),r.totals[s]=r.totals[s]+o*i;else{let a;s in r.totals?a=r.totals[s]:r.totals[s]=0;const u=(0,g.tidy)(()=>(0,g.add)(r.totals[s],(0,g.mul)(o,i)));r.totals[s]=u,a?.dispose()}}})()}onEpochEnd(n,e){var r=this;return(0,Mr.Z)(function*(){if(null!=e)for(const i of r.params.metrics)null!=r.totals[i]&&("number"==typeof r.totals[i]?e[i]=r.totals[i]/r.seen:(0,g.tidy)(()=>{const s=(0,g.mul)((0,g.div)(1,r.seen),r.totals[i]);e[i]=s,r.totals[i].dispose(),(0,g.keep)(e[i])}))})()}}class wst extends Sp{onTrainBegin(n){var e=this;return(0,Mr.Z)(function*(){e.epoch=[],e.history={}})()}onEpochEnd(n,e){var r=this;return(0,Mr.Z)(function*(){null==e&&(e={}),r.epoch.push(n);for(const i in e)null==r.history[i]&&(r.history[i]=[]),r.history[i].push(e[i])})()}syncData(){var n=this;return(0,Mr.Z)(function*(){const e=[],r=[],i=[];for(const o in n.history){const a=n.history[o];for(let u=0;u<a.length;++u)"number"!=typeof a[u]&&(e.push(a[u].data()),r.push(o),i.push(u))}const s=yield Promise.all(e);for(let o=0;o<s.length;++o)n.history[r[o]][i[o]].dispose(),n.history[r[o]][i[o]]=s[o][0]})()}}class Ist extends Sp{constructor(n,e){if(super(),this.currentEpoch=0,this.nowFunc=n.nowFunc,this.nextFrameFunc=n.nextFrameFunc||g.nextFrame,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");g.util.isNumber(this.yieldEvery)&&(this.maybeWait=function Sit(t,n,e){let i,r=null!=e?e():g.util.now();return(...o)=>{const a=null!=e?e():g.util.now();return a-r<n||(r=a,i=t(...o)),i}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,e,r){var i=this;return(0,Mr.Z)(function*(){const s=[];null!=i.yield&&(yield ed(r),s.push(i.yield(n,e,r))),s.push(i.nextFrameFunc()),yield Promise.all(s)})()}onEpochBegin(n,e){var r=this;return(0,Mr.Z)(function*(){r.currentEpoch=n,null!=r.epochBegin&&(yield ed(e),yield r.epochBegin(n,e))})()}onEpochEnd(n,e){var r=this;return(0,Mr.Z)(function*(){const i=[];null!=r.epochEnd&&(yield ed(e),i.push(r.epochEnd(n,e))),"epoch"===r.yieldEvery&&i.push(r.nextFrameFunc()),yield Promise.all(i)})()}onBatchBegin(n,e){var r=this;return(0,Mr.Z)(function*(){null!=r.batchBegin&&(yield ed(e),yield r.batchBegin(n,e))})()}onBatchEnd(n,e){var r=this;return(0,Mr.Z)(function*(){const i=[];null!=r.batchEnd&&(yield ed(e),i.push(r.batchEnd(n,e))),"batch"===r.yieldEvery?i.push(r.nextFrameFunc()):g.util.isNumber(r.yieldEvery)&&i.push(r.maybeWait(r.currentEpoch,n,e)),yield Promise.all(i)})()}onTrainBegin(n){var e=this;return(0,Mr.Z)(function*(){null!=e.trainBegin&&(yield ed(n),yield e.trainBegin(n))})()}onTrainEnd(n){var e=this;return(0,Mr.Z)(function*(){null!=e.trainEnd&&(yield ed(n),yield e.trainEnd(n))})()}}function T$(t,n){return null==t&&(t={}),t instanceof Sp?[t]:Array.isArray(t)&&t[0]instanceof Sp?t:Gs(t).map(r=>new Ist(r,n))}let Sst=(()=>{class t{constructor(){}static registerCallbackConstructor(e,r){g.util.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),t.checkForDuplicate(r),null==t.constructors[e]&&(t.constructors[e]=[]),t.constructors[e].push(r)}static checkForDuplicate(e){for(const r in t.constructors)t.constructors[+r].forEach(s=>{if(s===e)throw new be("Duplicate callback constructor.")})}static clear(){t.constructors={}}static createCallbacks(e){const r=[];for(const i in t.constructors){const s=+i;e>=s&&r.push(...t.constructors[s])}return r.map(i=>new i)}}return t.constructors={},t})();function N$(t,n,e,r,i,s,o,a,u){const c=new wst,d=[new bst,...Sst.createCallbacks(n)];null!=t&&d.push(...t),d.push(c);const p=new Cst(d);return p.setParams({epochs:e,initialEpoch:r,samples:i,steps:s,batchSize:o,verbose:n,doValidation:a,metrics:u}),{callbackList:p,history:c}}function Sh(t,n={},e=!1){return Pg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"layer",e)}function L_(t,n){return(0,g.tidy)(()=>{"float32"!==t.dtype&&(t=g.cast(t,"float32"));const e=g.sum(Lg(t),n,!0),r=g.fill(e.shape,Ya()),i=g.sqrt(g.maximum(e,r));return g.div(t,i)})}function k_(t,n){return(0,g.tidy)(()=>g.mean(Lg(g.sub(n,t)),-1))}function aI(t,n){return(0,g.tidy)(()=>g.mean(g.abs(g.sub(n,t)),-1))}function uI(t,n){return(0,g.tidy)(()=>{const e=g.sub(t,n),r=g.clipByValue(g.abs(t),Ya(),Number.MAX_VALUE),i=g.abs(g.div(e,r));return g.mul(100,g.mean(i,-1))})}function Bg(t,n,e=!1){return(0,g.tidy)(()=>{if(e)n=g.softmax(n);else{const r=g.sum(n,n.shape.length-1,!0);n=g.div(n,r)}return n=g.clipByValue(n,Ya(),1-Ya()),g.neg(g.sum(g.mul(g.cast(t,"float32"),g.log(n)),n.shape.length-1))})}function F_(t,n,e=!1){return(0,g.tidy)(()=>{const r=g.cast(g.floor(function zit(t){const n=[qh(t.shape)];return g.reshape(t,n)}(t)),"int32"),i=(n=g.clipByValue(n,Ya(),1-Ya())).shape;return Bg(g.reshape(g.oneHot(r,i[i.length-1]),i),n,e)})}function $_(t,n){return(0,g.tidy)(()=>{let e;return e=g.clipByValue(n,Ya(),1-Ya()),e=g.log(g.div(e,g.sub(1,e))),g.mean(function Pst(t,n){if(!g.util.arraysEqual(t.shape,n.shape))throw new be(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`);return(0,g.tidy)(()=>{const e=g.relu(n),r=g.neg(g.abs(n));return g.add(g.sub(e,g.mul(n,t)),g.log1p(g.exp(r)))})}(t,e),-1)})}function A$(t,n){return(0,g.tidy)(()=>{const e=L_(t,-1),r=L_(n,-1),i=g.mul(e,r);return g.neg(g.sum(i,-1))})}const B_={meanSquaredError:k_,meanAbsoluteError:aI,meanAbsolutePercentageError:uI,meanSquaredLogarithmicError:function Dst(t,n){return(0,g.tidy)(()=>{const e=g.clipByValue(n,Ya(),Number.MAX_VALUE),r=g.log(g.add(1,e)),i=g.clipByValue(t,Ya(),Number.MAX_VALUE),s=g.log(g.add(1,i));return g.mean(Lg(g.sub(r,s)),-1)})},squaredHinge:function Tst(t,n){return(0,g.tidy)(()=>{const e=g.maximum(0,g.sub(1,g.mul(t,n)));return g.mean(Lg(e),-1)})},hinge:function Nst(t,n){return(0,g.tidy)(()=>{const e=g.maximum(0,g.sub(1,g.mul(t,n)));return g.mean(e,-1)})},categoricalHinge:function Ast(t,n){return(0,g.tidy)(()=>{const e=g.sum(g.mul(t,n),-1),r=g.max(g.mul(g.sub(1,t),n),-1);return g.maximum(0,g.add(1,g.sub(r,e)))})},logcosh:function Mst(t,n){return(0,g.tidy)(()=>{const e=Math.log(2),r=g.sub(n,t),i=g.sub(g.add(r,g.softplus(g.mul(-2,r))),e);return g.mean(i,-1)})},categoricalCrossentropy:Bg,sparseCategoricalCrossentropy:F_,binaryCrossentropy:$_,kullbackLeiblerDivergence:function Ost(t,n){return(0,g.tidy)(()=>{const e=g.clipByValue(t,Ya(),1),r=g.clipByValue(n,Ya(),1);return g.sum(g.mul(t,g.log(g.div(e,r))),-1)})},poisson:function Rst(t,n){return(0,g.tidy)(()=>{const e=g.log(g.add(Ya(),n));return g.mean(g.sub(n,g.mul(t,e)),-1)})},cosineProximity:A$};function lI(t){if("string"==typeof t){if(t in B_)return B_[t];let n=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new be(n)}return t}function M$(t,n){return(0,g.tidy)(()=>{const e=g.mul(.5,g.onesLike(n)),r=qc(g.greater(n,e),t.dtype);return g.mean(g.equal(t,r),-1)})}function P$(t,n){return(0,g.tidy)(()=>qc(g.equal(g.argMax(t,-1),g.argMax(n,-1)),"float32"))}function $st(t,n){return $_(t,n)}function Bst(t,n){return t.rank===n.rank&&(t=g.squeeze(t,[t.rank-1])),(n=g.argMax(n,-1)).dtype!==t.dtype&&(n=g.cast(n,t.dtype)),g.cast(g.equal(t,n),"float32")}const R$=Bg,L$=F_,z_={binaryAccuracy:M$,categoricalAccuracy:P$,precision:function Fst(t,n){return(0,g.tidy)(()=>{const e=function O$(t,n){return(0,g.tidy)(()=>g.cast(g.sum(g.logicalAnd(g.equal(t,1),g.equal(n,1))),"float32"))}(t,n),r=function kst(t,n){return(0,g.tidy)(()=>g.cast(g.sum(g.logicalAnd(g.equal(t,0),g.equal(n,1))),"float32"))}(t,n),i=g.add(e,r);return g.cast(g.where(g.greater(i,0),g.div(e,i),0),"float32")})},categoricalCrossentropy:R$,sparseCategoricalCrossentropy:L$,mse:k_,MSE:k_,mae:aI,MAE:aI,mape:uI,MAPE:uI,cosine:A$};function Kst(t){if("string"==typeof t&&t in z_)return z_[t];if("string"!=typeof t&&null!=t)return t;throw new be(`Unknown metric ${t}`)}function V_(t){if(Bl(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let n;for(const e of Object.keys(B_))if(B_[e]===t){n=e;break}if(void 0!==n)return n;for(const e of Object.keys(z_))if(z_[e]===t){n=e;break}return void 0!==n?n:t.name}}function F$(t,n,e=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!cI(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(t);r.length>1048576&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function cI(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const n=Object.keys(t);for(const e of n)if("string"!=typeof e||!cI(t[e]))return!1;return!0}if(Array.isArray(t)){for(const n of t)if(!cI(n))return!1;return!0}return!1}{const n=typeof t;return"string"===n||"number"===n||"boolean"===n}}function U_(t,n,e=console.log){let r="";for(let i=0;i<t.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r+=t[i],r=r.slice(0,n[i]),r+=" ".repeat(n[i]-r.length);e(r)}function qst(t,n,e){let r,i;try{i=t.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}U_([`${t.name} (${t.getClassName()})`,i,r,t.countParams().toString()],n,e)}function Jst(t,n,e,r){let i,s;try{s=t.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{s="multiple"}try{i=JSON.stringify(t.outputShape)}catch{i="multiple"}const o=[];for(const p of t.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(p)))for(let v=0;v<p.inboundLayers.length;++v)o.push(`${p.inboundLayers[v].name}[${p.nodeIndices[v]}][${p.tensorIndices[v]}]`);const a=t.name,u=t.getClassName(),c=0===o.length?"":o[0];U_([`${a} (${u})`,s,i,t.countParams().toString(),c],n,r);for(let p=1;p<o.length;++p)U_(["","","","",o[p]],n,r)}function $$(t,n,e){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===n&&"string"==typeof e}function hI(t,n){if(null===t)return null;if("string"==typeof t)return Vd(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let i=0;i<r;++i){const s=t[i];$$(n,i,s)?e.push(s):e.push(hI(s,n))}return e}{const e={};for(const r of Object.keys(t)){const i=t[r];if("name"===r&&"string"==typeof i)e[r]=i;else{const s=Vd(r);e[s]=hI(i,s)}}return e}}function dI(t,n){if(null==t)return null;if("string"==typeof t)return Ih(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],r=t.length;for(let i=0;i<r;++i){const s=t[i];$$(n,i,s)?e.push(s):e.push(dI(s,n))}return e}{const e={};for(const r of Object.keys(t)){const i=t[r];e[Ih(r)]="name"!==r&&"className"!==r||"string"!=typeof i?dI(i,r):i}return e}}class Tc extends xi{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,null==this.name){const S=this.getClassName().toLowerCase();this.name=I_(S)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(n.inputs)?n.inputs.slice():[n.inputs],this.outputs=Array.isArray(n.outputs)?n.outputs.slice():[n.outputs],Qh(this.inputs).length!==this.inputs.length)throw new be(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(S=>S.name)}`);Qh(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(S=>S.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const S of this.outputs){const J=S.nodeIndex,ht=S.tensorIndex;this.outputLayers.push(S.sourceLayer),this.outputLayersNodeIndices.push(J),this.outputLayersTensorIndices.push(ht)}for(const S of this.inputs){const U=S.sourceLayer,J=S.nodeIndex,ht=S.tensorIndex;Bl(0===J,"input layer has >1 nodes"),Bl(0===ht,"input layer has >1 tensors"),this.inputLayers.push(U),this.inputLayersNodeIndices.push(J),this.inputLayersTensorIndices.push(ht)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let S=0;S<this.inputLayers.length;S++){const U=this.inputLayers[S];if(!(U instanceof P_))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${S} (0-based) originates from layer type ${U.getClassName()}.`);this.inputNames.push(U.name),this.feedInputShapes.push(U.batchInputShape),this.feedInputNames.push(U.name)}for(const S of this.outputLayers)this.outputNames.push(S.name);this.internalInputShapes=this.inputs.map(S=>S.shape),this.internalOutputShapes=this.outputs.map(S=>S.shape);const e={},r={},i={},s={},o={},a=[],u=(S,U,J,ht,Tt,Pt)=>{(null==ht||null==Tt||null==Pt)&&(ht=S.sourceLayer,Tt=S.nodeIndex,Pt=S.tensorIndex);const zt=ht.inboundNodes[Tt];if(-1!==J.indexOf(zt))throw new uc(`The tensor ${S.name} at layer "${ht.name}" is part of a cycle.`);if(-1!==U.indexOf(zt))return;this.containerNodes.add(Tc.nodeKey(ht,Tt)),ht.id in o||(o[ht.id]=Object.keys(o).length),-1===J.indexOf(zt)&&J.push(zt);const Ot=zt.inboundLayers.length;for(let le=0;le<Ot;le++)u(zt.inputTensors[le],U,J,zt.inboundLayers[le],zt.nodeIndices[le],zt.tensorIndices[le]);for(U.push(zt);J.indexOf(zt)>=0;)J.splice(J.indexOf(zt),1);a.push(zt)},c=[],d=[];for(const S of this.outputs)u(S,c,d);const p=a.slice().reverse();for(const S of p){r[S.id]=S,S.id in e||(e[S.id]=0);let U=e[S.id];U=Math.max(U,null==i[S.outboundLayer.id]?0:i[S.outboundLayer.id]),i[S.outboundLayer.id]=U,s[S.outboundLayer.id]=S.outboundLayer,e[S.id]=U;for(let ht=0;ht<S.inboundLayers.length;ht++){const zt=S.inboundLayers[ht].inboundNodes[S.nodeIndices[ht]];e[zt.id]=Math.max(U+1,null==e[zt.id]?0:e[zt.id]),r[zt.id]=zt}}const v={};for(const S in e){const U=e[S];U in v||(v[U]=[]),v[U].push(r[S])}const x={};for(const S in i){const U=i[S];U in x||(x[U]=[]),x[U].push(s[S])}let b=Object.keys(x).map(S=>parseInt(S,10)).sort(b_);this.layers=[];for(const S of b){const U=x[S];U.sort((J,ht)=>{const Tt=o[J.id],Pt=o[ht.id];return Tt<Pt?-1:Tt>Pt?1:0});for(const J of U)J instanceof Tc&&this.internalContainerRefs.push(J),this.layers.push(J)}this.layersByDepth=x,b=Object.keys(v).map(S=>parseInt(S,10)).sort(b_);const w=this.inputs.slice(),T=[];for(const S of b)for(const U of v[S]){const J=U.outboundLayer;if(null!=J){for(const ht of U.inputTensors)if(-1===w.indexOf(ht))throw new uc(`Graph disconnected: cannot obtain value for tensor ${ht} at layer "${J.name}". The following previous layers were accessed without issue: ${T}`);for(const ht of U.outputTensors)w.push(ht);T.push(J.name)}}this.nodesByDepth=v;const N=this.layers.map(S=>S.name);for(const S of N){const U=N.filter(J=>J===S).length;if(1!==U)throw new uc(`The name "${S}" is used ${U} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(N))}this.outboundNodes=[],this.inboundNodes=[],new M_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(S=>null),outputMasks:this.outputs.map(S=>null),inputShapes:this.inputs.map(S=>S.shape),outputShapes:this.outputs.map(S=>S.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const n={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)n.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)n.numDisposedVariables+=e.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new be("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(const e of this.layers)n=n.concat(e.trainableWeights);return n}get nonTrainableWeights(){const n=[];for(const e of this.layers)n.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,e=!0){const r={};let i=0;const s=(t=>{const n=Object.keys(t);if(0===n.length)return!1;const e=n[0].split("/");return!isNaN(parseInt(e[e.length-1],10))})(n);s&&this.parseWeights(n);for(const a of this.layers)for(const[u,c]of a.weights.entries()){const d=s?`${c.name.split("/").slice(0,-1).join("/")+"/"}${u}`:c.originalName;if(null!=r[d])throw new be(`Duplicate weight name: ${d}`);r[d]=c,i++}const o=[];for(const a in n){let u=a;if(null==r[a]){const c=a.split("/");u=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(null!=r[u])o.push([r[u],n[a]]);else if(e)throw new be(`Provided weight data has no target variable: ${a}`);delete r[u]}if(e){const a=[];for(const u in r)a.push(u);if(a.length>0)throw new be(`${a.length} of ${i} weights are not set: ${a}`)}iI(o)}parseWeights(n){for(const e in Object.keys(n)){const r=e.split("/"),i=["vars","layer_checkpoint_dependencies"],s=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!i.includes(o)).join("/");s!==e&&(n[s]=n[e],delete n[e])}}updatedConfig(){const n=this.getConfig(),e={};return e.className=this.getClassName(),e.config=n,e.kerasVersion="tfjs-layers 4.17.0",e.backend="TensorFlow.js",e}toJSON(n,e=!0){const r=dI(this.updatedConfig());return e?JSON.stringify(r):r}call(n,e){return(0,g.tidy)(()=>{n=Gs(n);const r=new td;for(let i=0;i<this.inputs.length;++i)r.add(this.inputs[i],n[i]);return Fg(this.outputs,r,e)})}computeMask(n,e){return(0,g.tidy)(()=>{let r;return n=Gs(n),r=null==e?zd(null,n.length):Gs(e),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){const e=N_(n);if(e.length!==this.inputLayers.length)throw new be(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(b_);if(i.length>1)for(const a of i){const u=this.nodesByDepth[a];for(const c of u){const d=c.outboundLayer;if(-1!==this.inputLayers.map(w=>w.id).indexOf(d.id))continue;const p=[];for(let w=0;w<c.inboundLayers.length;w++)p.push(r[`${c.inboundLayers[w].name}_${c.nodeIndices[w]}_${c.tensorIndices[w]}`]);const x=N_(d.computeOutputShape(hl(p))),b=d.inboundNodes.indexOf(c);for(let w=0;w<x.length;w++)r[`${d.name}_${b}_${w}`]=x[w]}}const s=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const u=o[a];Bl(u in r),s.push(r[u])}return hl(s)}runInternalGraph(n,e){null==e&&(e=zd(null,n.length));const r={};for(let u=0;u<this.inputs.length;++u)r[this.inputs[u].id]=[n[u],e[u]];const i=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(b_);for(const u of i){const c=this.nodesByDepth[u];for(const d of c){const p=d.outboundLayer,v=d.inputTensors,x=d.outputTensors,b=new Array;for(const w of v)w.id in r&&b.push(r[w.id]);if(b.length===v.length){let T,N,S,U,w={};if(null!=d.callArgs&&(w=d.callArgs),1===b.length){const[J,ht]=b[0];null==w.mask&&(w.mask=ht),S=Gs(p.call(J,w)),U=Gs(p.computeMask(J,ht)),T=[J],N=[ht]}else T=b.map(J=>J[0]),N=b.map(J=>J[1]),null==w.mask&&(w.mask=N),S=Gs(p.call(T,w)),U=Gs(p.computeMask(T,N));if(p.activityRegularizer)throw new ci("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let J=0;J<x.length;++J)r[x[J].id]=[S[J],U[J]]}}}const s=[],o=[],a=[];for(const u of this.outputs){Bl(u.id in r,`Could not compute output ${u.name} : ${u.id}`);const[c,d]=r[u.id];a.push(c.shape),s.push(c),o.push(d)}return[s,o,a]}buildNodeConversionMap(n){const e={};let r;for(const i of this.layers){r=i instanceof Tc?1:0;for(let s=0;s<i.inboundNodes.length;s++){const o=Tc.nodeKey(i,s);this.containerNodes.has(o)&&(e[o]=r,r+=1)}}return e}getLayer(n,e){if(null!=e)return this.findLayer(e);if(null==n)throw new be("Provide either a layer name or layer index");if("number"==typeof n)return this.findLayer(n);for(const r of this.layers)if(r.name===n)return r;throw new be(`No such layer: ${n}`)}findLayer(n){if(this.layers.length<=n)throw new be(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}calculateLosses(){return(0,g.tidy)(()=>{const n=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const i=Tc.nodeKey(e,r);this.containerNodes.has(i)&&n.push(...e.calculateLosses())}return n})}getConfig(){const n={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),u=o.getConfig(),c=[];for(let p=0;p<o.inboundNodes.length;p++){const v=o.inboundNodes[p],x=Tc.nodeKey(o,p);let b={};if(this.containerNodes.has(x)){if(v.callArgs)try{JSON.stringify(v.callArgs),b=v.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${v.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(v.inboundLayers.length>0){const w=[];for(let T=0;T<v.inboundLayers.length;T++){const N=v.inboundLayers[T],U=v.tensorIndices[T];let ht=e[Tc.nodeKey(N,v.nodeIndices[T])];null==ht&&(ht=0),w.push([N.name,ht,U,b])}c.push(w)}}}const d={};d.name=o.name,d.className=a,d.config=u,d.inboundNodes=c,r.push(d)}n.layers=r;const i=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],c=Tc.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let d=e[c];null==d&&(d=0),i.push([a.name,d,this.inputLayersTensorIndices[o]])}n.inputLayers=i;const s=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],c=Tc.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let d=e[c];null==d&&(d=0),s.push([a.name,d,this.outputLayersTensorIndices[o]])}return n.outputLayers=s,n}static fromConfig(n,e,r={},i=!1){const s={},o={};function a(T,N){T.name in o?o[T.name].push(N):o[T.name]=[N]}function u(T,N){const S=[];let U;for(const J of N){const ht=J[0],Tt=J[1],Pt=J[2];if(U=null==J[3]?{}:J[3],!(ht in s))return void a(T,N);const zt=s[ht];if(zt.inboundNodes.length<=Tt)return void a(T,N);S.push(zt.inboundNodes[Tt].outputTensors[Pt])}S.length>0&&T.apply(hl(S),U)}function c(T){const N=T.name,S=Sh(T,null!=e.customObjects?e.customObjects:{});S.setFastWeightInitDuringBuild(i),s[N]=S,T.inboundNodes.forEach(J=>{if(!(J instanceof Array))throw new be(`Corrupted configuration, expected array for nodeData: ${J}`);a(S,J)})}const d=e.name,p=e.layers;for(const T of p)c(T);for(;!Iit(o);)for(const T of p){const N=s[T.name];if(N.name in o){const S=o[N.name];delete o[N.name];for(const U of S)u(N,U)}}const v=[],x=[],b=e.inputLayers;for(const T of b){const N=T[0],S=T[1],U=T[2];Bl(N in s),v.push(s[N].inboundNodes[S].outputTensors[U])}const w=e.outputLayers;for(const T of w){const N=T[0],S=T[1],U=T[2];Bl(N in s),x.push(s[N].inboundNodes[S].outputTensors[U])}return new n({inputs:v,outputs:x,name:d})}get stateful(){if(this._stateful)throw new be("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const n of this.layers)if(n.stateful)return!0;return!1}resetStates(){(0,g.tidy)(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}}function z$(t,n){return function B$(t,n,e){const r=n.length;if(null==t||Array.isArray(t)&&0===t.length)return n.map(i=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&n[0]in t?[t[n[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${e} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const i=[];return n.forEach(s=>{i.push(s in t?t[s]:null)}),i}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${n} keys. Provided ${e} not understood: ${JSON.stringify(t)}`)}(t,n,"classWeight")}function V$(t,n,e,r){return pI.apply(this,arguments)}function pI(){return(pI=(0,Mr.Z)(function*(t,n,e,r){if(null!=n||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const i=(0,g.tidy)(()=>{if(1===t.shape.length)return(0,g.clone)(t);if(2===t.shape.length){if(t.shape[1]>1)return(0,g.argMax)(t,1);if(1===t.shape[1])return(0,g.reshape)(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield i.data());(0,g.dispose)(i);const o=[];return s.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),(0,g.tensor1d)(o,"float32")}return null})).apply(this,arguments)}function eot(t,n){return(0,g.mul)(t,n)}function U$(t,n){let e,r;e=n.xs,r=n.ys,g.util.assert(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);const s=W$("input",t.inputNames,e),o=W$("output",t.outputNames,r),a=s[0].shape[0];g.util.assert(s.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),g.util.assert(o.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let u=0;u<s.length;u++)g.util.assert(s[u].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[u]} has ${s[u].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let u=0;u<o.length;u++)g.util.assert(o[u].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[u]} has ${o[u].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:s,ys:o}}function W$(t,n,e){if(e instanceof g.Tensor)return[e];if(Array.isArray(e))return g.util.assert(e.length===n.length,()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`),e;{const r=[];for(const i of n){if(null==e[i])throw new be(`The feature data generated by the dataset lacks the required ${t} key '${i}'.`);r.push(e[i])}return r}}function mI(){return(mI=(0,Mr.Z)(function*(t,n,e){const r=null!=e.batchesPerEpoch;if(g.util.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),g.util.assert(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),g.util.assert(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),g.util.assert(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),g.util.assert(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const i=null!=e.validationData;let s,o;if(i)if(G$(e.validationData))g.util.assert(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const T=function rot(t){if(3===t.length)throw new ci("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(e.validationData);s=T.xs,o=T.ys}const a=t.makeTrainFunction(),u=t.getDedupedMetricsNames();let c;c=i?u.slice().concat(u.map(T=>"val_"+T)):u.slice();const d=T$(e.callbacks,e.yieldEvery),p=null==e.verbose?1:e.verbose,{callbackList:v,history:x}=N$(d,p,e.epochs,null,null,function sot(t,n){let e=null;return null!=n.batchesPerEpoch?e=n.batchesPerEpoch:Number.isFinite(t.size)&&(e=t.size),e}(n,e),null,i,c);v.setModel(t),t.history=x,yield v.onTrainBegin(),t.stopTraining_=!1;let b=null==e.initialEpoch?0:e.initialEpoch,w=yield n.iterator();for(;b<e.epochs;){const T={};yield v.onEpochBegin(b);let N=0,S=0;for(r||(w=yield n.iterator());!r||N<e.batchesPerEpoch;){const U=yield w.next();if(r&&U.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${N} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=U.value){const{xs:J,ys:ht}=U$(t,U.value),Tt={};Tt.batch=S,Tt.size=J[0].shape[0],yield v.onBatchBegin(S,Tt);const Pt=[];if(null!=e.classWeight){const le=z$(e.classWeight,t.outputNames);for(let ge=0;ge<le.length;++ge)Pt.push(yield V$(ht[ge],null,le[ge]))}const zt=J.concat(ht).concat(Pt),Ot=a(zt);g.dispose(zt);for(let le=0;le<u.length;++le){const Ae=Ot[le];Tt[u[le]]=Ae,g.keep(Ae)}yield v.onBatchEnd(S,Tt),D$(Tt),S++,N++}if(r?N>=e.batchesPerEpoch:U.done){if(i){let J;J=G$(e.validationData)?Gs(yield t.evaluateDataset(e.validationData,{batches:e.validationBatches})):Gs(t.evaluate(s,o,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let ht=0;ht<t.metricsNames.length;++ht)T[`val_${t.metricsNames[ht]}`]=J[ht]}break}if(t.stopTraining_)break}if(yield v.onEpochEnd(b,T),b++,t.stopTraining_)break}return yield v.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})).apply(this,arguments)}function G$(t){return"function"==typeof t.iterator}function gI(){return(gI=(0,Mr.Z)(function*(t,n,e){const r=null!=(e=e||{}).batches,i=t.testFunction;let s=[];if(e.verbose>0)throw new ci("Verbose mode is not implemented yet.");g.util.assert(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=function oot(t){return"function"==typeof t.next}(n)?n:yield n.iterator();let a=0,u=0;for(;!r||u<e.batches;){const c=yield o.next();if(s=g.tidy(()=>{if(c.value){const{xs:d,ys:p}=U$(t,c.value),v=d.concat(p),x=g.tidy(()=>i(v));if(g.dispose(v),0===u)for(let w=0;w<x.length;++w)s.push((0,g.scalar)(0));const b=v[0].shape[0];for(let w=0;w<x.length;++w){const T=x[w],N=s[w];s[w]=g.tidy(()=>g.add(s[w],g.mul(b,T))),u>0&&g.dispose(N)}g.dispose(x),a+=b,++u}return s}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<s.length;++c){const d=s[c];s[c]=g.div(s[c],a),g.dispose(d)}return hl(s)})).apply(this,arguments)}function yI(t){g.util.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function zg(t,n,e){return null==t?[null]:Array.isArray(t)?t.map(r=>Gd(r,n,e-n)):Gd(t,n,e-n)}function vI(t,n){return g.tidy(()=>null==t?null:Array.isArray(t)?t.map(e=>vI(e,n)):h$(t,"int32"===n.dtype?n:g.cast(n,"int32")))}function _I(t,n){const e=[];let r=0,i=null;for(;r<t;)i=r+n,i>=t&&(i=t),e.push([r,i]),r=i;return e}function H$(t){const n=[];t instanceof g.Tensor&&(t=[t]);for(let e=0;e<t.length;++e){const r=t[e];if(1===r.rank)n.push(Rg(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function Nc(t,n){if(null==t)return;const e=[];if(n instanceof g.Tensor)e.push(n.id);else if(Array.isArray(n))n.forEach(i=>e.push(i.id));else if(null!=n)for(const i in n)e.push(n[i].id);const r=[];if(t instanceof g.Tensor)-1===e.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(i=>{-1===e.indexOf(i.id)&&r.push(i)});else if(null!=t)for(const i in t){const s=t[i];-1===e.indexOf(s.id)&&r.push(s)}r.forEach(i=>{i.isDisposed||i.dispose()})}function xI(t){return Array.isArray(t)}function j$(t){return!function uot(t){return t instanceof g.Tensor}(t)&&!xI(t)}function K$(t,n,e,r=!0,i=""){if(null==n||0===n.length){if(null!=t){let o=!1;if(xI(t)&&t.length>0)o=!0;else if(j$(t)){for(const a in t)if(t.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new be(`Error when checking model ${i} expected no data, but got ${t}`)}return[]}if(null==t)return n.map(o=>null);let s;if(j$(t)){s=[];for(const o of n){if(null==t[o])throw new be(`No data provided for "${o}". Need data for each key in: ${n}`);s.push(t[o])}}else if(xI(t)){if(t.length!==n.length)throw new be(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(n.length>1)throw new be(`The model ${i} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=H$(s),null!=e)for(let o=0;o<n.length;++o){if(null==e[o])continue;const a=s[o];if(a.shape.length!==e[o].length)throw new be(`Error when checking ${i}: expected ${n[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[o].length;++u){if(0===u&&!r)continue;const d=e[o][u];if(null!=d&&d>=0&&a.shape[u]!==d)throw new be(`${i} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function X$(t,n,e,r=!0,i=""){let s;if(Array.isArray(t)){if(t.length!==n.length)throw new be(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(n.length>1)throw new be(`The model expects ${n.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(null!=e)for(let o=0;o<n.length;++o){if(null==e[o])continue;const a=s[o];if(a.shape.length!==e[o].length)throw new be(`Error when checking ${i}: expected ${n[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[o].length;++u){if(0===u&&!r)continue;const d=e[o][u];if(null!=d&&d!==a.shape[u])throw new be(`Error when checking ${i}: expected ${n[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Dp=(()=>{class t extends Tc{constructor(e){super(e),this.isTraining=!1}summary(e,r,i=console.log){if(!this.built)throw new be("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Zst(t,n,e,r=console.log){const i=function Qst(t){let n=!0;const e=[],r=[];for(const i in t.nodesByDepth)e.push(t.nodesByDepth[i]);for(const i of e){if(i.length>1||1===i.length&&i[0].inboundLayers.length>1){n=!1;break}r.push(...i)}if(n)for(const i of t.layers){let s=!1;for(const o of i.inboundNodes)if(-1!==r.indexOf(o)){if(s){n=!1;break}s=!0}if(!n)break}return n}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(i?(n=n||90,e=e||[.32,.61,.89,1]):(n=n||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(d=>Math.floor(n*d))),!i){s.push("Receives inputs"),o=[];for(const d in t.nodesByDepth)o.push(...t.nodesByDepth[d])}r("_".repeat(n)),U_(s,e,r),r("=".repeat(n));const a=t.layers;for(let d=0;d<a.length;++d)i?qst(a[d],e,r):Jst(a[d],e,o,r),r((d===a.length-1?"=":"_").repeat(n));t.checkTrainableWeightsConsistency();const u=function Yst(t){let n;return n=A_(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),n}(t),c=A_(t.nonTrainableWeights);r(`Total params: ${u+c}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${c}`),r("_".repeat(n))}(this,e,r,i)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Xst(t){const n={Adagrad:()=>g.train.adagrad(.01),Adadelta:()=>g.train.adadelta(1,.95,Ya()),Adam:()=>g.train.adam(.001,.9,.999,Ya()),Adamax:()=>g.train.adamax(.002,.9,.999,Ya(),0),RMSProp:()=>g.train.rmsprop(.001,.9,0,Ya()),SGD:()=>g.train.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new be(`Unknown Optimizer ${t}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof g.Optimizer))throw new be("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new be(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(u=>lI(u))}else{const a=lI(e.loss);this.outputs.forEach(u=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new be(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(lI(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const u=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(u),this.feedLossFns.push(this.lossFunctions[a])}const i=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Wd("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===i.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const s=function hot(t,n){if(null==t||Array.isArray(t)&&0===t.length)return n.map(r=>[]);let e;if("string"==typeof t||"function"==typeof t)e=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);e=t}if(Array.isArray(e))return n.map(r=>e);{const r=[];for(const i of n){let s=e.hasOwnProperty(i)?e[i]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}(e.metrics,this.outputNames),o=(a,u,c)=>{this.outputNames.length>1&&(u=this.outputNames[a]+"_"+u),this.metricsNames.push(u),this.metricsTensors.push([c,a])};Wd("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===i.indexOf(a)&&(d=>{let v,x,b;for(const w of d){if("string"==typeof w&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(w)){const N=this.internalOutputShapes[a];let S;1===N[N.length-1]||this.lossFunctions[a]===$_?-1!==["accuracy","acc"].indexOf(w)?x=M$:-1!==["crossentropy","ce"].indexOf(w)&&(x=$st):this.lossFunctions[a]===F_?-1!==["accuracy","acc"].indexOf(w)?x=Bst:-1!==["crossentropy","ce"].indexOf(w)&&(x=L$):-1!==["accuracy","acc"].indexOf(w)?x=P$:-1!==["crossentropy","ce"].indexOf(w)&&(x=R$),-1!==["accuracy","acc"].indexOf(w)?S="acc":-1!==["crossentropy","ce"].indexOf(w)&&(S="ce"),b=x,v=""+S}else b=Kst(w),v=""+V_(w);let T;Wd(v,()=>{T=b}),o(a,v,T)}})(s[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,i={}){const s=null==i.batchSize?32:i.batchSize;yI(s);const a=this.standardizeUserDataXY(e,r,!0,s);try{const u=a[0].concat(a[1]);return this.makeTestFunction(),hl(this.testLoop(this.testFunction,u,s,i.verbose,i.steps))}finally{Nc(a[0],e),Nc(a[1],r)}}evaluateDataset(e,r){var i=this;return(0,Mr.Z)(function*(){return i.makeTestFunction(),function aot(t,n,e){return gI.apply(this,arguments)}(i,e,r)})()}checkNumSamples(e,r,i,s="steps"){let o;if(null!=i){if(o=null,null!=r)throw new be(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new be(`Either the input data should have a defined shape, or ${s} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new be("`outputs` is an empty Array, which is not allowed.");const i=Array.isArray(r),o=this.retrieveSymbolicTensors(i?r:[r]),a=new td;if(e instanceof g.Tensor&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new be(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const d=e[c.name];if(null==d)throw new be(`No value is provided for the model's input ${c.name}`);a.add(c,d)}const u=Fg(o,a);return i?u:u[0]}retrieveSymbolicTensors(e){const r=zd(null,e.length);let i=e.length;for(const s of this.layers){const o=Array.isArray(s.output)?s.output:[s.output],a=o.map(u=>u.name);for(let u=0;u<e.length;++u){const c=a.indexOf(e[u]);if(-1!==c&&(r[u]=o[c],i--),0===i)break}if(0===i)break}if(i>0){const s=[];throw r.forEach((o,a)=>{null==o&&s.push(e[a])}),new be(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return r}predictLoop(e,r=32,i=!1){return g.tidy(()=>{const s=this.checkNumSamples(e);if(i)throw new ci("Verbose predictLoop() is not implemented yet.");const o=_I(s,r),a=this.outputs.map(u=>[]);for(let u=0;u<o.length;++u)g.tidy(()=>{const v=zg(e,o[u][0],o[u][1]),x=[];if(Array.isArray(v))for(let w=0;w<v.length;++w)x.push({key:this.inputs[w],value:v[w]});else x.push({key:this.inputs[0],value:v});const b=new td(x);return Fg(this.outputs,b)}).forEach((d,p)=>a[p].push(d));return hl(a.map(u=>g.concat(u,0)))})}predict(e,r={}){const i=H$(e);X$(i,this.inputNames,this.feedInputShapes,!1);try{const s=null==r.batchSize?32:r.batchSize;return yI(s),this.predictLoop(i,s)}finally{Nc(i,e)}}predictOnBatch(e){X$(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,i=!0,s){if(null==this.optimizer_)throw new uc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const u=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===F_?u.slice(0,u.length-1).concat([1]):u)}if(function lot(t,n,e){const r=Qh(t.map(s=>s.shape[0]));r.sort();const i=Qh(n.map(s=>s.shape[0]));if(i.sort(),r.length>1)throw new be(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(i.length>1)throw new be(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(r.length>0&&i.length>0&&!g.util.arraysEqual(r,i))throw new be(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}(e=K$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=K$(r,this.feedOutputNames,o,!1,"target")),function cot(t,n,e){const r=[k_,$_,Bg];for(let i=0;i<t.length;++i){const s=t[i],o=n[i],a=e[i];if(null!=o){if(o===Bg&&1===s.shape[s.shape.length-1])throw new be(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const u=s.shape.slice(1),c=a.slice(1);for(let d=0;d<u.length;++d){const v=c[d];if(null!=v&&u[d]!==v)throw new be(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&e[0].shape[0]%s!=0)throw new be(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,i,s,o=!0,a){var u=this;return(0,Mr.Z)(function*(){const[c,d]=u.standardizeUserDataXY(e,r,o,a);if(null!=i)throw new Error("sample weight is not supported yet.");let p=null;if(null!=s){const v=z$(s,u.outputNames);p=[];for(let x=0;x<v.length;++x)p.push(yield V$(d[x],null,v[x]))}return[c,d,p]})()}testLoop(e,r,i,s=0,o){return g.tidy(()=>{const a=this.checkNumSamples(r,i,o,"steps"),u=[];if(s>0)throw new ci("Verbose mode is not implemented yet.");if(null!=o)throw new ci("steps mode in testLoop() is not implemented yet");{const c=_I(a,i),d=(0,g.tensor1d)(Ic(0,a));for(let p=0;p<c.length;++p){const v=c[p][0],x=c[p][1],b=Gd(d,v,x-v),w=vI(r,b),T=e(w);if(0===p)for(let N=0;N<T.length;++N)u.push((0,g.scalar)(0));for(let N=0;N<T.length;++N)u[N]=g.add(u[N],g.mul(x-v,T[N]))}for(let p=0;p<u.length;++p)u[p]=g.div(u[p],a)}return u})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let i=0;i<e.length;++i){const s=e[i];let o=s;t$(e,s)>1&&(o+=`_${t$(e.slice(0,i),s)}`),r.push(o)}return r}makeTrainFunction(){return e=>{const r=[],i=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],c=this.collectedTrainableWeights.map(v=>v.read());return[this.optimizer_.minimize(()=>{const v=[];for(let T=0;T<this.inputs.length;++T)v.push({key:this.inputs[T],value:i[T]});const x=new td(v),b=Fg(this.outputs,x,{training:!0});let w;for(let T=0;T<this.lossFunctions.length;++T){let S=(0,this.lossFunctions[T])(s[T],b[T]);null!=o[T]&&(S=eot(S,o[T]));const U=g.mean(S);r.push(U),w=0===T?S:g.add(w,S)}for(let T=0;T<this.metricsTensors.length;++T){let N;if(this.outputs.length>1&&T<this.outputs.length)N=r[T];else{const U=this.metricsTensors[T][1];N=g.mean((0,this.metricsTensors[T][0])(s[U],b[U]))}g.keep(N),a.push(N)}return w=g.mean(w),this.calculateLosses().forEach(T=>{w=g.add(w,T)}),w},!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>g.tidy(()=>{const r=[];let i;const s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let d=0;d<this.inputs.length;++d)a.push({key:this.inputs[d],value:s[d]});const u=new td(a),c=Fg(this.outputs,u);for(let d=0;d<this.lossFunctions.length;++d){const v=g.mean((0,this.lossFunctions[d])(o[d],c[d]));i=0===d?v:g.add(i,v),r.push(i)}for(let d=0;d<this.metricsTensors.length;++d){const v=this.metricsTensors[d][1],x=g.mean((0,this.metricsTensors[d][0])(o[v],c[v]));r.push(x)}return r})}fit(e,r,i={}){var s=this;return(0,Mr.Z)(function*(){if(s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,u,c,d,p,v,x,b;s.isTraining=!0;try{const w=null==i.batchSize?32:i.batchSize;yI(w);const T=!1,N=yield s.standardizeUserData(e,r,i.sampleWeight,i.classWeight,T,w);o=N[0],a=N[1],b=N[2];let U,S=!1;if(null!=i.validationData&&i.validationData.length>0){if(S=!0,2!==i.validationData.length)throw 3===i.validationData.length?new ci("validationData including sample weights is not supported yet."):new be(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${i.validationData} is invalid.`);d=i.validationData[0],p=i.validationData[1];const ge=!0,Ae=yield s.standardizeUserData(d,p,null,null,ge,w);v=Ae[0],x=Ae[1],U=v.concat(x)}else if(null!=i.validationSplit&&i.validationSplit>0&&i.validationSplit<1){S=!0;const ge=Math.floor(o[0].shape[0]*(1-i.validationSplit)),Ae=o[0].shape[0];v=zg(o,ge,Ae),u=o,o=zg(o,0,ge),x=zg(a,ge,Ae),c=a,a=zg(a,0,ge),U=v.concat(x)}else null!=i.validationSteps&&(S=!0);const J=o.concat(a).concat(b);s.checkTrainableWeightsConsistency();const ht=s.makeTrainFunction(),Tt=s.getDedupedMetricsNames();let Pt,zt;S?(s.makeTestFunction(),Pt=s.testFunction,zt=Tt.slice().concat(Tt.map(ge=>"val_"+ge))):(Pt=null,U=[],zt=Tt.slice());const Ot=T$(i.callbacks,i.yieldEvery);return yield s.fitLoop(ht,J,Tt,w,i.epochs,i.verbose,Ot,Pt,U,i.shuffle,zt,i.initialEpoch,null,null)}finally{s.isTraining=!1,Nc(o,e),Nc(a,r),Nc(u,e),Nc(c,r),Nc(v,d),Nc(x,p),null!=b&&g.dispose(b)}})()}fitLoop(e,r,i,s,o,a,u,c,d,p,v,x,b,w){var T=this;return(0,Mr.Z)(function*(){null==s&&(s=32),null==o&&(o=1),null==p&&(p=!0),null==x&&(x=0);let N=!1;if(null!=c&&null!=d&&(N=!0),null!=w&&(N=!0,null==b))throw new be("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const S=T.checkNumSamples(r,s,b,"steps_per_epoch");let U;null!=S&&(U=Ic(0,S)),null==a&&(a=1);const{callbackList:J,history:ht}=N$(u,a,o,x,S,b,s,N,v);J.setModel(T),T.history=ht,yield J.onTrainBegin(),T.stopTraining_=!1;for(let Tt=x;Tt<o;++Tt){yield J.onEpochBegin(Tt);const Pt={};if(null!=b)throw new ci("stepsPerEpoch mode is not implemented yet.");{if("batch"===p)throw new ci("batch shuffling is not implemneted yet");p&&g.util.shuffle(U);const zt=(0,g.tensor1d)(U),Ot=_I(S,s);for(let le=0;le<Ot.length;++le){const ge={};if(yield J.onBatchBegin(le,ge),g.tidy(()=>{const Ae=Ot[le][0],Re=Ot[le][1],ve=Gd(zt,Ae,Re-Ae);ge.batch=le,ge.size=Re-Ae;const Ne=vI(r,ve),Se=e(Ne);for(let Ke=0;Ke<i.length;++Ke){const Be=Se[Ke];ge[i[Ke]]=Be,g.keep(Be)}if(le===Ot.length-1&&N){const Ke=T.testLoop(c,d,s);for(let Le=0;Le<i.length;++Le){const Be=i[Le],on=Ke[Le];g.keep(on),Pt["val_"+Be]=on}}}),yield J.onBatchEnd(le,ge),D$(ge),T.stopTraining_)break}zt.dispose()}if(yield J.onEpochEnd(Tt,Pt),T.stopTraining_)break}return yield J.onTrainEnd(),yield T.history.syncData(),T.history})()}fitDataset(e,r){var i=this;return(0,Mr.Z)(function*(){return function iot(t,n,e){return mI.apply(this,arguments)}(i,e,r)})()}trainOnBatch(e,r){var i=this;return(0,Mr.Z)(function*(){const s=yield i.standardizeUserData(e,r),o=s[0],a=s[1],c=i.makeTrainFunction()(o.concat(a)),d=[];for(const p of c){const v=yield p.data();d.push(v[0])}return g.dispose(c),Nc(s[0],e),Nc(s[1],r),hl(d)})()}getNamedWeights(e){const r=[],i=null!=e&&e.trainableOnly,s=i?this.trainableWeights:this.weights,o=this.getWeights(i);for(let a=0;a<s.length;++a)i&&!s[a].trainable||r.push({name:s[a].originalName,tensor:o[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=g.memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-g.memory().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Ih(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Ih(r))}else{const r=Object.keys(this.loss);e={};const i=this.loss;for(const s of r){if("string"!=typeof i[s])throw new Error("Serialization of non-string loss is not supported.");e[s]=Ih(i[s])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Ih(V_(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ih(V_(e)));{const e={};for(const r in this.metrics)e[r]=Ih(V_(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const i=Sh(hI(e.optimizer_config));let s,o;if("string"==typeof e.loss)s=Vd(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(a=>Vd(a));else if(null!=e.loss){s={};for(const a in e.loss)s[a]=Vd(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>Vd(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=Vd(e.metrics[a])}this.compile({loss:s,metrics:o,optimizer:i})}save(e,r){var i=this;return(0,Mr.Z)(function*(){if("string"==typeof e){const p=g.io.getSaveHandlers(e);if(0===p.length)throw new be(`Cannot find any save handlers for URL '${e}'`);if(p.length>1)throw new be(`Found more than one (${p.length}) save handlers for URL '${e}'`);e=p[0]}if(null==e.save)throw new be("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=yield g.io.encodeWeights(i.getNamedWeights(r)),c={modelTopology:i.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.17.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=i.optimizer){c.trainingConfig=i.getTrainingConfig();const p="optimizer",{data:v,specs:x}=yield g.io.encodeWeights(yield i.optimizer.getWeights(),p);s.specs.push(...x),s.data=g.io.concatenateArrayBuffers([s.data,v])}return null!=i.userDefinedMetadata&&(F$(i.userDefinedMetadata,i.name,!0),c.userDefinedMetadata=i.userDefinedMetadata),c.weightData=s.data,c.weightSpecs=s.specs,e.save(c)})()}setUserDefinedMetadata(e){F$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return t.className="Model",t})();g.serialization.registerClass(Dp),g.serialization.registerClass((()=>{class t extends Dp{}return t.className="Functional",t})());let got=(()=>{class t extends Dp{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:I_("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(i=>i<0))throw new be(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof t||e instanceof Dp;let i;if(r){if(i=e,1!==i.outputs.length)throw new be("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==i.inputs.length)throw new be("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new be("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=function cst(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new be("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=t.batchShape;null!=t.shape&&null==n&&(n=[null].concat(t.shape));let e=t.dtype;return null==e&&(e="float32"),new P_({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(r)this.outputs=i.outputs,this.inputs=i.inputs;else{if(1!==e.inboundNodes.length)throw new be(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new be("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=b$(this.outputs[0])}this.inboundNodes=[],new M_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:zd(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(xs(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Dp({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,i=console.log){this.built||this.build(),super.summary(e,r,i)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,i={}){if(!this.built)throw new uc("The model needs to be compiled before being used.");return this.model.evaluate(e,r,i)}evaluateDataset(e,r){var i=this;return(0,Mr.Z)(function*(){if(!i.built)throw new uc("The model needs to be compiled before being used.");return i.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,i={}){var s=this;return(0,Mr.Z)(function*(){if(!s.built)throw new uc("The model needs to be compiled before being used.");return s.model.fit(e,r,i)})()}fitDataset(e,r){var i=this;return(0,Mr.Z)(function*(){if(!i.built)throw new uc("The model needs to be compiled before being used.");return i.model.fitDataset(e,r)})()}trainOnBatch(e,r){var i=this;return(0,Mr.Z)(function*(){return i.model.trainOnBatch(e,r)})()}static fromConfig(e,r,i={},s=!1){let o,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new be("Legacy serialization format not supported yet.");o=r}else g.util.assert(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=r.layers,delete r.layers,a=r;const u=new e(a);if(!(u instanceof t))throw new ci(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(const c of o){const p=Sh(c,void 0,s);s&&p.setFastWeightInitDuringBuild(!0),u.add(p)}return u}set stopTraining(e){if(null==this.model)throw new be("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new be("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const i={};i.className=r.getClassName(),i.config=r.getConfig(),e.push(i)}return{name:this.name,layers:e}}}return t.className="Sequential",t})();g.serialization.registerClass(got);class dl extends g.serialization.Serializable{getConfig(){return{}}}let yot=(()=>{class t extends dl{apply(e,r=1){return function Uit(t,n=1){if(1!==n)throw new ci(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return g.elu(t)}(e,r)}}return t.className="elu",t})();g.serialization.registerClass(yot);let vot=(()=>{class t extends dl{apply(e){return g.selu(e)}}return t.className="selu",t})();g.serialization.registerClass(vot);let _ot=(()=>{class t extends dl{apply(e){return g.relu(e)}}return t.className="relu",t})();g.serialization.registerClass(_ot);let xot=(()=>{class t extends dl{apply(e){return(0,g.tidy)(()=>g.minimum(6,g.relu(e)))}}return t.className="relu6",t})();g.serialization.registerClass(xot),g.serialization.registerClass((()=>{class t extends dl{apply(e){return e}}return t.className="linear",t})());let Cot=(()=>{class t extends dl{apply(e){return g.sigmoid(e)}}return t.className="sigmoid",t})();g.serialization.registerClass(Cot);let bot=(()=>{class t extends dl{apply(e){return function Git(t){return(0,g.tidy)(()=>{const n=g.add(.5,g.mul(.2,t));return g.clipByValue(n,0,1)})}(e)}}return t.className="hardSigmoid",t})();g.serialization.registerClass(bot);let wot=(()=>{class t extends dl{apply(e){return g.softplus(e)}}return t.className="softplus",t})();g.serialization.registerClass(wot);let Iot=(()=>{class t extends dl{apply(e){return function Wit(t){return(0,g.tidy)(()=>g.div(t,g.add(g.abs(t),1)))}(e)}}return t.className="softsign",t})();g.serialization.registerClass(Iot);let Sot=(()=>{class t extends dl{apply(e){return g.tanh(e)}}return t.className="tanh",t})();g.serialization.registerClass(Sot);let Z$=(()=>{class t extends dl{apply(e,r=-1){return g.softmax(e,r)}}return t.className="softmax",t})();g.serialization.registerClass(Z$);let Tot=(()=>{class t extends dl{apply(e,r=-1){return g.logSoftmax(e,r)}}return t.className="logSoftmax",t})();g.serialization.registerClass(Tot);let Not=(()=>{class t extends dl{apply(e,r=1){return(0,g.tidy)(()=>g.mul(g.sigmoid(g.mul(e,r)),e))}}return t.className="swish",t})();g.serialization.registerClass(Not);let Aot=(()=>{class t extends dl{apply(e){return(0,g.tidy)(()=>g.mul(e,g.tanh(g.softplus(e))))}}return t.className="mish",t})();function nd(t){return t.getClassName()}function wI(t,n={}){return Pg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"activation")}function rd(t){if(null==t){return wI({className:"linear",config:{}})}if("string"==typeof t){const n={};return n.className=t,n.config={},wI(n)}return t instanceof dl?t:wI(t)}g.serialization.registerClass(Aot);class Y$ extends g.serialization.Serializable{}let SI=(()=>{class t extends Y${constructor(e){super(),function II(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return(0,g.tidy)(()=>{let r=(0,g.zeros)([1]);return this.hasL1&&(r=(0,g.add)(r,(0,g.sum)(g.mul(this.l1,(0,g.abs)(e))))),this.hasL2&&(r=(0,g.add)(r,(0,g.sum)(g.mul(this.l2,Lg(e))))),g.reshape(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return t.className="L1L2",t})();g.serialization.registerClass(SI);const Q$={l1l2:"L1L2"};function _o(t){return Zw(t)}function q$(t,n={}){return Pg(t,g.serialization.SerializationMap.getMap().classNameMap,n,"regularizer")}function Xo(t){return null==t?null:"string"==typeof t?q$({className:t in Q$?Q$[t]:t,config:{}}):t instanceof Y$?t:q$(t)}function Tp(t,n,e){if("number"==typeof t)return zd(t,n);if(t.length!==n)throw new be(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${t.length} elements.`);for(let r=0;r<n;++r){const i=t[r];if(!kit(i))throw new be(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`)}return t}function Ac(t,n,e,r,i=1){if(null==t)return t;let o;return o="same"===e?t:t-(n+(n-1)*(i-1))+1,Math.floor((o+r-1)/r)}function nh(t,n,e,r){if(null==t)return null;if("valid"===r)t=t*n+Jh([e-n,0]);else{if("same"!==r)throw new be(`Unsupport padding mode: ${r}.`);t*=n}return t}function DI(t,n){return(0,g.tidy)(()=>(Na(n),"channelsFirst"===n?g.transpose(t,[0,2,3,1]):t))}function J$(t,n){return(0,g.tidy)(()=>(Na(n),"channelsFirst"===n?g.transpose(t,[0,2,3,4,1]):t))}function TI(t,n,e,r=[1,1],i="valid",s,o,a=null){return(0,g.tidy)(()=>{if(null==s&&(s="channelsLast"),Na(s),3!==t.rank&&4!==t.rank)throw new be(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==n.rank&&4!==n.rank)throw new be(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let u=DI(t,s);if("causal"===i)throw new ci("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=g.fused.conv2d({x:u,filter:n,strides:r,pad:"same"===i?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===s&&(u=g.transpose(u,[0,3,1,2])),u})}g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=Fr(e);let i=(0,g.relu)(e);return null!=this.maxValue&&(i=(0,g.clipByValue)(i,0,this.maxValue)),i}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ReLU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const i=Fr(e);return(0,g.leakyRelu)(i,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LeakyReLU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Ko(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Xo(e.alphaRegularizer),this.alphaConstraint=Ja(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new be(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=xs(e)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)r[s-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const i={};if(null!=this.sharedAxes)for(let s=1;s<e.length;++s)i[s]=e[s];this.inputSpec=[new Qa({ndim:e.length,axes:i})],this.built=!0}call(e,r){return e=Fr(e),(0,g.prelu)(e,this.alpha.read())}getConfig(){const e={alphaInitializer:oa(this.alphaInitializer),alphaRegularizer:_o(this.alphaRegularizer),alphaConstraint:qa(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return t.className="PReLU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new ci(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,r){const i=Fr(e);return(0,g.elu)(i)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ELU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,r){const i=Fr(e);return(0,g.mul)(i,(0,g.cast)((0,g.greater)(i,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ThresholdedReLU",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Z$).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,r){return(0,g.tidy)(()=>{let i=Fr(e);const s=r.mask;if(null!=s){const o=(0,g.mul)((0,g.sub)((0,g.ones)(i.shape),(0,g.cast)(s,i.dtype)),(0,g.scalar)(-1e9));i=(0,g.add)(i,o)}return this.axis instanceof Array?this.axis.length>1?(0,g.exp)((0,g.sub)(i,(0,g.logSumExp)(i,this.axis,!0))):this.softmax(i,this.axis[0]):this.softmax(i,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Softmax",t})());class W_ extends xi{constructor(n,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",W_.verifyArgs(e),this.rank=n,hu(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new ci(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Tp(e.kernelSize,n,"kernelSize"),this.strides=Tp(null==e.strides?1:e.strides,n,"strides"),this.padding=null==e.padding?"valid":e.padding,zl(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Na(this.dataFormat),this.activation=rd(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=Ko(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ja(e.biasConstraint),this.biasRegularizer=Xo(e.biasRegularizer),this.activityRegularizer=Xo(e.activityRegularizer),this.dilationRate=Tp(null==e.dilationRate?1:e.dilationRate,n,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new be(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new be(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new be(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(n){if(Bl("kernelSize"in n,"required key 'kernelSize' not in config"),"number"!=typeof n.kernelSize&&!Qw(n.kernelSize,"number",1,3))throw new be(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){const n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:nd(this.activation),useBias:this.useBias,biasInitializer:oa(this.biasInitializer),biasRegularizer:_o(this.biasRegularizer),activityRegularizer:_o(this.activityRegularizer),biasConstraint:qa(this.biasConstraint)},e=super.getConfig();return Object.assign(n,e),n}}class Np extends W_{constructor(n,e){super(n,e),this.kernel=null,Np.verifyArgs(e),this.filters=e.filters,hu(this.filters,"filters"),this.kernelInitializer=Ko(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ja(e.kernelConstraint),this.kernelRegularizer=Xo(e.kernelRegularizer)}build(n){n=xs(n);const e="channelsFirst"===this.dataFormat?1:n.length-1;if(null==n[e])throw new be(`The channel dimension of the input should be defined. Found ${n[e]}`);const r=n[e],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(n,e){return(0,g.tidy)(()=>{let r;n=Fr(n);const i=null==this.bias?null:this.bias.read(),s=n$(this.activation.getClassName());if(null!=s&&2===this.rank)r=TI(n,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)r=function tB(t,n,e,r=1,i="valid",s,o=1){return(0,g.tidy)(()=>{if(null==s&&(s="channelsLast"),Na(s),3!==t.shape.length)throw new be(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==n.shape.length)throw new be(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new be(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===s&&(t=g.transpose(t,[0,2,1])),"causal"===i)throw new ci("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=g.conv1d(t,n,r,"same"===i?"same":"valid","NWC",o);return null!=e&&(a=Dc(a,e)),a})}(n,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=TI(n,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new ci("convolutions greater than 3D are not implemented yet.");r=function eB(t,n,e,r=[1,1,1],i="valid",s,o){return(0,g.tidy)(()=>{if(null==s&&(s="channelsLast"),Na(s),4!==t.rank&&5!==t.rank)throw new be(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==n.rank&&5!==n.rank)throw new be(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=J$(t,s);if("causal"===i)throw new ci("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=g.conv3d(a,n,r,"same"===i?"same":"valid","NDHWC",o),null!=e&&(a=Dc(a,e)),"channelsFirst"===s&&(a=g.transpose(a,[0,4,1,2,3])),a})}(n,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=xs(n);const e=[],r="channelsLast"===this.dataFormat?n.slice(1,n.length-1):n.slice(2);for(let s=0;s<r.length;++s){const o=Ac(r[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);e.push(o)}let i=[n[0]];return"channelsLast"===this.dataFormat?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const n={filters:this.filters,kernelInitializer:oa(this.kernelInitializer),kernelRegularizer:_o(this.kernelRegularizer),kernelConstraint:qa(this.kernelConstraint)},e=super.getConfig();return Object.assign(n,e),n}static verifyArgs(n){if(!("filters"in n)||"number"!=typeof n.filters||n.filters<1)throw new be(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}}let nB=(()=>{class t extends Np{constructor(e){super(2,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Qw(e.kernelSize,"number",1,2))throw new be(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv2D",t})();g.serialization.registerClass(nB);let rB=(()=>{class t extends Np{constructor(e){super(3,e),t.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new be(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv3D",t})();g.serialization.registerClass(rB);let Fot=(()=>{class t extends nB{constructor(e){if(super(e),this.inputSpec=[new Qa({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new be(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=xs(e)).length)throw new be("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new be("The channel dimension of the inputs should be defined. Found `None`.");const i=e[r],s=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qa({ndim:4,axes:{[r]:i}})],this.built=!0}call(e,r){return g.tidy(()=>{let i=Fr(e);if(4!==i.shape.length)throw new be(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const s=i.shape;let a,u;"channelsFirst"===this.dataFormat?(a=2,u=3):(a=1,u=2);const d=s[u],v=this.kernelSize[1],b=this.strides[1],N=[s[0],nh(s[a],this.strides[0],this.kernelSize[0],this.padding),nh(d,b,v,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=g.transpose(i,[0,2,3,1]));let S=g.conv2dTranspose(i,this.kernel.read(),N,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(S=g.transpose(S,[0,3,1,2])),null!=this.bias&&(S=Dc(S,this.bias.read(),this.dataFormat)),null!=this.activation&&(S=this.activation.apply(S)),S})}computeOutputShape(e){const r=(e=xs(e)).slice();let i,s,o;"channelsFirst"===this.dataFormat?(i=1,s=2,o=3):(i=3,s=1,o=2);const a=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1];return r[i]=this.filters,r[s]=nh(r[s],c,a,this.padding),r[o]=nh(r[o],d,u,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv2DTranspose",t})();g.serialization.registerClass(Fot);let $ot=(()=>{class t extends rB{constructor(e){if(super(e),this.inputSpec=[new Qa({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new be(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=xs(e)).length)throw new be("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new be("The channel dimension of the inputs should be defined. Found `None`.");const i=e[r],s=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qa({ndim:5,axes:{[r]:i}})],this.built=!0}call(e,r){return g.tidy(()=>{let i=Fr(e);if(5!==i.shape.length)throw new be(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const s=i.shape;let a,u,c;"channelsFirst"===this.dataFormat?(c=2,a=3,u=4):(c=1,a=2,u=3);const p=s[a],v=s[u],b=this.kernelSize[1],w=this.kernelSize[2],N=this.strides[1],S=this.strides[2],Tt=[s[0],nh(s[c],this.strides[0],this.kernelSize[0],this.padding),nh(p,N,b,this.padding),nh(v,S,w,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=g.transpose(i,[0,2,3,4,1]));let Pt=g.conv3dTranspose(i,this.kernel.read(),Tt,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(Pt=g.transpose(Pt,[0,4,1,2,3])),null!==this.bias&&(Pt=Dc(Pt,this.bias.read(),this.dataFormat)),null!==this.activation&&(Pt=this.activation.apply(Pt)),Pt})}computeOutputShape(e){const r=(e=xs(e)).slice();let i,s,o,a;"channelsFirst"===this.dataFormat?(i=1,s=2,o=3,a=4):(i=4,s=1,o=2,a=3);const u=this.kernelSize[0],c=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],v=this.strides[1],x=this.strides[2];return r[i]=this.filters,r[s]=nh(r[s],p,u,this.padding),r[o]=nh(r[o],v,c,this.padding),r[a]=nh(r[a],x,d,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv3DTranspose",t})();g.serialization.registerClass($ot);let Bot=(()=>{class t extends Np{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new be("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new be("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new be(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=Ko(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Xo(r.depthwiseRegularizer),this.depthwiseConstraint=Ja(r.depthwiseConstraint),this.pointwiseInitializer=Ko(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Xo(r.pointwiseRegularizer),this.pointwiseConstraint=Ja(r.pointwiseConstraint)}build(e){if((e=xs(e)).length<this.rank+2)throw new be(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new be(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const i=e[r],s=this.kernelSize.concat([i,this.depthMultiplier]),o=[];for(let u=0;u<this.rank;++u)o.push(1);o.push(i*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new Qa({ndim:this.rank+2,axes:{[r]:i}})],this.built=!0}call(e,r){return(0,g.tidy)(()=>{let i;if(e=Fr(e),1===this.rank)throw new ci("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=g.transpose(e,[0,2,3,1])),i=g.separableConv2d(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(i=Dc(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),"channelsFirst"===this.dataFormat&&(i=g.transpose(i,[0,3,1,2])),i})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=oa(this.depthwiseInitializer),e.pointwiseInitializer=oa(this.pointwiseInitializer),e.depthwiseRegularizer=_o(this.depthwiseRegularizer),e.pointwiseRegularizer=_o(this.pointwiseRegularizer),e.depthwiseConstraint=qa(this.depthwiseConstraint),e.pointwiseConstraint=qa(this.pointwiseConstraint),e}}return t.className="SeparableConv",t})();g.serialization.registerClass((()=>{class t extends Bot{constructor(e){super(2,e)}}return t.className="SeparableConv2D",t})()),g.serialization.registerClass((()=>{class t extends Np{constructor(e){super(1,e),t.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Qw(e.kernelSize,"number",1,1))throw new be(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv1D",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return(0,g.tidy)(()=>{if(e=Fr(e),"channelsLast"===this.dataFormat){const i=D_(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return D_(i,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const i=D_(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return D_(i,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Cropping2D",t})());let Wot=(()=>{class t extends xi{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Na(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function Oit(t){Ud(Nit,"InterpolationFormat",t)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return g.tidy(()=>{let i=Fr(e);const s=i.shape;if("channelsFirst"===this.dataFormat){i=g.transpose(i,[0,2,3,1]);const o=this.size[0]*s[2],a=this.size[1]*s[3],u="nearest"===this.interpolation?g.image.resizeNearestNeighbor(i,[o,a]):g.image.resizeBilinear(i,[o,a]);return g.transpose(u,[0,3,1,2])}{const o=this.size[0]*s[1],a=this.size[1]*s[2];return"nearest"===this.interpolation?g.image.resizeNearestNeighbor(i,[o,a]):g.image.resizeBilinear(i,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return t.className="UpSampling2D",t})();g.serialization.registerClass(Wot);let Hot=(()=>{class t extends W_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Ko(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ja(e.depthwiseConstraint),this.depthwiseRegularizer=Xo(e.depthwiseRegularizer)}build(e){if((e=xs(e)).length<4)throw new be(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new be(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const i=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return(0,g.tidy)(()=>{let i=function Got(t,n,e=[1,1],r="valid",i,s){return(0,g.tidy)(()=>{null==i&&(i="channelsLast"),Na(i);let o=DI(t,i);if(4!==t.rank)throw new be(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==n.rank)throw new be(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return o=g.depthwiseConv2d(o,n,e,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===i&&(o=g.transpose(o,[0,3,1,2])),o})}(e=Fr(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(i=Dc(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),i})}computeOutputShape(e){e=xs(e);const i="channelsFirst"===this.dataFormat?e[3]:e[2],s="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=Ac("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=Ac(i,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],s,o,a]:[e[0],o,a,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=oa(this.depthwiseInitializer),e.depthwiseRegularizer=_o(this.depthwiseRegularizer),e.depthwiseConstraint=qa(this.depthwiseRegularizer),e}}return t.className="DepthwiseConv2D",t})();function iB(t,n,e,r){if(Array.isArray(t)){if(null!=n||null!=e)throw new be("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(n=t.slice(1,t.length)),t=t[0]}function i(s){return null==s||Array.isArray(s)?s:[s]}return{inputs:t,initialState:n=i(n),constants:e=i(e)}}function sB(t,n,e,r=!1,i,s,o=!1,a=!1){return g.tidy(()=>{const u=n.shape.length;if(u<3)throw new be(`Input should be at least 3D, but is ${u}D.`);const c=[1,0].concat(Ic(2,u));if(n=g.transpose(n,c),null!=s)throw new ci("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=g.cast(g.cast(i,"bool"),"float32")).rank===u-1&&(i=g.expandDims(i,-1)),i=g.transpose(i,c)),r&&(n=g.reverse(n,0),null!=i&&(i=g.reverse(i,0)));const d=[];let p,v=e;const x=n.shape[0],b=g.unstack(n);let w,T;null!=i&&(w=g.unstack(i));for(let N=0;N<x;++N){const S=b[N],U=g.tidy(()=>t(S,v));if(null==i)p=U[0],v=U[1];else{const J=g.tidy(()=>{const ht=w[N],Tt=g.sub(g.onesLike(ht),ht);return{output:g.add(g.mul(U[0],ht),g.mul(v[0],Tt)),newStates:v.map((Ot,le)=>g.add(g.mul(U[1][le],ht),g.mul(Ot,Tt)))}});p=J.output,v=J.newStates}a&&d.push(p)}return a&&(T=g.stack(d,1)),[p,T,v]})}g.serialization.registerClass(Hot);let Vg=(()=>{class t extends xi{constructor(e){let r;if(super(e),null==e.cell)throw new be("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new uB({cells:e.cell}):e.cell,null==r.stateSize)throw new be("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Qa({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?Ic(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){nI(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const i=r[0];let s;if(s=this.returnSequences?[e[0],e[1],i]:[e[0],i],this.returnState){const o=[];for(const a of r)o.push([e[0],a]);return[s].concat(o)}return s}computeMask(e,r){return g.tidy(()=>{Array.isArray(r)&&(r=r[0]);const i=this.returnSequences?r:null;if(this.returnState){const s=this.states.map(o=>null);return[i].concat(s)}return i})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let i=0;i<e;++i)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new ci("Constants support is not implemented in RNN yet.");nI(e)&&(e=e[0]);const i=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Qa({shape:[i,null,...s]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!g.util.arraysEqual(this.stateSpec.map(u=>u.shape[u.shape.length-1]),a))throw new be(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(u=>new Qa({shape:[null,u]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){(0,g.tidy)(()=>{if(!this.stateful)throw new Qc("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(null==i)throw new be("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>g.zeros([i,s])):[g.zeros([i,this.cell.stateSize])];else if(null==e)g.dispose(this.states_),null!=this.keptStates&&(g.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>g.zeros([i,s])):this.states_[0]=g.zeros([i,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new be(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):g.dispose(this.states_);for(let s=0;s<this.states_.length;++s){const o=e[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,u=[i,a];if(!g.util.arraysEqual(o.shape,u))throw new be(`State ${s} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${o.shape}`);this.states_[s]=o}}this.states_=this.states_.map(s=>g.keep(s.clone()))})}apply(e,r){let i=null==r?null:r.initialState,s=null==r?null:r.constants;null==r&&(r={});const o=iB(e,i,s,this.numConstants);e=o.inputs,i=o.initialState,s=o.constants;let a=[],u=[];if(null!=i){r.initialState=i,a=a.concat(i),this.stateSpec=[];for(const d of i)this.stateSpec.push(new Qa({shape:d.shape}));u=u.concat(this.stateSpec)}if(null!=s&&(r.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof eh){const d=[e].concat(a),p=this.inputSpec.concat(u),v=this.inputSpec;this.inputSpec=p;const x=super.apply(d,r);return this.inputSpec=v,x}return super.apply(e,r)}call(e,r){return(0,g.tidy)(()=>{const i=null==r?null:r.mask,s=null==r?null:r.training;let o=null==r?null:r.initialState;e=Fr(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new be(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const u={training:s},d=sB((w,T)=>{const N=this.cell.call([w].concat(T),u);return[N[0],N.slice(1)]},e,o,this.goBackwards,i,null,this.unroll,this.returnSequences),p=d[0],v=d[1],x=d[2];this.stateful&&this.resetStates(x,s);const b=this.returnSequences?v:p;return this.returnState?[b].concat(x):b})}getInitialState(e){return(0,g.tidy)(()=>{let r=g.zeros(e.shape);return r=g.sum(r,[1,2]),r=Rg(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>i>1?tI(r,[1,i]):r):this.cell.stateSize>1?[tI(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===t.className&&(r.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),e),r)}static fromConfig(e,r,i={}){const o=Sh(r.cell,i);return new e(Object.assign(r,{cell:o}))}}return t.className="RNN",t})();g.serialization.registerClass(Vg);class G_ extends xi{}let oB=(()=>{class t extends G_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,hu(this.units,"units"),this.activation=rd(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Ko(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ko(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ko(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Xo(e.kernelRegularizer),this.recurrentRegularizer=Xo(e.recurrentRegularizer),this.biasRegularizer=Xo(e.biasRegularizer),this.kernelConstraint=Ja(e.kernelConstraint),this.recurrentConstraint=Ja(e.recurrentConstraint),this.biasConstraint=Ja(e.biasConstraint),this.dropout=Ip([1,Jh([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Ip([1,Jh([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=xs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return(0,g.tidy)(()=>{if(2!==e.length)throw new be(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let i=e[1];e=e[0];const s=null!=r.training&&r.training;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=id({ones:()=>g.onesLike(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=id({ones:()=>g.onesLike(i),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,u=this.recurrentDropoutMask;o=Jc(null!=a?g.mul(e,a):e,this.kernel.read()),null!=this.bias&&(o=Dc(o,this.bias.read())),null!=u&&(i=g.mul(i,u));let c=g.add(o,Jc(i,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:nd(this.activation),useBias:this.useBias,kernelInitializer:oa(this.kernelInitializer),recurrentInitializer:oa(this.recurrentInitializer),biasInitializer:oa(this.biasInitializer),kernelRegularizer:_o(this.kernelRegularizer),recurrentRegularizer:_o(this.recurrentRegularizer),biasRegularizer:_o(this.biasRegularizer),activityRegularizer:_o(this.activityRegularizer),kernelConstraint:qa(this.kernelConstraint),recurrentConstraint:qa(this.recurrentConstraint),biasConstraint:qa(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return t.className="SimpleRNNCell",t})();g.serialization.registerClass(oB);let jot=(()=>{class t extends Vg{constructor(e){e.cell=new oB(e),super(e)}call(e,r){return(0,g.tidy)(()=>(null!=this.cell.dropoutMask&&(g.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(g.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return t.className="SimpleRNN",t})();g.serialization.registerClass(jot);let aB=(()=>{class t extends G_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new be("GRUCell does not support reset_after parameter set to true.");this.units=e.units,hu(this.units,"units"),this.activation=rd(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=rd(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Ko(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ko(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ko(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Xo(e.kernelRegularizer),this.recurrentRegularizer=Xo(e.recurrentRegularizer),this.biasRegularizer=Xo(e.biasRegularizer),this.kernelConstraint=Ja(e.kernelConstraint),this.recurrentConstraint=Ja(e.recurrentConstraint),this.biasConstraint=Ja(e.biasConstraint),this.dropout=Ip([1,Jh([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Ip([1,Jh([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=xs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return(0,g.tidy)(()=>{if(2!==e.length)throw new be(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const i=null!=r.training&&r.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=id({ones:()=>g.onesLike(e),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=id({ones:()=>g.onesLike(s),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let u,c,d;0<this.dropout&&this.dropout<1&&(e=g.mul(e,this.dropoutMask[0]));let p=Jc(e,this.kernel.read());this.useBias&&(p=Dc(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=g.mul(s,a[0]));const v=this.recurrentKernel.read(),[x,b]=g.split(v,[2*this.units,this.units],v.rank-1),w=Jc(s,x),[T,N,S]=g.split(p,3,p.rank-1),[U,J]=g.split(w,2,w.rank-1);u=this.recurrentActivation.apply(g.add(T,U)),c=this.recurrentActivation.apply(g.add(N,J));const ht=Jc(g.mul(c,s),b);d=this.activation.apply(g.add(S,ht));const Tt=g.add(g.mul(u,s),g.mul(g.add(1,g.neg(u)),d));return[Tt,Tt]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:nd(this.activation),recurrentActivation:nd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:oa(this.kernelInitializer),recurrentInitializer:oa(this.recurrentInitializer),biasInitializer:oa(this.biasInitializer),kernelRegularizer:_o(this.kernelRegularizer),recurrentRegularizer:_o(this.recurrentRegularizer),biasRegularizer:_o(this.biasRegularizer),activityRegularizer:_o(this.activityRegularizer),kernelConstraint:qa(this.kernelConstraint),recurrentConstraint:qa(this.recurrentConstraint),biasConstraint:qa(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return t.className="GRUCell",t})();g.serialization.registerClass(aB);let Kot=(()=>{class t extends Vg{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new aB(e),super(e)}call(e,r){return(0,g.tidy)(()=>(null!=this.cell.dropoutMask&&(g.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(g.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="GRU",t})();g.serialization.registerClass(Kot);let NI=(()=>{class t extends G_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,hu(this.units,"units"),this.activation=rd(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=rd(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Ko(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ko(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ko(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Xo(e.kernelRegularizer),this.recurrentRegularizer=Xo(e.recurrentRegularizer),this.biasRegularizer=Xo(e.biasRegularizer),this.kernelConstraint=Ja(e.kernelConstraint),this.recurrentConstraint=Ja(e.recurrentConstraint),this.biasConstraint=Ja(e.biasConstraint),this.dropout=Ip([1,Jh([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Ip([1,Jh([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let s;if(e=xs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;s=new((r=class extends cc{apply(c,d){const p=o.apply([a]),v=(new f$).apply([a]),x=o.apply([2*a]);return c$(c$(p,v),x)}}).className="CustomInit",r)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return(0,g.tidy)(()=>{const i=null!=r.training&&r.training;if(3!==e.length)throw new be(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=id({ones:()=>g.onesLike(e),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=id({ones:()=>g.onesLike(s),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const u=this.recurrentDropoutMask;let c,d,p,v;0<this.dropout&&this.dropout<1&&(e=g.mul(e,this.dropoutMask[0]));let x=Jc(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=g.mul(s,u[0])),x=g.add(x,Jc(s,this.recurrentKernel.read())),this.useBias&&(x=Dc(x,this.bias.read()));const[b,w,T,N]=g.split(x,4,x.rank-1);c=this.recurrentActivation.apply(b),d=this.recurrentActivation.apply(w),p=g.add(g.mul(d,o),g.mul(c,this.activation.apply(T))),v=this.recurrentActivation.apply(N);const S=g.mul(v,this.activation.apply(p));return[S,S,p]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:nd(this.activation),recurrentActivation:nd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:oa(this.kernelInitializer),recurrentInitializer:oa(this.recurrentInitializer),biasInitializer:oa(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:_o(this.kernelRegularizer),recurrentRegularizer:_o(this.recurrentRegularizer),biasRegularizer:_o(this.biasRegularizer),activityRegularizer:_o(this.activityRegularizer),kernelConstraint:qa(this.kernelConstraint),recurrentConstraint:qa(this.recurrentConstraint),biasConstraint:qa(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return t.className="LSTMCell",t})();g.serialization.registerClass(NI);let Xot=(()=>{class t extends Vg{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new NI(e),super(e)}call(e,r){return(0,g.tidy)(()=>(null!=this.cell.dropoutMask&&(g.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(g.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return t.className="LSTM",t})();g.serialization.registerClass(Xot);let uB=(()=>{class t extends G_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return(0,g.tidy)(()=>{let i=e.slice(1);const s=[];for(const u of this.cells.slice().reverse())Array.isArray(u.stateSize)?s.push(i.splice(0,u.stateSize.length)):s.push(i.splice(0,1));s.reverse();const o=[];let a;for(let u=0;u<this.cells.length;++u){const c=this.cells[u];i=s[u],a=0===u?[e[0]].concat(i):[a[0]].concat(i),a=c.call(a,r),o.push(a.slice(1))}i=[];for(const u of o.slice().reverse())i.push(...u);return[a[0]].concat(i)})}build(e){let r;nI(e)&&(e=e[0]),this.cells.forEach((i,s)=>{Wd(`RNNCell_${s}`,()=>{i.build(e),r=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),s={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),s)}static fromConfig(e,r,i={}){const s=[];for(const o of r.cells)s.push(Sh(o,i));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const i of this.cells)r.push(...i.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return rI(e)}setWeights(e){const r=[];for(const i of this.cells){const o=e.splice(i.weights.length);for(let a=0;a<i.weights.length;++a)r.push([i.weights[a],o[a]])}iI(r)}}return t.className="StackedRNNCells",t})();function id(t){const{ones:n,rate:e,training:r=!1,count:i=1,dropoutFunc:s}=t,o=()=>null!=s?s(n(),e):d$(n(),e),a=()=>kg(o,n,r);return!i||i<=1?g.keep(a().clone()):Array(i).fill(void 0).map(a).map(c=>g.keep(c.clone()))}g.serialization.registerClass(uB);let Yot=(()=>{class t extends Vg{constructor(e){if(e.unroll)throw new ci("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ci("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Qa({ndim:5})]}call(e,r){return g.tidy(()=>{if(null!=this.cell.dropoutMask&&(g.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(g.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new be("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return g.tidy(()=>{const{stateSize:r}=this.cell,s=this.computeSingleOutputShape(e.shape),o=[s[0],...s.slice(2)],a=g.zeros(o);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){g.tidy(()=>{if(!this.stateful)throw new Qc("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape,s=this.computeSingleOutputShape(i),o=[s[0],...s.slice(2)];if(null==i[0])throw new be("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>g.zeros(o)):[g.zeros(o)];else if(null==e)g.dispose(this.states_),null!=this.keptStates&&(g.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>g.zeros(o)):this.states_[0]=g.zeros(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new be(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):g.dispose(this.states_);for(let u=0;u<this.states_.length;++u){const c=e[u],d=o;if(!g.util.arraysEqual(c.shape,d))throw new be(`State ${u} is incompatible with layer ${this.name}: expected shape=${d}, received shape=${c.shape}`);this.states_[u]=c}}this.states_=this.states_.map(u=>g.keep(u.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:i,kernelSize:s,padding:o,strides:a,dilationRate:u}=this.cell,c="channelsFirst"===r,p=e[c?4:3],v=Ac(e[c?3:2],s[0],o,a[0],u[0]),x=Ac(p,s[1],o,a[1],u[1]);return[...e.slice(0,2),...c?[i,v,x]:[v,x,i]]}}return t.className="ConvRNN2D",t})(),lB=(()=>{class t extends NI{constructor(e){const{filters:r,kernelSize:i,strides:s,padding:o,dataFormat:a,dilationRate:u}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,hu(this.filters,"filters"),this.kernelSize=Tp(i,2,"kernelSize"),this.kernelSize.forEach(c=>hu(c,"kernelSize")),this.strides=Tp(s||1,2,"strides"),this.strides.forEach(c=>hu(c,"strides")),this.padding=o||"valid",zl(this.padding),this.dataFormat=a||"channelsLast",Na(this.dataFormat),this.dilationRate=Tp(u||1,2,"dilationRate"),this.dilationRate.forEach(c=>hu(c,"dilationRate"))}build(e){var r;e=xs(e);const i="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[i])throw new be(`The channel dimension of the input should be defined. Found ${e[i]}`);const a=this.kernelSize.concat([e[i],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const u=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",u,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const d=this.biasInitializer,p=this.filters;c=new((r=class extends cc{apply(x,b){return Jw([d.apply([p]),g.ones([p]),d.apply([2*p])])}}).className="CustomInit",r)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return g.tidy(()=>{if(3!==e.length)throw new be(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const i=r.training||!1,s=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=id({ones:()=>g.onesLike(s),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,d=(rn,pn,qe)=>pn&&pn[qe]?g.mul(pn[qe],rn):rn;let p=d(s,c,0),v=d(s,c,1),x=d(s,c,2),b=d(s,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=id({ones:()=>g.onesLike(o),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const w=this.recurrentDropoutMask;let T=d(o,w,0),N=d(o,w,1),S=d(o,w,2),U=d(o,w,3);const[ht,Tt,Pt,zt]=g.split(this.kernel.read(),4,3),[Ot,le,ge,Ae]=this.useBias?g.split(this.bias.read(),4):[null,null,null,null];p=this.inputConv(p,ht,Ot,this.padding),v=this.inputConv(v,Tt,le,this.padding),x=this.inputConv(x,Pt,ge,this.padding),b=this.inputConv(b,zt,Ae,this.padding);const[Re,ve,Ne,Se]=g.split(this.recurrentKernel.read(),4,3);T=this.recurrentConv(T,Re),N=this.recurrentConv(N,ve),S=this.recurrentConv(S,Ne),U=this.recurrentConv(U,Se);const Ke=this.recurrentActivation.apply(g.add(p,T)),Le=this.recurrentActivation.apply(g.add(v,N)),Be=g.add(g.mul(Le,a),g.mul(Ke,this.activation.apply(g.add(x,S)))),on=g.mul(this.recurrentActivation.apply(g.add(b,U)),this.activation.apply(Be));return[on,on,Be]})}getConfig(){const i=function(t,n){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(t);i<r.length;i++)n.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(e[r[i]]=t[r[i]])}return e}(super.getConfig(),["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},i),s)}inputConv(e,r,i,s){const o=g.conv2d(e,r,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return i?Dc(o,i,this.dataFormat):o}recurrentConv(e,r){return g.conv2d(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return t.className="ConvLSTM2DCell",t})();g.serialization.registerClass(lB),g.serialization.registerClass((()=>{class t extends Yot{constructor(e){const r=new lB(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return t.className="ConvLSTM2D",t})());let cB=(()=>{class t extends xi{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,i=[];for(let s=0;s<this.noiseShape.length;++s)i.push(null==this.noiseShape[s]?r[s]:this.noiseShape[s]);return i}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e);if(0<this.rate&&this.rate<1){const s=null!=r.training&&r.training,o=this.getNoiseShape(i);return kg(()=>d$(i,this.rate,o,this.seed),()=>i,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return t.className="Dropout",t})();g.serialization.registerClass(cB),g.serialization.registerClass((()=>{class t extends cB{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return t.className="SpatialDropout1D",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,hu(this.units,"units"),this.activation=rd(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Ko(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Ko(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ja(e.kernelConstraint),this.biasConstraint=Ja(e.biasConstraint),this.kernelRegularizer=Xo(e.kernelRegularizer),this.biasRegularizer=Xo(e.biasRegularizer),this.activityRegularizer=Xo(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=xs(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=xs(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e),s=n$(this.activation.getClassName());let o;return null!=s?o=Jc(i,this.kernel.read(),s,this.bias?this.bias.read():null):(o=Jc(i,this.kernel.read()),null!=this.bias&&(o=Dc(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:nd(this.activation),useBias:this.useBias,kernelInitializer:oa(this.kernelInitializer),biasInitializer:oa(this.biasInitializer),kernelRegularizer:_o(this.kernelRegularizer),biasRegularizer:_o(this.biasRegularizer),activityRegularizer:_o(this.activityRegularizer),kernelConstraint:qa(this.kernelConstraint),biasConstraint:qa(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dense",t})());let tat=(()=>{class t extends xi{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=xs(e);for(const r of e.slice(1))if(null==r)throw new be(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],qh(e,1)]}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);let i=Fr(e);if("channelsFirst"===this.dataFormat&&i.rank>1){const s=[0];for(let o=2;o<i.rank;++o)s.push(o);s.push(1),i=(0,g.transpose)(i,s)}return function Vit(t){if(t.rank<=1)throw new be(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const n=[t.shape[0],qh(t.shape,1)];return g.reshape(t,n)}(i)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return t.className="Flatten",t})();g.serialization.registerClass(tat),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.supportsMasking=!0,this.activation=rd(e.activation)}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e);return this.activation.apply(i)})}getConfig(){const e={activation:nd(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Activation",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return(0,g.tidy)(()=>function Bit(t,n){return(0,g.tidy)(()=>{if(2!==t.shape.length)throw new be(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return tI(Rg(t,1),[1,n,1])})}(e=Fr(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return t.className="RepeatVector",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const i="Total size of new array must be unchanged.",s=r.slice();let o=1,a=null;for(let c=0;c<s.length;++c){const d=s[c];if(this.isUnknown(d)){if(null!==a)throw new be("Can only specifiy one unknown dimension.");a=c}else o*=d}const u=qh(e);if(null!==a){if(0===o||u%o!=0)throw new be(i);s[a]=u/o}else if(u!==o)throw new be(i);return s}computeOutputShape(e){let r=!1;for(let i=0;i<e.length;++i)if(this.isUnknown(e[i])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e),s=i.shape,o=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return(0,g.reshape)(i,o)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Reshape",t})());let iat=(()=>{class t extends xi{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=Ic(1,e.dims.length+1);if(!g.util.arraysEqual(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Qa({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=xs(e)).slice();return this.dims.forEach((i,s)=>{r[s+1]=e[i]}),r}call(e,r){return(0,g.transpose)(Fr(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Permute",t})();g.serialization.registerClass(iat),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const i=Fr(e);return(0,g.any)((0,g.notEqual)(i,this.maskValue),-1)}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e),a=(0,g.any)((0,g.notEqual)(i,this.maskValue),-1,!0);return(0,g.mul)(i,(0,g.cast)(a,i.dtype))})}}return t.className="Masking",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(Gs(e.inputLength))}this.inputDim=e.inputDim,hu(this.inputDim,"inputDim"),this.outputDim=e.outputDim,hu(this.outputDim,"outputDim"),this.embeddingsInitializer=Ko(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Xo(e.embeddingsRegularizer),this.activityRegularizer=Xo(e.activityRegularizer),this.embeddingsConstraint=Ja(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return(0,g.tidy)(()=>this.maskZero?(e=Fr(e),(0,g.notEqual)(e,(0,g.zerosLike)(e))):null)}computeOutputShape(e){if(e=xs(e),null==this.inputLength)return[...e,this.outputDim];const r=Gs(this.inputLength);if(r.length!==e.length-1)throw new be(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let i=0;for(let s=0;s<r.length;++s){const o=r[s],a=e[s+1];if(null!=o&&null!=a&&o!==a)throw new be(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(r[i]=a),i++}}return[e[0],...r,this.outputDim]}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);let i=Fr(e);"int32"!==i.dtype&&(i=qc(i,"int32"));const s=h$(this.embeddings.read(),(0,g.reshape)(i,[i.size]));return(0,g.reshape)(s,xs(this.computeOutputShape(i.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:oa(this.embeddingsInitializer),embeddingsRegularizer:_o(this.embeddingsRegularizer),activityRegularizer:_o(this.activityRegularizer),embeddingsConstraint:qa(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Embedding",t})());class Hd extends xi{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new ci}computeElementwiseOpOutputShape(n,e){if(null==n||null==e)return null;if(n.length<e.length)return this.computeElementwiseOpOutputShape(e,n);if(0===e.length)return n;const r=n.slice(0,n.length-e.length);for(let i=0;i<e.length;++i){const s=n[n.length-e.length+i],o=e[i];if(null==s||null==o||s<0||o<0)r.push(null);else if(1===s)r.push(o);else if(1===o)r.push(s);else{if(s!==o)throw new be("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(e));r.push(s)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[xs(n)]),n.length<2)throw new be(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let e=[];for(const s of n)null!=s&&null!==s[0]&&e.push(s[0]);if(e=Qh(e),e.length>1)throw new be(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=null==n[0]?null:n[0].slice(1);for(let s=1;s<n.length;++s){const o=null==n[s]?null:n[s].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const i=n.map(s=>s.length);this.reshapeRequired=-1!==n.indexOf(null)||1!==Qh(i).length}call(n,e){return(0,g.tidy)(()=>{if(this.reshapeRequired){const r=[],i=n.map(s=>s.rank);if(-1===i.indexOf(null)){const s=Jh(i);for(let o of n){const a=o.rank;for(let u=0;u<s-a;++u)o=Rg(o,1);r.push(o)}return this.mergeFunction(r)}{let s=!1;for(const u of n){const c=u.rank;if(null==c){const d=u.shape,p=d[0],v=d.slice(1).concat([p]);let x=g.reshape(u,[p].concat(qh(d.slice(1))));x=g.transpose(x,[1,0]),x=g.reshape(x,v),r.push(x),s=!0}else if(c>1){const d=Ic(1,c).concat([0]);r.push(g.transpose(u,d)),s=!0}else r.push(u)}let o=this.mergeFunction(r);const a=o.rank;if(s)if(null==a){const u=o.shape,d=u[u.length-1],p=[d].concat(u.slice(0,u.length-1));o=g.reshape(g.transpose(g.reshape(o,[-1,d]),[1,0]),p)}else if(a>1){const u=[a-1].concat(Ic(0,a-1));o=g.transpose(o,u)}return o}}return this.mergeFunction(n)})}computeOutputShape(n){let e;e=null==n[0]?null:n[0].slice(1);for(let i=1;i<n.length;++i){const s=null==n[i]?null:n[i].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let r=[];for(const i of n)null!=i&&null!==i[0]&&r.push(i[0]);return r=Qh(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(n,e){return g.tidy(()=>{if(null==e)return null;if(!Array.isArray(e))throw new be("`mask` should be an Array");if(!Array.isArray(n))throw new be("`inputs` should be an Array");if(e.length!==n.length)throw new be(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${e.length})`);if(e.every(i=>null==i))return null;let r=(e=e.map(i=>null==i?i:g.expandDims(i,0)))[0];for(let i=1;i<e.length-1;++i)r=g.logicalAnd(r,e[i]);return r})}}let AI=(()=>{class t extends Hd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=g.add(r,e[i]);return r})}}return t.className="Add",t})();g.serialization.registerClass(AI);let MI=(()=>{class t extends Hd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=g.mul(r,e[i]);return r})}}return t.className="Multiply",t})();g.serialization.registerClass(MI);let PI=(()=>{class t extends Hd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0].clone();for(let i=1;i<e.length;++i)r=g.add(r,e[i]);return g.mul(1/e.length,r)})}}return t.className="Average",t})();g.serialization.registerClass(PI);let OI=(()=>{class t extends Hd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0];for(let i=1;i<e.length;++i)r=g.maximum(r,e[i]);return r})}}return t.className="Maximum",t})();g.serialization.registerClass(OI);let RI=(()=>{class t extends Hd{constructor(e){super(e)}mergeFunction(e){return(0,g.tidy)(()=>{let r=e[0];for(let i=1;i<e.length;++i)r=g.minimum(r,e[i]);return r})}}return t.className="Minimum",t})();g.serialization.registerClass(RI);let LI=(()=>{class t extends Hd{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new be("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const s of e)if(null!=s){r=!1;break}if(r)return;const i=[];for(let s=0;s<e.length;++s){const o=e[s].slice();o.splice(this.axis,1);let a=!1;for(const u of i)if(g.util.arraysEqual(u,o)){a=!0;break}a||i.push(o)}if(i.length>1)throw new be("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return(0,g.tidy)(()=>Jw(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new be("A `Concatenate` layer should be called on a list of inputs.");const r=e,i=r[0].slice(),s=this.axis<0?i.length+this.axis:this.axis;for(const o of r.slice(1)){if(null==i[s]||null==o[s]){i[s]=null;break}i[s]+=o[s]}return i}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new be("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new be("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new be(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return g.tidy(()=>{let i=!0;if(r.forEach(a=>{null==a||(i=!1)}),i)return null;const s=[];for(let a=0;a<e.length;++a)s.push(null==r[a]?g.cast(g.onesLike(e[a]),"bool"):r[a].rank<e[a].rank?g.expandDims(r[a],-1):r[a]);const o=g.concat(s,this.axis);return g.all(o,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Concatenate",t})();function Ug(t,n){for(;t<0;)t+=n;return t}g.serialization.registerClass(LI);let uat=(()=>{class t extends Hd{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){g.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],i=e[1];if(r.length>3||i.length>3)throw new ci("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(r,i);if(r[s[0]]!==i[s[1]])throw new be(`Dimension incompatibility: ${r[s[0]]} !== ${i[s[1]]}`)}mergeFunction(e){if(2!==e.length)throw new be(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let s,r=e[0],i=e[1];return s=Array.isArray(this.axes)?this.axes.map((o,a)=>Ug(o,e[a].shape.length)):[Ug(this.axes,r.shape.length),Ug(this.axes,i.shape.length)],this.normalize&&(r=L_(r,s[0]),i=L_(i,s[1])),function aat(t,n,e){if(t.shape.length>3||n.shape.length>3)throw new ci("batchDot is not implemented for tensors of 4D or higher rank yet");if(g.util.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),g.util.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===t.dtype||"complex64"===n.dtype)throw new ci("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,i=n.shape.length;null==e&&(e=[r-1,i-2]);const s=e;return g.tidy(()=>{let o,a;if(r>i){o=r-i;const u=[];for(let c=0;c<o;++c)u.push(1);n=g.reshape(n,n.shape.concat(u))}else if(i>r){o=i-r;const u=[];for(let c=0;c<o;++c)u.push(1);t=g.reshape(t,t.shape.concat(u))}else o=0;if(a=2===t.shape.length&&2===n.shape.length?s[0]===s[1]?g.sum(g.mul(t,n),s[0]):g.sum(g.mul(g.transpose(t,[1,0]),n),s[1]):g.matMul(t,n,s[0]!==t.shape.length-1,s[1]===n.shape.length-1),o>0){let u;u=r>i?r+i-3:r-1;const c=[];for(let d=u;d<u+o;++d)c.push(d);a=g.squeeze(a,c)}return 1===a.shape.length&&(a=g.expandDims(a,1)),a})}(r,i,s)}interpretAxes(e,r){let i;return i=Array.isArray(this.axes)?this.axes:[Ug(this.axes,e.length),Ug(this.axes,r.length)],i}computeOutputShape(e){g.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),i=e[1].slice();if(r.length>3||i.length>3)throw new ci("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(r,i);r.splice(s[0],1),i.splice(s[1],1),i.splice(0,1);const o=r.concat(i);return 1===o.length&&o.push(1),o}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dot",t})();function Wg(t,n,e,r,i,s=.001){let o;if(2===t.rank)o=g.batchNorm2d(t,n,e,r,i,s);else if(3===t.rank)o=g.batchNorm3d(t,n,e,r,i,s);else{if(4!==t.rank)throw new ci(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=g.batchNorm4d(t,n,e,r,i,s)}return o}g.serialization.registerClass(uat),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e);return kg(()=>(0,g.add)(T_(i.shape,0,this.stddev),i),()=>i,r.training||!1)})}}return t.className="GaussianNoise",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return(0,g.tidy)(()=>{this.invokeCallHook(e,r);const i=Fr(e);return this.rate>0&&this.rate<1?kg(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return(0,g.mul)(i,T_(i.shape,1,o))},()=>i,r.training||!1):i})}}return t.className="GaussianDropout",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Fr(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return(0,g.tidy)(()=>{if(this.rate<1&&this.rate>0){const i=this._getNoiseShape(e);return kg(()=>{const o=Fr(e),c=-1.7580993408473766;let d=(0,g.greaterEqual)((0,g.randomUniform)(i),this.rate);d=qc(d,"float32");const p=((1-this.rate)*(1+this.rate*c**2))**-.5,v=-p*c*this.rate,x=(0,g.add)((0,g.mul)(o,d),(0,g.mul)((0,g.add)(d,-1),c));return(0,g.add)((0,g.mul)(x,p),v)},()=>Fr(e),r.training||!1)}return e})}}return t.className="AlphaDropout",t})());let mat=(()=>{class t extends xi{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Ko(e.betaInitializer||"zeros"),this.gammaInitializer=Ko(e.gammaInitializer||"ones"),this.movingMeanInitializer=Ko(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Ko(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ja(e.betaConstraint),this.gammaConstraint=Ja(e.gammaConstraint),this.betaRegularizer=Xo(e.betaRegularizer),this.gammaRegularizer=Xo(e.gammaRegularizer)}build(e){e=xs(e);const r=this.axis>=0?this.axis:this.axis+e.length,i=e[r];if(null==i)throw new be(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Qa({ndim:e.length,axes:{[r]:i}})];const s=[i];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return(0,g.tidy)(()=>{const i=null!=r.training&&r.training,s=Fr(e),o=s.shape,a=o.length,u=Ic(0,a),c=this.axis>=0?this.axis:this.axis+a;u.splice(c,1);const d=zd(1,a);d[c]=o[c];const p=u.slice();p.sort();const v=!g.util.arraysEqual(p,Ic(0,a).slice(0,a-1));if(!i)return(()=>{if(v){const U=(0,g.reshape)(this.movingMean.read(),d),J=(0,g.reshape)(this.movingVariance.read(),d),ht=this.center?(0,g.reshape)(this.beta.read(),d):null,Tt=this.scale?(0,g.reshape)(this.gamma.read(),d):null;return Wg(s,U,J,ht,Tt,this.epsilon)}return Wg(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[b,w,T]=function pat(t,n,e,r,i=.001){return g.util.arraysEqual(r.slice().sort(),Ic(0,t.rank-1))?function dat(t,n,e,r,i=.001){return(0,g.tidy)(()=>{const s=g.moments(t,r),o=s.mean,a=s.variance;return[Wg(t,o,a,e,n,i),o,a]})}(t,n,e,r,i):function fat(t,n,e,r,i=.001){return(0,g.tidy)(()=>{const s=g.moments(t,r),o=s.mean,a=s.variance,u=[];for(const b of Ic(0,t.rank))-1!==r.indexOf(b)?u.push(1):u.push(t.shape[b]);const c=(0,g.reshape)(o,u),d=(0,g.reshape)(a,u),p=null==n?null:(0,g.reshape)(n,u),v=null==e?null:(0,g.reshape)(e,u);return[Wg(t,c,d,v,p,i),o,a]})}(t,n,e,r,i)}(s,this.gamma.read(),this.beta.read(),u,this.epsilon),N=(U,J,ht)=>{g.tidy(()=>{const Tt=1-ht,Pt=U.read(),zt=g.mul(g.sub(Pt,J),Tt);U.write(g.sub(Pt,zt))})};return(()=>{N(this.movingMean,w,this.momentum),N(this.movingVariance,T,this.momentum)})(),b})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:oa(this.betaInitializer),gammaInitializer:oa(this.gammaInitializer),movingMeanInitializer:oa(this.movingMeanInitializer),movingVarianceInitializer:oa(this.movingVarianceInitializer),betaRegularizer:_o(this.betaRegularizer),gammaRegularizer:_o(this.gammaRegularizer),betaConstraint:qa(this.betaConstraint),gammaConstraint:qa(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BatchNormalization",t})();g.serialization.registerClass(mat);let gat=(()=>{class t extends xi{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Ko(e.betaInitializer||"zeros"),this.gammaInitializer=Ko(e.gammaInitializer||"ones"),this.betaRegularizer=Xo(e.betaRegularizer),this.gammaRegularizer=Xo(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=xs(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=r);for(const o of this.axis)if(o<0||o>=r)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==Qh(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const i=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",i,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",i,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const i=Fr(e),s=i.shape,o=s.length;return(0,g.tidy)(()=>{let{mean:u,variance:c}=(0,g.moments)(i,this.axis,!0);const d=zd(1,o);for(const T of this.axis)d[T]=s[T];const p=T=>null!=T&&T.shape.length!==o?g.reshape(T,d):T;let v=this.scale?p(this.gamma.read()):null,x=this.center?p(this.beta.read()):null;const b=[],w=[];for(let T=0;T<o;++T)-1!==this.axis.indexOf(T)?(b.push(s[T]),w.push(1)):(b.push(1),w.push(s[T]));return u=g.tile(u,b),c=g.tile(c,b),null!=v&&(v=g.tile(v,w)),null!=x&&(x=g.tile(x,w)),Wg(i,u,c,x,v,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:oa(this.betaInitializer),gammaInitializer:oa(this.gammaInitializer),betaRegularizer:_o(this.betaRegularizer),gammaRegularizer:_o(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LayerNormalization",t})();g.serialization.registerClass(gat);let vat=(()=>{class t extends xi{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new be(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,i;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],i=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new be(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new be(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);i=e.padding[1]}this.padding=[r,i]}this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(e){let r,i;return e=xs(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,i=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,i]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,i=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,i,e[3]])}call(e,r){return(0,g.tidy)(()=>function yat(t,n,e){return(0,g.tidy)(()=>{if(4!==t.rank)throw new be(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new be("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new be(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],g.pad(t,r)})}(Fr(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ZeroPadding2D",t})();function H_(t,n,e,r,i,s){return(0,g.tidy)(()=>{let o;Na(i),i$(s),zl(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),t=DI(t,i);const a="same"===r?"same":"valid";return o="max"===s?g.maxPool(t,n,e,a):g.avgPool(t,n,e,a),"channelsFirst"===i&&(o=g.transpose(o,[0,3,1,2])),o})}function hB(t,n,e,r,i,s){return(0,g.tidy)(()=>{let o;Na(i),i$(s),zl(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),t=J$(t,i);const a="same"===r?"same":"valid";return o="max"===s?g.maxPool3d(t,n,e,a):g.avgPool3d(t,n,e,a),"channelsFirst"===i&&(o=g.transpose(o,[0,4,1,2,3])),o})}g.serialization.registerClass(vat);class dB extends xi{constructor(n){if(null==n.poolSize&&(n.poolSize=2),super(n),"number"==typeof n.poolSize)this.poolSize=[n.poolSize];else{if(!Array.isArray(n.poolSize)||1!==n.poolSize.length||"number"!=typeof n.poolSize[0])throw new be(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);this.poolSize=n.poolSize}if(hu(this.poolSize,"poolSize"),null==n.strides)this.strides=this.poolSize;else if("number"==typeof n.strides)this.strides=[n.strides];else{if(!Array.isArray(n.strides)||1!==n.strides.length||"number"!=typeof n.strides[0])throw new be(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);this.strides=n.strides}hu(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,zl(this.padding),this.inputSpec=[new Qa({ndim:3})]}computeOutputShape(n){const e=Ac((n=xs(n))[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],e,n[2]]}call(n,e){return(0,g.tidy)(()=>{this.invokeCallHook(n,e),n=Rg(Fr(n),2);const r=this.poolingFunction(Fr(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return g.squeeze(r,[2])})}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(n,e),n}}g.serialization.registerClass((()=>{class t extends dB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Na(o),zl(s),H_(e,r,i,s,o,"max")}}return t.className="MaxPooling1D",t})()),g.serialization.registerClass((()=>{class t extends dB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Na(o),zl(s),H_(e,r,i,s,o,"avg")}}return t.className="AveragePooling1D",t})());class fB extends xi{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(2!==n.strides.length)throw new be(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];hu(this.poolSize,"poolSize"),hu(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Na(this.dataFormat),zl(this.padding),this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(n){n=xs(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2];return e=Ac(e,this.poolSize[0],this.padding,this.strides[0]),r=Ac(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r]:[n[0],e,r,n[3]]}call(n,e){return(0,g.tidy)(()=>(this.invokeCallHook(n,e),this.poolingFunction(Fr(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}g.serialization.registerClass((()=>{class t extends fB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Na(o),zl(s),H_(e,r,i,s,o,"max")}}return t.className="MaxPooling2D",t})()),g.serialization.registerClass((()=>{class t extends fB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Na(o),zl(s),H_(e,r,i,s,o,"avg")}}return t.className="AveragePooling2D",t})());class pB extends xi{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(3!==n.strides.length)throw new be(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];hu(this.poolSize,"poolSize"),hu(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Na(this.dataFormat),zl(this.padding),this.inputSpec=[new Qa({ndim:5})]}computeOutputShape(n){n=xs(n);let e="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2],i="channelsFirst"===this.dataFormat?n[4]:n[3];return e=Ac(e,this.poolSize[0],this.padding,this.strides[0]),r=Ac(r,this.poolSize[1],this.padding,this.strides[1]),i=Ac(i,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[n[0],n[1],e,r,i]:[n[0],e,r,i,n[4]]}call(n,e){return(0,g.tidy)(()=>(this.invokeCallHook(n,e),this.poolingFunction(Fr(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}g.serialization.registerClass((()=>{class t extends pB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Na(o),zl(s),hB(e,r,i,s,o,"max")}}return t.className="MaxPooling3D",t})()),g.serialization.registerClass((()=>{class t extends pB{constructor(e){super(e)}poolingFunction(e,r,i,s,o){return Na(o),zl(s),hB(e,r,i,s,o,"avg")}}return t.className="AveragePooling3D",t})());class mB extends xi{constructor(n){super(n),this.inputSpec=[new Qa({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,e){throw new ci}}let Iat=(()=>{class t extends mB{constructor(e){super(e||{})}call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);return g.mean(i,1)})}}return t.className="GlobalAveragePooling1D",t})();g.serialization.registerClass(Iat);let Sat=(()=>{class t extends mB{constructor(e){super(e||{})}call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);return g.max(i,1)})}}return t.className="GlobalMaxPooling1D",t})();g.serialization.registerClass(Sat);class gB extends xi{constructor(n){super(n),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Na(this.dataFormat),this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(n){return"channelsLast"===this.dataFormat?[n[0],n[3]]:[n[0],n[1]]}call(n,e){throw new ci}getConfig(){const n={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}}let Dat=(()=>{class t extends gB{call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);return g.mean(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalAveragePooling2D",t})();g.serialization.registerClass(Dat);let Tat=(()=>{class t extends gB{call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);return g.max(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return t.className="GlobalMaxPooling2D",t})();g.serialization.registerClass(Tat);class yB extends xi{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(n){null!=this.layer&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){const n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(n,e),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,e,r={}){const s=Sh(e.layer,r);delete e.layer;const o={layer:s};return Object.assign(o,e),new n(o)}}g.serialization.registerClass((()=>{class t extends yB{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=xs(e)).length<3)throw new be(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=xs(e))[0]].concat(e.slice(2)),i=this.layer.computeOutputShape(r);return[i[0],e[1]].concat(i.slice(1))}call(e,r){return(0,g.tidy)(()=>sB((a,u)=>[Fr(this.layer.call(a,r)),[]],e=Fr(e),[],!1,null,null,!1,!0)[1])}}return t.className="TimeDistributed",t})());let Pat=(()=>{class t extends yB{constructor(e){super(e);const r=e.layer.getConfig(),i={};i.className=e.layer.getClassName(),i.config=r,this.forwardLayer=Sh(i),r.goBackwards=!0!==r.goBackwards;const s={};if(s.className=e.layer.getClassName(),s.config=r,this.backwardLayer=Sh(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Aat(t){Ud(Pit,"BidirectionalMergeMode",t)}(this.mergeMode),e.weights)throw new ci("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const i=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,i)),this.backwardLayer.setWeights(e.slice(i))}computeOutputShape(e){let i,s,o,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(o=r.slice(1)),i=r[0],"concat"===this.mergeMode?(i[i.length-1]*=2,s=[i]):s=null==this.mergeMode?[i,i.slice()]:[i],this.returnState?null==this.mergeMode?s.concat(o).concat(o.slice()):[i].concat(o).concat(o.slice()):hl(s)}apply(e,r){let i=null==r?null:r.initialState,s=null==r?null:r.constants;null==r&&(r={});const o=iB(e,i,s,this.numConstants);if(e=o.inputs,i=o.initialState,s=o.constants,Array.isArray(e)&&(i=e.slice(1),e=e[0]),(null==i||0===i.length)&&null==s)return super.apply(e,r);const a=[],u=[];if(null!=i){const d=i.length;if(d%2>0)throw new be("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=i,a.push(...i);const p=i.map(v=>new Qa({shape:v.shape}));this.forwardLayer.stateSpec=p.slice(0,d/2),this.backwardLayer.stateSpec=p.slice(d/2),u.push(...p)}if(null!=s)throw new ci("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof eh;for(const d of a)if(d instanceof eh!==c)throw new be("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const d=[e].concat(a),p=this.inputSpec.concat(u),v=this.inputSpec;this.inputSpec=p;const x=super.apply(d,r);return this.inputSpec=v,x}return super.apply(e,r)}call(e,r){return(0,g.tidy)(()=>{const i=r.initialState;let s,o,a,u;if(null==i)s=this.forwardLayer.call(e,r),o=this.backwardLayer.call(e,r);else{const c=i.slice(0,i.length/2),d=i.slice(i.length/2);s=this.forwardLayer.call(e,Object.assign(r,{initialState:c})),o=this.backwardLayer.call(e,Object.assign(r,{initialState:d}))}return this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(o.slice(1))),s=s[0],o=o[0]),this.returnSequences&&(o=g.reverse(o,1)),"concat"===this.mergeMode?u=Jw([s,o]):"sum"===this.mergeMode?u=g.add(s,o):"ave"===this.mergeMode?u=g.mul(.5,g.add(s,o)):"mul"===this.mergeMode?u=g.mul(s,o):null==this.mergeMode&&(u=[s,o]),this.returnState?null==this.mergeMode?u.concat(a):[u].concat(a):u})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Wd(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Wd(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let i;if(Array.isArray(r)&&(r=r[0]),i=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(i)?i.concat(o).concat(o):[i].concat(o).concat(o)}return i}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const i=Sh(r.layer);if(delete r.layer,null!=r.numConstants)throw new ci("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=r;return s.layer=i,new e(s)}}return t.className="Bidirectional",t})();g.serialization.registerClass(Pat),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return(0,g.tidy)(()=>("float32"!==(e=Fr(e)).dtype&&(e=qc(e,"float32")),(0,g.add)((0,g.mul)(e,this.scale),this.offset)))}}return t.className="Rescaling",t})());const{resizeBilinear:Rat,cropAndResize:Lat}=g.image;g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,i,s,o,a,u,c){return(0,g.tidy)(()=>{let d,p=!1;const T=[r/a,i/u,(s+r)/a,(o+i)/u],N=[];3===e.rank?(p=!0,d=(0,g.stack)([e])):d=e;for(let Tt=0;Tt<d.shape[0];Tt++)N.push(T);const S=(0,g.tensor)(N,[N.length,4]),U=(0,g.range)(0,N.length,1,"int32"),ht=Lat(d,S,U,[s,o],"nearest");return qc(p?Fr((0,g.unstack)(ht)):ht,c)})}upsize(e,r,i,s){return(0,g.tidy)(()=>qc(Rat(e,[r,i]),s))}call(e,r){return(0,g.tidy)(()=>{const i=Fr(e),s=i.dtype,o=i.shape,a=o[o.length-3],u=o[o.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let d=0;return u!==this.width&&(d=Math.floor((u-this.width)/2),0===d&&(d=1)),c>=0&&d>=0?this.centerCrop(i,c,d,this.height,this.width,a,u,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const i=(e=xs(e)).length-2;return e[e.length-3]=this.height,e[i]=this.width,e}}return t.className="CenterCrop",t})()),g.serialization.registerClass((()=>{class t extends xi{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=xs(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return(0,g.tidy)(()=>{let i;if("int32"!==(e=Fr(e)).dtype&&(e=qc(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new be(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);i=Fr(r.countWeights)}const s=(0,g.max)(e),o=(0,g.min)(e),a=(0,g.greater)(this.numTokens,s).bufferSync().get(0),u=(0,g.greaterEqual)(o,0).bufferSync().get(0);if(!a||!u)throw new be(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function Fat(t,n,e,r){let i=Fr(t);if("int32"!==i.dtype&&(i=qc(i,"int32")),"int"===n)return i;const s=i.shape;if(0===i.rank&&(i=(0,g.expandDims)(i,-1)),"oneHot"===n&&1!==i.shape[i.shape.length-1]&&(i=(0,g.expandDims)(i,-1)),i.rank>2)throw new be(`When outputMode is not int, maximum output rank is 2 Received outputMode ${n} and input shape ${s} which would result in output rank ${i.rank}.`);const o=["multiHot","oneHot"].includes(n);let u;if(u=(0,g.denseBincount)(i,typeof r<"u"&&"count"===n?r:[],e,o),"tfIdf"!==n)return u;if(r)return(0,g.mul)(u,r);throw new be("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,i)})}}return t.className="CategoryEncoding",t})());const vB=new Set(["bilinear","nearest"]);let zat=(()=>{class t extends xi{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!vB.has(e.interpolation))throw new be(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){return e=xs(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return(0,g.tidy)(()=>{const i=[this.height,this.width];if("bilinear"===this.interpolation)return g.image.resizeBilinear(e,i,!this.cropToAspectRatio);if("nearest"===this.interpolation)return g.image.resizeNearestNeighbor(e,i,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...vB]} are supported`)})}}return t.className="Resizing",t})();g.serialization.registerClass(zat);let Vat=(()=>{class t{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return t.className="RandomSeed",t})(),Uat=(()=>{class t extends xi{constructor(e){super(e),this.randomGenerator=new Vat(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BaseRandomLayer",t})();const _B=new Set(["bilinear","nearest"]);let Gat=(()=>{class t extends Uat{constructor(e){super(e);const{factor:r,interpolation:i="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new be(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new be(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new be(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(i){if(!_B.has(i))throw new be(`Invalid interpolation parameter: ${i} is not implemented`);this.interpolation=i}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=xs(e),[this.imgHeight,-1,e[2]]}call(e,r){return(0,g.tidy)(()=>{const i=Fr(e);this.imgHeight=i.shape[i.shape.length-3];const s=i.shape[i.shape.length-2];this.widthFactor=(0,g.randomUniform)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*s;o=Math.round(o);const a=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return g.image.resizeBilinear(e,a);case"nearest":return g.image.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[..._B]} are supported`)}})}}return t.className="RandomWidth",t})();g.serialization.registerClass(Gat),y(7926);var Zat=y(9128);function ar(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&g.util.assert("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const but=g.kernel_impls.whereImpl;let wut=(()=>{class t extends g.KernelBackend{nextDataId(){return t.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new g.DataStorage(this,(0,g.engine)())}write(e,r,i){this.firstUse&&(this.firstUse=!1,(0,g.env)().get("IS_NODE")&&g.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:i,refCount:1}),s}makeTensorInfo(e,r,i){let s;if("string"===r&&null!=i&&i.length>0&&g.util.isString(i[0])){const o=i.map(a=>g.util.encodeString(a));s=this.write(o,e,r)}else s=this.write(i,e,r);return{dataId:s,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,i,s,o){this.data.set(e,{values:r,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return(0,Mr.Z)(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:i}=this.data.get(e);if("complex64"===r){const s=this.readSync(i.real.dataId),o=this.readSync(i.imag.dataId);return g.backend_util.mergeRealAndImagArrays(s,o)}return g.util.convertBackendValuesAndArrayBuffer(this.data.get(e).values,r)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const i=r.map(s=>g.util.decodeString(s));return(0,g.buffer)(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,g.buffer)(e.shape,e.dtype,r)}makeOutput(e,r,i){return(0,g.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(r,i,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:i}=this.data.get(e);null!=i&&(this.disposeData(i.real.dataId,!0),this.disposeData(i.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return(0,Mr.Z)(function*(){const r=g.util.now();return e(),{kernelMs:g.util.now()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ar([e],"where");const r=this.readSync(e.dataId);return but(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();function rh(t){return(n,e,r)=>{const i=g.util.getArrayFromDType(e,n.length);for(let s=0;s<n.length;++s)i[s]=t(n[s],r);return i}}function Js(t,n,e){return sd(t,rh(n),e)}function sd(t,n,e){return({inputs:r,attrs:i,backend:s})=>{const{x:o}=r;ar(o,t);const a=s,u=a.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=g.backend_util.fromUint8ToStringArray(u)}else c=u;const d=e||o.dtype,p=n(c,d,i);return a.makeTensorInfo(o.shape,d,p)}}(0,g.registerBackend)("cpu",()=>new wut,1);const RB=Js(g.Elu,t=>t>=0?t:Math.exp(t)-1),Sut={kernelName:g.Elu,backendName:"cpu",kernelFunc:RB};function ih(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Dut={kernelName:g.Identity,backendName:"cpu",kernelFunc:ih};function LB(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{alpha:s}=r;ar([i],"leakyRelu");const o=g.util.sizeFromShape(i.shape),a=e.data.get(i.dataId).values,u=g.util.getTypedArrayFromDType("float32",o);for(let c=0;c<a.length;c++)u[c]=a[c]<0?s*a[c]:a[c];return e.makeTensorInfo(i.shape,"float32",u)}const Tut={kernelName:g.LeakyRelu,backendName:"cpu",kernelFunc:LB};function Aa(t){return(n,e,r,i,s)=>{const o=g.backend_util.assertAndGetBroadcastShape(n,e),a=o.length,u=g.util.computeStrides(o),c=g.util.sizeFromShape(o),d=g.util.getTypedArrayFromDType(s,c),p=n.length,v=e.length,x=g.util.computeStrides(n),b=g.util.computeStrides(e),w=g.backend_util.getBroadcastDims(n,o),T=g.backend_util.getBroadcastDims(e,o);if(w.length+T.length===0)for(let N=0;N<d.length;++N)d[N]=t(r[N%r.length],i[N%i.length]);else for(let N=0;N<d.length;++N){const S=g.util.indexToLoc(N,a,u),U=S.slice(-p);w.forEach(Pt=>U[Pt]=0);const J=g.util.locToIndex(U,p,x),ht=S.slice(-v);T.forEach(Pt=>ht[Pt]=0);const Tt=g.util.locToIndex(ht,v,b);d[N]=t(r[J],i[Tt])}return[d,o]}}const Nut=Aa((t,n)=>t<0?n*t:t);function kB(t){const{inputs:n,backend:e}=t,{x:r,alpha:i}=n;ar([r,i],"prelu");const s=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,[a,u]=Nut(r.shape,i.shape,s,o,"float32");return e.makeTensorInfo(u,"float32",a)}const Aut={kernelName:g.Prelu,backendName:"cpu",kernelFunc:kB},FB=Js(g.Relu,t=>Math.max(0,t)),Mut={kernelName:g.Relu,backendName:"cpu",kernelFunc:FB},$B=Js(g.Relu6,t=>Math.min(Math.max(0,t),6)),Put={kernelName:g.Relu6,backendName:"cpu",kernelFunc:$B},Out=rh(t=>1/(1+Math.exp(-t))),BB=Js(g.Sigmoid,t=>1/(1+Math.exp(-t))),Rut={kernelName:g.Sigmoid,backendName:"cpu",kernelFunc:BB};function Y_(t,n,e,r,i){if("linear"===e)return ih({inputs:{x:n},backend:t});if("relu"===e)return FB({inputs:{x:n},backend:t});if("elu"===e)return RB({inputs:{x:n},backend:t});if("relu6"===e)return $B({inputs:{x:n},backend:t});if("prelu"===e)return kB({inputs:{x:n,alpha:r},backend:t});if("leakyrelu"===e)return LB({inputs:{x:n},backend:t,attrs:{alpha:i}});if("sigmoid"===e)return BB({inputs:{x:n},backend:t});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Cl(t){const{inputs:n,backend:e}=t,{real:r,imag:i}=n,s=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",s),imag:e.makeTensorInfo(i.shape,"float32",o)},a}const Lut={kernelName:g.Complex,backendName:"cpu",kernelFunc:Cl};function Q_(t,n,e="float32"){if("complex64"===e)return Cl({inputs:{real:Q_(t,n,"float32"),imag:Q_(t,n,"float32")},backend:t});const r=g.util.makeZerosTypedArray(g.util.sizeFromShape(n),e);return t.makeTensorInfo(n,e,r)}function jd(t){const{inputs:n,backend:e}=t,{input:r}=n,i=e.data.get(r.dataId).complexTensorInfos.real,s=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,s)}const kut={kernelName:g.Real,backendName:"cpu",kernelFunc:jd};function zB(t,n,e,r){if("int32"===r)return[n,"int32",Int32Array.from(t)];if("bool"===r){const i=g.util.toTypedArray([0],e),[s,o]=Aa((a,u)=>a!==u?1:0)(n,[],t,i,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function od(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===i.dtype)return ih({inputs:{x:i},backend:e});const d=Q_(e,i.shape,i.dtype),p=od({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),v=Cl({inputs:{real:p,imag:d},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),v}if("complex64"===i.dtype){const d=jd({inputs:{input:i},backend:e}),p=od({inputs:{x:d},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(d),p}if(!g.util.hasEncodingLoss(i.dtype,s)){const d=ih({inputs:{x:i},backend:e});return{dataId:d.dataId,shape:d.shape,dtype:s}}const o=e.data.get(i.dataId).values,[a,u,c]=zB(o,i.shape,i.dtype,s);return e.makeTensorInfo(a,u,c)}const Fut={kernelName:g.Cast,backendName:"cpu",kernelFunc:od};function tu(t,n,e,r){return null==e?({inputs:i,backend:s})=>{const{a:o,b:a}=i,u=s;ar([o,a],t);const c=u.data.get(o.dataId).values,d=u.data.get(a.dataId).values,p="string"===o.dtype?g.backend_util.fromUint8ToStringArray(c):c,v="string"===o.dtype?g.backend_util.fromUint8ToStringArray(d):d,x=r||o.dtype,[b,w]=n(o.shape,a.shape,p,v,x);return u.makeTensorInfo(w,x,b)}:({inputs:i,backend:s})=>{const{a:o,b:a}=i,u=s;if("complex64"===o.dtype||"complex64"===a.dtype){const c=od({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),d=u.data.get(c.dataId),v=d.complexTensorInfos.imag,x=u.data.get(d.complexTensorInfos.real.dataId).values,b=u.data.get(v.dataId).values,w=od({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),T=u.data.get(w.dataId),S=T.complexTensorInfos.imag,U=u.data.get(T.complexTensorInfos.real.dataId).values,J=u.data.get(S.dataId).values,[ht,Tt,Pt]=e(o.shape,a.shape,x,b,U,J),zt=u.makeTensorInfo(Pt,"float32",ht),Ot=u.makeTensorInfo(Pt,"float32",Tt),le=Cl({inputs:{real:zt,imag:Ot},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(w),u.disposeIntermediateTensorInfo(zt),u.disposeIntermediateTensorInfo(Ot),le}{const c=u.data.get(o.dataId).values,d=u.data.get(a.dataId).values,p=r||o.dtype,[v,x]=n(o.shape,a.shape,c,d,p);return u.makeTensorInfo(x,p,v)}}}function UI(t){return(n,e,r,i,s,o)=>{const a=g.backend_util.assertAndGetBroadcastShape(n,e),u=g.util.sizeFromShape(a),c=a.length,d=g.util.computeStrides(a),p=g.util.getTypedArrayFromDType("float32",u),v=g.util.getTypedArrayFromDType("float32",u),x=g.backend_util.getBroadcastDims(n,a),b=g.backend_util.getBroadcastDims(e,a),w=g.backend_util.mergeRealAndImagArrays(r,i),T=g.backend_util.mergeRealAndImagArrays(s,o),N=n.length,S=g.util.computeStrides(n),U=e.length,J=g.util.computeStrides(e);if(x.length+b.length===0)for(let ht=0;ht<p.length;ht++){const Tt=ht%w.length,Pt=ht%T.length,zt=t(w[2*Tt],w[2*Tt+1],T[2*Pt],T[2*Pt+1]);p[ht]=zt.real,v[ht]=zt.imag}else for(let ht=0;ht<p.length;ht++){const Tt=g.util.indexToLoc(ht,c,d),Pt=Tt.slice(-N);x.forEach(Ae=>Pt[Ae]=0);const zt=g.util.locToIndex(Pt,N,S),Ot=Tt.slice(-U);b.forEach(Ae=>Ot[Ae]=0);const le=g.util.locToIndex(Ot,U,J),ge=t(w[2*zt],w[2*zt+1],T[2*le],T[2*le+1]);p[ht]=ge.real,v[ht]=ge.imag}return[p,v,a]}}const VB=Aa((t,n)=>t+n),$ut=UI((t,n,e,r)=>({real:t+e,imag:n+r})),Mp=tu(g.Add,VB,$ut),But={kernelName:g.Add,backendName:"cpu",kernelFunc:Mp};function No(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{shape:s}=r,o=g.util.sizeFromShape(i.shape),a=g.util.inferFromImplicitShape(s,o),u=g.util.sizeFromShape(a);g.util.assert(o===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(i.dataId);const c=e.data.get(i.dataId);if(null!=c.complexTensorInfos){const p=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,p.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const zut={kernelName:g.Reshape,backendName:"cpu",kernelFunc:No};function UB(t){const{inputs:n,backend:e,attrs:r}=t,{a:i,b:s}=n,{transposeA:o,transposeB:a}=r;ar([i,s],"matMul");const u=i.shape.length,c=s.shape.length,d=o?i.shape[u-2]:i.shape[u-1],p=a?s.shape[c-1]:s.shape[c-2],v=o?i.shape[u-1]:i.shape[u-2],x=a?s.shape[c-2]:s.shape[c-1],b=i.shape.slice(0,-2),w=s.shape.slice(0,-2),T=g.util.sizeFromShape(b),N=g.util.sizeFromShape(w),U=g.broadcast_util.assertAndGetBroadcastShape(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([v,x]);g.util.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${o} and transposeB=${a} must match.`);const ht=a?[N,x,p]:[N,p,x],Tt=No({inputs:{x:i},backend:e,attrs:{shape:o?[T,d,v]:[T,v,d]}}),Pt=No({inputs:{x:s},backend:e,attrs:{shape:ht}}),zt=o?Tt.shape[1]:Tt.shape[2],Ot=o?Tt.shape[2]:Tt.shape[1],le=a?Pt.shape[1]:Pt.shape[2],ge=Math.max(T,N),Ae=e.data.get(Tt.dataId).values,Re=e.data.get(Pt.dataId).values,ve=g.util.computeStrides(Tt.shape),Ne=g.util.computeStrides(Pt.shape),[Se,Ke,Le]=o?[ve[0],1,ve[1]]:[ve[0],ve[1],1],[Be,on,rn]=a?[1,Ne[1],Ne[0]]:[Ne[1],1,Ne[0]],pn=Ot*le,qe=(0,g.buffer)([ge,Ot,le],Tt.dtype),gn=qe.values,dn=e.blockSize;for(let kn=0;kn<ge;kn++){const rr=kn%T,Cr=kn%N;for(let yr=0;yr<Ot;yr+=dn){const jr=Math.min(yr+dn,Ot);for(let qr=0;qr<le;qr+=dn){const Os=Math.min(qr+dn,le);for(let uo=0;uo<zt;uo+=dn){const Zo=Math.min(uo+dn,zt);for(let lo=yr;lo<jr;lo++)for(let co=qr;co<Os;co++){let aa=0;for(let Yo=uo;Yo<Zo;Yo++)aa+=Ae[rr*Se+lo*Ke+Yo*Le]*Re[Yo*Be+co*on+Cr*rn];gn[kn*pn+(lo*le+co)]+=aa}}}}}return e.disposeIntermediateTensorInfo(Tt),e.disposeIntermediateTensorInfo(Pt),e.makeTensorInfo(U,qe.dtype,qe.values)}const Vut={kernelName:g.BatchMatMul,backendName:"cpu",kernelFunc:UB},Wut={kernelName:g._FusedMatMul,backendName:"cpu",kernelFunc:function Uut(t){const{inputs:n,backend:e,attrs:r}=t,{a:i,b:s,bias:o,preluActivationWeights:a}=n,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=r;let v,x,b;const w=[];v=UB({inputs:{a:i,b:s},attrs:{transposeA:u,transposeB:c},backend:e}),o&&(x=Mp({inputs:{a:v,b:o},backend:e}),w.push(v),v=x),d&&(b=Y_(e,v,d,a,p),w.push(v),v=b);for(const N of w)e.disposeIntermediateTensorInfo(N);return v}};function WB(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}const Hut={kernelName:g.Abs,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend;ar(n,"abs");let r=new Float32Array(g.util.sizeFromShape(n.shape));return r=WB(e.data.get(n.dataId).values),e.makeOutput(r,n.shape,n.dtype)}},jut=Js(g.Acos,t=>Math.acos(t)),Kut={kernelName:g.Acos,backendName:"cpu",kernelFunc:jut},Xut=Js(g.Acosh,t=>Math.acosh(t)),Zut={kernelName:g.Acosh,backendName:"cpu",kernelFunc:Xut},Qut={kernelName:g.AddN,backendName:"cpu",kernelFunc:function Yut(t){const{inputs:n,backend:e}=t,r=n;ar(n,"addN");const i=r.map(a=>e.data.get(a.dataId).values),s=(0,g.buffer)(r[0].shape,r[0].dtype),o=s.values;for(let a=0;a<r.length;a++){const u=i[a];for(let c=0;c<o.length;c++)o[c]+=u[c]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}};function WI(t,n,e,r,i){const s=n.length,o=g.util.sizeFromShape(n),a=g.util.computeStrides(n),u=g.util.computeStrides(i),c=g.util.getTypedArrayFromDType(e,g.util.sizeFromShape(i));for(let d=0;d<o;++d){const p=g.util.indexToLoc(d,s,a),v=new Array(p.length);for(let b=0;b<v.length;b++)v[b]=p[r[b]];c[g.util.locToIndex(v,s,u)]=t[d]}return c}function fl(t){const{inputs:n,attrs:e,backend:r}=t,{x:i}=n,{perm:s}=e;ar(i,"transpose");const a=new Array(i.shape.length);for(let p=0;p<a.length;p++)a[p]=i.shape[s[p]];const c=WI(r.data.get(i.dataId).values,i.shape,i.dtype,s,a);return{dataId:r.write(c,a,i.dtype),shape:a,dtype:i.dtype}}const qut={kernelName:g.Transpose,backendName:"cpu",kernelFunc:fl},tlt={kernelName:g.All,backendName:"cpu",kernelFunc:function Jut(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;ar(i,"all");const a=g.util.parseAxisParam(s,i.shape);let u=a;const c=g.backend_util.getAxesPermutation(u,i.shape.length);let d=i;null!=c&&(d=fl({inputs:{x:i},backend:e,attrs:{perm:c}}),u=g.backend_util.getInnerMostAxes(u.length,i.shape.length)),g.backend_util.assertAxesAreInnerMostDims("all",u,d.shape.length);const[p,v]=g.backend_util.computeOutAndReduceShapes(d.shape,u),x=g.util.sizeFromShape(v),b=g.util.makeZerosTypedArray(g.util.sizeFromShape(p),d.dtype),w=e.data.get(d.dataId).values;for(let N=0;N<b.length;++N){const S=N*x;let U=w[S];for(let J=0;J<x;++J)U=U&&w[S+J];b[N]=U}null!=c&&e.disposeIntermediateTensorInfo(d);const T=e.makeTensorInfo(p,d.dtype,b);if(o){const S=No({inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(p,a)}});return e.disposeIntermediateTensorInfo(T),S}return T}},nlt={kernelName:g.Any,backendName:"cpu",kernelFunc:function elt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;ar(i,"any");const a=g.util.parseAxisParam(s,i.shape);let u=a;const c=g.backend_util.getAxesPermutation(u,i.shape.length);let d=i;null!=c&&(d=fl({inputs:{x:i},backend:e,attrs:{perm:c}}),u=g.backend_util.getInnerMostAxes(u.length,i.shape.length)),g.backend_util.assertAxesAreInnerMostDims("any",u,d.shape.length);const[p,v]=g.backend_util.computeOutAndReduceShapes(d.shape,u),x=g.util.sizeFromShape(v),b=g.util.makeZerosTypedArray(g.util.sizeFromShape(p),d.dtype),w=e.data.get(d.dataId).values;for(let N=0;N<b.length;++N){const S=N*x;let U=w[S];for(let J=0;J<x;++J)U=U||w[S+J];b[N]=U}null!=c&&e.disposeIntermediateTensorInfo(d);const T=e.makeTensorInfo(p,d.dtype,b);if(o){const S=No({inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(p,a)}});return e.disposeIntermediateTensorInfo(T),S}return T}},ilt={kernelName:g.ArgMax,backendName:"cpu",kernelFunc:function rlt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s}=r;ar(i,"argMax");let o=g.util.parseAxisParam(s,i.shape);const a=g.backend_util.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=a&&(u=fl({inputs:{x:i},backend:e,attrs:{perm:a}}),c.push(u),o=g.backend_util.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],g.backend_util.assertAxesAreInnerMostDims("argMax",o,u.shape.length);const[d,p]=g.backend_util.computeOutAndReduceShapes(u.shape,o),v=g.util.sizeFromShape(d),x=g.util.makeZerosTypedArray(v,"int32"),b=g.util.sizeFromShape(p),w=e.data.get(u.dataId).values;for(let T=0;T<x.length;++T){const N=T*b;let S=w[N],U=0;for(let J=0;J<b;++J){const ht=w[N+J];ht>S&&(S=ht,U=J)}x[T]=U}return c.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(d,"int32",x)}},olt={kernelName:g.ArgMin,backendName:"cpu",kernelFunc:function slt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s}=r;ar(i,"argMin");let o=g.util.parseAxisParam(s,i.shape);const a=g.backend_util.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=a&&(u=fl({inputs:{x:i},backend:e,attrs:{perm:a}}),c.push(u),o=g.backend_util.getInnerMostAxes(o.length,u.shape.length)),o=[o[0]],g.backend_util.assertAxesAreInnerMostDims("argMin",o,u.shape.length);const[d,p]=g.backend_util.computeOutAndReduceShapes(u.shape,o),v=g.util.sizeFromShape(d),x=g.util.makeZerosTypedArray(v,"int32"),b=g.util.sizeFromShape(p),w=e.data.get(u.dataId).values;for(let T=0;T<x.length;++T){const N=T*b;let S=w[N],U=0;for(let J=0;J<b;++J){const ht=w[N+J];ht<S&&(S=ht,U=J)}x[T]=U}return c.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(d,"int32",x)}},alt=Js(g.Asin,t=>Math.asin(t)),ult={kernelName:g.Asin,backendName:"cpu",kernelFunc:alt},llt=Js(g.Asinh,t=>Math.asinh(t)),clt={kernelName:g.Asinh,backendName:"cpu",kernelFunc:llt},hlt=Js(g.Atan,t=>Math.atan(t)),dlt={kernelName:g.Atan,backendName:"cpu",kernelFunc:hlt},flt=Aa((t,n)=>Math.atan2(t,n)),plt=tu(g.Atan2,flt),mlt={kernelName:g.Atan2,backendName:"cpu",kernelFunc:plt},glt=Js(g.Atanh,t=>Math.atanh(t)),ylt={kernelName:g.Atanh,backendName:"cpu",kernelFunc:glt};function GI(t,n,e,r,i,s){const o=i.strideHeight,a=i.strideWidth,u=i.dilationHeight,c=i.dilationWidth,d=i.effectiveFilterHeight,p=i.effectiveFilterWidth,v=i.padInfo.top,x=i.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=(0,g.buffer)(i.outShape,e),T=w.values,N=i.outShape[1]*i.outShape[2]*i.outShape[3],S=i.outShape[2]*i.outShape[3],U=i.outShape[3];for(let J=0;J<i.batchSize;++J){const ht=J*N,Tt=J*r[0];for(let Pt=0;Pt<i.inChannels;++Pt)for(let zt=0;zt<i.outHeight;++zt){const Ot=zt*o-v,le=Math.max(0,Ot),ge=Math.min(i.inHeight,d+Ot),Ae=ht+zt*S;for(let Re=0;Re<i.outWidth;++Re){const ve=Re*a-x,Ne=Math.max(0,ve),Se=Math.min(i.inWidth,p+ve);let Ke=b,Le=0,Be=0;for(let rn=le;rn<ge;rn+=u){const pn=Tt+rn*r[1];for(let qe=Ne;qe<Se;qe+=c){const dn=t[pn+qe*r[2]+Pt];"max"===s&&dn>Ke?Ke=dn:"avg"===s&&(Le+=dn,Be++)}if(isNaN(Ke))break}T[Ae+Re*U+Pt]="avg"===s?Le/Be:Ke}}}return w}function GB(t,n,e,r,i=!1,s=!1){const o=(0,g.buffer)(r.outShape,"int32"),a=r.strideHeight,u=r.strideWidth,c=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterHeight,v=r.effectiveFilterWidth,x=r.padInfo.top,b=r.padInfo.left,w=(0,g.buffer)(n,e,t);for(let T=0;T<r.batchSize;++T)for(let N=0;N<r.inChannels;++N)for(let S=0;S<r.outHeight;++S){const U=S*a-x;let J=U;for(;J<0;)J+=c;const ht=Math.min(r.inHeight,p+U);for(let Tt=0;Tt<r.outWidth;++Tt){const Pt=Tt*u-b;let zt=Pt;for(;zt<0;)zt+=d;const Ot=Math.min(r.inWidth,v+Pt);let le=Number.NEGATIVE_INFINITY,ge=-1;for(let Ae=J;Ae<ht;Ae+=c){const Re=Ae-U;for(let ve=zt;ve<Ot;ve+=d){const Ne=ve-Pt,Se=w.get(T,Ae,ve,N);Se>le&&(le=Se,ge=i?s?((T*r.inHeight+Ae)*r.inWidth+ve)*r.inChannels+N:(Ae*r.inWidth+ve)*r.inChannels+N:Re*v+Ne)}}o.set(ge,T,S,Tt,N)}}return o}function HB(t,n,e,r,i,s){const o=i.strideDepth,a=i.strideHeight,u=i.strideWidth,c=i.dilationDepth,d=i.dilationHeight,p=i.dilationWidth,v=i.effectiveFilterDepth,x=i.effectiveFilterHeight,b=i.effectiveFilterWidth,w=i.padInfo.front,T=i.padInfo.top,N=i.padInfo.left,S="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,U=(0,g.buffer)(i.outShape,e),J=U.values,ht=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],Tt=i.outShape[2]*i.outShape[3]*i.outShape[4],Pt=i.outShape[3]*i.outShape[4],zt=i.outShape[4];for(let Ot=0;Ot<i.batchSize;++Ot){const le=Ot*ht,ge=Ot*r[0];for(let Ae=0;Ae<i.inChannels;++Ae)for(let Re=0;Re<i.outDepth;++Re){const ve=Re*o-w;let Ne=ve;for(;Ne<0;)Ne+=c;const Se=Math.min(i.inDepth,v+ve),Ke=le+Re*Tt;for(let Le=0;Le<i.outHeight;++Le){const Be=Le*a-T;let on=Be;for(;on<0;)on+=d;const rn=Math.min(i.inHeight,x+Be),pn=Ke+Le*Pt;for(let qe=0;qe<i.outWidth;++qe){const gn=qe*u-N;let dn=gn;for(;dn<0;)dn+=p;const kn=Math.min(i.inWidth,b+gn),rr=pn+qe*zt;let Cr=S,yr=0,jr=0;for(let Os=Ne;Os<Se;Os+=c){const uo=ge+Os*r[1];for(let Zo=on;Zo<rn;Zo+=d){const lo=uo+Zo*r[2];for(let co=dn;co<kn;co+=p){const Yo=t[lo+co*r[3]+Ae];if("max"===s&&Yo>Cr?Cr=Yo:"avg"===s&&(yr+=Yo,jr++),isNaN(Cr))break}if(isNaN(Cr))break}if(isNaN(Cr))break}J[rr+Ae]="avg"===s?yr/Math.max(jr,1):Cr}}}}return U}const xlt={kernelName:g.AvgPool,backendName:"cpu",kernelFunc:function _lt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;ar(i,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=g.backend_util.computePool2DInfo(i.shape,s,o,1,a,u);let p;if(1===d.filterWidth&&1===d.filterHeight&&g.util.arraysEqual(d.inShape,d.outShape))p=ih({inputs:{x:i},backend:e});else{const v=e.data.get(i.dataId).values,x=g.util.computeStrides(i.shape),b=GI(v,0,i.dtype,x,d,"avg");p=e.makeTensorInfo(d.outShape,i.dtype,b.values)}return p}},Clt={kernelName:g.AvgPool3D,backendName:"cpu",kernelFunc:function Elt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{filterSize:s,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r;ar(i,"avgPool3d");const d=g.backend_util.computePool3DInfo(i.shape,s,o,1,a,u,c),v=HB(e.data.get(i.dataId).values,0,i.dtype,g.util.computeStrides(i.shape),d,"avg");return e.makeTensorInfo(v.shape,"float32",v.values)}},wlt={kernelName:g.AvgPool3DGrad,backendName:"cpu",kernelFunc:function blt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,{filterSize:o,strides:a,pad:u,dimRoundingMode:c}=r;ar([i,s],"avgPool3DGrad");const d=g.backend_util.computePool3DInfo(s.shape,o,a,1,u,c),p=d.strideDepth,v=d.strideHeight,x=d.strideWidth,b=d.filterDepth,w=d.filterHeight,T=d.filterWidth,N=d.dilationDepth,S=d.dilationHeight,U=d.dilationWidth,J=d.effectiveFilterDepth,ht=d.effectiveFilterHeight,Tt=d.effectiveFilterWidth,Pt=J-1-d.padInfo.front,zt=Tt-1-d.padInfo.left,Ot=ht-1-d.padInfo.top,le=(0,g.buffer)(s.shape,"float32"),ge=1/(b*w*T),Ae=e.bufferSync(i);for(let Re=0;Re<d.batchSize;++Re)for(let ve=0;ve<d.inChannels;++ve)for(let Ne=0;Ne<d.inDepth;++Ne)for(let Se=0;Se<d.inHeight;++Se)for(let Ke=0;Ke<d.inWidth;++Ke){const Le=Ne-Pt,Be=Se-Ot,on=Ke-zt;let rn=0;for(let pn=0;pn<J;pn+=N){const qe=(Le+pn)/p;if(!(qe<0||qe>=d.outDepth||Math.floor(qe)!==qe))for(let gn=0;gn<ht;gn+=S){const dn=(Be+gn)/v;if(!(dn<0||dn>=d.outHeight||Math.floor(dn)!==dn))for(let kn=0;kn<Tt;kn+=U){const rr=(on+kn)/x;rr<0||rr>=d.outWidth||Math.floor(rr)!==rr||(rn+=Ae.get(Re,qe,dn,rr,ve))}}}le.set(rn*ge,Re,Ne,Se,Ke,ve)}return e.makeTensorInfo(le.shape,le.dtype,le.values)}},Slt={kernelName:g.AvgPoolGrad,backendName:"cpu",kernelFunc:function Ilt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,o=s;ar([i,s],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,d=g.backend_util.computePool2DInfo(o.shape,a,u,1,c),p=d.strideHeight,v=d.strideWidth,x=d.filterHeight,b=d.filterWidth,w=d.dilationHeight,T=d.dilationWidth,N=d.effectiveFilterHeight,S=d.effectiveFilterWidth,U=S-1-d.padInfo.left,J=N-1-d.padInfo.top,ht=(0,g.buffer)(o.shape,"float32"),Tt=1/(x*b),Pt=e.data.get(i.dataId).values,zt=(0,g.buffer)(i.shape,"float32",Pt);for(let Ot=0;Ot<d.batchSize;++Ot)for(let le=0;le<d.inChannels;++le)for(let ge=0;ge<d.inHeight;++ge)for(let Ae=0;Ae<d.inWidth;++Ae){const Re=ge-J,ve=Ae-U;let Ne=0;for(let Se=0;Se<N;Se+=w){const Ke=(Re+Se)/p;if(!(Ke<0||Ke>=d.outHeight||Math.floor(Ke)!==Ke))for(let Le=0;Le<S;Le+=T){const Be=(ve+Le)/v;Be<0||Be>=d.outWidth||Math.floor(Be)!==Be||(Ne+=zt.get(Ot,Ke,Be,le))}}ht.set(Ne*Tt,Ot,ge,Ae,le)}return e.makeTensorInfo(ht.shape,ht.dtype,ht.values)}},Tlt={kernelName:g.FusedBatchNorm,backendName:"cpu",kernelFunc:function Dlt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,scale:s,offset:o,mean:a,variance:u}=n;g.util.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),g.util.assert(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),g.util.assert(null==s||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ar([i,a,u,s,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const d=e.data.get(i.dataId).values,p=e.data.get(a.dataId).values,v=e.data.get(u.dataId).values,x=s?e.data.get(s.dataId).values:new Float32Array([1]),b=o?e.data.get(o.dataId).values:new Float32Array([0]),w=new Float32Array(d.length),T=b.length,N=x.length,S=v.length,U=p.length;let J=0,ht=0,Tt=0,Pt=0;for(let zt=0;zt<d.length;++zt)w[zt]=b[J++]+(d[zt]-p[ht++])*x[Tt++]/Math.sqrt(v[Pt++]+c),J>=T&&(J=0),ht>=U&&(ht=0),Tt>=N&&(Tt=0),Pt>=S&&(Pt=0);return e.makeTensorInfo(i.shape,i.dtype,w)}};function jB(t,n,e,r,i){const s=g.slice_util.isSliceContinous(r,n,e),o=g.util.sizeFromShape(e),a=g.util.computeStrides(r);if(s){const p=g.slice_util.computeFlatOffset(n,a);return"string"===i?t.slice(p,p+o):t.subarray(p,p+o)}const u="string"===i?g.backend_util.fromUint8ToStringArray(t):t,c=(0,g.buffer)(r,i,u),d=(0,g.buffer)(e,i);for(let p=0;p<d.size;++p){const v=d.indexToLoc(p),x=v.map((b,w)=>b+n[w]);d.set(c.get(...x),...v)}return"string"===i?g.backend_util.fromStringArrayToUint8(d.values):d.values}function Kd(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{begin:s,size:o}=r;ar(i,"slice");const[a,u]=g.slice_util.parseSliceParams(i,s,o);g.slice_util.assertParamsValid(i,a,u);const d=jB(e.data.get(i.dataId).values,a,u,i.shape,i.dtype);return e.makeTensorInfo(u,i.dtype,d)}const Nlt={kernelName:g.Slice,backendName:"cpu",kernelFunc:Kd},Mlt={kernelName:g.BatchToSpaceND,backendName:"cpu",kernelFunc:function Alt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockShape:s,crops:o}=r;ar([i],"batchToSpaceND");const a=s.reduce((N,S)=>N*S),u=g.backend_util.getReshaped(i.shape,s,a),c=g.backend_util.getPermuted(u.length,s.length),d=g.backend_util.getReshapedPermuted(i.shape,s,a),p=g.backend_util.getSliceBeginCoords(o,s.length),v=g.backend_util.getSliceSize(d,o,s.length),x=No({inputs:{x:i},backend:e,attrs:{shape:u}}),b=fl({inputs:{x},backend:e,attrs:{perm:c}}),w=No({inputs:{x:b},backend:e,attrs:{shape:d}}),T=Kd({inputs:{x:w},backend:e,attrs:{begin:p,size:v}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w),T}};function HI(t,n,e,r,i){const s=g.util.sizeFromShape(r),o=g.util.makeZerosTypedArray(i,e);for(let a=0;a<t.length;a++){const u=t[a];if(u<0)throw new Error("Input x must be non-negative!");u>=i||(o[u]+=s>0?n[a]:1)}return o}function KB(t,n,e,r=!1){const i=t.shape[0],s=t.shape[1],o=(0,g.buffer)([i,e],n.dtype);for(let a=0;a<i;a++)for(let u=0;u<s;u++){const c=t.get(a,u);if(c<0)throw new Error("Input x must be non-negative!");c>=e||o.set(r?1:n.size>0?o.get(a,c)+n.get(a,u):o.get(a,c)+1,a,c)}return o}const Olt={kernelName:g.Bincount,backendName:"cpu",kernelFunc:function Plt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,weights:s}=n,{size:o}=r,c=HI(e.data.get(i.dataId).values,e.data.get(s.dataId).values,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,c)}},XB=Aa((t,n)=>t&n),Rlt=tu(g.BitwiseAnd,XB),Llt={kernelName:g.BitwiseAnd,backendName:"cpu",kernelFunc:Rlt},Flt={kernelName:g.BroadcastArgs,backendName:"cpu",kernelFunc:function klt(t){const{inputs:n,backend:e}=t,{s0:r,s1:i}=n,s=e.data.get(r.dataId).values,o=e.data.get(i.dataId).values,a=g.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},ZB=rh(t=>Math.ceil(t)),$lt=sd(g.Ceil,ZB),Blt={kernelName:g.Ceil,backendName:"cpu",kernelFunc:$lt},zlt=Js(g.ClipByValue,(t,n)=>t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t),Vlt={kernelName:g.ClipByValue,backendName:"cpu",kernelFunc:zlt},Wlt={kernelName:g.ComplexAbs,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend,r=new Float32Array(g.util.sizeFromShape(n.shape)),i=e.data.get(n.dataId),o=i.complexTensorInfos.imag,a=e.data.get(i.complexTensorInfos.real.dataId).values,u=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],u[c]);return e.makeOutput(r,n.shape,"float32")}};function YB(t,n,e,r){const i=g.util.getArrayFromDType(e,g.util.sizeFromShape(n));if(r&&"string"!==e){let s=0;t.forEach(o=>{const a=g.util.sizeFromShape(o.shape);i.set(o.vals,s),s+=a})}else{let s=0;t.forEach(o=>{const a="string"===e?g.backend_util.fromUint8ToStringArray(o.vals):o.vals;let u=0;for(let c=0;c<o.shape[0];++c){const d=c*n[1]+s;for(let p=0;p<o.shape[1];++p)i[d+p]=a[u++]}s+=o.shape[1]})}return i}function Pp(t){const{inputs:n,backend:e}=t,{input:r}=n,i=e.data.get(r.dataId).complexTensorInfos.imag,s=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,s)}const Glt={kernelName:g.Imag,backendName:"cpu",kernelFunc:Pp};function Op(t){const{inputs:n,backend:e,attrs:r}=t,{axis:i}=r,s=g.util.parseAxisParam(i,n[0].shape)[0],o=n.map(w=>w.shape);g.backend_util.assertParamsConsistent(o,s);let a=g.backend_util.computeOutShape(n.map(w=>w.shape),s);if(0===g.util.sizeFromShape(a))return e.makeTensorInfo(a,n[0].dtype,[]);const u=n.filter(w=>g.util.sizeFromShape(w.shape)>0);if(1===u.length)return ih({inputs:{x:u[0]},backend:e});if("complex64"===u[0].dtype){const w=u.map(J=>jd({inputs:{input:J},backend:e})),T=u.map(J=>Pp({inputs:{input:J},backend:e})),N=Op({inputs:w,backend:e,attrs:{axis:s}}),S=Op({inputs:T,backend:e,attrs:{axis:s}}),U=Cl({inputs:{real:N,imag:S},backend:e});return w.forEach(J=>e.disposeIntermediateTensorInfo(J)),T.forEach(J=>e.disposeIntermediateTensorInfo(J)),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(S),U}const c=u.map(w=>{const N=[-1,g.util.sizeFromShape(w.shape.slice(s))];return No({inputs:{x:w},backend:e,attrs:{shape:N}})}),d=c.map(w=>({vals:e.data.get(w.dataId).values,shape:w.shape}));a=g.backend_util.computeOutShape(c.map(w=>w.shape),1);const v=YB(d,a,n[0].dtype,1===c[0].shape[0]),x=g.backend_util.computeOutShape(u.map(w=>w.shape),s),b=e.makeTensorInfo(x,n[0].dtype,v);return c.forEach(w=>e.disposeIntermediateTensorInfo(w)),b}const Hlt={kernelName:g.Concat,backendName:"cpu",kernelFunc:Op};function QB(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dataFormat:u,dilations:c,dimRoundingMode:d}=r;ar([i,s],"conv2d");const p=g.backend_util.convertConv2DDataFormat(u),v=g.backend_util.computeConv2DInfo(i.shape,s.shape,o,c,a,d,!1,p),x=v.filterHeight,b=v.filterWidth,w=v.dilationHeight,T=v.dilationWidth,N=v.padInfo.left,S=v.padInfo.top,U="channelsLast"===v.dataFormat,J=new g.TensorBuffer(v.outShape,i.dtype),ht=g.util.computeStrides(i.shape),Tt=g.util.computeStrides(s.shape),Pt=ht[0],zt=U?ht[1]:ht[2],Ot=U?ht[2]:1,le=U?1:ht[1],ge=J.strides[0],Ae=U?J.strides[1]:J.strides[2],Re=U?J.strides[2]:1,ve=U?1:J.strides[1],Ne=e.data.get(i.dataId).values,Se=e.data.get(s.dataId).values,Ke=J.values;for(let Le=0;Le<v.batchSize;++Le){const Be=Le*Pt,on=Le*ge;for(let rn=0;rn<v.outHeight;++rn){const pn=on+rn*Ae,qe=rn*v.strideHeight-S;for(let gn=0;gn<x;++gn){const dn=qe+gn*w;if(dn<0||dn>=v.inHeight)continue;const kn=gn*Tt[0],rr=Be+dn*zt;for(let Cr=0;Cr<v.outWidth;++Cr){const yr=pn+Cr*Re,jr=Cr*v.strideWidth-N;for(let qr=0;qr<b;++qr){const Os=jr+qr*T;if(Os<0||Os>=v.inWidth)continue;const Zo=rr+Os*Ot;let lo=kn+qr*Tt[1];for(let co=0;co<v.inChannels;++co){const aa=Ne[Zo+co*le];for(let Yo=0;Yo<v.outChannels;++Yo)Ke[yr+Yo*ve]+=aa*Se[lo+Yo];lo+=v.outChannels}}}}}}return e.makeTensorInfo(J.shape,J.dtype,Ke)}const jlt={kernelName:g.Conv2D,backendName:"cpu",kernelFunc:QB},Xlt={kernelName:g.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function Klt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:d}=r;ar([i,s],"conv2dBackpropFilter");const p=g.backend_util.convertConv2DDataFormat(u),v=g.backend_util.computeConv2DInfo(i.shape,d,o,1,a,c,!1,p),{strideHeight:x,strideWidth:b,filterHeight:w,filterWidth:T}=v,N="channelsLast"===v.dataFormat,S=new g.TensorBuffer(v.filterShape,"float32"),U=v.padInfo.left,J=v.padInfo.top,ht=e.data.get(i.dataId).values,Tt=e.data.get(s.dataId).values,Pt=new g.TensorBuffer(i.shape,i.dtype,ht),zt=new g.TensorBuffer(s.shape,s.dtype,Tt);for(let Ot=0;Ot<w;++Ot){const le=Math.max(0,Math.ceil((J-Ot)/x)),ge=Math.min(v.outHeight,(v.inHeight+J-Ot)/x);for(let Ae=0;Ae<T;++Ae){const Re=Math.max(0,Math.ceil((U-Ae)/b)),ve=Math.min(v.outWidth,(v.inWidth+U-Ae)/b);for(let Ne=0;Ne<v.inChannels;++Ne)for(let Se=0;Se<v.outChannels;++Se){let Ke=0;for(let Le=0;Le<v.batchSize;++Le)for(let Be=le;Be<ge;++Be){const on=Ot+Be*x-J;for(let rn=Re;rn<ve;++rn){const pn=Ae+rn*b-U;Ke+=N?Pt.get(Le,on,pn,Ne)*zt.get(Le,Be,rn,Se):Pt.get(Le,Ne,on,pn)*zt.get(Le,Se,Be,rn)}}S.set(Ke,Ot,Ae,Ne,Se)}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}},Ylt={kernelName:g.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function Zlt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{inputShape:o,strides:a,pad:u,dataFormat:c,dimRoundingMode:d}=r;ar([i,s],"conv2dBackpropInput");const p=g.util.computeStrides(s.shape),v=g.util.computeStrides(i.shape);let x=g.backend_util.convertConv2DDataFormat(c);const b=g.backend_util.computeConv2DInfo(o,s.shape,a,1,u,d,!1,x),w=new g.TensorBuffer(b.inShape,"float32"),T=w.values,N=e.data.get(i.dataId).values,S=e.data.get(s.dataId).values,[U,J,ht]=p,{batchSize:Tt,filterHeight:Pt,filterWidth:zt,inChannels:Ot,inHeight:le,inWidth:ge,outChannels:Ae,outHeight:Re,outWidth:ve,strideHeight:Ne,strideWidth:Se}=b;x=b.dataFormat;const Ke=Pt-1-b.padInfo.top,Le=zt-1-b.padInfo.left,Be="channelsLast"===x,on=w.strides[0],rn=Be?w.strides[1]:w.strides[2],pn=Be?w.strides[2]:1,qe=Be?1:w.strides[1],gn=v[0],dn=Be?v[1]:v[2],kn=Be?v[2]:1,rr=Be?1:v[1];for(let Cr=0;Cr<Tt;++Cr)for(let yr=0;yr<Ot;++yr)for(let jr=0;jr<le;++jr){const qr=jr-Ke,Os=Math.max(0,Math.ceil(qr/Ne)),uo=Math.min(Re,(Pt+qr)/Ne);for(let Zo=0;Zo<ge;++Zo){const lo=Zo-Le,co=Math.max(0,Math.ceil(lo/Se)),aa=Math.min(ve,(zt+lo)/Se);let Yo=0;for(let Cu=Os;Cu<uo;++Cu){const hd=Cu*Ne-qr;for(let Wl=co;Wl<aa;++Wl){const Pc=gn*Cr+dn*Cu+kn*Wl,Nh=U*(Pt-1-hd)+J*(zt-1-(Wl*Se-lo))+ht*yr;for(let dd=0;dd<Ae;++dd)Yo+=N[Pc+rr*dd]*S[Nh+dd]}}T[on*Cr+rn*jr+pn*Zo+qe*yr]=Yo}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},qlt={kernelName:g.Conv3D,backendName:"cpu",kernelFunc:function Qlt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u}=r;ar([i,s],"conv3d");const c=g.backend_util.computeConv3DInfo(i.shape,s.shape,o,u,a),{filterDepth:d,filterHeight:p,filterWidth:v,dilationDepth:x,dilationHeight:b,dilationWidth:w,padInfo:T}=c,N=T.front,S=T.left,U=T.top,J=new g.TensorBuffer(c.outShape,i.dtype),ht=e.data.get(i.dataId).values,Tt=e.data.get(s.dataId).values,Pt=J.values,zt=g.util.computeStrides(i.shape),Ot=g.util.computeStrides(s.shape);for(let le=0;le<c.batchSize;++le){const ge=le*zt[0],Ae=le*J.strides[0];for(let Re=0;Re<c.outDepth;++Re){const ve=Ae+Re*J.strides[1],Ne=Re*c.strideDepth-N;for(let Se=0;Se<d;++Se){const Ke=Ne+Se*x;if(Ke<0||Ke>=c.inDepth)continue;const Le=Se*Ot[0],Be=ge+Ke*zt[1];for(let on=0;on<c.outHeight;++on){const rn=ve+on*J.strides[2],pn=on*c.strideHeight-U;for(let qe=0;qe<p;++qe){const gn=pn+qe*b;if(gn<0||gn>=c.inHeight)continue;const dn=Le+qe*Ot[1],kn=Be+gn*zt[2];for(let rr=0;rr<c.outWidth;++rr){const Cr=rn+rr*c.outChannels,yr=rr*c.strideWidth-S;for(let jr=0;jr<v;++jr){const qr=yr+jr*w;if(qr<0||qr>=c.inWidth)continue;const uo=kn+qr*c.inChannels;let Zo=dn+jr*Ot[2];for(let lo=0;lo<c.inChannels;++lo){const co=ht[uo+lo];for(let aa=0;aa<c.outChannels;++aa)Pt[Cr+aa]+=co*Tt[Zo+aa];Zo+=c.outChannels}}}}}}}}return e.makeTensorInfo(J.shape,J.dtype,J.values)}},tct={kernelName:g.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function Jlt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,pad:a,filterShape:u}=r;ar([i,s],"conv3dBackpropFilterV2");const c=g.util.computeStrides(i.shape),d=g.util.computeStrides(s.shape),p=g.backend_util.computeConv3DInfo(i.shape,u,o,1,a),v=p.strideDepth,x=p.strideHeight,b=p.strideWidth,w=p.filterDepth,T=p.filterHeight,N=p.filterWidth,S=new g.TensorBuffer(p.filterShape,"float32"),U=S.values,[J,ht,Tt,Pt]=S.strides,zt=e.data.get(s.dataId).values,[Ot,le,ge,Ae]=d,Re=e.data.get(i.dataId).values,[ve,Ne,Se,Ke]=c,Le=p.padInfo.front,Be=p.padInfo.left,on=p.padInfo.top;for(let rn=0;rn<w;++rn){const pn=Math.max(0,Math.ceil((Le-rn)/v)),qe=Math.min(p.outDepth,(p.inDepth+Le-rn)/v),gn=rn*J;for(let dn=0;dn<T;++dn){const kn=Math.max(0,Math.ceil((on-dn)/x)),rr=Math.min(p.outHeight,(p.inHeight+on-dn)/x),Cr=dn*ht+gn;for(let yr=0;yr<N;++yr){const jr=Math.max(0,Math.ceil((Be-yr)/b)),qr=Math.min(p.outWidth,(p.inWidth+Be-yr)/b),Os=yr*Tt+Cr;for(let uo=0;uo<p.inChannels;++uo){const Zo=uo*Pt+Os;for(let lo=0;lo<p.outChannels;++lo){let co=0;for(let aa=0;aa<p.batchSize;++aa){const Yo=aa*ve,Th=aa*Ot;for(let Cu=pn;Cu<qe;++Cu){const Wl=(rn+Cu*v-Le)*Ne+Yo,nf=Cu*le+Th;for(let Pc=kn;Pc<rr;++Pc){const dd=(dn+Pc*x-on)*Se+Wl,fd=Pc*ge+nf;for(let pd=jr;pd<qr;++pd)co+=Re[(yr+pd*b-Be)*Ke+dd+uo]*zt[pd*Ae+fd+lo]}}}U[Zo+lo]=co}}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}},nct={kernelName:g.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function ect(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{pad:o,strides:a,inputShape:u}=r;ar([i],"conv3dBackpropInputV2");const c=g.util.computeStrides(i.shape),d=g.util.computeStrides(s.shape),p=g.backend_util.computeConv3DInfo(u,s.shape,a,1,o),v=new g.TensorBuffer(p.inShape,"float32"),x=v.values,[b,w,T,N]=v.strides,S=e.data.get(i.dataId).values,[U,J,ht,Tt]=c,Pt=e.data.get(s.dataId).values,[zt,Ot,le,ge]=d,{batchSize:Ae,filterDepth:Re,filterHeight:ve,filterWidth:Ne,inChannels:Se,inDepth:Ke,inHeight:Le,inWidth:Be,outChannels:on,outDepth:rn,outHeight:pn,outWidth:qe,strideDepth:gn,strideHeight:dn,strideWidth:kn}=p,rr=Re-1-p.padInfo.front,Cr=ve-1-p.padInfo.top,yr=Ne-1-p.padInfo.left;for(let jr=0;jr<Ae;++jr)for(let qr=0;qr<Se;++qr)for(let Os=0;Os<Ke;++Os){const uo=Os-rr,Zo=Math.max(0,Math.ceil(uo/gn)),lo=Math.min(rn,(Re+uo)/gn);for(let co=0;co<Le;++co){const aa=co-Cr,Yo=Math.max(0,Math.ceil(aa/dn)),Th=Math.min(pn,(ve+aa)/dn);for(let Cu=0;Cu<Be;++Cu){const hd=Cu-yr,Wl=Math.max(0,Math.ceil(hd/kn)),nf=Math.min(qe,(Ne+hd)/kn);let Pc=0;for(let Nh=Zo;Nh<lo;++Nh){const dd=Nh*gn-uo;for(let fd=Yo;fd<Th;++fd){const pd=fd*dn-aa;for(let ny=Wl;ny<nf;++ny){const yS=U*jr+J*Nh+ht*fd+Tt*ny,dwt=zt*(Re-1-dd)+Ot*(ve-1-pd)+le*(Ne-1-(ny*kn-hd))+ge*qr;for(let w1=0;w1<on;++w1)Pc+=S[yS+w1]*Pt[dwt+w1]}}}x[b*jr+w*Os+T*co+N*Cu+qr]=Pc}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},rct=Js(g.Cos,t=>Math.cos(t)),ict={kernelName:g.Cos,backendName:"cpu",kernelFunc:rct},sct=Js(g.Cosh,t=>Math.cosh(t)),oct={kernelName:g.Cosh,backendName:"cpu",kernelFunc:sct},uct={kernelName:g.CropAndResize,backendName:"cpu",kernelFunc:function act(t){const{inputs:n,backend:e,attrs:r}=t,{image:i,boxes:s,boxInd:o}=n,{cropSize:a,method:u,extrapolationValue:c}=r,[d,p,v,x]=i.shape,b=s.shape[0],[w,T]=a,N=(0,g.buffer)([b,w,T,x],"float32"),S=e.data.get(s.dataId).values,U=e.data.get(o.dataId).values,J=e.data.get(i.dataId).values,ht=g.util.computeStrides(i.shape),Tt=g.util.computeStrides(N.shape);for(let Pt=0;Pt<b;Pt++){const zt=4*Pt,Ot=S[zt],le=S[zt+1],ge=S[zt+2],Ae=S[zt+3],Re=U[Pt];if(Re>=d)continue;const ve=w>1?(ge-Ot)*(p-1)/(w-1):0,Ne=T>1?(Ae-le)*(v-1)/(T-1):0;for(let Se=0;Se<w;Se++){const Ke=w>1?Ot*(p-1)+Se*ve:.5*(Ot+ge)*(p-1);if(Ke<0||Ke>p-1)for(let Le=0;Le<T;Le++)for(let Be=0;Be<x;Be++)N.values[Be+Le*Tt[2]+Se*Tt[1]+Pt*Tt[0]]=c;else if("bilinear"===u){const Le=Math.floor(Ke),Be=Math.ceil(Ke),on=Ke-Le;for(let rn=0;rn<T;rn++){const pn=T>1?le*(v-1)+rn*Ne:.5*(le+Ae)*(v-1);if(pn<0||pn>v-1){for(let kn=0;kn<x;kn++)N.values[kn+rn*Tt[2]+Se*Tt[1]+Pt*Tt[0]]=c;continue}const qe=Math.floor(pn),gn=Math.ceil(pn),dn=pn-qe;for(let kn=0;kn<x;kn++){let rr=kn+qe*ht[2]+Le*ht[1]+Re*ht[0];const Cr=J[rr];rr=kn+gn*ht[2]+Le*ht[1]+Re*ht[0];const yr=J[rr];rr=kn+qe*ht[2]+Be*ht[1]+Re*ht[0];const jr=J[rr];rr=kn+gn*ht[2]+Be*ht[1]+Re*ht[0];const qr=J[rr],Os=Cr+(yr-Cr)*dn;rr=kn+rn*Tt[2]+Se*Tt[1]+Pt*Tt[0],N.values[rr]=Os+(jr+(qr-jr)*dn-Os)*on}}}else for(let Le=0;Le<T;++Le){const Be=T>1?le*(v-1)+Le*Ne:.5*(le+Ae)*(v-1);if(Be<0||Be>v-1){for(let pn=0;pn<x;pn++)N.values[pn+Le*Tt[2]+Se*Tt[1]+Pt*Tt[0]]=c;continue}const on=Math.round(Be),rn=Math.round(Ke);for(let pn=0;pn<x;pn++)N.values[pn+Le*Tt[2]+Se*Tt[1]+Pt*Tt[0]]=J[pn+on*ht[2]+rn*ht[1]+Re*ht[0]]}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},cct={kernelName:g.Cumprod,backendName:"cpu",kernelFunc:function lct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,exclusive:o,reverse:a}=r;ar(i,"cumprod");const u=g.backend_util.getAxesPermutation([s],i.shape.length);let c=i;null!=u&&(c=fl({inputs:{x:i},backend:e,attrs:{perm:u}}));const d=g.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const p=(0,g.upcastType)(c.dtype,"int32"),v=g.util.makeOnesTypedArray(g.util.sizeFromShape(c.shape),p),x=e.data.get(c.dataId).values,b=c.shape[c.shape.length-1],w=a?(N,S)=>N+b-S-1:(N,S)=>N+S;for(let N=0;N<x.length;N+=b)for(let S=0;S<b;S++){const U=w(N,S);if(0===S)v[U]=o?1:x[U];else{const J=w(N,S-1);v[U]=o?x[J]*v[J]:x[U]*v[J]}}const T=e.makeTensorInfo(c.shape,p,v);if(null!=u){const S=fl({inputs:{x:T},backend:e,attrs:{perm:g.backend_util.getUndoAxesPermutation(u)}});return e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(c),S}return T}},dct={kernelName:g.Cumsum,backendName:"cpu",kernelFunc:function hct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,exclusive:o,reverse:a}=r;ar(i,"cumsum");const u=g.backend_util.getAxesPermutation([s],i.shape.length);let c=i;null!=u&&(c=fl({inputs:{x:i},backend:e,attrs:{perm:u}}));const d=g.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const p=(0,g.upcastType)(c.dtype,"int32"),v=g.util.makeZerosTypedArray(g.util.sizeFromShape(c.shape),p),x=e.data.get(c.dataId).values,b=c.shape[c.shape.length-1],w=a?(N,S)=>N+b-S-1:(N,S)=>N+S;for(let N=0;N<x.length;N+=b)for(let S=0;S<b;S++){const U=w(N,S);if(0===S)v[U]=o?0:x[U];else{const J=w(N,S-1);v[U]=o?x[J]+v[J]:x[U]+v[J]}}const T=e.makeTensorInfo(c.shape,p,v);if(null!=u){const S=fl({inputs:{x:T},backend:e,attrs:{perm:g.backend_util.getUndoAxesPermutation(u)}});return e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(c),S}return T}},pct={kernelName:g.DenseBincount,backendName:"cpu",kernelFunc:function fct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,weights:s}=n,{size:o,binaryOutput:a}=r;if(1===i.shape.length){const d=HI(e.data.get(i.dataId).values,e.data.get(s.dataId).values,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,d)}if(2===i.shape.length){const d=KB(e.bufferSync(i),e.bufferSync(s),o,a);return e.makeTensorInfo(d.shape,s.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}},gct={kernelName:g.DepthToSpace,backendName:"cpu",kernelFunc:function mct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockSize:s,dataFormat:o}=r;g.util.assert("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=i.shape[0],u=i.shape[1],c=i.shape[2],d=i.shape[3],p=u*s,v=c*s,x=d/(s*s),b=e.data.get(i.dataId).values,w=new Float32Array(a*p*v*x);let T=0;for(let N=0;N<a;++N)for(let S=0;S<p;++S){const U=Math.floor(S/s),J=S%s;for(let ht=0;ht<v;++ht){const Tt=Math.floor(ht/s),zt=(J*s+ht%s)*x;for(let Ot=0;Ot<x;++Ot)w[T++]=b[Ot+zt+d*(Tt+c*(U+u*N))]}}return e.makeTensorInfo([a,p,v,x],i.dtype,w)}};function qB(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u,dimRoundingMode:c}=r;ar([i,s],"depthwiseConv2DNative");const d=g.util.computeStrides(i.shape),p=g.util.computeStrides(s.shape);let v=u;null==v&&(v=[1,1]),g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,v),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${v}'`);const x=g.backend_util.computeConv2DInfo(i.shape,s.shape,o,v,a,c,!0),{filterHeight:b,filterWidth:w,dilationHeight:T,dilationWidth:N,padInfo:S}=x,U=S.left,J=S.top,ht=x.outChannels/x.inChannels,Tt=new g.TensorBuffer(x.outShape,i.dtype),Pt=e.data.get(i.dataId).values,zt=e.data.get(s.dataId).values,Ot=Tt.values;for(let le=0;le<x.batchSize;++le){const ge=le*d[0],Ae=le*Tt.strides[0];for(let Re=0;Re<x.outHeight;++Re){const ve=Ae+Re*Tt.strides[1],Ne=Re*x.strideHeight-J;for(let Se=0;Se<b;++Se){const Ke=Ne+Se*T;if(Ke<0||Ke>=x.inHeight)continue;const Le=Se*p[0],Be=ge+Ke*d[1];for(let on=0;on<x.outWidth;++on){const rn=ve+on*Tt.strides[2],pn=on*x.strideWidth-U;for(let qe=0;qe<w;++qe){const gn=pn+qe*N;if(gn<0||gn>=x.inWidth)continue;const kn=Be+gn*x.inChannels;let rr=rn,Cr=Le+qe*p[1];for(let yr=0;yr<x.inChannels;++yr){const jr=Pt[kn+yr];for(let qr=0;qr<ht;++qr)Ot[rr+qr]+=jr*zt[Cr+qr];rr+=ht,Cr+=ht}}}}}}return e.makeTensorInfo(Tt.shape,Tt.dtype,Tt.values)}const yct={kernelName:g.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:qB},_ct={kernelName:g.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function vct(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,dilations:a,pad:u,dimRoundingMode:c,filterShape:d}=r;ar([i,s],"depthwiseConv2dNativeBackpropFilter");const p=g.backend_util.computeConv2DInfo(i.shape,d,o,a,u,c,!0),{strideHeight:v,strideWidth:x,filterHeight:b,filterWidth:w}=p,T=new g.TensorBuffer(p.filterShape,"float32"),N=p.padInfo.left,S=p.padInfo.top,U=p.outChannels/p.inChannels,J=e.data.get(i.dataId).values,ht=new g.TensorBuffer(i.shape,i.dtype,J),Tt=e.data.get(s.dataId).values,Pt=new g.TensorBuffer(s.shape,s.dtype,Tt);for(let zt=0;zt<b;++zt){const Ot=Math.max(0,Math.ceil((S-zt)/v)),le=Math.min(p.outHeight,(p.inHeight+S-zt)/v);for(let ge=0;ge<w;++ge){const Ae=Math.max(0,Math.ceil((N-ge)/x)),Re=Math.min(p.outWidth,(p.inWidth+N-ge)/x);for(let ve=0;ve<p.outChannels;++ve){const Ne=Math.trunc(ve/U),Se=ve%U;let Ke=0;for(let Le=0;Le<p.batchSize;++Le)for(let Be=Ot;Be<le;++Be){const on=zt+Be*v-S;for(let rn=Ae;rn<Re;++rn)Ke+=ht.get(Le,on,ge+rn*x-N,Ne)*Pt.get(Le,Be,rn,ve)}T.set(Ke,zt,ge,Ne,Se)}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},Ect={kernelName:g.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function xct(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{strides:o,dilations:a,pad:u,dimRoundingMode:c,inputShape:d}=r;ar([i,s],"depthwiseConv2DNativeBackpropInput");const p=g.util.computeStrides(i.shape),v=g.util.computeStrides(s.shape),x=g.backend_util.computeConv2DInfo(d,s.shape,o,a,u,c,!0),b=new g.TensorBuffer(x.inShape,"float32"),w=b.values,[T,N,S]=b.strides,U=e.data.get(i.dataId).values,[J,ht,Tt]=p,Pt=e.data.get(s.dataId).values,[zt,Ot,le]=v,{batchSize:ge,filterHeight:Ae,filterWidth:Re,inChannels:ve,inHeight:Ne,inWidth:Se,outChannels:Ke,outHeight:Le,outWidth:Be,strideHeight:on,strideWidth:rn}=x,pn=Ae-1-x.padInfo.top,qe=Re-1-x.padInfo.left,gn=Ke/ve;for(let dn=0;dn<ge;++dn)for(let kn=0;kn<ve;++kn)for(let rr=0;rr<Ne;++rr){const Cr=rr-pn,yr=Math.max(0,Math.ceil(Cr/on)),jr=Math.min(Le,(Ae+Cr)/on);for(let qr=0;qr<Se;++qr){const Os=qr-qe,uo=Math.max(0,Math.ceil(Os/rn)),Zo=Math.min(Be,(Re+Os)/rn);let lo=0;for(let co=yr;co<jr;++co){const aa=co*on-Cr;for(let Yo=uo;Yo<Zo;++Yo){const Cu=J*dn+ht*co+Tt*Yo,hd=zt*(Ae-1-aa)+Ot*(Re-1-(Yo*rn-Os))+le*kn;for(let Wl=0;Wl<gn;++Wl)lo+=U[Cu+(kn*gn+Wl)]*Pt[hd+Wl]}}w[T*dn+N*rr+S*qr+kn]=lo}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},bct={kernelName:g.Diag,backendName:"cpu",kernelFunc:function Cct(t){const{inputs:n,backend:e}=t,{x:r}=n,i=g.util.sizeFromShape(r.shape),s=e.data.get(r.dataId).values,o=(0,g.buffer)([i,i],r.dtype),a=o.values;for(let c=0;c<s.length;c++)a[c*i+c]=s[c];const u=[...r.shape,...r.shape];return e.makeTensorInfo(u,o.dtype,o.values)}},wct={kernelName:g.Dilation2D,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:i}=t,{strides:s,pad:o,dilations:a}=e,u=n,c=u.data.get(r.dataId).values,d=r.shape.length,p=u.data.get(i.dataId).values,v=i.shape.length,{batchSize:x,inHeight:b,inWidth:w,inChannels:T,outHeight:N,outWidth:S,padInfo:U,strideHeight:J,strideWidth:ht,filterHeight:Tt,filterWidth:Pt,dilationHeight:zt,dilationWidth:Ot,outShape:le}=g.backend_util.computeDilation2DInfo(r.shape,i.shape,s,o,"NHWC",a),ge=g.util.sizeFromShape(le),Ae=le.length,Re=g.util.getArrayFromDType(r.dtype,ge);for(let Ne=0;Ne<x;++Ne)for(let Se=0;Se<N;++Se){const Ke=Se*J-U.top;for(let Le=0;Le<S;++Le){const Be=Le*ht-U.left;for(let on=0;on<T;++on){let rn=Number.MIN_SAFE_INTEGER;for(let qe=0;qe<Tt;++qe){const gn=Ke+qe*zt;if(gn>=0&&gn<b)for(let dn=0;dn<Pt;++dn){const kn=Be+dn*Ot;if(kn>=0&&kn<w){const rr=g.util.locToIndex([Ne,gn,kn,on],d,g.util.computeStrides(r.shape)),Cr=g.util.locToIndex([qe,dn,on],v,g.util.computeStrides(i.shape)),yr=c[rr]+p[Cr];yr>rn&&(rn=yr)}}}Re[g.util.locToIndex([Ne,Se,Le,on],Ae,g.util.computeStrides(le))]=rn}}}return{dataId:u.write(g.util.toTypedArray(Re,r.dtype),le,r.dtype),shape:le,dtype:r.dtype}}},Ict={kernelName:g.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:i,dy:s}=t,{strides:o,pad:a,dilations:u}=e,c=n,d=g.util.toNestedArray(r.shape,c.data.get(r.dataId).values),p=g.util.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:v,inHeight:x,inWidth:b,inChannels:w,outHeight:T,outWidth:N,padInfo:S,strideHeight:U,strideWidth:J,filterHeight:ht,filterWidth:Tt,dilationHeight:Pt,dilationWidth:zt,outShape:Ot}=g.backend_util.computeDilation2DInfo(r.shape,i.shape,o,a,"NHWC",u);g.util.assert(s.rank===Ot.length,()=>`Error in ${g.Dilation2DBackpropFilter}, dy must have the same rank as output ${Ot.length}, but got ${s.rank}`);const le=g.util.toNestedArray(Ot,c.data.get(s.dataId).values),ge=g.util.makeZerosNestedTypedArray(i.shape,i.dtype);for(let Re=0;Re<v;++Re)for(let ve=0;ve<T;++ve){const Ne=ve*U-S.top;for(let Se=0;Se<N;++Se){const Ke=Se*J-S.left;for(let Le=0;Le<w;++Le){let Be=Number.MIN_SAFE_INTEGER,on=0,rn=0;for(let pn=0;pn<ht;++pn){const qe=Ne+pn*Pt;if(qe>=0&&qe<x)for(let gn=0;gn<Tt;++gn){const dn=Ke+gn*zt;if(dn>=0&&dn<b){const kn=d[Re][qe][dn][Le]+p[pn][gn][Le];kn>Be&&(Be=kn,on=pn,rn=gn)}}}ge[on][rn][Le]+=le[Re][ve][Se][Le]}}}return{dataId:c.write(g.util.toTypedArray(ge,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},Sct={kernelName:g.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:i,dy:s}=t,{strides:o,pad:a,dilations:u}=e,c=n,d=g.util.toNestedArray(r.shape,c.data.get(r.dataId).values),p=g.util.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:v,inHeight:x,inWidth:b,inChannels:w,outHeight:T,outWidth:N,padInfo:S,strideHeight:U,strideWidth:J,filterHeight:ht,filterWidth:Tt,dilationHeight:Pt,dilationWidth:zt,outShape:Ot}=g.backend_util.computeDilation2DInfo(r.shape,i.shape,o,a,"NHWC",u);g.util.assert(s.rank===Ot.length,()=>`Error in ${g.Dilation2DBackpropInput}, dy must have the same rank as output ${Ot.length}, but got ${s.rank}`);const le=g.util.toNestedArray(Ot,c.data.get(s.dataId).values),ge=g.util.makeZerosNestedTypedArray(r.shape,r.dtype);for(let Re=0;Re<v;++Re)for(let ve=0;ve<T;++ve){const Ne=ve*U-S.top;for(let Se=0;Se<N;++Se){const Ke=Se*J-S.left;for(let Le=0;Le<w;++Le){let Be=Number.MIN_SAFE_INTEGER,on=Ne<0?0:Ne,rn=Ke<0?0:Ke;for(let pn=0;pn<ht;++pn){const qe=Ne+pn*Pt;if(qe>=0&&qe<x)for(let gn=0;gn<Tt;++gn){const dn=Ke+gn*zt;if(dn>=0&&dn<b){const kn=d[Re][qe][dn][Le]+p[pn][gn][Le];kn>Be&&(Be=kn,on=qe,rn=dn)}}}ge[Re][on][rn][Le]+=le[Re][ve][Se][Le]}}}return{dataId:c.write(g.util.toTypedArray(ge,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Tct={kernelName:g.Draw,backendName:"cpu",kernelFunc:function Dct(t){const{inputs:n,backend:e,attrs:r}=t,{image:i}=n,{canvas:s,options:o}=r,{contextOptions:a,imageOptions:u}=o||{},c=u?.alpha||1,d=a?.contextType||"2d";if("2d"!==d)throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const p=s.getContext(d,a?.contextAttributes||{});if(null==p)throw new Error(`Could not get the context with ${d} type.`);const[v,x]=i.shape.slice(0,2),b=2===i.shape.length?1:i.shape[2],w=e.data.get(i.dataId).values,T="float32"===i.dtype?255:1,N=new Uint8ClampedArray(x*v*4);for(let U=0;U<v*x;++U){const J=[0,0,0,255*c];for(let Tt=0;Tt<b;Tt++){const Pt=w[U*b+Tt];if("float32"===i.dtype){if(Pt<0||Pt>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Pt}.`)}else if("int32"===i.dtype&&(Pt<0||Pt>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Pt}.`);1===b?(J[0]=Pt*T,J[1]=Pt*T,J[2]=Pt*T):J[Tt]=Pt*T}const ht=4*U;N[ht+0]=Math.round(J[0]),N[ht+1]=Math.round(J[1]),N[ht+2]=Math.round(J[2]),N[ht+3]=Math.round(J[3])}s.width=x,s.height=v;const S=new ImageData(N,x,v);return p.putImageData(S,0,0),i}},jI=Aa((t,n)=>t*n),Nct=UI((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),q_=tu(g.Multiply,jI,Nct),Act={kernelName:g.Multiply,backendName:"cpu",kernelFunc:q_};function Hg(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;let a;ar(i,"sum"),a="bool"===i.dtype?od({inputs:{x:i},backend:e,attrs:{dtype:"int32"}}):ih({inputs:{x:i},backend:e});const u=a.shape.length,c=g.util.parseAxisParam(s,a.shape),d=g.backend_util.getAxesPermutation(c,u);let p=c,v=a;null!=d&&(v=fl({inputs:{x:a},backend:e,attrs:{perm:d}}),p=g.backend_util.getInnerMostAxes(p.length,u)),g.backend_util.assertAxesAreInnerMostDims("sum",p,v.shape.length);const[x,b]=g.backend_util.computeOutAndReduceShapes(v.shape,p);let T=Q_(e,x,g.backend_util.upcastType(v.dtype,"int32"));const N=g.util.sizeFromShape(b),S=e.data.get(T.dataId).values,U=e.data.get(v.dataId).values;for(let J=0;J<S.length;++J){const ht=J*N;let Tt=0;for(let Pt=0;Pt<N;++Pt)Tt+=U[ht+Pt];S[J]=Tt}if(o){const ht=T;T=No({inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(T.shape,c)}}),e.disposeIntermediateTensorInfo(ht)}return e.disposeIntermediateTensorInfo(a),null!=d&&e.disposeIntermediateTensorInfo(v),T}const Mct={kernelName:g.Sum,backendName:"cpu",kernelFunc:Hg},Oct={kernelName:g.Einsum,backendName:"cpu",kernelFunc:function Pct(t){const{inputs:n,backend:e,attrs:r}=t,{equation:i}=r,s=n,{allDims:o,summedDims:a,idDims:u}=g.backend_util.decodeEinsumEquation(i,s.length);g.backend_util.checkEinsumDimSizes(o.length,u,s);const{path:c,steps:d}=g.backend_util.getEinsumComputePath(a,u),p=d.length;let v=null,x=o.length;const b=[];for(let w=0;w<p;++w){for(const T of d[w]){const{permutationIndices:N,expandDims:S}=g.backend_util.getEinsumPermutation(x,u[T]);let U;g.backend_util.isIdentityPermutation(N)?U=s[T]:(U=fl({inputs:{x:s[T]},backend:e,attrs:{perm:N}}),b.push(U));const J=U.shape.slice();for(let ht=0;ht<S.length;++ht)J.splice(S[ht],0,1);g.util.arraysEqual(U.shape,J)||(U=No({inputs:{x:U},backend:e,attrs:{shape:J}}),b.push(U)),null===v?v=U:(v=q_({inputs:{a:U,b:v},backend:e}),b.push(v))}w<p-1&&(c[w]>=0&&(v=Hg({inputs:{x:v},backend:e,attrs:{axis:c[w]-(o.length-x),keepDims:!1}}),b.push(v)),x--)}for(const w of b)w!==v&&e.disposeIntermediateTensorInfo(w);return v}},Lct={kernelName:g.EluGrad,backendName:"cpu",kernelFunc:function Rct(t){const{inputs:n,backend:e}=t,{dy:r,y:i}=n;ar([r,i],"eluGrad");const s=new Float32Array(g.util.sizeFromShape(i.shape)),o=e.data.get(i.dataId).values,a=e.data.get(r.dataId).values;for(let u=0;u<o.length;++u){const c=o[u];s[u]=c>=0?a[u]:a[u]*(c+1)}return e.makeTensorInfo(i.shape,"float32",s)}},JB=Aa((t,n)=>t===n?1:0),t3=tu(g.Equal,JB,null,"bool"),kct={kernelName:g.Equal,backendName:"cpu",kernelFunc:t3},Fct=g.backend_util.ERF_P,$ct=g.backend_util.ERF_A1,Bct=g.backend_util.ERF_A2,zct=g.backend_util.ERF_A3,Vct=g.backend_util.ERF_A4,Uct=g.backend_util.ERF_A5,Wct=Js(g.Erf,t=>{const n=Math.sign(t),e=Math.abs(t),r=1/(1+Fct*e);return n*(1-((((Uct*r+Vct)*r+zct)*r+Bct)*r+$ct)*r*Math.exp(-e*e))}),Gct={kernelName:g.Erf,backendName:"cpu",kernelFunc:Wct},e3=rh(t=>Math.exp(t)),n3=sd(g.Exp,e3,"float32"),Hct={kernelName:g.Exp,backendName:"cpu",kernelFunc:n3};function J_(t){const{inputs:n,backend:e,attrs:r}=t,{input:i}=n,{dim:s}=r,o=i.shape.length,a=i.shape.slice();let u=s;return s<0&&(g.util.assert(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+s+1),a.splice(u,0,1),No({inputs:{x:i},backend:e,attrs:{shape:a}})}const jct={kernelName:g.ExpandDims,backendName:"cpu",kernelFunc:J_},r3=rh(t=>Math.expm1(t)),Kct=sd(g.Expm1,r3),Xct={kernelName:g.Expm1,backendName:"cpu",kernelFunc:Kct},Zct=Aa((t,n)=>t/n),KI=tu(g.RealDiv,Zct),XI={kernelName:g.RealDiv,backendName:"cpu",kernelFunc:KI},i3=Aa((t,n)=>t-n),Yct=UI((t,n,e,r)=>({real:t-e,imag:n-r})),ZI=tu(g.Sub,i3,Yct),Qct={kernelName:g.Sub,backendName:"cpu",kernelFunc:ZI};function s3(t,n,e){const r=t.shape,i=r[0],s=r[1],o=e.data.get(t.dataId),a=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[i,s],d=g.util.sizeFromShape(c),p=g.util.getTypedArrayFromDType("float32",d),v=g.util.getTypedArrayFromDType("float32",d);for(let T=0;T<i;T++){const N=Kd({inputs:{x:a},backend:e,attrs:{begin:[T,0],size:[1,s]}}),S=Kd({inputs:{x:u},backend:e,attrs:{begin:[T,0],size:[1,s]}}),U=Cl({inputs:{real:N,imag:S},backend:e}),{real:J,imag:ht}=qct(U,n,e),Tt=g.backend_util.mergeRealAndImagArrays(J,ht);for(let Pt=0;Pt<s;Pt++){const zt=g.backend_util.getComplexWithIndex(Tt,Pt);p[T*s+Pt]=zt.real,v[T*s+Pt]=zt.imag}e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(U)}const x=e.makeTensorInfo(c,"float32",p),b=e.makeTensorInfo(c,"float32",v),w=Cl({inputs:{real:x,imag:b},backend:e});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),w}function qct(t,n,e){const r=g.util.sizeFromShape(t.shape),i=e.data.get(t.dataId),s=e.data.get(i.complexTensorInfos.real.dataId).values,o=e.data.get(i.complexTensorInfos.imag.dataId).values;if(function Jct(t){return 0==(t&t-1)}(r)){const a=YI(s,o,r,n,e),u=[t.shape[0],t.shape[1]];if(n){const c=e.makeTensorInfo(u,"float32",a.real),d=e.makeTensorInfo(u,"float32",a.imag),p=e.makeTensorInfo([],"float32",g.util.createScalarValue(r,"float32")),v=ih({inputs:{x:p},backend:e}),x=XI.kernelFunc({inputs:{a:c,b:p},backend:e}),b=XI.kernelFunc({inputs:{a:d,b:v},backend:e}),w=e.data.get(x.dataId).values,T=e.data.get(b.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),{real:w,imag:T}}return a}{const u=function tht(t,n,e){const r=new Float32Array(2*n);for(let i=0;i<n;i++){let s=0,o=0;for(let a=0;a<n;a++){const u=g.backend_util.exponent(i*a,n,e),c=g.backend_util.getComplexWithIndex(t,a);s+=c.real*u.real-c.imag*u.imag,o+=c.real*u.imag+c.imag*u.real}e&&(s/=n,o/=n),g.backend_util.assignToTypedArray(r,s,o,i)}return r}(g.backend_util.mergeRealAndImagArrays(s,o),r,n);return g.backend_util.splitRealAndImagArrays(u)}}function YI(t,n,e,r,i){if(1===e)return{real:t,imag:n};const s=g.backend_util.mergeRealAndImagArrays(t,n),o=e/2,a=g.backend_util.complexWithEvenIndex(s),u=a.real,c=a.imag,d=[u.length],p=i.makeTensorInfo(d,"float32",u),v=i.makeTensorInfo(d,"float32",c),x=Cl({inputs:{real:p,imag:v},backend:i}),b=g.backend_util.complexWithOddIndex(s),w=b.real,T=b.imag,N=[w.length],S=i.makeTensorInfo(N,"float32",w),U=i.makeTensorInfo(N,"float32",T),J=Cl({inputs:{real:S,imag:U},backend:i}),ht=YI(u,c,o,r,i),Tt=ht.real,Pt=ht.imag,zt=[Tt.length],Ot=i.makeTensorInfo(zt,"float32",Tt),le=i.makeTensorInfo(zt,"float32",Pt),ge=Cl({inputs:{real:Ot,imag:le},backend:i}),Ae=YI(w,T,o,r,i),Re=Ae.real,ve=Ae.imag,Ne=[Re.length],Se=i.makeTensorInfo(Ne,"float32",Re),Ke=i.makeTensorInfo(Ne,"float32",ve),Le=Cl({inputs:{real:Se,imag:Ke},backend:i}),Be=g.backend_util.exponents(e,r),on=[Be.real.length],rn=i.makeTensorInfo(on,"float32",Be.real),pn=i.makeTensorInfo(on,"float32",Be.imag),qe=Cl({inputs:{real:rn,imag:pn},backend:i}),gn=q_({inputs:{a:qe,b:Le},backend:i}),dn=Mp({inputs:{a:ge,b:gn},backend:i}),kn=ZI({inputs:{a:ge,b:gn},backend:i}),rr=jd({inputs:{input:dn},backend:i}),Cr=jd({inputs:{input:kn},backend:i}),yr=Pp({inputs:{input:dn},backend:i}),jr=Pp({inputs:{input:kn},backend:i}),qr=Op({inputs:[rr,Cr],backend:i,attrs:{axis:0}}),Os=Op({inputs:[yr,jr],backend:i,attrs:{axis:0}}),uo=i.data.get(qr.dataId).values,Zo=i.data.get(Os.dataId).values;return i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(J),i.disposeIntermediateTensorInfo(Ot),i.disposeIntermediateTensorInfo(le),i.disposeIntermediateTensorInfo(ge),i.disposeIntermediateTensorInfo(Se),i.disposeIntermediateTensorInfo(Ke),i.disposeIntermediateTensorInfo(Le),i.disposeIntermediateTensorInfo(rn),i.disposeIntermediateTensorInfo(pn),i.disposeIntermediateTensorInfo(qe),i.disposeIntermediateTensorInfo(gn),i.disposeIntermediateTensorInfo(dn),i.disposeIntermediateTensorInfo(kn),i.disposeIntermediateTensorInfo(rr),i.disposeIntermediateTensorInfo(yr),i.disposeIntermediateTensorInfo(Cr),i.disposeIntermediateTensorInfo(jr),i.disposeIntermediateTensorInfo(qr),i.disposeIntermediateTensorInfo(Os),{real:uo,imag:Zo}}const nht={kernelName:g.FFT,backendName:"cpu",kernelFunc:function eht(t){const{inputs:n,backend:e}=t,{input:r}=n,i=g.util.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=No({inputs:{x:r},backend:e,attrs:{shape:[i/s,s]}}),u=s3(a,!1,e),c=No({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),c}};function QI(t){const{backend:n,attrs:e}=t,{shape:r,value:i,dtype:s}=e,o=s||g.util.inferDtype(i),a=g.util.getArrayFromDType(o,g.util.sizeFromShape(r));return function iht(t,n,e){t.fill(n)}(a,i),n.makeTensorInfo(r,o,a)}const rht={kernelName:g.Fill,backendName:"cpu",kernelFunc:QI},sht={kernelName:g.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:r}=t,i=e,s=g.util.getTypedArrayFromDType(r.dtype,g.util.sizeFromShape(r.shape)),[o,a,u,c]=r.shape,d=i.data.get(r.dataId).values;for(let v=0;v<o;v++){const x=v*u*a*c;for(let b=0;b<a;b++){const w=b*(u*c);for(let T=0;T<u;T++){const N=T*c;for(let S=0;S<c;S++){const U=Math.round(u-T-1),J=x+w+N+S;let ht=d[J];U>=0&&U<u&&(ht=d[x+w+U*c+S]),s[J]=ht}}}}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},o3=rh(t=>Math.floor(t)),oht=sd(g.Floor,o3),aht={kernelName:g.Floor,backendName:"cpu",kernelFunc:oht},uht=Aa((t,n)=>Math.floor(t/n)),lht=tu(g.FloorDiv,uht,null,"int32"),cht={kernelName:g.FloorDiv,backendName:"cpu",kernelFunc:lht},dht={kernelName:g.FusedConv2D,backendName:"cpu",kernelFunc:function hht(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v,activation:x,leakyreluAlpha:b}=r;let w=QB({inputs:{x:i,filter:s},backend:e,attrs:{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v}});if(o){const T=w;if("NCHW"===d&&1===o.shape.length&&1!==o.shape[0]){const N=No({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});w=Mp({inputs:{a:w,b:N},backend:e}),e.disposeIntermediateTensorInfo(N)}else w=Mp({inputs:{a:w,b:o},backend:e});e.disposeIntermediateTensorInfo(T)}if(x){const T=w;if("NCHW"===d&&"prelu"===x&&1===a.shape.length&&1!==a.shape[0]){const N=No({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});w=Y_(e,w,x,N,b),e.disposeIntermediateTensorInfo(N)}else w=Y_(e,w,x,a,b);e.disposeIntermediateTensorInfo(T)}return w}},pht={kernelName:g.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function fht(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v,activation:x,leakyreluAlpha:b}=r;let w=qB({inputs:{x:i,filter:s},backend:e,attrs:{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v}});if(o){const T=w;w=Mp({inputs:{a:w,b:o},backend:e}),e.disposeIntermediateTensorInfo(T)}if(x){const T=w;w=Y_(e,w,x,a,b),e.disposeIntermediateTensorInfo(T)}return w}};function a3(t,n,e,r,i,s,o,a,u){const c=(0,g.buffer)([r,s],e);for(let d=0;d<r;d++){const p=[];let v=0;for(let x=0;x<i;x++){const b=t[d*i+x];v+=b*o[x],p.push(b)}if(v<0||v>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let x=0;x<s;x++)c.values[d*s+x]=n.get(...n.indexToLoc(v*s+x))}return c}const ght={kernelName:g.GatherNd,backendName:"cpu",kernelFunc:function mht(t){const{inputs:n,backend:e}=t,{params:r,indices:i}=n,s=g.util.sizeFromShape(r.shape),o=i.shape,a=o[o.length-1],[u,c,d,p]=g.backend_util.prepareAndValidate(r,i);if(0===c)return e.makeTensorInfo(u,r.dtype,[]);const b=a3(e.data.get(i.dataId).values,e.bufferSync(r),r.dtype,c,a,d,p,r.shape,s);return e.makeTensorInfo(u,r.dtype,b.values)}};function u3(t,n,e){const r=(0,g.buffer)(e,t.dtype);for(let i=0;i<r.size;++i){const o=r.indexToLoc(i).slice(),c=n.locToIndex([o[0],o[2]]);o[2]=n.values[c];const d=t.locToIndex(o);0<=d&&d<t.values.length&&(r.values[i]=t.values[d])}return r}const vht={kernelName:g.GatherV2,backendName:"cpu",kernelFunc:function yht(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,indices:s}=n,{axis:o,batchDims:a}=r;ar([i,s],"gatherV2");const u=g.util.parseAxisParam(o,i.shape)[0],c=e.data.get(s.dataId).values,d=i.shape[u];for(let J=0;J<c.length;++J){const ht=c[J];g.util.assert(ht<=d-1&&ht>=0,()=>`GatherV2: the index value ${ht} is not in [0, ${d-1}]`)}let p=a;null==a&&(p=0);const v=g.util.sizeFromShape(s.shape),x=g.backend_util.segment_util.collectGatherOpShapeInfo(i,s,u,p),b=No({inputs:{x:i},backend:e,attrs:{shape:[x.batchSize,x.outerSize,x.dimSize,x.sliceSize]}}),w=No({inputs:{x:s},backend:e,attrs:{shape:[x.batchSize,v/x.batchSize]}}),T=[x.batchSize,x.outerSize,v/x.batchSize,x.sliceSize],N=e.bufferSync(w),U=u3(e.bufferSync(b),N,T);return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w),e.makeTensorInfo(x.outputShape,U.dtype,U.values)}},l3=Aa((t,n)=>t>n?1:0),_ht=tu(g.Greater,l3,null,"bool"),xht={kernelName:g.Greater,backendName:"cpu",kernelFunc:_ht},c3=Aa((t,n)=>t>=n?1:0),Eht=tu(g.GreaterEqual,c3,null,"bool"),Cht={kernelName:g.GreaterEqual,backendName:"cpu",kernelFunc:Eht},wht={kernelName:g.IFFT,backendName:"cpu",kernelFunc:function bht(t){const{inputs:n,backend:e}=t,{input:r}=n,i=g.util.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=No({inputs:{x:r},backend:e,attrs:{shape:[i/s,s]}}),u=s3(a,!0,e),c=No({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),c}},Iht=Js(g.IsFinite,t=>Number.isFinite(t)?1:0,"bool"),Sht={kernelName:g.IsFinite,backendName:"cpu",kernelFunc:Iht},Dht=Js(g.IsInf,t=>Math.abs(t)===1/0?1:0,"bool"),Tht={kernelName:g.IsInf,backendName:"cpu",kernelFunc:Dht},Nht=Js(g.IsNan,t=>Number.isNaN(t)?1:0,"bool"),Aht={kernelName:g.IsNan,backendName:"cpu",kernelFunc:Nht},h3=Aa((t,n)=>t<n?1:0),Mht=tu(g.Less,h3,null,"bool"),Pht={kernelName:g.Less,backendName:"cpu",kernelFunc:Mht},d3=Aa((t,n)=>t<=n?1:0),Oht=tu(g.LessEqual,d3,null,"bool"),Rht={kernelName:g.LessEqual,backendName:"cpu",kernelFunc:Oht};function f3(t,n,e){const r=(n-t)/(e-1),i=g.util.makeZerosTypedArray(e,"float32");i[0]=t;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}const kht={kernelName:g.LinSpace,backendName:"cpu",kernelFunc:function Lht(t){const{backend:n,attrs:e}=t,{start:r,stop:i,num:s}=e,o=f3(r,i,s);return n.makeTensorInfo([o.length],"float32",o)}},p3=rh(t=>Math.log(t)),Fht=sd(g.Log,p3),$ht={kernelName:g.Log,backendName:"cpu",kernelFunc:Fht},Bht=Js(g.Log1p,t=>Math.log1p(t)),zht={kernelName:g.Log1p,backendName:"cpu",kernelFunc:Bht},Vht=Aa((t,n)=>t&&n),Uht=tu(g.LogicalAnd,Vht,null,"bool"),Wht={kernelName:g.LogicalAnd,backendName:"cpu",kernelFunc:Uht},Ght=Js(g.LogicalNot,t=>t?0:1,"bool"),Hht={kernelName:g.LogicalNot,backendName:"cpu",kernelFunc:Ght},jht=Aa((t,n)=>t||n),Kht=tu(g.LogicalOr,jht,null,"bool"),Xht={kernelName:g.LogicalOr,backendName:"cpu",kernelFunc:Kht},Yht={kernelName:g.LRN,backendName:"cpu",kernelFunc:function Zht(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{depthRadius:s,bias:o,alpha:a,beta:u}=r;ar(i,"LRN");const c=i.shape[3],d=c-1,p=e.data.get(i.dataId).values,v=g.util.sizeFromShape(i.shape),x=new Float32Array(v);function b(w){const T=w%c;let N=w-T+Math.max(0,T-s);const S=w-T+Math.min(T+s,d);let U=0;for(;N<=S;N++){const J=p[N];U+=J*J}return U}for(let w=0;w<v;w++){const T=b(w),N=p[w]*Math.pow(o+a*T,-u);x[w]=N}return e.makeTensorInfo(i.shape,i.dtype,x)}},qht={kernelName:g.LRNGrad,backendName:"cpu",kernelFunc:function Qht(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,y:s,dy:o}=n,{depthRadius:a,bias:u,alpha:c,beta:d}=r;ar(o,"LRNGrad");const p=g.util.sizeFromShape(o.shape),v=o.shape[3],x=e.data.get(o.dataId).values,b=e.data.get(i.dataId).values,w=e.data.get(s.dataId).values,T=new Float32Array(p),N=p;for(let S=0;S<N;S++){const U=S%v,J=S-U+Math.max(0,U-a),ht=S-U+Math.min(v,U+a+1);let Tt=0;for(let Pt=J;Pt<ht;Pt++)Tt+=Math.pow(b[Pt],2);Tt=c*Tt+u;for(let Pt=J;Pt<ht;Pt++){let zt=-2*c*d*b[Pt]*w[S]/Tt;S===Pt&&(zt+=Math.pow(Tt,-d)),zt*=x[S],T[Pt]+=zt}}return e.makeTensorInfo(o.shape,i.dtype,T)}};function m3(t,n,e,r){const i=g.util.getTypedArrayFromDType(r,g.util.sizeFromShape(e));for(let s=0;s<i.length;++s){const o=s*n;let a=t[o];for(let u=0;u<n;++u){const c=t[o+u];(Number.isNaN(c)||c>a)&&(a=c)}i[s]=a}return i}function g3(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{reductionIndices:s,keepDims:o}=r,a=e;let u=i.shape;const c=u.length,d=g.util.parseAxisParam(s,u);let p=d;const v=g.backend_util.getAxesPermutation(p,c);let x=a.data.get(i.dataId).values;if(null!=v){const J=new Array(c);for(let ht=0;ht<J.length;ht++)J[ht]=u[v[ht]];x=WI(x,u,i.dtype,v,J),p=g.backend_util.getInnerMostAxes(p.length,c),u=J}ar(i,"max"),g.backend_util.assertAxesAreInnerMostDims("max",p,c);const[b,w]=g.backend_util.computeOutAndReduceShapes(u,p),N=m3(x,g.util.sizeFromShape(w),b,i.dtype),S=a.write(N,b,i.dtype);let U=b;return o&&(U=g.backend_util.expandShapeToKeepDim(b,d)),{dataId:S,shape:U,dtype:i.dtype}}const Jht={kernelName:g.Max,backendName:"cpu",kernelFunc:g3},y3=Aa((t,n)=>Math.max(t,n)),tdt=tu(g.Maximum,y3),edt={kernelName:g.Maximum,backendName:"cpu",kernelFunc:tdt},rdt={kernelName:g.MaxPool,backendName:"cpu",kernelFunc:function ndt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;ar(i,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=g.backend_util.computePool2DInfo(i.shape,s,o,1,a,u);let p;if(1===d.filterWidth&&1===d.filterHeight&&g.util.arraysEqual(d.inShape,d.outShape))p=ih({inputs:{x:i},backend:e});else{const v=e.data.get(i.dataId).values,x=g.util.computeStrides(i.shape),b=GI(v,0,i.dtype,x,d,"max");p=e.makeTensorInfo(d.outShape,i.dtype,b.values)}return p}},sdt={kernelName:g.MaxPool3D,backendName:"cpu",kernelFunc:function idt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{filterSize:s,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r;ar(i,"maxPool3d");const d=g.backend_util.computePool3DInfo(i.shape,s,o,1,a,u,c),v=HB(e.data.get(i.dataId).values,0,i.dtype,g.util.computeStrides(i.shape),d,"max");return e.makeTensorInfo(v.shape,"float32",v.values)}},adt={kernelName:g.MaxPool3DGrad,backendName:"cpu",kernelFunc:function odt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,{filterSize:o,strides:a,pad:u,dimRoundingMode:c}=r;ar([i,s],"maxPool3DGrad");const d=g.backend_util.computePool3DInfo(s.shape,o,a,1,u,c),v=function vlt(t,n){const e=(0,g.buffer)(n.outShape,"int32"),r=n.strideDepth,i=n.strideHeight,s=n.strideWidth,o=n.dilationDepth,a=n.dilationHeight,u=n.dilationWidth,c=n.effectiveFilterDepth,d=n.effectiveFilterHeight,p=n.effectiveFilterWidth,v=n.padInfo.front,x=n.padInfo.top,b=n.padInfo.left;for(let w=0;w<n.batchSize;++w)for(let T=0;T<n.inChannels;++T)for(let N=0;N<n.outDepth;++N){const S=N*r-v;let U=S;for(;U<0;)U+=o;const J=Math.min(n.inDepth,c+S);for(let ht=0;ht<n.outHeight;++ht){const Tt=ht*i-x;let Pt=Tt;for(;Pt<0;)Pt+=a;const zt=Math.min(n.inHeight,d+Tt);for(let Ot=0;Ot<n.outWidth;++Ot){const le=Ot*s-b;let ge=le;for(;ge<0;)ge+=u;const Ae=Math.min(n.inWidth,p+le);let Re=Number.NEGATIVE_INFINITY,ve=-1;for(let Ne=U;Ne<J;Ne+=o){const Se=Ne-S;for(let Ke=Pt;Ke<zt;Ke+=a){const Le=Ke-Tt;for(let Be=ge;Be<Ae;Be+=u){const on=Be-le,rn=t.get(w,Ne,Ke,Be,T);rn>=Re&&(Re=rn,ve=Se*d*p+Le*d+on)}}}e.set(ve,w,N,ht,Ot,T)}}}return e}(e.bufferSync(s),d),x=d.strideDepth,b=d.strideHeight,w=d.strideWidth,T=d.dilationDepth,N=d.dilationHeight,S=d.dilationWidth,U=d.effectiveFilterDepth,J=d.effectiveFilterHeight,ht=d.effectiveFilterWidth,Tt=U-1-d.padInfo.front,Pt=ht-1-d.padInfo.left,zt=J-1-d.padInfo.top,Ot=(0,g.buffer)(s.shape,"float32"),le=e.bufferSync(i);for(let ge=0;ge<d.batchSize;++ge)for(let Ae=0;Ae<d.inChannels;++Ae)for(let Re=0;Re<d.inDepth;++Re)for(let ve=0;ve<d.inHeight;++ve)for(let Ne=0;Ne<d.inWidth;++Ne){const Se=Re-Tt,Ke=ve-zt,Le=Ne-Pt;let Be=0;for(let on=0;on<U;on+=T){const rn=(Se+on)/x;if(!(rn<0||rn>=d.outDepth||Math.floor(rn)!==rn))for(let pn=0;pn<J;pn+=N){const qe=(Ke+pn)/b;if(!(qe<0||qe>=d.outHeight||Math.floor(qe)!==qe))for(let gn=0;gn<ht;gn+=S){const dn=(Le+gn)/w;if(dn<0||dn>=d.outWidth||Math.floor(dn)!==dn)continue;const Cr=U*J*ht-1-v.get(ge,rn,qe,dn,Ae)===on*J*ht+pn*ht+gn?1:0;0!==Cr&&(Be+=le.get(ge,rn,qe,dn,Ae)*Cr)}}}Ot.set(Be,ge,Re,ve,Ne,Ae)}return e.makeTensorInfo(Ot.shape,Ot.dtype,Ot.values)}},ldt={kernelName:g.MaxPoolGrad,backendName:"cpu",kernelFunc:function udt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s,output:o}=n,a=s;ar([s,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=r,v=g.backend_util.computePool2DInfo(a.shape,u,c,1,d,p),x=e.data.get(a.dataId).values,b=(0,g.buffer)(v.outShape,a.dtype,GB(x,a.shape,a.dtype,v).values),w=v.strideHeight,T=v.strideWidth,N=v.dilationHeight,S=v.dilationWidth,U=v.effectiveFilterHeight,J=v.effectiveFilterWidth,ht=J-1-v.padInfo.left,Tt=U-1-v.padInfo.top,Pt=(0,g.buffer)(a.shape,"float32"),zt=e.data.get(i.dataId).values,Ot=(0,g.buffer)(i.shape,"float32",zt);for(let le=0;le<v.batchSize;++le)for(let ge=0;ge<v.inChannels;++ge)for(let Ae=0;Ae<v.inHeight;++Ae)for(let Re=0;Re<v.inWidth;++Re){const ve=Ae-Tt,Ne=Re-ht;let Se=0;for(let Ke=0;Ke<U;Ke+=N){const Le=(ve+Ke)/w;if(!(Le<0||Le>=v.outHeight||Math.floor(Le)!==Le))for(let Be=0;Be<J;Be+=S){const on=(Ne+Be)/T;if(on<0||on>=v.outWidth||Math.floor(on)!==on)continue;const qe=U*J-1-b.get(le,Le,on,ge)===Ke*J+Be?1:0;0!==qe&&(Se+=Ot.get(le,Le,on,ge)*qe)}}Pt.set(Se,le,Ae,Re,ge)}return e.makeTensorInfo(Pt.shape,Pt.dtype,Pt.values)}},hdt={kernelName:g.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:a}=n,u=e;ar(r,"MaxPoolWithArgmax");const c=u.data.get(r.dataId).values,d=g.backend_util.computePool2DInfo(r.shape,i,s,[1,1],o),[p,v]=function cdt(t,n,e,r,i){const o=GI(t,0,e,g.util.computeStrides(n),i,"max"),a=GB(t,n,e,i,!0,r);return[o.values,a.values]}(c,r.shape,r.dtype,a,d),x=u.write(p,d.outShape,r.dtype),b=u.write(v,d.outShape,r.dtype);return[{dataId:x,shape:d.outShape,dtype:r.dtype},{dataId:b,shape:d.outShape,dtype:"int32"}]}},fdt={kernelName:g.Mean,backendName:"cpu",kernelFunc:function ddt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=g.util.parseAxisParam(s,i.shape),c=g.backend_util.computeOutAndReduceShapes(i.shape,a)[1],d=g.util.sizeFromShape(c),p=[],v=e.makeTensorInfo([],"float32",new Float32Array([d]));p.push(v);const x=od({inputs:{x:i},backend:e,attrs:{dtype:"float32"}});p.push(x);const b=KI({inputs:{a:x,b:v},backend:e});p.push(b);const w=Hg({inputs:{x:b},backend:e,attrs:{axis:s,keepDims:o}});return p.forEach(T=>e.disposeIntermediateTensorInfo(T)),w}},mdt={kernelName:g.Min,backendName:"cpu",kernelFunc:function pdt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;ar(i,"min");const a=g.util.parseAxisParam(s,i.shape);let u=a;const c=g.backend_util.getAxesPermutation(u,i.shape.length);let d=i;null!=c&&(d=fl({inputs:{x:i},backend:e,attrs:{perm:c}}),u=g.backend_util.getInnerMostAxes(u.length,i.shape.length)),g.backend_util.assertAxesAreInnerMostDims("min",u,d.shape.length);const[p,v]=g.backend_util.computeOutAndReduceShapes(d.shape,u),x=g.util.sizeFromShape(v),b=g.util.makeZerosTypedArray(g.util.sizeFromShape(p),d.dtype),w=e.data.get(d.dataId).values;for(let N=0;N<b.length;++N){const S=N*x;let U=w[S];for(let J=0;J<x;++J){const ht=w[S+J];(Number.isNaN(ht)||ht<U)&&(U=ht)}b[N]=U}null!=c&&e.disposeIntermediateTensorInfo(d);const T=e.makeTensorInfo(p,d.dtype,b);if(o){const S=No({inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(p,a)}});return e.disposeIntermediateTensorInfo(T),S}return T}},v3=Aa((t,n)=>Math.min(t,n)),gdt=tu(g.Minimum,v3),ydt={kernelName:g.Minimum,backendName:"cpu",kernelFunc:gdt},_dt={kernelName:g.MirrorPad,backendName:"cpu",kernelFunc:function vdt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{paddings:s,mode:o}=r;ar(i,"mirrorPad");const a=s.map((U,J)=>U[0]+i.shape[J]+U[1]),u=s.map(U=>U[0]),c=s.map((U,J)=>U[0]+i.shape[J]),d="reflect"===o?0:1,p=e.data.get(i.dataId).values,v=i.shape.length,x=g.util.computeStrides(i.shape),b=g.util.sizeFromShape(a),w=a.length,T=g.util.computeStrides(a),N=g.util.getTypedArrayFromDType(i.dtype,b);for(let U=0;U<b;U++){let J=g.util.indexToLoc(U,w,T);for(let Tt=0;Tt<w;Tt++)J[Tt]<u[Tt]?J[Tt]=2*u[Tt]-J[Tt]-d:J[Tt]>=c[Tt]&&(J[Tt]=2*(c[Tt]-1)-J[Tt]+d);J=J.map((Tt,Pt)=>Tt-u[Pt]);const ht=g.util.locToIndex(J,v,x);N[U]=p[ht]}return{dataId:e.write(N,a,i.dtype),shape:a,dtype:i.dtype}}},xdt=Aa((t,n)=>{const e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),Edt=tu(g.Mod,xdt),Cdt={kernelName:g.Mod,backendName:"cpu",kernelFunc:Edt};function _3(t){const{inputs:n,backend:e,attrs:r}=t,{logits:i}=n,{dim:s}=r,o=i.shape.length;let a=s;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const u=g.util.parseAxisParam([a],i.shape),c=g3({inputs:{x:i},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),d=g.backend_util.expandShapeToKeepDim(c.shape,u),p=No({inputs:{x:c},backend:e,attrs:{shape:d}}),v=ZI({inputs:{a:i,b:p},backend:e}),x=n3({inputs:{x:v},backend:e}),b=Hg({inputs:{x},backend:e,attrs:{axis:u,keepDims:!1}}),w=No({inputs:{x:b},backend:e,attrs:{shape:d}}),T=KI({inputs:{a:x,b:w},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w),T}const bdt={kernelName:g.Softmax,backendName:"cpu",kernelFunc:_3},Idt={kernelName:g.Multinomial,backendName:"cpu",kernelFunc:function wdt(t){const{inputs:n,backend:e,attrs:r}=t,{logits:i}=n,{numSamples:s,seed:o,normalized:a}=r;ar(i,"multinomial");const u=a?i:_3({inputs:{logits:i},backend:e,attrs:{dim:-1}}),c=u.shape[0],d=u.shape[1],p=e.data.get(u.dataId).values,v=[c,s],x=g.util.makeZerosTypedArray(g.util.sizeFromShape(v),"int32");for(let b=0;b<c;++b){const w=b*d,T=new Float32Array(d-1);T[0]=p[w];for(let U=1;U<T.length;++U)T[U]=T[U-1]+p[w+U];const N=Zat.alea(o.toString()),S=b*s;for(let U=0;U<s;++U){const J=N();x[S+U]=T.length;for(let ht=0;ht<T.length;ht++)if(J<T[ht]){x[S+U]=ht;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(v,"int32",x)}};function x3(t,n,e){const r=g.util.createScalarValue(-1,e);return jI([],n,r,t,e)}const Ddt={kernelName:g.Neg,backendName:"cpu",kernelFunc:function Sdt(t){const{inputs:n,backend:e}=t,{x:r}=n;ar(r,"neg");const i=e.data.get(r.dataId).values,[s,o]=x3(i,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,s)}},Tdt=g.kernel_impls.nonMaxSuppressionV3Impl,Adt={kernelName:g.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function Ndt(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=r;ar(i,"NonMaxSuppression");const c=e.data.get(i.dataId).values,d=e.data.get(s.dataId).values,{selectedIndices:p}=Tdt(c,d,o,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}},Mdt=g.kernel_impls.nonMaxSuppressionV4Impl,Odt={kernelName:g.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function Pdt(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r;ar(i,"NonMaxSuppressionPadded");const d=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:v,validOutputs:x}=Mdt(d,p,o,a,u,c);return[e.makeTensorInfo([v.length],"int32",new Int32Array(v)),e.makeTensorInfo([],"int32",new Int32Array([x]))]}},Rdt=g.kernel_impls.nonMaxSuppressionV5Impl,kdt={kernelName:g.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function Ldt(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r;ar(i,"NonMaxSuppressionWithScore");const d=e.data.get(i.dataId).values,p=e.data.get(s.dataId).values,v=o,x=a,b=u,w=c,{selectedIndices:T,selectedScores:N}=Rdt(d,p,v,x,b,w);return[e.makeTensorInfo([T.length],"int32",new Int32Array(T)),e.makeTensorInfo([N.length],"float32",new Float32Array(N))]}},E3=Aa((t,n)=>t!==n?1:0),Fdt=tu(g.NotEqual,E3,null,"bool"),$dt={kernelName:g.NotEqual,backendName:"cpu",kernelFunc:Fdt},zdt={kernelName:g.OneHot,backendName:"cpu",kernelFunc:function Bdt(t){const{inputs:n,backend:e,attrs:r}=t,{indices:i}=n,{dtype:s,depth:o,onValue:a,offValue:u}=r;ar(i,"oneHot");const c=g.util.sizeFromShape(i.shape),d=new Float32Array(c*o);d.fill(u);const p=e.data.get(i.dataId).values;for(let v=0;v<c;++v)p[v]>=0&&p[v]<o&&(d[v*o+p[v]]=a);return e.makeTensorInfo([...i.shape,o],s,d)}};function t1(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const i=jd({inputs:{input:r},backend:e}),s=t1({inputs:{x:i},backend:e}),o=Pp({inputs:{input:r},backend:e}),a=t1({inputs:{x:o},backend:e}),u=Cl({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return QI({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Vdt={kernelName:g.ZerosLike,backendName:"cpu",kernelFunc:t1},Udt={kernelName:g.OnesLike,backendName:"cpu",kernelFunc:function C3(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const i=jd({inputs:{input:r},backend:e}),s=C3({inputs:{x:i},backend:e}),o=Pp({inputs:{input:r},backend:e}),a=t1({inputs:{x:o},backend:e}),u=Cl({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return QI({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function b3(t){const{inputs:n,backend:e,attrs:r}=t,{axis:i}=r;if(1===n.length)return J_({inputs:{input:n[0]},backend:e,attrs:{dim:i}});const s=n[0].shape,o=n[0].dtype;n.forEach(d=>{g.util.assertShapesMatch(s,d.shape,"All tensors passed to stack must have matching shapes"),g.util.assert(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Op({inputs:n.map(d=>{const p=J_({inputs:{input:d},backend:e,attrs:{dim:i}});return a.push(p),p}),backend:e,attrs:{axis:i}});return a.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}const Wdt={kernelName:g.Pack,backendName:"cpu",kernelFunc:b3},w3={kernelName:g.PadV2,backendName:"cpu",kernelFunc:function Gdt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{paddings:s,constantValue:o}=r;ar(i,"pad");const a=s.map((S,U)=>S[0]+i.shape[U]+S[1]),u=s.map(S=>S[0]),c=e.data.get(i.dataId).values,d=g.util.sizeFromShape(i.shape),p=i.shape.length,v=g.util.computeStrides(i.shape),x=g.util.sizeFromShape(a),b=a.length,w=g.util.computeStrides(a),T=g.util.getTypedArrayFromDType(i.dtype,x);0!==o&&T.fill(o);for(let S=0;S<d;S++){const J=g.util.indexToLoc(S,p,v).map((Tt,Pt)=>Tt+u[Pt]);T[g.util.locToIndex(J,b,w)]=c[S]}return{dataId:e.write(T,a,i.dtype),shape:a,dtype:i.dtype}}},Hdt=Aa((t,n)=>Math.pow(t,n)),jdt=tu(g.Pow,Hdt),Kdt={kernelName:g.Pow,backendName:"cpu",kernelFunc:jdt};function I3(t,n,e,r){const[i,s]=g.backend_util.computeOutAndReduceShapes(t,r),o=(0,g.upcastType)(n,"int32"),a=g.util.makeZerosTypedArray(g.util.sizeFromShape(i),o),u=g.util.sizeFromShape(s);for(let c=0;c<a.length;++c){const d=c*u;let p=1;for(let v=0;v<u;++v)p*=e[d+v];a[c]=p}return{outVals:a,outShape:i,outDtype:o}}const Zdt={kernelName:g.Prod,backendName:"cpu",kernelFunc:function Xdt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;ar(i,"prod");const a=i.shape.length,u=g.util.parseAxisParam(s,i.shape),c=g.backend_util.getAxesPermutation(u,a);let d=u,p=i;const v=[];null!=c&&(p=fl({inputs:{x:i},backend:e,attrs:{perm:c}}),v.push(p),d=g.backend_util.getInnerMostAxes(d.length,a));const x=e.data.get(p.dataId).values,{outVals:b,outShape:w,outDtype:T}=I3(p.shape,p.dtype,x,d);let N=w;return o&&(N=g.backend_util.expandShapeToKeepDim(w,u)),v.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(N,T,b)}};function S3(t,n){const e=t.slice(0,n);for(;e.length<n;)e.push(1);for(let r=n;r<t.length;r++)e[n-1]*=t[r];return e}function D3(t,n,e,r,i,s,o,a){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw new Error("Split tensors must not be scalars");if(function Ydt(t,n,e){t.forEach((r,i)=>{if(r<0||r>=e){const s=g.util.indexToLoc(i,n.length,g.util.computeStrides(n)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${e})`)}})}(s,o,n[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:d,valueSlices:p,numValues:v}=function qdt(t,n,e,r){const i=[];let s=0;const a=new Array(n.length-1+e.length).fill(null).map(()=>[0]);!function Qdt(t,n){for(let e=0;e<t.length;++e){const r=t[e],i=e===t.length-1?n:t[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let u=1;for(let c=0;c<n.length-1;++c){u*=n[c];const d=n[c+1];for(let p=1;p<u+1;++p)a[c].push(p*d)}for(let c=0;c<t.length;++c){let d=t[c],p=t[c]+1;for(let v=0;v<e.length;++v){const x=e[v],b=v+n.length-1;if(b>=0){const w=a[b],T=w[w.length-1]-x[d];for(let N=d;N<p;++N)a[b].push(x[N+1]+T)}d=x[d],p=x[p]}p!==d&&(i.push([d,p]),s+=p-d)}return{outSplits:a,valueSlices:i,numValues:s}}(s,o,t,c),x=function Jdt(t){const n=[];for(let e=0;e<t.length;++e){const i=g.util.getArrayFromDType("int32",t[e].length);n.push(i),t[e].forEach((s,o)=>i[o]=s)}return n}(d),b=function eft(t,n,e,r,i){const s=n.slice();s[0]=i;const o=g.util.getArrayFromDType(e,g.util.sizeFromShape(s)),a=t.length;return function tft(t,n,e,r,i,s){const o=S3(n,2)[1],a=S3(s,2)[1];let u=0;for(const c of e)for(let d=c[0];d<c[1];++d){for(let p=0;p<r;++p)i[u*a+p]=t[d*o+p];++u}}(t,n,r,0===a?0:a/n[0],o,s),[o,s]}(e,r,i,p,v);return[x,b[0],b[1]]}const rft={kernelName:g.RaggedGather,backendName:"cpu",kernelFunc:function nft(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:o}=n,u=i.map(N=>e.data.get(N.dataId).values),c=i.map(N=>N.shape),d=e.data.get(s.dataId).values,p=e.data.get(o.dataId).values,[v,x,b]=D3(u,c,d,s.shape,s.dtype,p,o.shape),w=v.map(N=>e.makeTensorInfo([N.length],"int32",N)),T=e.makeTensorInfo(b,s.dtype,x);return w.concat([T])}},T3=2147483647;function N3(t,n,e,r,i,s,o){if(n.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===n.length,u=0===i.length,c=0===o.length,d=[];a||d.push(n[0]),u||d.push(i[0]),c||d.push(o[0]);for(let T=1;T<d.length;++T)if(d[T]!==d[T-1])throw new Error("starts, limits, and deltas must have the same shape");const p=0===d.length?1:d[0],v=g.util.getArrayFromDType("int32",p+1);v[0]=0;for(let T=0;T<p;++T){const N=a?t[0]:t[T],S=u?r[0]:r[T],U=c?s[0]:s[T];if(0===U)throw new Error("Requires delta != 0");let J;if(U>0&&S<N||U<0&&S>N)J=0;else if(J=Math.ceil(Math.abs((S-N)/U)),J>T3)throw new Error(`Requires ((limit - start) / delta) <= ${T3}`);v[T+1]=v[T]+J}const b=g.util.getArrayFromDType(e,v[p]);let w=0;for(let T=0;T<p;++T){const N=v[T+1]-v[T];let S=a?t[0]:t[T];const U=c?s[0]:s[T];for(let J=0;J<N;++J)b[w++]=S,S+=U}return[v,b]}const sft={kernelName:g.RaggedRange,backendName:"cpu",kernelFunc:function ift(t){const{inputs:n,backend:e}=t,{starts:r,limits:i,deltas:s}=n,o=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(s.dataId).values,[c,d]=N3(o,r.shape,r.dtype,a,i.shape,u,s.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([d.length],r.dtype,d)]}};var hc=g.backend_util.RowPartitionType;class e1{constructor(n,e,r,i,s,o,a,u,c,d){this.shape=n,this.shapeShape=e,this.values=r,this.valuesShape=i,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=g.backend_util.getRowPartitionTypesHelper(d),this.raggedRank=g.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===hc.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===hc.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){const e=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case hc.VALUE_ROWIDS:return e1.getMaxWidthValueRowID(e);case hc.ROW_SPLITS:return e1.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${hc[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){const e=n.length;if(0===e||1===e)return 0;let r=0;for(let i=0;i<e-1;++i){const s=n[i+1]-n[i];s>r&&(r=s)}return r}static getMaxWidthValueRowID(n){const e=n.length;if(0===e)return 0;let r=0,i=n[0],s=0;for(let o=1;o<e;++o){const a=n[o];a!==i&&(i=a,s=Math.max(o-r,s),r=o)}return Math.max(e-r,s)}tensorShapeFromTensor(n,e,r=!0){if(0===e.length){if(-1===n[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return M3(n,r)}calculateOutputSize(n){const e=this.valuesShape;g.backend_util.validateDefaultValueShape(this.defaultValueShape,e);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=g.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,i,e);o[0]<0&&(o[0]=n);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(n,e,r){const i=Math.min(n,r),s=[];let o=0;for(let a=0;a<i;++a,o+=e)s.push(o);for(let a=i;a<n;++a)s.push(-1);return g.util.assert(s.length===n,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(n,e,r,i){const s=n.length,o=[];for(let a=0;a<s-1;++a){const u=n[a+1]-n[a];let c=Math.min(i,u),d=e[a];-1===d&&(c=0);for(let p=0;p<c;++p)o.push(d),d+=r;for(let p=0;p<u-c;++p)o.push(-1)}if(s>0&&o.length!==n[s-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(n,e,r,i){const s=n.length,o=[];if(0===s)return[];let a=0,u=n[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let c=e[u];o.push(c);for(let d=1;d<s;++d){const p=n[d];if(p===u)c>=0&&(++a,a<i?c+=r:c=-1);else{if(a=0,u=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);c=e[p]}o.push(c)}if(o.length!==n.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(n,e,r,i){const s=this.getRowPartitionTensor(n),o=this.getRowPartitionTypeByDimension(n);switch(o){case hc.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,r,i);case hc.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,r,i);default:throw new Error(`Unsupported partition type: ${hc[o]}`)}}getFirstDimensionSize(){const n=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case hc.FIRST_DIM_SIZE:return n[0];case hc.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case hc.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${hc[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let u=i.length-2;u>=0;--u)i[u]=i[u+1]*r[u+1];const s=M3(r,!1),o=g.util.getArrayFromDType(this.valuesDType,g.util.sizeFromShape(s));if(i[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(e,i[0],r[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,i[c],r[c]);this.setOutput(this.raggedRank,u,o,s)}return[s,o]}setOutput(n,e,r,i){if(0===r.length)return;const s=this.values,o=r;let a=i.slice();a=a.slice(n+1);const u=g.util.sizeFromShape(a),c=e.length;let d=this.defaultValue;if(d.length!==u&&1!==d.length){const b=this.defaultValueShape;(0,g.tidy)(()=>{const w=(0,g.reshape)(d,b);d=(0,g.broadcastTo)(w,a).dataSync()})}let p=0,v=0,x=0;for(let b=0;b<=c;++b){let w=b<c?e[b]:-1;if(w!==x){if(v<x){const T=s.subarray(p*u);A3(o.subarray(v*u),T,(x-v)*u)}if(b>=c&&(w=Math.floor(r.length/u)),w>x)if(1===this.defaultValue.length)o.subarray(x*u,w*u).fill(this.defaultValue[0]),x=w;else for(;w>x;)A3(o.slice(x*u),d,u),++x;w<0?(p=b+1,v=x):(p=b,v=x,x=v+1)}else++x}}}function A3(t,n,e){for(let r=0;r<e;r++)t[r]=n[r]}function M3(t,n){const e=[];for(let r of t){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function P3(t,n,e,r,i,s,o,a,u,c){return new e1(t,n,e,r,i,s,o,a,u,c).compute()}const aft={kernelName:g.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function oft(t){const{inputs:n,backend:e,attrs:r}=t,{shape:i,values:s,defaultValue:o,rowPartitionTensors:a}=n,{rowPartitionTypes:u}=r,c=e.data.get(i.dataId).values,d=e.data.get(s.dataId).values,p=e.data.get(o.dataId).values,v=a.map(T=>e.data.get(T.dataId).values),x=a.map(T=>T.shape),[b,w]=P3(c,i.shape,d,s.shape,s.dtype,p,o.shape,v,x,u);return e.makeTensorInfo(b,s.dtype,w)}};function O3(t,n,e,r){if(t===n||t<n&&e<0||n<t&&e>1)return g.util.makeZerosTypedArray(0,r);const a=Math.abs(Math.ceil((n-t)/e)),u=g.util.makeZerosTypedArray(a,r);n<t&&1===e&&(e=-1),u[0]=t;for(let c=1;c<u.length;c++)u[c]=u[c-1]+e;return u}const lft={kernelName:g.Range,backendName:"cpu",kernelFunc:function uft(t){const{backend:n,attrs:e}=t,{start:r,stop:i,dtype:s,step:o}=e,a=O3(r,i,o,s);return n.makeTensorInfo([a.length],s,a)}},cft=Js(g.Reciprocal,t=>1/t),hft={kernelName:g.Reciprocal,backendName:"cpu",kernelFunc:cft},fft={kernelName:g.ResizeBilinear,backendName:"cpu",kernelFunc:function dft(t){const{inputs:n,backend:e,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:o,size:a}=r;ar(i,"resizeBilinear");const u=g.util.computeStrides(i.shape),[c,d]=a,[p,v,x,b]=i.shape,w=e.data.get(i.dataId).values,T=new Float32Array(g.util.sizeFromShape([p,c,d,b])),N=[s&&c>1?v-1:v,s&&d>1?x-1:x],S=[s&&c>1?c-1:c,s&&d>1?d-1:d];let U=0;const J=N[0]/S[0],ht=N[1]/S[1];for(let Tt=0;Tt<p;Tt++)for(let Pt=0;Pt<c;Pt++){let zt;zt=o?J*(Pt+.5)-.5:J*Pt;const Ot=Math.max(0,Math.floor(zt)),le=zt-Ot,ge=Math.min(v-1,Math.ceil(zt)),Ae=Tt*u[0]+Ot*u[1],Re=Tt*u[0]+ge*u[1];for(let ve=0;ve<d;ve++){let Ne;Ne=o?ht*(ve+.5)-.5:ht*ve;const Se=Math.max(0,Math.floor(Ne)),Ke=Ne-Se,Le=Math.min(x-1,Math.ceil(Ne)),Be=Ae+Se*u[2],on=Re+Se*u[2],rn=Ae+Le*u[2],pn=Re+Le*u[2];for(let qe=0;qe<b;qe++){const gn=w[Be+qe],dn=w[on+qe],Cr=gn+(w[rn+qe]-gn)*Ke;T[U++]=Cr+(dn+(w[pn+qe]-dn)*Ke-Cr)*le}}}return e.makeTensorInfo([p,c,d,b],"float32",T)}},mft={kernelName:g.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function pft(t){const{inputs:n,backend:e,attrs:r}=t,{images:i,dy:s}=n,{alignCorners:o}=r;ar([s,i],"resizeBilinearGrad");const a=g.util.computeStrides(i.shape),[u,c,d,p]=i.shape,[,v,x]=s.shape,b=new Float32Array(u*c*d*p),w=[o&&v>1?c-1:c,o&&x>1?d-1:d],T=[o&&v>1?v-1:v,o&&x>1?x-1:x],N=w[0]/T[0],S=w[1]/T[1],U=e.data.get(s.dataId).values;let J=0;for(let ht=0;ht<u;ht++){const Tt=ht*a[0];for(let Pt=0;Pt<v;Pt++){const zt=Pt*N,Ot=Math.floor(zt),le=Math.min(Math.ceil(zt),c-1),ge=Tt+Ot*a[1],Ae=Tt+le*a[1],Re=zt-Ot,ve=1-Re;for(let Ne=0;Ne<x;Ne++){const Se=Ne*S,Ke=Math.floor(Se),Le=Math.min(Math.ceil(Se),d-1),Be=Se-Ke,on=1-Be,rn=ge+Ke*a[2],pn=ge+Le*a[2],qe=Ae+Ke*a[2],gn=Ae+Le*a[2],dn=ve*on,kn=ve*Be,rr=Re*on,Cr=Re*Be;for(let yr=0;yr<p;yr++){const jr=U[J++];b[rn+yr]+=jr*dn,b[pn+yr]+=jr*kn,b[qe+yr]+=jr*rr,b[gn+yr]+=jr*Cr}}}}return e.makeTensorInfo([u,d,c,p],"float32",b)}},yft={kernelName:g.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function gft(t){const{inputs:n,backend:e,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:o,size:a}=r;ar(i,"resizeNearestNeighbor");const u=g.util.computeStrides(i.shape),[c,d]=a,[p,v,x,b]=i.shape,w=e.data.get(i.dataId).values,T=new Float32Array(p*c*d*b),N=[s&&c>1?v-1:v,s&&d>1?x-1:x],S=[s&&c>1?c-1:c,s&&d>1?d-1:d],U=N[0]/S[0],J=N[1]/S[1];let ht=0;for(let Tt=0;Tt<p;Tt++){const Pt=Tt*u[0];for(let zt=0;zt<c;zt++){const Ot=o?U*(zt+.5):U*zt;let le=Math.min(v-1,s?Math.round(Ot):Math.floor(Ot));o&&(le=Math.max(0,le));const ge=Pt+le*u[1];for(let Ae=0;Ae<d;Ae++){const Re=o?J*(Ae+.5):J*Ae;let ve=Math.min(x-1,s?Math.round(Re):Math.floor(Re));o&&(ve=Math.max(0,ve));const Ne=ge+ve*u[2];for(let Se=0;Se<b;Se++)T[ht++]=w[Ne+Se]}}}return e.makeTensorInfo([p,c,d,b],i.dtype,T)}},_ft={kernelName:g.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function vft(t){const{inputs:n,backend:e,attrs:r}=t,{images:i,dy:s}=n,{alignCorners:o}=r;ar([s,i],"resizeNearestNeighborGrad");const a=g.util.computeStrides(i.shape),u=g.util.computeStrides(s.shape),[c,d,p,v]=i.shape,[,x,b]=s.shape,w=new Float32Array(c*d*p*v),T=e.data.get(s.dataId).values,N=[o&&x>1?d-1:d,o&&b>1?p-1:p],S=[o&&x>1?x-1:x,o&&b>1?b-1:b],U=N[0]/S[0],J=N[1]/S[1],ht=1/U,Tt=1/J,Pt=2*Math.ceil(ht)+2,zt=2*Math.ceil(Tt)+2;for(let Ot=0;Ot<c;Ot++){const le=Ot*a[0];for(let ge=0;ge<d;ge++){const Ae=le+ge*a[1],Re=Math.floor(ge*ht),ve=Math.floor(Re-Pt/2);for(let Ne=0;Ne<p;Ne++){const Se=Ae+Ne*a[2],Ke=Math.floor(Ne*Tt),Le=Math.floor(Ke-zt/2);for(let Be=0;Be<v;Be++){let on=0;for(let rn=0;rn<Pt;rn++){const pn=rn+ve;if(pn<0||pn>=x)continue;const qe=le+pn*u[1],gn=pn*U;if(ge===Math.min(d-1,o?Math.round(gn):Math.floor(gn)))for(let kn=0;kn<zt;kn++){const rr=kn+Le;if(rr<0||rr>=b)continue;const Cr=qe+rr*u[2],yr=rr*J;Ne===Math.min(p-1,o?Math.round(yr):Math.floor(yr))&&(on+=T[Cr+Be])}}w[Se+Be]=on}}}}return e.makeTensorInfo(i.shape,i.dtype,w)}},Eft={kernelName:g.Reverse,backendName:"cpu",kernelFunc:function xft(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{dims:s}=r;ar(i,"reverse");const o=i.shape.length,a=g.util.parseAxisParam(s,i.shape);if(0===o)return ih({inputs:{x:i},backend:e});const u=new g.TensorBuffer(i.shape,i.dtype),c=e.bufferSync(i);for(let d=0;d<u.size;d++){const p=u.indexToLoc(d),v=p.slice();a.forEach(x=>v[x]=i.shape[x]-1-v[x]),u.set(c.get(...v),...p)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}},Cft={kernelName:g.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:i,fillValue:s,center:o}=n,a=e,u=g.util.getTypedArrayFromDType(r.dtype,g.util.sizeFromShape(r.shape)),[c,d,p,v]=r.shape,[x,b]=g.backend_util.getImageCenter(o,d,p),T=Math.sin(i),N=Math.cos(i),S=a.data.get(r.dataId).values;for(let J=0;J<c;J++){const ht=J*p*d*v;for(let Tt=0;Tt<d;Tt++){const Pt=Tt*(p*v);for(let zt=0;zt<p;zt++){const Ot=zt*v;for(let le=0;le<v;le++){const ge=[c,Tt,zt,le],Ae=ge[2],Re=ge[1];let ve=(Ae-x)*N-(Re-b)*T,Ne=(Ae-x)*T+(Re-b)*N;ve=Math.round(ve+x),Ne=Math.round(Ne+b);let Se=s;"number"!=typeof s&&(Se=3===le?255:s[le]),ve>=0&&ve<p&&Ne>=0&&Ne<d&&(Se=S[ht+Ne*(p*v)+ve*v+le]),u[ht+Pt+Ot+le]=Se}}}}return{dataId:a.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},bft=Js(g.Round,t=>{const n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2==0?n:n+1}),wft={kernelName:g.Round,backendName:"cpu",kernelFunc:bft},R3=rh(t=>1/Math.sqrt(t)),Ift=sd(g.Rsqrt,R3),Sft={kernelName:g.Rsqrt,backendName:"cpu",kernelFunc:Ift};function Xd(t,n,e,r,i,s,o,a,u,c){const d=[r/i,i],p=t.values,v=n.values;if(0===r)return(0,g.buffer)(e,n.dtype);const x=u instanceof g.TensorBuffer?u:(0,g.buffer)(d,n.dtype);"string"==typeof u||"number"==typeof u?x.values.fill(u):"boolean"==typeof u&&x.values.fill(+u);for(let b=0;b<s;b++){const w=[];let T=0;for(let N=0;N<o;N++){const S=p[b*o+N];w.push(S),T+=S*a[N]}if(T<0||T>=r/i)throw new Error(`Invalid indices: ${w} does not index into ${e}`);for(let N=0;N<i;N++)c?x.values[T*i+N]+=v[b*i+N]:x.values[T*i+N]=0===n.rank?v[0]:v[b*i+N]}return x}const Tft={kernelName:g.ScatterNd,backendName:"cpu",kernelFunc:function Dft(t){const{inputs:n,backend:e,attrs:r}=t,{indices:i,updates:s}=n,{shape:o}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=g.backend_util.calculateShapes(s,i,o),w=Xd(e.bufferSync(i),e.bufferSync(s),o,p,c,u,a,d,0,!0);return e.makeTensorInfo(o,w.dtype,w.values)}};function Nft(t,n){let e=0,r=t.length,i=0;for(;e<r;)i=Math.floor((e+r)/2),t[i]<n?e=i+1:r=i;return r}function Aft(t,n){let e=0,r=t.length,i=0;for(;e<r;)i=Math.floor((e+r)/2),t[i]<=n?e=i+1:r=i;return r}const Oft={kernelName:g.SearchSorted,backendName:"cpu",kernelFunc:function Pft(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:i,values:s}=n,{side:o}=r,c=function Mft(t,n,e,r,i,s){const o=g.util.getArrayFromDType("int32",e*i);for(let a=0;a<e;++a){const u=t.slice(a*r,(a+1)*r),c=a*i;for(let d=0;d<i;++d)o[c+d]="left"===s?Nft(u,n[d+c]):Aft(u,n[d+c])}return o}(e.data.get(i.dataId).values,e.data.get(s.dataId).values,i.shape[0],i.shape[1],s.shape[1],o);return e.makeTensorInfo(s.shape,"int32",c)}},Lft={kernelName:g.Select,backendName:"cpu",kernelFunc:function Rft(t){const{inputs:n,backend:e}=t,{condition:r,t:i,e:s}=n;ar([r,i,s],"select");const o=r.shape.length,a=e.data.get(r.dataId).values,u=e.data.get(i.dataId).values,c=e.data.get(s.dataId).values,d=(0,g.upcastType)(i.dtype,s.dtype),p=g.util.makeZerosTypedArray(g.util.sizeFromShape(i.shape),d);let v=0;const x=0===o||o>1||1===i.shape.length?1:g.util.sizeFromShape(i.shape.slice(1));for(let b=0;b<a.length;b++)for(let w=0;w<x;w++)p[v++]=1===a[b]?u[b]:c[b];return e.makeTensorInfo(i.shape,d,p)}},kft=g.backend_util.SELU_SCALEALPHA,Fft=g.backend_util.SELU_SCALE,$ft=Js(g.Selu,t=>t>=0?Fft*t:kft*(Math.exp(t)-1)),Bft={kernelName:g.Selu,backendName:"cpu",kernelFunc:$ft},zft=Js(g.Sign,t=>t<0?-1:t>0?1:0),Vft={kernelName:g.Sign,backendName:"cpu",kernelFunc:zft},Uft=Js(g.Sin,t=>Math.sin(t)),Wft={kernelName:g.Sin,backendName:"cpu",kernelFunc:Uft},Gft=Js(g.Sinh,t=>Math.sinh(t)),Hft={kernelName:g.Sinh,backendName:"cpu",kernelFunc:Gft},L3=Math.log(1.1920928955078125e-7)+2,jft=Js(g.Softplus,t=>{const n=t>-L3,e=t<L3,r=Math.exp(t);let i;return i=e?r:n?t:Math.log(1+r),i}),Kft={kernelName:g.Softplus,backendName:"cpu",kernelFunc:jft},Zft={kernelName:g.SpaceToBatchND,backendName:"cpu",kernelFunc:function Xft(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockShape:s,paddings:o}=r;ar([i],"spaceToBatchND");const a=g.util.sizeFromShape(s),u=[[0,0]];u.push(...o);for(let Tt=1+s.length;Tt<i.shape.length;++Tt)u.push([0,0]);const c=w3.kernelFunc({inputs:{x:i},backend:e,attrs:{paddings:u,constantValue:0}}),d=g.backend_util.getReshaped(c.shape,s,a,!1),p=g.backend_util.getPermuted(d.length,s.length,!1),v=g.backend_util.getReshapedPermuted(c.shape,s,a,!1),w=No({inputs:{x:c},backend:e,attrs:{shape:d}}),S=fl({inputs:{x:w},backend:e,attrs:{perm:p}}),ht=No({inputs:{x:S},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(S),ht}};function k3(t,n,e,r,i,s,o){const a=n[0],u=s[0],c=new Array(u),d=new Array(a),p=n[1];if(0===u){if(0!==a)throw new Error(g.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));return[g.util.getArrayFromDType(e,0),[0,p],g.util.getArrayFromDType(i,0),c,d]}let v=!0,x=0;const b=new Array(u).fill(0);for(let T=0;T<a;++T){const N=t[T*p];if(N<0)throw new Error(g.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(T,N));if(N>=u)throw new Error(g.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T,N,u));++b[N],v=v&&N>=x,x=N}let w=!0;for(let T=0;T<u;++T){const N=0===b[T];c[T]=N,w=w&&!N,b[T]=Math.max(b[T],1),T>0&&(b[T]+=b[T-1])}if(w&&v){const T=t,N=r;for(let S=0;S<a;++S)d[S]=S;return[T,[a,p],N,c,d]}{const T=b[u-1],N=g.util.getArrayFromDType(e,T*p),S=g.util.getArrayFromDType(i,T),U=new Array(u).fill(0);for(let J=0;J<a;++J){const ht=t[J*p],Pt=(0===ht?0:b[ht-1])+U[ht];U[ht]++;for(let zt=0;zt<p;++zt)N[Pt*p+zt]=t[J*p+zt];S[Pt]=r[J],d[J]=Pt}for(let J=0;J<u;++J)if(0===U[J]){const Tt=0===J?0:b[J-1];N[Tt*p+0]=J;for(let Pt=1;Pt<p;++Pt)N[Tt*p+Pt]=0;S[Tt]=o}return[N,[T,p],S,c,d]}}const Qft={kernelName:g.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function Yft(t){const{inputs:n,backend:e}=t,{indices:r,values:i,denseShape:s,defaultValue:o}=n;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n        ${i.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(r.dataId).values,u=e.data.get(i.dataId).values,c=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values[0],[p,v,x,b,w]=k3(a,r.shape,r.dtype,u,i.dtype,c,d);return[e.makeTensorInfo(v,r.dtype,p),e.makeTensorInfo([v[0]],i.dtype,x),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(T=>Number(T)))),e.makeTensorInfo([w.length],r.dtype,new Int32Array(w))]}};function F3(t,n,e,r,i){const s=g.util.sizeFromShape(r),o=n[0],a=i.length,u=[];let c=1,d=-1;for(let T=0;T<a;++T){const N=i[T];if(-1===N){if(-1!==d)throw new Error(g.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,T));d=T,u.push(1)}else{if(N<0)throw new Error(g.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(T,N));c*=N,u.push(N)}}if(-1!==d){if(c<=0)throw new Error(g.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const T=Math.trunc(s/c);if(c*T!==s)throw new Error(g.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(r,u));u[d]=T}if(g.util.sizeFromShape(u)!==s)throw new Error(g.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(r,u));const v=r.length,x=[];if(v>0){x[v-1]=1;for(let T=v-2;T>=0;--T)x[T]=x[T+1]*r[T+1]}const b=[];if(a>0){b[a-1]=1;for(let T=a-2;T>=0;--T)b[T]=b[T+1]*u[T+1]}const w=g.util.getArrayFromDType(e,o*a);for(let T=0;T<o;++T){let N=0;for(let S=0;S<v;++S)N+=t[T*v+S]*x[S];for(let S=0;S<a;++S)w[T*a+S]=Math.trunc(N/b[S]),N%=b[S]}return[w,[o,a],u]}const Jft={kernelName:g.SparseReshape,backendName:"cpu",kernelFunc:function qft(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:i,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(e.data.get(i.dataId).values),a=e.data.get(r.dataId).values,u=Array.from(e.data.get(s.dataId).values),[c,d,p]=F3(a,r.shape,r.dtype,o,u);return[e.makeTensorInfo(d,r.dtype,c),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}};function qI(t,n,e,r,i,s=!1,o=0){const a=r.length,u=[n[0],t.length/n[0]],c=u[1],p=a>0?i[a-1]+1:0;if(p<0)throw new Error(g.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const v=n.slice();v[0]=p;const x=v.reduce((U,J)=>U*J,1),b=g.util.getArrayFromDType(e,x);if(0===a)return p>0&&b.fill(o),[b,v];if(p<=0)throw new Error(g.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let w=0,T=1,N=0,S=i[w];for(;;){let U=0;if(T<a){if(U=i[T],S===U){++T;continue}if(S>=U)throw new Error(g.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(S<0||S>=p)throw new Error(g.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(S,p));S>N&&b.fill(o,N*c,S*c);for(let J=w;J<T;++J){const ht=r[J];if(ht<0||ht>=u[0])throw new Error(g.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(J,r[J],u[0]));for(let Tt=0;Tt<c;Tt++)b[S*c+Tt]+=t[ht*c+Tt]}if(s)for(let J=0;J<c;J++)b[S*c+J]/=T-w;if(w=T,++T,N=S+1,S=U,T>a)break}return N<p&&b.fill(o,N*c,p*c),[b,v]}const ept={kernelName:g.SparseSegmentMean,backendName:"cpu",kernelFunc:function tpt(t){const{inputs:n,backend:e}=t,{data:r,indices:i,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(s.dataId).values,[c,d]=qI(o,r.shape,r.dtype,a,u,!0);return e.makeTensorInfo(d,r.dtype,c)}},rpt={kernelName:g.SparseSegmentSum,backendName:"cpu",kernelFunc:function npt(t){const{inputs:n,backend:e}=t,{data:r,indices:i,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(i.dataId).values,u=e.data.get(s.dataId).values,[c,d]=qI(o,r.shape,r.dtype,a,u);return e.makeTensorInfo(d,r.dtype,c)}},spt={kernelName:g.SparseToDense,backendName:"cpu",kernelFunc:function ipt(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:o}=n,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:v}=g.backend_util.calculateShapes(s,i,a),x=!1,b=e.bufferSync(i);let w;switch(s.dtype){case"bool":w=Xd(b,e.bufferSync(s),a,v,d,c,u,p,!!e.data.get(o.dataId).values[0],x);break;case"float32":case"int32":w=Xd(b,e.bufferSync(s),a,v,d,c,u,p,e.data.get(o.dataId).values[0],x);break;case"string":w=Xd(b,e.bufferSync(s),a,v,d,c,u,p,g.util.decodeString(e.data.get(o.dataId).values[0]),x);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,w.dtype,w.values)}},apt={kernelName:g.SplitV,backendName:"cpu",kernelFunc:function opt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{numOrSizeSplits:s,axis:o}=r,a=g.util.parseAxisParam(o,i.shape)[0],u=g.backend_util.prepareSplitSize(i,s,a),c=new Array(i.shape.length).fill(0),d=i.shape.slice();return u.map(p=>{const v=[...d];v[a]=p;const x=Kd({inputs:{x:i},backend:e,attrs:{begin:c,size:v}});return c[a]+=p,x})}},upt=rh(t=>Math.sqrt(t)),lpt=Js(g.Sqrt,t=>Math.sqrt(t)),cpt={kernelName:g.Sqrt,backendName:"cpu",kernelFunc:lpt},hpt={kernelName:g.Square,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t,r=n;ar(e,"square");const i=r.data.get(e.dataId).values,s=new Float32Array(i.length);for(let a=0;a<i.length;++a){const u=i[a];s[a]=u*u}return{dataId:r.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},dpt=Aa((t,n)=>{const e=t-n;return e*e}),fpt=tu(g.SquaredDifference,dpt),ppt={kernelName:g.SquaredDifference,backendName:"cpu",kernelFunc:fpt},$3=rh((t,n)=>{const{pattern:e,replaceGlobal:r,rewrite:i}=n;return t.replace(new RegExp(e,r?"g":""),i)}),mpt=sd(g.StaticRegexReplace,$3),gpt={kernelName:g.StaticRegexReplace,backendName:"cpu",kernelFunc:mpt},ypt=Js(g.Step,(t,n)=>{const e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),vpt={kernelName:g.Step,backendName:"cpu",kernelFunc:ypt};function B3(t,n,e,r){const i=(0,g.buffer)(t,n.dtype);for(let s=0;s<i.size;s++){const o=i.indexToLoc(s),a=new Array(o.length);for(let u=0;u<a.length;u++)a[u]=o[u]*e[u]+r[u];i.set(n.get(...a),...o)}return i}const xpt={kernelName:g.StridedSlice,backendName:"cpu",kernelFunc:function _pt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{begin:s,end:o,strides:a,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:v}=r;ar(i,"stridedSlice");const{finalShapeSparse:x,finalShape:b,isIdentity:w,sliceDim0:T,isSimpleSlice:N,begin:S,end:U,strides:J}=g.slice_util.sliceInfo(i.shape,s,o,a,u,c,d,p,v);let ht;if(w)ht=No({inputs:{x:i},backend:e,attrs:{shape:b}});else if(T||N){g.util.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const Tt=g.slice_util.computeOutShape(S,U,J),Pt=Kd({inputs:{x:i},backend:e,attrs:{begin:S,size:Tt}});ht=No({inputs:{x:Pt},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(Pt)}else{const Pt=B3(x,e.bufferSync(i),J,S);ht=e.makeTensorInfo(b,Pt.dtype,Pt.values)}return ht}};class Ept{constructor(n,e,r,i,s,o){this.separator=g.util.encodeString(n),this.nGramWidths=e,this.leftPad=g.util.encodeString(r),this.rightPad=g.util.encodeString(i),this.padWidth=s,this.preserveShort=o}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,e){const r=this.getPadWidth(e);return Math.max(0,n+2*r-e+1)}createNGrams(n,e,r,i,s,o){for(let a=0;a<s;++a){const u=this.getPadWidth(o),c=Math.max(0,u-a),d=Math.max(0,u-(s-(a+1))),p=o-(c+d),v=e+(c>0?0:a-u);let x=0;x+=c*this.leftPad.length;for(let S=0;S<p;++S)x+=n[v+S].length;x+=d*this.rightPad.length,x+=(c+d+p-1)*this.separator.length,r[i+a]=new Uint8Array(x);const w=r[i+a];let T=0;const N=S=>S.forEach(U=>w[T++]=U);for(let S=0;S<c;++S)N(this.leftPad),N(this.separator);for(let S=0;S<p-1;++S)N(n[v+S]),N(this.separator);if(p>0){N(n[v+p-1]);for(let S=0;S<d;++S)N(this.separator),N(this.rightPad)}else{for(let S=0;S<d-1;++S)N(this.rightPad),N(this.separator);N(this.rightPad)}}}compute(n,e){const r=n.length,i=e.length;if(i>0){let u=e[0];if(0!==u)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<i;++c){let d=e[c]>=u;if(d=d&&e[c]<=r,!d)throw new Error(`Invalid split value ${e[c]}, must be in [${u}, ${r}]`);u=e[c]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const s=i-1,o=g.util.getArrayFromDType("int32",i);if(0===r||0===i){const u=new Array(r);for(let c=0;c<=s;++c)o[c]=0;return[u,o]}o[0]=0;for(let u=1;u<=s;++u){const c=e[u]-e[u-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(c,p)}),this.preserveShort&&c>0&&0===d&&(d=1),o[u]=o[u-1]+d}const a=new Array(o[s]);for(let u=0;u<s;++u){const c=e[u];let d=o[u];if(this.nGramWidths.forEach(p=>{const x=this.getNumNGrams(e[u+1]-e[u],p);this.createNGrams(n,c,a,d,x,p),d+=x}),this.preserveShort&&d===o[u]){const p=e[u+1]-e[u];if(0===p)continue;this.createNGrams(n,c,a,d,1,p+2*this.padWidth)}}return[a,o]}}function z3(t,n,e,r,i,s,o,a){return new Ept(e,r,i,s,o,a).compute(t,n)}const bpt={kernelName:g.StringNGrams,backendName:"cpu",kernelFunc:function Cpt(t){const{inputs:n,backend:e,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:d,dataSplits:p}=n,v=e.data.get(d.dataId).values,x=e.data.get(p.dataId).values,[b,w]=z3(v,x,i,s,o,a,u,c);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",w)]}};function wpt(t,n,e,r){if(!t.length)return;if(0===n.length){for(let s=0;s<t.length;++s)r.push(t.subarray(s,s+1));return}if(1===n.length){const s=n[0];let o=t.indexOf(s);for(;-1!==o;){const a=t.subarray(0,o);(!e||0!==a.length)&&r.push(a),o=(t=t.subarray(o+1)).indexOf(s)}return void((!e||0!==t.length)&&r.push(t))}let i=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==n.indexOf(t[s])){const o=t.subarray(i,s);(!e||0!==o.length)&&r.push(o),i=s+1}}function V3(t,n,e){const r=t.length,i=[];let s=0,o=0;const a=new Array(r);for(let v=0;v<r;++v){const x=i.length;wpt(t[v],n,e,i);const b=i.length-x;a[v]=b,s+=b,o=Math.max(o,b)}const u=g.util.getArrayFromDType("int32",2*s),c=new Array(s),d=[r,o];let p=0;for(let v=0;v<r;++v)for(let x=0;x<a[v];++x)u[2*p]=v,u[2*p+1]=x,c[p]=i[p],++p;return[u,c,d]}const Spt={kernelName:g.StringSplit,backendName:"cpu",kernelFunc:function Ipt(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:o}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values[0],[c,d,p]=V3(a,u,i),v=d.length;return[e.makeTensorInfo([v,2],"int32",c),e.makeTensorInfo([v],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}};function U3(t,n){const e=g.util.getArrayFromDType("int32",t.length);for(let r=0;r<t.length;++r)e[r]=g.util.fingerPrint64(t[r]).modulo(n).getLowBitsUnsigned();return e}const Tpt={kernelName:g.StringToHashBucketFast,backendName:"cpu",kernelFunc:function Dpt(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:i}=r,{input:s}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=U3(e.data.get(s.dataId).values,i);return e.makeTensorInfo(s.shape,"int32",a)}},Npt=Js(g.Tan,t=>Math.tan(t)),Apt={kernelName:g.Tan,backendName:"cpu",kernelFunc:Npt},Mpt=Js(g.Tanh,t=>Math.tanh(t));function W3(t,n){const e=new Array(t.rank);for(let i=0;i<e.length;i++)e[i]=t.shape[i]*n[i];const r=(0,g.buffer)(e,t.dtype);for(let i=0;i<r.values.length;++i){const s=r.indexToLoc(i),o=new Array(t.rank);for(let u=0;u<o.length;u++)o[u]=s[u]%t.shape[u];const a=t.locToIndex(o);r.values[i]=t.values[a]}return r}const jg=(t,n)=>{const e=n.value-t.value;return 0===e?t.index-n.index:e};function G3(t,n,e=0,r=t.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,u=n-e+1,c=Math.log(a),d=.5*Math.exp(2*c/3),p=.5*Math.sqrt(c*d*(a-d)/a)*Math.sign(u-a/2);G3(t,n,Math.max(e,Math.floor(n-u*d/a+p)),Math.min(r,Math.floor(n+(a-u)*d/a+p)))}const i=t[n];let s=e,o=r;for(g.util.swap(t,e,n),jg(t[r],i)>0&&g.util.swap(t,e,r);s<o;){for(g.util.swap(t,s,o),s++,o--;jg(t[s],i)<0;)s+=1;for(;jg(t[o],i)>0;)o-=1}0===jg(t[e],i)?g.util.swap(t,e,o):(o+=1,g.util.swap(t,o,r)),o<=n&&(e=o+1),n<=o&&(r=o-1)}}function H3(t,n,e,r,i){const s=n[n.length-1],[o,a]=[t.length/s,s],u=g.util.getTypedArrayFromDType(e,o*r),c=g.util.getTypedArrayFromDType("int32",o*r);for(let p=0;p<o;p++){const v=p*a,x=t.subarray(v,v+a);let b=new Array(x.length);x.forEach((S,U)=>b[U]={value:S,index:U}),r<b.length&&(G3(b,r),b=b.slice(0,r)),i&&b.sort(jg);const w=p*r,T=u.subarray(w,w+r),N=c.subarray(w,w+r);for(let S=0;S<r;S++)T[S]=b[S].value,N[S]=b[S].index}const d=n.slice();return d[d.length-1]=r,[(0,g.buffer)(d,e,u),(0,g.buffer)(d,"int32",c)]}function j3(t,n,e){switch(e){case"reflect":return function Vpt(t,n){let e=t;if(e<0)if(n<=1)e=0;else{const r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{const r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return g.util.clamp(0,e,n-1)}(t,n);case"wrap":return function Upt(t,n){let e=t;return e<0?n<=1?e=0:e+=n*(Math.trunc(-e/(n-1))+1):e>n-1&&(n<=1?e=0:e-=n*Math.trunc(e/(n-1))),g.util.clamp(0,e,n-1)}(t,n);case"nearest":return function Gpt(t,n){return g.util.clamp(0,t,n-1)}(t,n);default:return function Wpt(t,n){return t}(t)}}function Kg(t,n,e,r,i,s,o,a,u,c,d){return 0<=a&&a<n&&0<=u&&u<e?t[o*r+a*i+u*s+c]:d}function Hpt(t,n,e,r,i,s,o,a,u,c,d){return Kg(t,n,e,r,i,s,o,Math.round(a),Math.round(u),c,d)}function jpt(t,n,e,r,i,s,o,a,u,c,d){const p=Math.floor(a),v=Math.floor(u),x=p+1,b=v+1;return(x-a)*((b-u)*Kg(t,n,e,r,i,s,o,p,v,c,d)+(u-v)*Kg(t,n,e,r,i,s,o,p,b,c,d))+(a-p)*((b-u)*Kg(t,n,e,r,i,s,o,x,v,c,d)+(u-v)*Kg(t,n,e,r,i,s,o,x,b,c,d))}function K3(t,n,e,r){const i=g.util.parseAxisParam(n,e)[0],s=[1,e[0],1];for(let b=0;b<i;b++)s[0]*=e[b];s[1]=e[i];for(let b=i+1;b<e.length;b++)s[2]*=e[b];const o=new Map,a=new Int32Array(e[i]),u=new g.TensorBuffer(s,r,t),c=[],d=1===s[0]&&1===s[2];for(let b=0;b<e[i];b++){let w;if(d)w=t[b].toString();else{const N=[];for(let S=0;S<s[0];S++)for(let U=0;U<s[2];U++)N.push(u.get(S,b,U));w=N.join(",")}const T=o.get(w);if(null!=T)a[b]=T;else{const N=o.size;o.set(w,N),a[b]=N,c.push(b)}}const p=s.slice();p[1]=o.size;const v=new g.TensorBuffer(p,r);c.forEach((b,w)=>{for(let T=0;T<s[0];T++)for(let N=0;N<s[2];N++)v.set(u.get(T,b,N),T,w,N)});const x=e.slice();return x[i]=p[1],{outputValues:v.values,outputShape:x,indices:a}}const Jpt=[Wut,Hut,Kut,Zut,But,Qut,tlt,nlt,ilt,olt,ult,clt,dlt,mlt,ylt,xlt,Clt,wlt,Slt,Vut,Tlt,Mlt,Olt,Llt,Flt,Fut,Blt,Vlt,Lut,Wlt,Hlt,jlt,Xlt,Ylt,qlt,tct,nct,ict,oct,uct,cct,dct,pct,gct,yct,_ct,Ect,bct,wct,Ict,Sct,Tct,Oct,Sut,Lct,kct,Gct,Hct,jct,Xct,nht,rht,sht,aht,cht,dht,pht,ght,vht,xht,Cht,Dut,wht,Glt,Sht,Tht,Aht,Tut,Pht,Rht,kht,$ht,zht,Wht,Hht,Xht,Yht,qht,Jht,edt,rdt,sdt,adt,ldt,hdt,fdt,mdt,ydt,_dt,Cdt,Idt,Act,Ddt,Adt,Odt,kdt,$dt,zdt,Udt,Wdt,w3,Kdt,Aut,Zdt,rft,sft,aft,lft,kut,XI,hft,Mut,Put,zut,fft,mft,yft,_ft,Eft,Cft,wft,Sft,Tft,Oft,Lft,Bft,Rut,Vft,Wft,Hft,Nlt,bdt,Kft,Zft,Qft,Jft,ept,rpt,spt,apt,cpt,hpt,ppt,gpt,vpt,xpt,bpt,Spt,Tpt,Qct,Mct,Apt,{kernelName:g.Tanh,backendName:"cpu",kernelFunc:Mpt},{kernelName:g.TensorScatterUpdate,backendName:"cpu",kernelFunc:function Opt(t){const{inputs:n,backend:e}=t,{tensor:r,indices:i,updates:s}=n,{sliceRank:o,numUpdates:a,sliceSize:u,strides:c,outputSize:d}=g.backend_util.calculateShapes(s,i,r.shape),v=e.bufferSync(i),x=e.bufferSync(s),b=e.bufferSync(r),w=Xd(v,x,r.shape,d,u,a,o,c,b,!1);return e.makeTensorInfo(r.shape,w.dtype,w.values)}},{kernelName:g.Tile,backendName:"cpu",kernelFunc:function Lpt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{reps:s}=r;ar(i,"tile");const o=W3(e.bufferSync(i),s);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:g.TopK,backendName:"cpu",kernelFunc:function Fpt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{k:s,sorted:o}=r;ar(i,"topk");const a=e.data.get(i.dataId).values,[u,c]=H3(a,i.shape,i.dtype,s,o);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:g.Transform,backendName:"cpu",kernelFunc:function Bpt(t){const{inputs:n,attrs:e,backend:r}=t,{image:i,transforms:s}=n,{interpolation:o,fillMode:a,fillValue:u,outputShape:c}=e,[d,p,v,x]=i.shape,[b,w]=c??[p,v],T=[d,b,w,x],N=g.util.computeStrides(i.shape),S=N[0],U=N[1],J=N[2],ht=g.util.computeStrides(T),Tt=ht[0],Pt=ht[1],zt=ht[2],Ot=g.util.getTypedArrayFromDType(i.dtype,g.util.sizeFromShape(T));Ot.fill(u);const le=r.data.get(i.dataId).values,ge=r.data.get(s.dataId).values;for(let Re=0;Re<d;++Re){const ve=1===s.shape[0]?ge:ge.subarray(8*Re,8*Re+8);for(let Ne=0;Ne<b;++Ne)for(let Se=0;Se<w;++Se)for(let Ke=0;Ke<x;++Ke){let Le;const Be=ve[6]*Se+ve[7]*Ne+1;if(0===Be)continue;const rn=(ve[3]*Se+ve[4]*Ne+ve[5])/Be,pn=j3((ve[0]*Se+ve[1]*Ne+ve[2])/Be,v,a),qe=j3(rn,p,a);switch(o){case"nearest":Le=Hpt(le,p,v,S,U,J,Re,qe,pn,Ke,u);break;case"bilinear":Le=jpt(le,p,v,S,U,J,Re,qe,pn,Ke,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}Ot[Re*Tt+Ne*Pt+Se*zt+Ke]=Le}return r.makeTensorInfo(T,i.dtype,Ot)}return{dataId:r.write(Ot,T,i.dtype),shape:i.shape,dtype:i.dtype}}},qut,{kernelName:g.Unique,backendName:"cpu",kernelFunc:function Kpt(t){const{inputs:n,attrs:e,backend:r}=t,{axis:i}=e,{x:s}=n;ar(s,"unique");const o=r.data.get(s.dataId).values,{outputValues:a,outputShape:u,indices:c}=K3(o,i,s.shape,s.dtype);return[r.makeTensorInfo(u,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},{kernelName:g.Unpack,backendName:"cpu",kernelFunc:function Zpt(t){const{inputs:n,backend:e,attrs:r}=t,{value:i}=n;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i.shape.length,a=i.shape[s],u=new Array(o-1);let c=0;for(let x=0;x<o;x++)x!==s&&(u[c++]=i.shape[x]);const d=new Array(o).fill(0),p=i.shape.slice();p[s]=1;const v=new Array(a);for(let x=0;x<v.length;x++){d[s]=x;const b=Kd({inputs:{x:i},backend:e,attrs:{begin:d,size:p}});v[x]=No({inputs:{x:b},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(b)}return v}},{kernelName:g.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function Qpt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,segmentIds:s}=n,{numSegments:o}=r;ar(i,"unsortedSegmentSum");const c=[],d=[],p=i.shape.length-s.shape.length;let v=s;for(let b=0;b<p;++b){const w=J_({inputs:{input:v},backend:e,attrs:{dim:b+1}});v=w,d.push(w)}for(let b=0;b<o;++b){const w=g.util.createScalarValue(b,"int32"),T=e.makeTensorInfo([],"int32",w),N=t3({inputs:{a:T,b:v},backend:e}),S=od({inputs:{x:N},backend:e,attrs:{dtype:"float32"}}),U=q_({inputs:{a:S,b:i},backend:e}),J=Hg({inputs:{x:U},backend:e,attrs:{axis:0,keepDims:!1}});c.push(J),d.push(T),d.push(N),d.push(S),d.push(U),d.push(J)}const x=b3({inputs:c,backend:e,attrs:{axis:0}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}},Vdt];for(const t of Jpt)(0,g.registerKernel)(t);const ad={},n1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Mc(t,n){if(!(t in ad)||null!=n){const r=function nmt(t,n){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=n??function emt(t){if(!(0,g.env)().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===t)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete ad[t]},!1),(0,g.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(n1.failIfMajorPerformanceCaveat=!1),1===t?e.getContext("webgl",n1)||e.getContext("experimental-webgl",n1):e.getContext("webgl2",n1)}(t,n);if(null===r)return console.log("Could not get context for WebGL version",t),null;ad[t]=r}const e=ad[t];return null==e||e.isContextLost()?(delete ad[t],Mc(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),ad[t])}var r1=function(t){return t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",t}(r1||{}),dc=function(t){return t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD",t}(dc||{}),Ou=function(t){return t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",t}(Ou||{});function Xg(t,n){return[n,t]}function i1(t){const n=g.util.sizeFromShape(t),e=Math.ceil(n/4);return g.util.sizeToSquarishShape(e)}function Rp(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function JI(t,n){const e=t;let r,i,s,o,a,u,c,d,p,v;return 2===(0,g.env)().getNumber("WEBGL_VERSION")?(r=e.R32F,i=e.R16F,s=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,d=1,p=e.HALF_FLOAT,v=e.FLOAT,u=e.RGBA8):(r=t.RGBA,i=t.RGBA,s=t.RGBA,o=e.RGBA,a=t.RGBA,c=4,d=4,p=null!=n?n.HALF_FLOAT_OES:null,v=t.FLOAT,u=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:v}}function Bn(t,n){const e=n();return(0,g.env)().getBool("DEBUG")&&function smt(t){const n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+function lmt(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(t,n))}(t),e}function umt(t){return!!((0,g.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function s1(t,n){return Dh(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}const dmt=/ERROR: [0-9]+:([0-9]+):/g;function X3(t,n){const e=dmt.exec(n);if(null==e)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(t);const r=+e[1],i=t.split("\n"),s=i.length.toString().length+2,o=i.map((p,v)=>g.util.rightPad((v+1).toString(),s)+p);let a=0;for(let p=0;p<o.length;p++)a=Math.max(o[p].length,a);const u=o.slice(0,r-1),c=o.slice(r-1,r),d=o.slice(r);console.log(u.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${g.util.rightPad(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function tS(t,n){if(Bn(t,()=>t.validateProgram(n)),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function Z3(t,n,e,r,i,s,o){const a=t.getAttribLocation(n,e);return-1!==a&&(Bn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),Bn(t,()=>t.vertexAttribPointer(a,i,t.FLOAT,!1,s,o)),Bn(t,()=>t.enableVertexAttribArray(a)),!0)}function bmt(t,n,e,r){Bn(t,()=>function xmt(t,n,e){(function Q3(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(t,e),Bn(t,()=>t.activeTexture(t.TEXTURE0+e)),Bn(t,()=>t.bindTexture(t.TEXTURE_2D,n))}(t,n,r)),Bn(t,()=>t.uniform1i(e,r))}function eS(t,n,e){Bn(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Bn(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function Y3(t,n){Bn(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Bn(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function o1(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function wmt(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(t,n))}function Dh(t,n,e){const r=Bn(t,()=>n());if(null==r)throw new Error(e);return r}function Lp(t,n=2){return g.util.sizeFromShape(t.slice(0,t.length-n))}function kp(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function a1(t){let n=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(n=[Lp(t),...kp(t)]),n}function u1(t){return t%2==0}function l1(t,n){if(t=t.slice(-2),n=n.slice(-2),g.util.arraysEqual(t,n)||!t.length||!n.length||0===t[0]||0===t[1]||0===n[0]||0===n[1])return!0;if(t.length!==n.length){const e=t[t.length-1],r=n[n.length-1];if(e===r||u1(e)&&u1(r)&&(1===t[0]||1===n[0]))return!0}return t[1]===n[1]&&u1(t[0])&&u1(n[0])}let c1,h1;function fc(t,n){return null!=t.getExtension(n)}function q3(t){try{if(null!=Mc(t))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function nS(t){const n=JI(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(s),o}function Zg(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&g.util.assert("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}const lr=(0,g.env)();function Ku(){let t,n,e,r,i,s,o,a,u,c;return 2===(0,g.env)().getNumber("WEBGL_VERSION")?(t="#version 300 es",n="in",e="out",r="in",i="texture",s="outputColor",o="out vec4 outputColor;",a=(0,g.env)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",n="attribute",e="varying",r="varying",i="texture2D",s="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:i,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:u,defineRound:c}}function Zd(t,n,e="index"){const r=g.util.computeStrides(n);return r.map((i,s)=>`int ${t[s]} = ${e} / ${i}; ${s===r.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * ${i}`:`index -= ${t[s]} * ${i}`};`).join("")}function d1(t,n,e="index"){const r=g.util.computeStrides(n);return r.map((i,s)=>`int ${t[s]} = ${e} / outShapeStrides[${s}]; ${s===r.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * outShapeStrides[${s}]`:`index -= ${t[s]} * outShapeStrides[${s}]`};`).join("")}function rS(t){const n=g.util.computeStrides(t).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}lr.registerFlag("HAS_WEBGL",()=>lr.getNumber("WEBGL_VERSION")>0),lr.registerFlag("WEBGL_VERSION",()=>q3(2)?2:q3(1)?1:0),lr.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),lr.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===lr.get("WEBGL_VERSION")),lr.registerFlag("WEBGL_CPU_FORWARD",()=>!0),lr.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),lr.registerFlag("WEBGL_PACK",()=>lr.getBool("HAS_WEBGL")),lr.registerFlag("WEBGL_PACK_NORMALIZATION",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_CLIP",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_REDUCE",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_LAZILY_UNPACK",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_CONV_IM2COL",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>lr.getBool("WEBGL_PACK")),lr.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function Smt(t){if(null==c1){const n=Mc(t);c1=n.getParameter(n.MAX_TEXTURE_SIZE)}return c1}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function Dmt(t){if(null==h1){const n=Mc(t);h1=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,h1)}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=lr.getNumber("WEBGL_VERSION");return 0===t?0:function Tmt(t){if(0===t)return 0;let n;const e=Mc(t);return n=fc(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:fc(e,"EXT_disjoint_timer_query")?1:0,n}(t)}),lr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>lr.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!g.device_util.isMobile()),lr.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function Nmt(t){if(0===t)return!1;const n=Mc(t);if(1===t){if(!fc(n,"OES_texture_float"))return!1}else if(!fc(n,"EXT_color_buffer_float"))return!1;return nS(n)}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!lr.getBool("WEBGL_FORCE_F16_TEXTURES")&&lr.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),lr.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function Amt(t){if(0===t)return!1;const n=Mc(t);if(1!==t){if(fc(n,"EXT_color_buffer_float"))return nS(n);const r="EXT_color_buffer_half_float";if(fc(n,r)){const i=n.getExtension(r);return function Mmt(t,n){const e=JI(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),a}(n,i)}return!1}return!(!fc(n,"OES_texture_float")||!fc(n,"WEBGL_color_buffer_float"))&&nS(n)}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function Pmt(t){return 2===t&&null!=Mc(t).fenceSync}(lr.getNumber("WEBGL_VERSION"))),lr.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>lr.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),lr.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if("number"!=typeof t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),lr.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>g.device_util.isMobile()?1:-1,t=>{if("number"!=typeof t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}),lr.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),lr.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),lr.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),lr.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),lr.registerFlag("WEBGL_EXP_CONV",()=>!1),lr.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>lr.getBool("IS_TEST")),lr.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),lr.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),lr.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),lr.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const J3="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:tz}=g.backend_util;function Lmt(t,n,e){const r=[];if(t.forEach(x=>{const b=g.util.sizeFromShape(x.shapeInfo.logicalShape);if(x.shapeInfo.isUniform?r.push(`uniform float ${x.name}${b>1?`[${b}]`:""};`):(r.push(`uniform sampler2D ${x.name};`),r.push(`uniform int offset${x.name};`)),e.enableShapeUniforms){const{uniformShape:w}=sS(e.packedInputs,x.shapeInfo.logicalShape,x.shapeInfo.texShape);switch(w.length){case 1:r.push(`uniform int ${x.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${x.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${x.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${x.name}Shape;`)}r.push(`uniform ivec2 ${x.name}TexShape;`)}}),e.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(x=>{r.push(`uniform ${x.type} ${x.name}${x.arrayIndex?`[${x.arrayIndex}]`:""};`)});const i=r.join("\n"),s=t.map(x=>function kmt(t,n,e=!1,r){let i="";i+=e?ez(t,r):Fp(t,r);return t.shapeInfo.logicalShape.length<=n.logicalShape.length&&(i+=e?function mgt(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),i="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,o=n.logicalShape.length,a=tz(t.shapeInfo.logicalShape,n.logicalShape),u=ao(o),c=o-s;let d;const p=["x","y","z","w","u","v"];d=0===s?"":o<2&&a.length>=1?"coords = 0;":a.map(S=>`coords.${p[S+c]} = 0;`).join("\n");let v="";v=o<2&&s>0?"coords":t.shapeInfo.logicalShape.map((S,U)=>`coords.${p[U+c]}`).join(", ");let x="return outputValue;";const w=1===g.util.sizeFromShape(t.shapeInfo.logicalShape),N=1===g.util.sizeFromShape(n.logicalShape);if(1!==s||w||N){if(w&&!N)x=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const S=s-2,U=s-1;a.indexOf(S)>-1&&a.indexOf(U)>-1?x="return vec4(outputValue.x);":a.indexOf(S)>-1?x="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(U)>-1&&(x="return vec4(outputValue.xx, outputValue.zz);")}}else x="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${r}(${v});\n      ${x}\n    }\n  `}(t,n):function ggt(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),i="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,u=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===u&&null==t.shapeInfo.flatOffset&&g.util.arraysEqual(t.shapeInfo.texShape,n.texShape))return`\n      float ${i}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=ao(u),d=tz(t.shapeInfo.logicalShape,n.logicalShape),p=u-a;let v;const x=["x","y","z","w","u","v"];v=0===a?"":u<2&&d.length>=1?"coords = 0;":d.map(w=>`coords.${x[w+p]} = 0;`).join("\n");let b="";return b=u<2&&a>0?"coords":t.shapeInfo.logicalShape.map((w,T)=>`coords.${x[T+p]}`).join(", "),`\n    float ${i}() {\n      ${c} coords = getOutputCoords();\n      ${v}\n      return get${r}(${b});\n    }\n  `}(t,n)),i}(x,n,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=n.texShape,a=Ku(),u=function Bmt(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,d,p=function Umt(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Wmt}\n    ${Gmt}\n    ${Hmt}\n  `}(a);return n.isPacked?(c=function Fmt(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Kmt(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,e);case 2:return function egt(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(g.util.arraysEqual(t,n))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const i=Math.ceil(t[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function Zmt(t,n,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],i=Math.ceil(t[2]/2),s=i*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,n,e);default:return function Qmt(t,n,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],i=Math.ceil(t[t.length-1]/2),s=i*Math.ceil(t[t.length-2]/2);let o=s,a="",u="b, r, c";for(let c=2;c<t.length-1;c++)o*=t[t.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,u=`b${c}, `+u;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${t.length}(${u});\n    }\n  `}(t,n,e)}}(n.logicalShape,o,e.enableShapeUniforms),d=function Vmt(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(a)):(c=function $mt(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function Xmt(t,n,e){return 1===n[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,e);case 2:return function ngt(t,n,e){return g.util.arraysEqual(t,n)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===t[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function Ymt(t,n,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${d1(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`;const r=Zd(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(t,n,e);case 4:return function qmt(t,n,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${d1(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Zd(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,n,e);case 5:return function Jmt(t,n){const e=Zd(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,n);case 6:return function tgt(t,n){const e=Zd(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(n.logicalShape,o,e.enableShapeUniforms),d=function zmt(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(p+=jmt),[p,u,d,i,c,s,e.userCode].join("\n")}function Fp(t,n=!1){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function igt(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[i,s]=t.shapeInfo.texShape;if(1===i&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=Yd(e);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,u]=t.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${u}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 1:return function ogt(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${$p(t)}\n      }\n    `;const i=t.shapeInfo.texShape,s=i[0],o=i[1];if(1===o&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Yd(e);return 1===o?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===s?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:n?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 2:return function ugt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(null!=s&&g.util.arraysEqual(e,s))return n?`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=g.util.squeezeShape(e);if(o.length<e.length){const x=["row","col"];return`\n      ${Fp(Bp(t,o),n)}\n      float ${i}(int row, int col) {\n        return ${i}(${zp(x,a)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${$p(t)}\n      }\n    `;const c=s[0],d=s[1],p=Yd(r);return 1===d?n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?n?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${c}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(t,n);case 3:return function cgt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[1]*e[2],o=e[2],{newShape:a,keptDims:u}=g.util.squeezeShape(e);if(a.length<e.length){const T=["row","col","depth"];return`\n        ${Fp(Bp(t,a),n)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${zp(T,u)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${$p(t)}\n      }\n    `;const d=t.shapeInfo.texShape,p=d[0],v=d[1],x=t.shapeInfo.flatOffset;if(v===s&&null==x)return n?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${v}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(v===o&&null==x)return n?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${v}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const b=Yd(r);return n?`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${b};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${b};\n        vec2 uv = uvFromFlat(${p}, ${v}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(t,n);case 4:return function dgt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[3],o=e[2]*s,a=e[1]*o,{newShape:u,keptDims:c}=g.util.squeezeShape(e);if(u.length<e.length){const U=["row","col","depth","depth2"];return`\n      ${Fp(Bp(t,u),n)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${zp(U,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${s}, 1)));\n        ${$p(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,v=p[0],x=p[1],b=`int stride2 = ${r}Shape[3];`,w=`int stride1 = ${r}Shape[2] * stride2;`,T=`int stride0 = ${r}Shape[1] * stride1;`;if(x===a&&null==d)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${b}\n        ${w}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(x===s&&null==d)return n?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const N=Yd(r);return n?`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${b}\n      ${w}\n      ${T}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${N});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${v}, ${x}, index + ${N});\n      return sampleTexture(${r}, uv);\n    }\n  `}(t,n);case 5:return function fgt(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=n[4],s=n[3]*i,o=n[2]*s,a=n[1]*o,{newShape:u,keptDims:c}=g.util.squeezeShape(n);if(u.length<n.length){const T=["row","col","depth","depth2","depth3"];return`\n      ${Fp(Bp(t,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${zp(T,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${s}, ${i})) +\n          depth3;\n        ${$p(t)}\n      }\n    `;const d=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,v=p[0],x=p[1];if(x===a&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${v}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(x===i&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${v}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${s} +\n          depth2 * ${i} + depth3 + ${Yd(e)};\n      vec2 uv = uvFromFlat(${v}, ${x}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 6:return function pgt(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:i,keptDims:s}=g.util.squeezeShape(n);if(i.length<n.length){const N=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Fp(Bp(t,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${zp(N,s)});\n      }\n    `}const o=n[5],a=n[4]*o,u=n[3]*a,c=n[2]*u,d=n[1]*c;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${u}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${$p(t)}\n      }\n    `;const p=t.shapeInfo.flatOffset,v=t.shapeInfo.texShape,x=v[0],b=v[1];if(b===d&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${u}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${b}.0, ${x}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(b===o&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${b}.0, ${x}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${u} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${Yd(e)};\n      vec2 uv = uvFromFlat(${x}, ${b}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function ez(t,n){switch(t.shapeInfo.logicalShape.length){case 0:return function rgt(t){const n=t.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${Ku().texture2D}(${n}, halfCR);\n    }\n  `}(t);case 1:return function sgt(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=t.shapeInfo.texShape,s=Ku();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(t,n);case 2:return function agt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=s[0],a=s[1],u=Ku();if(null!=s&&g.util.arraysEqual(e,s))return n?`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(n)return`\n    vec4 ${i}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(t,n);case 3:return function lgt(t,n){const e=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===e[0]){const x=[1,2],w=["b","row","col"];return`\n        ${ez(Bp(t,e.slice(1)),n)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${zp(w,x)});\n        }\n      `}const a=Ku();if(n)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const u=o[0],c=o[1],d=Math.ceil(e[2]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${c}, ${d*Math.ceil(e[1]/2)}, ${d}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(t,n);default:return function hgt(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),i=Ku();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${e}, uv);\n    }\n  `;const s=t.shapeInfo.logicalShape,o=s.length,a=t.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=u[0],d=u[1],p=Math.ceil(s[o-1]/2);let v=p*Math.ceil(s[o-2]/2),x="int b, int row, int col",b=`b * ${v} + (row / 2) * ${p} + (col / 2)`;for(let w=2;w<o-1;w++)x=`int b${w}, `+x,v*=s[o-w-1],b=`b${w} * ${v} + `+b;return`\n    vec4 ${r}(${x}) {\n      int index = ${b};\n      int texR = index / ${d};\n      int texC = index - texR * ${d};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(t,n)}}const Wmt="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Gmt="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Hmt="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",jmt="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Yd(t){return`offset${t}`}function $p(t){const n=t.name,e=g.util.sizeFromShape(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function ao(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function sS(t,n,e){const{newShape:r,keptDims:i}=g.util.squeezeShape(n),s=n.length,o=t&&3===s&&1===n[0],a=o?n.slice(1):r,u=!t&&s>1&&!g.util.arraysEqual(n,e)&&r.length<s||o;return{useSqueezeShape:u,uniformShape:u?a:n,keptDims:i}}function Bp(t,n){const e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function zp(t,n){return n.map(e=>t[e]).join(", ")}function rz(t,n,e){const r=[],i=[];let s,o,a,u=null,c=null;c=t.getUniformLocation(e,"NAN",!1),1===(0,g.env)().getNumber("WEBGL_VERSION")&&(u=t.getUniformLocation(e,"INFINITY",!1));const d=!1;for(const p of n.variableNames){const v={name:p,uniform:t.getUniformLocation(e,p,d),offset:t.getUniformLocation(e,`offset${p}`,d)};n.enableShapeUniforms&&(v.shape=t.getUniformLocation(e,`${p}Shape`,d),v.texShape=t.getUniformLocation(e,`${p}TexShape`,d)),r.push(v)}if(n.enableShapeUniforms&&(s=t.getUniformLocation(e,"outShape",d),a=t.getUniformLocation(e,"outShapeStrides",d),o=t.getUniformLocation(e,"outTexShape",d)),n.customUniforms)for(const p of n.customUniforms)i.push(t.getUniformLocation(e,p.name,d));return{variablesLocations:r,customUniformLocations:i,infLoc:u,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:o}}function iz(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{const i=e.logicalShape,s=n[r],o=s.shape;if(!g.util.arraysEqual(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(e.isUniform&&s.isUniform)return;const a=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!g.util.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function Ru(t){return(0,g.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class xgt{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=r1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ku();this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?d1(["r","c","d"],n):Zd(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Egt{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=r1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ku();this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?d1(["r","c","d"],n):Zd(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Cgt{constructor(n){this.variableNames=["A"],this.outTexUsage=dc.DOWNLOAD;const e=Ku();this.outputShape=n,this.userCode=`\n      ${J3}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class bgt{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=dc.DOWNLOAD;const e=Ku();this.outputShape=n,this.userCode=`\n      ${J3}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const wgt={R:0,G:1,B:2,A:3};class sz{constructor(n,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Ku();this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++)o+=`\n          if(offset == ${a}) {\n            result = values[${wgt[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":rS(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${i.texture2D}(A, uv);\n          ${o}\n        }\n        ${i.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class Igt{constructor(n,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ku();this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length);let i="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const u=2*o+a;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${u}] = values[0];\n            } else if (offset == 1) {\n              result[${u}] = values[1];\n            } else if (offset == 2) {\n              result[${u}] = values[2];\n            } else {\n              result[${u}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":rS(n)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${i}\n\n          ${r.output} = ${s};\n        }\n    `}}function Yg(t,n,e,r,i,s){!function vmt(t,n){const e=(0,g.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0)throw new Error(`Requested texture size [${t}x${n}] is invalid.`);if(t>e||n>e)throw new Error(`Requested texture size [${t}x${n}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(n,e);const o=function ymt(t){return Dh(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return Bn(t,()=>t.bindTexture(a,o)),Bn(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Bn(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Bn(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Bn(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),1===(0,g.env)().getNumber("WEBGL_VERSION")?Bn(t,()=>t.texImage2D(a,0,r,n,e,0,i,s,null)):Bn(t,()=>t.texStorage2D(a,1,r,n,e)),Bn(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:o,texShape:[e,n]}}function oz(t){return t.internalFormatFloat}function az(t){return t.internalFormatHalfFloat}function uz(t){return t.downloadTextureFormat}function lz(t){return t.internalFormatPackedFloat}function cz(t){return t.internalFormatPackedHalfFloat}class oS{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=(0,g.env)().getNumber("WEBGL_VERSION");if(null!=n?(this.gl=n,function tmt(t,n){ad[t]=n}(e,n)):this.gl=Mc(e),n=this.gl,2===(0,g.env)().getNumber("WEBGL_VERSION")){const s=n;this.createVertexArray=()=>Bn(s,()=>s.createVertexArray()),this.bindVertexArray=o=>Bn(s,()=>s.bindVertexArray(o)),this.deleteVertexArray=o=>Bn(s,()=>s.deleteVertexArray(o)),this.getVertexArray=()=>Bn(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(null!=n){const s=n.getExtension("OES_vertex_array_object");if(null==s)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Bn(n,()=>s.createVertexArrayOES()),this.bindVertexArray=o=>Bn(n,()=>s.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Bn(n,()=>s.deleteVertexArrayOES(o)),this.getVertexArray=()=>Bn(n,()=>n.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,g.env)().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=s1(this.gl,"OES_texture_float"),fc(this.gl,o))this.textureHalfFloatExtension=s1(this.gl,o);else if((0,g.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),fc(this.gl,i))this.colorBufferHalfFloatExtension=s1(this.gl,i);else if((0,g.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",fc(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!fc(this.gl,i))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(i)}this.vertexBuffer=function Dgt(t){return function mmt(t,n){const e=Dh(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Bn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),Bn(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function Tgt(t){return function gmt(t,n){const e=Dh(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Bn(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),Bn(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function _mt(t){return Dh(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=JI(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,g.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;Bn(n,()=>n.finish()),Bn(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Bn(n,()=>n.deleteFramebuffer(this.framebuffer)),Bn(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),Bn(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),Bn(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),function Ngt(t,n,e,r){const[i,s]=Xg(n,e);return Yg(t,i,s,oz(r),r.textureFormatFloat,t.FLOAT)}(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),function Agt(t,n,e,r){const[i,s]=Xg(n,e);return Yg(t,i,s,az(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),function Mgt(t,n,e,r){const[i,s]=Xg(n,e);return Yg(t,i,s,uz(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),function kgt(t,n,e){Bn(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?2===(0,g.env)().getNumber("WEBGL_VERSION")?Bn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)):Bn(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):2===(0,g.env)().getNumber("WEBGL_VERSION")?Bn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)):Bn(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),Bn(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,i){this.throwIfDisposed(),function Lgt(t,n,e,r,i,s){let o,a,u;Bn(t,()=>t.bindTexture(t.TEXTURE_2D,n)),i instanceof Uint8Array?(o=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,u=t.RGBA):(o=new Float32Array(e*r*4),a=t.FLOAT,u=s.internalFormatPackedFloat),o.set(i),2===(0,g.env)().getNumber("WEBGL_VERSION")?Bn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,r,t.RGBA,a,o)):Bn(t,()=>t.texImage2D(t.TEXTURE_2D,0,u,e,r,0,t.RGBA,a,o)),Bn(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e,r,i,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),function Ogt(t,n,e,r){const[i,s]=Rp(n,e);return Yg(t,i,s,cz(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),function Pgt(t,n,e,r){const[i,s]=Rp(n,e);return Yg(t,i,s,lz(r),t.RGBA,t.FLOAT)}(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(Y3(this.gl,this.framebuffer),this.outputTexture=null),Bn(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function Bgt(t,n,e,r){const[i,s]=Xg(n,e),a=new Uint8Array(function rmt(t,n){return t*n}(n*e,4));return Bn(t,()=>t.readPixels(0,0,i,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,i,s,o){return function zgt(t,n,e,r,i,s,o,a){const u=t,c=new Float32Array(function imt(t,n){const[e,r]=Rp(t,n);return e*r*4}(s,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,n),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}(this.gl,n,0,0,0,s,o)}downloadFloat32MatrixFromBuffer(n,e){return function $gt(t,n,e){const r=t,i=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);const i=function Fgt(t,n,e,r){const i=t.createBuffer();Bn(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,i));const a=16*n*e;return Bn(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Bn(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),Bn(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),i}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if((0,g.env)().getBool("WEBGL_FENCE_API_ENABLED")){const i=n,s=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const o=i.clientWaitSync(s,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},e=s}else(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function Vgt(t,n,e){const r=new Float32Array(n*e*4);return Bn(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}(this.gl,e,r))}createProgram(n){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function Sgt(t){const n=Ku();return function cmt(t,n){const e=Dh(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Bn(t,()=>t.shaderSource(e,n)),Bn(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(t,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function fmt(t){return Dh(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);Bn(e,()=>e.attachShader(r,this.vertexShader)),Bn(e,()=>e.attachShader(r,n)),function pmt(t,n){if(Bn(t,()=>t.linkProgram(n)),!(0,g.env)().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(e,r);const i=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&tS(e,i),i}buildVao(n){this.setProgram(n),this.bindVertexArray(n.vao);const e=this.gl;Bn(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function Rgt(t,n,e){Bn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),Z3(t,n,"clipSpacePos",e,3,20,0)&&Z3(t,n,"uv",e,2,20,12)}(e,n,this.vertexBuffer)}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&(Bn(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&this.debug&&tS(this.gl,this.program),Bn(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?function Emt(t,n,e){return Dh(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}(this.gl,n,e):function Cmt(t,n,e){return t.getUniformLocation(n,e)}(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),Bn(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),bmt(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();const[i,s]=Rp(e,r);this.setOutputMatrixTextureDriver(n,i,s)}setOutputMatrixWriteRegion(n,e,r,i){this.setOutputMatrixWriteRegionDriver(r,n,i,e)}setOutputPackedMatrixWriteRegion(n,e,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&tS(this.gl,this.program),o1(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Bn(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Bn(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=s1(this.gl,2===(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(i.TIME_ELAPSED_EXT,s),s}const n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var e=this;return(0,Mr.Z)(function*(){return yield g.util.repeatedTry(()=>e.disposed||e.isQueryAvailable(n,(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(n,(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(0===e)return!0;if(2===e){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),i=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){const n=function Ugt(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in(0,g.env)().platform&&(r=(0,g.env)().platform.setTimeoutCustom.bind((0,g.env)().platform)),g.util.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),eS(this.gl,n,this.framebuffer),this.debug&&o1(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(eS(this.gl,this.outputTexture,this.framebuffer),this.debug&&o1(this.gl)):Y3(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();const i=this.gl;eS(i,n,this.framebuffer),this.debug&&o1(i),this.outputTexture=n,Bn(i,()=>i.viewport(0,0,e,r)),Bn(i,()=>i.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,i){this.throwIfDisposed(),Bn(this.gl,()=>this.gl.scissor(n,e,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:Wgt,bincountImpl:hz,bincountReduceImpl:Ggt,bitwiseAndImpl:Hgt,castImpl:jgt,ceilImpl:Kgt,concatImpl:Xgt,equalImpl:Zgt,expImpl:Ygt,expm1Impl:Qgt,floorImpl:qgt,gatherNdImpl:Jgt,gatherV2Impl:tyt,greaterImpl:eyt,greaterEqualImpl:nyt,lessImpl:ryt,lessEqualImpl:iyt,linSpaceImpl:syt,logImpl:oyt,maxImpl:ayt,maximumImpl:uyt,minimumImpl:lyt,multiplyImpl:cyt,negImpl:hyt,notEqualImpl:dyt,prodImpl:fyt,raggedGatherImpl:pyt,raggedRangeImpl:myt,raggedTensorToTensorImpl:gyt,rangeImpl:yyt,rsqrtImpl:vyt,scatterImpl:_yt,sigmoidImpl:xyt,simpleAbsImpl:dz,sliceImpl:Eyt,sparseFillEmptyRowsImpl:Cyt,sparseReshapeImpl:byt,sparseSegmentReductionImpl:fz,sqrtImpl:wyt,staticRegexReplaceImpl:Iyt,stridedSliceImpl:Syt,stringNGramsImpl:Dyt,stringSplitImpl:Tyt,stringToHashBucketFastImpl:Nyt,subImpl:Ayt,tileImpl:Myt,topKImpl:Pyt,transposeImpl:aS,uniqueImpl:Oyt}=$;function pz(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function Xu(t,n){return 1===n?[t]:pz(t,n)}class Lyt{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=Ru(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Xu("rc",this.rank),r=ao(this.rank),i=this.getOutOfBoundsCondition(e),s=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${i}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(n){const e=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let s=`${0===r?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let o=2;o<this.rank;o++)s=`${n[n.length-1-o]},`+s;e.push(s)}return e}getOutOfBoundsCondition(n){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(n){if(1===this.rank)return"";const e=n.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(n){const e=this.getSourceCoordsArr(n);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class mz{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length);let r="";for(let i=0;i<4;i++){let s="thisRC = rc;";i%2==1&&(s+="thisRC.z += 1;"),i>1&&(s+="thisRC.y += 1;"),r+=`\n        ${s}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}this.userCode=`\n      ${function kyt(t,n){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n?function Rmt(t,n,e="index"){const i=function Omt(t,n){const e=t.length,r=t.map(s=>`${n}[${s}]`),i=new Array(e-1);i[e-2]=r[e-1];for(let s=e-3;s>=0;--s)i[s]=`(${i[s+1]} * ${r[s+1]})`;return i}(t.map((s,o)=>o),n);return i.map((s,o)=>`int ${t[o]} = ${e} / ${i[o]}; ${o===i.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${i[o]}`:`index -= ${t[o]} * ${i[o]}`};`).join("")}(["r","c","d"],"inputShape"):Zd(["r","c","d"],t)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":rS(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Fyt{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(n,e,r){const i=yz(e,r),s=vz(n,i,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=gz(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const u=this.freeTextures[s].pop();return this.usedTextures[s].push(u),u}let a;return i===Ou.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):i===Ou.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):i===Ou.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):i===Ou.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):i===Ou.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(n,e,r,i){if(null==this.freeTextures)return;const s=yz(r,i),o=vz(e,s,i);o in this.freeTextures||(this.freeTextures[o]=[]);const a=gz(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,i),u=(0,g.env)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],d=c&&c.indexOf(n);if(null==d||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function gz(t,n,e,r,i){const s=function Byt(t,n){switch(t){case Ou.PACKED_2X2_FLOAT32:return lz(n);case Ou.PACKED_2X2_FLOAT16:return cz(n);case Ou.UNPACKED_FLOAT32:return oz(n);case Ou.UNPACKED_FLOAT16:return az(n);case Ou.PACKED_4X1_UNSIGNED_BYTE:return uz(n);default:throw new Error(`Unknown physical texture type ${t}`)}}(n,r);let o;if(i){const[u,c]=Rp(t[0],t[1]);o=u*c}else{const[u,c]=Xg(t[0],t[1]);o=u*c}const a=function $yt(t,n){if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===t.RGBA16F)return 8;if(n===t.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}(e,s);return o*a}function yz(t,n){if(t===dc.UPLOAD)return Ou.PACKED_2X2_FLOAT32;if(t===dc.RENDER||null==t)return function zyt(t){return(0,g.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Ou.PACKED_2X2_FLOAT32:Ou.UNPACKED_FLOAT32:t?Ou.PACKED_2X2_FLOAT16:Ou.UNPACKED_FLOAT16}(n);if(t===dc.DOWNLOAD||t===dc.PIXELS)return Ou.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function vz(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}class sh{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Ul="if (isnan(x)) return x;",Vyt="return x;",_z="return abs(x);",Uyt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Wyt=Ul+"\n  return (x < 0.0) ? 0.0 : x;\n",Gyt=Ul+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",ud="return x;",Hyt="return 1.0 / (1.0 + exp(-1.0 * x));",jyt="return x;",Kyt="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Xyt="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Zyt="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Yyt="return 1.0 / (1.0 + exp(-1.0 * x));";class ld{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Qyt{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length);const e=n.length,r=Xu("rc",e),i=ao(e),s=function Ryt(t,n){if(1===t)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}(e,r),o=r.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${i} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const qyt=g.kernel_impls.whereImpl,p1={},n0t=(0,g.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let s0t=(()=>{class t extends g.KernelBackend{nextDataId(){return t.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,g.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof oS)r=e;else{const i=Mc((0,g.env)().getNumber("WEBGL_VERSION"),e);r=new oS(i)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const i=Mc((0,g.env)().getNumber("WEBGL_VERSION"));r=new oS(i),this.binaryCache=function e0t(t){return t in p1||(p1[t]={}),p1[t]}((0,g.env)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Fyt(this.gpgpu),this.numMBBeforeWarning=function i0t(){return null==(0,g.env)().global.screen?1024:(0,g.env)().global.screen.height*(0,g.env)().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new g.DataStorage(this,(0,g.engine)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,i,s,o,a){const u=this.makeTensorInfo(r,i),c=this.texData.get(u.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[s,o]},c.texShape=[s,o];const d=a1(r),p=new sz(d,!1,a),v=this.runWebGLProgram(p,[u],i,[[s,o]]);return v.shape=r,c.texture=null,this.disposeIntermediateTensorInfo(u),v.dataId}write(e,r,i){if(((0,g.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,g.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===i&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:i,values:e,usage:dc.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,i,s,o){if((0,g.env)().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:i,dtype:s,values:r,usage:dc.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:i,dtype:s,complexTensorInfos:o,slice:a,shape:u,isPacked:c}=r;if(null!=a){let x;x=c?new ld(u,ud):new sh(u,ud);const b=this.runWebGLProgram(x,[{dataId:e,shape:u,dtype:s}],s),w=this.readSync(b.dataId);return this.disposeIntermediateTensorInfo(b),w}if(null!=i)return this.convertAndCacheOnCPU(e);if("string"===s)return i;const d=null!=this.activeTimers;let p,v;if(d&&(p=g.util.now()),"complex64"===s){const x=this.readSync(o.real.dataId),b=this.readSync(o.imag.dataId);v=g.backend_util.mergeRealAndImagArrays(x,b)}else v=this.getValuesFromTexture(e);return d&&(this.downloadWaitMs+=g.util.now()-p),this.convertAndCacheOnCPU(e,v)}read(e){var r=this;return(0,Mr.Z)(function*(){if(r.pendingRead.has(e)){const T=r.pendingRead.get(e);return new Promise(N=>T.push(N))}const i=r.texData.get(e),{values:s,shape:o,slice:a,dtype:u,complexTensorInfos:c,isPacked:d}=i;if(null!=a){let T;T=d?new ld(o,ud):new sh(o,ud);const N=r.runWebGLProgram(T,[{dataId:e,shape:o,dtype:u}],u),S=r.read(N.dataId);return r.disposeIntermediateTensorInfo(N),S}if(null!=s)return r.convertAndCacheOnCPU(e);if((0,g.env)().getBool("DEBUG")&&!(0,g.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,g.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let v,x,p=null;if("complex64"!==u&&(0,g.env)().get("WEBGL_BUFFER_SUPPORTED")){v=r.decode(e);const T=r.texData.get(v.dataId);p=r.gpgpu.createBufferFromTexture(T.texture.texture,...i1(o))}if(r.pendingRead.set(e,[]),"complex64"!==u&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===u){const T=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);x=g.backend_util.mergeRealAndImagArrays(T[0],T[1])}else if(null==p)x=r.getValuesFromTexture(e);else{const T=g.util.sizeFromShape(o);x=r.gpgpu.downloadFloat32MatrixFromBuffer(p,T)}if(null!=v&&r.disposeIntermediateTensorInfo(v),null!=p){const T=r.gpgpu.gl;Bn(T,()=>T.deleteBuffer(p))}const b=r.convertAndCacheOnCPU(e,x),w=r.pendingRead.get(e);return r.pendingRead.delete(e),w.forEach(T=>T(b)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&(0,g.engine)().removeDataId(e,r),r.pendingDeletes--),b})()}readToGPU(e,r={}){const i=this.texData.get(e),{values:s,shape:o,slice:a,dtype:u,isPacked:c,texture:d}=i;if("complex64"===u)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let b;b=c?new ld(o,ud):new sh(o,ud);const w=this.runWebGLProgram(b,[{dataId:e,shape:o,dtype:u}],u),T=this.readToGPU(w,r);return this.disposeIntermediateTensorInfo(w),T}if(null==d)throw null!=s?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const p=this.decode(e,r.customTexShape),v=(0,g.engine)().makeTensorFromTensorInfo(p),x=this.texData.get(p.dataId);return Object.assign({tensorRef:v},x.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const i=r.map(s=>g.util.decodeString(s));return(0,g.buffer)(e.shape,e.dtype,i)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,g.buffer)(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const i=e[r];if(!umt(i))throw(0,g.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${i} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${i} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:i,isPacked:s}=this.texData.get(e),o=g.util.sizeFromShape(r);if((0,g.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const x=this.decode(e),b=this.texData.get(x.dataId),w=this.gpgpu.downloadMatrixFromPackedTexture(b.texture.texture,...i1(r)).subarray(0,o);return this.disposeIntermediateTensorInfo(x),w}const a=(0,g.env)().getBool("WEBGL_PACK")&&!0===s,u=a?a1(r):r,c=a?new bgt(u):new Cgt(u),d=this.runWebGLProgram(c,[{shape:u,dtype:i,dataId:e}],"float32"),p=this.texData.get(d.dataId),v=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(d),v}timerAvailable(){return(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const i=this.activeTimers,s=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=s,o=!0):this.activeTimers.push(s),this.activeTimers=s,e();const a=g.util.flatten(this.activeTimers.map(d=>d.query)).filter(d=>null!=d),u=g.util.flatten(this.activeTimers.map(d=>d.name)).filter(d=>null!=d);this.activeTimers=i,o&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(0,Mr.Z)(function*(){if((0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const d=yield Promise.all(a);c.kernelMs=g.util.sum(d),c.getExtraProfileInfo=()=>d.map((p,v)=>({name:u[v],ms:p})).map(p=>`${p.name}: ${p.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:g.util.now(),endMs:null}}endTimer(e){return(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=g.util.now(),e)}getQueryTime(e){var r=this;return(0,Mr.Z)(function*(){return(0,g.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:i}=this.texData.get(e);return null!=i&&(this.disposeData(i.real.dataId,r),this.disposeData(i.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:i,texShape:s,usage:o,isPacked:a,slice:u}=this.texData.get(e),c=u&&u.origDataId||e,d=this.dataRefCount.get(c);d>1?this.dataRefCount.set(c,d-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(s,i),this.textureManager.releaseTexture(r,s,o,a)));const p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=n0t){return(0,g.env)().getBool("WEBGL_CPU_FORWARD")&&e.every(i=>null==this.texData.get(i.dataId).texture&&g.util.sizeFromShape(i.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){g.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return qyt(e.shape,r)}packedUnaryOp(e,r,i){const s=new ld(e.shape,r),o=this.compileAndRun(s,[e],i);return(0,g.engine)().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const s=dz(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if((0,g.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,_z,e.dtype);const r=new sh(e.shape,_z),i=this.compileAndRun(r,[e]);return(0,g.engine)().makeTensorFromTensorInfo(i)}makeTensorInfo(e,r,i){let s;if("string"===r&&null!=i&&i.length>0&&g.util.isString(i[0])){const o=i.map(a=>g.util.encodeString(a));s=this.write(o,e,r)}else s=this.write(i,e,r);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:r}}makeOutput(e,r,i){return(0,g.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,i),this)}unpackTensor(e){const r=new Qyt(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new Lyt(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const i=[Lp(e.shape),...kp(e.shape)],s={dtype:e.dtype,shape:i,dataId:e.dataId},o=[Lp(r),...kp(r)],a=new mz(o,i),d=this.runWebGLProgram(a,[s],e.dtype,[i],!0);return{dataId:d.dataId,shape:r,dtype:d.dtype}}decode(e,r){const i=this.texData.get(e),{isPacked:s,shape:o,dtype:a}=i;if(null!=r){const x=g.util.sizeFromShape(o);g.util.assert(x<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const u=a1(o);let c;c=s?new Egt(u):new xgt(u);const p=[r??i1(u)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(c,[{shape:u,dtype:a,dataId:e}],a,p,!0,r).dataId}}runWebGLProgram(e,r,i,s,o=!1,a){const u=this.makeTensorInfo(e.outputShape,i),c=this.texData.get(u.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===r1.DENSE){const S=a??i1(e.outputShape);c.texShape=S.map(U=>2*U)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===g.util.sizeFromShape(u.shape))return c.values=g.util.getTypedArrayFromDType(u.dtype,0),u;const d=[],p=r.map(S=>{if("complex64"===S.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let U=this.texData.get(S.dataId);if(null==U.texture){if(!e.packedInputs&&g.util.sizeFromShape(S.shape)<=(0,g.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:U.values};e.packedInputs&&(U.isPacked=!0,U.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!U.isPacked!=!!e.packedInputs)S=U.isPacked?this.unpackTensor(S):this.packTensor(S),d.push(S),U=this.texData.get(S.dataId);else if(U.isPacked&&!l1(U.shape,S.shape)){const J=S,ht=S.shape;S.shape=U.shape,S=this.packedReshape(S,ht),d.push(S),U=this.texData.get(S.dataId),J.shape=ht}return{shape:S.shape,texData:U,isUniform:!1}});this.uploadToGPU(u.dataId);const v={shape:u.shape,texData:c,isUniform:!1},x=function _gt(t,n,e){let r="";n.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!o.isUniform){const u=o.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:p}=sS(t.packedInputs,o.shape,u);let v="",x="",b="";if(1===d.length&&t.packedInputs){const ht=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];v=`${ht[0]>1}_${ht[1]>1}`}else if(2!==d.length||t.packedInputs){if(d.length>2&&!t.packedInputs){const ht=g.util.computeStrides(d);b=`${ht[0]===u[1]}_${ht[ht.length-1]===u[1]}`}}else x=`${d[0]>1}_${d[1]>1}`;const w=o.shape.length,T=2===d.length&&g.util.arraysEqual(o.shape,u),N=1===g.util.sizeFromShape(o.shape),S=g.backend_util.getBroadcastDims(o.shape,e.shape),U=!t.packedInputs&&w===e.shape.length&&g.util.arraysEqual(u,e.texData.texShape);r+=`${w}_${U}_${c?p:""}_${d.length}_${N}_${S}_${T}_${v}_${x}_${b}_${t.packedInputs||d.length>2?"":`${u[0]>1}_${u[1]>1}`}_${a}`}else r+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let s=t.constructor.name;return s+="_"+r+"_"+t.userCode+`${(0,g.env)().getNumber("WEBGL_VERSION")}`,s}(e,p,v),b=this.getAndSaveBinary(x,()=>function ygt(t,n,e,r){const i=e.map((d,p)=>{const v={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:!d.isUniform&&d.texData.isPacked,flatOffset:null};return null!=d.texData&&null!=d.texData.slice&&d.texData.slice.flatOffset>0&&(v.flatOffset=d.texData.slice.flatOffset),{name:n.variableNames[p],shapeInfo:v}}),s=i.map(d=>d.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=Lmt(i,o,n),u=function hmt(t,n){const e=Dh(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Bn(t,()=>t.shaderSource(e,n)),Bn(t,()=>t.compileShader(e)),(0,g.env)().get("ENGINE_COMPILE_ONLY"))return e;if(!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw X3(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(t.gl,a),c=t.createProgram(u);return(0,g.env)().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:n,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},rz(t,n,c)))}(this.gpgpu,e,p,v)),w=null!=this.activeTimers;let T;w&&(T=this.startTimer()),(0,g.env)().get("ENGINE_COMPILE_ONLY")||function vgt(t,n,e,r,i){n.program.enableShapeUniforms||(iz(n.inShapeInfos,e),iz([n.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):t.setOutputMatrixTexture(s.texture,o[0],o[1]),t.setProgram(n.webGLProgram),t.bindVertexArray(n.webGLProgram.vao),1===(0,g.env)().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&t.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&t.gl.uniform1f(n.nanLoc,NaN);for(let u=0;u<e.length;++u){const c=e[u],{uniform:d,offset:p,shape:v,texShape:x}=n.variablesLocations[u];if(v){const{uniformShape:b}=sS(n.program.packedInputs,c.shape,c.texData.texShape);switch(b.length){case 1:t.gl.uniform1iv(v,new Int32Array(b));break;case 2:t.gl.uniform2iv(v,new Int32Array(b));break;case 3:t.gl.uniform3iv(v,new Int32Array(b));break;case 4:t.gl.uniform4iv(v,new Int32Array(b))}}if(x&&t.gl.uniform2i(x,c.texData.texShape[0],c.texData.texShape[1]),null!=d){if(c.isUniform){if(g.util.sizeFromShape(c.shape)<2)t.gl.uniform1f(d,c.uniformValues[0]);else{let b=c.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),t.gl.uniform1fv(d,b)}continue}null!=c.texData.slice&&null!=p&&t.gl.uniform1i(p,c.texData.slice.flatOffset),t.setInputMatrixTexture(c.texData.texture.texture,d,u)}}const a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape))}if(n.outShapeStridesLocation){const u=g.util.computeStrides(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(u));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(u));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(u))}}if(n.outTexShapeLocation&&t.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&i)for(let u=0;u<n.program.customUniforms.length;++u){const c=n.program.customUniforms[u],d=n.customUniformLocations[u],p=i[u];if("float"===c.type)t.gl.uniform1fv(d,p);else if("vec2"===c.type)t.gl.uniform2fv(d,p);else if("vec3"===c.type)t.gl.uniform3fv(d,p);else if("vec4"===c.type)t.gl.uniform4fv(d,p);else if("int"===c.type)t.gl.uniform1iv(d,p);else if("ivec2"===c.type)t.gl.uniform2iv(d,p);else if("ivec3"===c.type)t.gl.uniform3iv(d,p);else{if("ivec4"!==c.type)throw Error(`uniform type ${c.type} is not supported yet.`);t.gl.uniform4iv(d,p)}}t.executeProgram()}(this.gpgpu,b,p,v,s),d.forEach(S=>this.disposeIntermediateTensorInfo(S)),w&&(T=this.endTimer(T),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(T)}));const N=(0,g.env)().getNumber("WEBGL_FLUSH_THRESHOLD");if(N>0){const S=g.util.now();S-this.lastGlFlushTime>N&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!(0,g.env)().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===o){const S=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),S}return u}compileAndRun(e,r,i,s,o=!1){return this.runWebGLProgram(e,r,i=i||r[0].dtype,s,o)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,g.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,g.tidy)(()=>{if(!(0,g.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,g.env)().getBool("DEBUG");(0,g.env)().set("DEBUG",!1);const r=this.abs((0,g.scalar)(1e-8)).dataSync()[0];if((0,g.env)().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:i,dtype:s,values:o,texture:a,usage:u,isPacked:c}=r;if(null!=a)return;const d=null!=this.activeTimers;let p;d&&(p=g.util.now());let v=r.texShape;if(null==v&&(v=function Imt(t,n=!1){let e=(0,g.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=(0,g.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&(0,g.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),n&&(e*=2,r*=2,1===(t=t.map((a,u)=>u>=t.length-2?g.util.nearestLargerEven(t[u]):t[u])).length&&(t=[2,t[0]])),2!==t.length&&(t=g.util.squeezeShape(t).newShape);let i=g.util.sizeFromShape(t),s=null;t.length<=1&&i<=e?s=[1,i]:2===t.length&&t[0]<=e&&t[1]<=e?s=t:3===t.length&&t[0]*t[1]<=e&&t[2]<=e?s=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=e&&t[1]*t[2]<=e?s=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=e&&t[3]<=e?s=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=e&&t[1]*t[2]*t[3]<=e&&(s=[t[0],t[1]*t[2]*t[3]]);const o=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(n?2:1)&&Math.min(...s)>0;if(null==s||o)if(n){const a=Lp(t);let u=2,c=2;t.length&&([u,c]=kp(t)),i=a*(u/2)*(c/2),s=g.util.sizeToSquarishShape(i).map(d=>2*d)}else s=g.util.sizeToSquarishShape(i);return s}(i,c),r.texShape=v),null!=o){const x=a1(i);let b,w=v[1],T=v[0];const N=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!N)&&([w,T]=Rp(v[0],v[1])),b=c?new Igt(x,N):new sz(x,N);const S=N?[T,w]:v,U=this.makeTensorInfo(S,s),J=this.texData.get(U.dataId);J.usage=N?dc.PIXELS:dc.UPLOAD,J.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(U.dataId),w,T,o);const Pt=this.runWebGLProgram(b,[U],s,[[T,w]],!0),zt=this.texData.get(Pt.dataId);r.texShape=zt.texShape,r.isPacked=zt.isPacked,r.usage=zt.usage,(0,g.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(Pt.dataId):(r.texture=zt.texture,r.values=null,this.texData.delete(Pt.dataId)),this.disposeIntermediateTensorInfo(U),d&&(this.uploadWaitMs+=g.util.now()-p)}else{const x=this.acquireTexture(v,u,s,c);r.texture=x}}convertAndCacheOnCPU(e,r){const i=this.texData.get(e),{dtype:s}=i;return null!=r&&(i.values=function o0t(t,n){if("float32"===n||"complex64"===n)return t;if("int32"===n||"bool"===n){const e="int32"===n?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}throw new Error(`Unknown dtype ${n}`)}(r,s)),i.values}acquireTexture(e,r,i,s){if(this.numBytesInGPU+=this.computeBytes(e,i),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,s)}computeBytes(e,r){return e[0]*e[1]*g.util.bytesPerElement(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return(0,Mr.Z)(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,i]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(i));return Promise.all(r)}for(const[,i]of Object.entries(e.binaryCache)){const s=new Promise(o=>{try{e.checkCompletion_(i),o(!0)}catch(a){throw a}});r.push(s)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return(0,Mr.Z)(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield(0,g.nextFrame)(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(X3(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:r,customUniformLocations:i,infLoc:s,nanLoc:o,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:c}=rz(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=i,e.infLoc=s,e.nanLoc=o,e.outShapeLocation=a,e.outShapeStridesLocation=u,e.outTexShapeLocation=c}}createTensorFromGPUData(e,r,i){e.channels=e.channels||"RGBA";const{texture:s,height:o,width:a,channels:u}=e,c=(0,g.engine)().backend;if(!c.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const d=c.writeTexture(s,r,i,o,a,u);return(0,g.engine)().makeTensorFromDataId(d,r,i,c)}}return t.nextDataId=0,t})();g.device_util.isBrowser()&&(0,g.registerBackend)("webgl",()=>new s0t,2);const uS="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class Qd{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=g.backend_util.assertAndGetBroadcastShape(e,r),this.enableShapeUniforms=Ru(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const qd="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Vp{constructor(n,e,r,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=g.backend_util.assertAndGetBroadcastShape(e,r);const s=this.outputShape.length;this.enableShapeUniforms=Ru(s);let o="";if(i)if(0===s||1===g.util.sizeFromShape(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${ao(s)} coords = getOutputCoords();\n        `,1===s)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const u=Xu("coords",s);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${u[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${u[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${n}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function bl(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const l0t={kernelName:g.Identity,backendName:"webgl",kernelFunc:bl};function cd(t){const{inputs:n,backend:e}=t,{real:r,imag:i}=n,s=e.makeTensorInfo(r.shape,"complex64"),o=e.texData.get(s.dataId),a=bl({inputs:{x:r},backend:e}),u=bl({inputs:{x:i},backend:e});return o.complexTensorInfos={real:a,imag:u},s}const c0t={kernelName:g.Complex,backendName:"webgl",kernelFunc:cd},xz="return (a < 0.) ? b * a : a;",Ez="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",d0t={kernelName:g.LeakyRelu,backendName:"webgl",kernelFunc:function h0t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{alpha:s}=r,o=e.makeTensorInfo([],"float32",g.util.createScalarValue(s,"float32")),a=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vp(Ez,i.shape,o.shape):new Qd(xz,i.shape,o.shape),u=e.runWebGLProgram(a,[i,o],"float32");return e.disposeIntermediateTensorInfo(o),u}},Cz="return (a < 0.) ? b * a : a;",bz="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",p0t={kernelName:g.Prelu,backendName:"webgl",kernelFunc:function f0t(t){const{inputs:n,backend:e}=t,{x:r,alpha:i}=n,s=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vp(bz,r.shape,i.shape):new Qd(Cz,r.shape,i.shape);return e.runWebGLProgram(s,[r,i],"float32")}},Up="if (isnan(x)) return x;";function ms({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:i,backend:s})=>{const{x:o}=i,a=s,u=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const p=a.texData.get(o.dataId),v=e(p.values,u);return a.makeTensorInfo(o.shape,u,v)}let d;return d=(0,g.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new ld(o.shape,n):new sh(o.shape,t),a.runWebGLProgram(d,[o],u)}}function Eu({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:o,backend:a})=>{const{a:u,b:c}=o,d=a;if(r&&"complex64"===u.dtype){const b=d.texData.get(u.dataId),w=d.texData.get(c.dataId),[T,N]=[[b.complexTensorInfos.real,w.complexTensorInfos.real],[b.complexTensorInfos.imag,w.complexTensorInfos.imag]].map(U=>{const[J,ht]=U,Tt={dataId:J.dataId,dtype:J.dtype,shape:u.shape},Pt={dataId:ht.dataId,dtype:ht.dtype,shape:c.shape},zt=new Qd(t,u.shape,c.shape);return d.runWebGLProgram(zt,[Tt,Pt],(0,g.upcastType)(J.dtype,ht.dtype))}),S=cd({inputs:{real:T,imag:N},backend:d});return d.disposeIntermediateTensorInfo(T),d.disposeIntermediateTensorInfo(N),S}const p=s||(0,g.upcastType)(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=i){const b=d.texData.get(u.dataId).values,w=d.texData.get(c.dataId).values,T="string"===u.dtype?g.backend_util.fromUint8ToStringArray(b):b,N="string"===u.dtype?g.backend_util.fromUint8ToStringArray(w):w,[S,U]=i(u.shape,c.shape,T,N,p),J=d.makeTensorInfo(U,p);return d.texData.get(J.dataId).values=S,J}let x;return x=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Vp(n,u.shape,c.shape,e):new Qd(t,u.shape,c.shape),d.runWebGLProgram(x,[u,c],p)}}function Qg(t,n=!1){if("linear"===t)return n?jyt:Vyt;if("relu"===t)return n?Xyt:Wyt;if("elu"===t)return n?Kyt:Uyt;if("relu6"===t)return n?Zyt:Gyt;if("prelu"===t)return n?bz:Cz;if("leakyrelu"===t)return n?Ez:xz;if("sigmoid"===t)return n?Yyt:Hyt;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class wz{constructor(n,e,r,i=!1,s=!1,o=!1,a=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Ru(this.outputShape.length);const p=Math.ceil((i?n[1]:n[2])/2),v=i?"i * 2, rc.y":"rc.y, i * 2",x=s?"rc.z, i * 2":"i * 2, rc.z",b=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],w=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let T="",N="";a&&(T=u?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,N="result = activation(result);");const S=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let U="rc.x",J="rc.x";n[0]<e[0]?U=`imod(rc.x, ${n[0]})`:e[0]<n[0]&&(J=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${T}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${p}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${U};\n        int batchB = ${J};\n        for (int i = 0; i < ${p}; i++) {\n          vec4 a = getMatrixA(batchA, ${v});\n          vec4 b = getMatrixB(batchB, ${x});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${b[0]} * ${w[0]});\n          result += (${b[1]} * ${w[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${S}\n\n        ${N}\n\n        setOutput(result);\n      }\n    `}}const Iz={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Sz{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=g.backend_util.assertAndGetBroadcastShape(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${n}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Dz="return a * b;";function lS(t){const{inputs:n,backend:e}=t,{a:r,b:i}=n,s=g.backend_util.upcastType(r.dtype,i.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),u=e.texData.get(i.dataId),c=new Sz(Iz.REAL,r.shape,i.shape),d=new Sz(Iz.IMAG,r.shape,i.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:i.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:i.shape}],v=e.runWebGLProgram(c,p,"float32"),x=e.runWebGLProgram(d,p,"float32"),b=cd({inputs:{real:v,imag:x},backend:e});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),b}if(e.shouldExecuteOnCPU([r,i])){const a=e.texData.get(r.dataId),u=e.texData.get(i.dataId),[c,d]=cyt(r.shape,i.shape,a.values,u.values,s),p=e.makeTensorInfo(d,s);return e.texData.get(p.dataId).values=c,p}let o;return o=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vp(Dz,r.shape,i.shape):new Qd(Dz,r.shape,i.shape),e.runWebGLProgram(o,[r,i],s)}const m0t={kernelName:g.Multiply,backendName:"webgl",kernelFunc:lS};function Ln(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{shape:s}=r,o=e,a=g.util.sizeFromShape(i.shape),u=g.util.inferFromImplicitShape(s,a),c=g.util.sizeFromShape(u);g.util.assert(a===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(i.dataId);return!d.isPacked||l1(i.shape,u)||null!==d.texture&&l1(d.shape,u)?(o.incRef(i.dataId),{dataId:i.dataId,shape:u,dtype:i.dtype}):function g0t(t,n,e){const r=[Lp(t.shape),...kp(t.shape)],i={dtype:t.dtype,shape:r,dataId:t.dataId},s=[Lp(n),...kp(n)],o=new mz(s,r),c=e.runWebGLProgram(o,[i],t.dtype,[r],!0);return{dataId:c.dataId,shape:n,dtype:c.dtype}}(i,u,o)}const y0t={kernelName:g.Reshape,backendName:"webgl",kernelFunc:Ln};class Tz{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:o}=n;this.outputShape=[i,o];const a=4*Math.floor(r/4),u=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const p=1/e;c=`sumValue += dot(values * ${g.util.isInt(p)?p.toPrecision(2):p}, ones);`}let d="";s%r>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class v0t{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:o}=n;this.outputShape=[i,o];let a="0.0",u="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",u="min"):"max"===e&&(a="-1.0 / 1e-20",u="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const d=4*Math.floor(r/4),p=r%4;let v=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${u}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${u}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,x="vec4";"all"===e?(a="1.0",v="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",x="bvec4"):"any"===e&&(a="0.0",v="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",x="bvec4");let b="";s%r>0&&(b=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${b}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${v}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===p}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${v}\n        } else if (${2===p}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${v}\n        } else if (${3===p}) {\n          ${x} values = ${x}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${v}\n        }\n        setOutput(${c});\n      }\n    `}}function Jd(t,n,e,r){const i=function _0t(t){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const e=n.length?n[n.length-1].outSize:t[1],r=g.backend_util.computeOptimalWindowSize(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}(t.shape);let s=t;for(let o=0;o<i.length;o++){const{inSize:a,windowSize:u,outSize:c}=i[o];let d,p;d="mean"===e?0===o?new Tz({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c},a):new Tz({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c}):new v0t({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c},e),p=s,s=r.runWebGLProgram(d,[s],n),p.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(p)}return s}class x0t{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let o=0;o<r.length;o++)r[o]=n[e[o]];this.outputShape=r,this.rank=r.length;const i=ao(this.rank),s=function E0t(t){const n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let i=0;i<t.length;i++)r[t[i]]=e[i];return r.join()}(e);this.userCode=`\n    void main() {\n      ${i} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class C0t{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(n.length);for(let d=0;d<r.length;d++)r[d]=n[e[d]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=ao(this.rank),s=pz("rc",this.rank),o=new Array(this.rank);for(let d=0;d<e.length;d++)o[e[d]]=s[d];const a=`vec2(${o.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${u}) {\n        result[1] = ${c};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${u}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function m1(t,n,e){const r=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new C0t(t.shape,n):new x0t(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function g1(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r;return function b0t(t,n,e,r){const s=t.shape.length,o=g.util.parseAxisParam(n,t.shape);let a=o;const u=g.backend_util.getAxesPermutation(a,s),c=null!=u;let d=t;c&&(d=m1(t,u,r),a=g.backend_util.getInnerMostAxes(a.length,s)),g.backend_util.assertAxesAreInnerMostDims("sum",a,s);const[p,v]=g.backend_util.computeOutAndReduceShapes(d.shape,a);let x=p;e&&(x=g.backend_util.expandShapeToKeepDim(p,o));const b=g.util.sizeFromShape(v),N=Ln({inputs:{x:d},attrs:{shape:[g.util.sizeFromShape(t.shape)/b,b]},backend:r}),U=Jd(N,(0,g.sumOutType)(t.dtype),"sum",r),J=Ln({inputs:{x:U},attrs:{shape:x},backend:r});return r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(U),c&&r.disposeIntermediateTensorInfo(d),J}(i,s,o,e)}const w0t={kernelName:g.Sum,backendName:"webgl",kernelFunc:g1};function Zu(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{perm:s}=r,o=e,u=new Array(i.shape.length);for(let d=0;d<u.length;d++)u[d]=i.shape[s[d]];let c;if(o.shouldExecuteOnCPU([i])){const p=o.texData.get(i.dataId).values,v=aS(p,i.shape,i.dtype,s,u);c=o.makeTensorInfo(u,i.dtype),o.texData.get(c.dataId).values=v}else c=m1(i,s,o);return c}const I0t={kernelName:g.Transpose,backendName:"webgl",kernelFunc:Zu},Nz=1e3;function y1({a:t,b:n,transposeA:e,transposeB:r,backend:i,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:u=null}){const c=t.shape.length,d=n.shape.length,p=e?t.shape[c-2]:t.shape[c-1],v=r?n.shape[d-1]:n.shape[d-2],x=e?t.shape[c-1]:t.shape[c-2],b=r?n.shape[d-2]:n.shape[d-1],w=t.shape.slice(0,-2),T=n.shape.slice(0,-2),N=g.util.sizeFromShape(w),S=g.util.sizeFromShape(T),J=g.broadcast_util.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([x,b]);g.util.assert(p===v,()=>`Error in matMul: inner shapes (${p}) and (${v}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);const ht=e?[N,p,x]:[N,x,p],Tt=r?[S,b,v]:[S,v,b],Pt=Ln({inputs:{x:t},backend:i,attrs:{shape:ht}}),zt=Ln({inputs:{x:n},backend:i,attrs:{shape:Tt}}),Ot=[Pt,zt],le=Math.max(N,S),ge=e?Pt.shape[1]:Pt.shape[2],Ae=null!=s,Re=null!=o,ve="leakyrelu"===u,Ne=null!=u?Qg(u,!0):null;let Ke;if((1===x||1===b)&&ge>Nz&&!1===(Ae||Re||ve||null!=Ne)){let Be=Pt,on=zt;e&&(Be=Zu({inputs:{x:Pt},backend:i,attrs:{perm:[0,2,1]}}),Ot.push(Be)),r&&(on=Zu({inputs:{x:zt},backend:i,attrs:{perm:[0,2,1]}}),Ot.push(on));const pn=1===b;let qe=Be;1!==b&&(qe=Ln({inputs:{x:Be},backend:i,attrs:{shape:[le,ge,1]}}),Ot.push(qe));const gn=1===b?2:1;let dn=on;pn&&(dn=Ln({inputs:{x:on},backend:i,attrs:{shape:[le,1,ge]}}),Ot.push(dn));const kn=lS({inputs:{a:qe,b:dn},backend:i});Ke=g1({inputs:{x:kn},backend:i,attrs:{axis:gn,keepDims:!0}}),Ot.push(kn)}else{const Be=(0,g.upcastType)(t.dtype,n.dtype),on=new wz(ht,Tt,[le,x,b],e,r,Ae,Ne,Re,ve),rn=[Pt,zt];if(null!=s&&rn.push(s),Re&&rn.push(o),ve){const pn=i.makeTensorInfo([],"float32",g.util.createScalarValue(a,"float32"));rn.push(pn),Ot.push(pn)}Ke=i.runWebGLProgram(on,rn,Be)}const Le=Ln({inputs:{x:Ke},backend:i,attrs:{shape:J}});Ot.push(Ke);for(const Be of Ot)i.disposeIntermediateTensorInfo(Be);return Le}const D0t={kernelName:g._FusedMatMul,backendName:"webgl",kernelFunc:function S0t(t){const{inputs:n,backend:e,attrs:r}=t,{a:i,b:s,bias:o,preluActivationWeights:a}=n,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=r;return y1({a:i,b:s,transposeA:u,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:p,activation:d})}},Az="return abs(x);",N0t={kernelName:g.Abs,backendName:"webgl",kernelFunc:function T0t(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const s=e.texData.get(r.dataId),o=dz(s.values);return e.makeTensorInfo(r.shape,r.dtype,o)}let i;return i=(0,g.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new ld(r.shape,Az):new sh(r.shape,Az),e.runWebGLProgram(i,[r],r.dtype)}},M0t=ms({opSnippet:Ul+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),P0t={kernelName:g.Acos,backendName:"webgl",kernelFunc:M0t},R0t=ms({opSnippet:Ul+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),L0t={kernelName:g.Acosh,backendName:"webgl",kernelFunc:R0t},Mz="return a + b;",k0t=Eu({opSnippet:Mz,packedOpSnippet:Mz,supportsComplex:!0,cpuKernelImpl:Wgt}),F0t={kernelName:g.Add,backendName:"webgl",kernelFunc:k0t};class $0t{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${i};\n        setOutput(result);\n      }\n    `}}class B0t{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${i};\n        setOutput(result);\n      }\n    `}}const z0t={kernelName:g.AddN,backendName:"webgl",kernelFunc:function v1(t){const{inputs:n,backend:e}=t,r=n;if(1===r.length)return bl({inputs:{x:r[0]},backend:e});if(r.length>(0,g.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),c=v1({inputs:r.slice(0,u),backend:e}),d=v1({inputs:r.slice(u),backend:e});return v1({inputs:[c,d],backend:e})}const i=r.map(u=>u.dtype).reduce((u,c)=>(0,g.upcastType)(u,c)),s=r.map(u=>u.shape),a=(0,g.env)().getBool("WEBGL_PACK")?new B0t(r[0].shape,s):new $0t(r[0].shape,s);return e.runWebGLProgram(a,r,i)}},U0t={kernelName:g.All,backendName:"webgl",kernelFunc:function V0t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=i.shape.length,u=g.util.parseAxisParam(s,i.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a);let p=i;null!=d&&(p=Zu({inputs:{x:i},backend:e,attrs:{perm:d}}),c=g.backend_util.getInnerMostAxes(c.length,a)),g.backend_util.assertAxesAreInnerMostDims("all",c,a);const[v,x]=g.backend_util.computeOutAndReduceShapes(p.shape,c),w=Ln({inputs:{x:p},backend:e,attrs:{shape:[-1,g.util.sizeFromShape(x)]}}),T=Jd(w,w.dtype,"all",e);let N;return N=Ln(o?{inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(v,u)}}:{inputs:{x:T},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),null!=d&&e.disposeIntermediateTensorInfo(p),N}},G0t={kernelName:g.Any,backendName:"webgl",kernelFunc:function W0t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=i.shape.length,u=g.util.parseAxisParam(s,i.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a);let p=i;null!=d&&(p=Zu({inputs:{x:i},backend:e,attrs:{perm:d}}),c=g.backend_util.getInnerMostAxes(c.length,a)),g.backend_util.assertAxesAreInnerMostDims("any",c,a);const[v,x]=g.backend_util.computeOutAndReduceShapes(p.shape,c),w=Ln({inputs:{x:p},backend:e,attrs:{shape:[-1,g.util.sizeFromShape(x)]}}),T=Jd(w,w.dtype,"any",e);let N;return N=Ln(o?{inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(v,u)}}:{inputs:{x:T},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),null!=d&&e.disposeIntermediateTensorInfo(p),N}};class H0t{constructor(n,e,r){this.variableNames=["A"];const{windowSize:i,batchSize:s,outSize:o}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class j0t{constructor(n,e,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,g.util.assert(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(n[n.length-1]/e);this.outputShape=n.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,c=ao(u),d=Xu("coords",u);let p,v;if(1===o){v=u+1;const zt=ao(v);p=`\n        ${zt} sourceLocR = ${zt}(${d.join()}, 0);\n        ++${d[u-1]};\n        ${zt} sourceLocG = ${zt}(${d.join()}, 0);\n        ++${d[u-2]};\n        ${zt} sourceLocA = ${zt}(${d.join()}, 0);\n        --${d[u-1]};\n        ${zt} sourceLocB = ${zt}(${d.join()}, 0);\n        --${d[u-2]};`}else v=u,p=`\n        ${c} sourceLocR = coords;\n        ++${d[u-1]};\n        ${c} sourceLocG = coords;\n        ++${d[u-2]};\n        ${c} sourceLocA = coords;\n        --${d[u-1]};\n        ${c} sourceLocB = coords;\n        --${d[u-2]};`;const x=["x","y","z","w","u","v"].slice(0,v),b="."+x[v-1],w=x.map(zt=>"int "+zt),T=Xu("sourceLocR",v-1).concat("inIdx.r"),N=Xu("sourceLocG",v-1).concat("inIdx.g"),S=Xu("sourceLocB",v-1).concat("inIdx.b"),U=Xu("sourceLocA",v-1).concat("inIdx.a"),J="max"===r?"greaterThan":"lessThan",ht=i?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${T.join()}),\n                             getBestIndicesAChannel(${N.join()}),\n                             getBestIndicesAChannel(${S.join()}),\n                             getBestIndicesAChannel(${U.join()})));`,Tt=`vec4(\n            getAChannel(${T.join()}),\n            hasNextCol ? getAChannel(${N.join()}) : 0.,\n            hasNextRow ? getAChannel(${S.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${U.join()}) : 0.)`,Pt=i?"":`\n      float getBestIndicesAChannel(${w.join()}) {\n        return getChannel(getBestIndicesA(${x.join()}),\n                                          vec2(${x.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${w.join()}) {\n        return getChannel(getA(${x.join()}),\n                               vec2(${x.slice(-2).join()}));\n      }\n      ${Pt}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${d[u-1]} < ${a[u-1]-1};\n        bool hasNextRow = ${d[u-2]} < ${a[u-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},\n          sourceLocB${b}, sourceLocA${b}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${Tt};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${ht}\n          vec4 candidate = ${Tt};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${J}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Pz(t,n,e,r=null){let i=n.shape[0],s=n.shape[1];null!=r&&(i=r.shape[0],s=r.shape[1]);const o=g.backend_util.computeOptimalWindowSize(s),a={windowSize:o,inSize:s,batchSize:i,outSize:Math.ceil(s/o)},u=new H0t(a,e,null==r),c=[n];null!=r&&c.push(r);const d=t.runWebGLProgram(u,c,"int32");if(1===d.shape[1])return d;const p=Pz(t,n,e,d);return t.disposeIntermediateTensorInfo(d),p}function Oz(t,n,e,r=null){const i=null!=r?r.shape:n.shape,o=g.backend_util.computeOptimalWindowSize(i[i.length-1]),a=new j0t(i,o,e,null==r),c=t.runWebGLProgram(a,null==r?[n]:[n,r],"int32");if(c.shape.length===n.shape.length){const d=Oz(t,n,e,c);return t.disposeIntermediateTensorInfo(c),d}return c}function Rz(t,n,e,r){const i=[e];if(g.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,n.shape.length),!(0,g.env)().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const s=[],o=t.texData.get(n.dataId);let u=n;null!==o&&o.isPacked&&(u=t.unpackTensor(n),s.push(u));const[c,d]=g.backend_util.computeOutAndReduceShapes(u.shape,i),p=g.util.sizeFromShape(d),v=Ln({inputs:{x:u},backend:t,attrs:{shape:[-1,p]}});s.push(v);const x=Pz(t,v,r);s.push(x);const b=Ln({inputs:{x},backend:t,attrs:{shape:c}});return s.forEach(w=>t.disposeIntermediateTensorInfo(w)),b}return Oz(t,n,r)}const X0t={kernelName:g.ArgMax,backendName:"webgl",kernelFunc:function K0t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s}=r;let o=g.util.parseAxisParam(s,i.shape);const a=g.backend_util.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=a&&(u=Zu({inputs:{x:i},backend:e,attrs:{perm:a}}),c.push(u),o=g.backend_util.getInnerMostAxes(o.length,u.shape.length)),g.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);const d=Rz(e,u,o[0],"max");return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}},Y0t={kernelName:g.ArgMin,backendName:"webgl",kernelFunc:function Z0t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s}=r;let o=g.util.parseAxisParam(s,i.shape);const a=g.backend_util.getAxesPermutation(o,i.shape.length);let u=i;const c=[];null!=a&&(u=Zu({inputs:{x:i},backend:e,attrs:{perm:a}}),c.push(u),o=g.backend_util.getInnerMostAxes(o.length,u.shape.length)),g.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);const d=Rz(e,u,o[0],"min");return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}},q0t=ms({opSnippet:Ul+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),J0t={kernelName:g.Asin,backendName:"webgl",kernelFunc:q0t},evt=ms({opSnippet:Ul+"return log(x + sqrt(x * x + 1.0));"}),nvt={kernelName:g.Asinh,backendName:"webgl",kernelFunc:evt},ivt=ms({opSnippet:Ul+"\n  return atan(x);\n"}),svt={kernelName:g.Atan,backendName:"webgl",kernelFunc:ivt},uvt=Eu({opSnippet:uS+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+qd+"\n  return result;\n"}),lvt={kernelName:g.Atan2,backendName:"webgl",kernelFunc:uvt},hvt=ms({opSnippet:Ul+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),dvt={kernelName:g.Atanh,backendName:"webgl",kernelFunc:hvt};class qg{constructor(n,e,r,i=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=n.filterWidth,a=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,d=n.dilationWidth,p=n.effectiveFilterHeight,v=n.effectiveFilterWidth,x=n.padInfo.top,b=n.padInfo.left;this.outputShape=n.outShape;const w="avg"===e;let S="0.0";if(w||(S="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${u});\n        const ivec2 pads = ivec2(${x}, ${b});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${p};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v};\n                wC += ${d}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?s?`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`:`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`:`wR * ${v} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let J=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(J="avgValue / max(count, 1.0)");const ht=4*Math.floor(o/4),Tt=o%4,Pt=`\n      if (${w}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${u});\n      const ivec2 pads = ivec2(${x}, ${b});\n      const float initializationValue = ${S};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${S});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${ht}; wC += 4) {\n            int xC = xCCorner + wC * ${d};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              getValue(batch, xR, xC + 2 * ${d}, d),\n              getValue(batch, xR, xC + 3 * ${d}, d)\n            );\n\n            ${Pt}\n          }\n\n          int xC = xCCorner + ${ht};\n          if (${1===Tt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${Pt}\n          } else if (${2===Tt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${Pt}\n          } else if (${3===Tt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              getValue(batch, xR, xC + 2 * ${d}, d),\n              initializationValue\n            );\n\n            ${Pt}\n          }\n        }\n        setOutput(${J});\n      }\n    `}}class cS{constructor(n,e,r,i=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=n.filterWidth,a=n.strideDepth,u=n.strideHeight,c=n.strideWidth,d=n.dilationDepth,p=n.dilationHeight,v=n.dilationWidth,x=n.effectiveFilterDepth,b=n.effectiveFilterHeight,w=n.effectiveFilterWidth,T=n.padInfo.front,N=n.padInfo.top,S=n.padInfo.left;this.outputShape=n.outShape;const U="avg"===e;let J="0.0";if(U||(J="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${u}, ${c});\n        const ivec3 pads = ivec3(${T}, ${N}, ${S});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${x};\n              wD += ${d}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${b};\n                wR += ${p}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${w};\n                  wC += ${v}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?s?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${b} * ${w} +\n                      wR * ${w} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let Tt=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(Tt="avgValue / max(count, 1.0)");const Pt=4*Math.floor(o/4),zt=o%4,Ot=`\n      if (${U}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${u}, ${c});\n      const ivec3 pads = ivec3(${T}, ${N}, ${S});\n      const float initializationValue = ${J};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${J});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${x};\n            wD += ${d}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${b};\n            wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${Pt}; wC += 4) {\n              int xC = xCCorner + wC * ${v};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${v}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${v}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${v}, ch)\n              );\n\n              ${Ot}\n            }\n\n            int xC = xCCorner + ${Pt};\n            if (${1===zt}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${Ot}\n            } else if (${2===zt}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${v}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${Ot}\n            } else if (${3===zt}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${v}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${v}, ch),\n                initializationValue\n              );\n\n              ${Ot}\n            }\n          }\n        }\n        setOutput(${Tt});\n      }\n    `}}const pvt={kernelName:g.AvgPool,backendName:"webgl",kernelFunc:function fvt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;Zg(i,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=g.backend_util.computePool2DInfo(i.shape,s,o,1,a,u);if(1===d.filterWidth&&1===d.filterHeight&&g.util.arraysEqual(d.inShape,d.outShape))return bl({inputs:{x:i},backend:e});const p=new qg(d,"avg",!1);return e.runWebGLProgram(p,[i],"float32")}},gvt={kernelName:g.AvgPool3D,backendName:"webgl",kernelFunc:function mvt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{filterSize:s,strides:o,pad:a,dimRoundingMode:u,dataFormat:c}=r,p=g.backend_util.computePool3DInfo(i.shape,s,o,[1,1,1],a,u,c),v=new cS(p,"avg",!1);return e.runWebGLProgram(v,[i],"float32")}};class yvt{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const u=n.effectiveFilterHeight,c=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${u-1-n.padInfo.top}, ${c-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${u};\n            wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${n.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vvt{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const p=n.effectiveFilterDepth,v=n.effectiveFilterHeight,x=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${p-1-n.padInfo.front}, ${v-1-n.padInfo.top}, ${x-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterDepth*n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${v};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${x};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const xvt={kernelName:g.AvgPool3DGrad,backendName:"webgl",kernelFunc:function _vt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,o=s,{filterSize:a,strides:u,pad:c,dimRoundingMode:d}=r,v=g.backend_util.computePool3DInfo(o.shape,a,u,[1,1,1],c,d),x=new vvt(v);return e.runWebGLProgram(x,[i],o.dtype)}},Cvt={kernelName:g.AvgPoolGrad,backendName:"webgl",kernelFunc:function Evt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,o=s;Zg([i,s],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,d=g.backend_util.computePool2DInfo(o.shape,a,u,1,c),p=new yvt(d);return e.runWebGLProgram(p,[i],o.dtype)}},wvt={kernelName:g.BatchMatMul,backendName:"webgl",kernelFunc:function bvt(t){const{inputs:n,backend:e,attrs:r}=t,{a:i,b:s}=n,{transposeA:o,transposeB:a}=r;return y1({a:i,b:s,transposeA:o,transposeB:a,backend:e})}};class Ivt{constructor(n,e,r,i,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],g.backend_util.assertAndGetBroadcastShape(n,e),g.backend_util.assertAndGetBroadcastShape(n,r);let a="0.0";null!=i&&(g.backend_util.assertAndGetBroadcastShape(n,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";null!=s&&(g.backend_util.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Svt{constructor(n,e,r,i,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],g.backend_util.assertAndGetBroadcastShape(n,e),g.backend_util.assertAndGetBroadcastShape(n,r);let a="vec4(0.0)";null!=i&&(g.backend_util.assertAndGetBroadcastShape(n,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=s&&(g.backend_util.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Tvt={kernelName:g.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,mean:i,variance:s,offset:o,scale:a}=t;g.util.assert(i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),g.util.assert(null==o||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),g.util.assert(null==a||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;null==u&&(u=.001);const c=[r,i,s];let d=null;null!=o&&(d=o.shape,c.push(o));let p=null;null!=a&&(p=a.shape,c.push(a));const v=(0,g.env)().getBool("WEBGL_PACK_NORMALIZATION")?new Svt(r.shape,i.shape,s.shape,d,p,u):new Ivt(r.shape,i.shape,s.shape,d,p,u);return n.runWebGLProgram(v,c,c[0].dtype)}};class Nvt{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const e=ao(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function Avt(t){if(1===t)return"sourceLoc";if(t<=6)return hS.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let i;i=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${n.map((o,a)=>`sourceLoc.${hS[a]} = start[${a}] + coords.${hS[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${i}\n        setOutput(getSource(${r}));\n      }\n    `}}const hS=["x","y","z","w","u","v"];class Mvt{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=ao(this.rank),r=Xu("coords",this.rank),i=Xu("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${s})`,a=`\n      result.x = ${o};\n      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${i[this.rank-1]};\n        result.y = ${o};\n        --${i[this.rank-1]};\n      }\n    `,u=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${i[this.rank-2]};\n        result.z = ${o};\n        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${i[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${n.map((d,p)=>`start[${p}]`).join()});`:n.map((d,p)=>`${i[p]} = ${r[p]} + start[${p}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${u}\n        setOutput(result);\n      }\n    `}}function Wp(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{begin:s,size:o}=r,[a,u]=g.slice_util.parseSliceParams(i,s,o);if(g.slice_util.assertParamsValid(i,a,u),0===g.util.sizeFromShape(u))return e.makeTensorInfo(u,i.dtype,[]);if(e.shouldExecuteOnCPU([i])||"string"===i.dtype){const p=e.texData.get(i.dataId),v=Eyt(p.values,a,u,i.shape,i.dtype);return e.makeTensorInfo(u,i.dtype,v)}const{isPacked:c}=e.texData.get(i.dataId),d=g.slice_util.isSliceContinous(i.shape,a,u);if(c||!d){const p=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mvt(u):new Nvt(u);return e.runWebGLProgram(p,[i],i.dtype,[a])}return e.uploadToGPU(i.dataId),function Pvt(t,n,e,r){const i=r.texData.get(t.dataId),s=r.makeTensorInfo(e,t.dtype),o=r.texData.get(s.dataId);Object.assign(o,i),o.refCount=1,o.shape=e,o.dtype=t.dtype;let a=g.slice_util.computeFlatOffset(n,g.util.computeStrides(t.shape));i.slice&&(a+=i.slice.flatOffset),o.slice={flatOffset:a,origDataId:i.slice&&i.slice.origDataId||t.dataId};const u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),s}(i,a,u,e)}const Ovt={kernelName:g.Slice,backendName:"webgl",kernelFunc:Wp},Lvt={kernelName:g.BatchToSpaceND,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockShape:s,crops:o}=r;g.util.assert(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((S,U)=>S*U),u=g.backend_util.getReshaped(i.shape,s,a),c=g.backend_util.getPermuted(u.length,s.length),d=g.backend_util.getReshapedPermuted(i.shape,s,a),p=g.backend_util.getSliceBeginCoords(o,s.length),v=g.backend_util.getSliceSize(d,o,s.length),x=[],b=Ln({inputs:{x:i},backend:e,attrs:{shape:u}}),w=Zu({inputs:{x:b},backend:e,attrs:{perm:c}}),T=Ln({inputs:{x:w},backend:e,attrs:{shape:d}}),N=Wp({inputs:{x:T},backend:e,attrs:{begin:p,size:v}});return x.push(b),x.push(w),x.push(T),x.forEach(S=>e.disposeIntermediateTensorInfo(S)),N}},Fvt={kernelName:g.Bincount,backendName:"webgl",kernelFunc:function kvt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,weights:s}=n,{size:o}=r,a=e.readSync(i.dataId),u=e.readSync(s.dataId),c=hz(a,u,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,c)}},Vvt={kernelName:g.BitwiseAnd,backendName:"webgl",kernelFunc:function zvt(t){const{inputs:n,backend:e}=t,{a:r,b:i}=n,s=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=(0,g.env)().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([r,i])||1===o){const u=e.texData.get(r.dataId).values,c=e.texData.get(i.dataId).values,[d,p]=Hgt(r.shape,i.shape,u,c,r.dtype),v=e.makeTensorInfo(p,r.dtype);return e.texData.get(v.dataId).values=d,v}let a;return a=s?new Vp("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,i.shape,!1):new Qd("\n  return float(int(a.r) & int(b.r));\n",r.shape,i.shape),e.runWebGLProgram(a,[r,i],r.dtype)}},Wvt={kernelName:g.BroadcastArgs,backendName:"webgl",kernelFunc:function Uvt(t){const{inputs:n,backend:e}=t,{s0:r,s1:i}=n,s=e.readSync(r.dataId),o=e.readSync(i.dataId),a=g.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},Lz=Eu({opSnippet:"return float(a != b);",cpuKernelImpl:dyt,dtype:"bool"}),Gvt={kernelName:g.NotEqual,backendName:"webgl",kernelFunc:Lz};function Jg(t){const{inputs:n,backend:e}=t,{input:r}=n;return bl({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const Hvt={kernelName:g.Real,backendName:"webgl",kernelFunc:Jg},Xvt={kernelName:g.Cast,backendName:"webgl",kernelFunc:function dS(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{dtype:s}=r;if("complex64"===s){if("complex64"===i.dtype)return bl({inputs:{x:i},backend:e});const o=g.zeros(i.shape),a=dS({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),u=cd({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),u}if("complex64"===i.dtype){const o=Jg({inputs:{input:i},backend:e}),a=dS({inputs:{x:o},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(o),a}if(!g.util.hasEncodingLoss(i.dtype,s)){const o=bl({inputs:{x:i},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(e.shouldExecuteOnCPU([i])){const o=e.texData.get(i.dataId).values,[a,u,c]=jgt(o,i.shape,i.dtype,s);return e.makeTensorInfo(a,u,c)}if("int32"===s)return function Kvt(t,n){const e=new sh(t.shape,"return float(int(x));"),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,e);if("bool"===s){const o=e.makeTensorInfo([],"bool",g.util.getTypedArrayFromDType("bool",1)),u=Lz({inputs:{a:i,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}},kz="return ceil(x);",Zvt=ms({opSnippet:kz,packedOpSnippet:kz,cpuKernelImpl:Kgt}),Yvt={kernelName:g.Ceil,backendName:"webgl",kernelFunc:Zvt};class Qvt{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class qvt{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const t_t={kernelName:g.ClipByValue,backendName:"webgl",kernelFunc:function Jvt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{clipValueMin:s,clipValueMax:o}=r;let a;return a=(0,g.env)().getBool("WEBGL_PACK_CLIP")?new qvt(i.shape):new Qvt(i.shape),e.runWebGLProgram(a,[i],i.dtype,[[s],[o]])}};class e_t{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Fz(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}const r_t={kernelName:g.ComplexAbs,backendName:"webgl",kernelFunc:function n_t(t){const{inputs:n,backend:e}=t,{x:r}=n,i=e.texData.get(r.dataId),s=new e_t(r.shape),o=[Fz(r,i.complexTensorInfos.real),Fz(r,i.complexTensorInfos.imag)];return e.runWebGLProgram(s,o,o[0].dtype)}};class i_t{constructor(n){this.outputShape=[],this.outputShape=g.backend_util.computeOutShape(n,1),this.variableNames=n.map((o,a)=>`T${a}`);const e=new Array(n.length-1);e[0]=n[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+n[o][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)r.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class s_t{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=g.backend_util.computeOutShape(n,e);const r=this.outputShape,i=r.length,s=ao(i),o=Xu("coords",i),a=["x","y","z","w","u","v"].slice(0,i);this.variableNames=n.map((w,T)=>`T${T}`);const u=new Array(n.length-1);u[0]=n[0][e];for(let w=1;w<u.length;w++)u[w]=u[w-1]+n[w][e];const c=a[e],d=a.slice(-2),p=a.join();let v=`if (${c} < ${u[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${d.join()}));\n        }`;for(let w=1;w<u.length;w++){const T=u[w-1];v+=`\n        if (${c} < ${u[w]}  && ${c} >= ${u[w-1]}) {\n          return getChannel(\n            getT${w}(${_1(a,c,T)}),\n            vec2(${_1(d,c,T)}));\n        }`}const b=u[u.length-1];v+=`\n        return getChannel(\n          getT${u.length}(${_1(a,c,b)}),\n          vec2(${_1(d,c,b)}));`,this.userCode=`\n      float getValue(${a.map(w=>"int "+w)}) {\n        ${v}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[i-1]} = ${o[i-1]} + 1;\n        if (${o[i-1]} < ${r[i-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[i-2]} = ${o[i-2]} + 1;\n        if (${o[i-2]} < ${r[i-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[i-1]} = ${o[i-1]} - 1;\n        if (${o[i-2]} < ${r[i-2]} &&\n            ${o[i-1]} < ${r[i-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function _1(t,n,e){const r=t.indexOf(n);return t.map((s,o)=>o===r?`${s} - ${e}`:s).join()}function x1(t){const{inputs:n,backend:e}=t,{input:r}=n;return bl({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const o_t={kernelName:g.Imag,backendName:"webgl",kernelFunc:x1};function ty(t,n,e){const r=t[0].dtype;if("complex64"===r){const x=t.map(S=>Jg({inputs:{input:S},backend:e})),b=t.map(S=>x1({inputs:{input:S},backend:e})),w=ty(x,n,e),T=ty(b,n,e),N=cd({inputs:{real:w,imag:T},backend:e});return x.forEach(S=>e.disposeIntermediateTensorInfo(S)),b.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),N}let i=e.shouldExecuteOnCPU(t);if("string"===r&&(i=!0),i){const x=t.map(J=>{const Tt=[-1,g.util.sizeFromShape(J.shape.slice(n))];return Ln({inputs:{x:J},backend:e,attrs:{shape:Tt}})}),b=x.map(J=>({vals:e.readSync(J.dataId),shape:J.shape})),w=g.backend_util.computeOutShape(x.map(J=>J.shape),1),N=Xgt(b,w,r,1===x[0].shape[0]),S=g.backend_util.computeOutShape(t.map(J=>J.shape),n),U=e.makeTensorInfo(S,r,N);return x.forEach(J=>e.disposeIntermediateTensorInfo(J)),U}const s=t.filter(x=>g.util.sizeFromShape(x.shape)>0),o=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const x=o?new sh(t[0].shape,ud):new ld(t[0].shape,ud);return e.runWebGLProgram(x,t,r)}const a=(0,g.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){const x=[];for(let w=0;w<s.length;w+=a){const T=s.slice(w,w+a);x.push(ty(T,n,e))}const b=ty(x,n,e);for(const w of x)e.disposeIntermediateTensorInfo(w);return b}if(o){const x=new s_t(s.map(b=>b.shape),n);return e.runWebGLProgram(x,s,r)}const{tensors2D:u,outShape:c}=function a_t(t,n,e){const r=g.backend_util.computeOutShape(t.map(s=>s.shape),n);return{tensors2D:t.map(s=>Ln({inputs:{x:s},attrs:{shape:[-1,g.util.sizeFromShape(s.shape.slice(n))]},backend:e})),outShape:r}}(s,n,e),d=new i_t(u.map(x=>x.shape)),p=e.runWebGLProgram(d,u,r);u.forEach(x=>e.disposeIntermediateTensorInfo(x));const v=Ln({inputs:{x:p},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(p),v}function $z(t){const{inputs:n,backend:e,attrs:r}=t,{axis:i}=r,s=g.util.parseAxisParam(i,n[0].shape)[0],o=n.map(c=>c.shape);g.backend_util.assertParamsConsistent(o,s);const a=g.backend_util.computeOutShape(n.map(c=>c.shape),s);if(0===g.util.sizeFromShape(a))return e.makeTensorInfo(a,n[0].dtype,[]);const u=n.filter(c=>g.util.sizeFromShape(c.shape)>0);return 1===u.length?bl({inputs:{x:u[0]},backend:e}):ty(u,s,e)}const u_t={kernelName:g.Concat,backendName:"webgl",kernelFunc:$z};class Bz{constructor(n,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const o=n.padInfo.top,a=n.padInfo.left,u=n.strideHeight,c=n.strideWidth,d=n.dilationHeight,p=n.dilationWidth,v=n.filterHeight,x=n.filterWidth,b=4*Math.floor(n.inChannels/4),w=n.inChannels%4,T="channelsLast"===n.dataFormat,N=T?1:2,S=T?2:3,U=T?3:1;let J="",ht="";r&&(J=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,ht="result = activation(result);");const Tt=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${J}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${U}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${N}], coords[${S}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${v}; wR++) {\n          int xR = xRCorner + wR * ${d};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${b}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${T}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===w}) {\n\n              if (${T}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${b}) *\n                    getW(wR, wC, ${b}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${b}, xR, xC) *\n                    getW(wR, wC, ${b}, d2);\n              }\n\n            } else if (${2===w}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${b}, d2),\n                getW(wR, wC, ${b} + 1, d2)\n              );\n\n              if (${T}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${b}),\n                  getX(batch, xR, xC, ${b} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${b}, xR, xC),\n                  getX(batch, ${b} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===w}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${b}, d2),\n                getW(wR, wC, ${b} + 1, d2),\n                getW(wR, wC, ${b} + 2, d2)\n              );\n\n              if (${T}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${b}),\n                  getX(batch, xR, xC, ${b} + 1),\n                  getX(batch, xR, xC, ${b} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${b}, xR, xC),\n                  getX(batch, ${b} + 1, xR, xC),\n                  getX(batch, ${b} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${Tt}\n        ${ht}\n        setOutput(result);\n      }\n    `}}class l_t{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const e=n.padInfo.front,r=n.padInfo.top,i=n.padInfo.left,s=n.strideDepth,o=n.strideHeight,a=n.strideWidth,u=n.dilationDepth,c=n.dilationHeight,d=n.dilationWidth,p=n.filterDepth,v=n.filterHeight,x=n.filterWidth,b=4*Math.floor(n.inChannels/4),w=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${i});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${p}; wF++) {\n          int xF = xFCorner + wF * ${u};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${v}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC++) {\n              int xC = xCCorner + wC * ${d};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${b}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===w}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${b}) *\n                  getW(wF, wR, wC, ${b}, d2);\n              } else if (${2===w}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${b}),\n                  getX(batch, xF, xR, xC, ${b} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${b}, d2),\n                  getW(wF, wR, wC, ${b} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===w}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${b}),\n                  getX(batch, xF, xR, xC, ${b} + 1),\n                  getX(batch, xF, xR, xC, ${b} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${b}, d2),\n                  getW(wF, wR, wC, ${b} + 1, d2),\n                  getW(wF, wR, wC, ${b} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zz{constructor(n,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Ru(this.outputShape.length);const o=n.padInfo.left,a=n.strideWidth,u=n.dilationWidth,c=n.filterHeight,d=n.filterWidth,p=d;let v="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let T=0;T<d;T++)v+=`\n           vec4 xTexelC${2*T};\n           int xTexelC${2*T}Ready;\n           vec4 xTexelC${2*T+1};\n           int xTexelC${2*T+1}Ready;\n           vec4 xC${T};`;v+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {\n       `;for(let T=0;T<d;T++)v+=`\n           xTexelC${2*T} = vec4(0.0);\n           xTexelC${2*T}Ready = 0;\n           xTexelC${2*T+1} = vec4(0.0);\n           xTexelC${2*T+1}Ready = 0;\n           xC${T} = vec4(0.0);`;v+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let T=0;T<(p+1)/2;T++){const N=2*T;if(v+=`\n           xC = xCCorner + ${N*u};\n           `,1===a){if(N<d&&(o%2==1?(v+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n               `,v+=1===u&&N>0?`\n                 xC${N} = vec4(xTexelC${N-2}.zw, xTexelC${N}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${N} = vec4(previous.zw, xTexelC${N}.xy);\n                   } else {\n                     xC${N} = vec4(0.0, 0.0, xTexelC${N}.xy);\n                   }\n                   `):v+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 xC${N} = xTexelC${N};\n                 `,N+1<d)){const S=o%2==0?g.util.nearestLargerEven(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(v+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${S};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                     xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${N+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${N+1}Ready = 1;\n                   }\n                   `,v+=u>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${N+1} = vec4(previous.zw, xTexelC${N+1}.xy);\n                     } else {\n                      xC${N+1} = vec4(0.0, 0.0, xTexelC${N+1}.xy);\n                     }\n                     `:`\n                     xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.xy);\n                     `):v+=1===S?`\n                     xC${N+1} = xTexelC${N};\n                     `:`\n                     xCOffset = xC + ${S};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                       xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${N+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${N+1}Ready = 1;\n                     }\n\n                     xC${N+1} = xTexelC${N+1};\n                     `}}else N<d&&(o%2==1?(v+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${N+1}Ready == 0) {\n                   xTexelC${N+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${N+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${N+1}Ready = 1;\n                 }\n\n                 xC${N} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);\n               `,N+1<d&&(v+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${N+1} = vec4(xTexelC${N+1}.xy, final.xy);\n                 `)):(v+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${N}Ready == 0) {\n                   xTexelC${N} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${N}.zw = vec2(0.0);\n                   }\n                   xTexelC${N}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${N+1}Ready == 0) {\n                   xTexelC${N+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${N+1}.zw = vec2(0.);\n                   }\n                   xTexelC${N+1}Ready = 1;\n                 }\n\n                 xC${N} = vec4(\n                   xTexelC${N}.xy, xTexelC${N+1}.xy);\n               `,N+1<d&&(v+=`\n                   xC${N+1} = vec4(xTexelC${N}.zw, xTexelC${N+1}.zw);\n                 `)));N<d&&(v+=`\n             wTexel = getW(r, ${N}, d1, d2);\n             dotProd += xC${N}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${n.inChannels}) {\n               dotProd += xC${N}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,N+1<d&&(v+=`\n               wTexel = getW(r, ${N+1}, d1, d2);\n               dotProd += xC${N+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${n.inChannels}) {\n                 dotProd += xC${N+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}v+="\n     }\n   ",v+="\n     }\n   ",v+="\n     }\n   ";let x="",b="";r&&(x=i?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,b="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${x}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${v}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${w}\n         ${b}\n         setOutput(result);\n       }\n     `}}class c_t{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=Ru(this.outputShape.length);const{dataFormat:r}=e,i=Ku(),s="channelsLast"===r,o=s?1:2,a=s?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)c+=`\n          blockIndex = rc.z + ${p};\n          pos = rc.y + ${d};\n\n          ${u}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*d+p}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*d+p}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${i.output} = result;\n      }\n    `}}function E1(t,n){const e=t.length;return e>=3?n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]:!n&&1===e&&t[0]>1?[t[0],1]:null}function Vz({x:t,filter:n,convInfo:e,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const u=t.shape,c=r.texData.get(t.dataId),d=e.inChannels,p=u[0]*u[1]*u[2],v=e.outChannels,x="channelsLast"===e.dataFormat;let T;const N=[];if(null!=s){const J=E1(s.shape,x);null!=J&&(s=Ln({inputs:{x:s},backend:r,attrs:{shape:J}}),N.push(s))}if(null!=i){const J=E1(i.shape,x);null!=J&&(i=Ln({inputs:{x:i},backend:r,attrs:{shape:J}}),N.push(i))}if((1!==p&&1!==v||!(d>Nz))&&c.isPacked&&x&&null!=c.texture&&u[2]%2!=0&&g.util.arraysEqual(c.shape.slice(-3),u.slice(-3))){const ht={dataId:t.dataId,shape:[1,u[0]*u[1]*(u[2]+1),e.inChannels],dtype:t.dtype},Tt=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,g.util.assert(l1(c.shape,ht.shape),()=>`packed reshape ${c.shape} to ${ht.shape} isn't free`);const Pt=Ln({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});N.push(Pt);const zt=y1({a:ht,b:Pt,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),Ot=r.texData.get(zt.dataId);g.util.assert(Ot.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=Tt,Ot.shape=e.outShape,T=bl({inputs:{x:zt},backend:r}),T.shape=e.outShape,N.push(zt)}else{const J=e.outHeight*e.outWidth,ht=Ln({inputs:{x:t},backend:r,attrs:{shape:x?[e.batchSize,J,e.inChannels]:[e.batchSize,e.inChannels,J]}}),Tt=Ln({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),Pt=y1({a:x?ht:Tt,b:x?Tt:ht,transposeA:!x,transposeB:!1,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o});T=Ln({inputs:{x:Pt},backend:r,attrs:{shape:e.outShape}}),N.push(ht),N.push(Tt),N.push(Pt)}for(const J of N)r.disposeIntermediateTensorInfo(J);return T}function Uz({x:t,filter:n,convInfo:e,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:p,outHeight:v,dataFormat:x}=e,b="channelsLast"===x,w=u*c*d,T=v*p,N=[e.batchSize,w,T],J=[];if(null!=s){const Le=E1(s.shape,b);null!=Le&&(s=Ln({inputs:{x:s},backend:r,attrs:{shape:Le}}),J.push(s))}if(null!=i){const Le=E1(i.shape,b);null!=Le&&(i=Ln({inputs:{x:i},backend:r,attrs:{shape:Le}}),J.push(i))}const ht=Ln({inputs:{x:n},backend:r,attrs:{shape:[1,w,g.util.sizeFromShape(n.shape)/w]}});J.push(ht);const Tt=new c_t(N,e),zt=r.runWebGLProgram(Tt,[t],"float32",[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),Ot=Ln({inputs:{x:zt},backend:r,attrs:{shape:N}});J.push(zt),J.push(Ot);const le=null!=i,ge=null!=s,Ae="leakyrelu"===a,Re=a?Qg(a,!0):null,ve=new wz(b?Ot.shape:ht.shape,b?ht.shape:Ot.shape,b?[e.batchSize,T,e.outChannels]:[e.batchSize,e.outChannels,T],!0,!1,le,Re,ge,Ae),Ne=b?[Ot,ht]:[ht,Ot];if(i&&Ne.push(i),ge&&Ne.push(s),Ae){const Le=r.makeTensorInfo([],"float32",g.util.createScalarValue(o,"float32"));Ne.push(Le),J.push(Le)}const Se=r.runWebGLProgram(ve,Ne,"float32"),Ke=Ln({inputs:{x:Se},backend:r,attrs:{shape:e.outShape}});J.push(Se);for(const Le of J)r.disposeIntermediateTensorInfo(Le);return Ke}const d_t={kernelName:g.Conv2D,backendName:"webgl",kernelFunc:function h_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dataFormat:u,dilations:c,dimRoundingMode:d}=r,p=g.backend_util.convertConv2DDataFormat(u),v=g.backend_util.computeConv2DInfo(i.shape,s.shape,o,c,a,d,!1,p);let x;if(1!==v.filterHeight||1!==v.filterWidth||1!==v.dilationHeight||1!==v.dilationWidth||1!==v.strideHeight||1!==v.strideWidth||"SAME"!==v.padInfo.type&&"VALID"!==v.padInfo.type)if(v.strideWidth<=2&&"channelsLast"===p&&(0,g.env)().getBool("WEBGL_EXP_CONV")){const w=new zz(v);x=e.runWebGLProgram(w,[i,s],"float32",[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]])}else if((0,g.env)().getBool("WEBGL_CONV_IM2COL"))x=Uz({x:i,filter:s,convInfo:v,backend:e});else{const w=new Bz(v);x=e.runWebGLProgram(w,[i,s],"float32")}else x=Vz({x:i,filter:s,convInfo:v,backend:e});const b=Ln({inputs:{x},backend:e,attrs:{shape:v.outShape}});return e.disposeIntermediateTensorInfo(x),b}};class f_t{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===n.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class p_t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,o="channelsLast"===n.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class m_t{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${n.strideDepth} - ${n.padInfo.front};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class g_t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterDepth,r=n.filterHeight,i=n.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-n.padInfo.front}, ${r-1-n.padInfo.top}, ${i-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${n.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${i}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${i} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const v_t={kernelName:g.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function y_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:d}=r,p=g.backend_util.convertConv2DDataFormat(u),v=g.backend_util.computeConv2DInfo(i.shape,d,o,1,a,c,!1,p),x=new f_t(v);return e.runWebGLProgram(x,[i,s],"float32")}};class __t{constructor(n){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=n.inShape,this.enableShapeUniforms=Ru(this.outputShape.length);const e=n.filterHeight,r=n.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${n.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${n.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const E_t={kernelName:g.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function x_t(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{inputShape:o,strides:a,pad:u,dataFormat:c,dimRoundingMode:d}=r,p=g.backend_util.convertConv2DDataFormat(c),v=g.backend_util.computeConv2DInfo(o,s.shape,a,1,u,d,!1,p);if((0,g.env)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===p){const x=[[v.strideHeight,v.strideWidth]],b=new __t(v);return e.runWebGLProgram(b,[i,s],"float32",x)}{const x=new p_t(v);return e.runWebGLProgram(x,[i,s],"float32")}}},b_t={kernelName:g.Conv3D,backendName:"webgl",kernelFunc:function C_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u}=r,c=g.backend_util.computeConv3DInfo(i.shape,s.shape,o,u,a),d=new l_t(c);return e.runWebGLProgram(d,[i,s],"float32")}},I_t={kernelName:g.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function w_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,pad:a,filterShape:u}=r,c=g.backend_util.computeConv3DInfo(i.shape,u,o,1,a),d=new m_t(c);return e.runWebGLProgram(d,[i,s],"float32")}},D_t={kernelName:g.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function S_t(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{pad:o,strides:a,inputShape:u}=r,c=g.backend_util.computeConv3DInfo(u,s.shape,a,1,o),d=new g_t(c);return e.runWebGLProgram(d,[i,s],"float32")}},A_t=ms({opSnippet:Up+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${qd}\n  return result;\n`}),M_t={kernelName:g.Cos,backendName:"webgl",kernelFunc:A_t},P_t=ms({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),O_t={kernelName:g.Cosh,backendName:"webgl",kernelFunc:P_t};class R_t{constructor(n,e,r,i,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,u,c]=n,[d]=e,[p,v]=r;this.outputShape=[d,p,v,c];const x="bilinear"===i?1:0,[b,w]=[a-1+".0",u-1+".0"],[T,N,S]=p>1?[""+(a-1)/(p-1),"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[U,J,ht]=v>1?[""+(u-1)/(v-1),"(x2-x1) * width_ratio",`x1*${w} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${w}`];this.userCode=`\n      const float height_ratio = float(${T});\n      const float width_ratio = float(${U});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${N};\n        float width_scale = ${J};\n\n        float in_y = ${S};\n        if( in_y < 0.0 || in_y > ${b} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${ht};\n        if( in_x < 0.0 || in_x > ${w} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${x} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const k_t={kernelName:g.CropAndResize,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{image:i,boxes:s,boxInd:o}=n,{cropSize:a,method:u,extrapolationValue:c}=r,d=new R_t(i.shape,s.shape,a,u,c);return e.runWebGLProgram(d,[i,s,o],"float32")}};var C1=function(t){return t.Prod="*",t.Sum="+",t}(C1||{});class Wz{constructor(n,e,r,i){this.op=n,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=r?this.op===C1.Prod?"1.0":"0.0":`getX(${Gz(s,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",d="";r?(c=i?"end != "+(u-1):"end != 0",d=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${u}`:"end >= pow2",d=i?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${ao(s)} coords = getOutputCoords();\n        int end = ${Hz(s,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${d};\n          ${Hz(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Gz(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Gz(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.x, ${n}.y`;if(3===t)return`${n}.x, ${n}.y, ${n}.z`;if(4===t)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function Hz(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.y`;if(3===t)return`${n}.z`;if(4===t)return`${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function jz(t,n,e,r,i,s){const o=n.shape.length,a=g.backend_util.getAxesPermutation([r],o);let u=n;null!=a&&(u=Zu({inputs:{x:n},backend:e,attrs:{perm:a}}));const c=g.backend_util.getInnerMostAxes(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);const d=u.shape[c];let p=bl({inputs:{x:u},backend:e});for(let v=0;v<=Math.ceil(Math.log2(d))-1;v++){const x=new Wz(t,u.shape,!1,s),w=p;p=e.runWebGLProgram(x,[p],p.dtype,[[v]]),e.disposeIntermediateTensorInfo(w)}if(i){const v=new Wz(t,u.shape,i,s),x=p;p=e.runWebGLProgram(v,[p],p.dtype),e.disposeIntermediateTensorInfo(x)}if(null!=a){const x=Zu({inputs:{x:p},backend:e,attrs:{perm:g.backend_util.getUndoAxesPermutation(a)}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(u),x}return p}const $_t={kernelName:g.Cumprod,backendName:"webgl",kernelFunc:function F_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,exclusive:o,reverse:a}=r;return jz(C1.Prod,i,e,s,o,a)}},z_t={kernelName:g.Cumsum,backendName:"webgl",kernelFunc:function B_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,exclusive:o,reverse:a}=r;return jz(C1.Sum,i,e,s,o,a)}},U_t={kernelName:g.DenseBincount,backendName:"webgl",kernelFunc:function V_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,weights:s}=n,{size:o,binaryOutput:a}=r;if(1===i.shape.length){const u=e.readSync(i.dataId),c=e.readSync(s.dataId),d=hz(u,c,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,d)}if(2===i.shape.length){const u=e.bufferSync(i),c=e.bufferSync(s),d=Ggt(u,c,o,a);return e.makeTensorInfo(d.shape,s.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}};class W_t{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const H_t={kernelName:g.DepthToSpace,backendName:"webgl",kernelFunc:function G_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockSize:s,dataFormat:o}=r,a=i.shape[0],p=("NHWC"===o?i.shape[1]:i.shape[2])*s,v=("NHWC"===o?i.shape[2]:i.shape[3])*s,x=("NHWC"===o?i.shape[3]:i.shape[1])/(s*s),w=new W_t("NHWC"===o?[a,p,v,x]:[a,x,p,v],s,o);return e.runWebGLProgram(w,[i],i.dtype)}};class Kz{constructor(n,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Ru(this.outputShape.length);const o=n.filterHeight,a=n.filterWidth,u=n.outChannels/n.inChannels;let c="",d="";r&&(c=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,d="result = activation(result);");const p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${u};\n        int q = d2 - d1 * ${u};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${d}\n        setOutput(result);\n      }\n    `}}class Xz{constructor(n,e=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=Ru(this.outputShape.length);const o=n.outChannels/n.inChannels,a=n.padInfo.left,u=n.strideWidth,c=n.dilationWidth,d=n.filterHeight,p=n.filterWidth,v=p;let x="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let N=0;N<p;N++)x+=`\n          vec4 xTexelC${2*N};\n          int xTexelC${2*N}Ready;\n          vec4 xTexelC${2*N+1};\n          int xTexelC${2*N+1}Ready;\n          vec4 xC${N};`;x+=`\n    for (int r = 0; r < ${d}; r++) {\n      `;for(let N=0;N<p;N++)x+=`\n          xTexelC${2*N} = vec4(0.0);\n          xTexelC${2*N}Ready = 0;\n          xTexelC${2*N+1} = vec4(0.0);\n          xTexelC${2*N+1}Ready = 0;\n          xC${N} = vec4(0.0);`;x+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let N=0;N<(v+1)/2;N++){const S=2*N;if(x+=`\n          xC = xCCorner + ${S*c};\n          `,1===u){if(S<p&&(a%2==1?(x+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {\n                  xTexelC${S} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${S}.zw = vec2(0.0);\n                  }\n                  xTexelC${S}Ready = 1;\n                }\n              `,x+=1===c&&S>0?`\n                xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${S} = vec4(previous.zw, xTexelC${S}.xy);\n                  } else {\n                    xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);\n                  }\n                  `):x+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {\n                  xTexelC${S} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${S}.zw = vec2(0.0);\n                  }\n                  xTexelC${S}Ready = 1;\n                }\n\n                xC${S} = xTexelC${S};\n                `,S+1<p)){const U=a%2==0?g.util.nearestLargerEven(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(x+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${U};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {\n                    xTexelC${S+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${S+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${S+1}Ready = 1;\n                  }\n                  `,x+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);\n                    } else {\n                     xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);\n                    }\n                    `:`\n                    xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);\n                    `):x+=1===U?`\n                    xC${S+1} = xTexelC${S};\n                    `:`\n                    xCOffset = xC + ${U};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {\n                      xTexelC${S+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${S+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${S+1}Ready = 1;\n                    }\n\n                    xC${S+1} = xTexelC${S+1};\n                    `}}else S<p&&(a%2==1?(x+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {\n                  xTexelC${S} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${S}.zw = vec2(0.0);\n                  }\n                  xTexelC${S}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {\n                  xTexelC${S+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${S+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${S+1}Ready = 1;\n                }\n\n                xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);\n              `,S+1<p&&(x+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);\n                `)):(x+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {\n                  xTexelC${S} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${S}.zw = vec2(0.0);\n                  }\n                  xTexelC${S}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {\n                  xTexelC${S+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${S+1}.zw = vec2(0.);\n                  }\n                  xTexelC${S+1}Ready = 1;\n                }\n\n                xC${S} = vec4(\n                  xTexelC${S}.xy, xTexelC${S+1}.xy);\n              `,S+1<p&&(x+=`\n                  xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);\n                `)));S<p&&(x+=`\n            wTexel = getW(r, ${S}, d1, q);\n            dotProd += xC${S} * vec4(wTexel.xz, wTexel.xz);\n          `,S+1<p&&(x+=`\n              wTexel = getW(r, ${S+1}, d1, q);\n              dotProd += xC${S+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}x+="\n    }\n  ",x+="\n      }\n    ";let b="",w="";r&&(b=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,w="result = activation(result);");const T=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${x}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${T}\n        ${w}\n        setOutput(result);\n      }\n    `}}const K_t={kernelName:g.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function j_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u,dimRoundingMode:c}=r;let d=u;null==d&&(d=[1,1]),g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=g.backend_util.computeConv2DInfo(i.shape,s.shape,o,d,a,c,!0);let v;return v=(0,g.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new Xz(p):new Kz(p),e.runWebGLProgram(v,[i,s],"float32",[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]])}};class X_t{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${n.outChannels/n.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Z_t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,u=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${u}; dm++) {\n              int d2 = d1 * ${u} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Q_t={kernelName:g.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function Y_t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,dy:s}=n,{strides:o,dilations:a,pad:u,dimRoundingMode:c,filterShape:d}=r,p=g.backend_util.computeConv2DInfo(i.shape,d,o,a,u,c,!0),v=new X_t(p);return e.runWebGLProgram(v,[i,s],"float32")}},J_t={kernelName:g.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function q_t(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,filter:s}=n,{strides:o,dilations:a,pad:u,dimRoundingMode:c,inputShape:d}=r,p=g.backend_util.computeConv2DInfo(d,s.shape,o,a,u,c,!0),v=new Z_t(p);return e.runWebGLProgram(v,[i,s],"float32")}};class t1t{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const n1t={kernelName:g.Diag,backendName:"webgl",kernelFunc:function e1t(t){const{inputs:n,backend:e}=t,{x:r}=n,i=[...r.shape,...r.shape],s=g.util.sizeFromShape(r.shape),o=Ln({inputs:{x:r},backend:e,attrs:{shape:[s]}}),a=new t1t(s),u=e.runWebGLProgram(a,[o],o.dtype),c=Ln({inputs:{x:u},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(u),c}};class r1t{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:e,inWidth:r,padInfo:i,strideHeight:s,strideWidth:o,filterHeight:a,filterWidth:u,dilationHeight:c,dilationWidth:d}=n,{top:p,left:v}=i;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${p}, ${v});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${u}; w++) {\n              int wIn = wBeg + w * ${d};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const s1t={kernelName:g.Dilation2D,backendName:"webgl",kernelFunc:function i1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s}=n,{strides:o,pad:a,dilations:u}=r,c=g.backend_util.computeDilation2DInfo(i.shape,s.shape,o,a,"NHWC",u);let d;const p=new r1t(c);d=e.runWebGLProgram(p,[i,s],"float32");const v=Ln({inputs:{x:d},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(d),v}},a1t={kernelName:g.Einsum,backendName:"webgl",kernelFunc:function o1t(t){const{inputs:n,backend:e,attrs:r}=t,{equation:i}=r,s=n,{allDims:o,summedDims:a,idDims:u}=g.backend_util.decodeEinsumEquation(i,s.length);g.backend_util.checkEinsumDimSizes(o.length,u,s);const{path:c,steps:d}=g.backend_util.getEinsumComputePath(a,u),p=d.length;let v=null,x=o.length;const b=[];for(let w=0;w<p;++w){for(const T of d[w]){const{permutationIndices:N,expandDims:S}=g.backend_util.getEinsumPermutation(x,u[T]);let U;g.backend_util.isIdentityPermutation(N)?U=s[T]:(U=Zu({inputs:{x:s[T]},backend:e,attrs:{perm:N}}),b.push(U));const J=U.shape.slice();for(let ht=0;ht<S.length;++ht)J.splice(S[ht],0,1);g.util.arraysEqual(U.shape,J)||(U=Ln({inputs:{x:U},backend:e,attrs:{shape:J}}),b.push(U)),null===v?v=U:(v=lS({inputs:{a:U,b:v},backend:e}),b.push(v))}w<p-1&&(c[w]>=0&&(v=g1({inputs:{x:v},backend:e,attrs:{axis:c[w]-(o.length-x),keepDims:!1}}),b.push(v)),x--)}for(const w of b)w!==v&&e.disposeIntermediateTensorInfo(w);return v}},u1t=ms({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),l1t={kernelName:g.Elu,backendName:"webgl",kernelFunc:u1t},f1t={kernelName:g.EluGrad,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e}=t,{dy:r,y:i}=n,s=(0,g.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Vp("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,i.shape):new Qd("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,i.shape);return e.runWebGLProgram(s,[r,i],r.dtype)}},p1t=Eu({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Zgt}),m1t={kernelName:g.Equal,backendName:"webgl",kernelFunc:p1t},y1t=ms({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${g.backend_util.ERF_P};\n  float a1 = ${g.backend_util.ERF_A1};\n  float a2 = ${g.backend_util.ERF_A2};\n  float a3 = ${g.backend_util.ERF_A3};\n  float a4 = ${g.backend_util.ERF_A4};\n  float a5 = ${g.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),v1t={kernelName:g.Erf,backendName:"webgl",kernelFunc:y1t},Zz=ms({opSnippet:Up+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ygt,dtype:"float32"}),x1t={kernelName:g.Exp,backendName:"webgl",kernelFunc:Zz};function fS(t){const{inputs:n,attrs:e,backend:r}=t,{dim:i}=e,{input:s}=n,o=s.shape.length,a=s.shape.slice();let u=i;return i<0&&(g.util.assert(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+i+1),a.splice(u,0,1),Ln({inputs:{x:s},backend:r,attrs:{shape:a}})}const E1t={kernelName:g.ExpandDims,backendName:"webgl",kernelFunc:fS},Yz="return exp(x) - 1.0;",C1t=ms({opSnippet:Yz,packedOpSnippet:Yz,cpuKernelImpl:Qgt}),b1t={kernelName:g.Expm1,backendName:"webgl",kernelFunc:C1t};class Qz{constructor(n,e,r){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${i}.0`:"1.0";let a;if("real"===n)a="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${i});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${i}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function qz(t,n,e){const r=e.texData.get(t.dataId),i=g.util.sizeFromShape(t.shape),s=t.shape[t.shape.length-1],a=Ln({inputs:{x:t},backend:e,attrs:{shape:[i/s,s]}}),u=a.shape,c=new Qz("real",u,n),d=new Qz("imag",u,n),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],v=e.runWebGLProgram(c,p,"float32"),x=e.runWebGLProgram(d,p,"float32"),b=cd({inputs:{real:v,imag:x},backend:e});e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x);const w=Ln({inputs:{x:b},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(b),w}const I1t={kernelName:g.FFT,backendName:"webgl",kernelFunc:function w1t(t){const{inputs:n,backend:e}=t,{input:r}=n;return qz(r,!1,e)}};class S1t{constructor(n,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function ey(t){const{backend:n,attrs:e}=t,{shape:r,value:i}=e;let{dtype:s}=e;if(s=s||g.util.inferDtype(i),"string"===s){const o=g.util.getArrayFromDType(s,g.util.sizeFromShape(r));return o.fill(i),n.makeTensorInfo(r,s,o)}{const o=new S1t(r,i);return n.runWebGLProgram(o,[],s,[[i]])}}const D1t={kernelName:g.Fill,backendName:"webgl",kernelFunc:ey};class T1t{constructor(n){this.variableNames=["Image"],this.outputShape=[];const e=n[2];this.outputShape=n,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const N1t={kernelName:g.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t,r=n,i=new T1t(e.shape);return r.runWebGLProgram(i,[e],e.dtype)}},Jz="return floor(x);",A1t=ms({opSnippet:Jz,packedOpSnippet:Jz,cpuKernelImpl:qgt}),M1t={kernelName:g.Floor,backendName:"webgl",kernelFunc:A1t},P1t=Eu({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),O1t={kernelName:g.FloorDiv,backendName:"webgl",kernelFunc:P1t};class R1t{constructor(n){this.variableNames=["A"];const e=Ku(),[r,i]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class L1t{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Ku(),[r,i]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${i}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const k1t={kernelName:g.FromPixels,backendName:"webgl",kernelFunc:function F1t(t){const{inputs:n,backend:e,attrs:r}=t;let{pixels:i}=n;const{numChannels:s}=r,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[u,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],d=[c,u],p=[c,u,s];if(a||o){const w=(0,g.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Gp||w!==pS)&&(pS=w,Gp=document.createElement("canvas").getContext("2d",{willReadFrequently:pS})),Gp.canvas.width=u,Gp.canvas.height=c,Gp.drawImage(i,0,0,u,c),i=Gp.canvas}const v=e.makeTensorInfo(d,"int32");e.texData.get(v.dataId).usage=dc.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(v.dataId),i);const x=(0,g.env)().getBool("WEBGL_PACK")?new L1t(p):new R1t(p),b=e.runWebGLProgram(x,[v],"int32");return e.disposeData(v.dataId),b}};let Gp,pS=(0,g.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const B1t={kernelName:g.FusedConv2D,backendName:"webgl",kernelFunc:function $1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:v,activation:x,leakyreluAlpha:b}=r,w=g.backend_util.convertConv2DDataFormat(d),T=g.backend_util.computeConv2DInfo(i.shape,s.shape,u,p,c,v,!1,w);let N;const S=[],U=null!=o,J=null!=a,ht="leakyrelu"===x,Tt=()=>{const zt=[i,s],Ot=(le,ge)=>{if("NCHW"===ge&&1===le.shape.length&&1!==le.shape[0]){const Ae=Ln({inputs:{x:le},backend:e,attrs:{shape:[le.shape[0],1,1]}});return S.push(Ae),Ae}return le};if(U&&zt.push(Ot(o,d)),J&&zt.push(Ot(a,d)),ht){const le=e.makeTensorInfo([],"float32",g.util.createScalarValue(b,"float32"));zt.push(le),S.push(le)}return zt};if(1!==T.filterHeight||1!==T.filterWidth||1!==T.dilationHeight||1!==T.dilationWidth||1!==T.strideHeight||1!==T.strideWidth||"SAME"!==T.padInfo.type&&"VALID"!==T.padInfo.type)if(T.strideWidth<=2&&"channelsLast"===w&&(0,g.env)().getBool("WEBGL_EXP_CONV")){const zt=x?Qg(x,!0):null,Ot=new zz(T,U,zt,J,ht),le=[[T.padInfo.top,T.padInfo.left],[T.strideHeight,T.strideWidth],[T.dilationHeight,T.dilationWidth],[T.inHeight,T.inWidth]],ge=Tt();N=e.runWebGLProgram(Ot,ge,"float32",le)}else if((0,g.env)().getBool("WEBGL_CONV_IM2COL"))N=Uz({x:i,filter:s,convInfo:T,backend:e,bias:o,activation:x,preluActivationWeights:a,leakyreluAlpha:b});else{const zt=x?Qg(x,!1):null,Ot=new Bz(T,U,zt,J,ht),le=Tt();N=e.runWebGLProgram(Ot,le,"float32")}else N=Vz({x:i,filter:s,convInfo:T,backend:e,bias:o,activation:x,preluActivationWeights:a,leakyreluAlpha:b});const Pt=Ln({inputs:{x:N},backend:e,attrs:{shape:T.outShape}});return S.push(N),S.forEach(zt=>e.disposeIntermediateTensorInfo(zt)),Pt}},V1t={kernelName:g.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function z1t(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=n,{strides:u,pad:c,dilations:d,dimRoundingMode:p,activation:v,leakyreluAlpha:x}=r,b=[];let w=d;null==w&&(w=[1,1]),g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(u,w),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${w}'`);const T=g.backend_util.computeConv2DInfo(i.shape,s.shape,u,w,c,p,!0),N=(0,g.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&T.strideWidth<=2&&T.outChannels/T.inChannels==1,S=v?Qg(v,N):null,U=[i,s],J=null!=o,ht=null!=a,Tt="leakyrelu"===v;if(J&&U.push(o),ht&&U.push(a),Tt){const le=e.makeTensorInfo([],"float32",g.util.createScalarValue(x,"float32"));U.push(le),b.push(le)}let Pt;Pt=N?new Xz(T,J,S,ht,Tt):new Kz(T,J,S,ht,Tt);const Ot=e.runWebGLProgram(Pt,U,"float32",[[T.padInfo.top,T.padInfo.left],[T.strideHeight,T.strideWidth],[T.dilationHeight,T.dilationWidth],[T.inHeight,T.inWidth]]);return b.forEach(le=>e.disposeIntermediateTensorInfo(le)),Ot}};class U1t{constructor(n,e,r,i){this.sliceDim=n,this.strides=e,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=r;const s=ao(r.length);let o="\n    int index;";for(let a=0;a<this.sliceDim;a++)o+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const G1t={kernelName:g.GatherNd,backendName:"webgl",kernelFunc:function W1t(t){const{inputs:n,backend:e}=t,{params:r,indices:i}=n,s=i.shape,o=s[s.length-1],a=g.util.sizeFromShape(r.shape),[u,c,d,p]=g.backend_util.prepareAndValidate(r,i),v=Ln({inputs:{x:i},backend:e,attrs:{shape:[c,o]}}),x=Ln({inputs:{x:r},backend:e,attrs:{shape:[g.util.sizeFromShape(r.shape)/d,d]}});if(e.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const N=e.readSync(i.dataId),S=e.bufferSync(r),U=Jgt(N,S,r.dtype,c,o,d,p,r.shape,a);return e.makeTensorInfo(u,r.dtype,U.values)}const b=new U1t(o,p,[c,d],r.shape),w=e.runWebGLProgram(b,[x,v],x.dtype),T=Ln({inputs:{x:w},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),T}};class H1t{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=ao(this.rank),i=function j1t(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<t.length;i++)r.push(2===i?"index":`${e[i]}`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}}function tV(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,indices:s}=n,{axis:o,batchDims:a}=r,u=g.util.parseAxisParam(o,i.shape)[0];if((0,g.env)().get("DEBUG")){const S=e.readSync(s.dataId),U=i.shape[u];for(let J=0;J<S.length;++J){const ht=S[J];g.util.assert(ht<=U-1&&ht>=0,()=>`GatherV2: the index value ${ht} is not in [0, ${U-1}]`)}}const c=g.backend_util.segment_util.collectGatherOpShapeInfo(i,s,u,a),d=g.util.sizeFromShape(s.shape),p=[],v=Ln({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),x=Ln({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,d/c.batchSize]}});p.push(v),p.push(x);const b=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([i,s])||"string"===i.dtype){const S=e.bufferSync(x),U=e.bufferSync(v),J=tyt(U,S,b);return p.forEach(ht=>e.disposeIntermediateTensorInfo(ht)),e.makeTensorInfo(c.outputShape,J.dtype,J.values)}const w=new H1t(v.shape,b),T=e.runWebGLProgram(w,[v,x],v.dtype);p.push(T);const N=Ln({inputs:{x:T},backend:e,attrs:{shape:c.outputShape}});return p.forEach(S=>e.disposeIntermediateTensorInfo(S)),N}const K1t={kernelName:g.GatherV2,backendName:"webgl",kernelFunc:tV},X1t=Eu({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:eyt,dtype:"bool"}),Z1t={kernelName:g.Greater,backendName:"webgl",kernelFunc:X1t},Y1t=Eu({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:nyt}),Q1t={kernelName:g.GreaterEqual,backendName:"webgl",kernelFunc:Y1t},J1t={kernelName:g.IFFT,backendName:"webgl",kernelFunc:function q1t(t){const{inputs:n,backend:e}=t,{input:r}=n;return qz(r,!0,e)}},txt=ms({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),ext={kernelName:g.IsFinite,backendName:"webgl",kernelFunc:txt},nxt=ms({opSnippet:"return float(isinf(x));",dtype:"bool"}),rxt={kernelName:g.IsInf,backendName:"webgl",kernelFunc:nxt},ixt=ms({opSnippet:"return float(isnan(x));",dtype:"bool"}),sxt={kernelName:g.IsNan,backendName:"webgl",kernelFunc:ixt},oxt=Eu({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:ryt,dtype:"bool"}),axt={kernelName:g.Less,backendName:"webgl",kernelFunc:oxt},uxt=Eu({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:iyt,dtype:"bool"}),lxt={kernelName:g.LessEqual,backendName:"webgl",kernelFunc:uxt},hxt={kernelName:g.LinSpace,backendName:"webgl",kernelFunc:function cxt(t){const{backend:n,attrs:e}=t,{start:r,stop:i,num:s}=e,o=syt(r,i,s);return n.makeTensorInfo([o.length],"float32",o)}},fxt=ms({opSnippet:Up+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:oyt}),pxt={kernelName:g.Log,backendName:"webgl",kernelFunc:fxt},gxt=ms({opSnippet:Up+"\n  return log(1.0 + x);\n"}),yxt={kernelName:g.Log1p,backendName:"webgl",kernelFunc:gxt},vxt=Eu({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),_xt={kernelName:g.LogicalAnd,backendName:"webgl",kernelFunc:vxt},xxt=ms({opSnippet:"return float(!(x >= 1.0));"}),Ext={kernelName:g.LogicalNot,backendName:"webgl",kernelFunc:xxt},Cxt=Eu({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),bxt={kernelName:g.LogicalOr,backendName:"webgl",kernelFunc:Cxt};class wxt{constructor(n,e,r,i,s){this.variableNames=["x"],this.outputShape=[];const o=e,a=n[3]-1;let u;this.outputShape=n;const c=`float(${r}) + float(${i}) * sum`;u=.5===s?`inversesqrt(${c})`:1===s?`1.0/(${c})`:`exp(log(${c}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${u};\n        setOutput(val);\n      }\n    `}}class Ixt{constructor(n,e,r,i,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=n[3]-1;let u;this.outputShape=n;const c=`float(${r}) + float(${i}) * sum`;u=.5===s?`inversesqrt(${c})`:1===s?`1.0/(${c})`:`exp(log(${c}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${u};\n        setOutput(result);\n      }\n    `}}const Dxt={kernelName:g.LRN,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{depthRadius:s,bias:o,alpha:a,beta:u}=r,c=(0,g.env)().getBool("WEBGL_PACK_NORMALIZATION")?new Ixt(i.shape,s,o,a,u):new wxt(i.shape,s,o,a,u);return e.runWebGLProgram(c,[i],i.dtype)}};class Txt{constructor(n,e,r,i,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=i,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${i}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${i})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Axt={kernelName:g.LRNGrad,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i,y:s,dy:o}=n,{depthRadius:a,bias:u,alpha:c,beta:d}=r,p=new Txt(i.shape,a,u,c,d);return e.runWebGLProgram(p,[i,s,o],i.dtype)}};function eV(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{reductionIndices:s,keepDims:o}=r,a=i.shape.length,u=g.util.parseAxisParam(s,i.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a),p=null!=d,v=e.shouldExecuteOnCPU([i]);let x=i;if(p){if(v){const U=e.texData.get(x.dataId).values,J=new Array(a);for(let Pt=0;Pt<J.length;Pt++)J[Pt]=i.shape[d[Pt]];const ht=aS(U,i.shape,i.dtype,d,J);x=e.makeTensorInfo(J,i.dtype),e.texData.get(x.dataId).values=ht}else x=m1(i,d,e);c=g.backend_util.getInnerMostAxes(c.length,a)}g.backend_util.assertAxesAreInnerMostDims("max",c,a);const[b,w]=g.backend_util.computeOutAndReduceShapes(x.shape,c);let N,T=b;if(o&&(T=g.backend_util.expandShapeToKeepDim(b,u)),v){const U=e.texData.get(x.dataId).values,J=ayt(U,g.util.sizeFromShape(w),T,i.dtype);N=e.makeTensorInfo(T,i.dtype),e.texData.get(N.dataId).values=J}else N=function Mxt(t,n,e,r){const i=g.util.sizeFromShape(n),a=Ln({inputs:{x:t},attrs:{shape:[g.util.sizeFromShape(t.shape)/i,i]},backend:r}),u=Jd(a,t.dtype,"max",r),c=Ln({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}(x,w,T,e);return p&&e.disposeIntermediateTensorInfo(x),N}const Pxt={kernelName:g.Max,backendName:"webgl",kernelFunc:eV},Lxt=Eu({opSnippet:uS+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+qd+"\n  return result;\n",cpuKernelImpl:uyt}),kxt={kernelName:g.Maximum,backendName:"webgl",kernelFunc:Lxt},$xt={kernelName:g.MaxPool,backendName:"webgl",kernelFunc:function Fxt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;Zg(i,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:u}=r;g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const d=g.backend_util.computePool2DInfo(i.shape,s,o,1,a,u);if(1===d.filterWidth&&1===d.filterHeight&&g.util.arraysEqual(d.inShape,d.outShape))return bl({inputs:{x:i},backend:e});const p=new qg(d,"max",!1);return e.runWebGLProgram(p,[i],i.dtype)}},zxt={kernelName:g.MaxPool3D,backendName:"webgl",kernelFunc:function Bxt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{filterSize:s,strides:o,pad:a,dataFormat:u,dimRoundingMode:c}=r,p=g.backend_util.computePool3DInfo(i.shape,s,o,[1,1,1],a,c,u),v=new cS(p,"max",!1);return e.runWebGLProgram(v,[i],i.dtype)}};class Vxt{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const s=n.effectiveFilterHeight,o=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${s-1-n.padInfo.top}, ${o-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${s*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Uxt{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,d=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${u-1-n.padInfo.front}, ${c-1-n.padInfo.top}, ${d-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n           wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${u*c*d-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${d} +\n                  wR * ${d} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Gxt={kernelName:g.MaxPool3DGrad,backendName:"webgl",kernelFunc:function Wxt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s}=n,o=s,{filterSize:a,strides:u,pad:c,dimRoundingMode:d}=r,v=g.backend_util.computePool3DInfo(o.shape,a,u,[1,1,1],c,d),x=new cS(v,"max",!0),b=e.runWebGLProgram(x,[o],o.dtype),w=new Uxt(v),T=e.runWebGLProgram(w,[i,b],o.dtype);return e.disposeIntermediateTensorInfo(b),T}},jxt={kernelName:g.MaxPoolGrad,backendName:"webgl",kernelFunc:function Hxt(t){const{inputs:n,backend:e,attrs:r}=t,{dy:i,input:s,output:o}=n,a=s;Zg([s,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=r,v=g.backend_util.computePool2DInfo(a.shape,u,c,1,d,p),b=new qg(v,"max",!0),w=e.runWebGLProgram(b,[a],a.dtype),T=new Vxt(v),N=e.runWebGLProgram(T,[i,w],a.dtype);return e.disposeIntermediateTensorInfo(w),N}},Xxt={kernelName:g.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:a}=n,u=e;g.util.assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];g.util.assert(g.backend_util.eitherStridesOrDilationsAreOne(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);const d=g.backend_util.computePool2DInfo(r.shape,i,s,c,o),[p,v]=function Kxt(t,n,e,r){let i=new qg(e,"max",!1);const s=r.runWebGLProgram(i,[t],"float32");return i=new qg(e,"max",!0,!0,n),[s,r.runWebGLProgram(i,[t],"float32")]}(r,a,d,u);return[p,v]}},Yxt={kernelName:g.Mean,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{keepDims:i,axis:s}=n,o=e,a=r.shape.length,u=g.util.parseAxisParam(s,r.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a),p=null!=d,v=o.shouldExecuteOnCPU([r]),x=[];let b=r;if(p){if(v){const J=o.texData.get(b.dataId).values,ht=new Array(a);for(let zt=0;zt<ht.length;zt++)ht[zt]=r.shape[d[zt]];const Tt=aS(J,r.shape,r.dtype,d,ht);b=o.makeTensorInfo(ht,r.dtype),o.texData.get(b.dataId).values=Tt}else b=m1(r,d,o);x.push(b),c=g.backend_util.getInnerMostAxes(c.length,a)}g.backend_util.assertAxesAreInnerMostDims("sum",c,a);const[w,T]=g.backend_util.computeOutAndReduceShapes(b.shape,c);let N=w;i&&(N=g.backend_util.expandShapeToKeepDim(w,u));const S=function Zxt(t,n,e,r){const i=g.util.sizeFromShape(n),a=Ln({inputs:{x:t},attrs:{shape:[g.util.sizeFromShape(t.shape)/i,i]},backend:r}),u=Jd(a,"float32","mean",r),c=Ln({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}(b,T,N,o);for(const U of x)o.disposeIntermediateTensorInfo(U);return S}},qxt={kernelName:g.Min,backendName:"webgl",kernelFunc:function Qxt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=i.shape.length,u=g.util.parseAxisParam(s,i.shape);let c=u;const d=g.backend_util.getAxesPermutation(c,a);let p=i;null!=d&&(p=Zu({inputs:{x:i},backend:e,attrs:{perm:d}}),c=g.backend_util.getInnerMostAxes(c.length,i.shape.length)),g.backend_util.assertAxesAreInnerMostDims("min",c,a);const[v,x]=g.backend_util.computeOutAndReduceShapes(p.shape,c),w=Ln({inputs:{x:p},backend:e,attrs:{shape:[-1,g.util.sizeFromShape(x)]}}),T=Jd(w,w.dtype,"min",e);let N;return N=Ln(o?{inputs:{x:T},backend:e,attrs:{shape:g.backend_util.expandShapeToKeepDim(v,u)}}:{inputs:{x:T},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(T),null!=d&&e.disposeIntermediateTensorInfo(p),N}},eEt=Eu({opSnippet:uS+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+qd+"\n  return result;\n",cpuKernelImpl:lyt}),nEt={kernelName:g.Minimum,backendName:"webgl",kernelFunc:eEt};class rEt{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((d,p)=>d[0]+n[p]+d[1]);const i=n.length,s=ao(i),o=e.map(d=>d[0]).join(","),a=e.map((d,p)=>d[0]+n[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c="reflect"===r?0:1;this.userCode=1!==i?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${i}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${u}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class iEt{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((b,w)=>b[0]+n[w]+b[1]);const i=n.length,s=ao(i),o=e.map(b=>b[0]).join(","),a=e.map((b,w)=>b[0]+n[w]).join(","),u=Xu("rc",i),c=Xu("source",i),d=`${u[i-1]} < ${this.outputShape[i-1]}`,p=1===i?"source":`vec2(${c.slice(-2).join()})`,v="reflect"===r?0:1;let x="";if(1===i){const b=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${v};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${v};\n        }\n        source -= start;\n      `;x=`\n        ${s} rc = outputLoc;\n        ${b}\n        result[0] = getChannel(getX(${c.join()}), ${p});\n        ${u[i-1]} += 1;\n        if(${d}) {\n          ${b}\n          result[1] = getChannel(getX(${c.join()}), ${p});\n        }\n      `}else{const b=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${v}) +\n                gte * ((end - 1) * 2 - source + ${v});\n        source -= start;\n      `;x=`\n        ${s} rc = outputLoc;\n        ${b}\n        result[0] = getChannel(getX(${c.join()}), ${p});\n        ${u[i-1]} += 1;\n        if(${d}) {\n          ${b}\n          result[1] = getChannel(getX(${c.join()}), ${p});\n        }\n        rc = outputLoc;\n        ${u[i-2]} += 1;\n        if(${u[i-2]} < ${this.outputShape[i-2]}) {\n          ${b}\n          result[2] = getChannel(getX(${c.join()}), ${p});\n          ${u[i-1]} += 1;\n          if(${d}) {\n            ${b}\n            result[3] = getChannel(getX(${c.join()}), ${p});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${x}\n        setOutput(result);\n      }\n    `}}const oEt={kernelName:g.MirrorPad,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r}=t,{paddings:i,mode:s}=e,o=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new iEt(r.shape,i,s):new rEt(r.shape,i,s);return n.runWebGLProgram(o,[r],r.dtype)}},lEt=Eu({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+qd+"\n  return result;\n"}),cEt={kernelName:g.Mod,backendName:"webgl",kernelFunc:lEt};class hEt{constructor(n,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const nV=Eu({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),dEt={kernelName:g.RealDiv,backendName:"webgl",kernelFunc:nV},rV="return a - b;",iV=Eu({opSnippet:rV,packedOpSnippet:rV,supportsComplex:!0,cpuKernelImpl:Ayt}),fEt={kernelName:g.Sub,backendName:"webgl",kernelFunc:iV};function sV(t){const{inputs:n,backend:e,attrs:r}=t,{logits:i}=n,{dim:s}=r,o=g.util.parseAxisParam([s],i.shape),a=eV({inputs:{x:i},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),u=g.backend_util.expandShapeToKeepDim(a.shape,o),c=Ln({inputs:{x:a},backend:e,attrs:{shape:u}}),d=iV({inputs:{a:i,b:c},backend:e}),p=Zz({inputs:{x:d},backend:e}),v=g1({inputs:{x:p},backend:e,attrs:{axis:o,keepDims:!1}}),x=Ln({inputs:{x:v},backend:e,attrs:{shape:u}}),b=nV({inputs:{a:p,b:x},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(x),b}const pEt={kernelName:g.Softmax,backendName:"webgl",kernelFunc:sV},gEt={kernelName:g.Multinomial,backendName:"webgl",kernelFunc:function mEt(t){const{inputs:n,backend:e,attrs:r}=t,{logits:i}=n,{numSamples:s,seed:o,normalized:a}=r,u=a?i:sV({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),p=new hEt(u.shape[0],u.shape[1],s),x=e.runWebGLProgram(p,[u],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(u),x}},yEt=Ul+"\n  return -x;\n",xEt={kernelName:g.Neg,backendName:"webgl",kernelFunc:function _Et(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){const s=e.texData.get(r.dataId),[o,a]=hyt(s.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,o)}let i;return i=(0,g.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new ld(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new sh(r.shape,yEt),e.runWebGLProgram(i,[r],r.dtype)}},EEt=g.kernel_impls.nonMaxSuppressionV3Impl,bEt={kernelName:g.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function CEt(t){g.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u}=r,c=e.readSync(i.dataId),d=e.readSync(s.dataId),{selectedIndices:p}=EEt(c,d,o,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}},wEt=g.kernel_impls.nonMaxSuppressionV4Impl,SEt={kernelName:g.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function IEt(t){g.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r,d=e.readSync(i.dataId),p=e.readSync(s.dataId),{selectedIndices:v,validOutputs:x}=wEt(d,p,o,a,u,c);return[e.makeTensorInfo([v.length],"int32",new Int32Array(v)),e.makeTensorInfo([],"int32",new Int32Array([x]))]}},DEt=g.kernel_impls.nonMaxSuppressionV5Impl,NEt={kernelName:g.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function TEt(t){g.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:i,scores:s}=n,{maxOutputSize:o,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r,d=e.readSync(i.dataId),p=e.readSync(s.dataId),v=o,x=a,b=u,w=c,{selectedIndices:T,selectedScores:N}=DEt(d,p,v,x,b,w);return[e.makeTensorInfo([T.length],"int32",new Int32Array(T)),e.makeTensorInfo([N.length],"float32",new Float32Array(N))]}};class AEt{constructor(n,e,r,i){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${i}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const PEt={kernelName:g.OneHot,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{indices:i}=n,{dtype:s,depth:o,onValue:a,offValue:u}=r,c=g.util.sizeFromShape(i.shape),d=new AEt(c,o,a,u),p=Ln({inputs:{x:i},backend:e,attrs:{shape:[c]}}),v=e.runWebGLProgram(d,[p],s);e.disposeIntermediateTensorInfo(p);const b=Ln({inputs:{x:v},backend:e,attrs:{shape:[...i.shape,o]}});return e.disposeIntermediateTensorInfo(v),b}};function b1(t){const{inputs:n,backend:e}=t,{x:r}=n;if("complex64"===r.dtype){const i=Jg({inputs:{input:r},backend:e}),s=b1({inputs:{x:i},backend:e}),o=x1({inputs:{input:r},backend:e}),a=b1({inputs:{x:o},backend:e}),u=cd({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return ey({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const OEt={kernelName:g.ZerosLike,backendName:"webgl",kernelFunc:b1},REt={kernelName:g.OnesLike,backendName:"webgl",kernelFunc:function oV(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const i=Jg({inputs:{input:r},backend:e}),s=oV({inputs:{x:i},backend:e}),o=x1({inputs:{input:r},backend:e}),a=b1({inputs:{x:o},backend:e}),u=cd({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),u}return ey({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},kEt={kernelName:g.Pack,backendName:"webgl",kernelFunc:function LEt(t){const{inputs:n,backend:e,attrs:r}=t,{axis:i}=r;if(1===n.length)return fS({inputs:{input:n[0]},backend:e,attrs:{dim:i}});const s=n[0].shape,o=n[0].dtype;n.forEach(d=>{g.util.assertShapesMatch(s,d.shape,"All tensors passed to stack must have matching shapes"),g.util.assert(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=$z({inputs:n.map(d=>{const p=fS({inputs:{input:d},backend:e,attrs:{dim:i}});return a.push(p),p}),backend:e,attrs:{axis:i}});return a.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}};class FEt{constructor(n,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,d)=>c[0]+n[d]+c[1]);const i=n.length,s=ao(i),o=e.map(c=>c[0]).join(","),a=e.map((c,d)=>c[0]+n[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);this.userCode=1!==i?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${u}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class $Et{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((w,T)=>w[0]+n[T]+w[1]);const i=n.length,s=ao(i),o=e.map(w=>w[0]).join(","),a=e.map((w,T)=>w[0]+n[T]).join(","),u=Xu("rc",i),c=Xu("source",i),d=`${u[i-1]} < ${this.outputShape[i-1]}`,p=1===i?"source":`vec2(${c.slice(-2).join()})`,v=[`${s} rc = outputLoc;`,`${u[i-1]} += 1;\n       if(${d}) {\n      `,1===i?"":`}\n       rc = outputLoc;\n       ${u[i-2]} += 1;\n       if(${u[i-2]} < ${this.outputShape[i-2]}) {`,1===i?"":`  ${u[i-1]} += 1;\n         if(${d}) {`],x=1===i?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let w=0,T=1===i?2:4;w<T;w++)b+=`\n        ${v[w]}\n        if (${x}) {\n          result[${w}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${w}] = getChannel(getX(${c.join()}), ${p});\n        }\n      `;b+=1===i?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${b}\n        setOutput(result);\n      }\n    `}}const aV=t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{paddings:s,constantValue:o}=r;if(0===g.util.sizeFromShape(i.shape))return ey({backend:e,attrs:{shape:s.map((d,p)=>d[0]+i.shape[p]+d[1]),value:o,dtype:i.dtype}});const a=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $Et(i.shape,s,o):new FEt(i.shape,s,o);return e.runWebGLProgram(a,[i],i.dtype,[[o]])},BEt={kernelName:g.PadV2,backendName:"webgl",kernelFunc:aV},UEt=Eu({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+qd+"\n  return result;\n"}),WEt={kernelName:g.Pow,backendName:"webgl",kernelFunc:UEt},HEt={kernelName:g.Prod,backendName:"webgl",kernelFunc:function GEt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{axis:s,keepDims:o}=r,a=i.shape.length,u=[],c=g.util.parseAxisParam(s,i.shape);let d=c;const p=g.backend_util.getAxesPermutation(d,a);let x,v=i;if(null!=p&&(v=Zu({inputs:{x:i},backend:e,attrs:{perm:p}}),d=g.backend_util.getInnerMostAxes(d.length,a),u.push(v)),g.backend_util.assertAxesAreInnerMostDims("prod",d,a),e.shouldExecuteOnCPU([v])){const b=e.texData.get(v.dataId).values,{outVals:w,outShape:T,outDtype:N}=fyt(v.shape,v.dtype,b,d);x=e.makeTensorInfo(T,N,w)}else{const[b,w]=g.backend_util.computeOutAndReduceShapes(v.shape,d),T=g.util.sizeFromShape(w),N=Ln({inputs:{x:v},backend:e,attrs:{shape:[-1,T]}}),U=Jd(N,(0,g.sumOutType)(i.dtype),"prod",e);x=Ln({inputs:{x:U},backend:e,attrs:{shape:b}}),u.push(N),u.push(U)}if(o){u.push(x);const b=g.backend_util.expandShapeToKeepDim(x.shape,c);x=Ln({inputs:{x},backend:e,attrs:{shape:b}})}return u.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}},KEt={kernelName:g.RaggedGather,backendName:"webgl",kernelFunc:function jEt(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:o}=n,{outputRaggedRank:a}=r,u=i.map(N=>e.readSync(N.dataId)),c=i.map(N=>N.shape),d=e.readSync(s.dataId),p=e.readSync(o.dataId),[v,x,b]=pyt(u,c,d,s.shape,s.dtype,p,o.shape,a),w=v.map(N=>e.makeTensorInfo([N.length],"int32",N)),T=e.makeTensorInfo(b,s.dtype,x);return w.concat([T])}},ZEt={kernelName:g.RaggedRange,backendName:"webgl",kernelFunc:function XEt(t){const{inputs:n,backend:e}=t,{starts:r,limits:i,deltas:s}=n,o=e.readSync(r.dataId),a=e.readSync(i.dataId),u=e.readSync(s.dataId),[c,d]=myt(o,r.shape,r.dtype,a,i.shape,u,s.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([d.length],r.dtype,d)]}},QEt={kernelName:g.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function YEt(t){const{inputs:n,backend:e,attrs:r}=t,{shape:i,values:s,defaultValue:o,rowPartitionTensors:a}=n,{rowPartitionTypes:u}=r,c=e.readSync(i.dataId),d=e.readSync(s.dataId),p=e.readSync(o.dataId),v=a.map(T=>e.readSync(T.dataId)),x=a.map(T=>T.shape),[b,w]=gyt(c,i.shape,d,s.shape,s.dtype,p,o.shape,v,x,u);return e.makeTensorInfo(b,s.dtype,w)}},uV=t=>{const{backend:n,attrs:e}=t,{start:r,stop:i,step:s,dtype:o}=e,a=yyt(r,i,s,o);return n.makeTensorInfo([a.length],o,a)},qEt={kernelName:g.Range,backendName:"webgl",kernelFunc:uV},JEt=ms({opSnippet:"return 1.0 / x;"}),tCt={kernelName:g.Reciprocal,backendName:"webgl",kernelFunc:JEt},nCt=ms({opSnippet:Ul+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),rCt={kernelName:g.Relu,backendName:"webgl",kernelFunc:nCt},sCt=ms({opSnippet:Ul+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),oCt={kernelName:g.Relu6,backendName:"webgl",kernelFunc:sCt};class aCt{constructor(n,e,r,i,s){this.variableNames=["A"],this.outputShape=[];const[o,a,u,c]=n;this.outputShape=[o,e,r,c];const d=[i&&e>1?a-1:a,i&&r>1?u-1:u],p=[i&&e>1?e-1:e,i&&r>1?r-1:r];let v;v=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${v};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class uCt{constructor(n,e,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,u,c]=n;this.outputShape=[o,e,r,c];const d=[i&&e>1?a-1:a,i&&r>1?u-1:u],p=[i&&e>1?e-1:e,i&&r>1?r-1:r];let v;v=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]},\n          ${d[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${v};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const cCt={kernelName:g.ResizeBilinear,backendName:"webgl",kernelFunc:function lCt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:o,size:a}=r,[u,c]=a,d=(0,g.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new uCt(i.shape,u,c,s,o):new aCt(i.shape,u,c,s,o);return e.runWebGLProgram(d,[i],"float32")}};class hCt{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,s]=e,[,o,a]=n,u=[r&&o>1?i-1:i,r&&a>1?s-1:s],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],d=u[0]/c[0],p=u[1]/c[1],v=1/d,x=1/p,b=2*Math.ceil(v)+2,w=2*Math.ceil(x)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${d});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${v});\n        const float invWidthScale = float(${x});\n\n        const int winHeight = int(${b});\n        const int winWidth = int(${w});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const fCt={kernelName:g.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function dCt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i,dy:s}=n,{alignCorners:o}=r,a=new hCt(s.shape,i.shape,o);return e.runWebGLProgram(a,[s],s.dtype)}};class pCt{constructor(n,e,r,i,s){this.variableNames=["A"],this.outputShape=[];const[o,a,u,c]=n;this.outputShape=[o,e,r,c];const d=[i&&e>1?a-1:a,i&&r>1?u-1:u],p=[i&&e>1?e-1:e,i&&r>1?r-1:r];let x;x=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${x};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class mCt{constructor(n,e,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,u,c]=n;this.outputShape=[o,e,r,c];const d=[i&&e>1?a-1:a,i&&r>1?u-1:u],p=[i&&e>1?e-1:e,i&&r>1?r-1:r];let x;x=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]},\n          ${d[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${x};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${i?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const yCt={kernelName:g.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function gCt(t){const{inputs:n,backend:e,attrs:r}=t,{images:i}=n,{alignCorners:s,halfPixelCenters:o,size:a}=r,[u,c]=a,d=(0,g.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new mCt(i.shape,u,c,s,o):new pCt(i.shape,u,c,s,o);return e.runWebGLProgram(d,[i],i.dtype)}};class vCt{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,s]=e,[,o,a]=n,u=[r&&o>1?i-1:i,r&&a>1?s-1:s],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],d=u[0]/c[0],p=u[1]/c[1],v=1/d,x=1/p,b=2*Math.ceil(v)+2,w=2*Math.ceil(x)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${d});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${v});\n        const float invWidthScale = float(${x});\n\n        const int winHeight = int(${b});\n        const int winWidth = int(${w});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${u[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${u[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const xCt={kernelName:g.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function _Ct(t){const{inputs:n,backend:e,attrs:r}=t,{images:i,dy:s}=n,{alignCorners:o}=r,a=new vCt(s.shape,i.shape,o);return e.runWebGLProgram(a,[s],s.dtype)}};class ECt{constructor(n,e){this.variableNames=["x"];const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const s=n.map((a,u)=>(a=>-1!==e.indexOf(a)&&1!==n[a]?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`)(u)).join(","),o=ao(r);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class CCt{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;const i=Xu("rc",r),s=`${i[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${i[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ao(r);function v(b){const w=n.map((S,U)=>function x(b,w){return-1!==e.indexOf(b)&&1!==n[b]?`${n[b]} - ${w[b]} - 1`:`${w[b]}`}(U,b));return`getChannel(getX(${w.join(",")}), vec2(${w.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function u(b){return v(b)}(i.slice())};\n          if(${s}){\n            result.g = ${function c(b){return b[r-1]="("+b[r-1]+" + 1)",v(b)}(i.slice())};\n          }\n          if(${o}) {\n            result.b = ${function d(b){return b[r-2]="("+b[r-2]+" + 1)",v(b)}(i.slice())};\n            if(${s}) {\n              result.a = ${function p(b){return b[r-1]="("+b[r-1]+" + 1)",b[r-2]="("+b[r-2]+" + 1)",v(b)}(i.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const wCt={kernelName:g.Reverse,backendName:"webgl",kernelFunc:function bCt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{dims:s}=r,o=i.shape.length,a=g.util.parseAxisParam(s,i.shape);if(0===o)return bl({inputs:{x:i},backend:e});const u=(0,g.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CCt(i.shape,a):new ECt(i.shape,a);return e.runWebGLProgram(u,[i],i.dtype)}};class ICt{constructor(n,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=n[1],i=n[2];this.outputShape=n;let s="";s="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const SCt={kernelName:g.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:i,fillValue:s,center:o}=n,a=e,u=new ICt(r.shape,s),[c,d]=g.backend_util.getImageCenter(o,r.shape[1],r.shape[2]),p=[[c,d,Math.sin(i),Math.cos(i)]];return a.runWebGLProgram(u,[r],r.dtype,p)}},DCt=ms({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),TCt={kernelName:g.Round,backendName:"webgl",kernelFunc:DCt},NCt=ms({opSnippet:"return inversesqrt(x);",cpuKernelImpl:vyt}),ACt={kernelName:g.Rsqrt,backendName:"webgl",kernelFunc:NCt};class mS{constructor(n,e,r,i,s,o,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=ao(s.length),d=ao(o.length);let p="";1===r?p="i":2===r&&(p="i, j");let x="";1===i?x="i":2===i&&(x="i, coords[1]");let w="";u&&(w="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${s});\n\n        void main() {\n          ${d} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${p}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${x});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${w}), sum, float(found)));\n        }\n      `}}class MCt{constructor(n,e,r,i,s,o,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=ao(s.length),d=ao(o.length);let p="";1===r?p="i":2===r&&(p="i, j");let x="";1===i?x="i":2===i&&(x="i, coords[1]");let w="";u&&(w="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${s});\n\n        void main() {\n          ${d} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${n}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${p}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${x});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${w}), sum, found));\n        }\n      `}}const OCt={kernelName:g.ScatterNd,backendName:"webgl",kernelFunc:function PCt(t){const{inputs:n,backend:e,attrs:r}=t,{indices:i,updates:s}=n,{shape:o}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=g.backend_util.calculateShapes(s,i,o),v=[p/c,c];if(0===p)return e.makeTensorInfo(o,i.dtype);const x=Ln({inputs:{x:i},backend:e,attrs:{shape:[u,a]}}),b=Ln({inputs:{x:s},backend:e,attrs:{shape:[u,c]}}),w=e.makeTensorInfo([],"float32",new Float32Array([0]));let T;T=(0,g.env)().getBool("WEBGL_PACK")?new MCt(u,a,x.shape.length,b.shape.length,d,v):new mS(u,a,x.shape.length,b.shape.length,d,v);const N=e.runWebGLProgram(T,[b,x,w],b.dtype),S=Ln({inputs:{x:N},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(w),S}};class RCt{constructor(n,e,r,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===(0,g.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===i?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const kCt={kernelName:g.SearchSorted,backendName:"webgl",kernelFunc:function LCt(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:i,values:s}=n,{side:o}=r,a=new RCt(i.shape[0],i.shape[1],s.shape[1],o);return e.runWebGLProgram(a,[i,s],"int32",[[i.shape[1]]])}};class FCt{constructor(n,e,r){let i,s;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)s="resRC",i="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let d=0;d<e.length;d++)c.push(`${a[d]}`),d<n&&u.push(`${a[d]}`);i=u.join(),s=c.join()}const o=ao(r);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${i});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const BCt={kernelName:g.Select,backendName:"webgl",kernelFunc:function $Ct(t){const{inputs:n,backend:e}=t,{condition:r,t:i,e:s}=n,o=new FCt(r.shape.length,i.shape,i.shape.length);return e.runWebGLProgram(o,[r,i,s],(0,g.upcastType)(i.dtype,s.dtype))}},VCt=ms({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${g.backend_util.SELU_SCALEALPHA};\n  float scale = ${g.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),UCt={kernelName:g.Selu,backendName:"webgl",kernelFunc:VCt},GCt=ms({opSnippet:Up+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:xyt}),HCt={kernelName:g.Sigmoid,backendName:"webgl",kernelFunc:GCt},jCt=ms({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),KCt={kernelName:g.Sign,backendName:"webgl",kernelFunc:jCt},YCt=ms({opSnippet:Up+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${qd}\n  return result;\n`}),QCt={kernelName:g.Sin,backendName:"webgl",kernelFunc:YCt},qCt=ms({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),JCt={kernelName:g.Sinh,backendName:"webgl",kernelFunc:qCt},tbt=ms({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),ebt={kernelName:g.Softplus,backendName:"webgl",kernelFunc:tbt},rbt={kernelName:g.SpaceToBatchND,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{blockShape:s,paddings:o}=r;g.util.assert(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((N,S)=>N*S),u=[[0,0]];u.push(...o);for(let N=1+s.length;N<i.shape.length;++N)u.push([0,0]);const c=[],d=aV({inputs:{x:i},backend:e,attrs:{paddings:u,constantValue:0}}),p=g.backend_util.getReshaped(d.shape,s,a,!1),v=g.backend_util.getPermuted(p.length,s.length,!1),x=g.backend_util.getReshapedPermuted(d.shape,s,a,!1),b=Ln({inputs:{x:d},backend:e,attrs:{shape:p}}),w=Zu({inputs:{x:b},backend:e,attrs:{perm:v}}),T=Ln({inputs:{x:w},backend:e,attrs:{shape:x}});return c.push(d),c.push(b),c.push(w),c.forEach(N=>e.disposeIntermediateTensorInfo(N)),T}},sbt={kernelName:g.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function ibt(t){const{inputs:n,backend:e}=t,{indices:r,values:i,denseShape:s,defaultValue:o}=n;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n         ${i.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(r.dataId),u=e.readSync(i.dataId),c=e.readSync(s.dataId),d=e.readSync(o.dataId)[0],[p,v,x,b,w]=Cyt(a,r.shape,r.dtype,u,i.dtype,c,d);return[e.makeTensorInfo(v,r.dtype,p),e.makeTensorInfo([v[0]],i.dtype,x),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(T=>Number(T)))),e.makeTensorInfo([w.length],r.dtype,new Int32Array(w))]}},abt={kernelName:g.SparseReshape,backendName:"webgl",kernelFunc:function obt(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:i,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(e.readSync(i.dataId)),a=e.readSync(r.dataId),u=Array.from(e.readSync(s.dataId)),[c,d,p]=byt(a,r.shape,r.dtype,o,u);return[e.makeTensorInfo(d,r.dtype,c),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}},lbt={kernelName:g.SparseSegmentMean,backendName:"webgl",kernelFunc:function ubt(t){const{inputs:n,backend:e}=t,{data:r,indices:i,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const o=e.readSync(r.dataId),a=e.readSync(i.dataId),u=e.readSync(s.dataId),[c,d]=fz(o,r.shape,r.dtype,a,u,!0);return e.makeTensorInfo(d,r.dtype,c)}},hbt={kernelName:g.SparseSegmentSum,backendName:"webgl",kernelFunc:function cbt(t){const{inputs:n,backend:e}=t,{data:r,indices:i,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const o=e.readSync(r.dataId),a=e.readSync(i.dataId),u=e.readSync(s.dataId),[c,d]=fz(o,r.shape,r.dtype,a,u);return e.makeTensorInfo(d,r.dtype,c)}},fbt={kernelName:g.SparseToDense,backendName:"webgl",kernelFunc:function dbt(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:o}=n,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:v}=g.backend_util.calculateShapes(s,i,a);if("string"===s.dtype){const N=e.bufferSync(i),S=e.bufferSync(s),U=g.util.decodeString(e.readSync(o.dataId)[0]),J=_yt(N,S,a,v,d,c,u,p,U,!1);return e.makeTensorInfo(a,J.dtype,J.values)}const b=new mS(c,u,i.shape.length,s.shape.length,p,[v,1],!1),w=e.runWebGLProgram(b,[s,i,o],s.dtype),T=Ln({inputs:{x:w},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(w),T}},mbt={kernelName:g.SplitV,backendName:"webgl",kernelFunc:function pbt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{numOrSizeSplits:s,axis:o}=r,a=g.util.parseAxisParam(o,i.shape)[0],u=g.backend_util.prepareSplitSize(i,s,a),d=new Array(i.shape.length).fill(0),p=i.shape.slice();return u.map(v=>{const x=[...p];x[a]=v;const b=Wp({inputs:{x:i},backend:e,attrs:{begin:d,size:x}});return d[a]+=v,b})}},lV="return sqrt(x);",gbt=ms({opSnippet:lV,packedOpSnippet:lV,cpuKernelImpl:wyt}),ybt={kernelName:g.Sqrt,backendName:"webgl",kernelFunc:gbt},vbt=ms({opSnippet:"return x * x;"}),_bt={kernelName:g.Square,backendName:"webgl",kernelFunc:vbt},cV="return (a - b) * (a - b);",xbt=Eu({opSnippet:cV,packedOpSnippet:cV}),Ebt={kernelName:g.SquaredDifference,backendName:"webgl",kernelFunc:xbt},bbt={kernelName:g.StaticRegexReplace,backendName:"webgl",kernelFunc:function Cbt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n;if("string"!==i.dtype)throw new Error("Input must be of datatype string");const s=e.readSync(i.dataId),o=g.backend_util.fromUint8ToStringArray(s),a=Iyt(o,"string",r);return e.makeTensorInfo(i.shape,"string",a)}},Ibt={kernelName:g.Step,backendName:"webgl",kernelFunc:function wbt({inputs:t,attrs:n,backend:e}){const{x:r}=t,s=new sh(r.shape,Ul+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `);return e.runWebGLProgram(s,[r],r.dtype)}};class Sbt{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;const i=r.length,s=ao(r.length),o=ao(r.length);let a="";if(1===i)a="coords * strides + begin";else{let u=0;a=r.map((c,d)=>(u++,1===r.length?`coords * strides[${d}] + begin[${d}]`:`coords[${u-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${n});\n      ${s} strides = ${s}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const Tbt={kernelName:g.StridedSlice,backendName:"webgl",kernelFunc:function Dbt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{begin:s,end:o,strides:a,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:v}=r,{finalShapeSparse:x,finalShape:b,isIdentity:w,sliceDim0:T,isSimpleSlice:N,begin:S,end:U,strides:J}=g.slice_util.sliceInfo(i.shape,s,o,a,u,c,d,p,v);let ht;if(w)ht=Ln({inputs:{x:i},backend:e,attrs:{shape:b}});else if(T||N){g.util.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const Pt=g.slice_util.computeOutShape(S,U,J),zt=Wp({inputs:{x:i},backend:e,attrs:{begin:S,size:Pt}});ht=Ln({inputs:{x:zt},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(zt)}else if(e.shouldExecuteOnCPU([i])){const zt=e.readSync(i.dataId),Ot=(0,g.buffer)(i.shape,i.dtype,zt),le=Syt(x,Ot,J,S);ht=e.makeTensorInfo(b,i.dtype,le.values)}else{const zt=new Sbt(S,J,x);ht=e.runWebGLProgram(zt,[i],i.dtype)}const Tt=Ln({inputs:{x:ht},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(ht),Tt}},Abt={kernelName:g.StringNGrams,backendName:"webgl",kernelFunc:function Nbt(t){const{inputs:n,backend:e,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:d,dataSplits:p}=n,v=e.readSync(d.dataId),x=e.readSync(p.dataId),[b,w]=Dyt(v,x,i,s,o,a,u,c);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",w)]}},Pbt={kernelName:g.StringSplit,backendName:"webgl",kernelFunc:function Mbt(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:o}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(s.dataId),u=e.readSync(o.dataId)[0],[c,d,p]=Tyt(a,u,i),v=d.length;return[e.makeTensorInfo([v,2],"int32",c),e.makeTensorInfo([v],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}},Rbt={kernelName:g.StringToHashBucketFast,backendName:"webgl",kernelFunc:function Obt(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:i}=r,{input:s}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(s.dataId),a=Nyt(o,i);return e.makeTensorInfo(s.shape,"int32",a)}},Lbt=ms({opSnippet:"return tan(x);"}),kbt={kernelName:g.Tan,backendName:"webgl",kernelFunc:Lbt},Fbt=ms({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),$bt={kernelName:g.Tanh,backendName:"webgl",kernelFunc:Fbt},zbt={kernelName:g.TensorScatterUpdate,backendName:"webgl",kernelFunc:function Bbt(t){const{inputs:n,backend:e}=t,{tensor:i,indices:s,updates:o}=n,{sliceRank:a,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=g.backend_util.calculateShapes(o,s,i.shape),v=[p/c,c];if(0===p)return e.makeTensorInfo(i.shape,s.dtype);const x=Ln({inputs:{x:s},backend:e,attrs:{shape:[u,a]}}),b=Ln({inputs:{x:o},backend:e,attrs:{shape:[u,c]}}),w=Ln({inputs:{x:i},backend:e,attrs:{shape:v}}),T=new mS(u,a,x.shape.length,b.shape.length,d,v,!1,!0),N=e.runWebGLProgram(T,[b,x,w],w.dtype),S=Ln({inputs:{x:N},backend:e,attrs:{shape:i.shape}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N),S}};class Vbt{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let o=0;o<r.length;o++)r[o]=n[o]*e[o];this.outputShape=r,this.rank=r.length;const i=ao(this.rank),s=function Ubt(t){const n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${t[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<t.length;i++)r.push(`imod(${e[i]}, ${t[i]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function hV(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{reps:s}=r;if("string"===i.dtype||i.shape.length>5){const u=e.readSync(i.dataId),c="string"===i.dtype?u.map(v=>g.util.decodeString(v)):u,d=(0,g.buffer)(i.shape,i.dtype,c),p=Myt(d,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}const o=new Vbt(i.shape,s);return e.runWebGLProgram(o,[i],i.dtype)}const Wbt={kernelName:g.Tile,backendName:"webgl",kernelFunc:hV};class Gbt{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Hbt{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function ef(t,n){null!==n&&t.disposeIntermediateTensorInfo(n)}function dV(t){let n=1;for(;n<t;)n*=2;return n}const Kbt={kernelName:g.TopK,backendName:"webgl",kernelFunc:function jbt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i}=n,{k:s,sorted:o}=r,a=(0,g.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=(0,g.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,d=c[c.length-1];if(e.shouldExecuteOnCPU([i])||d<a||s>u){const le=e.readSync(i.dataId),[ge,Ae]=Pyt(le,c,i.dtype,s,o);return[e.makeTensorInfo(ge.shape,ge.dtype,ge.values),e.makeTensorInfo(Ae.shape,Ae.dtype,Ae.values)]}if(0===s)return c[c.length-1]=0,[e.makeTensorInfo(c,i.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===d)return[i,ey({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const p=e.texData.get(i.dataId),v=null!==p&&p.isPacked,x=v?e.unpackTensor(i):i,w=g.util.sizeFromShape(c)/d,T=Ln({inputs:{x},attrs:{shape:[w,d]},backend:e});v&&ef(e,x);const N=dV(s),S=dV(d);let U=null;const J=()=>null===U?[T,T]:[T,U],ht=(le,ge,Ae)=>{const Re=J(),ve=new Gbt(Ae),Ke=U;U=e.runWebGLProgram(ve,Re,"int32",[[d],[null===U?1:0],[Number.NEGATIVE_INFINITY],[le],[ge]]),ef(e,Ke)};for(let le=1;le<N;le*=2){const ge=2*le;for(let Ae=le;Ae>=1;Ae/=2)ht(ge,Ae,[w,S])}for(let le=S;le>N;le/=2){const ge=J(),Ae=new Hbt([w,le/2]),Ne=U;U=e.runWebGLProgram(Ae,ge,"int32",[[d],[null===U?1:0],[N]]),ef(e,Ne);const Se=N/2,Ke=2*Se;for(let Le=Se;Le>=1;Le/=2)ht(Ke,Le,U.shape)}let Tt=U;U=Wp({inputs:{x:U},backend:e,attrs:{begin:0,size:[w,s]}}),ef(e,Tt);let Pt=tV({inputs:{x:T,indices:U},backend:e,attrs:{axis:1,batchDims:1}});ef(e,T);const zt=c.slice(0,-1);zt.push(s),Tt=U,U=Ln({inputs:{x:U},attrs:{shape:zt},backend:e}),ef(e,Tt);const Ot=Pt;return Pt=Ln({inputs:{x:Pt},attrs:{shape:zt},backend:e}),ef(e,Ot),[Pt,U]}};class Xbt{constructor(n,e,r,i,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===r?1:2;let u;switch(i){case"constant":default:u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${u} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Ybt={kernelName:g.Transform,backendName:"webgl",kernelFunc:function Zbt(t){const{inputs:n,backend:e,attrs:r}=t,{image:i,transforms:s}=n,{interpolation:o,fillMode:a,fillValue:u,outputShape:c}=r,[d,p,v,x]=i.shape,[b,w]=c??[p,v],N=new Xbt(p,v,o,a,u,[d,b,w,x]);return e.runWebGLProgram(N,[i,s],"float32")}},qbt={kernelName:g.Unique,backendName:"webgl",kernelFunc:function Qbt(t){const{inputs:n,attrs:e,backend:r}=t,{axis:i}=e,{x:s}=n;Zg(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:a,outputShape:u,indices:c}=Oyt(o,i,s.shape,s.dtype);return[r.makeTensorInfo(u,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},twt={kernelName:g.Unpack,backendName:"webgl",kernelFunc:function Jbt(t){const{inputs:n,backend:e,attrs:r}=t,{value:i}=n;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i,a=o.shape.length,u=i.shape[s],c=new Array(a-1);let d=0;for(let w=0;w<a;w++)w!==s&&(c[d++]=o.shape[w]);const p=[],v=new Array(a).fill(0),x=o.shape.slice();x[s]=1;const b=new Array(u);for(let w=0;w<b.length;w++){v[s]=w;const T=Wp({inputs:{x:o},backend:e,attrs:{begin:v,size:x}}),N=Ln({inputs:{x:T},backend:e,attrs:{shape:c}});b[w]=N,p.push(T)}return p.forEach(w=>e.disposeIntermediateTensorInfo(w)),b}};class ewt{constructor(n,e){this.variableNames=["x","segmentIds"];const r=n.windowSize,i=n.batchSize,s=n.inSize,o=n.numSegments,a=o*Math.ceil(s/r);this.outputShape=[i,a];const d=4*Math.floor(r/4),p=r%4,v="\n        sumValue += dot(values, segFilter);\n    ";let x="";s%r>0&&(x=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let b="";s%r>0&&(b=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${x}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${b}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${v}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${v}\n        } else if (${2===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${v}\n        } else if (${3===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${v}\n        }\n        setOutput(sumValue);\n      }\n    `}}const iwt=[D0t,N0t,P0t,L0t,F0t,z0t,U0t,G0t,X0t,Y0t,J0t,nvt,svt,lvt,dvt,pvt,gvt,xvt,Cvt,wvt,Tvt,Lvt,Fvt,Vvt,Wvt,Xvt,Yvt,t_t,c0t,r_t,u_t,d_t,v_t,E_t,b_t,I_t,D_t,M_t,O_t,k_t,$_t,z_t,U_t,H_t,K_t,Q_t,J_t,n1t,s1t,a1t,l1t,f1t,m1t,v1t,x1t,E1t,b1t,I1t,D1t,N1t,M1t,O1t,k1t,B1t,V1t,G1t,K1t,Z1t,Q1t,l0t,J1t,o_t,ext,rxt,sxt,d0t,axt,lxt,hxt,pxt,yxt,_xt,Ext,bxt,Dxt,Axt,Pxt,kxt,$xt,zxt,Gxt,jxt,Xxt,Yxt,qxt,nEt,oEt,cEt,gEt,m0t,xEt,bEt,SEt,NEt,Gvt,PEt,REt,kEt,BEt,WEt,p0t,HEt,KEt,ZEt,QEt,qEt,Hvt,dEt,tCt,rCt,oCt,y0t,cCt,fCt,yCt,xCt,wCt,SCt,TCt,ACt,OCt,kCt,BCt,UCt,HCt,KCt,QCt,JCt,Ovt,pEt,ebt,rbt,sbt,abt,lbt,hbt,fbt,mbt,ybt,_bt,Ebt,bbt,Ibt,Tbt,Abt,Pbt,Rbt,fEt,w0t,kbt,$bt,zbt,Wbt,Kbt,Ybt,I0t,qbt,twt,{kernelName:g.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function nwt(t){const{inputs:n,backend:e,attrs:r}=t,{x:i,segmentIds:s}=n,{numSegments:o}=r,a=i.shape.length,u=[];let c=0;const d=g.backend_util.getAxesPermutation([c],a);let p=i;null!=d&&(p=Zu({inputs:{x:i},backend:e,attrs:{perm:d}}),u.push(p),c=g.backend_util.getInnerMostAxes(1,a)[0]);const v=g.backend_util.segment_util.computeOutShape(p.shape,c,o),x=g.util.sizeFromShape([p.shape[c]]),b=Ln({inputs:{x:p},backend:e,attrs:{shape:[-1,x]}});u.push(b);const w=(0,g.sumOutType)(i.dtype),T=(J,ht,Tt,Pt,zt)=>{const Ot=J.shape[0],le=J.shape[1],ge=g.backend_util.segment_util.segOpComputeOptimalWindowSize(le,zt),Re=new ewt({windowSize:ge,inSize:le,batchSize:Ot,numSegments:zt},ht),ve=e.compileAndRun(Re,[J,Tt],Pt);if(u.push(ve),ve.shape[1]===zt)return ve;const Ne=uV({backend:e,attrs:{start:0,stop:zt,step:1,dtype:"float32"}}),Se=hV({inputs:{x:Ne},backend:e,attrs:{reps:[le/ge]}});return u.push(Ne),u.push(Se),T(ve,ht,Se,Pt,zt)},S=Ln({inputs:{x:T(b,"unsortedSegmentSum",s,w,o)},backend:e,attrs:{shape:v}});let U=S;if(null!=d){u.push(S);const J=g.backend_util.getUndoAxesPermutation(d);U=Zu({inputs:{x:U},backend:e,attrs:{perm:J}})}return u.forEach(J=>e.disposeIntermediateTensorInfo(J)),U}},OEt];for(const t of iwt)(0,g.registerKernel)(t);var owt=y(2155);const awt=["video"],uwt=["canvas"];let lwt=(()=>{class t{constructor(e){this.tfMlStateService=e}ngOnInit(){var e=this;return(0,Mr.Z)(function*(){yield g.setBackend("webgl");const r=yield owt.load();console.log("COCO-SSD model loaded:",r);const i=e.videoElement.nativeElement,s=e.canvas.nativeElement;try{const o=yield navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});i.srcObject=o,i.onloadedmetadata=()=>{s.width=i.videoWidth,s.height=i.videoHeight,e.detectObjects(i,r,s)}}catch(o){console.error("Erro ao acessar a c\xe2mera:",o)}})()}detectObjects(e,r,i){var s=this;return(0,Mr.Z)(function*(){const o=i.getContext("2d");o.clearRect(0,0,i.width,i.height);const a=yield r.detect(e);a.length>0?a.forEach(u=>{s.checkIsObjectSelected(u,e,i),o.beginPath(),o.lineWidth=1,o.strokeStyle="white",o.fillStyle="rgba(0, 255, 0, 0.25)",o.rect(u.bbox[0],u.bbox[1],u.bbox[2],u.bbox[3]),o.stroke(),o.fill();const w=`${u.class} - ${Math.round(100*u.score)}%`,T=u.bbox[2];o.font="16px Arial",o.fillStyle="black",o.fillRect(u.bbox[0],u.bbox[1]-20,T,20),o.fillStyle="white",o.fillText(w,u.bbox[0],u.bbox[1]>10?u.bbox[1]-5:10)}):console.log("Nenhum objeto detectado."),requestAnimationFrame(()=>s.detectObjects(e,r,i))})()}checkIsObjectSelected(e,r,i){if("traffic light"===e.class){const s={prediction:e,photo:this.capturePhotoObjectFound(r,i)};return this.tfMlStateService.objectIsFound(s),!0}return!1}capturePhotoObjectFound(e,r){return r.width=e.videoWidth,r.height=e.videoHeight,r.getContext("2d").drawImage(e,0,0),r.toDataURL("image/png")}static#t=this.\u0275fac=function(r){return new(r||t)(vn(pk))};static#e=this.\u0275cmp=ca({type:t,selectors:[["app-tf-ml"]],viewQuery:function(r,i){if(1&r&&(zE(awt,5),zE(uwt,5)),2&r){let s;M0(s=P0())&&(i.videoElement=s.first),M0(s=P0())&&(i.canvas=s.first)}},decls:5,vars:0,consts:[[1,"video-container"],["autoplay",""],["video",""],["canvas",""]],template:function(r,i){1&r&&(Ka(0,"div",0),vu(1,"video",1,2)(3,"canvas",null,3),Xa())},styles:[".video-container[_ngcontent-%COMP%]{position:relative}video[_ngcontent-%COMP%]{width:20rem;height:auto}canvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:20rem;height:auto}"]})}return t})(),cwt=(()=>{class t{constructor(e){this.tfMlStateService=e,this.coordinatesArray=[],this.coordinatesArrayAreaToExplore=[],this.displacementLimit=10,this.speedLimit=5,this.accelerationLimit=20,this.timeInterval=500,this.lastPosition=null,this.lastSpeed=0,this.lastTimestamp=0,this.totalDistance=0,this.pontos=0,this.mensagem="0-Inicio",this.objectFoundMarkerAdded=!1}ngOnInit(){this.tfMlStateService.objectFound$.subscribe(e=>this.objectFound=e),this.createMap()}createMap(){this.map=Uu.map("map").setView([0,0],1);const e=Uu.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png",{maxZoom:19,minZoom:0,attribution:'&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'});this.polyline=Uu.polyline([],{color:"#C4EEF2",weight:7,opacity:1}).addTo(this.map),this.polylineBorder=Uu.polyline([],{color:"#025159",weight:4}).addTo(this.map),this.heatMap=Uu.heatLayer([],{radius:16}),e.addTo(this.map),this.polyline.addTo(this.map),this.polylineBorder.addTo(this.map),this.heatMap.addTo(this.map),this.geoJsonDrawLimit(),setTimeout(()=>{this.zoneToExplore()},3e3)}startTracking(){let e=!1;navigator.geolocation?this.watchId=navigator.geolocation.watchPosition(i=>{this.updateCoordinates(i),e||(this.updateCurrentViewPoint([i.coords.latitude,i.coords.longitude]),e=!0)},i=>i,{enableHighAccuracy:!0,timeout:100,maximumAge:0}):alert("Navegador n\xe3o suportado")}updateCurrentViewPoint(e){this.map.flyTo(e,19,{duration:2,easeLinearity:.25,animate:!0})}stopTracking(){navigator.geolocation.clearWatch(this.watchId),this.pointIcon&&this.map.removeLayer(this.pointIcon),this.pointIcon=Uu.icon({iconUrl:"assets/icons/finish.png",iconSize:[32,32]}),Uu.marker(this.coordinatesArray[this.coordinatesArray.length-1],{icon:this.pointIcon}).addTo(this.map).bindPopup("Chegada")}updateCoordinates(e){const r=e.coords.latitude,i=e.coords.longitude,s=e.timestamp;if(this.checkIsInsideAreaToExplore(r,i),this.lastPosition&&this.lastTimestamp){this.pontos++,this.mensagem="criando novos pontos - "+this.pontos+" - accuracy= "+e.coords.accuracy+" metros";const o=this.calculateDistanceHaversinesFormula(r,i,this.lastPosition.coords.latitude,this.lastPosition.coords.longitude),a=s-this.lastTimestamp;o<=this.displacementLimit&&o/a*1e3<=this.speedLimit&&a>=this.timeInterval?(this.addPathLine(r,i),this.totalDistance=this.calculateTotalDistanceLeafletMethod(this.polyline),this.calculeExploredArea()):this.mensagem="Ponto descartado devido a filtros."}else this.mensagem="Cria primeiro ponto",this.addPathLine(r,i);this.lastPosition=e,this.lastSpeed=this.speed,this.lastTimestamp=s}addPathLine(e,r){this.polyline.addLatLng([e,r]),this.polylineBorder.addLatLng([e,r]),this.heatMap.addLatLng([e,r,2]),this.coordinatesArray.push([e,r,2]),this.createIcons(),this.objectFound.prediction&&this.markerObjectFound()}createIcons(){const e=Uu.icon({iconUrl:"assets/icons/start.png",iconSize:[32,32]});Uu.marker(this.coordinatesArray[0],{icon:e}).addTo(this.map).bindPopup("Inicio"),this.pointIcon&&this.map.removeLayer(this.pointIcon);const r=Uu.icon({iconUrl:"assets/icons/point.png",iconSize:[32,32]});this.pointIcon=Uu.marker(this.coordinatesArray[this.coordinatesArray.length-1],{icon:r}).addTo(this.map).bindPopup("Ponto")}calculateDistanceHaversinesFormula(e,r,i,s){const a=e*Math.PI/180,u=i*Math.PI/180,c=(i-e)*Math.PI/180,d=(s-r)*Math.PI/180,p=Math.sin(c/2)*Math.sin(c/2)+Math.cos(a)*Math.cos(u)*Math.sin(d/2)*Math.sin(d/2);return 2*Math.atan2(Math.sqrt(p),Math.sqrt(1-p))*6371e3}calculateTotalDistanceLeafletMethod(e){let r=0;const i=e.getLatLngs();for(let s=0;s<i.length-1;s++)r+=i[s].distanceTo(i[s+1]);return r/1e3}zoneToExplore(){Uu.circle([-23.217103741057613,-45.90646211989807],{color:"#FA7F08",fillColor:"#F24405",fillOpacity:.3,weight:1,radius:50}).addTo(this.map).bindPopup("Zona de trabalho = 100 metros de di\xe2metro")}geoJsonDrawLimit(){const e=Uu.geoJSON(this.geoJson(),{style:{fillColor:"rgba(255, 0, 0, 0.5)",fillOpacity:0,color:"#8C034E",weight:2,opacity:.8}}).addTo(this.map);this.map.fitBounds(e.getBounds());const r=vb(this.geoJson());Uu.popup().setLatLng(e.getBounds().getCenter()).setContent("\xc1rea: "+r.toFixed(2)+" m<sup>2</sup>").openOn(this.map)}calculeExploredArea(){if(this.coordinatesArrayAreaToExplore.length<3)return;const e=vb(this.geoJson()),o=vb(function FJ(t,n,e){var r=(e=e||{}).units||"kilometers",i=e.steps||8;if(!t)throw new Error("geojson is required");if("object"!=typeof e)throw new Error("options must be an object");if("number"!=typeof i)throw new Error("steps must be an number");if(void 0===n)throw new Error("radius is required");if(i<=0)throw new Error("steps must be greater than 0");var s=[];switch(t.type){case"GeometryCollection":return xv(t,function(o){var a=u_(o,n,r,i);a&&s.push(a)}),up(s);case"FeatureCollection":return lb(t,function(o){var a=u_(o,n,r,i);a&&lb(a,function(u){u&&s.push(u)})}),up(s)}return u_(t,n,r,i)}(_v(this.coordinatesArrayAreaToExplore.map(a=>[a[1],a[0]])),.002,{units:"kilometers"}));return this.totalAreaExplored=o/e*100,this.totalAreaExplored.toFixed(2)+"%"}checkIsInsideAreaToExplore(e,r){db(ap([r,e]),sg(this.geoJson().features[0].geometry.coordinates))&&this.coordinatesArrayAreaToExplore.push([e,r])}ngOnDestroy(){this.map&&this.map.remove()}markerObjectFound(){if(!this.objectFoundMarkerAdded){const e=Uu.icon({iconUrl:"assets/icons/traffic-light.png",iconSize:[32,32]});let r=Uu.marker(this.coordinatesArray[this.coordinatesArray.length-1],{icon:e}).addTo(this.map).bindPopup("Objeto Encontrado");const i=this.createPhotoBase64ToBlob();r.bindPopup(`<img src="${i}" width="150">`),this.objectFoundMarkerAdded=!0,r.on("click",()=>{r.openPopup()})}}createPhotoBase64ToBlob(){const e=atob(this.objectFound.photo.split(",")[1]),r=new Uint8Array(e.length);for(let o=0;o<e.length;o++)r[o]=e.charCodeAt(o);const i=new Blob([r],{type:"image/png"});return URL.createObjectURL(i)}geoJson(){return{type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:{coordinates:[[[-45.89634664432393,-23.23426051912533],[-45.89726763410698,-23.23440391159032],[-45.89725845480686,-23.235070262785584],[-45.89632522595693,-23.2350280887581],[-45.89634664432393,-23.23426051912533]]],type:"Polygon"}}]}}static#t=this.\u0275fac=function(r){return new(r||t)(vn(pk))};static#e=this.\u0275cmp=ca({type:t,selectors:[["app-root"]],decls:43,vars:10,consts:[[1,"container"],[1,"map-container"],["id","map",1,"map"],[3,"click"],["for","fname"],["type","number",3,"ngModel","ngModelChange"],["target","_blank","href","https://icons8.com"]],template:function(r,i){1&r&&(Ka(0,"div",0)(1,"div",1),vu(2,"div",2),Xa(),Ka(3,"button",3),_u("click",function(){return i.startTracking()}),Jl(4,"Iniciar"),Xa(),Ka(5,"button",3),_u("click",function(){return i.stopTracking()}),Jl(6,"Finalizar"),Xa(),vu(7,"br"),Ka(8,"label",4),Jl(9,"Limite de deslocamento m\xe1ximo em metros:"),Xa(),vu(10,"br"),Ka(11,"input",5),_u("ngModelChange",function(o){return i.displacementLimit=o}),Xa(),vu(12,"br"),Ka(13,"label",4),Jl(14,"Limite de velocidade m\xe1xima em metros por segundo"),Xa(),vu(15,"br"),Ka(16,"input",5),_u("ngModelChange",function(o){return i.speedLimit=o}),Xa(),vu(17,"br"),Ka(18,"label",4),Jl(19,"Limite de acelera\xe7\xe3o m\xe1xima em metros por segundo ao quadrado"),Xa(),vu(20,"br"),Ka(21,"input",5),_u("ngModelChange",function(o){return i.accelerationLimit=o}),Xa(),vu(22,"br"),Ka(23,"label",4),Jl(24,"Intervalo de tempo entre leituras de GPS em milissegundos"),Xa(),vu(25,"br"),Ka(26,"input",5),_u("ngModelChange",function(o){return i.timeInterval=o}),Xa(),Ka(27,"div"),vu(28,"br"),Ka(29,"span"),Jl(30),Xa(),vu(31,"br"),Ka(32,"span"),Jl(33),function uM(t,n){const e=Lr();let r;const i=t+Rr;e.firstCreatePass?(r=function q6(t,n){if(n)for(let e=n.length-1;e>=0;e--){const r=n[e];if(t===r.name)return r}}(n,e.pipeRegistry),e.data[i]=r,r.onDestroy&&(e.destroyHooks??=[]).push(i,r.onDestroy)):r=e.data[i];const s=r.factory||(r.factory=oh(r.type)),a=vs(vn);try{const u=Ny(!1),c=s();return Ny(u),function TG(t,n,e,r){e>=t.data.length&&(t.data[e]=null,t.blueprint[e]=null),n[e]=r}(e,Qe(),i,c),c}finally{vs(a)}}(34,"number"),Xa(),vu(35,"br"),Ka(36,"span"),Jl(37),Xa(),vu(38,"br"),Jl(39," icon by "),Ka(40,"a",6),Jl(41,"Icons8"),Xa()(),vu(42,"app-tf-ml"),Xa()),2&r&&(Lh(11),Uf("ngModel",i.displacementLimit),Lh(5),Uf("ngModel",i.speedLimit),Lh(5),Uf("ngModel",i.accelerationLimit),Lh(5),Uf("ngModel",i.timeInterval),Lh(4),CE(i.mensagem),Lh(3),Dm("distancia Total = ",lM(34,7,i.totalDistance,"1.3-3")," Km"),Lh(4),Dm("total da \xe1rea explorada = ",i.calculeExploredArea(),""))},dependencies:[l_,Lw,zk,Rw,lwt,UP],styles:[".container[_ngcontent-%COMP%]{width:500px;height:500px}.map[_ngcontent-%COMP%]{height:100%;width:100%}.map-container[_ngcontent-%COMP%]{border:1px solid #6665ff;height:400px}"]})}return t})(),hwt=(()=>{class t{static#t=this.\u0275fac=function(r){return new(r||t)};static#e=this.\u0275mod=Yr({type:t,bootstrap:[cwt]});static#n=this.\u0275inj=$n({imports:[x9,oZ,Utt]})}return t})();v9().bootstrapModule(hwt).catch(t=>console.error(t))},2155:function(Lt,ut,y){var $=y(7156).default;!function(V,H,Q){"use strict";const Y={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class R{constructor(k,A){this.modelPath=A||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(k)}/model.json`}getPrefix(k){return"lite_mobilenet_v2"===k?`ssd${k}`:`ssd_${k}`}load(){var k=this;return $(function*(){k.model=yield H.loadGraphModel(k.modelPath);const A=Q.zeros([1,300,300,3],"int32"),X=yield k.model.executeAsync(A);yield Promise.all(X.map(Z=>Z.data())),X.map(Z=>Z.dispose()),A.dispose()})()}infer(k,A,X){var Z=this;return $(function*(){const G=Q.tidy(()=>(k instanceof Q.Tensor||(k=Q.browser.fromPixels(k)),Q.expandDims(k))),it=G.shape[1],wt=G.shape[2],K=yield Z.model.executeAsync(G),st=K[0].dataSync(),et=K[1].dataSync();G.dispose(),Q.dispose(K);const[dt,lt]=Z.calculateMaxScores(st,K[0].shape[1],K[0].shape[2]),St=Q.getBackend();"webgl"===Q.getBackend()&&Q.setBackend("cpu");const q=Q.tidy(()=>{const pt=Q.tensor2d(et,[K[1].shape[1],K[1].shape[3]]);return Q.image.nonMaxSuppression(pt,dt,A,X,X)}),ft=q.dataSync();return q.dispose(),St!==Q.getBackend()&&Q.setBackend(St),Z.buildDetectedObjects(wt,it,et,dt,ft,lt)})()}buildDetectedObjects(k,A,X,Z,G,it){const wt=G.length,K=[];for(let st=0;st<wt;st++){const et=[];for(let ft=0;ft<4;ft++)et[ft]=X[4*G[st]+ft];const dt=et[0]*A,lt=et[1]*k,St=et[2]*A,q=et[3]*k;et[0]=lt,et[1]=dt,et[2]=q-lt,et[3]=St-dt,K.push({bbox:et,class:Y[it[G[st]]+1].displayName,score:Z[G[st]]})}return K}calculateMaxScores(k,A,X){const Z=[],G=[];for(let it=0;it<A;it++){let wt=Number.MIN_VALUE,K=-1;for(let st=0;st<X;st++)k[it*X+st]>wt&&(wt=k[it*X+st],K=st);Z[it]=wt,G[it]=K}return[Z,G]}detect(k,A=20,X=.5){var Z=this;return $(function*(){return Z.infer(k,A,X)})()}dispose(){null!=this.model&&this.model.dispose()}}V.ObjectDetection=R,V.load=$(function*(W={}){if(null==Q)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const k=W.base||"lite_mobilenet_v2",A=W.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(k))throw new Error(`ObjectDetection constructed with invalid base model ${k}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const X=new R(k,A);return yield X.load(),X}),V.version="2.2.3",Object.defineProperty(V,"__esModule",{value:!0})}(ut,y(7926),y(6300))},7926:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{GraphModel:()=>ss,deregisterOp:()=>Gt,loadGraphModel:()=>wu,loadGraphModelSync:()=>Or,registerOp:()=>at,version_converter:()=>_e});var $={};y.r($),y.d($,{json:()=>ee});var V={};y.r(V),y.d(V,{json:()=>jt});var H={};y.r(H),y.d(H,{json:()=>se});var Q={};y.r(Q),y.d(Q,{json:()=>we});var Y={};y.r(Y),y.d(Y,{json:()=>Me});var R={};y.r(R),y.d(R,{json:()=>Xe});var W={};y.r(W),y.d(W,{json:()=>Ue});var k={};y.r(k),y.d(k,{json:()=>De});var A={};y.r(A),y.d(A,{json:()=>Tn});var X={};y.r(X),y.d(X,{json:()=>On});var Z={};y.r(Z),y.d(Z,{json:()=>ne});var G={};y.r(G),y.d(G,{json:()=>pe});var it={};y.r(it),y.d(it,{json:()=>Ie});var wt={};y.r(wt),y.d(wt,{json:()=>Je});var K={};y.r(K),y.d(K,{json:()=>Wn});var st={};y.r(st),y.d(st,{json:()=>Er});var et={};y.r(et),y.d(et,{json:()=>Nn});var dt={};y.r(dt),y.d(dt,{json:()=>Yn});var lt={};y.r(lt),y.d(lt,{json:()=>hi});var St={};y.r(St),y.d(St,{OP_SCOPE_SUFFIX:()=>Xt.zvA,abs:()=>Xt.WnP,acos:()=>Xt.Khb,acosh:()=>Xt.__u,add:()=>Xt.IHx,addN:()=>Xt.QBD,all:()=>Xt.$6P,any:()=>Xt.YjB,argMax:()=>Xt.NqF,argMin:()=>Xt.vHJ,asin:()=>Xt.ZRM,asinh:()=>Xt.VfV,atan:()=>Xt.z4N,atan2:()=>Xt.fvJ,atanh:()=>Xt.C80,avgPool:()=>Xt.wS1,avgPool3d:()=>Xt.uR5,basicLSTMCell:()=>Xt.zEQ,batchNorm:()=>Xt.tgs,batchNorm2d:()=>Xt.Dxk,batchNorm3d:()=>Xt.JY5,batchNorm4d:()=>Xt.p3b,batchToSpaceND:()=>Xt.E4h,bincount:()=>Xt.yE8,bitwiseAnd:()=>Xt.ycw,booleanMaskAsync:()=>Xt.anm,broadcastArgs:()=>Xt.XsQ,broadcastTo:()=>Xt.UFq,buffer:()=>Xt.f3b,cast:()=>Xt.pju,ceil:()=>Xt.mDi,clipByValue:()=>Xt.iUl,clone:()=>Xt.d9v,complex:()=>Xt.PYB,concat:()=>Xt.zoF,concat1d:()=>Xt.gME,concat2d:()=>Xt.Izb,concat3d:()=>Xt.MNy,concat4d:()=>Xt.ZaL,conv1d:()=>Xt.PAt,conv2d:()=>Xt.Tek,conv2dTranspose:()=>Xt.bc,conv3d:()=>Xt.pdZ,conv3dTranspose:()=>Xt.$QV,cos:()=>Xt.mCk,cosh:()=>Xt.f9Y,cosineWindow:()=>Xt.mew,cumprod:()=>Xt.$Gn,cumsum:()=>Xt.zbp,denseBincount:()=>Xt.ppE,depthToSpace:()=>Xt.nTT,depthwiseConv2d:()=>Xt.B10,diag:()=>Xt.Ka3,dilation2d:()=>Xt.WmZ,div:()=>Xt.hiC,divNoNan:()=>Xt.NTj,dot:()=>Xt.AKD,dropout:()=>Xt.rvX,einsum:()=>Xt.WYO,elu:()=>Xt.pyx,enclosingPowerOfTwo:()=>Xt.GRh,ensureShape:()=>Xt.EDe,equal:()=>Xt.DgJ,erf:()=>Xt.qNN,euclideanNorm:()=>Xt.d2q,exp:()=>Xt.Qqt,expandDims:()=>Xt.dt4,expm1:()=>Xt.t$B,eye:()=>Xt.iyy,fft:()=>Xt.kp_,fill:()=>Xt.hlL,floor:()=>Xt.GWj,floorDiv:()=>Xt.qPi,fused:()=>Xt.imm,gather:()=>Xt.Iqj,gatherND:()=>Xt.dbB,greater:()=>Xt.pjt,greaterEqual:()=>Xt.brS,ifft:()=>Xt.Sxn,imag:()=>Xt.asL,image:()=>Xt.BHj,inTopKAsync:()=>Xt.V3u,irfft:()=>Xt.wx0,isFinite:()=>Xt.xVT,isInf:()=>Xt.UWc,isNaN:()=>Xt.i2d,leakyRelu:()=>Xt.hi7,less:()=>Xt.d9m,lessEqual:()=>Xt.zN1,linalg:()=>Xt.$r2,linspace:()=>Xt.SX3,localResponseNormalization:()=>Xt.G9k,log:()=>Xt.cM7,log1p:()=>Xt.Krr,logSigmoid:()=>Xt.e_t,logSoftmax:()=>Xt.CmS,logSumExp:()=>Xt.l_t,logicalAnd:()=>Xt.HvI,logicalNot:()=>Xt.hJK,logicalOr:()=>Xt.K5V,logicalXor:()=>Xt.egP,losses:()=>Xt.MB5,lowerBound:()=>Xt.eab,matMul:()=>Xt.OI3,max:()=>Xt.Fp7,maxPool:()=>Xt._sB,maxPool3d:()=>Xt.YQQ,maxPoolWithArgmax:()=>Xt.Ip$,maximum:()=>Xt.gWQ,mean:()=>Xt.J69,meshgrid:()=>Xt.ry_,min:()=>Xt.VV$,minimum:()=>Xt.LTh,mirrorPad:()=>Xt.VdP,mod:()=>Xt.wQq,moments:()=>Xt.Gi7,movingAverage:()=>Xt.p_,mul:()=>Xt.dC7,multiRNNCell:()=>Xt.rq4,multinomial:()=>Xt.SJ_,neg:()=>Xt.W76,norm:()=>Xt.KOy,notEqual:()=>Xt.Quu,oneHot:()=>Xt.lfX,ones:()=>Xt.iUs,onesLike:()=>Xt.JpU,op:()=>Xt.op,outerProduct:()=>Xt.N2O,pad:()=>Xt.vku,pad1d:()=>Xt.pNR,pad2d:()=>Xt.koy,pad3d:()=>Xt.t1L,pad4d:()=>Xt.lGY,pool:()=>Xt.d_R,pow:()=>Xt.sQ3,prelu:()=>Xt.AL3,print:()=>Xt.S0v,prod:()=>Xt.WVs,raggedGather:()=>Xt.$gW,raggedRange:()=>Xt.VT$,raggedTensorToTensor:()=>Xt.N89,rand:()=>Xt.TN_,randomGamma:()=>Xt.wzB,randomNormal:()=>Xt.nGf,randomStandardNormal:()=>Xt.ruB,randomUniform:()=>Xt.LGj,randomUniformInt:()=>Xt.pe5,range:()=>Xt.w6H,real:()=>Xt.kwC,reciprocal:()=>Xt.M25,relu:()=>Xt.UYe,relu6:()=>Xt.btT,reshape:()=>Xt.XLQ,reverse:()=>Xt.GYS,reverse1d:()=>Xt.SDf,reverse2d:()=>Xt.diP,reverse3d:()=>Xt.sx7,reverse4d:()=>Xt.mG2,rfft:()=>Xt.QEs,round:()=>Xt.NMM,rsqrt:()=>Xt.bp0,scalar:()=>Xt.iD$,scatterND:()=>Xt.snQ,searchSorted:()=>Xt.zcT,selu:()=>Xt.U8D,separableConv2d:()=>Xt.U_I,setdiff1dAsync:()=>Xt.ODp,sigmoid:()=>Xt.XD2,sign:()=>Xt.Xxe,signal:()=>Xt.tdS,sin:()=>Xt.O$l,sinh:()=>Xt.R_K,slice:()=>Xt.tPi,slice1d:()=>Xt.jZU,slice2d:()=>Xt.SmN,slice3d:()=>Xt.CnO,slice4d:()=>Xt.p0P,softmax:()=>Xt.XAC,softplus:()=>Xt.Wvh,spaceToBatchND:()=>Xt.fBT,sparse:()=>Xt.rVs,sparseToDense:()=>Xt.ers,spectral:()=>Xt.uN7,split:()=>Xt.Vl2,sqrt:()=>Xt._b3,square:()=>Xt.h62,squaredDifference:()=>Xt.$i,squeeze:()=>Xt.L9e,stack:()=>Xt.knu,step:()=>Xt.Nbs,stridedSlice:()=>Xt.NXj,string:()=>Xt.Z_8,sub:()=>Xt.luU,sum:()=>Xt.Smz,tan:()=>Xt.ORZ,tanh:()=>Xt.AEp,tensor:()=>Xt.XeE,tensor1d:()=>Xt.RRF,tensor2d:()=>Xt.odF,tensor3d:()=>Xt.wOQ,tensor4d:()=>Xt.yXz,tensor5d:()=>Xt.Bfx,tensor6d:()=>Xt.xZs,tensorScatterUpdate:()=>Xt.Pg0,tile:()=>Xt.Gg6,topk:()=>Xt.hg7,transpose:()=>Xt.p4s,truncatedNormal:()=>Xt.Xu6,unique:()=>Xt.Two,unsortedSegmentSum:()=>Xt.pUJ,unstack:()=>Xt.HHK,upperBound:()=>Xt.GaM,variable:()=>Xt.VD$,where:()=>Xt.arb,whereAsync:()=>Xt.itS,zeros:()=>Xt.lls,zerosLike:()=>Xt.P84});var q=y(6300);(0,q.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,z=>{z&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var ot,pt=y(5861),B=function(z){return z[z.DT_INVALID=0]="DT_INVALID",z[z.DT_FLOAT=1]="DT_FLOAT",z[z.DT_DOUBLE=2]="DT_DOUBLE",z[z.DT_INT32=3]="DT_INT32",z[z.DT_UINT8=4]="DT_UINT8",z[z.DT_INT16=5]="DT_INT16",z[z.DT_INT8=6]="DT_INT8",z[z.DT_STRING=7]="DT_STRING",z[z.DT_COMPLEX64=8]="DT_COMPLEX64",z[z.DT_INT64=9]="DT_INT64",z[z.DT_BOOL=10]="DT_BOOL",z[z.DT_QINT8=11]="DT_QINT8",z[z.DT_QUINT8=12]="DT_QUINT8",z[z.DT_QINT32=13]="DT_QINT32",z[z.DT_BFLOAT16=14]="DT_BFLOAT16",z[z.DT_QINT16=15]="DT_QINT16",z[z.DT_QUINT16=16]="DT_QUINT16",z[z.DT_UINT16=17]="DT_UINT16",z[z.DT_COMPLEX128=18]="DT_COMPLEX128",z[z.DT_HALF=19]="DT_HALF",z[z.DT_RESOURCE=20]="DT_RESOURCE",z[z.DT_VARIANT=21]="DT_VARIANT",z[z.DT_UINT32=22]="DT_UINT32",z[z.DT_UINT64=23]="DT_UINT64",z[z.DT_FLOAT_REF=101]="DT_FLOAT_REF",z[z.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",z[z.DT_INT32_REF=103]="DT_INT32_REF",z[z.DT_UINT8_REF=104]="DT_UINT8_REF",z[z.DT_INT16_REF=105]="DT_INT16_REF",z[z.DT_INT8_REF=106]="DT_INT8_REF",z[z.DT_STRING_REF=107]="DT_STRING_REF",z[z.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",z[z.DT_INT64_REF=109]="DT_INT64_REF",z[z.DT_BOOL_REF=110]="DT_BOOL_REF",z[z.DT_QINT8_REF=111]="DT_QINT8_REF",z[z.DT_QUINT8_REF=112]="DT_QUINT8_REF",z[z.DT_QINT32_REF=113]="DT_QINT32_REF",z[z.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",z[z.DT_QINT16_REF=115]="DT_QINT16_REF",z[z.DT_QUINT16_REF=116]="DT_QUINT16_REF",z[z.DT_UINT16_REF=117]="DT_UINT16_REF",z[z.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",z[z.DT_HALF_REF=119]="DT_HALF_REF",z[z.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",z[z.DT_VARIANT_REF=121]="DT_VARIANT_REF",z[z.DT_UINT32_REF=122]="DT_UINT32_REF",z[z.DT_UINT64_REF=123]="DT_UINT64_REF",z}(B||{});!function(z){let I;var M;(M=I=z.CheckpointFormatVersion||(z.CheckpointFormatVersion={}))[M.LEGACY=0]="LEGACY",M[M.V1=1]="V1",M[M.V2=2]="V2"}(ot||(ot={}));const P={};function at(z,I){P[z]={tfOpName:z,category:"custom",inputs:[],attrs:[],customExecutor:I}}function nt(z){return P[z]}function Gt(z){delete P[z]}function O(z,I,M,tt,bt){const At=I.inputParams[z];if(At&&void 0!==At.inputIndexStart){const kt=At.inputIndexStart,ae=0===At.inputIndexEnd?void 0:void 0===At.inputIndexEnd?kt+1:At.inputIndexEnd,nn=kt<0?I.inputNames.length+kt:kt;if("tensor"===At.type)return Ct(I.inputNames[nn],M,tt,bt);if("tensors"===At.type){const Cn=I.inputs.slice(kt,ae);return I.inputNames.slice(kt,ae).filter((Vn,vr)=>{var bn;return"NoOp"!==(null===(bn=Cn[vr])||void 0===bn?void 0:bn.op)}).map(Vn=>Ct(Vn,M,tt,bt))}const Ye=Ct(I.inputNames[nn],M,tt,bt),$e=Ye.dataSync();return"number"===At.type?$e[0]:q.util.toNestedArray(Ye.shape,$e)}const Yt=I.attrParams[z];return Yt&&Yt.value}function Ct(z,I,M,tt){const[bt,At]=Mt(z,M);if(null!=tt){const kt=tt.getHashTableHandleByName(bt);if(null!=kt)return kt}const Yt=M.currentContextIds.find(kt=>!!I[xt(bt,kt)]);return void 0!==Yt?I[xt(bt,Yt)][At]:void 0}function yt(z,I,M){return I[xt(z,M.currentContextId)]}function vt(z,I){const[M,tt,bt]=Mt(z,I);return[xt(M,I&&I.currentContextId),tt,bt]}function xt(z,I){return I?`${z}-${I}`:z}function Mt(z,I){if(""===z)return["",0,void 0];const M=null!=I&&null!=I.parseNodeNameCache;if(M){const At=I.parseNodeNameCache.get(z);if(null!=At)return At}const tt=z.split(":");let bt;if(1===tt.length)bt=[z,0,void 0];else{const Yt=3===tt.length?tt[1]:void 0;bt=[tt[0],Number(tt[tt.length-1]),Yt]}return M&&I.parseNodeNameCache.set(z,bt),bt}function re(z,I,M){let tt=O("pad",z,I,M);if("explicit"===tt){tt=O("explicitPaddings",z,I,M);const bt=[[0,0],[0,0],[0,0],[0,0]];for(let At=0;At<4;At++)bt[At][0]=tt[2*At],bt[At][1]=tt[2*At+1];return bt}return tt}function Bt(z){return z.kept?z:(0,q.clone)(z)}const ee=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],se=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],we=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Me=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Xe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],De=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Tn=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],On=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],ne=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],pe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Ie=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Je=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Wn=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Er=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Nn=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Yn=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],hi=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class di{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const M=[].concat(...[$,V,H,Q,Y,R,W,k,A,X,Z,G,it,wt,K,st,et,dt,lt].map(tt=>tt.json));this.opMappers=M.reduce((tt,bt)=>(tt[bt.tfOpName]=bt,tt),{})}transformGraph(I,M={}){const bt=[],At=[],Yt=[],kt=I.node.reduce((vr,bn)=>(vr[bn.name]=this.mapNode(bn),bn.op.startsWith("Placeholder")?bt.push(vr[bn.name]):"Const"===bn.op?At.push(vr[bn.name]):(null==bn.input||0===bn.input.length)&&Yt.push(vr[bn.name]),vr),{});let ae=[];const nn=[];let Ye={},$e={};null!=M&&(Ye=this.mapSignatureEntries(M.inputs),$e=this.mapSignatureEntries(M.outputs));const Cn=Object.keys(kt);Cn.forEach(vr=>{const bn=kt[vr];bn.inputNames.forEach((_r,ni)=>{const[Zs,,Xr]=vt(_r),tn=kt[Zs];if(null!=tn.outputs){const Iu=tn.outputs.indexOf(Xr);-1!==Iu&&(bn.inputNames[ni]=`${Zs}:${Iu}`)}bn.inputs.push(tn),tn.children.push(bn)})}),0===Object.keys($e).length?Cn.forEach(vr=>{const bn=kt[vr];0===bn.children.length&&nn.push(bn)}):Object.keys($e).forEach(vr=>{const[bn]=vt(vr),_r=kt[bn];null!=_r&&(_r.signatureKey=$e[vr],nn.push(_r))}),Object.keys(Ye).length>0?Object.keys(Ye).forEach(vr=>{const[bn]=vt(vr),_r=kt[bn];_r&&(_r.signatureKey=Ye[vr],ae.push(_r))}):ae=bt;let $n={};null!=I.library&&null!=I.library.function&&($n=I.library.function.reduce((vr,bn)=>(vr[bn.signature.name]=this.mapFunction(bn),vr),{}));const Vn={nodes:kt,inputs:ae,outputs:nn,weights:At,placeholders:bt,signature:M,functions:$n};return Yt.length>0&&(Vn.initNodes=Yt),Vn}mapSignatureEntries(I){return Object.keys(I||{}).reduce((M,tt)=>(M[I[tt].name]=tt,M),{})}mapNode(I){const M=nt(I.op)||this.opMappers[I.op]||{};null==I.attr&&(I.attr={});const tt={name:I.name,op:I.op,category:M.category,inputNames:(I.input||[]).map(bt=>bt.startsWith("^")?bt.slice(1):bt),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:I.attr,outputs:M.outputs};return null!=M.inputs&&(tt.inputParams=M.inputs.reduce((bt,At)=>(bt[At.name]={type:At.type,inputIndexStart:At.start,inputIndexEnd:At.end},bt),{})),null!=M.attrs&&(tt.attrParams=M.attrs.reduce((bt,At)=>{const Yt=At.type;let kt;switch(At.type){case"string":kt=yn(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=yn(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"string[]":kt=ie(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=ie(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"number":kt=xo(I.attr,At.tfName,At.defaultValue||0),void 0===kt&&At.tfDeprecatedName&&(kt=xo(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"number[]":kt=oe(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=oe(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"bool":kt=Qo(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Qo(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"bool[]":kt=Oe(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Oe(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"shape":kt=te(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=te(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"shape[]":kt=ze(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=ze(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"dtype":kt=Ce(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Ce(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"dtype[]":kt=Et(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Et(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"func":kt=Hs(I.attr,At.tfName,At.defaultValue),void 0===kt&&At.tfDeprecatedName&&(kt=Hs(I.attr,At.tfDeprecatedName,At.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${At.type} for op: ${I.op}`)}return bt[At.name]={value:kt,type:Yt},bt},{})),tt}mapFunction(I){const M=I.nodeDef,bt=[];let At={};null!=M&&(At=M.reduce(($e,Cn)=>($e[Cn.name]=this.mapNode(Cn),"Const"===Cn.op&&bt.push($e[Cn.name]),$e),{}));const Yt=[],kt=[];I.signature.inputArg.forEach($e=>{const[Cn]=vt($e.name),$n={name:Cn,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Gn($e.type),type:"dtype"}},children:[]};$n.signatureKey=$e.name,Yt.push($n),At[Cn]=$n}),Object.keys(At).forEach($e=>{const Cn=At[$e];Cn.inputNames.forEach(($n,Vn)=>{const[vr,,bn]=vt($n),_r=At[vr];if(null!=_r.outputs){const ni=_r.outputs.indexOf(bn);-1!==ni&&(Cn.inputNames[Vn]=`${vr}:${ni}`)}Cn.inputs.push(_r),_r.children.push(Cn)})});const nn=I.ret;I.signature.outputArg.forEach($e=>{const[Cn,$n]=vt(nn[$e.name]),Vn=At[Cn];null!=Vn&&(Vn.defaultOutput=$n,kt.push(Vn))});const Ye=this.mapArgsToSignature(I);return{nodes:At,inputs:Yt,outputs:kt,weights:bt,placeholders:[],signature:Ye}}mapArgsToSignature(I){return{methodName:I.signature.name,inputs:I.signature.inputArg.reduce((M,tt)=>(M[tt.name]=this.mapArgToTensorInfo(tt),M),{}),outputs:I.signature.outputArg.reduce((M,tt)=>(M[tt.name]=this.mapArgToTensorInfo(tt,I.ret),M),{})}}mapArgToTensorInfo(I,M){let tt=I.name;return null!=M&&(tt=M[tt]),{name:tt,dtype:I.type}}}function ii(z,I){const M=Array.isArray(z)?String.fromCharCode.apply(null,z):function to(z){const I=(0,q.env)().global;if(typeof I.atob<"u")return I.atob(z);if(typeof Buffer<"u")return new Buffer(z,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(z);return I?M:M.toLowerCase()}function yn(z,I,M,tt=!1){const bt=z[I];return null!=bt?ii(bt.s,tt):M}function Qo(z,I,M){const tt=z[I];return tt?tt.b:M}function xo(z,I,M){const tt=z[I]||{},bt=null!=tt.i?tt.i:null!=tt.f?tt.f:M;return"number"==typeof bt?bt:parseInt(bt,10)}function Gn(z){switch("string"==typeof z&&(z=B[z]),z){case B.DT_FLOAT:case B.DT_HALF:return"float32";case B.DT_INT32:case B.DT_INT64:case B.DT_INT8:case B.DT_UINT8:return"int32";case B.DT_BOOL:return"bool";case B.DT_DOUBLE:return"float32";case B.DT_STRING:return"string";case B.DT_COMPLEX64:case B.DT_COMPLEX128:return"complex64";default:return null}}function Hs(z,I,M){const tt=z[I];return tt&&tt.func?tt.func.name:M}function Ce(z,I,M){const tt=z[I];return tt&&tt.type?Gn(tt.type):M}function Et(z,I,M){const tt=z[I];return tt&&tt.list&&tt.list.type?tt.list.type.map(bt=>Gn(bt)):M}function Rt(z){if(!z.unknownRank)return null!=z.dim?z.dim.map(I=>"number"==typeof I.size?I.size:parseInt(I.size,10)):[]}function te(z,I,M){const tt=z[I];return tt&&tt.shape?Rt(tt.shape):M}function oe(z,I,M){const tt=z[I];return tt?((tt.list.f&&tt.list.f.length?tt.list.f:tt.list.i)||[]).map(bt=>"number"==typeof bt?bt:parseInt(bt,10)):M}function ie(z,I,M,tt=!1){const bt=z[I];return bt&&bt.list&&bt.list.s?bt.list.s.map(At=>ii(At,tt)):M}function ze(z,I,M){const tt=z[I];return tt&&tt.list&&tt.list.shape?tt.list.shape.map(bt=>Rt(bt)):M}function Oe(z,I,M){const tt=z[I];return tt&&tt.list&&tt.list.b?tt.list.b:M}class je{constructor(I,M,tt){this.node=I,this.tensorMap=M,this.context=tt,this.inputs=[],this.attrs={},this.inputs=I.inputNames.map(bt=>this.getInput(bt)),null!=I.rawAttrs&&(this.attrs=Object.keys(I.rawAttrs).reduce((bt,At)=>(bt[At]=this.getAttr(At),bt),{}))}getInput(I){return Ct(I,this.tensorMap,this.context)}getAttr(I,M){const tt=this.node.rawAttrs[I];if(null!=tt.tensor)return Ct(I,this.tensorMap,this.context);if(null!=tt.i||null!=tt.f)return xo(this.node.rawAttrs,I,M);if(null!=tt.s)return yn(this.node.rawAttrs,I,M);if(null!=tt.b)return Qo(this.node.rawAttrs,I,M);if(null!=tt.shape)return te(this.node.rawAttrs,I,M);if(null!=tt.type)return Ce(this.node.rawAttrs,I,M);if(null!=tt.list){if(null!=tt.list.i||null!=tt.list.f)return oe(this.node.rawAttrs,I,M);if(null!=tt.list.s)return ie(this.node.rawAttrs,I,M);if(null!=tt.list.shape)return ze(this.node.rawAttrs,I,M);if(null!=tt.list.b)return Oe(this.node.rawAttrs,I,M);if(null!=tt.list.type)return Et(this.node.rawAttrs,I,M)}return M}}var Xt=y(3667);function un(z,I,M=""){if("number"!=typeof z&&"number"!=typeof I){q.util.assert(z.length===I.length,()=>M+` Shapes ${z} and ${I} must match`);for(let tt=0;tt<z.length;tt++){const bt=z[tt],At=I[tt];q.util.assert(bt<0||At<0||bt===At,()=>M+` Shapes ${z} and ${I} must match`)}}}function ir(z){return!("number"==typeof z||z.some(I=>I<0))}function dr(z,I,M){let tt=zn(z,M);const bt=!ir(tt);if(bt&&0===I.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${tt}`);if(bt&&I.forEach(At=>{tt=zn(At.shape,tt)}),!ir(tt))throw new Error(`Non-fully-defined elementShape: ${tt}`);return tt}function zn(z,I){if("number"==typeof z)return I;if("number"==typeof I)return z;if(z.length!==I.length)throw new Error(`Incompatible ranks during merge: ${z} vs. ${I}`);const M=[];for(let tt=0;tt<z.length;++tt){const bt=z[tt],At=I[tt];if(bt>=0&&At>=0&&bt!==At)throw new Error(`Incompatible shape during merge: ${z} vs. ${I}`);M[tt]=bt>=0?bt:At}return M}class _n{constructor(I,M,tt,bt,At,Yt,kt){this.name=I,this.dtype=M,this.maxSize=tt,this.elementShape=bt,this.identicalElementShapes=At,this.dynamicSize=Yt,this.clearAfterRead=kt,this.tensors=[],this.closed_=!1,this.idTensor=(0,q.scalar)(0),(0,q.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(I){this.tensors.forEach(M=>{(null==I||!I.has(M.tensor.id))&&M.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(I){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(I<0||I>=this.size())throw new Error(`Tried to read from index ${I}, but array size is: ${this.size()}`);const M=this.tensors[I];if(M.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${I} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(M.cleared=!0),M.read=!0,M.tensor}readMany(I){return I.map(M=>this.read(M))}write(I,M){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(I<0||!this.dynamicSize&&I>=this.maxSize)throw new Error(`Tried to write to index ${I}, but array is not resizeable and size is: ${this.maxSize}`);const tt=this.tensors[I]||{};if(M.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${I},\n          because the value dtype is ${M.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=M.shape),un(this.elementShape,M.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${I}.`),tt.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${I}, because it has already been read.`);if(tt.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${I}, because it has already been written.`);tt.tensor=M,(0,q.keep)(M),tt.written=!0,this.tensors[I]=tt}writeMany(I,M){if(I.length!==M.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${I.length} is not the same as tensors size: ${M.length}.`);I.forEach((tt,bt)=>this.write(tt,M[bt]))}gather(I,M){if(M&&M!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${M}`);if(I)I=I.slice(0,this.size());else{I=[];for(let bt=0;bt<this.size();bt++)I.push(bt)}if(0===I.length)return(0,q.tensor)([],[0].concat(this.elementShape));const tt=this.readMany(I);return un(this.elementShape,tt[0].shape,"TensorArray shape mismatch: "),(0,q.stack)(tt,0)}concat(I){if(I&&I!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${I}`);if(0===this.size())return(0,q.tensor)([],[0].concat(this.elementShape));const M=[];for(let bt=0;bt<this.size();bt++)M.push(bt);const tt=this.readMany(M);return un(this.elementShape,tt[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tt[0].shape})`),(0,q.concat)(tt,0)}scatter(I,M){if(M.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${M.dtype}`);if(I.length!==M.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${I.length} vs. ${M.shape[0]}`);const tt=Math.max(...I);if(!this.dynamicSize&&tt>=this.maxSize)throw new Error(`Max index must be < array size (${tt}  vs. ${this.maxSize})`);this.writeMany(I,(0,q.unstack)(M,0))}split(I,M){if(M.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${M.dtype}`);let tt=0;const bt=I.map(ae=>(tt+=ae,tt));if(tt!==M.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${tt}, and tensor's shape is: ${M.shape}`);if(!this.dynamicSize&&I.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${I.length}), and the TensorArray is not marked as dynamically resizeable`);const At=0===tt?0:M.size/tt,Yt=[];(0,q.tidy)(()=>{M=(0,q.reshape)(M,[1,tt,At]);for(let ae=0;ae<I.length;++ae)Yt[ae]=(0,q.reshape)((0,q.slice)(M,[0,0===ae?0:bt[ae-1],0],[1,I[ae],At]),this.elementShape);return Yt});const kt=[];for(let ae=0;ae<I.length;ae++)kt[ae]=ae;this.writeMany(kt,Yt)}}class sr{get id(){return this.idTensor.id}constructor(I,M,tt,bt=-1){this.tensors=I,this.elementShape=M,this.elementDtype=tt,I?.forEach(At=>{if(tt!==At.dtype)throw new Error(`Invalid data types; op elements ${tt}, but list elements ${At.dtype}`);un(M,At.shape,"TensorList shape mismatch: "),(0,q.keep)(At)}),this.idTensor=(0,q.scalar)(0),this.maxNumElements=bt,(0,q.keep)(this.idTensor)}copy(){return new sr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(I){this.tensors.forEach(M=>{(null==I||!I.has(M.id))&&M.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(I,M,tt=-1){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);if(-1!==tt&&this.tensors.length!==tt)throw new Error(`Operation expected a list with ${tt} elements but got a list with ${this.tensors.length} elements.`);un(I,this.elementShape,"TensorList shape mismatch: ");const bt=dr(this.elementShape,this.tensors,I);return(0,q.tidy)(()=>{const At=this.tensors.map(Yt=>(0,q.reshape)(Yt,bt));return(0,q.stack)(At,0)})}popBack(I,M){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const tt=dr(this.elementShape,this.tensors,I),bt=this.tensors.pop();return bt.kept=!1,un(bt.shape,I,"TensorList shape mismatch: "),(0,q.reshape)(bt,tt)}pushBack(I){if(I.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${I.dtype}, but list elements ${this.elementDtype}`);if(un(I.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,q.keep)(I),this.tensors.push(I)}resize(I){if(I<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${I}`);if(-1!==this.maxNumElements&&I>this.maxNumElements)throw new Error(`TensorListResize input size ${I} is greater maxNumElement ${this.maxNumElements}.`);const M=new sr([],this.elementShape,this.elementDtype,this.maxNumElements);M.tensors.length=I;for(let tt=0;tt<Math.min(this.tensors.length,I);++tt)M.tensors[tt]=this.tensors[tt];return M}getItem(I,M,tt){if(tt!==this.elementDtype)throw new Error(`Invalid data types; op elements ${tt}, but list elements ${this.elementDtype}`);if(I<0||I>this.tensors.length)throw new Error(`Trying to access element ${I} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[I])throw new Error(`element at index ${I} is null.`);un(this.tensors[I].shape,M,"TensorList shape mismatch: ");const bt=dr(this.elementShape,this.tensors,M);return(0,q.reshape)(this.tensors[I],bt)}setItem(I,M){if(M.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M.dtype}, but list elements ${this.elementDtype}`);if(I<0||-1!==this.maxNumElements&&I>=this.maxNumElements)throw new Error(`Trying to set element ${I} in a list with max ${this.maxNumElements} elements.`);un(this.elementShape,M.shape,"TensorList shape mismatch: "),(0,q.keep)(M),null!=this.tensors[I]&&(this.tensors[I].kept=!1),this.tensors[I]=M}gather(I,M,tt){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);un(this.elementShape,tt,"TensorList shape mismatch: "),I=I.slice(0,this.size());const bt=dr(this.elementShape,this.tensors,tt);return 0===I.length?(0,q.tensor)([],[0].concat(bt)):(0,q.tidy)(()=>{const At=I.map(Yt=>(0,q.reshape)(this.tensors[Yt],bt));return(0,q.stack)(At,0)})}concat(I,M){if(I&&I!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${I}`);un(this.elementShape,M,"TensorList shape mismatch: ");const tt=dr(this.elementShape,this.tensors,M);return 0===this.size()?(0,q.tensor)([],[0].concat(tt)):(0,q.tidy)(()=>{const bt=this.tensors.map(At=>(0,q.reshape)(At,tt));return(0,q.concat)(bt,0)})}}const si=function(){var z=(0,pt.Z)(function*(I,M,tt){switch(I.op){case"If":case"StatelessIf":{const bt=O("thenBranch",I,M,tt),At=O("elseBranch",I,M,tt),Yt=O("cond",I,M,tt),kt=O("args",I,M,tt);return(yield Yt.data())[0]?tt.functionMap[bt].executeFunctionAsync(kt,tt.tensorArrayMap,tt.tensorListMap):tt.functionMap[At].executeFunctionAsync(kt,tt.tensorArrayMap,tt.tensorListMap)}case"While":case"StatelessWhile":{const bt=O("body",I,M,tt),At=O("cond",I,M,tt),Yt=O("args",I,M,tt),kt=yield tt.functionMap[At].executeFunctionAsync(Yt,tt.tensorArrayMap,tt.tensorListMap),ae=Yt.map($e=>$e.id);let nn=yield kt[0].data();kt.forEach($e=>{!$e.kept&&-1===ae.indexOf($e.id)&&$e.dispose()});let Ye=Yt;for(;nn[0];){const $e=Ye;Ye=yield tt.functionMap[bt].executeFunctionAsync(Ye,tt.tensorArrayMap,tt.tensorListMap);const Cn=Ye.map(Vn=>Vn.id);$e.forEach(Vn=>{!Vn.kept&&-1===ae.indexOf(Vn.id)&&-1===Cn.indexOf(Vn.id)&&Vn.dispose()});const $n=yield tt.functionMap[At].executeFunctionAsync(Ye,tt.tensorArrayMap,tt.tensorListMap);nn=yield $n[0].data(),$n.forEach(Vn=>{!Vn.kept&&-1===ae.indexOf(Vn.id)&&-1===Cn.indexOf(Vn.id)&&Vn.dispose()})}return Ye}case"LoopCond":return[Bt(O("pred",I,M,tt))];case"Switch":{const bt=O("pred",I,M,tt);let At=O("data",I,M,tt);return At.kept||(At=Bt(At)),(yield bt.data())[0]?[void 0,At]:[At,void 0]}case"Merge":{const bt=I.inputNames.find(At=>void 0!==Ct(At,M,tt));return bt?[Bt(Ct(bt,M,tt))]:void 0}case"Enter":{const bt=O("frameName",I,M,tt),At=O("tensor",I,M,tt);return tt.enterFrame(bt),[Bt(At)]}case"Exit":{const bt=O("tensor",I,M,tt);return tt.exitFrame(),[Bt(bt)]}case"NextIteration":{const bt=O("tensor",I,M,tt);return tt.nextIteration(),[Bt(bt)]}case"TensorArrayV3":{const bt=O("size",I,M,tt),At=O("dtype",I,M,tt),Yt=O("elementShape",I,M,tt),kt=O("dynamicSize",I,M,tt),ae=O("clearAfterRead",I,M,tt),nn=O("identicalElementShapes",I,M,tt),Ye=O("name",I,M,tt),$e=new _n(Ye,At,bt,Yt,nn,kt,ae);return tt.addTensorArray($e),[$e.idTensor,(0,q.scalar)(1)]}case"TensorArrayWriteV3":{const bt=O("tensorArrayId",I,M,tt),At=O("index",I,M,tt),Yt=O("tensor",I,M,tt),kt=tt.getTensorArray(bt.id);return kt.write(At,Yt),[kt.idTensor]}case"TensorArrayReadV3":{const bt=O("tensorArrayId",I,M,tt),At=O("index",I,M,tt);return[tt.getTensorArray(bt.id).read(At)]}case"TensorArrayGatherV3":{const bt=O("tensorArrayId",I,M,tt),At=O("indices",I,M,tt),Yt=O("dtype",I,M,tt);return[tt.getTensorArray(bt.id).gather(At,Yt)]}case"TensorArrayScatterV3":{const bt=O("tensorArrayId",I,M,tt),At=O("indices",I,M,tt),Yt=O("tensor",I,M,tt),kt=tt.getTensorArray(bt.id);return kt.scatter(At,Yt),[kt.idTensor]}case"TensorArrayConcatV3":{const bt=O("tensorArrayId",I,M,tt),At=tt.getTensorArray(bt.id),Yt=O("dtype",I,M,tt);return[At.concat(Yt)]}case"TensorArraySplitV3":{const bt=O("tensorArrayId",I,M,tt),At=O("tensor",I,M,tt),Yt=O("lengths",I,M,tt),kt=tt.getTensorArray(bt.id);return kt.split(Yt,At),[kt.idTensor]}case"TensorArraySizeV3":{const bt=O("tensorArrayId",I,M,tt),At=tt.getTensorArray(bt.id);return[(0,q.scalar)(At.size(),"int32")]}case"TensorArrayCloseV3":{const bt=O("tensorArrayId",I,M,tt),At=tt.getTensorArray(bt.id);return At.clearAndClose(),[At.idTensor]}case"TensorListSetItem":{const bt=O("tensorListId",I,M,tt),At=O("index",I,M,tt),Yt=O("tensor",I,M,tt),kt=tt.getTensorList(bt.id);return kt.setItem(At,Yt),[kt.idTensor]}case"TensorListGetItem":{const bt=O("tensorListId",I,M,tt),At=O("index",I,M,tt),Yt=O("elementShape",I,M,tt),kt=O("elementDType",I,M,tt);return[tt.getTensorList(bt.id).getItem(At,Yt,kt)]}case"TensorListScatterV2":case"TensorListScatter":{const bt=O("indices",I,M,tt),ae=function br(z,I,M,tt){if(I.length!==z.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${I.length} vs. ${z.shape[0]}`);const bt=Math.max(...I);if(null!=tt&&-1!==tt&&bt>=tt)throw new Error(`Max index must be < array size (${bt}  vs. ${tt})`);const At=new sr([],M,z.dtype,tt),Yt=(0,q.unstack)(z,0);return I.forEach((kt,ae)=>{At.setItem(kt,Yt[ae])}),At}(O("tensor",I,M,tt),bt,O("elementShape",I,M,tt),O("numElements",I,M,tt));return tt.addTensorList(ae),[ae.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const bt=O("elementShape",I,M,tt),At=O("elementDType",I,M,tt);let Yt;Yt="TensorListReserve"===I.op?"numElements":"maxNumElements";const kt=O(Yt,I,M,tt),nn=function qn(z,I,M,tt){return new sr([],z,I,tt)}(bt,At,0,"TensorListReserve"===I.op?-1:kt);return tt.addTensorList(nn),[nn.idTensor]}case"TensorListGather":{const bt=O("tensorListId",I,M,tt),At=O("indices",I,M,tt),Yt=O("elementShape",I,M,tt),kt=O("elementDType",I,M,tt);return[tt.getTensorList(bt.id).gather(At,kt,Yt)]}case"TensorListStack":{const bt=O("tensorListId",I,M,tt),At=O("elementShape",I,M,tt),Yt=O("elementDType",I,M,tt),kt=O("numElements",I,M,tt);return[tt.getTensorList(bt.id).stack(At,Yt,kt)]}case"TensorListFromTensor":{const kt=function Jr(z,I,M){const tt=z.dtype;if(z.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${z.shape}`);if(z.dtype!==M)throw new Error(`Invalid data types; op elements ${z.dtype}, but list elements ${M}`);un(z.shape.slice(1),I,"TensorList shape mismatch: ");const At=(0,q.unstack)(z);return new sr(At,I,tt)}(O("tensor",I,M,tt),O("elementShape",I,M,tt),O("elementDType",I,M,tt));return tt.addTensorList(kt),[kt.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const bt=O("tensorListId",I,M,tt),At=tt.getTensorList(bt.id),Yt=O("dtype",I,M,tt),kt=O("elementShape",I,M,tt);return[At.concat(Yt,kt)]}case"TensorListPushBack":{const bt=O("tensorListId",I,M,tt),At=O("tensor",I,M,tt),Yt=tt.getTensorList(bt.id);return Yt.pushBack(At),[Yt.idTensor]}case"TensorListPopBack":{const bt=O("tensorListId",I,M,tt),At=O("elementShape",I,M,tt),Yt=O("elementDType",I,M,tt);return[tt.getTensorList(bt.id).popBack(At,Yt)]}case"TensorListSplit":{const bt=O("tensor",I,M,tt),At=O("elementShape",I,M,tt),kt=function Dn(z,I,M){let tt=0;const bt=I.map(Ye=>(tt+=Ye,tt));if(tt!==z.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${tt}, and tensor's shape is: ${z.shape}`);const Yt=zn(z.shape.slice(1),M),kt=0===tt?0:z.size/tt,ae=(0,q.tidy)(()=>{const Ye=[];z=(0,q.reshape)(z,[1,tt,kt]);for(let $e=0;$e<I.length;++$e)Ye[$e]=(0,q.reshape)((0,q.slice)(z,[0,0===$e?0:bt[$e-1],0],[1,I[$e],kt]),Yt);return z.dispose(),Ye}),nn=new sr([],M,z.dtype,I.length);for(let Ye=0;Ye<ae.length;Ye++)nn.setItem(Ye,ae[Ye]);return nn}(bt,O("lengths",I,M,tt),At);return tt.addTensorList(kt),[kt.idTensor]}case"TensorListLength":{const bt=O("tensorListId",I,M,tt),At=tt.getTensorList(bt.id);return[(0,q.scalar)(At.size(),"int32")]}case"TensorListResize":{const bt=O("tensorListId",I,M,tt),At=O("size",I,M,tt),kt=tt.getTensorList(bt.id).resize(At);return tt.addTensorList(kt),[kt.idTensor]}default:throw TypeError(`Node type ${I.op} is not implemented`)}});return function(M,tt,bt){return z.apply(this,arguments)}}();function tr(z,I,M){const[tt,bt]=O("fusedOps",z,I,M),At="biasadd"===tt,Yt=!At,kt="prelu"===bt,ae="fusedbatchnorm"===tt,nn=O("numArgs",z,I,M);if(At){if(kt&&2!==nn)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!kt&&At&&1!==nn)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(ae)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const Ye=O("strides",z,I,M),$e=re(z,I,M),Cn=O("dataFormat",z,I,M).toUpperCase(),$n=O("dilations",z,I,M);let[Vn,vr]=O("args",z,I,M);return Yt&&(vr=Vn,Vn=void 0),{stride:Ye,pad:$e,dataFormat:Cn,dilations:$n,biasArg:Vn,preluArg:vr,activationFunc:bt,leakyreluAlpha:O("leakyreluAlpha",z,I,M)}}function js(z,I,M){return{boxes:O("boxes",z,I,M),scores:O("scores",z,I,M),maxOutputSize:O("maxOutputSize",z,I,M),iouThreshold:O("iouThreshold",z,I,M),scoreThreshold:O("scoreThreshold",z,I,M),softNmsSigma:O("softNmsSigma",z,I,M)}}const ho=function(){var z=(0,pt.Z)(function*(I,M,tt,bt,At=St){switch(I.op){case"NonMaxSuppressionV5":{const{boxes:Yt,scores:kt,maxOutputSize:ae,iouThreshold:nn,scoreThreshold:Ye,softNmsSigma:$e}=js(I,M,tt),Cn=yield At.image.nonMaxSuppressionWithScoreAsync(Yt,kt,ae,nn,Ye,$e);return[Cn.selectedIndices,Cn.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:Yt,scores:kt,maxOutputSize:ae,iouThreshold:nn,scoreThreshold:Ye}=js(I,M,tt),$e=O("padToMaxOutputSize",I,M,tt),Cn=yield At.image.nonMaxSuppressionPaddedAsync(Yt,kt,ae,nn,Ye,$e);return[Cn.selectedIndices,Cn.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:Yt,scores:kt,maxOutputSize:ae,iouThreshold:nn,scoreThreshold:Ye}=js(I,M,tt);return[yield At.image.nonMaxSuppressionAsync(Yt,kt,ae,nn,Ye)]}case"Where":{const Yt=At.cast(O("condition",I,M,tt),"bool"),kt=[yield At.whereAsync(Yt)];return Yt.dispose(),kt}case"ListDiff":return At.setdiff1dAsync(O("x",I,M,tt),O("y",I,M,tt));default:throw TypeError(`Node type ${I.op} is not implemented`)}});return function(M,tt,bt,At){return z.apply(this,arguments)}}();var Eo=y(8661);class Ls{get id(){return this.handle.id}constructor(I,M){this.keyDType=I,this.valueDType=M,this.handle=(0,q.scalar)(0),this.tensorMap=new Map,(0,q.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach(I=>I.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Eo.i(this.size(),"int32")}import(I,M){var tt=this;return(0,pt.Z)(function*(){tt.checkKeyAndValueTensor(I,M);const bt=yield I.data();return tt.tensorMap.forEach(At=>At.dispose()),tt.tensorMap.clear(),(0,q.tidy)(()=>{const At=(0,q.unstack)(M),Yt=bt.length,kt=At.length;q.util.assert(Yt===kt,()=>`The number of elements doesn't match, keys has ${Yt} elements, the values has ${kt} elements.`);for(let ae=0;ae<Yt;ae++){const nn=bt[ae],Ye=At[ae];(0,q.keep)(Ye),tt.tensorMap.set(nn,Ye)}return tt.handle})})()}find(I,M){var tt=this;return(0,pt.Z)(function*(){tt.checkKeyAndValueTensor(I,M);const bt=yield I.data();return(0,q.tidy)(()=>{const At=[];for(let Yt=0;Yt<bt.length;Yt++){const ae=tt.findWithDefault(bt[Yt],M);At.push(ae)}return(0,q.stack)(At)})})()}findWithDefault(I,M){return this.tensorMap.get(I)??M}checkKeyAndValueTensor(I,M){if(I.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${I.dtype}`);if(M.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${M.dtype}`)}}const Ma=function(){var z=(0,pt.Z)(function*(I,M,tt,bt){switch(I.op){case"HashTable":case"HashTableV2":{const At=bt.getHashTableHandleByName(I.name);if(null!=At)return[At];{const Yt=O("keyDType",I,M,tt),kt=O("valueDType",I,M,tt),ae=new Ls(Yt,kt);return bt.addHashTable(I.name,ae),[ae.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const At=O("tableHandle",I,M,tt,bt),Yt=O("keys",I,M,tt),kt=O("values",I,M,tt);return[yield bt.getHashTableById(At.id).import(Yt,kt)]}case"LookupTableFind":case"LookupTableFindV2":{const At=O("tableHandle",I,M,tt,bt),Yt=O("keys",I,M,tt),kt=O("defaultValue",I,M,tt);return[yield bt.getHashTableById(At.id).find(Yt,kt)]}case"LookupTableSize":case"LookupTableSizeV2":{const At=O("tableHandle",I,M,tt,bt);return[bt.getHashTableById(At.id).tensorSize()]}default:throw TypeError(`Node type ${I.op} is not implemented`)}});return function(M,tt,bt,At){return z.apply(this,arguments)}}();function Cs(z,I,M,tt,bt=q.tidy){const At=((Yt,kt,ae)=>{switch(Yt.category){case"arithmetic":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"BiasAdd":case"AddV2":case"Add":return[tt.add(O("a",z,I,M),O("b",z,I,M))];case"AddN":return[tt.addN(O("tensors",z,I,M))];case"FloorMod":case"Mod":return[tt.mod(O("a",z,I,M),O("b",z,I,M))];case"Mul":return[tt.mul(O("a",z,I,M),O("b",z,I,M))];case"RealDiv":case"Div":return[tt.div(O("a",z,I,M),O("b",z,I,M))];case"DivNoNan":return[tt.divNoNan(O("a",z,I,M),O("b",z,I,M))];case"FloorDiv":return[tt.floorDiv(O("a",z,I,M),O("b",z,I,M))];case"Sub":return[tt.sub(O("a",z,I,M),O("b",z,I,M))];case"Minimum":return[tt.minimum(O("a",z,I,M),O("b",z,I,M))];case"Maximum":return[tt.maximum(O("a",z,I,M),O("b",z,I,M))];case"Pow":return[tt.pow(O("a",z,I,M),O("b",z,I,M))];case"SquaredDifference":return[tt.squaredDifference(O("a",z,I,M),O("b",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"basic_math":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Abs":case"ComplexAbs":return[tt.abs(O("x",z,I,M))];case"Acos":return[tt.acos(O("x",z,I,M))];case"Acosh":return[tt.acosh(O("x",z,I,M))];case"Asin":return[tt.asin(O("x",z,I,M))];case"Asinh":return[tt.asinh(O("x",z,I,M))];case"Atan":return[tt.atan(O("x",z,I,M))];case"Atan2":return[tt.atan2(O("x",z,I,M),O("y",z,I,M))];case"Atanh":return[tt.atanh(O("x",z,I,M))];case"Ceil":return[tt.ceil(O("x",z,I,M))];case"Complex":return[tt.complex(O("real",z,I,M),O("imag",z,I,M))];case"Cos":return[tt.cos(O("x",z,I,M))];case"Cosh":return[tt.cosh(O("x",z,I,M))];case"Elu":return[tt.elu(O("x",z,I,M))];case"Erf":return[tt.erf(O("x",z,I,M))];case"Exp":return[tt.exp(O("x",z,I,M))];case"Expm1":return[tt.expm1(O("x",z,I,M))];case"Floor":return[tt.floor(O("x",z,I,M))];case"Log":return[tt.log(O("x",z,I,M))];case"Log1p":return[tt.log1p(O("x",z,I,M))];case"Imag":return[tt.imag(O("x",z,I,M))];case"Neg":return[tt.neg(O("x",z,I,M))];case"Reciprocal":return[tt.reciprocal(O("x",z,I,M))];case"Real":return[tt.real(O("x",z,I,M))];case"Relu":return[tt.relu(O("x",z,I,M))];case"Round":return[tt.round(O("x",z,I,M))];case"Selu":return[tt.selu(O("x",z,I,M))];case"Sigmoid":return[tt.sigmoid(O("x",z,I,M))];case"Sin":return[tt.sin(O("x",z,I,M))];case"Sign":return[tt.sign(O("x",z,I,M))];case"Sinh":return[tt.sinh(O("x",z,I,M))];case"Softplus":return[tt.softplus(O("x",z,I,M))];case"Sqrt":return[tt.sqrt(O("x",z,I,M))];case"Square":return[tt.square(O("x",z,I,M))];case"Tanh":return[tt.tanh(O("x",z,I,M))];case"Tan":return[tt.tan(O("x",z,I,M))];case"ClipByValue":return[tt.clipByValue(O("x",z,I,M),O("clipValueMin",z,I,M),O("clipValueMax",z,I,M))];case"Relu6":return[tt.relu6(O("x",z,I,M))];case"Rsqrt":return[tt.rsqrt(Ct(z.inputNames[0],I,M))];case"LeakyRelu":return[tt.leakyRelu(O("x",z,I,M),O("alpha",z,I,M))];case"Prelu":return[tt.prelu(O("x",z,I,M),O("alpha",z,I,M))];case"IsNan":return[tt.isNaN(Ct(z.inputNames[0],I,M))];case"IsInf":return[tt.isInf(Ct(z.inputNames[0],I,M))];case"IsFinite":return[tt.isFinite(Ct(z.inputNames[0],I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"control":return si(Yt,kt,ae);case"convolution":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Conv1D":{const bt=O("stride",z,I,M),At=O("pad",z,I,M),Yt=O("dataFormat",z,I,M).toUpperCase(),kt=O("dilation",z,I,M);return[tt.conv1d(O("x",z,I,M),O("filter",z,I,M),bt,At,Yt,kt)]}case"Conv2D":{const bt=O("strides",z,I,M),At=re(z,I,M),Yt=O("dataFormat",z,I,M).toUpperCase(),kt=O("dilations",z,I,M);return[tt.conv2d(O("x",z,I,M),O("filter",z,I,M),[bt[1],bt[2]],At,Yt,[kt[1],kt[2]])]}case"_FusedConv2D":{const{stride:bt,pad:At,dataFormat:Yt,dilations:kt,biasArg:ae,preluArg:nn,activationFunc:Ye,leakyreluAlpha:$e}=tr(z,I,M);return[tt.fused.conv2d({x:O("x",z,I,M),filter:O("filter",z,I,M),strides:[bt[1],bt[2]],pad:At,dataFormat:Yt,dilations:[kt[1],kt[2]],bias:ae,activation:Ye,preluActivationWeights:nn,leakyreluAlpha:$e})]}case"FusedDepthwiseConv2dNative":{const{stride:bt,pad:At,dataFormat:Yt,dilations:kt,biasArg:ae,preluArg:nn,activationFunc:Ye,leakyreluAlpha:$e}=tr(z,I,M);return[tt.fused.depthwiseConv2d({x:O("x",z,I,M),filter:O("filter",z,I,M),strides:[bt[1],bt[2]],pad:At,dataFormat:Yt,dilations:[kt[1],kt[2]],bias:ae,activation:Ye,preluActivationWeights:nn,leakyreluAlpha:$e})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const bt=O("outputShape",z,I,M),At=O("strides",z,I,M),Yt=re(z,I,M);return[tt.conv2dTranspose(O("x",z,I,M),O("filter",z,I,M),bt,[At[1],At[2]],Yt)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const bt=O("strides",z,I,M),At=re(z,I,M),Yt=O("dilations",z,I,M),kt=O("dataFormat",z,I,M).toUpperCase();return[tt.depthwiseConv2d(O("input",z,I,M),O("filter",z,I,M),[bt[1],bt[2]],At,kt,[Yt[1],Yt[2]])]}case"Conv3D":{const bt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("dataFormat",z,I,M).toUpperCase(),kt=O("dilations",z,I,M);return[tt.conv3d(O("x",z,I,M),O("filter",z,I,M),[bt[1],bt[2],bt[3]],At,Yt,[kt[1],kt[2],kt[3]])]}case"AvgPool":{const bt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M);return[tt.avgPool(O("x",z,I,M),[Yt[1],Yt[2]],[bt[1],bt[2]],At)]}case"MaxPool":{const bt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M);return[tt.maxPool(O("x",z,I,M),[Yt[1],Yt[2]],[bt[1],bt[2]],At)]}case"MaxPoolWithArgmax":{const bt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M),kt=O("includeBatchInIndex",z,I,M),{result:ae,indexes:nn}=tt.maxPoolWithArgmax(O("x",z,I,M),[Yt[1],Yt[2]],[bt[1],bt[2]],At,kt);return[ae,nn]}case"AvgPool3D":{const bt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M);return[tt.avgPool3d(O("x",z,I,M),[Yt[1],Yt[2],Yt[3]],[bt[1],bt[2],bt[3]],At)]}case"MaxPool3D":{const bt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("kernelSize",z,I,M);return[tt.maxPool3d(O("x",z,I,M),[Yt[1],Yt[2],Yt[3]],[bt[1],bt[2],bt[3]],At)]}case"Dilation2D":{const bt=O("strides",z,I,M),At=O("pad",z,I,M),Yt=O("dilations",z,I,M),kt=bt[1],ae=bt[2],nn=Yt[1],Ye=Yt[2];return[tt.dilation2d(O("x",z,I,M),O("filter",z,I,M),[kt,ae],At,[nn,Ye],"NHWC")]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"creation":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Fill":{const bt=O("shape",z,I,M),At=O("dtype",z,I,M),Yt=O("value",z,I,M);return[tt.fill(bt,Yt,At)]}case"LinSpace":{const bt=O("start",z,I,M),At=O("stop",z,I,M),Yt=O("num",z,I,M);return[tt.linspace(bt,At,Yt)]}case"Multinomial":{const bt=O("logits",z,I,M),At=O("numSamples",z,I,M),Yt=O("seed",z,I,M);return[tt.multinomial(bt,At,Yt)]}case"OneHot":{const bt=O("indices",z,I,M),At=O("depth",z,I,M),Yt=O("onValue",z,I,M),kt=O("offValue",z,I,M),ae=O("dtype",z,I,M);return[tt.oneHot(bt,At,Yt,kt,ae)]}case"Ones":return[tt.ones(O("shape",z,I,M),O("dtype",z,I,M))];case"OnesLike":return[tt.onesLike(O("x",z,I,M))];case"RandomStandardNormal":return[tt.randomStandardNormal(O("shape",z,I,M),O("dtype",z,I,M),O("seed",z,I,M))];case"RandomUniform":return[tt.randomUniform(O("shape",z,I,M),O("minval",z,I,M),O("maxval",z,I,M),O("dtype",z,I,M))];case"RandomUniformInt":return[tt.randomUniformInt(O("shape",z,I,M),O("minval",z,I,M),O("maxval",z,I,M),O("seed",z,I,M))];case"Range":{const bt=O("start",z,I,M),At=O("stop",z,I,M),Yt=O("step",z,I,M);return[tt.range(bt,At,Yt,O("dtype",z,I,M))]}case"TruncatedNormal":{const bt=O("shape",z,I,M),At=O("mean",z,I,M),Yt=O("stdDev",z,I,M),kt=O("seed",z,I,M);return[tt.truncatedNormal(bt,At,Yt,O("dtype",z,I,M),kt)]}case"Zeros":return[tt.zeros(O("shape",z,I,M),O("dtype",z,I,M))];case"ZerosLike":return[tt.zerosLike(O("x",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"dynamic":return ho(Yt,kt,ae);case"evaluation":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"LowerBound":{const bt=O("sortedSequence",z,I,M),At=O("values",z,I,M);return[tt.lowerBound(bt,At)]}case"TopKV2":{const bt=O("x",z,I,M),At=O("k",z,I,M),Yt=O("sorted",z,I,M),kt=tt.topk(bt,At,Yt);return[kt.values,kt.indices]}case"UpperBound":{const bt=O("sortedSequence",z,I,M),At=O("values",z,I,M);return[tt.upperBound(bt,At)]}case"Unique":{const bt=O("x",z,I,M),At=tt.unique(bt);return[At.values,At.indices]}case"UniqueV2":{const bt=O("x",z,I,M),At=O("axis",z,I,M),Yt=tt.unique(bt,At);return[Yt.values,Yt.indices]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"image":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"ResizeBilinear":{const bt=O("images",z,I,M),At=O("size",z,I,M),Yt=O("alignCorners",z,I,M),kt=O("halfPixelCenters",z,I,M);return[tt.image.resizeBilinear(bt,[At[0],At[1]],Yt,kt)]}case"ResizeNearestNeighbor":{const bt=O("images",z,I,M),At=O("size",z,I,M),Yt=O("alignCorners",z,I,M),kt=O("halfPixelCenters",z,I,M);return[tt.image.resizeNearestNeighbor(bt,[At[0],At[1]],Yt,kt)]}case"CropAndResize":{const bt=O("image",z,I,M),At=O("boxes",z,I,M),Yt=O("boxInd",z,I,M),kt=O("cropSize",z,I,M),ae=O("method",z,I,M),nn=O("extrapolationValue",z,I,M);return[tt.image.cropAndResize(bt,At,Yt,kt,ae,nn)]}case"ImageProjectiveTransformV3":{const bt=O("images",z,I,M),At=O("transforms",z,I,M),Yt=O("outputShape",z,I,M),kt=O("fillValue",z,I,M),ae=O("interpolation",z,I,M),nn=O("fillMode",z,I,M);return[tt.image.transform(bt,At,ae.toLowerCase(),nn.toLowerCase(),kt,Yt)]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"graph":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Const":return I[z.name];case"PlaceholderWithDefault":const bt=O("default",z,I,M);return[Ct(z.name,I,M)||bt];case"Placeholder":return[Ct(z.name,I,M)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Bt(O("x",z,I,M))];case"IdentityN":return O("x",z,I,M).map(Ye=>Bt(Ye));case"Shape":return[tt.tensor1d(O("x",z,I,M).shape,"int32")];case"ShapeN":return O("x",z,I,M).map(Ye=>tt.tensor1d(Ye.shape));case"Size":return[tt.scalar(O("x",z,I,M).size,"int32")];case"Rank":return[tt.scalar(O("x",z,I,M).rank,"int32")];case"NoOp":return[tt.scalar(1)];case"Print":const Yt=O("x",z,I,M),kt=O("data",z,I,M),ae=O("message",z,I,M),nn=O("summarize",z,I,M);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(ae);for(let Ye=0;Ye<kt.length;Ye++)console.log(Array.prototype.slice.call(kt[Ye].dataSync()).slice(0,nn));return[Yt];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"logical":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Equal":return[tt.equal(O("a",z,I,M),O("b",z,I,M))];case"NotEqual":return[tt.notEqual(O("a",z,I,M),O("b",z,I,M))];case"Greater":return[tt.greater(O("a",z,I,M),O("b",z,I,M))];case"GreaterEqual":return[tt.greaterEqual(O("a",z,I,M),O("b",z,I,M))];case"Less":return[tt.less(O("a",z,I,M),O("b",z,I,M))];case"LessEqual":return[tt.lessEqual(O("a",z,I,M),O("b",z,I,M))];case"LogicalAnd":return[tt.logicalAnd(O("a",z,I,M),O("b",z,I,M))];case"LogicalNot":return[tt.logicalNot(O("a",z,I,M))];case"LogicalOr":return[tt.logicalOr(O("a",z,I,M),O("b",z,I,M))];case"Select":case"SelectV2":return[tt.where(O("condition",z,I,M),O("a",z,I,M),O("b",z,I,M))];case"BitwiseAnd":return[tt.bitwiseAnd(O("a",z,I,M),O("b",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"matrices":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[tt.matMul(O("a",z,I,M),O("b",z,I,M),O("transposeA",z,I,M),O("transposeB",z,I,M))];case"Einsum":return[tt.einsum(O("equation",z,I,M),...O("tensors",z,I,M))];case"Transpose":return[tt.transpose(O("x",z,I,M),O("perm",z,I,M))];case"_FusedMatMul":const[bt,At]=O("fusedOps",z,I,M),Yt="biasadd"===bt,kt="prelu"===At,ae=O("numArgs",z,I,M),nn=O("leakyreluAlpha",z,I,M);if(Yt){if(kt&&2!==ae)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!kt&&1!==ae)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[Ye,$e]=O("args",z,I,M);return[tt.fused.matMul({a:O("a",z,I,M),b:O("b",z,I,M),transposeA:O("transposeA",z,I,M),transposeB:O("transposeB",z,I,M),bias:Ye,activation:At,preluActivationWeights:$e,leakyreluAlpha:nn})];case"MatrixBandPart":return[tt.linalg.bandPart(O("a",z,I,M),O("numLower",z,I,M),O("numUpper",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"normalization":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"EuclideanNorm":return[tt.euclideanNorm(O("x",z,I,M),O("axis",z,I,M),O("keepDims",z,I,M))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[tt.batchNorm(O("x",z,I,M),O("mean",z,I,M),O("variance",z,I,M),O("offset",z,I,M),O("scale",z,I,M),O("epsilon",z,I,M))];case"LRN":return[tt.localResponseNormalization(O("x",z,I,M),O("radius",z,I,M),O("bias",z,I,M),O("alpha",z,I,M),O("beta",z,I,M))];case"Softmax":return[tt.softmax(O("x",z,I,M))];case"LogSoftmax":return[tt.logSoftmax(O("x",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"ragged":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"RaggedGather":{const{outputNestedSplits:bt,outputDenseValues:At}=tt.raggedGather(O("paramsNestedSplits",z,I,M),O("paramsDenseValues",z,I,M),O("indices",z,I,M),O("outputRaggedRank",z,I,M));return bt.concat(At)}case"RaggedRange":{const{rtNestedSplits:bt,rtDenseValues:At}=tt.raggedRange(O("starts",z,I,M),O("limits",z,I,M),O("splits",z,I,M));return[bt,At]}case"RaggedTensorToTensor":return[tt.raggedTensorToTensor(O("shape",z,I,M),O("values",z,I,M),O("defaultValue",z,I,M),O("rowPartitionTensors",z,I,M),O("rowPartitionTypes",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"reduction":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Max":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.max(O("x",z,I,M),kt,ae)]}case"Mean":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.mean(O("x",z,I,M),kt,ae)]}case"Min":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.min(O("x",z,I,M),kt,ae)]}case"Sum":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.sum(O("x",z,I,M),kt,ae)]}case"All":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.all(O("x",z,I,M),kt,ae)]}case"Any":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.any(O("x",z,I,M),kt,ae)]}case"ArgMax":{const kt=O("axis",z,I,M);return[tt.argMax(O("x",z,I,M),kt)]}case"ArgMin":{const kt=O("axis",z,I,M);return[tt.argMin(O("x",z,I,M),kt)]}case"Prod":{const kt=O("axis",z,I,M),ae=O("keepDims",z,I,M);return[tt.prod(O("x",z,I,M),kt,ae)]}case"Cumprod":{const kt=O("axis",z,I,M),ae=O("exclusive",z,I,M),nn=O("reverse",z,I,M);return[tt.cumprod(O("x",z,I,M),kt,ae,nn)]}case"Cumsum":{const kt=O("axis",z,I,M),ae=O("exclusive",z,I,M),nn=O("reverse",z,I,M);return[tt.cumsum(O("x",z,I,M),kt,ae,nn)]}case"Bincount":const bt=O("x",z,I,M),At=O("weights",z,I,M),Yt=O("size",z,I,M);return[tt.bincount(bt,At,Yt)];case"DenseBincount":{const kt=O("x",z,I,M),ae=O("weights",z,I,M),nn=O("size",z,I,M),Ye=O("binaryOutput",z,I,M);return[tt.denseBincount(kt,ae,nn,Ye)]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"slice_join":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"ConcatV2":case"Concat":{const bt=O("n",z,I,M),At=O("axis",z,I,M);let Yt=O("tensors",z,I,M);return Yt=Yt.slice(0,bt),[tt.concat(Yt,At)]}case"Gather":{const bt=O("x",z,I,M),At=O("indices",z,I,M);return[tt.gather(bt,tt.cast(At,"int32"),0)]}case"GatherV2":{const bt=O("axis",z,I,M),At=O("batchDims",z,I,M),Yt=O("x",z,I,M),kt=O("indices",z,I,M);return[tt.gather(Yt,tt.cast(kt,"int32"),bt,At)]}case"Reverse":{const bt=O("dims",z,I,M),At=[];for(let kt=0;kt<bt.length;kt++)bt[kt]&&At.push(kt);const Yt=O("x",z,I,M);return[tt.reverse(Yt,At)]}case"ReverseV2":{const bt=O("axis",z,I,M),At=O("x",z,I,M);return[tt.reverse(At,bt)]}case"Slice":{const bt=O("begin",z,I,M),At=O("size",z,I,M);return[tt.slice(O("x",z,I,M),bt,At)]}case"StridedSlice":{const bt=O("begin",z,I,M),At=O("end",z,I,M),Yt=O("strides",z,I,M),kt=O("beginMask",z,I,M),ae=O("endMask",z,I,M),nn=O("ellipsisMask",z,I,M),Ye=O("newAxisMask",z,I,M),$e=O("shrinkAxisMask",z,I,M),Cn=O("x",z,I,M);return[tt.stridedSlice(Cn,bt,At,Yt,kt,ae,nn,Ye,$e)]}case"Pack":return(0,q.tidy)(()=>{const bt=O("axis",z,I,M),At=O("tensors",z,I,M),Yt=At[0].shape,kt=tt.squeeze(At[0]).shape,ae=At.map(nn=>{const Ye=q.util.arraysEqual(nn.shape,Yt);if(!Ye&&!q.util.arraysEqual(tt.squeeze(nn).shape,kt))throw new Error("the input tensors shape does not match");return Ye?nn:tt.reshape(nn,Yt)});return[tt.stack(ae,bt)]});case"Unpack":{const bt=O("axis",z,I,M),At=O("tensor",z,I,M);return tt.unstack(At,bt)}case"Tile":{const bt=O("reps",z,I,M);return[tt.tile(O("x",z,I,M),bt)]}case"Split":case"SplitV":{const bt=O("axis",z,I,M),At=O("numOrSizeSplits",z,I,M),Yt=O("x",z,I,M);return tt.split(Yt,At,bt)}case"ScatterNd":{const bt=O("indices",z,I,M),At=O("values",z,I,M),Yt=O("shape",z,I,M);return[tt.scatterND(bt,At,Yt)]}case"GatherNd":{const bt=O("x",z,I,M),At=O("indices",z,I,M);return[tt.gatherND(bt,At)]}case"SparseToDense":{const bt=O("sparseIndices",z,I,M),At=O("outputShape",z,I,M),Yt=O("sparseValues",z,I,M),kt=O("defaultValue",z,I,M);return[tt.sparseToDense(bt,Yt,At,Yt.dtype===kt.dtype?kt:tt.cast(kt,Yt.dtype))]}case"TensorScatterUpdate":{const bt=O("indices",z,I,M),At=O("values",z,I,M),Yt=O("tensor",z,I,M);return[tt.tensorScatterUpdate(Yt,bt,At)]}default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"sparse":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"SparseFillEmptyRows":{const{outputIndices:bt,outputValues:At,emptyRowIndicator:Yt,reverseIndexMap:kt}=tt.sparse.sparseFillEmptyRows(O("indices",z,I,M),O("values",z,I,M),O("denseShape",z,I,M),O("defaultValue",z,I,M));return[bt,At,Yt,kt]}case"SparseReshape":{const{outputIndices:bt,outputShape:At}=tt.sparse.sparseReshape(O("inputIndices",z,I,M),O("inputShape",z,I,M),O("newShape",z,I,M));return[bt,At]}case"SparseSegmentMean":return[tt.sparse.sparseSegmentMean(O("data",z,I,M),O("indices",z,I,M),O("segmentIds",z,I,M))];case"SparseSegmentSum":return[tt.sparse.sparseSegmentSum(O("data",z,I,M),O("indices",z,I,M),O("segmentIds",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"spectral":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"FFT":return[tt.fft(O("x",z,I,M))];case"IFFT":return[tt.ifft(O("x",z,I,M))];case"RFFT":return[tt.rfft(O("x",z,I,M))];case"IRFFT":return[tt.irfft(O("x",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"string":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"StaticRegexReplace":return[tt.string.staticRegexReplace(O("input",z,I,M),O("pattern",z,I,M),O("rewrite",z,I,M),O("replaceGlobal",z,I,M))];case"StringNGrams":{const{nGrams:bt,nGramsSplits:At}=tt.string.stringNGrams(O("data",z,I,M),O("dataSplits",z,I,M),O("separator",z,I,M),O("nGramWidths",z,I,M),O("leftPad",z,I,M),O("rightPad",z,I,M),O("padWidth",z,I,M),O("preserveShortSequences",z,I,M));return[bt,At]}case"StringSplit":{const{indices:bt,values:At,shape:Yt}=tt.string.stringSplit(O("input",z,I,M),O("delimiter",z,I,M),O("skipEmpty",z,I,M));return[bt,At,Yt]}case"StringToHashBucketFast":return[tt.string.stringToHashBucketFast(O("input",z,I,M),O("numBuckets",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"transformation":return bt(()=>((z,I,M,tt=St)=>{switch(z.op){case"Cast":return[tt.cast(O("x",z,I,M),O("dtype",z,I,M))];case"ExpandDims":{const bt=O("axis",z,I,M);return[tt.expandDims(O("x",z,I,M),bt)]}case"Squeeze":{const bt=O("axis",z,I,M);return[tt.squeeze(O("x",z,I,M),bt)]}case"Reshape":return[tt.reshape(O("x",z,I,M),O("shape",z,I,M))];case"EnsureShape":return[tt.ensureShape(O("x",z,I,M),O("shape",z,I,M))];case"MirrorPad":return[tt.mirrorPad(O("x",z,I,M),O("padding",z,I,M),O("mode",z,I,M))];case"PadV2":case"Pad":return[tt.pad(O("x",z,I,M),O("padding",z,I,M),O("constantValue",z,I,M))];case"SpaceToBatchND":{const bt=O("blockShape",z,I,M),At=O("paddings",z,I,M);return[tt.spaceToBatchND(O("x",z,I,M),bt,At)]}case"BatchToSpaceND":{const bt=O("blockShape",z,I,M),At=O("crops",z,I,M);return[tt.batchToSpaceND(O("x",z,I,M),bt,At)]}case"DepthToSpace":{const bt=O("blockSize",z,I,M),At=O("dataFormat",z,I,M).toUpperCase();return[tt.depthToSpace(O("x",z,I,M),bt,At)]}case"BroadcastTo":return[tt.broadcastTo(O("x",z,I,M),O("shape",z,I,M))];case"BroadcastArgs":return[tt.broadcastArgs(O("s0",z,I,M),O("s1",z,I,M))];default:throw TypeError(`Node type ${z.op} is not implemented`)}})(Yt,kt,ae));case"hash_table":return Ma(Yt,kt,ae,tt);case"custom":const nn=nt(Yt.op);if(nn&&nn.customExecutor)return nn.customExecutor(new je(Yt,kt,ae));throw TypeError(`Custom op ${Yt.op} is not registered.`);default:throw TypeError(`Unknown op '${Yt.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(z,I,M);return q.util.isPromise(At)?At.then(Yt=>[].concat(Yt)):[].concat(At)}class Yi{constructor(I={},M={},tt={},bt={},At){this.weightMap=I,this.tensorArrayMap=M,this.tensorListMap=tt,this.functionMap=bt,this.parseNodeNameCache=At,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(I,M){return{id:I,frameName:M,iterationId:0}}set currentContext(I){this.contexts!==I&&(this.contexts=I,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const I=[];for(let M=0;M<this.contexts.length-1;M++){const tt=this.contexts.slice(0,this.contexts.length-M);I.push(this.contextIdforContexts(tt))}I.push(""),this._currentContextIds=I}contextIdforContexts(I){return I?I.map(M=>0===M.id&&0===M.iterationId?"":`${M.frameName}-${M.iterationId}`).join("/"):""}enterFrame(I){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,I)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const I=Object.assign({},this.contexts[this.contexts.length-1]);I.iterationId+=1,I.id=this.lastId,this.contexts.splice(-1,1,I),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(I){return this.weightMap[I]}addTensorArray(I){this.tensorArrayMap[I.id]=I}getTensorArray(I){return this.tensorArrayMap[I]}addTensorList(I){this.tensorListMap[I.id]=I}getTensorList(I){return this.tensorListMap[I]}dispose(I){for(const M in this.tensorArrayMap)this.tensorArrayMap[M].clearAndClose(I);for(const M in this.tensorListMap)this.tensorListMap[M].clearAndClose(I)}}function Ra(z,I,M,tt){const bt=new Set,At=[];let Yt=null,kt=null;const ae=new Set,nn=new Set(Object.keys(z).map(Cn=>Mt(Cn)[0]));tt=tt||[];const Ye=new Set(tt.map(Cn=>Mt(Cn.name)[0])),$e=[...I];for(;$e.length>0;){const Cn=$e.pop();if((Kr(Cn)||mr(Cn)||ai(Cn))&&null==Yt&&(Yt=Cn,kt=Yt.children.map($n=>$n.name).filter($n=>bt.has($n))),bt.add(Cn.name),null==M[Cn.name]&&!nn.has(Cn.name)&&!Ye.has(Cn.name)){if(0===Cn.inputs.length){At.push(Cn.name);continue}Cn.inputs.forEach($n=>{ae.has($n.name)||(ae.add($n.name),$e.push($n))})}}return{inputs:z,outputs:I,usedNodes:bt,missingInputs:At,dynamicNode:Yt,syncInputs:kt}}class Fn extends Error{constructor(I){super(`NodesExecutionOrderError: ${I}`)}}const ks=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Ur=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),We=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Kr(z){return ks.has(z.op)}function mr(z){return Ur.has(z.op)}function ai(z){return We.has(z.op)}class Kn{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(I){const M=Object.keys(I).map(tt=>I[tt].map(bt=>bt.id));this._weightIds=[].concat(...M),this._weightMap=I}set resourceManager(I){this._resourceManager=I}get inputs(){return this._inputs.map(I=>({name:I.name,shape:I.attrParams.shape?I.attrParams.shape.value:void 0,dtype:I.attrParams.dtype?I.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(I=>({name:I.name,shape:I.attrParams.shape?I.attrParams.shape.value:void 0,dtype:I.attrParams.dtype?I.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(I=>I.signatureKey||I.name)}get outputNodes(){return this._outputs.map(I=>{const M=I.signatureKey||I.name;return I.defaultOutput?`${M}:${I.defaultOutput}`:M})}get functions(){return Object.keys(this._functions).reduce((I,M)=>(I[M]=this._functions[M].signature,I),{})}constructor(I,M){this.graph=I,this.parent=M,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=I.outputs,this._inputs=I.inputs,this._initNodes=I.initNodes,this._signature=I.signature,this._functions=I.functions,null!=I.functions&&Object.keys(I.functions).forEach(tt=>{this._functionExecutorMap[tt]=new Kn(I.functions[tt],this)})}getCompilationKey(I,M){const tt=I.map(At=>At.name).sort(),bt=M.map(At=>At.name).sort();return tt.join(this.SEPARATOR)+"--"+bt.join(this.SEPARATOR)}compile(I,M){const tt=Ra(I,M,this.weightMap,this._initNodes),{missingInputs:bt,dynamicNode:At,syncInputs:Yt}=tt;if(null!=At)throw new Error(`This execution contains the node '${At.name}', which has the dynamic op '${At.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${Yt}]`);if(bt.length>0){const nn=M.map($e=>$e.name),Ye=Object.keys(I);throw new Error(`Cannot compute the outputs [${nn}] from the provided inputs [${Ye}]. Missing the following inputs: [${bt}]`)}const kt=function an(z,I){const{usedNodes:M,inputs:tt}=I,Yt=bn=>M.has("string"==typeof bn?bn:bn.name);function kt(bn){return[...new Map(bn.map(_r=>[_r.name,_r])).values()]}const ae=kt([...Object.keys(tt).map(bn=>Mt(bn)[0]).map(bn=>z.nodes[bn]),...z.weights,...z.initNodes||[]]).filter(Yt),nn=kt([...ae,...Object.values(z.nodes)]).filter(Yt),Ye=new Map(nn.map(bn=>[bn.name,bn])),$e={};for(const bn of nn){$e[bn.name]=$e[bn.name]||0;for(const _r of bn.children)Yt(_r)||($e[_r.name]=Number.POSITIVE_INFINITY),$e[_r.name]=($e[_r.name]||0)+1}const Cn=Object.entries($e).filter(([,bn])=>0===bn).map(([bn])=>bn),$n=[...Cn];for(;Cn.length>0;){const bn=Cn.pop(),_r=Ye.get(bn);for(const ni of _r.children.filter(Yt))0==--$e[ni.name]&&($n.push(ni.name),Cn.push(ni.name))}const vr=function ei(z,I){const M=new Map(z.map(Yt=>[Yt.name,Yt])),tt=I.map(Yt=>Yt.name),bt=new Set(tt);for(;tt.length>0;){const Yt=tt.pop(),kt=M.get(Yt);for(const ae of kt.children)!M.has(ae.name)||bt.has(ae.name)||(bt.add(ae.name),tt.push(ae.name))}return z.filter(Yt=>bt.has(Yt.name))}($n.map(bn=>Ye.get(bn)),ae);return function Ss(z,I){const M=new Map(z.map((kt,ae)=>[kt.name,ae])),tt=new Set(I.map(kt=>kt.name)),bt=kt=>tt.has("string"==typeof kt?kt:kt.name),At=new Set(z.map(kt=>kt.name)),Yt=kt=>At.has("string"==typeof kt?kt:kt.name);for(const kt of z){for(const ae of kt.children.filter(Yt)){if(!M.has(ae.name))throw new Fn(`Child ${ae.name} of node ${kt.name} is unreachable.`);if(M.get(kt.name)>M.get(ae.name))throw new Fn(`Node ${kt.name} is scheduled to run after its child ${ae.name}.`)}if(!bt(kt))for(const ae of kt.inputs){if(!M.has(ae.name))throw new Fn(`Input ${ae.name} of node ${kt.name} is unreachable.`);if(M.get(ae.name)>M.get(kt.name))throw new Fn(`Node ${kt.name} is scheduled to run before its input ${ae.name}.`)}}}(vr,ae),vr}(this.graph,tt),ae=function wo(z){const I=new Map(z.map((kt,ae)=>[kt.name,ae])),M=Number.MAX_SAFE_INTEGER,tt=z.map((kt,ae)=>Kr(kt)?M:ae),bt=kt=>tt[I.get(kt.name)]??-1,At=z.map((kt,ae)=>kt.children.map(bt).reduce((nn,Ye)=>Math.max(nn,Ye),tt[ae])),Yt=new Map;for(let kt=0;kt<z.length;++kt){const ae=At[kt];if(ae===M)continue;const nn=z[kt],Ye=z[ae];Yt.has(Ye.name)||Yt.set(Ye.name,[]),Yt.get(Ye.name).push(nn)}return Yt}(kt);return{orderedNodes:kt,nodeLiveUntilMap:ae}}cloneAndKeepTensor(I){if(null==I)return null;const M=I.clone();return(0,q.keep)(M),M}cloneTensorList(I){return I?I.map(tt=>this.cloneAndKeepTensor(tt)):null}cloneTensorMap(I){return Object.fromEntries(Object.entries(I).map(([M,tt])=>[M,this.cloneTensorList(tt)]))}execute(I,M){this.disposeIntermediateTensors(),I=this.mapInputs(I);const tt=Object.keys(I).sort();this.checkInputs(I),this.checkInputShapeAndType(I),M=this.mapOutputs(M),this.checkOutputs(M);const bt=tt.map(Cn=>this.graph.nodes[Mt(Cn)[0]]),At=M.map(Cn=>Mt(Cn)[0]),Yt=new Set(At);let kt=At.map(Cn=>this.graph.nodes[Cn]);0===kt.length&&(kt=this._outputs);const ae=this.getCompilationKey(bt,kt);let nn=this.compiledMap.get(ae);null==nn&&(nn=this.compile(I,kt),this.compiledMap.set(ae,nn));try{this.keepIntermediateTensors=(0,q.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(Cn){this.keepIntermediateTensors=!1,console.warn(Cn.message)}const Ye={},$e={};return(0,q.tidy)(()=>{const Cn=new Yi(this.weightMap,Ye,$e,this.functionExecutorMap,this.parseNodeNameCache),$n=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(I).forEach(_r=>{const[ni,Zs]=Mt(_r,Cn),Xr=[];Xr[Zs]=I[_r],$n[ni]=Xr,this.keepIntermediateTensors&&(this.clonedTensorsMap[ni]=this.cloneTensorList(Xr))});const Vn=this.getFrozenTensorIds($n),{orderedNodes:vr,nodeLiveUntilMap:bn}=nn;for(const _r of vr){if($n[_r.name])continue;const ni=Cs(_r,$n,Cn,this._resourceManager);if(q.util.isPromise(ni))throw new Error(`The execution of the op '${_r.op}' returned a promise. Please use model.executeAsync() instead.`);$n[_r.name]=ni,this.keepIntermediateTensors&&(this.clonedTensorsMap[_r.name]=this.cloneTensorList(ni)),this.checkTensorForDisposalWithNodeLiveUntilInfo(_r,$n,Cn,Vn,Yt,bn.get(_r.name))}return null==this.parent&&Cn.dispose(Vn),M.map(_r=>Ct(_r,$n,Cn))})}getFrozenTensorIds(I){const M=[].concat.apply([],Object.keys(I).map(tt=>I[tt]).map(tt=>tt.map(bt=>bt.id)));return new Set(M)}checkTensorForDisposal(I,M,tt,bt,At,Yt,kt){if(!Kr(M)&&!Yt.has(I)){for(const ae of tt[I])null!=ae&&(kt[ae.id]=(kt[ae.id]||0)+M.children.length);for(const ae of M.inputs){if(Kr(ae))continue;const nn=yt(ae.name,tt,bt);if(null!=nn)for(const Ye of nn){if(!Ye||Ye.kept||At.has(Ye.id))continue;const $e=kt[Ye.id];1===$e?(Ye.dispose(),delete kt[Ye.id]):null!=$e&&kt[Ye.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(I,M,tt,bt,At,Yt){function kt(ae){return Kr(ae)||At.has(ae.name)}if(!Kr(I)&&null!=Yt)for(const ae of Yt){if(kt(ae))continue;const nn=yt(ae.name,M,tt);for(const Ye of nn)!Ye||Ye.kept||bt.has(Ye.id)||Ye.dispose()}}executeAsync(I,M){var tt=this;return(0,pt.Z)(function*(){return tt._executeAsync(I,M)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(I=>{for(const M of I)M&&!M.isDisposed&&M.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(I,M,tt=!1,bt={},At={}){var Yt=this;return(0,pt.Z)(function*(){Yt.disposeIntermediateTensors(),tt||(I=Yt.mapInputs(I),Yt.checkInputs(I),Yt.checkInputShapeAndType(I),M=Yt.mapOutputs(M),Yt.checkOutputs(M));try{Yt.keepIntermediateTensors=(0,q.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch($n){Yt.keepIntermediateTensors=!1,console.warn($n.message)}const kt=new Yi(Yt.weightMap,bt,At,Yt.functionExecutorMap,Yt.parseNodeNameCache);Yt.keepIntermediateTensors&&(Yt.clonedTensorsMap=Yt.cloneTensorMap(Yt.weightMap));const ae=yield Yt.executeWithControlFlow(I,kt,M,tt),nn=M.map($n=>Ct($n,ae,kt)),Ye=nn.map($n=>$n.id),$e=Object.keys(I).map($n=>I[$n].id),Cn=new Set([...Ye,...$e,...Yt.weightIds]);return Object.values(ae).forEach($n=>{$n.forEach(Vn=>{Vn&&!Vn.isDisposed&&!Cn.has(Vn.id)&&Vn.dispose()})}),null==Yt.parent&&kt.dispose(Cn),nn})()}executeFunctionAsync(I,M,tt){var bt=this;return(0,pt.Z)(function*(){const At=I.reduce((Yt,kt,ae)=>(Yt[bt.inputs[ae].name]=kt,Yt),{});return bt._executeAsync(At,bt.outputNodes,!0,M,tt)})()}executeWithControlFlow(I,M,tt,bt){var At=this;return(0,pt.Z)(function*(){const Yt=Object.keys(I),kt=Yt.map(tn=>At.graph.nodes[Mt(tn)[0]]),ae=tt.map(tn=>Mt(tn)[0]),nn=new Set(ae);let Ye=ae.map(tn=>At.graph.nodes[tn]);0===Ye.length&&(Ye=At._outputs);const{usedNodes:$e,missingInputs:Cn,dynamicNode:$n,syncInputs:Vn}=Ra(I,Ye,At.weightMap,At._initNodes),vr=[...kt,...At.graph.weights,...At._initNodes||[]].map(tn=>({node:tn,contexts:M.currentContext})),bn=Object.assign({},At.weightMap);Object.keys(I).forEach(tn=>{const[Iu,xr]=Mt(tn),Qi=[];Qi[xr]=I[tn],bn[Iu]=Qi});const _r={},ni=At.getFrozenTensorIds(bn),Zs={};for(;vr.length>0;){const tn=At.processStack(kt,vr,M,bn,Zs,ni,nn,_r,$e);yield Promise.all(tn)}null==$n&&!bt&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const Xr=Ye.filter(tn=>!Kr(tn)&&!Ct(tn.name,bn,M)).map(tn=>tn.name);if(Xr.length>0){let tn="";throw null!=$n&&(tn=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${Vn}]`),new Error(`Cannot compute the outputs [${Xr}] from the provided inputs [${Yt}]. Consider providing the following inputs: [${Cn}]. ${tn}`)}return bn})()}processStack(I,M,tt,bt,At,Yt,kt,ae,nn){const Ye=[];for(;M.length>0;){const $e=M.pop();tt.currentContext=$e.contexts;let Cn="";if("Enter"===$e.node.op&&O("isConstant",$e.node,bt,tt)&&([Cn]=vt($e.node.name,tt)),null==bt[$e.node.name]){const $n=Cs($e.node,bt,tt,this._resourceManager);Cn||([Cn]=vt($e.node.name,tt));const Vn=tt.currentContext;q.util.isPromise($n)?Ye.push($n.then(vr=>(bt[Cn]=vr,this.keepIntermediateTensors&&(this.clonedTensorsMap[Cn]=this.cloneTensorList(vr)),tt.currentContext=Vn,this.checkTensorForDisposal(Cn,$e.node,bt,tt,Yt,kt,ae),this.processChildNodes($e.node,M,tt,bt,At,nn),vr))):(bt[Cn]=$n,this.keepIntermediateTensors&&(this.clonedTensorsMap[Cn]=this.cloneTensorList($n)),this.checkTensorForDisposal(Cn,$e.node,bt,tt,Yt,kt,ae),this.processChildNodes($e.node,M,tt,bt,At,nn))}else this.processChildNodes($e.node,M,tt,bt,At,nn)}return Ye}processChildNodes(I,M,tt,bt,At,Yt){I.children.forEach(kt=>{const[ae]=vt(kt.name,tt);At[ae]||!Yt.has(kt.name)||("Merge"===kt.op?kt.inputNames.some(nn=>!!Ct(nn,bt,tt))&&(At[ae]=!0,M.push({contexts:tt.currentContext,node:kt})):kt.inputNames.every(nn=>!!Ct(nn,bt,tt))&&(At[ae]=!0,M.push({contexts:tt.currentContext,node:kt})))})}dispose(){Object.keys(this.weightMap).forEach(I=>this.weightMap[I].forEach(M=>M.dispose()))}checkInputShapeAndType(I){Object.keys(I).forEach(M=>{const tt=I[M],[bt]=Mt(M),At=this.graph.nodes[bt];if(At.attrParams.shape&&At.attrParams.shape.value){const Yt=At.attrParams.shape.value,kt=Yt.length===tt.shape.length&&tt.shape.every((ae,nn)=>-1===Yt[nn]||Yt[nn]===ae);q.util.assert(kt,()=>`The shape of dict['${At.name}'] provided in model.execute(dict) must be [${Yt}], but was [${tt.shape}]`)}At.attrParams.dtype&&At.attrParams.dtype.value&&q.util.assert(tt.dtype===At.attrParams.dtype.value,()=>`The dtype of dict['${At.name}'] provided in model.execute(dict) must be ${At.attrParams.dtype.value}, but was ${tt.dtype}`)})}mapInputs(I){var M,tt;const bt={};for(const At in I){const Yt=null===(tt=null===(M=this._signature)||void 0===M?void 0:M.inputs)||void 0===tt?void 0:tt[At];null!=Yt?bt[Yt.name]=I[At]:bt[At]=I[At]}return bt}checkInputs(I){const M=Object.keys(I).filter(tt=>{const[bt]=Mt(tt);return null==this.graph.nodes[bt]});if(M.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${M}] that are not part of graph`)}mapOutputs(I){return I.map(M=>{var tt,bt;const At=null===(bt=null===(tt=this._signature)||void 0===tt?void 0:tt.outputs)||void 0===bt?void 0:bt[M];return null!=At?At.name:M},{})}checkOutputs(I){I.forEach(M=>{const[tt]=Mt(M);if(!this.graph.nodes[tt])throw new Error(`The output '${M}' is not found in the graph`)})}}class Pr{constructor(I={},M={}){this.hashTableNameToHandle=I,this.hashTableMap=M}addHashTable(I,M){this.hashTableNameToHandle[I]=M.handle,this.hashTableMap[M.id]=M}getHashTableHandleByName(I){return this.hashTableNameToHandle[I]}getHashTableById(I){return this.hashTableMap[I]}dispose(){for(const I in this.hashTableMap)this.hashTableMap[I].clearAndClose(),delete this.hashTableMap[I];for(const I in this.hashTableNameToHandle)this.hashTableNameToHandle[I].dispose(),delete this.hashTableNameToHandle[I]}}var wr=y(8339);const Wr="?tfjs-format=file",Ds="model.json";class ss{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(I,M={},tt=q.io){this.modelUrl=I,this.loadOptions=M,this.version="n/a",this.io=tt,null==M&&(this.loadOptions={}),this.resourceManager=new Pr}findIOHandler(){const I=this.modelUrl;if(null!=I.load)this.handler=I;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(I,this.loadOptions);else{const M=this.io.getLoadHandlers(I,this.loadOptions);if(0===M.length)M.push(this.io.browserHTTPRequest(I,this.loadOptions));else if(M.length>1)throw new Error(`Found more than one (${M.length}) load handlers for URL '${[I]}'`);this.handler=M[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const I=this.handler.load();return q.util.isPromise(I)?I.then(M=>null==M.getWeightStream?this.loadSync(M):this.loadStreaming(M)):this.loadSync(I)}loadSync(I){const M=this.io.decodeWeights(I.weightData,I.weightSpecs);return this.loadWithWeightMap(I,M)}loadStreaming(I){var M=this;return(0,pt.Z)(function*(){if(null==I.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const tt=yield(0,wr.r)(I.getWeightStream(),I.weightSpecs);return M.loadWithWeightMap(I,tt)})()}loadWithWeightMap(I,M){this.artifacts=I;const tt=this.artifacts.modelTopology;let bt=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const At=this.artifacts.userDefinedMetadata;null!=At.signature&&(bt=At.signature),null!=At.structuredOutputKeys&&(this.structuredOutputKeys=At.structuredOutputKeys)}if(this.signature=bt,this.version=`${tt.versions.producer}.${tt.versions.minConsumer}`,this.executor=new Kn(di.Instance.transformGraph(tt,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(M),this.executor.resourceManager=this.resourceManager,null!=I.modelInitializer&&null!=I.modelInitializer.node){const At=di.Instance.transformGraph(I.modelInitializer);this.initializer=new Kn(At),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=I.initializerSignature}return!0}save(I,M){var tt=this;return(0,pt.Z)(function*(){if("string"==typeof I){const bt=tt.io.getSaveHandlers(I);if(0===bt.length)throw new Error(`Cannot find any save handlers for URL '${I}'`);if(bt.length>1)throw new Error(`Found more than one (${bt.length}) save handlers for URL '${I}'`);I=bt[0]}if(null==I.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return I.save(tt.artifacts)})()}addStructuredOutputNames(I){if(this.structuredOutputKeys){const tt={};return(I instanceof q.Tensor?[I]:I).forEach((bt,At)=>tt[this.structuredOutputKeys[At]]=bt),tt}return I}predict(I,M){const tt=this.execute(I,this.outputNodes);return this.addStructuredOutputNames(tt)}predictAsync(I,M){var tt=this;return(0,pt.Z)(function*(){const bt=yield tt.executeAsync(I,tt.outputNodes);return tt.addStructuredOutputNames(bt)})()}normalizeInputs(I){var M;if(!(I instanceof q.Tensor||Array.isArray(I))){const At=null===(M=this.signature)||void 0===M?void 0:M.inputs;if(null!=At)for(const Yt in At){const kt=At[Yt];null!=kt.resourceId&&(I[Yt]=this.resourceIdToCapturedInput[kt.resourceId])}return I}I=Array.isArray(I)?I:[I];const tt=Object.keys(this.resourceIdToCapturedInput).length;if(I.length+tt!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-tt} non-resource placeholders, while there are ${I.length} input tensors provided.`);let bt=0;return this.inputNodes.reduce((At,Yt)=>{var kt,ae,nn;const Ye=null===(nn=null===(ae=null===(kt=this.signature)||void 0===kt?void 0:kt.inputs)||void 0===ae?void 0:ae[Yt])||void 0===nn?void 0:nn.resourceId;return At[Yt]=null!=Ye?this.resourceIdToCapturedInput[Ye]:I[bt++],At},{})}normalizeOutputs(I){return I=I||this.outputNodes,Array.isArray(I)?I:[I]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var I=this;return(0,pt.Z)(function*(){return null==I.initializer?[]:I.initializer.executeAsync({},null==I.initializerSignature?[]:Object.keys(I.initializerSignature.outputs))})()}setResourceIdToCapturedInput(I){if(this.resourceIdToCapturedInput={},this.initializerSignature){const M=this.initializerSignature.outputs,tt=Object.keys(M);for(let bt=0;bt<tt.length;bt++)this.resourceIdToCapturedInput[M[tt[bt]].resourceId]=I[bt]}}execute(I,M){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),I=this.normalizeInputs(I),M=this.normalizeOutputs(M);const tt=this.executor.execute(I,M);return tt.length>1?tt:tt[0]}executeAsync(I,M){var tt=this;return(0,pt.Z)(function*(){null==tt.resourceIdToCapturedInput&&tt.setResourceIdToCapturedInput(yield tt.executeInitializerGraphAsync()),I=tt.normalizeInputs(I),M=tt.normalizeOutputs(M);const bt=yield tt.executor.executeAsync(I,M);return bt.length>1?bt:bt[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(I){return Object.keys(I).reduce((M,tt)=>(M[tt]=[I[tt]],M),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,q.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function wu(z){return Fo.apply(this,arguments)}function Fo(){return(Fo=(0,pt.Z)(function*(z,I={},M=q.io){if(null==z)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==I&&(I={}),I.fromTFHub&&"string"==typeof z&&(z=function os(z){return z.endsWith("/")||(z+="/"),`${z}${Ds}${Wr}`}(z));const tt=new ss(z,I,M);return yield tt.load(),tt})).apply(this,arguments)}function Or(z){if(null==z)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let I;if(z instanceof Array){const[tt,bt]=z;if(!tt)throw new Error("modelJSON must be the first element of the array");if(!(bt&&bt instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in tt))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in tt))throw new Error("Model JSON is missing 'weightsManifest'");const At=q.io.getWeightSpecs(tt.weightsManifest),Yt=q.io.getModelArtifactsForJSONSync(tt,At,bt);I=q.io.fromMemorySync(Yt)}else if("load"in z)I=z;else{if(!("modelTopology"in z&&"weightSpecs"in z&&"weightData"in z))throw new Error("Unknown model format");I=q.io.fromMemorySync(z)}const M=new ss(I);return M.load(),M}const _e="4.17.0"},7173:(Lt,ut,y)=>{"use strict";y.d(ut,{JL:()=>H,Zu:()=>Q});class H{constructor(W,k){this.backend=W,this.dataMover=k,this.data=new WeakMap,this.dataIdsCount=0}get(W){return this.data.has(W)||this.dataMover.moveData(this.backend,W),this.data.get(W)}set(W,k){this.dataIdsCount++,this.data.set(W,k)}has(W){return this.data.has(W)}delete(W){return this.dataIdsCount--,this.data.delete(W)}numDataIds(){return this.dataIdsCount}}class Q{refCount(W){return Y("refCount")}incRef(W){return Y("incRef")}timerAvailable(){return!0}time(W){return Y("time")}read(W){return Y("read")}readSync(W){return Y("readSync")}readToGPU(W,k){return Y("readToGPU")}numDataIds(){return Y("numDataIds")}disposeData(W,k){return Y("disposeData")}write(W,k,A){return Y("write")}move(W,k,A,X,Z){return Y("move")}createTensorFromGPUData(W,k,A){return Y("createTensorFromGPUData")}memory(){return Y("memory")}floatPrecision(){return Y("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Y("dispose")}}function Y(R){throw new Error(`'${R}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},5672:(Lt,ut,y)=>{"use strict";function $(G,it,wt){const K=function V(G,it,wt){return function Q(G,it,wt){let K=0,st=G.length,et=0,dt=!1;for(;K<st;){et=K+(st-K>>>1);const lt=wt(it,G[et]);lt>0?K=et+1:(st=et,dt=!lt)}return dt?K:-K-1}(G,it,wt||H)}(G,it,wt);G.splice(K<0?-(K+1):K,0,it)}function H(G,it){return G>it?1:G<it?-1:0}function Y(G,it,wt,K,st){return k(G,it,wt,K,st,0)}function R(G,it,wt,K,st,et){return k(G,it,wt,K,st,0,!1,et,!0)}function W(G,it,wt,K,st,et){return k(G,it,wt,K,st,et,!0)}function k(G,it,wt,K,st,et,dt=!1,lt=!1,St=!1){const q=[];for(let nt=0;nt<it.length;nt++)it[nt]>st&&q.push({score:it[nt],boxIndex:nt,suppressBeginIndex:0});q.sort(Z);const ft=et>0?-.5/et:0,pt=[],B=[];for(;pt.length<wt&&q.length>0;){const nt=q.pop(),{score:Gt,boxIndex:O,suppressBeginIndex:Ct}=nt;if(Gt<st)break;let yt=!1;for(let vt=pt.length-1;vt>=Ct;--vt){const xt=A(G,O,pt[vt]);if(xt>=K){yt=!0;break}if(nt.score=nt.score*X(K,ft,xt),nt.score<=st)break}nt.suppressBeginIndex=pt.length,yt||(nt.score===Gt?(pt.push(O),B.push(nt.score)):nt.score>st&&$(q,nt,Z))}const ot=pt.length,P=wt-ot;lt&&P>0&&(pt.push(...new Array(P).fill(0)),B.push(...new Array(P).fill(0)));const at={selectedIndices:pt};return dt&&(at.selectedScores=B),St&&(at.validOutputs=ot),at}function A(G,it,wt){const K=G.subarray(4*it,4*it+4),st=G.subarray(4*wt,4*wt+4),et=Math.min(K[0],K[2]),dt=Math.min(K[1],K[3]),lt=Math.max(K[0],K[2]),St=Math.max(K[1],K[3]),q=Math.min(st[0],st[2]),ft=Math.min(st[1],st[3]),pt=Math.max(st[0],st[2]),B=Math.max(st[1],st[3]),ot=(lt-et)*(St-dt),P=(pt-q)*(B-ft);if(ot<=0||P<=0)return 0;const at=Math.max(et,q),nt=Math.max(dt,ft),Gt=Math.min(lt,pt),O=Math.min(St,B),Ct=Math.max(Gt-at,0)*Math.max(O-nt,0);return Ct/(ot+P-Ct)}function X(G,it,wt){const K=Math.exp(it*wt*wt);return wt<=G?K:0}function Z(G,it){return G.score-it.score||G.score===it.score&&it.boxIndex-G.boxIndex}y.d(ut,{GP:()=>Y,qP:()=>R,pA:()=>W})},7349:(Lt,ut,y)=>{"use strict";y.d(ut,{Z:()=>V});var $=y(582);function V(H,Q){const Y=[];for(let k=0;k<Q.length;k++)Q[k]&&Y.push(k);const R=(0,$.f)(H,"int32"),W=(0,$.f)([Y.length,H.length],"int32");for(let k=0;k<Y.length;k++){const A=R.indexToLoc(Y[k]);W.values.set(A,k*H.length)}return W.toTensor()}},687:(Lt,ut,y)=>{"use strict";y.d(ut,{BV:()=>ft,wv:()=>q});var $=y(5861),V=y(7173),H=y(5527),Q=y(2918),Y=y(4251),R=y(8987),W=y(2932),k=y(1153),A=y(5359);class X{constructor(ot,P){this.backendTimer=ot,this.logger=P,null==P&&(this.logger=new G)}profileKernel(ot,P,at){let nt;const Gt=()=>{nt=at()};let O;const Ct=k.now();if(this.backendTimer.timerAvailable())O=this.backendTimer.time(Gt);else{Gt();for(const vt of nt)vt.dataSync();O=Promise.resolve({kernelMs:k.now()-Ct})}if((0,H.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let vt=0;vt<nt.length;vt++){const xt=nt[vt];xt.data().then(Mt=>{Z(Mt,xt.dtype,ot)})}return{kernelName:ot,outputs:nt,inputs:P,timeMs:O.then(vt=>vt.kernelMs),extraInfo:O.then(vt=>null!=vt.getExtraProfileInfo?vt.getExtraProfileInfo():"")}}logKernelProfile(ot){const{kernelName:P,outputs:at,timeMs:nt,inputs:Gt,extraInfo:O}=ot;at.forEach(Ct=>{Promise.all([Ct.data(),nt,O]).then(yt=>{this.logger.logKernelProfile(P,Ct,yt[0],yt[1],Gt,yt[2])})})}}function Z(B,ot,P){if("float32"!==ot)return!1;for(let at=0;at<B.length;at++){const nt=B[at];if(isNaN(nt)||!isFinite(nt))return console.warn(`Found ${nt} in the result of '${P}'`),!0}return!1}class G{logKernelProfile(ot,P,at,nt,Gt,O){const Ct="number"==typeof nt?A.oj(`${nt}ms`,9):nt.error,yt=A.oj(ot,25),vt=P.rank,xt=P.size,Mt=A.oj(P.shape.toString(),14);let It="";for(const re in Gt){const Bt=Gt[re];if(null!=Bt){const ee=Bt.shape||P.shape,jt=ee.length;It+=`${re}: ${jt}D ${jt>0?ee:""} `}}console.log(`%c${yt}\t%c${Ct}\t%c${vt}D ${Mt}\t%c${xt}\t%c${It}\t%c${O}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var K=y(4945),st=y(7664);function et(B){return null!=B.kernelName}class dt{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(ot=>ot.name)))}}}dispose(){for(const ot in this.registeredVariables)this.registeredVariables[ot].dispose()}}let lt=(()=>{class B{constructor(P){this.ENV=P,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new dt}ready(){var P=this;return(0,$.Z)(function*(){if(null!=P.pendingBackendInit)return P.pendingBackendInit.then(()=>{});if(null!=P.backendInstance)return;const at=P.getSortedBackends();for(let nt=0;nt<at.length;nt++){const Gt=at[nt];if(yield P.initializeBackend(Gt).success)return void(yield P.setBackend(Gt))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:P,asyncInit:at}=this.initializeBackendsAndReturnBest();if(at)throw new Error(`The highest priority backend '${P}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(P)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(P){if(!(P in this.registry)){if(!(P in this.registryFactory))return null;{const{asyncInit:at}=this.initializeBackend(P);if(at)return null}}return this.registry[P]}findBackendFactory(P){return P in this.registryFactory?this.registryFactory[P].factory:null}registerBackend(P,at,nt=1){return P in this.registryFactory?(W.Z(`${P} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[P]={factory:at,priority:nt},!0)}setBackend(P){var at=this;return(0,$.Z)(function*(){if(null==at.registryFactory[P])throw new Error(`Backend name '${P}' not found in registry`);if(at.backendName=P,null==at.registry[P]){at.backendInstance=null;const{success:nt,asyncInit:Gt}=at.initializeBackend(P);if(!(Gt?yield nt:nt))return!1}return at.backendInstance=at.registry[P],at.setupRegisteredKernels(),at.profiler=new X(at.backendInstance),!0})()}setupRegisteredKernels(){(0,R.tr)(this.backendName).forEach(at=>{null!=at.setupFunc&&at.setupFunc(this.backendInstance)})}disposeRegisteredKernels(P){(0,R.tr)(P).forEach(nt=>{null!=nt.disposeFunc&&nt.disposeFunc(this.registry[P])})}initializeBackend(P){const at=this.registryFactory[P];if(null==at)throw new Error(`Cannot initialize backend ${P}, no registration found.`);try{const nt=at.factory();if(!nt||nt instanceof V.Zu||"function"!=typeof nt.then)return this.registry[P]=nt,{success:!0,asyncInit:!1};{const Gt=++this.pendingBackendInitId,O=nt.then(Ct=>!(Gt<this.pendingBackendInitId||(this.registry[P]=Ct,this.pendingBackendInit=null,0))).catch(Ct=>(Gt<this.pendingBackendInitId||(this.pendingBackendInit=null,W.Z(`Initialization of backend ${P} failed`),W.Z(Ct.stack||Ct.message)),!1));return this.pendingBackendInit=O,{success:O,asyncInit:!0}}}catch(nt){return W.Z(`Initialization of backend ${P} failed`),W.Z(nt.stack||nt.message),{success:!1,asyncInit:!1}}}removeBackend(P){if(!(P in this.registryFactory))throw new Error(`${P} backend not found in registry`);this.backendName===P&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,P in this.registry&&(this.disposeRegisteredKernels(P),this.registry[P].dispose(),delete this.registry[P]),delete this.registryFactory[P],this.backendName===P&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((P,at)=>this.registryFactory[at].priority-this.registryFactory[P].priority)}initializeBackendsAndReturnBest(){const P=this.getSortedBackends();for(let at=0;at<P.length;at++){const nt=P[at],{success:Gt,asyncInit:O}=this.initializeBackend(nt);if(O||Gt)return{name:nt,asyncInit:O}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(P,at){const nt=this.state.tensorInfo.get(at),Gt=nt.backend,O=this.readSync(at),Ct=Gt.refCount(at);Gt.disposeData(at,!0),nt.backend=P,P.move(at,O,nt.shape,nt.dtype,Ct),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(P,at){let Gt,nt=null;if(null==at){if("function"!=typeof P)throw new Error("Please provide a function to tidy()");at=P}else{if("string"!=typeof P&&!(P instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof at)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");nt=P}return this.scopedRun(()=>this.startScope(nt),()=>this.endScope(Gt),()=>(Gt=at(),Gt instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Gt))}scopedRun(P,at,nt){P();try{const Gt=nt();return at(),Gt}catch(Gt){throw at(),Gt}}nextTensorId(){return B.nextTensorId++}nextVariableId(){return B.nextVariableId++}clone(P){const at=ft.runKernel(Y.iJz,{x:P});return this.addTapeNode(this.state.activeScope.name,{x:P},[at],Ct=>({x:()=>ft.runKernel(Y.RFZ,{x:Ct},{dtype:"float32"})}),[],{}),at}runKernel(P,at,nt){if(null==(0,R.pI)(P,this.backendName))throw new Error(`Kernel '${P}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:P,inputs:at,attrs:nt})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(P,at,nt){const Gt=this.backend.numDataIds();let O=0;nt.forEach(vt=>{O+="complex64"===vt.dtype?3:1});const yt=Gt-at-O-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(yt>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${yt} data ids) after running '${P}'`)}runKernelFunc(P){let at,nt=[];const Gt=this.isTapeOn(),O=this.state.numBytes,Ct=this.state.numTensors;let yt,vt;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const xt=et(P)?P.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(et(P)){const{kernelName:ee,inputs:jt,attrs:se}=P,we=(0,R.pI)(ee,this.backendName);A.hu(null!=we,()=>`Cannot find registered kernel '${ee}' for backend '${this.backendName}'`),yt=()=>{const Me=this.backend.numDataIds();vt=we.kernelFunc({inputs:jt,attrs:se,backend:this.backend});const Xe=Array.isArray(vt)?vt:[vt];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(ee,Me,Xe);const Ue=Xe.map(De=>null!=De.rank?De:this.makeTensorFromTensorInfo(De));if(Gt){const De=this.getTensorsForGradient(ee,jt,Ue);nt=this.saveTensorsForBackwardMode(De)}return Ue}}else{const{forwardFunc:ee}=P,jt=se=>{Gt&&(nt=se.map(we=>this.keep(this.clone(we))))};yt=()=>{const se=this.backend.numDataIds();vt=this.tidy(()=>ee(this.backend,jt));const we=Array.isArray(vt)?vt:[vt];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(xt,se,we),we}}const{inputs:Mt,attrs:It}=P,re=et(P)?null:P.backwardsFunc;let Bt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(Bt=this.profiler.profileKernel(xt,Mt,()=>yt()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Bt),at=Bt.outputs):at=yt()}),Gt&&this.addTapeNode(xt,Mt,at,re,nt,It),this.state.profiling&&this.state.activeProfile.kernels.push({name:xt,bytesAdded:this.state.numBytes-O,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-Ct,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Mt).map(ee=>null!=Mt[ee]?Mt[ee].shape:null),outputShapes:at.map(ee=>ee.shape),kernelTimeMs:Bt.timeMs,extraInfo:Bt.extraInfo}),Array.isArray(vt)?at:at[0]}saveTensorsForBackwardMode(P){return P.map(nt=>this.keep(this.clone(nt)))}getTensorsForGradient(P,at,nt){const Gt=(0,R.uk)(P);if(null!=Gt){const O=Gt.inputsToSave||[],Ct=Gt.outputsToSave||[];let yt;Gt.saveAllInputs?(A.hu(Array.isArray(at),()=>"saveAllInputs is true, expected inputs to be an array."),yt=Object.keys(at).map(xt=>at[xt])):yt=O.map(xt=>at[xt]);const vt=nt.filter((xt,Mt)=>Ct[Mt]);return yt.concat(vt)}return[]}makeTensor(P,at,nt,Gt){if(null==P)throw new Error("Values passed to engine.makeTensor() are null");Gt=Gt||this.backend;let O=P;"string"===(nt=nt||"float32")&&A.HD(P[0])&&(O=P.map(vt=>k.encodeString(vt)));const Ct=Gt.write(O,at,nt),yt=new K.es(at,nt,Ct,this.nextTensorId());if(this.trackTensor(yt,Gt),"string"===nt){const vt=this.state.tensorInfo.get(Ct),xt=(0,A.Ub)(O);this.state.numBytes+=xt-vt.bytes,vt.bytes=xt}return yt}makeTensorFromDataId(P,at,nt,Gt){return this.makeTensorFromTensorInfo({dataId:P,shape:at,dtype:nt=nt||"float32"},Gt)}makeTensorFromTensorInfo(P,at){const{dataId:nt,shape:Gt,dtype:O}=P,Ct=new K.es(Gt,O,nt,this.nextTensorId());return this.trackTensor(Ct,at),Ct}makeVariable(P,at=!0,nt,Gt){nt=nt||this.nextVariableId().toString(),null!=Gt&&Gt!==P.dtype&&(P=P.cast(Gt));const O=new K._w(P,at,nt,this.nextTensorId());if(null!=this.state.registeredVariables[O.name])throw new Error(`Variable with name ${O.name} was already registered`);return this.state.registeredVariables[O.name]=O,this.incRef(O,this.backend),O}trackTensor(P,at){this.state.numTensors++,"string"===P.dtype&&this.state.numStringTensors++;let nt=0;"complex64"!==P.dtype&&"string"!==P.dtype&&(nt=P.size*A.bT(P.dtype)),this.state.numBytes+=nt,this.state.tensorInfo.has(P.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(P.dataId,{backend:at||this.backend,dtype:P.dtype,shape:P.shape,bytes:nt})),P instanceof K._w||this.track(P)}incRef(P,at){this.trackTensor(P,at),this.backend.incRef(P.dataId)}removeDataId(P,at){this.state.tensorInfo.has(P)&&this.state.tensorInfo.get(P).backend===at&&(this.state.tensorInfo.delete(P),this.state.numDataBuffers--)}disposeTensor(P){if(!this.state.tensorInfo.has(P.dataId))return;const at=this.state.tensorInfo.get(P.dataId);if(this.state.numTensors--,"string"===P.dtype&&(this.state.numStringTensors--,this.state.numBytes-=at.bytes),"complex64"!==P.dtype&&"string"!==P.dtype){const nt=P.size*A.bT(P.dtype);this.state.numBytes-=nt}at.backend.disposeData(P.dataId)&&this.removeDataId(P.dataId,at.backend)}disposeVariables(){for(const P in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[P])}disposeVariable(P){this.disposeTensor(P),null!=this.state.registeredVariables[P.name]&&delete this.state.registeredVariables[P.name]}memory(){const P=this.backend.memory();return P.numTensors=this.state.numTensors,P.numDataBuffers=this.state.numDataBuffers,P.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(P.unreliable=!0,null==P.reasons&&(P.reasons=[]),P.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),P}profile(P){var at=this;return(0,$.Z)(function*(){at.state.profiling=!0;const nt=at.state.numBytes,Gt=at.state.numTensors;at.state.activeProfile.kernels=[],at.state.activeProfile.result=yield P(),at.state.profiling=!1,at.state.activeProfile.peakBytes=Math.max(...at.state.activeProfile.kernels.map(O=>O.totalBytesSnapshot)),at.state.activeProfile.newBytes=at.state.numBytes-nt,at.state.activeProfile.newTensors=at.state.numTensors-Gt;for(const O of at.state.activeProfile.kernels)O.kernelTimeMs=yield O.kernelTimeMs,O.extraInfo=yield O.extraInfo;return at.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(P,at,nt,Gt,O,Ct){const yt={id:this.state.nextTapeNodeId++,kernelName:P,inputs:at,outputs:nt,saved:O},vt=(0,R.uk)(P);null!=vt&&(Gt=vt.gradFunc),null!=Gt&&(yt.gradient=xt=>(xt=xt.map((Mt,It)=>{if(null==Mt){const re=nt[It],Bt=A.wT(re.size,re.dtype);return this.makeTensor(Bt,re.shape,re.dtype)}return Mt}),Gt(xt.length>1?xt:xt[0],O,Ct))),this.state.activeTape.push(yt)}keep(P){return P.kept=!0,P}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(P){const at={track:[],name:"unnamed scope",id:this.state.nextScopeId++};P&&(at.name=P),this.state.scopeStack.push(at),this.state.activeScope=at}endScope(P){const at=(0,st.getTensorsInContainer)(P),nt=new Set(at.map(O=>O.id));for(let O=0;O<this.state.activeScope.track.length;O++){const Ct=this.state.activeScope.track[O];!Ct.kept&&!nt.has(Ct.id)&&Ct.dispose()}const Gt=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],at.forEach(O=>{!O.kept&&O.scopeId===Gt.id&&this.track(O)})}gradients(P,at,nt,Gt=!1){if(A.hu(at.length>0,()=>"gradients() received an empty list of xs."),null!=nt&&"float32"!==nt.dtype)throw new Error(`dy must have 'float32' dtype, but has '${nt.dtype}'`);const O=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",P));A.hu(O instanceof K.es,()=>"The result y returned by f() must be a tensor.");const Ct=function it(B,ot,P){const at={},nt={};for(let yt=0;yt<ot.length;yt++)at[ot[yt].id]=!0;for(let yt=0;yt<B.length;yt++){const vt=B[yt],xt=vt.inputs;for(const Mt in xt){const It=xt[Mt];let re=!1;for(let Bt=0;Bt<ot.length;Bt++)if(at[It.id]){vt.outputs.forEach(ee=>at[ee.id]=!0),re=!0,nt[vt.id]=!0;break}if(re)break}}const Gt={};Gt[P.id]=!0;const O={};for(let yt=B.length-1;yt>=0;yt--){const vt=B[yt],xt=vt.inputs;for(let Mt=0;Mt<vt.outputs.length;Mt++)if(Gt[vt.outputs[Mt].id]){for(const It in xt)Gt[xt[It].id]=!0,O[vt.id]=!0;break}}const Ct=[];for(let yt=0;yt<B.length;yt++){const vt=B[yt];if(nt[vt.id]&&O[vt.id]){const xt={};for(const It in vt.inputs){const re=vt.inputs[It];at[re.id]&&(xt[It]=re)}const Mt=Object.assign({},vt);Mt.inputs=xt,Mt.outputs=vt.outputs,Ct.push(Mt)}}return Ct}(this.state.activeTape,at,O);if(!Gt&&0===Ct.length&&at.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const yt={};yt[O.id]=nt??function St(B){const ot=(0,A.p8)((0,A.NA)(B),"float32");return ft.makeTensor(ot,B,"float32")}(O.shape),function wt(B,ot,P,at){for(let nt=ot.length-1;nt>=0;nt--){const Gt=ot[nt],O=[];if(Gt.outputs.forEach(yt=>{const vt=B[yt.id];O.push(null!=vt?vt:null)}),null==Gt.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${Gt.kernelName}.`);const Ct=Gt.gradient(O);for(const yt in Gt.inputs){if(!(yt in Ct))throw new Error(`Cannot backprop through input ${yt}. Available gradients found: ${Object.keys(Ct)}.`);const vt=P(()=>Ct[yt]());if("float32"!==vt.dtype)throw new Error(`Error in gradient for op ${Gt.kernelName}. The gradient of input ${yt} must have 'float32' dtype, but has '${vt.dtype}'`);const xt=Gt.inputs[yt];if(!A.cO(vt.shape,xt.shape))throw new Error(`Error in gradient for op ${Gt.kernelName}. The gradient of input '${yt}' has shape '${vt.shape}', which does not match the shape of the input '${xt.shape}'`);if(null==B[xt.id])B[xt.id]=vt;else{const Mt=B[xt.id];B[xt.id]=at(Mt,vt),Mt.dispose()}}}}(yt,Ct,xt=>this.tidy(xt),pt);const vt=at.map(xt=>yt[xt.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(xt=>{for(const Mt of xt.saved)Mt.dispose()}),this.state.activeTape=null),{value:O,grads:vt}})}customGrad(P){return A.hu(A.mf(P),()=>"The f passed in customGrad(f) must be a function."),(...at)=>{let nt;A.hu(at.every(yt=>yt instanceof K.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const Gt={};return at.forEach((yt,vt)=>{Gt[vt]=yt}),this.runKernelFunc({forwardFunc:(yt,vt)=>(nt=P(...at,vt),A.hu(nt.value instanceof K.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A.hu(A.mf(nt.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),nt.value),backwardsFunc:(yt,vt)=>{const xt=nt.gradFunc(yt,vt),Mt=Array.isArray(xt)?xt:[xt];A.hu(Mt.length===at.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A.hu(Mt.every(re=>re instanceof K.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const It={};return Mt.forEach((re,Bt)=>{It[Bt]=()=>re}),It},inputs:Gt})}}readSync(P){return this.state.tensorInfo.get(P).backend.readSync(P)}read(P){return this.state.tensorInfo.get(P).backend.read(P)}readToGPU(P,at){return this.state.tensorInfo.get(P).backend.readToGPU(P,at)}time(P){var at=this;return(0,$.Z)(function*(){const nt=(0,k.now)(),Gt=yield at.backend.time(P);return Gt.wallMs=(0,k.now)()-nt,Gt})()}track(P){return null!=this.state.activeScope&&(P.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(P)),P}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new dt;for(const P in this.registry)this.disposeRegisteredKernels(P),this.registry[P].dispose(),delete this.registry[P];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return B.nextTensorId=0,B.nextVariableId=0,B})();function q(){const B=(0,Q.D)();if(null==B._tfengine){const ot=new H.qA(B);B._tfengine=new lt(ot)}return(0,H.iG)(B._tfengine.ENV),(0,K.Vi)(()=>B._tfengine),B._tfengine}const ft=q();function pt(B,ot){return ft.runKernel(Y.mm_,{a:B,b:ot})}},5527:(Lt,ut,y)=>{"use strict";y.d(ut,{OB:()=>k,Vi:()=>A,iG:()=>X,qA:()=>Q});var $=y(5861),V=y(5359);const H="tfjsflags";class Q{constructor(G){this.global=G,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Y,this.populateURLFlags()}setPlatform(G,it){null!=this.platform&&(k().getBool("IS_TEST")||k().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${G}.`)),this.platformName=G,this.platform=it}registerFlag(G,it,wt){if(this.flagRegistry[G]={evaluationFn:it,setHook:wt},null!=this.urlFlags[G]){const K=this.urlFlags[G];k().getBool("IS_TEST")||k().getBool("PROD")||console.warn(`Setting feature override from URL ${G}: ${K}.`),this.set(G,K)}}getAsync(G){var it=this;return(0,$.Z)(function*(){return G in it.flags||(it.flags[G]=yield it.evaluateFlag(G)),it.flags[G]})()}get(G){if(G in this.flags)return this.flags[G];const it=this.evaluateFlag(G);if((0,V.tI)(it))throw new Error(`Flag ${G} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[G]=it,this.flags[G]}getNumber(G){return this.get(G)}getBool(G){return this.get(G)}getString(G){return this.get(G)}getFlags(){return this.flags}get features(){return this.flags}set(G,it){if(null==this.flagRegistry[G])throw new Error(`Cannot set flag ${G} as it has not been registered.`);this.flags[G]=it,null!=this.flagRegistry[G].setHook&&this.flagRegistry[G].setHook(it)}evaluateFlag(G){if(null==this.flagRegistry[G])throw new Error(`Cannot evaluate flag '${G}': no evaluation function found.`);return this.flagRegistry[G].evaluationFn()}setFlags(G){this.flags=Object.assign({},G)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const G=this.getQueryParams(this.global.location.search);H in G&&G[H].split(",").forEach(wt=>{const[K,st]=wt.split(":");this.urlFlags[K]=function W(Z,G){const it=G.toLowerCase();return"true"===it||"false"===it?"true"===it:""+ +it===it?+it:G}(0,st)})}}function Y(Z){const G={};return Z.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(it,...wt)=>(function R(Z,G,it){Z[decodeURIComponent(G)]=decodeURIComponent(it||"")}(G,wt[0],wt[1]),wt.join("="))),G}function k(){return A}let A=null;function X(Z){A=Z}},2918:(Lt,ut,y)=>{"use strict";let $;function V(){if(null==$){let Y;if(typeof window<"u")Y=window;else if(typeof global<"u")Y=global;else if(typeof process<"u")Y=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");Y=self}$=Y}return $}function Q(Y,R){const W=function H(){const Y=V();return null==Y._tfGlobals&&(Y._tfGlobals=new Map),Y._tfGlobals}();if(W.has(Y))return W.get(Y);{const k=R();return W.set(Y,k),W.get(Y)}}y.d(ut,{D:()=>V,R:()=>Q})},2773:(Lt,ut,y)=>{"use strict";y.d(ut,{B9:()=>wt,CQ:()=>et,Cd:()=>dt,Cn:()=>K,G4:()=>Y,MX:()=>k,N5:()=>G,N8:()=>A,N_:()=>lt,R:()=>R,SR:()=>X,VY:()=>ot,XV:()=>st,cF:()=>W,cj:()=>St,jq:()=>pt,lu:()=>it,sq:()=>Z,x3:()=>q,y3:()=>B,ze:()=>ft});var $=y(687),V=y(5527),H=y(4945),Q=y(7664);function Y(){(0,V.OB)().set("PROD",!0)}function R(){(0,V.OB)().set("DEBUG",!0)}function W(){(0,V.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function k(P){(0,V.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(P+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function A(){$.BV.disposeVariables()}function X(){return $.BV}function Z(){return $.BV.memory()}function G(P){return $.BV.profile(P)}function it(P,at){return $.BV.tidy(P,at)}function wt(P){(0,Q.getTensorsInContainer)(P).forEach(nt=>nt.dispose())}function K(P){return $.BV.keep(P)}function st(P){return $.BV.time(P)}function et(P){return $.BV.setBackend(P)}function dt(){return $.BV.ready()}function lt(){return $.BV.backendName}function St(P){$.BV.removeBackend(P)}function q(P){return $.BV.findBackend(P)}function ft(P){return $.BV.findBackendFactory(P)}function pt(P,at,nt=1){return $.BV.registerBackend(P,at,nt)}function B(){return $.BV.backend}function ot(P,at){(0,V.OB)().setPlatform(P,at)}(0,H.FZ)(k)},3537:(Lt,ut,y)=>{"use strict";y.d(ut,{UQ:()=>Y,cb:()=>X,fN:()=>k,h7:()=>W,pn:()=>A,ti:()=>R});var $=y(687),V=y(4945),H=y(1257),Q=y(5359);function Y(G){return Q.hu(Q.mf(G),()=>"The f passed in grad(f) must be a function"),(it,wt)=>{const K=(0,H._1)(it,"x","tf.grad","string_or_numeric"),st=null!=wt?(0,H._1)(wt,"dy","tf.grad"):null;return $.BV.tidy(()=>{const{value:et,grads:dt}=$.BV.gradients(()=>G(K),[K],st);return null!=st&&Q.k5(et.shape,st.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Z(dt),dt[0]})}}function R(G){return Q.hu(Q.mf(G),()=>"The f passed in grads(f) must be a function"),(it,wt)=>{Q.hu(Array.isArray(it),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const K=(0,H.sI)(it,"args","tf.grads","string_or_numeric"),st=null!=wt?(0,H._1)(wt,"dy","tf.grads"):null;return $.BV.tidy(()=>{const{value:et,grads:dt}=$.BV.gradients(()=>G(...K),K,st);return null!=st&&Q.k5(et.shape,st.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Z(dt),dt})}}function W(G){return Q.hu(Q.mf(G),()=>"The f passed in valueAndGrad(f) must be a function"),(it,wt)=>{Q.hu(it instanceof V.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),Q.hu(null==wt||wt instanceof V.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:K,value:st}=$.BV.gradients(()=>G(it),[it],wt);return Z(K),{grad:K[0],value:st}}}function k(G){return Q.hu(Q.mf(G),()=>"The f passed in valueAndGrads(f) must be a function"),(it,wt)=>{Q.hu(Array.isArray(it)&&it.every(st=>st instanceof V.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),Q.hu(null==wt||wt instanceof V.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const K=$.BV.gradients(()=>G(...it),it,wt);return null!=wt&&Q.k5(K.value.shape,wt.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Z(K.grads),K}}function A(G,it){Q.hu(Q.mf(G),()=>"The f passed in variableGrads(f) must be a function"),Q.hu(null==it||Array.isArray(it)&&it.every(q=>q instanceof V._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const wt=null!=it;if(!wt){it=[];for(const q in $.BV.registeredVariables)it.push($.BV.registeredVariables[q])}const K=wt?it.filter(q=>!q.trainable):null,st=it.length;it=it.filter(q=>q.trainable),Q.hu(it.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${st} variables is trainable.`);const{value:dt,grads:lt}=$.BV.gradients(G,it,null,!0);Q.hu(lt.some(q=>null!=q),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Q.hu(0===dt.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${dt.rank} tensor`);const St={};return it.forEach((q,ft)=>{null!=lt[ft]&&(St[q.name]=lt[ft])}),K?.forEach(q=>St[q.name]=null),{value:dt,grads:St}}function X(G){return $.BV.customGrad(G)}function Z(G){if(G.filter(wt=>null==wt).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},6300:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{Abs:()=>_e.SYM,Acos:()=>_e.VGw,Acosh:()=>_e.SpW,AdadeltaOptimizer:()=>Ks,AdagradOptimizer:()=>ti,AdamOptimizer:()=>Ls,AdamaxOptimizer:()=>Pa,Add:()=>_e.mm_,AddN:()=>_e.Xze,All:()=>_e.oT6,Any:()=>_e.IKK,ArgMax:()=>_e.sJF,ArgMin:()=>_e.aJk,Asin:()=>_e.M2y,Asinh:()=>_e.qw7,Atan:()=>_e.jMg,Atan2:()=>_e.QCc,Atanh:()=>_e.Oyi,AvgPool:()=>_e.JhU,AvgPool3D:()=>_e._k9,AvgPool3DGrad:()=>_e.IMb,AvgPoolGrad:()=>_e.ROF,BatchMatMul:()=>_e.XLW,BatchToSpaceND:()=>_e.zws,Bincount:()=>_e.zvY,BitwiseAnd:()=>_e.hCO,BroadcastArgs:()=>_e.eEB,BroadcastTo:()=>_e.Ly9,Cast:()=>_e.RFZ,Ceil:()=>_e.gJX,ClipByValue:()=>_e.xnO,Complex:()=>_e.Zz9,ComplexAbs:()=>_e.yj2,Concat:()=>_e.Eh3,Conv2D:()=>_e.mhS,Conv2DBackpropFilter:()=>_e.wUP,Conv2DBackpropInput:()=>_e.wm,Conv3D:()=>_e.x12,Conv3DBackpropFilterV2:()=>_e.o2y,Conv3DBackpropInputV2:()=>_e.ik2,Cos:()=>_e.mc4,Cosh:()=>_e.TR1,CropAndResize:()=>_e.VcC,Cumprod:()=>_e.Byc,Cumsum:()=>_e.iHb,DataStorage:()=>ds.JL,DenseBincount:()=>_e.QRR,DepthToSpace:()=>_e.T0n,DepthwiseConv2dNative:()=>_e.cie,DepthwiseConv2dNativeBackpropFilter:()=>_e.sL$,DepthwiseConv2dNativeBackpropInput:()=>_e.y7R,Diag:()=>_e.$w,Dilation2D:()=>_e.p4S,Dilation2DBackpropFilter:()=>_e.Vn9,Dilation2DBackpropInput:()=>_e.ekb,Draw:()=>_e.hGc,ENV:()=>et.Vi,Einsum:()=>_e.$g6,Elu:()=>_e.SX0,EluGrad:()=>_e.HEU,Environment:()=>et.qA,Equal:()=>_e.hdR,Erf:()=>_e.Omj,Exp:()=>_e.NEP,ExpandDims:()=>_e.YFo,Expm1:()=>_e.Y0y,FFT:()=>_e.vwp,Fill:()=>_e.deh,FlipLeftRight:()=>_e.Uyb,Floor:()=>_e.OR,FloorDiv:()=>_e.jeX,FromPixels:()=>_e.eBW,FusedBatchNorm:()=>_e.sHE,FusedConv2D:()=>_e._V0,FusedDepthwiseConv2D:()=>_e.luS,GatherNd:()=>_e.q1x,GatherV2:()=>_e.qi_,Greater:()=>_e.iZT,GreaterEqual:()=>_e.Acj,IFFT:()=>_e.Qg5,Identity:()=>_e.iJz,Imag:()=>_e.J_u,IsFinite:()=>_e.avt,IsInf:()=>_e.iWB,IsNan:()=>_e.r7n,KernelBackend:()=>ds.Zu,LRN:()=>_e.eZ0,LRNGrad:()=>_e.Hhh,LeakyRelu:()=>_e.J$2,Less:()=>_e.vtC,LessEqual:()=>_e.CAk,LinSpace:()=>_e.e7N,Log:()=>_e.ZbH,Log1p:()=>_e.kU,LogSoftmax:()=>_e.qCd,LogicalAnd:()=>_e.PYm,LogicalNot:()=>_e.VfG,LogicalOr:()=>_e.MZg,LogicalXor:()=>_e.w6g,LowerBound:()=>_e.qIC,MatrixBandPart:()=>_e.J7O,Max:()=>_e.YoZ,MaxPool:()=>_e.mTV,MaxPool3D:()=>_e.OAf,MaxPool3DGrad:()=>_e.OU7,MaxPoolGrad:()=>_e.OV7,MaxPoolWithArgmax:()=>_e.vFR,Maximum:()=>_e.BMI,Mean:()=>_e.q2K,Min:()=>_e.c17,Minimum:()=>_e.q8u,MirrorPad:()=>_e.jQs,Mod:()=>_e.Vbg,MomentumOptimizer:()=>Co,Multinomial:()=>_e.NZg,Multiply:()=>_e.wYn,Neg:()=>_e.kuV,NonMaxSuppressionV3:()=>_e.uv1,NonMaxSuppressionV4:()=>_e.cye,NonMaxSuppressionV5:()=>_e.W0H,NotEqual:()=>_e.yQU,OP_SCOPE_SUFFIX:()=>he.zvA,OneHot:()=>_e.we_,OnesLike:()=>_e.qWM,Optimizer:()=>Es,OptimizerConstructors:()=>Hr,Pack:()=>_e.QiL,PadV2:()=>_e.lyA,Pool:()=>_e.Kgp,Pow:()=>_e.pe_,Prelu:()=>_e.o0g,Prod:()=>_e.DlI,RMSPropOptimizer:()=>gs,RaggedGather:()=>_e.dDz,RaggedRange:()=>_e.CQl,RaggedTensorToTensor:()=>_e.BiW,Range:()=>_e.e6w,Rank:()=>Qu.yw,Real:()=>_e.xJR,RealDiv:()=>_e.oHH,Reciprocal:()=>_e.$HU,Reduction:()=>Bo.I,Relu:()=>_e.qkr,Relu6:()=>_e.SbG,Reshape:()=>_e.HZH,ResizeBilinear:()=>_e._Yw,ResizeBilinearGrad:()=>_e.zbQ,ResizeNearestNeighbor:()=>_e.dpD,ResizeNearestNeighborGrad:()=>_e.Hmb,Reverse:()=>_e.mKl,RotateWithOffset:()=>_e.b9H,Round:()=>_e.e07,Rsqrt:()=>_e.bV0,SGDOptimizer:()=>eo,ScatterNd:()=>_e.xQA,SearchSorted:()=>_e.nr8,Select:()=>_e.PhF,Selu:()=>_e.oFR,Sigmoid:()=>_e.a5O,Sign:()=>_e.i5y,Sin:()=>_e.RQH,Sinh:()=>_e.wYB,Slice:()=>_e.p2w,Softmax:()=>_e.Gcp,Softplus:()=>_e.MRv,SpaceToBatchND:()=>_e.TQc,SparseFillEmptyRows:()=>_e.O3z,SparseReshape:()=>_e.nhH,SparseSegmentMean:()=>_e.w3H,SparseSegmentSum:()=>_e.ZjV,SparseToDense:()=>_e.D2d,SplitV:()=>_e.L8s,Sqrt:()=>_e.FKq,Square:()=>_e.bK0,SquaredDifference:()=>_e._tC,StaticRegexReplace:()=>_e.e0R,Step:()=>_e.h8e,StridedSlice:()=>_e.jQk,StringNGrams:()=>_e._JP,StringSplit:()=>_e.s1s,StringToHashBucketFast:()=>_e.XkS,Sub:()=>_e.Tr8,Sum:()=>_e.GBy,Tan:()=>_e.sEM,Tanh:()=>_e.MIZ,Tensor:()=>dr.es,TensorBuffer:()=>dr.YD,TensorScatterUpdate:()=>_e.SIB,Tile:()=>_e.n9L,TopK:()=>_e.cWu,Transform:()=>_e.wx7,Transpose:()=>_e.G3Y,Unique:()=>_e.kpP,Unpack:()=>_e.ToN,UnsortedSegmentSum:()=>_e.Qvg,UpperBound:()=>_e.XDQ,Variable:()=>dr._w,ZerosLike:()=>_e.RuY,_FusedMatMul:()=>_e.usg,abs:()=>he.WnP,acos:()=>he.Khb,acosh:()=>he.__u,add:()=>he.IHx,addN:()=>he.QBD,all:()=>he.$6P,any:()=>he.YjB,argMax:()=>he.NqF,argMin:()=>he.vHJ,asin:()=>he.ZRM,asinh:()=>he.VfV,atan:()=>he.z4N,atan2:()=>he.fvJ,atanh:()=>he.C80,avgPool:()=>he.wS1,avgPool3d:()=>he.uR5,backend:()=>_n.y3,backend_util:()=>A,basicLSTMCell:()=>he.zEQ,batchNorm:()=>he.tgs,batchNorm2d:()=>he.Dxk,batchNorm3d:()=>he.JY5,batchNorm4d:()=>he.p3b,batchToSpaceND:()=>he.E4h,bincount:()=>he.yE8,bitwiseAnd:()=>he.ycw,booleanMaskAsync:()=>he.anm,broadcastArgs:()=>he.XsQ,broadcastTo:()=>he.UFq,broadcast_util:()=>os,browser:()=>Y,buffer:()=>he.f3b,cast:()=>he.pju,ceil:()=>he.mDi,clipByValue:()=>he.iUl,clone:()=>he.d9v,complex:()=>he.PYB,concat:()=>he.zoF,concat1d:()=>he.gME,concat2d:()=>he.Izb,concat3d:()=>he.MNy,concat4d:()=>he.ZaL,conv1d:()=>he.PAt,conv2d:()=>he.Tek,conv2dTranspose:()=>he.bc,conv3d:()=>he.pdZ,conv3dTranspose:()=>he.$QV,copyRegisteredKernels:()=>z.T3,cos:()=>he.mCk,cosh:()=>he.f9Y,cosineWindow:()=>he.mew,cumprod:()=>he.$Gn,cumsum:()=>he.zbp,customGrad:()=>kr.cb,denseBincount:()=>he.ppE,deprecationWarn:()=>_n.MX,depthToSpace:()=>he.nTT,depthwiseConv2d:()=>he.B10,device_util:()=>$,diag:()=>he.Ka3,dilation2d:()=>he.WmZ,disableDeprecationWarnings:()=>_n.cF,dispose:()=>_n.B9,disposeVariables:()=>_n.N8,div:()=>he.hiC,divNoNan:()=>he.NTj,dot:()=>he.AKD,dropout:()=>he.rvX,einsum:()=>he.WYO,elu:()=>he.pyx,enableDebugMode:()=>_n.R,enableProdMode:()=>_n.G4,enclosingPowerOfTwo:()=>he.GRh,engine:()=>_n.SR,ensureShape:()=>he.EDe,env:()=>et.OB,equal:()=>he.DgJ,erf:()=>he.qNN,euclideanNorm:()=>he.d2q,exp:()=>he.Qqt,expandDims:()=>he.dt4,expm1:()=>he.t$B,eye:()=>he.iyy,fft:()=>he.kp_,fill:()=>he.hlL,findBackend:()=>_n.x3,findBackendFactory:()=>_n.ze,floor:()=>he.GWj,floorDiv:()=>he.qPi,fused:()=>he.imm,gather:()=>he.Iqj,gatherND:()=>he.dbB,gather_util:()=>R,getBackend:()=>_n.N_,getGradient:()=>z.uk,getKernel:()=>z.pI,getKernelsForBackend:()=>z.tr,grad:()=>kr.UQ,grads:()=>kr.ti,greater:()=>he.pjt,greaterEqual:()=>he.brS,ifft:()=>he.Sxn,imag:()=>he.asL,image:()=>he.BHj,inTopKAsync:()=>he.V3u,io:()=>H,irfft:()=>he.wx0,isFinite:()=>he.xVT,isInf:()=>he.UWc,isNaN:()=>he.i2d,keep:()=>_n.Cn,kernel_impls:()=>X,leakyRelu:()=>he.hi7,less:()=>he.d9m,lessEqual:()=>he.zN1,linalg:()=>he.$r2,linspace:()=>he.SX3,localResponseNormalization:()=>he.G9k,log:()=>he.cM7,log1p:()=>he.Krr,logSigmoid:()=>he.e_t,logSoftmax:()=>he.CmS,logSumExp:()=>he.l_t,logicalAnd:()=>he.HvI,logicalNot:()=>he.hJK,logicalOr:()=>he.K5V,logicalXor:()=>he.egP,losses:()=>he.MB5,lowerBound:()=>he.eab,matMul:()=>he.OI3,math:()=>Q,max:()=>he.Fp7,maxPool:()=>he._sB,maxPool3d:()=>he.YQQ,maxPoolWithArgmax:()=>he.Ip$,maximum:()=>he.gWQ,mean:()=>he.J69,memory:()=>_n.sq,meshgrid:()=>he.ry_,min:()=>he.VV$,minimum:()=>he.LTh,mirrorPad:()=>he.VdP,mod:()=>he.wQq,moments:()=>he.Gi7,movingAverage:()=>he.p_,mul:()=>he.dC7,multiRNNCell:()=>he.rq4,multinomial:()=>he.SJ_,neg:()=>he.W76,nextFrame:()=>Br,norm:()=>he.KOy,notEqual:()=>he.Quu,oneHot:()=>he.lfX,ones:()=>he.iUs,onesLike:()=>he.JpU,op:()=>he.op,outerProduct:()=>he.N2O,pad:()=>he.vku,pad1d:()=>he.pNR,pad2d:()=>he.koy,pad3d:()=>he.t1L,pad4d:()=>he.lGY,pool:()=>he.d_R,pow:()=>he.sQ3,prelu:()=>he.AL3,print:()=>he.S0v,prod:()=>he.WVs,profile:()=>_n.N5,raggedGather:()=>he.$gW,raggedRange:()=>he.VT$,raggedTensorToTensor:()=>he.N89,rand:()=>he.TN_,randomGamma:()=>he.wzB,randomNormal:()=>he.nGf,randomStandardNormal:()=>he.ruB,randomUniform:()=>he.LGj,randomUniformInt:()=>he.pe5,range:()=>he.w6H,ready:()=>_n.Cd,real:()=>he.kwC,reciprocal:()=>he.M25,registerBackend:()=>_n.jq,registerGradient:()=>z.Li,registerKernel:()=>z.wC,relu:()=>he.UYe,relu6:()=>he.btT,removeBackend:()=>_n.cj,reshape:()=>he.XLQ,reverse:()=>he.GYS,reverse1d:()=>he.SDf,reverse2d:()=>he.diP,reverse3d:()=>he.sx7,reverse4d:()=>he.mG2,rfft:()=>he.QEs,round:()=>he.NMM,rsqrt:()=>he.bp0,scalar:()=>he.iD$,scatterND:()=>he.snQ,scatter_util:()=>ni,searchSorted:()=>he.zcT,selu:()=>he.U8D,separableConv2d:()=>he.U_I,serialization:()=>V,setBackend:()=>_n.CQ,setPlatform:()=>_n.VY,setdiff1dAsync:()=>he.ODp,sigmoid:()=>he.XD2,sign:()=>he.Xxe,signal:()=>he.tdS,sin:()=>he.O$l,sinh:()=>he.R_K,slice:()=>he.tPi,slice1d:()=>he.jZU,slice2d:()=>he.SmN,slice3d:()=>he.CnO,slice4d:()=>he.p0P,slice_util:()=>Zs,softmax:()=>he.XAC,softplus:()=>he.Wvh,spaceToBatchND:()=>he.fBT,sparse:()=>he.rVs,sparseToDense:()=>he.ers,spectral:()=>he.uN7,split:()=>he.Vl2,sqrt:()=>he._b3,square:()=>he.h62,squaredDifference:()=>he.$i,squeeze:()=>he.L9e,stack:()=>he.knu,step:()=>he.Nbs,stridedSlice:()=>he.NXj,string:()=>he.Z_8,sub:()=>he.luU,sum:()=>he.Smz,sumOutType:()=>Qu.z4,tan:()=>he.ORZ,tanh:()=>he.AEp,tensor:()=>he.XeE,tensor1d:()=>he.RRF,tensor2d:()=>he.odF,tensor3d:()=>he.wOQ,tensor4d:()=>he.yXz,tensor5d:()=>he.Bfx,tensor6d:()=>he.xZs,tensorScatterUpdate:()=>he.Pg0,tensor_util:()=>Xr,test_util:()=>W,tidy:()=>_n.lu,tile:()=>he.Gg6,time:()=>_n.XV,topk:()=>he.hg7,train:()=>Hl,transpose:()=>he.p4s,truncatedNormal:()=>he.Xu6,unique:()=>he.Two,unregisterGradient:()=>z.bt,unregisterKernel:()=>z.nE,unsortedSegmentSum:()=>he.pUJ,unstack:()=>he.HHK,upcastType:()=>Qu.x8,upperBound:()=>he.GaM,util:()=>tn,valueAndGrad:()=>kr.h7,valueAndGrads:()=>kr.fN,variable:()=>he.VD$,variableGrads:()=>kr.pn,version_core:()=>pu,where:()=>he.arb,whereAsync:()=>he.itS,zeros:()=>he.lls,zerosLike:()=>he.P84});var $={};y.r($),y.d($,{isBrowser:()=>st,isMobile:()=>K,mockIsMobile:()=>wt});var V={};y.r(V),y.d(V,{Serializable:()=>oi,SerializationMap:()=>zr,getRegisteredName:()=>ho,registerClass:()=>js});var H={};y.r(H),y.d(H,{CompositeArrayBuffer:()=>P.w,browserFiles:()=>Gr,browserHTTPRequest:()=>ks,concatenateArrayBuffers:()=>St.JY,copyModel:()=>Ce,decodeWeights:()=>St.dI,decodeWeightsStream:()=>St.r,encodeWeights:()=>St.yz,fromMemory:()=>mr,fromMemorySync:()=>ai,getLoadHandlers:()=>ot,getModelArtifactsForJSON:()=>St.jN,getModelArtifactsForJSONSync:()=>St.ji,getModelArtifactsInfoForJSON:()=>St.Q,getSaveHandlers:()=>B,getWeightSpecs:()=>St.hu,http:()=>wo,isHTTPScheme:()=>Fn,listModels:()=>Qo,loadWeights:()=>ga,moveModel:()=>Rt,registerLoadRouter:()=>pt,registerSaveRouter:()=>ft,removeModel:()=>Gn,weightsLoaderFactory:()=>Cs,withSaveHandler:()=>Kn,withSaveHandlerSync:()=>Pr});var Q={};y.r(Q),y.d(Q,{confusionMatrix:()=>Or});var Y={};y.r(Y),y.d(Y,{draw:()=>vr,fromPixels:()=>bn,fromPixelsAsync:()=>nn,toPixels:()=>$n});var R={};y.r(R),y.d(R,{prepareAndValidate:()=>_r});var W={};y.r(W),y.d(W,{TEST_EPSILON_FLOAT16:()=>xr,createVideoElement:()=>$o,encodeStrings:()=>fu,expectArrayBuffersEqual:()=>In,expectArraysClose:()=>Qi,expectArraysEqual:()=>Oc,expectNumbersClose:()=>as,expectPromiseToFail:()=>Lu,expectValuesInRange:()=>eu,play:()=>Gl,testEpsilon:()=>fo});var k={};y.r(k),y.d(k,{collectGatherOpShapeInfo:()=>yu,computeOutShape:()=>ha,segOpComputeOptimalWindowSize:()=>Yr});var A={};y.r(A),y.d(A,{ERF_A1:()=>Vo,ERF_A2:()=>xa,ERF_A3:()=>mi,ERF_A4:()=>yi,ERF_A5:()=>La,ERF_P:()=>$s,PARALLELIZE_THRESHOLD:()=>Hn,RowPartitionType:()=>ya,SELU_SCALE:()=>Ys.$,SELU_SCALEALPHA:()=>Ys.y,applyActivation:()=>Fs.QH,assertAndGetBroadcastShape:()=>os.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>es.lB,assertParamsConsistent:()=>nu,assignToTypedArray:()=>Du,axesAreInnerMostDims:()=>es.YB,calculateShapes:()=>ni.calculateShapes,checkEinsumDimSizes:()=>ta,checkPadOnDimRoundingMode:()=>us.m,combineLocations:()=>es.Vh,combineRaggedTensorToTensorShapes:()=>zo,complexWithEvenIndex:()=>Jo,complexWithOddIndex:()=>Uo,computeConv2DInfo:()=>us.Ix,computeConv3DInfo:()=>us.jw,computeDefaultPad:()=>us.aO,computeDilation2DInfo:()=>us.Rf,computeOptimalWindowSize:()=>Ao,computeOutAndReduceShapes:()=>es.kz,computeOutShape:()=>ru,computePool2DInfo:()=>us.Xw,computePool3DInfo:()=>us.pl,convertConv2DDataFormat:()=>us.sl,decodeEinsumEquation:()=>Ca,eitherStridesOrDilationsAreOne:()=>us.jT,expandShapeToKeepDim:()=>es.rv,exponent:()=>Wo,exponents:()=>Bs,fromStringArrayToUint8:()=>bs,fromUint8ToStringArray:()=>or,getAxesPermutation:()=>es.Q3,getBroadcastDims:()=>os.getBroadcastDims,getComplexWithIndex:()=>Ts,getEinsumComputePath:()=>go,getEinsumPermutation:()=>Qs,getFusedBiasGradient:()=>Fs.pf,getFusedDyActivation:()=>Fs.Fr,getImageCenter:()=>Mn,getInnerMostAxes:()=>es.sY,getPermuted:()=>_a,getRaggedRank:()=>po,getReductionAxes:()=>os.getReductionAxes,getReshaped:()=>ua,getReshapedPermuted:()=>ls,getRowPartitionTypesHelper:()=>va,getSliceBeginCoords:()=>mo,getSliceSize:()=>iu,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>cs,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>So,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>la,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Nu,getSparseReshapeInputOutputMismatchErrorMessage:()=>hs,getSparseReshapeInputOutputMultipleErrorMessage:()=>Go,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>ns,getSparseReshapeNegativeOutputDimErrorMessage:()=>wl,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>ja,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>ca,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>no,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>jl,getUndoAxesPermutation:()=>es.LJ,isIdentityPermutation:()=>ka,log:()=>Su.c,mergeRealAndImagArrays:()=>Ga,prepareAndValidate:()=>_r,prepareSplitSize:()=>Io,segment_util:()=>k,shouldFuse:()=>Fs.uy,slice_util:()=>Zs,splitRealAndImagArrays:()=>pl,stridesOrDilationsArePositive:()=>us.U3,tupleValuesAreOne:()=>us.I0,upcastType:()=>Qu.x8,validateDefaultValueShape:()=>qo,validateInput:()=>ni.validateInput,validateUpdateShape:()=>ni.validateUpdateShape,warn:()=>Su.Z});var X={};y.r(X),y.d(X,{nonMaxSuppressionV3Impl:()=>Tr.GP,nonMaxSuppressionV4Impl:()=>Tr.qP,nonMaxSuppressionV5Impl:()=>Tr.pA,whereImpl:()=>ri.Z});var Z=y(687);let it;function wt(gt){it=gt}function K(gt){if(void 0!==it)return it;if(gt||function G(){return typeof navigator<"u"&&null!=navigator}()){if(gt||(gt=navigator),"ReactNative"===gt.product)return!0;const ct=gt.userAgent||gt.vendor||(typeof window<"u"?window.opera:"");return ct?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(ct)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(ct.substr(0,4)):gt.userAgentData&&gt.userAgentData.mobile}return!1}function st(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}var et=y(5527);const dt=(0,et.OB)();dt.registerFlag("DEBUG",()=>!1,gt=>{gt&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),dt.registerFlag("IS_BROWSER",()=>st()),dt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),dt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),dt.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),dt.registerFlag("PROD",()=>!1),dt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>dt.getBool("DEBUG")),dt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),dt.registerFlag("IS_TEST",()=>!1),dt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>dt.getBool("DEBUG")),dt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),dt.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),dt.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var lt=y(5861),St=y(8339);class q{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==q.instance&&(q.instance=new q),q.instance}static registerSaveRouter(ct){q.getInstance().saveRouters.push(ct)}static registerLoadRouter(ct){q.getInstance().loadRouters.push(ct)}static getSaveHandlers(ct){return q.getHandlers(ct,"save")}static getLoadHandlers(ct,_t){return q.getHandlers(ct,"load",_t)}static getHandlers(ct,_t,Nt){const Kt=[];return("load"===_t?q.getInstance().loadRouters:q.getInstance().saveRouters).forEach(Ee=>{const Te=Ee(ct,Nt);null!==Te&&Kt.push(Te)}),Kt}}const ft=gt=>q.registerSaveRouter(gt),pt=gt=>q.registerLoadRouter(gt),B=gt=>q.getSaveHandlers(gt),ot=(gt,ct)=>q.getLoadHandlers(gt,ct);var P=y(7864);const at="tensorflowjs",Gt="models_store",O="model_info_store";function vt(){if(!(0,et.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const gt=typeof window>"u"?self:window,ct=gt.indexedDB||gt.mozIndexedDB||gt.webkitIndexedDB||gt.msIndexedDB||gt.shimIndexedDB;if(null==ct)throw new Error("The current browser does not appear to support IndexedDB.");return ct}function xt(gt){const ct=gt.result;ct.createObjectStore(Gt,{keyPath:"modelPath"}),ct.createObjectStore(O,{keyPath:"modelPath"})}let Mt=(()=>{class gt{constructor(_t){if(this.indexedDB=vt(),null==_t||!_t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=_t}save(_t){var Nt=this;return(0,lt.Z)(function*(){if(_t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return Nt.databaseAction(Nt.modelPath,_t)})()}load(){var _t=this;return(0,lt.Z)(function*(){return _t.databaseAction(_t.modelPath)})()}databaseAction(_t,Nt){return new Promise((Kt,de)=>{const Ee=this.indexedDB.open(at,1);Ee.onupgradeneeded=()=>xt(Ee),Ee.onsuccess=()=>{const Te=Ee.result;if(null==Nt){const xe=Te.transaction(Gt,"readonly"),fn=xe.objectStore(Gt).get(this.modelPath);fn.onsuccess=()=>{if(null==fn.result)return Te.close(),de(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));Kt(fn.result.modelArtifacts)},fn.onerror=f=>(Te.close(),de(fn.error)),xe.oncomplete=()=>Te.close()}else{Nt.weightData=P.w.join(Nt.weightData);const xe=(0,St.Q)(Nt),Pe=Te.transaction(O,"readwrite");let f,E,fn=Pe.objectStore(O);try{f=fn.put({modelPath:this.modelPath,modelArtifactsInfo:xe})}catch(D){return de(D)}f.onsuccess=()=>{E=Te.transaction(Gt,"readwrite");const D=E.objectStore(Gt);let j;try{j=D.put({modelPath:this.modelPath,modelArtifacts:Nt,modelArtifactsInfo:xe})}catch(mt){return de(mt)}j.onsuccess=()=>Kt({modelArtifactsInfo:xe}),j.onerror=mt=>{fn=Pe.objectStore(O);const Ft=fn.delete(this.modelPath);Ft.onsuccess=()=>(Te.close(),de(j.error)),Ft.onerror=ce=>(Te.close(),de(j.error))}},f.onerror=D=>(Te.close(),de(f.error)),Pe.oncomplete=()=>{null==E?Te.close():E.oncomplete=()=>Te.close()}}},Ee.onerror=Te=>de(Ee.error)})}}return gt.URL_SCHEME="indexeddb://",gt})();const It=gt=>(0,et.OB)().getBool("IS_BROWSER")&&!Array.isArray(gt)&&gt.startsWith(Mt.URL_SCHEME)?function re(gt){return new Mt(gt)}(gt.slice(Mt.URL_SCHEME.length)):null;q.registerSaveRouter(It),q.registerLoadRouter(It);class ee{constructor(){this.indexedDB=vt()}listModels(){var ct=this;return(0,lt.Z)(function*(){return new Promise((_t,Nt)=>{const Kt=ct.indexedDB.open(at,1);Kt.onupgradeneeded=()=>xt(Kt),Kt.onsuccess=()=>{const de=Kt.result,Ee=de.transaction(O,"readonly"),xe=Ee.objectStore(O).getAll();xe.onsuccess=()=>{const Pe={};for(const fn of xe.result)Pe[fn.modelPath]=fn.modelArtifactsInfo;_t(Pe)},xe.onerror=Pe=>(de.close(),Nt(xe.error)),Ee.oncomplete=()=>de.close()},Kt.onerror=de=>Nt(Kt.error)})})()}removeModel(ct){var _t=this;return(0,lt.Z)(function*(){return ct=function Bt(gt){return gt.startsWith(Mt.URL_SCHEME)?gt.slice(Mt.URL_SCHEME.length):gt}(ct),new Promise((Nt,Kt)=>{const de=_t.indexedDB.open(at,1);de.onupgradeneeded=()=>xt(de),de.onsuccess=()=>{const Ee=de.result,Te=Ee.transaction(O,"readwrite"),xe=Te.objectStore(O),Pe=xe.get(ct);let fn;Pe.onsuccess=()=>{if(null==Pe.result)return Ee.close(),Kt(new Error(`Cannot find model with path '${ct}' in IndexedDB.`));{const f=xe.delete(ct),E=()=>{fn=Ee.transaction(Gt,"readwrite");const j=fn.objectStore(Gt).delete(ct);j.onsuccess=()=>Nt(Pe.result.modelArtifactsInfo),j.onerror=mt=>Kt(Pe.error)};f.onsuccess=E,f.onerror=D=>(E(),Ee.close(),Kt(Pe.error))}},Pe.onerror=f=>(Ee.close(),Kt(Pe.error)),Te.oncomplete=()=>{null==fn?Ee.close():fn.oncomplete=()=>Ee.close()}},de.onerror=Ee=>Kt(de.error)})})()}}var jt=y(5359);const se="/",we="tensorflowjs_models",Me="info",Xe="model_topology",Ue="weight_specs",De="weight_data",Tn="model_metadata";function ne(gt){return{info:[we,gt,Me].join(se),topology:[we,gt,Xe].join(se),weightSpecs:[we,gt,Ue].join(se),weightData:[we,gt,De].join(se),modelMetadata:[we,gt,Tn].join(se)}}function pe(gt){for(const ct of Object.values(gt))window.localStorage.removeItem(ct)}function Ie(gt){const ct=gt.split(se);if(ct.length<3)throw new Error(`Invalid key format: ${gt}`);return ct.slice(1,ct.length-1).join(se)}let Wn=(()=>{class gt{constructor(_t){if(!(0,et.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==_t||!_t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=_t,this.keys=ne(this.modelPath)}save(_t){var Nt=this;return(0,lt.Z)(function*(){if(_t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const Kt=JSON.stringify(_t.modelTopology),de=JSON.stringify(_t.weightSpecs),Ee=(0,St.Q)(_t),Te=P.w.join(_t.weightData);try{return Nt.LS.setItem(Nt.keys.info,JSON.stringify(Ee)),Nt.LS.setItem(Nt.keys.topology,Kt),Nt.LS.setItem(Nt.keys.weightSpecs,de),Nt.LS.setItem(Nt.keys.weightData,(0,St._n)(Te)),Nt.LS.setItem(Nt.keys.modelMetadata,JSON.stringify({format:_t.format,generatedBy:_t.generatedBy,convertedBy:_t.convertedBy,signature:null!=_t.signature?_t.signature:void 0,userDefinedMetadata:null!=_t.userDefinedMetadata?_t.userDefinedMetadata:void 0,modelInitializer:null!=_t.modelInitializer?_t.modelInitializer:void 0,initializerSignature:null!=_t.initializerSignature?_t.initializerSignature:void 0,trainingConfig:null!=_t.trainingConfig?_t.trainingConfig:void 0})),{modelArtifactsInfo:Ee}}catch{throw pe(Nt.keys),new Error(`Failed to save model '${Nt.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${Ee.modelTopologyBytes}, weightSpecsBytes=${Ee.weightSpecsBytes}, weightDataBytes=${Ee.weightDataBytes}.`)}}})()}load(){var _t=this;return(0,lt.Z)(function*(){const Nt=JSON.parse(_t.LS.getItem(_t.keys.info));if(null==Nt)throw new Error(`In local storage, there is no model with name '${_t.modelPath}'`);if("JSON"!==Nt.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const Kt={},de=JSON.parse(_t.LS.getItem(_t.keys.topology));if(null==de)throw new Error(`In local storage, the topology of model '${_t.modelPath}' is missing.`);Kt.modelTopology=de;const Ee=JSON.parse(_t.LS.getItem(_t.keys.weightSpecs));if(null==Ee)throw new Error(`In local storage, the weight specs of model '${_t.modelPath}' are missing.`);Kt.weightSpecs=Ee;const Te=_t.LS.getItem(_t.keys.modelMetadata);if(null!=Te){const Pe=JSON.parse(Te);Kt.format=Pe.format,Kt.generatedBy=Pe.generatedBy,Kt.convertedBy=Pe.convertedBy,null!=Pe.signature&&(Kt.signature=Pe.signature),null!=Pe.userDefinedMetadata&&(Kt.userDefinedMetadata=Pe.userDefinedMetadata),null!=Pe.modelInitializer&&(Kt.modelInitializer=Pe.modelInitializer),null!=Pe.initializerSignature&&(Kt.initializerSignature=Pe.initializerSignature),null!=Pe.trainingConfig&&(Kt.trainingConfig=Pe.trainingConfig)}const xe=_t.LS.getItem(_t.keys.weightData);if(null==xe)throw new Error(`In local storage, the binary weight values of model '${_t.modelPath}' are missing.`);return Kt.weightData=(0,St.n7)(xe),Kt})()}}return gt.URL_SCHEME="localstorage://",gt})();const Er=gt=>(0,et.OB)().getBool("IS_BROWSER")&&!Array.isArray(gt)&&gt.startsWith(Wn.URL_SCHEME)?function Nn(gt){return new Wn(gt)}(gt.slice(Wn.URL_SCHEME.length)):null;q.registerSaveRouter(Er),q.registerLoadRouter(Er);class Yn{constructor(){(0,jt.hu)((0,et.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,jt.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var ct=this;return(0,lt.Z)(function*(){const _t={},Nt=we+se,Kt=se+Me;for(let de=0;de<ct.LS.length;++de){const Ee=ct.LS.key(de);Ee.startsWith(Nt)&&Ee.endsWith(Kt)&&(_t[Ie(Ee)]=JSON.parse(ct.LS.getItem(Ee)))}return _t})()}removeModel(ct){var _t=this;return(0,lt.Z)(function*(){const Nt=ne(ct=function Je(gt){return gt.startsWith(Wn.URL_SCHEME)?gt.slice(Wn.URL_SCHEME.length):gt}(ct));if(null==_t.LS.getItem(Nt.info))throw new Error(`Cannot find model at path '${ct}'`);const Kt=JSON.parse(_t.LS.getItem(Nt.info));return pe(Nt),Kt})()}}const hi="://";class di{constructor(){this.managers={}}static getInstance(){return null==di.instance&&(di.instance=new di),di.instance}static registerManager(ct,_t){(0,jt.hu)(null!=ct,()=>"scheme must not be undefined or null."),ct.endsWith(hi)&&(ct=ct.slice(0,ct.indexOf(hi))),(0,jt.hu)(ct.length>0,()=>"scheme must not be an empty string.");const Nt=di.getInstance();(0,jt.hu)(null==Nt.managers[ct],()=>`A model store manager is already registered for scheme '${ct}'.`),Nt.managers[ct]=_t}static getManager(ct){const _t=di.getInstance().managers[ct];if(null==_t)throw new Error(`Cannot find model manager for scheme '${ct}'`);return _t}static getSchemes(){return Object.keys(di.getInstance().managers)}}function to(gt){if(-1===gt.indexOf(hi))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${di.getSchemes().join(",")}`);return{scheme:gt.split(hi)[0],path:gt.split(hi)[1]}}function ii(gt,ct){return yn.apply(this,arguments)}function yn(){return(yn=(0,lt.Z)(function*(gt,ct,_t=!1){(0,jt.hu)(gt!==ct,()=>`Old path and new path are the same: '${gt}'`);const Nt=q.getLoadHandlers(gt);(0,jt.hu)(Nt.length>0,()=>`Copying failed because no load handler is found for source URL ${gt}.`),(0,jt.hu)(Nt.length<2,()=>`Copying failed because more than one (${Nt.length}) load handlers for source URL ${gt}.`);const Kt=Nt[0],de=q.getSaveHandlers(ct);(0,jt.hu)(de.length>0,()=>`Copying failed because no save handler is found for destination URL ${ct}.`),(0,jt.hu)(de.length<2,()=>`Copying failed because more than one (${Nt.length}) save handlers for destination URL ${ct}.`);const Ee=de[0],Te=to(gt).scheme,xe=to(gt).path,Pe=Te===to(gt).scheme,fn=yield Kt.load();_t&&Pe&&(yield di.getManager(Te).removeModel(xe));const f=yield Ee.save(fn);return _t&&!Pe&&(yield di.getManager(Te).removeModel(xe)),f.modelArtifactsInfo})).apply(this,arguments)}function Qo(){return xo.apply(this,arguments)}function xo(){return(xo=(0,lt.Z)(function*(){const gt=di.getSchemes(),ct={};for(const _t of gt){const Nt=yield di.getManager(_t).listModels();for(const Kt in Nt)ct[_t+hi+Kt]=Nt[Kt]}return ct})).apply(this,arguments)}function Gn(gt){return Hs.apply(this,arguments)}function Hs(){return(Hs=(0,lt.Z)(function*(gt){const ct=to(gt);return di.getManager(ct.scheme).removeModel(ct.path)})).apply(this,arguments)}function Ce(gt,ct){return Et.apply(this,arguments)}function Et(){return(Et=(0,lt.Z)(function*(gt,ct){return ii(gt,ct,!1)})).apply(this,arguments)}function Rt(gt,ct){return te.apply(this,arguments)}function te(){return(te=(0,lt.Z)(function*(gt,ct){return ii(gt,ct,!0)})).apply(this,arguments)}var oe=y(4705);class ie{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(ct,_t){return fetch(ct,_t)}now(){return performance.now()}encode(ct,_t){if("utf-8"!==_t&&"utf8"!==_t)throw new Error(`Browser's encoder only supports utf-8, but got ${_t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(ct)}decode(ct,_t){return new TextDecoder(_t).decode(ct)}setTimeoutCustom(ct,_t){typeof window>"u"||!(0,et.OB)().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(ct,_t):(this.functionRefs.push(ct),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},_t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",Nt=>{Nt.source===window&&Nt.data.name===this.messageName&&(Nt.stopPropagation(),(0,this.functionRefs[Nt.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(ct){return(0,oe.j)(ct)}}if((0,et.OB)().get("IS_BROWSER")){(0,et.OB)().setPlatform("browser",new ie);try{di.registerManager(Wn.URL_SCHEME,new Yn)}catch{}try{di.registerManager(Mt.URL_SCHEME,new ee)}catch{}}let Oe;(0,et.OB)().get("IS_NODE")&&!(0,et.OB)().get("IS_BROWSER")&&(0,et.OB)().setPlatform("node",new class ue{constructor(){this.util=y(8628),this.textEncoder=new this.util.TextEncoder}fetch(ct,_t){return null!=(0,et.OB)().global.fetch?(0,et.OB)().global.fetch(ct,_t):(null==Oe&&(Oe=y(5410)),Oe(ct,_t))}now(){const ct=process.hrtime();return 1e3*ct[0]+ct[1]/1e6}encode(ct,_t){if("utf-8"!==_t&&"utf8"!==_t)throw new Error(`Node built-in encoder only supports utf-8, but got ${_t}`);return this.textEncoder.encode(ct)}decode(ct,_t){return 0===ct.length?"":new this.util.TextDecoder(_t).decode(ct)}isTypedArray(ct){return this.util.types.isFloat32Array(ct)||this.util.types.isInt32Array(ct)||this.util.types.isUint8Array(ct)||this.util.types.isUint8ClampedArray(ct)}});var en=y(582),mn=y(3062),un=y(7315),ir=y(3006),dr=y(4945);(0,Z.wv)(),(0,dr.Vp)({buffer:en.f,cast:mn.p,clone:un.d,print:ir.S});var _n=y(2773),sr=y(7066),Jr=y(3530),qn=y(8737),br=y(930),Dn=y(7527),si=y(3143),kr=y(3537),tr=y(8661);const Zi=new Map,fi=new Map;class oi{getClassName(){return this.constructor.className}static fromConfig(ct,_t){return new ct(_t)}}class zr{constructor(){this.classNameMap={}}static getMap(){return null==zr.instance&&(zr.instance=new zr),zr.instance}static register(ct){zr.getMap().classNameMap[ct.className]=[ct,ct.fromConfig]}}function js(gt,ct,_t){(0,jt.hu)(null!=gt.className,()=>"Class being registered does not have the static className property defined."),(0,jt.hu)("string"==typeof gt.className,()=>"className is required to be a string, but got type "+typeof gt.className),(0,jt.hu)(gt.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof ct>"u"&&(ct="Custom"),typeof _t>"u"&&(_t=gt.className);const Kt=ct+">"+_t;return zr.register(gt),Zi.set(Kt,gt),fi.set(gt,Kt),gt}function ho(gt){return fi.has(gt)?fi.get(gt):gt.className}class Es extends oi{minimize(ct,_t=!1,Nt){const{value:Kt,grads:de}=this.computeGradients(ct,Nt);if(null!=Nt){const Ee=Nt.map(Te=>({name:Te.name,tensor:de[Te.name]}));this.applyGradients(Ee)}else this.applyGradients(de);return(0,_n.B9)(de),_t?Kt:(Kt.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(ct,_t){return(0,kr.pn)(ct,_t)}dispose(){null!=this.iterations_&&(0,_n.B9)(this.iterations_)}saveIterations(){var ct=this;return(0,lt.Z)(function*(){return null==ct.iterations_&&(ct.iterations_=0),{name:"iter",tensor:(0,tr.i)(ct.iterations_,"int32")}})()}getWeights(){return(0,lt.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${_t.getClassName()}`)})()}extractIterations(ct){var _t=this;return(0,lt.Z)(function*(){return _t.iterations_=(yield ct[0].tensor.data())[0],ct.slice(1)})()}}Object.defineProperty(Es,Symbol.hasInstance,{value:gt=>null!=gt.minimize&&null!=gt.computeGradients&&null!=gt.applyGradients});class Ks extends Es{static get className(){return"Adadelta"}constructor(ct,_t,Nt=null){super(),this.learningRate=ct,this.rho=_t,this.epsilon=Nt,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==Nt&&(this.epsilon=Z.BV.backend.epsilon())}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Z.BV.registeredVariables[Nt];null==this.accumulatedGrads[Kt]&&(this.accumulatedGrads[Kt]={originalName:`${Nt}/accum_grad`,variable:(0,_n.lu)(()=>(0,si.P)(de).variable(!1))}),null==this.accumulatedUpdates[Kt]&&(this.accumulatedUpdates[Kt]={originalName:`${Nt}/accum_var`,variable:(0,_n.lu)(()=>(0,si.P)(de).variable(!1))});const Te=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];if(null==Te)return;const xe=this.accumulatedGrads[Kt].variable,Pe=this.accumulatedUpdates[Kt].variable;(0,_n.lu)(()=>{const fn=(0,sr.I)((0,qn.d)(xe,this.rho),(0,qn.d)((0,Dn.h)(Te),1-this.rho)),f=(0,qn.d)((0,Jr.h)((0,br._)((0,sr.I)(Pe,this.epsilon)),(0,br._)((0,sr.I)(xe,this.epsilon))),Te),E=(0,sr.I)((0,qn.d)(Pe,this.rho),(0,qn.d)((0,Dn.h)(f),1-this.rho));xe.assign(fn),Pe.assign(E);const D=(0,sr.I)((0,qn.d)(f,-this.learningRate),de);de.assign(D)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,_n.B9)(this.accumulatedGrads.map(ct=>ct.variable)),(0,_n.B9)(this.accumulatedUpdates.map(ct=>ct.variable)))}getWeights(){var ct=this;return(0,lt.Z)(function*(){const _t=[...ct.accumulatedGrads,...ct.accumulatedUpdates];return[yield ct.saveIterations()].concat(_t.map(Nt=>({name:Nt.originalName,tensor:Nt.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){const Nt=(ct=yield _t.extractIterations(ct)).length/2;_t.accumulatedGrads=ct.slice(0,Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})),_t.accumulatedUpdates=ct.slice(Nt,2*Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.rho,_t.epsilon)}}var Rs=y(2787);class ti extends Es{static get className(){return"Adagrad"}constructor(ct,_t=.1){super(),this.learningRate=ct,this.initialAccumulatorValue=_t,this.accumulatedGrads=[]}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Z.BV.registeredVariables[Nt];null==this.accumulatedGrads[Kt]&&(this.accumulatedGrads[Kt]={originalName:`${Nt}/accumulator`,variable:(0,_n.lu)(()=>(0,Rs.h)(de.shape,this.initialAccumulatorValue).variable(!1))});const Ee=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];if(null==Ee)return;const Te=this.accumulatedGrads[Kt].variable;(0,_n.lu)(()=>{const xe=(0,sr.I)(Te,(0,Dn.h)(Ee));Te.assign(xe);const Pe=(0,sr.I)((0,qn.d)((0,Jr.h)(Ee,(0,br._)((0,sr.I)(xe,Z.BV.backend.epsilon()))),-this.learningRate),de);de.assign(Pe)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,_n.B9)(this.accumulatedGrads.map(ct=>ct.variable))}getWeights(){var ct=this;return(0,lt.Z)(function*(){return[yield ct.saveIterations()].concat(ct.accumulatedGrads.map(_t=>({name:_t.originalName,tensor:_t.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){ct=yield _t.extractIterations(ct),_t.accumulatedGrads=ct.map(Kt=>({originalName:Kt.name,variable:Kt.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.initialAccumulatorValue)}}var Vr=y(2962),Eo=y(1191);class Ls extends Es{static get className(){return"Adam"}constructor(ct,_t,Nt,Kt=null){super(),this.learningRate=ct,this.beta1=_t,this.beta2=Nt,this.epsilon=Kt,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,_n.lu)(()=>{this.accBeta1=(0,tr.i)(_t).variable(),this.accBeta2=(0,tr.i)(Nt).variable()}),null==Kt&&(this.epsilon=Z.BV.backend.epsilon())}applyGradients(ct){const _t=Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct);(0,_n.lu)(()=>{const Nt=(0,Eo.l)(1,this.accBeta1),Kt=(0,Eo.l)(1,this.accBeta2);_t.forEach((de,Ee)=>{const Te=Z.BV.registeredVariables[de];null==this.accumulatedFirstMoment[Ee]&&(this.accumulatedFirstMoment[Ee]={originalName:`${de}/m`,variable:(0,_n.lu)(()=>(0,si.P)(Te).variable(!1))}),null==this.accumulatedSecondMoment[Ee]&&(this.accumulatedSecondMoment[Ee]={originalName:`${de}/v`,variable:(0,_n.lu)(()=>(0,si.P)(Te).variable(!1))});const Pe=Array.isArray(ct)?ct[Ee].tensor:ct[de];if(null==Pe)return;const fn=this.accumulatedFirstMoment[Ee].variable,f=this.accumulatedSecondMoment[Ee].variable,E=(0,sr.I)((0,qn.d)(fn,this.beta1),(0,qn.d)(Pe,1-this.beta1)),D=(0,sr.I)((0,qn.d)(f,this.beta2),(0,qn.d)((0,Dn.h)(Pe),1-this.beta2)),j=(0,Jr.h)(E,Nt),mt=(0,Jr.h)(D,Kt);fn.assign(E),f.assign(D);const Ft=(0,sr.I)((0,qn.d)((0,Jr.h)(j,(0,sr.I)((0,br._)(mt),this.epsilon)),-this.learningRate),Te);Te.assign(Ft)}),this.accBeta1.assign((0,qn.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,qn.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,_n.B9)(this.accumulatedFirstMoment.map(ct=>ct.variable)),null!=this.accumulatedSecondMoment&&(0,_n.B9)(this.accumulatedSecondMoment.map(ct=>ct.variable))}getWeights(){var ct=this;return(0,lt.Z)(function*(){const _t=[...ct.accumulatedFirstMoment,...ct.accumulatedSecondMoment];return[yield ct.saveIterations()].concat(_t.map(Nt=>({name:Nt.originalName,tensor:Nt.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){ct=yield _t.extractIterations(ct),(0,_n.lu)(()=>{_t.accBeta1.assign((0,Vr.s)(_t.beta1,_t.iterations_+1)),_t.accBeta2.assign((0,Vr.s)(_t.beta2,_t.iterations_+1))});const Nt=ct.length/2;_t.accumulatedFirstMoment=ct.slice(0,Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})),_t.accumulatedSecondMoment=ct.slice(Nt,2*Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.beta1,_t.beta2,_t.epsilon)}}var Ma=y(6989),rs=y(765);class Pa extends Es{static get className(){return"Adamax"}constructor(ct,_t,Nt,Kt=null,de=0){super(),this.learningRate=ct,this.beta1=_t,this.beta2=Nt,this.epsilon=Kt,this.decay=de,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,_n.lu)(()=>{this.iteration=(0,tr.i)(0).variable(),this.accBeta1=(0,tr.i)(_t).variable()}),null==Kt&&(this.epsilon=Z.BV.backend.epsilon())}applyGradients(ct){const _t=Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct);(0,_n.lu)(()=>{const Nt=(0,Eo.l)(1,this.accBeta1),Kt=(0,Jr.h)(-this.learningRate,(0,sr.I)((0,qn.d)(this.iteration,this.decay),1));_t.forEach((de,Ee)=>{const Te=Z.BV.registeredVariables[de];null==this.accumulatedFirstMoment[Ee]&&(this.accumulatedFirstMoment[Ee]={originalName:`${de}/m`,variable:(0,si.P)(Te).variable(!1)}),null==this.accumulatedWeightedInfNorm[Ee]&&(this.accumulatedWeightedInfNorm[Ee]={originalName:`${de}/v`,variable:(0,si.P)(Te).variable(!1)});const Pe=Array.isArray(ct)?ct[Ee].tensor:ct[de];if(null==Pe)return;const fn=this.accumulatedFirstMoment[Ee].variable,f=this.accumulatedWeightedInfNorm[Ee].variable,E=(0,sr.I)((0,qn.d)(fn,this.beta1),(0,qn.d)(Pe,1-this.beta1)),D=(0,qn.d)(f,this.beta2),j=(0,Ma.W)(Pe),mt=(0,rs.g)(D,j);fn.assign(E),f.assign(mt);const Ft=(0,sr.I)((0,qn.d)((0,Jr.h)(Kt,Nt),(0,Jr.h)(E,(0,sr.I)(mt,this.epsilon))),Te);Te.assign(Ft)}),this.iteration.assign((0,sr.I)(this.iteration,1)),this.accBeta1.assign((0,qn.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,_n.B9)(this.accumulatedFirstMoment.map(ct=>ct.variable)),null!=this.accumulatedWeightedInfNorm&&(0,_n.B9)(this.accumulatedWeightedInfNorm.map(ct=>ct.variable))}getWeights(){return(0,lt.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(ct){return(0,lt.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.beta1,_t.beta2,_t.epsilon,_t.decay)}}class eo extends Es{static get className(){return"SGD"}constructor(ct){super(),this.learningRate=ct,this.setLearningRate(ct)}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];if(null==de)return;const Ee=Z.BV.registeredVariables[Nt];(0,_n.lu)(()=>{const Te=(0,sr.I)((0,qn.d)(this.c,de),Ee);Ee.assign(Te)})}),this.incrementIterations()}setLearningRate(ct){this.learningRate=ct,null!=this.c&&this.c.dispose(),this.c=(0,_n.Cn)((0,tr.i)(-ct))}dispose(){this.c.dispose()}getWeights(){var ct=this;return(0,lt.Z)(function*(){return[yield ct.saveIterations()]})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){if(0!==(ct=yield _t.extractIterations(ct)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(ct,_t){return new ct(_t.learningRate)}}class Co extends eo{static get className(){return"Momentum"}constructor(ct,_t,Nt=!1){super(ct),this.learningRate=ct,this.momentum=_t,this.useNesterov=Nt,this.accumulations=[],this.m=(0,tr.i)(this.momentum)}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Z.BV.registeredVariables[Nt];null==this.accumulations[Kt]&&(this.accumulations[Kt]={originalName:`${Nt}/momentum`,variable:(0,_n.lu)(()=>(0,si.P)(de).variable(!1))});const Ee=this.accumulations[Kt].variable,Te=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];null!=Te&&(0,_n.lu)(()=>{let xe;const Pe=(0,sr.I)((0,qn.d)(this.m,Ee),Te);xe=(0,sr.I)((0,qn.d)(this.c,this.useNesterov?(0,sr.I)(Te,(0,qn.d)(Pe,this.m)):Pe),de),Ee.assign(Pe),de.assign(xe)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,_n.B9)(this.accumulations.map(ct=>ct.variable))}setMomentum(ct){this.momentum=ct}getWeights(){var ct=this;return(0,lt.Z)(function*(){return[yield ct.saveIterations()].concat(ct.accumulations.map(_t=>({name:_t.originalName,tensor:_t.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){ct=yield _t.extractIterations(ct),_t.accumulations=ct.map(Kt=>({originalName:Kt.name,variable:Kt.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.momentum,_t.useNesterov)}}class gs extends Es{static get className(){return"RMSProp"}constructor(ct,_t=.9,Nt=0,Kt=null,de=!1){if(super(),this.learningRate=ct,this.decay=_t,this.momentum=Nt,this.epsilon=Kt,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=de,null==Kt&&(this.epsilon=Z.BV.backend.epsilon()),null==ct)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(ct){(Array.isArray(ct)?ct.map(Nt=>Nt.name):Object.keys(ct)).forEach((Nt,Kt)=>{const de=Z.BV.registeredVariables[Nt];null==this.accumulatedMeanSquares[Kt]&&(this.accumulatedMeanSquares[Kt]={originalName:`${Nt}/rms`,variable:(0,_n.lu)(()=>(0,si.P)(de).variable(!1))}),null==this.accumulatedMoments[Kt]&&(this.accumulatedMoments[Kt]={originalName:`${Nt}/momentum`,variable:(0,_n.lu)(()=>(0,si.P)(de).variable(!1))}),null==this.accumulatedMeanGrads[Kt]&&this.centered&&(this.accumulatedMeanGrads[Kt]={originalName:`${Nt}/mg`,variable:(0,_n.lu)(()=>(0,si.P)(de).variable(!1))});const Te=Array.isArray(ct)?ct[Kt].tensor:ct[Nt];if(null==Te)return;const xe=this.accumulatedMeanSquares[Kt].variable,Pe=this.accumulatedMoments[Kt].variable;(0,_n.lu)(()=>{const fn=(0,sr.I)((0,qn.d)(xe,this.decay),(0,qn.d)((0,Dn.h)(Te),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[Kt].variable,E=(0,sr.I)((0,qn.d)(f,this.decay),(0,qn.d)(Te,1-this.decay)),D=(0,Jr.h)((0,qn.d)(Te,this.learningRate),(0,br._)((0,Eo.l)(fn,(0,sr.I)((0,Dn.h)(E),this.epsilon)))),j=(0,sr.I)((0,qn.d)(Pe,this.momentum),D);xe.assign(fn),f.assign(E),Pe.assign(j);const mt=(0,Eo.l)(de,j);de.assign(mt)}else{const f=(0,sr.I)((0,qn.d)(xe,this.decay),(0,qn.d)((0,Dn.h)(Te),1-this.decay)),E=(0,sr.I)((0,qn.d)(Pe,this.momentum),(0,Jr.h)((0,qn.d)(Te,this.learningRate),(0,br._)((0,sr.I)(f,this.epsilon))));xe.assign(f),Pe.assign(E);const D=(0,Eo.l)(de,E);de.assign(D)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,_n.B9)(this.accumulatedMeanSquares.map(ct=>ct.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,_n.B9)(this.accumulatedMeanGrads.map(ct=>ct.variable)),null!=this.accumulatedMoments&&(0,_n.B9)(this.accumulatedMoments.map(ct=>ct.variable))}getWeights(){var ct=this;return(0,lt.Z)(function*(){const _t=[...ct.accumulatedMeanSquares,...ct.accumulatedMoments];return ct.centered&&_t.push(...ct.accumulatedMeanGrads),[yield ct.saveIterations()].concat(_t.map(Nt=>({name:Nt.originalName,tensor:Nt.variable})))})()}setWeights(ct){var _t=this;return(0,lt.Z)(function*(){ct=yield _t.extractIterations(ct);const Nt=_t.centered?ct.length/3:ct.length/2;_t.accumulatedMeanSquares=ct.slice(0,Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})),_t.accumulatedMoments=ct.slice(Nt,2*Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})),_t.centered&&(_t.accumulatedMeanGrads=ct.slice(2*Nt,3*Nt).map(de=>({originalName:de.name,variable:de.tensor.variable(!1)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(ct,_t){return new ct(_t.learningRate,_t.decay,_t.momentum,_t.epsilon,_t.centered)}}const Ua=[Ks,ti,Ls,Pa,Co,gs,eo];function du(gt){return new Promise(ct=>setTimeout(ct)).then(gt)}let Xs=(()=>{class gt{constructor(_t){if(!(0,et.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");_t.startsWith(gt.URL_SCHEME)&&(_t=_t.slice(gt.URL_SCHEME.length)),(null==_t||0===_t.length)&&(_t="model"),this.modelJsonFileName=_t+".json",this.weightDataFileName=_t+".weights.bin"}save(_t){var Nt=this;return(0,lt.Z)(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const Kt=P.w.join(_t.weightData),de=window.URL.createObjectURL(new Blob([Kt],{type:"application/octet-stream"}));if(_t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const Te=(0,St.Yd)(_t,[{paths:["./"+Nt.weightDataFileName],weights:_t.weightSpecs}]),xe=window.URL.createObjectURL(new Blob([JSON.stringify(Te)],{type:"application/json"})),Pe=null==Nt.modelJsonAnchor?document.createElement("a"):Nt.modelJsonAnchor;if(Pe.download=Nt.modelJsonFileName,Pe.href=xe,yield du(()=>Pe.dispatchEvent(new MouseEvent("click"))),null!=_t.weightData){const fn=null==Nt.weightDataAnchor?document.createElement("a"):Nt.weightDataAnchor;fn.download=Nt.weightDataFileName,fn.href=de,yield du(()=>fn.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:(0,St.Q)(_t)}}})()}}return gt.URL_SCHEME="downloads://",gt})();class Wa{constructor(ct){if(null==ct||ct.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${ct}`);this.jsonFile=ct[0],this.weightsFiles=ct.slice(1)}load(){var ct=this;return(0,lt.Z)(function*(){return new Promise((_t,Nt)=>{const Kt=new FileReader;Kt.onload=de=>{const Ee=JSON.parse(de.target.result),Te=Ee.modelTopology;if(null==Te)return void Nt(new Error(`modelTopology field is missing from file ${ct.jsonFile.name}`));if(null==Ee.weightsManifest)return void Nt(new Error(`weightManifest field is missing from file ${ct.jsonFile.name}`));if(0===ct.weightsFiles.length)return void _t({modelTopology:Te});const Pe=(0,St.jN)(Ee,fn=>ct.loadWeights(fn));_t(Pe)},Kt.onerror=de=>Nt(`Failed to read model topology and weights manifest JSON from file '${ct.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),Kt.readAsText(ct.jsonFile)})})()}loadWeights(ct){const _t=[],Nt=[];for(const Ee of ct)_t.push(...Ee.weights),Nt.push(...Ee.paths);const Kt=this.checkManifestAndWeightFiles(ct),de=Nt.map(Ee=>this.loadWeightsFile(Ee,Kt[Ee]));return Promise.all(de).then(Ee=>[_t,Ee])}loadWeightsFile(ct,_t){return new Promise((Nt,Kt)=>{const de=new FileReader;de.onload=Ee=>{Nt(Ee.target.result)},de.onerror=Ee=>Kt(`Failed to weights data from file of path '${ct}'.`),de.readAsArrayBuffer(_t)})}checkManifestAndWeightFiles(ct){const _t=[],Nt=this.weightsFiles.map(de=>(0,St.EZ)(de.name)),Kt={};for(const de of ct)de.paths.forEach(Ee=>{const Te=(0,St.EZ)(Ee);if(-1!==_t.indexOf(Te))throw new Error(`Duplicate file basename found in weights manifest: '${Te}'`);if(_t.push(Te),-1===Nt.indexOf(Te))throw new Error(`Weight file with basename '${Te}' is not provided.`);Kt[Ee]=this.weightsFiles[Nt.indexOf(Te)]});if(_t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${_t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return Kt}}function Gr(gt){return new Wa(gt)}function Qn(gt,ct,_t,Nt){(function Ee(xe){(0,jt.hu)(null!=xe&&Array.isArray(xe)&&xe.length>0,()=>"promises must be a none empty array")})(gt),function Te(xe,Pe){(0,jt.hu)(xe>=0&&xe<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${xe}`),(0,jt.hu)(Pe>=0&&Pe<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${Pe}`),(0,jt.hu)(Pe>=xe,()=>`startFraction must be no more than endFraction, but got startFraction ${xe} and endFraction ${Pe}`)}(_t=_t??0,Nt=Nt??1);let Kt=0;return Promise.all(gt.map(xe=>(xe.then(Pe=>{const fn=_t+ ++Kt/gt.length*(Nt-_t);return ct(fn),Pe}),xe)))}q.registerSaveRouter(gt=>(0,et.OB)().getBool("IS_BROWSER")&&!Array.isArray(gt)&&gt.startsWith(Xs.URL_SCHEME)?function An(gt="model"){return new Xs(gt)}(gt.slice(Xs.URL_SCHEME.length)):null);var ma=y(1352);function er(gt,ct){return bo.apply(this,arguments)}function bo(){return(bo=(0,lt.Z)(function*(gt,ct){null==ct&&(ct={});const _t=null==ct.fetchFunc?(0,et.OB)().platform.fetch:ct.fetchFunc,Nt=gt.map(f=>_t(f,ct.requestInit,{isBinary:!0})),Te=(null==ct.onProgress?yield Promise.all(Nt):yield Qn(Nt,ct.onProgress,0,.5)).map(f=>f.arrayBuffer());return null==ct.onProgress?yield Promise.all(Te):yield Qn(Te,ct.onProgress,.5,1)})).apply(this,arguments)}function ga(gt){return Xn.apply(this,arguments)}function Xn(){return(Xn=(0,lt.Z)(function*(gt,ct="",_t,Nt){return Cs(Ee=>er(Ee,{requestInit:Nt}))(gt,ct,_t)})).apply(this,arguments)}function Cs(gt){return function(){var ct=(0,lt.Z)(function*(_t,Nt="",Kt){const de=_t.map(()=>!1),Ee={},Te=null!=Kt?Kt.map(()=>!1):[],xe=[];if(_t.forEach((j,mt)=>{let Ft=0;j.weights.forEach(ce=>{const Ve=ma.J["quantization"in ce?ce.quantization.dtype:ce.dtype]*jt.NA(ce.shape),sn=()=>{de[mt]=!0,null==Ee[mt]&&(Ee[mt]=[]),Ee[mt].push({manifestEntry:ce,groupOffset:Ft,sizeBytes:Ve})};null!=Kt?Kt.forEach((wn,Pn)=>{wn===ce.name&&(sn(),Te[Pn]=!0)}):sn(),xe.push(ce.name),Ft+=Ve})}),!Te.every(j=>j)){const j=Kt.filter((mt,Ft)=>!Te[Ft]);throw new Error(`Could not find weights in manifest with names: ${j.join(", ")}. \nManifest JSON has weights with names: ${xe.join(", ")}.`)}const Pe=de.reduce((j,mt,Ft)=>(mt&&j.push(Ft),j),[]),fn=[];Pe.forEach(j=>{_t[j].paths.forEach(mt=>{const Ft=Nt+(Nt.endsWith("/")?"":"/")+mt;fn.push(Ft)})});const f=yield gt(fn),E={};let D=0;return Pe.forEach(j=>{const mt=_t[j].paths.length,Ft=new P.w(f.slice(D,D+mt));Ee[j].forEach(ye=>{const Ve=Ft.slice(ye.groupOffset,ye.groupOffset+ye.sizeBytes),sn=(0,St.dI)(Ve,[ye.manifestEntry]);for(const wn in sn)E[wn]=sn[wn]}),D+=mt}),E});return function(_t){return ct.apply(this,arguments)}}()}let an=(()=>{class gt{constructor(_t,Nt){if(this.DEFAULT_METHOD="POST",null==Nt&&(Nt={}),this.weightPathPrefix=Nt.weightPathPrefix,this.weightUrlConverter=Nt.weightUrlConverter,null!=Nt.fetchFunc?((0,jt.hu)("function"==typeof Nt.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=Nt.fetchFunc):this.fetch=(0,et.OB)().platform.fetch,(0,jt.hu)(null!=_t&&_t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(_t)&&(0,jt.hu)(2===_t.length,()=>`URL paths for http must have a length of 2, (actual length is ${_t.length}).`),this.path=_t,null!=Nt.requestInit&&null!=Nt.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=Nt.requestInit||{},this.loadOptions=Nt}save(_t){var Nt=this;return(0,lt.Z)(function*(){if(_t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const Kt=Object.assign({method:Nt.DEFAULT_METHOD},Nt.requestInit);Kt.body=new FormData;const Ee=(0,St.Yd)(_t,[{paths:["./model.weights.bin"],weights:_t.weightSpecs}]);if(Kt.body.append("model.json",new Blob([JSON.stringify(Ee)],{type:"application/json"}),"model.json"),null!=_t.weightData){const xe=P.w.join(_t.weightData);Kt.body.append("model.weights.bin",new Blob([xe],{type:"application/octet-stream"}),"model.weights.bin")}const Te=yield Nt.fetch(Nt.path,Kt);if(Te.ok)return{modelArtifactsInfo:(0,St.Q)(_t),responses:[Te]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${Te.status}.`)})()}loadModelJSON(){var _t=this;return(0,lt.Z)(function*(){const Nt=yield _t.fetch(_t.path,_t.requestInit);if(!Nt.ok)throw new Error(`Request to ${_t.path} failed with status code ${Nt.status}. Please verify this URL points to the model JSON of the model to load.`);let Kt;try{Kt=yield Nt.json()}catch{let xe=`Failed to parse model JSON of response from ${_t.path}.`;throw _t.path.endsWith(".pb")?xe+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":xe+=" Please make sure the server is serving valid JSON for this request.",new Error(xe)}if(null==Kt.modelTopology&&null==Kt.weightsManifest)throw new Error(`The JSON from HTTP path ${_t.path} contains neither model topology or manifest for weights.`);return Kt})()}load(){var _t=this;return(0,lt.Z)(function*(){if(_t.loadOptions.streamWeights)return _t.loadStream();const Nt=yield _t.loadModelJSON();return(0,St.jN)(Nt,Kt=>_t.loadWeights(Kt))})()}loadStream(){var _t=this;return(0,lt.Z)(function*(){const Nt=yield _t.loadModelJSON(),Kt=yield _t.getWeightUrls(Nt.weightsManifest),de=(0,St.hu)(Nt.weightsManifest);return Object.assign(Object.assign({},Nt),{weightSpecs:de,getWeightStream:()=>function Yu(gt,ct){var _t;const Nt=null==ct.fetchFunc?(0,et.OB)().platform.fetch:ct.fetchFunc;let de,Kt=0;return null===(_t=ct.onProgress)||void 0===_t||_t.call(ct,0),new ReadableStream({pull:(Ee=(0,lt.Z)(function*(Te){for(var xe;Kt<gt.length;){de||(de=(yield Nt(gt[Kt],ct.requestInit,{isBinary:!0})).body.getReader());const{done:Pe,value:fn}=yield de.read();if(!Pe)return void Te.enqueue(fn);Kt++,de=void 0,null===(xe=ct.onProgress)||void 0===xe||xe.call(ct,Kt/gt.length)}Te.close()}),function(xe){return Ee.apply(this,arguments)})});var Ee}(Kt,_t.loadOptions)})})()}getWeightUrls(_t){var Nt=this;return(0,lt.Z)(function*(){const Kt=Array.isArray(Nt.path)?Nt.path[1]:Nt.path,[de,Ee]=function ei(gt){const ct=gt.lastIndexOf("/"),_t=gt.lastIndexOf("?");return[gt.substring(0,ct)+"/",_t>ct?gt.substring(_t):""]}(Kt),Te=Nt.weightPathPrefix||de,xe=[],Pe=[];for(const fn of _t)for(const f of fn.paths)null!=Nt.weightUrlConverter?Pe.push(Nt.weightUrlConverter(f)):xe.push(Te+f+Ee);return Nt.weightUrlConverter&&xe.push(...yield Promise.all(Pe)),xe})()}loadWeights(_t){var Nt=this;return(0,lt.Z)(function*(){const Kt=yield Nt.getWeightUrls(_t);return[(0,St.hu)(_t),yield er(Kt,Nt.loadOptions)]})()}}return gt.URL_SCHEME_REGEX=/^https?:\/\//,gt})();function Fn(gt){return null!=gt.match(an.URL_SCHEME_REGEX)}const Ss=(gt,ct)=>{if(typeof fetch>"u"&&(null==ct||null==ct.fetchFunc))return null;{let _t=!0;if(_t=Array.isArray(gt)?gt.every(Nt=>Fn(Nt)):Fn(gt),_t)return wo(gt,ct)}return null};function wo(gt,ct){return new an(gt,ct)}function ks(gt,ct){return wo(gt,ct)}q.registerSaveRouter(Ss),q.registerLoadRouter(Ss);class Ur{constructor(ct){this.modelArtifacts=ct}load(){return this.modelArtifacts}}class We{constructor(ct){this.saveHandler=ct}save(ct){return this.saveHandler(ct)}}class Kr{constructor(ct){ct.load&&(this.load=()=>Promise.resolve(ct.load())),ct.save&&(this.save=_t=>Promise.resolve(ct.save(_t)))}}function mr(gt,ct,_t,Nt){return new Kr(ai(...arguments))}function ai(gt,ct,_t,Nt){return 1===arguments.length?null!=gt.modelTopology||null!=gt.weightSpecs?new Ur(gt):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ur({modelTopology:gt})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ur({modelTopology:gt,weightSpecs:ct,weightData:_t,trainingConfig:Nt}))}function Kn(gt){return new We(gt)}function Pr(gt){return new We(gt)}var wr=y(1257),Wr=y(5592),Ds=y(5618),ss=y(4195),wu=y(9194);const Or=(0,ss.op)({confusionMatrix_:function Fo(gt,ct,_t){const Nt=(0,wr._1)(gt,"labels","confusionMatrix"),Kt=(0,wr._1)(ct,"predictions","confusionMatrix");jt.hu(null==_t||_t>0&&Number.isInteger(_t),()=>`If provided, numClasses must be a positive integer, but got ${_t}`),jt.hu(1===Nt.rank,()=>`Expected the rank of labels to be 1, but got ${Nt.rank}`),jt.hu(1===Kt.rank,()=>`Expected the rank of predictions to be 1, but got ${Kt.rank}`),jt.hu(Nt.shape[0]===Kt.shape[0],()=>`Mismatch in the number of examples: ${Nt.shape[0]} vs. ${Kt.shape[0]}. Labels and predictions should have the same number of elements.`),jt.hu(_t>0&&Number.isInteger(_t),()=>`numClasses is required to be a positive integer, but got ${_t}`);const de=(0,Ds.l)((0,mn.p)(Nt,"int32"),_t),Ee=(0,Ds.l)((0,mn.p)(Kt,"int32"),_t),Te=(0,wu.p)(de),xe=(0,Wr.O)(Te,Ee);return(0,mn.p)(xe,"int32")}});var os=y(3239),_e=y(4251),z=y(8987),I=y(2786);let M,tt=!1;function bt(gt,ct=3){if(ct>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==gt)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let _t=!1,Nt=!1,Kt=!1,de=!1,Ee=!1,Te=!1;if(gt.data instanceof Uint8Array)_t=!0;else if(typeof ImageData<"u"&&gt instanceof ImageData)Nt=!0;else if(typeof HTMLVideoElement<"u"&&gt instanceof HTMLVideoElement)Kt=!0;else if(typeof HTMLImageElement<"u"&&gt instanceof HTMLImageElement)de=!0;else if(null!=gt.getContext)Ee=!0;else{if(!(typeof ImageBitmap<"u"&&gt instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${gt.constructor.name}`);Te=!0}if(null!=(0,z.pI)(_e.eBW,Z.BV.backendName))return Z.BV.runKernel(_e.eBW,{pixels:gt},{numChannels:ct});const[Pe,fn]=Kt?[gt.videoWidth,gt.videoHeight]:[gt.width,gt.height];let f,E;if(Ee)f=gt.getContext("2d").getImageData(0,0,Pe,fn).data;else if(Nt||_t)f=gt.data;else if(de||Kt||Te){if(null==M)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");M=new OffscreenCanvas(1,1).getContext("2d")}else M=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});M.canvas.width=Pe,M.canvas.height=fn,M.drawImage(gt,0,0,Pe,fn),f=M.getImageData(0,0,Pe,fn).data}if(4===ct)E=new Int32Array(f);else{const j=Pe*fn;E=new Int32Array(j*ct);for(let mt=0;mt<j;mt++)for(let Ft=0;Ft<ct;++Ft)E[mt*ct+Ft]=f[4*mt+Ft]}return(0,I.w)(E,[fn,Pe,ct],"int32")}function nn(gt){return Ye.apply(this,arguments)}function Ye(){return(Ye=(0,lt.Z)(function*(gt,ct=3){let _t=null;if((0,et.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function ae(gt){return function Yt(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(gt instanceof ImageBitmap)&&function kt(gt){return null!=gt&&0!==gt.width&&0!==gt.height}(gt)&&!function At(gt){return null!=gt&&gt.data instanceof Uint8Array}(gt)}(gt)){let Nt;try{Nt=yield createImageBitmap(gt,{premultiplyAlpha:"none"})}catch{Nt=null}_t=null!=Nt&&Nt.width===gt.width&&Nt.height===gt.height?Nt:gt}else _t=gt;return bt(_t,ct)})).apply(this,arguments)}function $e(gt){if(2!==gt.rank&&3!==gt.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${gt.rank}.`);const ct=2===gt.rank?1:gt.shape[2];if(ct>4||2===ct)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${ct}`);if("float32"!==gt.dtype&&"int32"!==gt.dtype)throw new Error(`Unsupported type for toPixels: ${gt.dtype}. Please use float32 or int32 tensors.`)}function $n(gt,ct){return Vn.apply(this,arguments)}function Vn(){return(Vn=(0,lt.Z)(function*(gt,ct){let _t=(0,wr._1)(gt,"img","toPixels");if(!(gt instanceof dr.es)){const Pe=_t;_t=(0,mn.p)(Pe,"int32"),Pe.dispose()}$e(_t);const[Nt,Kt]=_t.shape.slice(0,2),de=2===_t.rank?1:_t.shape[2],Ee=yield _t.data(),Te="float32"===_t.dtype?255:1,xe=new Uint8ClampedArray(Kt*Nt*4);for(let Pe=0;Pe<Nt*Kt;++Pe){const fn=[0,0,0,255];for(let E=0;E<de;E++){const D=Ee[Pe*de+E];if("float32"===_t.dtype){if(D<0||D>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${D}.`)}else if("int32"===_t.dtype&&(D<0||D>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${D}.`);1===de?(fn[0]=D*Te,fn[1]=D*Te,fn[2]=D*Te):fn[E]=D*Te}const f=4*Pe;xe[f+0]=Math.round(fn[0]),xe[f+1]=Math.round(fn[1]),xe[f+2]=Math.round(fn[2]),xe[f+3]=Math.round(fn[3])}if(null!=ct){tt||null!=(0,z.pI)(_e.hGc,Z.BV.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),tt=!0),ct.width=Kt,ct.height=Nt;const Pe=ct.getContext("2d"),fn=new ImageData(xe,Kt,Nt);Pe.putImageData(fn,0,0)}return _t!==gt&&_t.dispose(),xe})).apply(this,arguments)}function vr(gt,ct,_t){let Nt=(0,wr._1)(gt,"img","draw");if(!(gt instanceof dr.es)){const Ee=Nt;Nt=(0,mn.p)(Ee,"int32"),Ee.dispose()}$e(Nt),function Cn(gt){const ct=gt?.alpha||1;if(ct>1||ct<0)throw new Error(`Alpha value ${ct} is suppoed to be in range [0 - 1].`)}(_t?.imageOptions),Z.BV.runKernel(_e.hGc,{image:Nt},{canvas:ct,options:_t})}const bn=(0,ss.op)({fromPixels_:bt});function _r(gt,ct){const _t=gt.shape.length,Nt=ct.shape.length;if(_t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${_t}.`);if(Nt<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${Nt}.`);if("int32"!==ct.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${ct.dtype}.`);if(ct.shape[Nt-1]>_t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${ct.shape[Nt-1]} vs. ${_t}`);if(0===(0,jt.NA)(gt.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${gt.shape}.`);const Kt=ct.shape,de=Kt[Kt.length-1];let Ee=1;for(let f=0;f<Kt.length-1;++f)Ee*=Kt[f];const Te=gt.shape,xe=Kt.slice();xe.pop();let Pe=1;for(let f=de;f<_t;++f)Pe*=Te[f],xe.push(Te[f]);const fn=[...(0,jt.e3)(gt.shape).map(f=>f/Pe),1].slice(0,de);return[xe,Ee,Pe,fn]}var ni=y(1876),Zs=y(2320),Xr=y(7664),tn=y(1153);const Iu=.001,xr=.1;function Qi(gt,ct,_t){return null==_t&&(_t=fo()),vs(gt,ct,(Nt,Kt)=>Zr(Nt,Kt,_t))}function fo(){return 32===Z.BV.backend.floatPrecision()?Iu:xr}function vs(gt,ct,_t){let Nt=!0;if(((0,tn.isTypedArray)(gt)||(0,tn.isTypedArray)(ct))&&(Nt=!1),(0,tn.isTypedArray)(gt)&&(0,tn.isTypedArray)(ct)&&(Nt=!0),Nt){const Ee=gt.constructor.name,Te=ct.constructor.name;if(Ee!==Te)throw new Error(`Arrays are of different type. Actual: ${Ee}. Expected: ${Te}`)}if(Array.isArray(gt)&&Array.isArray(ct)){const Ee=(0,wr.C)(gt),Te=(0,wr.C)(ct);if(!(0,jt.cO)(Ee,Te))throw new Error(`Arrays have different shapes. Actual: [${Ee}]. Expected: [${Te}]`)}const Kt=(0,tn.isTypedArray)(gt)?gt:(0,tn.flatten)(gt),de=(0,tn.isTypedArray)(ct)?ct:(0,tn.flatten)(ct);if(Kt.length!==de.length)throw new Error(`Arrays have different lengths actual: ${Kt.length} vs expected: ${de.length}.\nActual:   ${Kt}.\nExpected: ${de}.`);for(let Ee=0;Ee<de.length;++Ee){const Te=Kt[Ee],xe=de[Ee];if(!_t(Te,xe))throw new Error(`Arrays differ: actual[${Ee}] = ${Te}, expected[${Ee}] = ${xe}.\nActual:   ${Kt}.\nExpected: ${de}.`)}typeof expect<"u"&&expect().nothing()}function Lu(gt,ct){gt().then(()=>ct.fail(),()=>ct()),typeof expect<"u"&&expect().nothing()}function Oc(gt,ct){const _t="string"==typeof ct||"number"==typeof ct||"boolean"==typeof ct?[ct]:ct;return(0,jt.HD)(gt)||(0,jt.HD)(gt[0])||(0,jt.HD)(ct)||(0,jt.HD)(ct[0])?vs(gt,_t,(Nt,Kt)=>Nt==Kt):vs(gt,ct,(Nt,Kt)=>Zr(Nt,Kt,0))}function as(gt,ct,_t){if(null==_t&&(_t=fo()),!Zr(gt,ct,_t))throw new Error(`Numbers differ: actual === ${gt}, expected === ${ct}`);typeof expect<"u"&&expect().nothing()}function Zr(gt,ct,_t){return!isFinite(gt)&&!isFinite(ct)||!(isNaN(gt)||isNaN(ct)||Math.abs(gt-ct)>_t)}function eu(gt,ct,_t){for(let Nt=0;Nt<gt.length;Nt++)if(gt[Nt]<ct||gt[Nt]>_t)throw new Error(`Value out of range:${gt[Nt]} low: ${ct}, high: ${_t}`)}function In(gt,ct){const _t=new Float32Array(gt),Nt=new Float32Array(ct);if(_t.length!==Nt.length)throw new Error(`Expected ArrayBuffer to be of length ${Nt.length}, but it was ${_t.length}`);for(let Kt=0;Kt<Nt.length;Kt++)if(_t[Kt]!==Nt[Kt])throw new Error(`Expected ArrayBuffer value at ${Kt} to be ${Nt[Kt]} but got ${_t[Kt]} instead`)}function fu(gt){for(let ct=0;ct<gt.length;ct++){const _t=gt[ct];Array.isArray(_t)?fu(_t):gt[ct]=(0,tn.encodeString)(_t)}return gt}function $o(gt){const ct=document.createElement("video");return"playsInline"in ct&&(ct.playsInline=!0),ct.muted=!0,ct.loop=!0,ct.style.position="fixed",ct.style.left="0px",ct.style.top="0px",ct.preload="auto",ct.appendChild(gt),new Promise(_t=>{ct.addEventListener("loadeddata",Nt=>_t(ct)),ct.load()})}function Gl(gt){return Ir.apply(this,arguments)}function Ir(){return(Ir=(0,lt.Z)(function*(gt){yield gt.play(),"requestVideoFrameCallback"in gt&&(yield new Promise(ct=>{gt.requestVideoFrameCallback(ct)}))})).apply(this,arguments)}const pu="4.17.0";class Hr{static sgd(ct){return new eo(ct)}static momentum(ct,_t,Nt=!1){return new Co(ct,_t,Nt)}static rmsprop(ct,_t=.9,Nt=0,Kt=null,de=!1){return new gs(ct,_t,Nt,Kt,de)}static adam(ct=.001,_t=.9,Nt=.999,Kt=null){return new Ls(ct,_t,Nt,Kt)}static adadelta(ct=.001,_t=.95,Nt=null){return new Ks(ct,_t,Nt)}static adamax(ct=.002,_t=.9,Nt=.999,Kt=null,de=0){return new Pa(ct,_t,Nt,Kt,de)}static adagrad(ct,_t=.1){return new ti(ct,_t)}}var Qu=y(1216),he=y(3667),Bo=y(4839);const Hl=Hr,ku=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:gt=>gt();function Br(){return new Promise(gt=>ku(()=>gt()))}var es=y(929);function nu(gt,ct){const _t=gt[0].length;gt.forEach((Kt,de)=>{jt.hu(Kt.length===_t,()=>`Error in concat${_t}D: rank of tensors[${de}] must be the same as the rank of the rest (${_t})`)}),jt.hu(ct>=0&&ct<_t,()=>`Error in concat${_t}D: axis must be between 0 and ${_t-1}.`);const Nt=gt[0];gt.forEach((Kt,de)=>{for(let Ee=0;Ee<_t;Ee++)jt.hu(Ee===ct||Kt[Ee]===Nt[Ee],()=>`Error in concat${_t}D: Shape of tensors[${de}] (${Kt}) does not match the shape of the rest (${Nt}) along the non-concatenated axis ${de}.`)})}function ru(gt,ct){const _t=gt[0].slice();for(let Nt=1;Nt<gt.length;Nt++)_t[ct]+=gt[Nt][ct];return _t}var us=y(5551),Fs=y(6254),ya=function(gt){return gt[gt.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",gt[gt.VALUE_ROWIDS=1]="VALUE_ROWIDS",gt[gt.ROW_LENGTHS=2]="ROW_LENGTHS",gt[gt.ROW_SPLITS=3]="ROW_SPLITS",gt[gt.ROW_LIMITS=4]="ROW_LIMITS",gt[gt.ROW_STARTS=5]="ROW_STARTS",gt}(ya||{});function zo(gt,ct,_t){let Nt=new Array;if(null==_t&&null==ct)return Nt;if(null==ct)for(;Nt.length<gt+_t.length;)Nt.push(-1);else Nt=ct.slice();if(null==_t)return Nt;if(gt+_t.length!==Nt.length)throw new Error(`rt input.shape and shape=${ct} are incompatible: rt input.rank = ${gt+_t.length}, but shape.rank = ${Nt.length}`);for(let Kt=1;Kt<_t.length;++Kt){const de=_t[Kt],Ee=Nt[Nt.length-_t.length+Kt],Te=Nt[Ee];if(de>=0)if(Te>=0){if(Te!==de)throw new Error(`rt input.shape and shape=${ct} are incompatible: rt input.shape[${Kt+gt}] = ${de} but shape[${Kt+gt}] = ${Te}`)}else Nt[Ee]=de}return Nt}function va(gt){const ct={FIRST_DIM_SIZE:ya.FIRST_DIM_SIZE,VALUE_ROWIDS:ya.VALUE_ROWIDS,ROW_LENGTHS:ya.ROW_LENGTHS,ROW_SPLITS:ya.ROW_SPLITS,ROW_LIMITS:ya.ROW_LIMITS,ROW_STARTS:ya.ROW_STARTS},_t=[];for(const Nt of gt){if(!(Nt in ct))break;_t.push(ct[Nt])}return _t}function po(gt){return 0===gt.length?0:gt[0]===ya.FIRST_DIM_SIZE?gt.length-1:gt.length}function qo(gt,ct){if(null==gt||null==ct)return;const _t=gt.length,Nt=ct.length;if(_t>=Nt)throw new Error(`defaultValue.shape=${gt} and ragged tensor flatValues.shape=${ct}, are incompatible: defaultValue.rank = ${_t} must be less than ragged tensor input flatValues.rank = ${Nt})`);for(let Kt=0;Kt<Math.min(_t,Nt-1);++Kt){const de=gt[Kt],Ee=ct[Kt+1];if(de>=0&&Ee>=0&&1!==de&&de!==Ee)throw new Error(`defaultValue.shape=${gt}, and ragged tensor input flatValues.shape=${ct} are incompatible: defaultValue.shape[${Kt-gt.length}] = ${de} but ragged tensor input.flatValues.shape[${Kt-gt.length}] = ${Ee}`)}}const Hn=30;function Ao(gt){return gt<=Hn?gt:(0,jt.jP)(gt,Math.floor(Math.sqrt(gt)))}function Mn(gt,ct,_t){return[_t*("number"==typeof gt?gt:gt[0]),ct*("number"==typeof gt?gt:gt[1])]}function ua(gt,ct,_t,Nt=!0){let Kt=[];if(Nt)Kt=Kt.concat(ct.slice(0)),Kt.push(gt[0]/_t),Kt=Kt.concat(gt.slice(1));else{Kt=Kt.concat(gt[0]);const de=ct.length;for(let Ee=0;Ee<de;++Ee)Kt=Kt.concat([gt[Ee+1]/ct[Ee],ct[Ee]]);Kt=Kt.concat(gt.slice(de+1))}return Kt}function _a(gt,ct,_t=!0){const Nt=[];if(_t){Nt.push(ct);for(let Kt=ct+1;Kt<gt;++Kt)Kt<=2*ct?(Nt.push(Kt),Nt.push(Kt-(ct+1))):Nt.push(Kt)}else{const Kt=[],de=[];for(let Ee=1;Ee<gt;++Ee)Ee>=2*ct+1||Ee%2==1?de.push(Ee):Kt.push(Ee);Nt.push(...Kt),Nt.push(0),Nt.push(...de)}return Nt}function ls(gt,ct,_t,Nt=!0){const Kt=[];Kt.push(Nt?gt[0]/_t:gt[0]*_t);for(let de=1;de<gt.length;++de)Kt.push(de<=ct.length?Nt?ct[de-1]*gt[de]:gt[de]/ct[de-1]:gt[de]);return Kt}function mo(gt,ct){const _t=[0];for(let Nt=0;Nt<ct;++Nt)_t.push(gt[Nt][0]);return _t}function iu(gt,ct,_t){const Nt=gt.slice(0,1);for(let Kt=0;Kt<_t;++Kt)Nt.push(gt[Kt+1]-ct[Kt][0]-ct[Kt][1]);return Nt}var Ys=y(2152);const $s=.3275911,Vo=.254829592,xa=-.284496736,mi=1.421413741,yi=-1.453152027,La=1.061405429;var Su=y(2932);function Ga(gt,ct){if(gt.length!==ct.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${gt.length}, imag: ${ct.length}.`);const _t=new Float32Array(2*gt.length);for(let Nt=0;Nt<_t.length;Nt+=2)_t[Nt]=gt[Nt/2],_t[Nt+1]=ct[Nt/2];return _t}function pl(gt){const ct=new Float32Array(gt.length/2),_t=new Float32Array(gt.length/2);for(let Nt=0;Nt<gt.length;Nt+=2)ct[Nt/2]=gt[Nt],_t[Nt/2]=gt[Nt+1];return{real:ct,imag:_t}}function Jo(gt){const ct=Math.ceil(gt.length/4),_t=new Float32Array(ct),Nt=new Float32Array(ct);for(let Kt=0;Kt<gt.length;Kt+=4)_t[Math.floor(Kt/4)]=gt[Kt],Nt[Math.floor(Kt/4)]=gt[Kt+1];return{real:_t,imag:Nt}}function Uo(gt){const ct=Math.floor(gt.length/4),_t=new Float32Array(ct),Nt=new Float32Array(ct);for(let Kt=2;Kt<gt.length;Kt+=4)_t[Math.floor(Kt/4)]=gt[Kt],Nt[Math.floor(Kt/4)]=gt[Kt+1];return{real:_t,imag:Nt}}function Ts(gt,ct){return{real:gt[2*ct],imag:gt[2*ct+1]}}function Du(gt,ct,_t,Nt){gt[2*Nt]=ct,gt[2*Nt+1]=_t}function Bs(gt,ct){const _t=new Float32Array(gt/2),Nt=new Float32Array(gt/2);for(let Kt=0;Kt<Math.ceil(gt/2);Kt++){const de=(ct?2:-2)*Math.PI*(Kt/gt);_t[Kt]=Math.cos(de),Nt[Kt]=Math.sin(de)}return{real:_t,imag:Nt}}function Wo(gt,ct,_t){const Nt=(_t?2:-2)*Math.PI*(gt/ct);return{real:Math.cos(Nt),imag:Math.sin(Nt)}}const Ea="->",Tu=/->/g,mu=",",Ha="...";function Ca(gt,ct){const _t=((gt=gt.replace(/\s/g,"")).length-gt.replace(Tu,"").length)/Ea.length;if(_t<1)throw new Error("Equations without an arrow are not supported.");if(_t>1)throw new Error(`Equation must contain exactly one arrow ("${Ea}").`);const[Nt,Kt]=gt.split(Ea);(0,jt.hu)(-1===Nt.indexOf(Ha),()=>`The ellipsis notation ("${Ha}") is not supported yet.`);const de=Nt.split(mu),Ee=de.length;if(ct!==Ee)throw new Error(`Expected ${Ee} input tensors, received ${ct}`);if(Ee>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const Te=[];for(let E=0;E<Kt.length;++E){const D=Kt[E];if(!de.some(j=>-1!==j.indexOf(D)))throw new Error(`Output subscripts contain the label ${D} not present in the input subscripts.`);-1===Te.indexOf(D)&&Te.push(D)}for(let E=0;E<Nt.length;++E){const D=Nt[E];-1===Te.indexOf(D)&&D!==mu&&Te.push(D)}const xe=new Array(de.length);for(let E=0;E<Ee;++E){if(new Set(de[E].split("")).size!==de[E].length)throw new Error(`Found duplicate axes in input component ${de[E]}. Support for duplicate axes in input is not implemented yet.`);xe[E]=[];for(let D=0;D<de[E].length;++D)xe[E].push(Te.indexOf(de[E][D]))}const Pe=Te.length,f=[];for(let E=Kt.length;E<Pe;++E)f.push(E);return{allDims:Te,summedDims:f,idDims:xe}}function Qs(gt,ct){let _t=new Array(gt);_t.fill(-1);for(let Kt=0;Kt<ct.length;++Kt)_t[ct[Kt]]=Kt;const Nt=[];for(let Kt=0;Kt<gt;++Kt)-1===_t[Kt]&&Nt.push(Kt);return _t=_t.filter(Kt=>-1!==Kt),{permutationIndices:_t,expandDims:Nt}}function ta(gt,ct,_t){const Nt=new Array(gt);for(let Kt=0;Kt<_t.length;++Kt){const de=_t[Kt].shape;for(let Ee=0;Ee<ct[Kt].length;++Ee)void 0===Nt[ct[Kt][Ee]]?Nt[ct[Kt][Ee]]=de[Ee]:(0,jt.hu)(Nt[ct[Kt][Ee]]===de[Ee],()=>`Expected dimension ${Nt[ct[Kt][Ee]]} at axis ${Ee} of input shaped ${JSON.stringify(de)}, but got dimension ${de[Ee]}`)}}function go(gt,ct){const _t=gt,Nt=[];let Kt=0;0===gt.length&&_t.push(-1),Kt=gt.length+1;for(let Ee=0;Ee<Kt;++Ee)Nt.push([]);const de=[];for(let Ee=0;Ee<_t.length;++Ee){const xe=gu(ct,_t[Ee]);for(const Pe of xe)-1===de.indexOf(Pe)&&(Nt[Ee].push(Pe),de.push(Pe))}return{path:_t,steps:Nt}}function ka(gt){return gt.every((ct,_t)=>ct===_t)}function gu(gt,ct){const _t=[];for(let Nt=0;Nt<gt.length;++Nt)(0===gt[Nt].length||-1!==gt[Nt].indexOf(ct)||-1===ct)&&_t.push(Nt);return _t}function Io(gt,ct,_t=0){let Nt=[];if("number"==typeof ct)(0,jt.hu)(gt.shape[_t]%ct==0,()=>"Number of splits must evenly divide the axis."),Nt=new Array(ct).fill(gt.shape[_t]/ct);else{const Kt=ct.reduce((Ee,Te)=>(-1===Te&&(Ee+=1),Ee),0);(0,jt.hu)(Kt<=1,()=>"There should be only one negative value in split array.");const de=ct.indexOf(-1);if(-1!==de){const Ee=ct.reduce((Te,xe)=>xe>0?Te+xe:Te);ct[de]=gt.shape[_t]-Ee}(0,jt.hu)(gt.shape[_t]===ct.reduce((Ee,Te)=>Ee+Te),()=>"The sum of sizes must match the size of the axis dimension."),Nt=ct}return Nt}function cs(gt){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${gt}`}function So(gt,ct){return`indices(${gt}, 0) is invalid: ${ct} < 0`}function la(gt,ct,_t){return`indices(${gt}, 0) is invalid: ${ct} >= ${_t}`}function ns(gt,ct){return`only one output dimension may be -1, not both ${gt} and ${ct}`}function wl(gt,ct){return`size ${gt} must be non-negative, not ${ct}`}function Nu(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Go(gt,ct){return`Input to reshape is a SparseTensor with ${(0,jt.NA)(gt)}\n  dense values, but the requested shape requires a multiple of ${(0,jt.NA)(ct)}. inputShape=${gt} outputShape= ${ct}`}function hs(gt,ct){return`Input to reshape is a tensor with ${(0,jt.NA)(gt)} dense values, but the requested shape has ${(0,jt.NA)(ct)}. inputShape=${gt} outputShape=${ct}`}function ca(){return"segment ids must be >= 0"}function no(){return"segment ids are not increasing"}function jl(gt,ct){return`Segment id ${gt} out of range [0, ${ct}), possibly because segmentIds input is not sorted.`}function ja(gt,ct,_t){return`Bad: indices[${gt}] == ${ct} out of range [0, ${_t})`}function Yr(gt,ct){let Nt,_t=!1;for(gt<=Hn?(Nt=gt,_t=!0):Nt=(0,jt.jP)(gt,Math.floor(Math.sqrt(gt)));!_t;)Nt>ct||Nt===gt?_t=!0:Nt=(0,jt.jP)(gt,Nt+1);return Nt}function ha(gt,ct,_t){const Nt=[],Kt=gt.length;for(let de=0;de<Kt;de++)Nt.push(de!==ct?gt[de]:_t);return Nt}function yu(gt,ct,_t,Nt){const Kt=ct.shape.length,de=gt.shape.length;if(0!==Nt&&(Nt<-Kt||Nt>Kt))throw new Error(`Expect batchDims in the range of [-${Kt}, ${Kt}], but got ${Nt}`);if(Nt<0&&(Nt+=Kt),Nt>de)throw new Error(`batchDims (${Nt}) must be less than rank(x) (\n    ${de}).`);if(_t<Nt)throw new Error(`batchDims (${Nt}) must be less than or equal to axis (${_t}).`);for(let f=0;f<Nt;++f)if(gt.shape[f]!==ct.shape[f])throw new Error(`x.shape[${f}]: ${gt.shape[f]} should be equal to indices.shape[${f}]: ${ct.shape[f]}.`);const Ee=gt.shape[_t],Te=[];let xe=1,Pe=1,fn=1;for(let f=0;f<Nt;++f)Te.push(gt.shape[f]),xe*=gt.shape[f];for(let f=Nt;f<_t;f++)Te.push(gt.shape[f]),Pe*=gt.shape[f];for(let f=Nt;f<Kt;f++)Te.push(ct.shape[f]);for(let f=_t+1;f<de;f++)Te.push(gt.shape[f]),fn*=gt.shape[f];return{batchSize:xe,sliceSize:fn,outerSize:Pe,dimSize:Ee,outputShape:Te}}function or(gt){try{return gt.map(ct=>(0,tn.decodeString)(ct))}catch(ct){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${ct}`)}}function bs(gt){return gt.map(ct=>(0,tn.encodeString)(ct))}var Tr=y(5672),ri=y(7349),ds=y(7173);!function bu(){for(const gt of Ua)js(gt)}()},7864:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>V});var $=y(1153);class V{static join(Y){return new V(Y).slice()}constructor(Y){if(this.shards=[],this.previousShardIndex=0,null==Y||(Y instanceof Array||(Y=[Y]),0===(Y=Y.map(W=>$.isTypedArray(W)?W.buffer:W)).length))return;this.bufferUniformSize=Y[0].byteLength;let R=0;for(let W=0;W<Y.length;W++){const k=Y[W];W!==Y.length-1&&k.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const A=R+k.byteLength;this.shards.push({buffer:k,start:R,end:A}),R=A}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(Y=0,R=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(Y=isNaN(Number(Y))?0:Y,R=isNaN(Number(R))?0:R,Y=Math.max(0,Y),(R=Math.min(this.byteLength,R))<=Y)return new ArrayBuffer(0);const W=this.findShardForByte(Y);if(-1===W)throw new Error(`Could not find start shard for byte ${Y}`);const A=new ArrayBuffer(R-Y),X=new Uint8Array(A);let Z=0;for(let G=W;G<this.shards.length;G++){const it=this.shards[G],K=Y+Z-it.start,st=Z,dt=Math.min(R,it.end)-it.start,lt=new Uint8Array(it.buffer,K,dt-K);if(X.set(lt,st),Z+=lt.length,R<it.end)break}return A}findShardForByte(Y){if(0===this.shards.length||Y<0||Y>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(Y/this.bufferUniformSize),this.previousShardIndex;function R(k){return Y<k.start?-1:Y>=k.end?1:0}if(0===R(this.shards[this.previousShardIndex]))return this.previousShardIndex;const W=function H(Q,Y){let R=0,W=Q.length;for(;R<=W;){const k=Math.floor((W-R)/2)+R,A=Y(Q[k]);if(0===A)return k;A<0?W=k:R=k+1}return-1}(this.shards,R);return-1===W?-1:(this.previousShardIndex=W,this.previousShardIndex)}}},8339:(Lt,ut,y)=>{"use strict";y.d(ut,{EZ:()=>at,JY:()=>P,Q:()=>yt,Yd:()=>nt,_n:()=>B,dI:()=>G,hu:()=>vt,jN:()=>O,ji:()=>Gt,n7:()=>ot,r:()=>lt,yz:()=>X});var $=y(5861),V=y(3037),H=y(3905),Q=y(5359),Y=y(1352),R=y(7864),W=y(2773),k=y(5527);const A=4;function X(Bt,ee){return Z.apply(this,arguments)}function Z(){return Z=(0,$.Z)(function*(Bt,ee){const jt=[],se=[],we=Array.isArray(Bt)?Bt.map(Xe=>Xe.name):Object.keys(Bt);for(let Xe=0;Xe<we.length;++Xe){const Ue=we[Xe],De=Array.isArray(Bt)?Bt[Xe].tensor:Bt[Ue];if("float32"!==De.dtype&&"int32"!==De.dtype&&"bool"!==De.dtype&&"string"!==De.dtype&&"complex64"!==De.dtype)throw new Error(`Unsupported dtype in weight '${Ue}': ${De.dtype}`);const Tn={name:Ue,shape:De.shape,dtype:De.dtype};if("string"===De.dtype){const On=new Promise(function(){var ne=(0,$.Z)(function*(pe){const Ie=yield De.bytes(),Je=Ie.reduce((Nn,Yn)=>Nn+Yn.length,0)+A*Ie.length,Wn=new Uint8Array(Je);let Er=0;for(let Nn=0;Nn<Ie.length;Nn++){const Yn=Ie[Nn],hi=new Uint8Array(new Uint32Array([Yn.length]).buffer);Wn.set(hi,Er),Er+=A,Wn.set(Yn,Er),Er+=Yn.length}pe(Wn)});return function(pe){return ne.apply(this,arguments)}}());se.push(On)}else se.push(De.data());null!=ee&&(Tn.group=ee),jt.push(Tn)}return{data:q(yield Promise.all(se)),specs:jt}}),Z.apply(this,arguments)}function G(Bt,ee){const jt=new R.w(Bt),se={};let we=0;for(const Me of ee){const Xe=it(Me,(Ue,De)=>jt.slice(we+Ue,we+De));se[Me.name]=st(Me,jt.slice(we,we+Xe)),we+=Xe}return se}function it(Bt,ee){const jt=(0,Q.NA)(Bt.shape);let se;if("quantization"in Bt)se=Y.J[Bt.quantization.dtype];else{if("string"===Bt.dtype){let we=0;for(let Me=0;Me<jt;Me++)we+=A+new Uint32Array(ee(we,we+A))[0];return we}se=Y.J[Bt.dtype]}return jt*se}function wt(Bt,ee){return K.apply(this,arguments)}function K(){return(K=(0,$.Z)(function*(Bt,ee){const jt=(0,Q.NA)(Bt.shape);let se;if("quantization"in Bt)se=Y.J[Bt.quantization.dtype];else{if("string"===Bt.dtype){let we=0;for(let Me=0;Me<jt;Me++)we+=A+new Uint32Array(yield ee(we,we+A))[0];return we}se=Y.J[Bt.dtype]}return jt*se})).apply(this,arguments)}function st(Bt,ee){const jt=Bt.name,se=Bt.dtype,we=Bt.shape,Me=(0,Q.NA)(we);let Xe,Ue=0;if("quantization"in Bt){const De=Bt.quantization;if("uint8"===De.dtype||"uint16"===De.dtype){if(!("min"in De)||!("scale"in De))throw new Error(`Weight ${Bt.name} with quantization ${De.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==De.dtype)throw new Error(`Weight ${Bt.name} has unknown quantization dtype ${De.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==se)throw new Error(`Weight ${Bt.name} is quantized with ${De.dtype} which only supports weights of type float32 not ${se}.`)}const Tn=Y.J[De.dtype],On="uint8"===De.dtype?new Uint8Array(ee):new Uint16Array(ee);if("float32"===se)if("uint8"===De.dtype||"uint16"===De.dtype){Xe=new Float32Array(On.length);for(let ne=0;ne<On.length;ne++)Xe[ne]=On[ne]*De.scale+De.min}else{if("float16"!==De.dtype)throw new Error(`Unsupported quantization type ${De.dtype} for weight type float32.`);Xe=function re(){const Bt=function xt(){const Bt=jt=>{let se=jt<<13,we=0;for(;!(8388608&se);)we-=8388608,se<<=1;return se&=-8388609,we+=947912704,se|we},ee=new Uint32Array(2048);ee[0]=0;for(let jt=1;jt<1024;jt++)ee[jt]=Bt(jt);for(let jt=1024;jt<2048;jt++)ee[jt]=939524096+(jt-1024<<13);return ee}(),ee=function Mt(){const Bt=new Uint32Array(64);Bt[0]=0,Bt[31]=1199570944,Bt[32]=2147483648,Bt[63]=3347054592;for(let ee=1;ee<31;ee++)Bt[ee]=ee<<23;for(let ee=33;ee<63;ee++)Bt[ee]=2147483648+(ee-32<<23);return Bt}(),jt=function It(){const Bt=new Uint32Array(64);for(let ee=0;ee<64;ee++)Bt[ee]=1024;return Bt[0]=Bt[32]=0,Bt}();return se=>{const we=new ArrayBuffer(4*se.length),Me=new Uint32Array(we);for(let Xe=0;Xe<se.length;Xe++){const Ue=se[Xe];Me[Xe]=Bt[jt[Ue>>10]+(1023&Ue)]+ee[Ue>>10]}return new Float32Array(we)}}()(On)}else{if("int32"!==se)throw new Error(`Unsupported dtype in weight '${jt}': ${se}`);if("uint8"!==De.dtype&&"uint16"!==De.dtype)throw new Error(`Unsupported quantization type ${De.dtype} for weight type int32.`);Xe=new Int32Array(On.length);for(let ne=0;ne<On.length;ne++)Xe[ne]=Math.round(On[ne]*De.scale+De.min)}Ue+=Me*Tn}else if("string"===se){const De=(0,Q.NA)(Bt.shape);Xe=[];for(let Tn=0;Tn<De;Tn++){const On=new Uint32Array(ee.slice(Ue,Ue+A))[0];Ue+=A;const ne=new Uint8Array(ee.slice(Ue,Ue+On));Xe.push(ne),Ue+=On}}else{const De=Y.J[se];if("float32"===se)Xe=new Float32Array(ee);else if("int32"===se)Xe=new Int32Array(ee);else{if("bool"!==se){if("complex64"===se){Xe=new Float32Array(ee);const Tn=new Float32Array(Xe.length/2),On=new Float32Array(Xe.length/2);for(let Je=0;Je<Tn.length;Je++)Tn[Je]=Xe[2*Je],On[Je]=Xe[2*Je+1];const ne=(0,H.X)(Tn,we,"float32"),pe=(0,H.X)(On,we,"float32"),Ie=(0,V.P)(ne,pe);return ne.dispose(),pe.dispose(),Ie}throw new Error(`Unsupported dtype in weight '${jt}': ${se}`)}Xe=new Uint8Array(ee)}Ue+=Me*De}return(0,H.X)(Xe,we,se)}function et(Bt,ee,jt){return dt.apply(this,arguments)}function dt(){return(dt=(0,$.Z)(function*(Bt,ee,jt){let se=new Uint8Array(ee);for(;se.byteLength<jt;){const{done:we,value:Me}=yield Bt.read();if(we&&null==Me)throw new Error(`Reader is done but ${jt-se.byteLength} bytes are still expected`);const Xe=new Uint8Array(se.length+Me.byteLength);Xe.set(se,0),Xe.set(new Uint8Array(Me),se.length),se=Xe}return se.buffer})).apply(this,arguments)}function lt(Bt,ee){return St.apply(this,arguments)}function St(){return St=(0,$.Z)(function*(Bt,ee){const jt={},se=Bt.getReader();let we=new ArrayBuffer(0);for(const Me of ee){const Xe=yield wt(Me,function(){var Tn=(0,$.Z)(function*(On,ne){return we=yield et(se,we,ne),we.slice(On,ne)});return function(On,ne){return Tn.apply(this,arguments)}}());we=yield et(se,we,Xe);const Ue=we.slice(0,Xe);we=we.slice(Xe);const De=st(Me,Ue);if(jt[Me.name]=De,"webgpu"===(0,W.N_)()){const Tn=(0,W.y3)();"uploadToGPU"in Tn&&(0,Q.NA)(De.shape)>=(0,k.OB)().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&Tn.uploadToGPU(De.dataId)}}return jt}),St.apply(this,arguments)}function q(Bt){if(null===Bt)throw new Error(`Invalid input value: ${JSON.stringify(Bt)}`);let ee=0;const jt=[];Bt.forEach(Me=>{if(ee+=Me.byteLength,jt.push(Me.byteLength===Me.buffer.byteLength?Me:new Me.constructor(Me)),!(Me instanceof Float32Array||Me instanceof Int32Array||Me instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${Me.constructor.name}`)});const se=new Uint8Array(ee);let we=0;return jt.forEach(Me=>{se.set(new Uint8Array(Me.buffer),we),we+=Me.byteLength}),se.buffer}const ft=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function pt(Bt){return ft?Buffer.byteLength(Bt,"utf8"):new Blob([Bt]).size}function B(Bt){if(ft)return Buffer.from(Bt).toString("base64");const ee=new Uint8Array(Bt);let jt="";for(let se=0,we=ee.length;se<we;se++)jt+=String.fromCharCode(ee[se]);return btoa(jt)}function ot(Bt){if(ft){const se=Buffer.from(Bt,"base64");return se.buffer.slice(se.byteOffset,se.byteOffset+se.byteLength)}const ee=atob(Bt),jt=new Uint8Array(ee.length);for(let se=0;se<ee.length;++se)jt.set([ee.charCodeAt(se)],se);return jt.buffer}function P(Bt){return R.w.join(Bt)}function at(Bt){for(Bt=Bt.trim();Bt.endsWith("/");)Bt=Bt.slice(0,Bt.length-1);const jt=Bt.split("/");return jt[jt.length-1]}function nt(Bt,ee){const jt={modelTopology:Bt.modelTopology,format:Bt.format,generatedBy:Bt.generatedBy,convertedBy:Bt.convertedBy,weightsManifest:ee};return null!=Bt.signature&&(jt.signature=Bt.signature),null!=Bt.userDefinedMetadata&&(jt.userDefinedMetadata=Bt.userDefinedMetadata),null!=Bt.modelInitializer&&(jt.modelInitializer=Bt.modelInitializer),null!=Bt.initializerSignature&&(jt.initializerSignature=Bt.initializerSignature),null!=Bt.trainingConfig&&(jt.trainingConfig=Bt.trainingConfig),jt}function Gt(Bt,ee,jt){const se={modelTopology:Bt.modelTopology,format:Bt.format,generatedBy:Bt.generatedBy,convertedBy:Bt.convertedBy};if(null!=Bt.trainingConfig&&(se.trainingConfig=Bt.trainingConfig),null!=Bt.weightsManifest){if(!ee)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!jt)throw new Error("modelJSON has weightsManifest but weightData is null");se.weightSpecs=ee,se.weightData=jt}return null!=Bt.signature&&(se.signature=Bt.signature),null!=Bt.userDefinedMetadata&&(se.userDefinedMetadata=Bt.userDefinedMetadata),null!=Bt.modelInitializer&&(se.modelInitializer=Bt.modelInitializer),null!=Bt.initializerSignature&&(se.initializerSignature=Bt.initializerSignature),se}function O(Bt,ee){return Ct.apply(this,arguments)}function Ct(){return(Ct=(0,$.Z)(function*(Bt,ee){let jt,se;return null!=Bt.weightsManifest&&([jt,se]=yield ee(Bt.weightsManifest)),Gt(Bt,jt,se)})).apply(this,arguments)}function yt(Bt){if(Bt.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==Bt.modelTopology?0:pt(JSON.stringify(Bt.modelTopology)),weightSpecsBytes:null==Bt.weightSpecs?0:pt(JSON.stringify(Bt.weightSpecs)),weightDataBytes:null==Bt.weightData?0:new R.w(Bt.weightData).byteLength}}function vt(Bt){const ee=[];for(const jt of Bt)ee.push(...jt.weights);return ee}},1352:(Lt,ut,y)=>{"use strict";y.d(ut,{J:()=>$});const $={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},4251:(Lt,ut,y)=>{"use strict";y.d(ut,{$HU:()=>ma,$g6:()=>Wn,$w:()=>Tn,Acj:()=>oe,BMI:()=>Zi,BiW:()=>An,Byc:()=>ee,CAk:()=>mn,CQl:()=>ys,D2d:()=>z,DlI:()=>Xs,Eh3:()=>O,FKq:()=>wr,G3Y:()=>Vn,GBy:()=>Wr,Gcp:()=>wu,HEU:()=>Nn,HZH:()=>bo,Hhh:()=>si,Hmb:()=>ga,IKK:()=>W,IMb:()=>dt,J$2:()=>ue,J7O:()=>kr,J_u:()=>Oe,JhU:()=>K,Kgp:()=>$r,L8s:()=>ss,Ly9:()=>pt,M2y:()=>X,MIZ:()=>Ye,MRv:()=>Pr,MZg:()=>sr,NEP:()=>di,NZg:()=>Eo,O3z:()=>Fo,OAf:()=>zr,OR:()=>Gn,OU7:()=>js,OV7:()=>oi,Omj:()=>Yn,Oyi:()=>it,PYm:()=>zn,PhF:()=>ks,QCc:()=>wt,QRR:()=>we,Qg5:()=>ze,QiL:()=>bu,Qvg:()=>_r,RFZ:()=>ot,ROF:()=>st,RQH:()=>Kr,RuY:()=>Zs,SIB:()=>Ss,SX0:()=>Er,SYM:()=>$,SbG:()=>Yi,SpW:()=>H,T0n:()=>Me,TQc:()=>Ds,TR1:()=>Bt,ToN:()=>bn,Tr8:()=>ae,Uyb:()=>xo,VGw:()=>V,Vbg:()=>Vr,VcC:()=>se,VfG:()=>_n,Vn9:()=>pe,W0H:()=>Co,XDQ:()=>ni,XLW:()=>lt,XkS:()=>kt,Xze:()=>Y,Y0y:()=>ii,YFo:()=>to,YoZ:()=>tr,ZbH:()=>ir,ZjV:()=>_e,Zz9:()=>nt,_JP:()=>At,_V0:()=>Qi,_Yw:()=>Xn,_k9:()=>et,_tC:()=>I,a5O:()=>Kn,aJk:()=>A,avt:()=>je,b9H:()=>Iu,bK0:()=>M,bV0:()=>ei,c17:()=>Ks,cWu:()=>Cn,cie:()=>Xe,cye:()=>eo,dDz:()=>Wa,deh:()=>Qo,dpD:()=>Yu,e07:()=>an,e0R:()=>tt,e6w:()=>Gr,e7N:()=>un,eBW:()=>tn,eEB:()=>B,eZ0:()=>Dn,ekb:()=>ne,gJX:()=>P,h8e:()=>Xr,hCO:()=>ft,hGc:()=>Ie,hdR:()=>hi,i5y:()=>ai,iHb:()=>jt,iJz:()=>ie,iWB:()=>Xt,iZT:()=>te,ik2:()=>It,jMg:()=>G,jQk:()=>bt,jQs:()=>ti,jeX:()=>Hs,kU:()=>dr,kpP:()=>vr,kuV:()=>Ma,luS:()=>fo,lyA:()=>Oa,mKl:()=>Ra,mTV:()=>fi,mc4:()=>re,mhS:()=>Ct,mm_:()=>Q,n9L:()=>$e,nhH:()=>Or,nr8:()=>wo,o0g:()=>du,o2y:()=>Mt,oFR:()=>Ur,oHH:()=>Je,oT6:()=>R,p2w:()=>We,p4S:()=>On,pe_:()=>pr,q1x:()=>Rt,q2K:()=>Es,q8u:()=>Rs,qCd:()=>qn,qIC:()=>br,qWM:()=>gs,qi_:()=>Et,qkr:()=>er,qw7:()=>Z,r7n:()=>En,s1s:()=>Yt,sEM:()=>nn,sHE:()=>Ce,sJF:()=>k,sL$:()=>Ue,usg:()=>xr,uv1:()=>Pa,vFR:()=>ho,vtC:()=>en,vwp:()=>yn,w3H:()=>os,w6g:()=>Jr,wUP:()=>yt,wYB:()=>mr,wYn:()=>Ls,we_:()=>Ua,wm:()=>vt,wx7:()=>$n,x12:()=>xt,xJR:()=>Qn,xQA:()=>Fn,xnO:()=>at,y7R:()=>De,yQU:()=>rs,yj2:()=>Gt,zbQ:()=>Cs,zvY:()=>q,zws:()=>St});const $="Abs",V="Acos",H="Acosh",Q="Add",Y="AddN",R="All",W="Any",k="ArgMax",A="ArgMin",X="Asin",Z="Asinh",G="Atan",it="Atanh",wt="Atan2",K="AvgPool",st="AvgPoolGrad",et="AvgPool3D",dt="AvgPool3DGrad",lt="BatchMatMul",St="BatchToSpaceND",q="Bincount",ft="BitwiseAnd",pt="BroadcastTo",B="BroadcastArgs",ot="Cast",P="Ceil",at="ClipByValue",nt="Complex",Gt="ComplexAbs",O="Concat",Ct="Conv2D",yt="Conv2DBackpropFilter",vt="Conv2DBackpropInput",xt="Conv3D",Mt="Conv3DBackpropFilterV2",It="Conv3DBackpropInputV2",re="Cos",Bt="Cosh",ee="Cumprod",jt="Cumsum",se="CropAndResize",we="DenseBincount",Me="DepthToSpace",Xe="DepthwiseConv2dNative",Ue="DepthwiseConv2dNativeBackpropFilter",De="DepthwiseConv2dNativeBackpropInput",Tn="Diag",On="Dilation2D",ne="Dilation2DBackpropInput",pe="Dilation2DBackpropFilter",Ie="Draw",Je="RealDiv",Wn="Einsum",Er="Elu",Nn="EluGrad",Yn="Erf",hi="Equal",di="Exp",to="ExpandDims",ii="Expm1",yn="FFT",Qo="Fill",xo="FlipLeftRight",Gn="Floor",Hs="FloorDiv",Ce="FusedBatchNorm",Et="GatherV2",Rt="GatherNd",te="Greater",oe="GreaterEqual",ie="Identity",ze="IFFT",Oe="Imag",je="IsFinite",Xt="IsInf",En="IsNan",ue="LeakyRelu",en="Less",mn="LessEqual",un="LinSpace",ir="Log",dr="Log1p",zn="LogicalAnd",_n="LogicalNot",sr="LogicalOr",Jr="LogicalXor",qn="LogSoftmax",br="LowerBound",Dn="LRN",si="LRNGrad",kr="MatrixBandPart",tr="Max",Zi="Maximum",fi="MaxPool",oi="MaxPoolGrad",zr="MaxPool3D",js="MaxPool3DGrad",ho="MaxPoolWithArgmax",Es="Mean",Ks="Min",Rs="Minimum",ti="MirrorPad",Vr="Mod",Eo="Multinomial",Ls="Multiply",Ma="Neg",rs="NotEqual",Pa="NonMaxSuppressionV3",eo="NonMaxSuppressionV4",Co="NonMaxSuppressionV5",gs="OnesLike",Ua="OneHot",bu="Pack",Oa="PadV2",$r="Pool",pr="Pow",du="Prelu",Xs="Prod",Wa="RaggedGather",ys="RaggedRange",An="RaggedTensorToTensor",Gr="Range",Qn="Real",ma="Reciprocal",er="Relu",bo="Reshape",Yu="ResizeNearestNeighbor",ga="ResizeNearestNeighborGrad",Xn="ResizeBilinear",Cs="ResizeBilinearGrad",Yi="Relu6",Ra="Reverse",an="Round",ei="Rsqrt",Fn="ScatterNd",Ss="TensorScatterUpdate",wo="SearchSorted",ks="Select",Ur="Selu",We="Slice",Kr="Sin",mr="Sinh",ai="Sign",Kn="Sigmoid",Pr="Softplus",wr="Sqrt",Wr="Sum",Ds="SpaceToBatchND",ss="SplitV",wu="Softmax",Fo="SparseFillEmptyRows",Or="SparseReshape",os="SparseSegmentMean",_e="SparseSegmentSum",z="SparseToDense",I="SquaredDifference",M="Square",tt="StaticRegexReplace",bt="StridedSlice",At="StringNGrams",Yt="StringSplit",kt="StringToHashBucketFast",ae="Sub",nn="Tan",Ye="Tanh",$e="Tile",Cn="TopK",$n="Transform",Vn="Transpose",vr="Unique",bn="Unpack",_r="UnsortedSegmentSum",ni="UpperBound",Zs="ZerosLike",Xr="Step",tn="FromPixels",Iu="RotateWithOffset",xr="_FusedMatMul",Qi="FusedConv2D",fo="FusedDepthwiseConv2D"},8987:(Lt,ut,y)=>{"use strict";y.d(ut,{Li:()=>X,T3:()=>it,bt:()=>G,nE:()=>Z,pI:()=>R,tr:()=>k,uk:()=>W,wC:()=>A});var $=y(5527),V=y(2918),H=y(2932);const Q=(0,V.R)("kernelRegistry",()=>new Map),Y=(0,V.R)("gradRegistry",()=>new Map);function R(K,st){const et=wt(K,st);return Q.get(et)}function W(K){return Y.get(K)}function k(K){const st=Q.entries(),et=[];for(;;){const{done:dt,value:lt}=st.next();if(dt)break;const[St,q]=lt,[ft]=St.split("_");ft===K&&et.push(q)}return et}function A(K){const{kernelName:st,backendName:et}=K,dt=wt(st,et);Q.has(dt)&&H.Z(`The kernel '${st}' for backend '${et}' is already registered`),Q.set(dt,K)}function X(K){const{kernelName:st}=K;Y.has(st)&&(0,$.OB)().getBool("DEBUG")&&H.Z(`Overriding the gradient for '${st}'`),Y.set(st,K)}function Z(K,st){const et=wt(K,st);if(!Q.has(et))throw new Error(`The kernel '${K}' for backend '${st}' is not registered`);Q.delete(et)}function G(K){if(!Y.has(K))throw new Error(`The gradient '${K}' for backend is not registered`);Y.delete(K)}function it(K,st){k(K).forEach(dt=>{A(Object.assign({},dt,{backendName:st}))})}function wt(K,st){return`${st}_${K}`}},2932:(Lt,ut,y)=>{"use strict";y.d(ut,{Z:()=>V,c:()=>H});var $=y(5527);function V(...Q){(0,$.OB)().getBool("IS_TEST")||(0,$.OB)().getBool("PROD")||console.warn(...Q)}function H(...Q){(0,$.OB)().getBool("IS_TEST")||(0,$.OB)().getBool("PROD")||console.log(...Q)}},6989:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({abs_:function Y(W){const k=(0,H._1)(W,"x","abs");return $.BV.runKernel("complex64"===k.dtype?V.yj2:V.SYM,{x:k})}})},1184:(Lt,ut,y)=>{"use strict";y.d(ut,{K:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({acos_:function Y(W){const A={x:(0,H._1)(W,"x","acos")};return $.BV.runKernel(V.VGw,A)}})},5622:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({acosh_:function Y(W){const A={x:(0,H._1)(W,"x","acosh")};return $.BV.runKernel(V.SpW,A)}})},7066:(Lt,ut,y)=>{"use strict";y.d(ut,{I:()=>W});var $=y(687),V=y(4251),H=y(7664),Q=y(1257);const W=(0,y(4195).op)({add_:function R(k,A){let X=(0,Q._1)(k,"a","add"),Z=(0,Q._1)(A,"b","add");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.mm_,{a:X,b:Z})}})},1862:(Lt,ut,y)=>{"use strict";y.d(ut,{$:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({all_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","all","bool")};return $.BV.runKernel(V.oT6,Z,{axis:k,keepDims:A})}})},876:(Lt,ut,y)=>{"use strict";y.d(ut,{Y:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({any_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","any","bool")};return $.BV.runKernel(V.IKK,Z,{axis:k,keepDims:A})}})},5784:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({argMax_:function Y(W,k=0){const X={x:(0,H._1)(W,"x","argMax")};return $.BV.runKernel(V.sJF,X,{axis:k})}})},8340:(Lt,ut,y)=>{"use strict";y.d(ut,{v:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({argMin_:function Y(W,k=0){const X={x:(0,H._1)(W,"x","argMin")};return $.BV.runKernel(V.aJk,X,{axis:k})}})},586:(Lt,ut,y)=>{"use strict";y.d(ut,{Z:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({asin_:function Y(W){const A={x:(0,H._1)(W,"x","asin")};return $.BV.runKernel(V.M2y,A)}})},8355:(Lt,ut,y)=>{"use strict";y.d(ut,{V:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({asinh_:function Y(W){const A={x:(0,H._1)(W,"x","asinh")};return $.BV.runKernel(V.qw7,A)}})},7881:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({atan_:function Y(W){const A={x:(0,H._1)(W,"x","atan")};return $.BV.runKernel(V.jMg,A)}})},5825:(Lt,ut,y)=>{"use strict";y.d(ut,{f:()=>W});var $=y(687),V=y(4251),H=y(7664),Q=y(1257);const W=(0,y(4195).op)({atan2_:function R(k,A){let X=(0,Q._1)(k,"a","atan2"),Z=(0,Q._1)(A,"b","atan2");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.QCc,{a:X,b:Z})}})},7932:(Lt,ut,y)=>{"use strict";y.d(ut,{C:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({atanh_:function Y(W){const A={x:(0,H._1)(W,"x","atanh")};return $.BV.runKernel(V.Oyi,A)}})},6903:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>X});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(3062),R=y(5551),W=y(4195),k=y(5715);const X=(0,W.op)({avgPool_:function A(Z,G,it,wt,K){const st=(0,H._1)(Z,"x","avgPool","float32");Q.hu(R.jT(it,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${it} and dilations '1'`);let dt=st,lt=!1;3===st.rank&&(lt=!0,dt=(0,k.X)(st,[1,st.shape[0],st.shape[1],st.shape[2]])),Q.hu(4===dt.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${dt.rank}.`),R.m("avgPool",wt,K);let ft=$.BV.runKernel(V.JhU,{x:dt},{filterSize:G,strides:it,pad:wt,dimRoundingMode:K});return ft=(0,Y.p)(ft,st.dtype),lt?(0,k.X)(ft,[ft.shape[1],ft.shape[2],ft.shape[3]]):ft}})},929:(Lt,ut,y)=>{"use strict";y.d(ut,{LJ:()=>k,Q3:()=>W,Vh:()=>H,YB:()=>V,kz:()=>Q,lB:()=>R,rv:()=>Y,sY:()=>A});var $=y(5359);function V(X,Z){for(let G=0;G<X.length;++G)if(X[X.length-G-1]!==Z-1-G)return!1;return!0}function H(X,Z,G){const it=X.length+Z.length,wt=[];let K=0,st=0;for(let et=0;et<it;et++)-1===G.indexOf(et)?wt.push(X[K++]):wt.push(Z[st++]);return wt}function Q(X,Z){const G=[],it=X.length;for(let K=0;K<it;K++)-1===Z.indexOf(K)&&G.push(X[K]);return[G,Z.map(K=>X[K])]}function Y(X,Z){return H(X,Z.map(it=>1),Z)}function R(X,Z,G){$.hu(V(Z,G),()=>`${X} supports only inner-most axes for now. Got axes ${Z} and rank-${G} input.`)}function W(X,Z){if(V(X,Z))return null;const G=[];for(let it=0;it<Z;++it)-1===X.indexOf(it)&&G.push(it);return X.forEach(it=>G.push(it)),G}function k(X){return X.map((Z,G)=>[G,Z]).sort((Z,G)=>Z[1]-G[1]).map(Z=>Z[0])}function A(X,Z){const G=[];for(let it=Z-X;it<Z;++it)G.push(it);return G}},2782:(Lt,ut,y)=>{"use strict";y.d(ut,{E:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({batchToSpaceND_:function R(k,A,X){const Z=(0,H._1)(k,"x","batchToSpaceND"),G=A.reduce((K,st)=>K*st);return Q.hu(Z.rank>=1+A.length,()=>`input rank is ${Z.rank} but should be > than blockShape.length ${A.length}`),Q.hu(X.length===A.length,()=>`crops.length is ${X.length} but should be equal to blockShape.length  ${A.length}`),Q.hu(Z.shape[0]%G==0,()=>`input tensor batch is ${Z.shape[0]} but is not divisible by the product of the elements of blockShape ${A.join(" * ")} === ${G}`),$.BV.runKernel(V.zws,{x:Z},{blockShape:A,crops:X})}})},5307:(Lt,ut,y)=>{"use strict";y.d(ut,{t:()=>A});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(5715);function R(X){let Z;return Z=0===X.rank||1===X.rank?(0,Y.X)(X,[1,1,1,X.size]):2===X.rank?(0,Y.X)(X,[1,1,X.shape[0],X.shape[1]]):3===X.rank?(0,Y.X)(X,[1,X.shape[0],X.shape[1],X.shape[2]]):X,Z}const A=(0,y(4195).op)({batchNorm_:function k(X,Z,G,it,wt,K){null==K&&(K=.001);const st=(0,H._1)(X,"x","batchNorm"),et=(0,H._1)(Z,"mean","batchNorm"),dt=(0,H._1)(G,"variance","batchNorm");let lt,St;null!=wt&&(lt=(0,H._1)(wt,"scale","batchNorm")),null!=it&&(St=(0,H._1)(it,"offset","batchNorm")),Q.hu(et.rank===dt.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Q.hu(null==St||et.rank===St.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Q.hu(null==lt||et.rank===lt.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const ft={x:R(st),scale:lt,offset:St,mean:et,variance:dt},B=$.BV.runKernel(V.sHE,ft,{varianceEpsilon:K});return(0,Y.X)(B,st.shape)}})},983:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>A});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(7315),R=y(4195),W=y(5715);const A=(0,R.op)({broadcastTo_:function k(X,Z){let G=(0,H._1)(X,"broadcastTo","x");const it=G.shape;if((0,Q.Mu)(Z),Z.length<G.rank)throw new Error(`broadcastTo(): shape.length=${Z.length} < input.rank=${G.rank}.`);if(Z.length>G.rank){const lt=G.shape.slice();for(;lt.length<Z.length;)lt.unshift(1);G=(0,W.X)(G,lt)}const wt=G.shape,K=Array.from(Z);for(let lt=Z.length-1;lt>=0;lt--)if(wt[lt]===Z[lt])K[lt]=1;else if(1!==G.shape[lt])throw new Error(`broadcastTo(): [${it}] cannot be broadcast to [${Z}].`);return 0===K.map((lt,St)=>lt>1?St:-1).filter(lt=>lt>=0).length?(0,Y.d)(G):$.BV.runKernel(V.n9L,{x:G},{reps:K})}})},3239:(Lt,ut,y)=>{"use strict";function $(Q,Y){const R=Q.length,W=[];for(let k=0;k<R;k++){const A=R-1-k;(Y[Y.length-1-k]||1)>1&&1===(Q[A]||1)&&W.unshift(A)}return W}function V(Q,Y){const R=[];for(let W=0;W<Y.length;W++){const k=Q[Q.length-W-1],A=Y.length-W-1;(null==k||1===k&&Y[A]>1)&&R.unshift(A)}return R}function H(Q,Y){const R=Math.max(Q.length,Y.length),W=new Array(R);for(let k=0;k<R;k++){let A=Q[Q.length-k-1];null==A&&(A=1);let X=Y[Y.length-k-1];if(null==X&&(X=1),1===A)W[R-k-1]=X;else if(1===X)W[R-k-1]=A;else{if(A!==X)throw Error(`Operands could not be broadcast together with shapes ${Q} and ${Y}.`);W[R-k-1]=A}}return W}y.r(ut),y.d(ut,{assertAndGetBroadcastShape:()=>H,getBroadcastDims:()=>$,getReductionAxes:()=>V})},582:(Lt,ut,y)=>{"use strict";y.d(ut,{f:()=>H});var $=y(4945),V=y(5359);function H(Q,Y="float32",R){return Y=Y||"float32",V.Mu(Q),new $.YD(Q,Y,R)}},3062:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({cast_:function R(k,A){const X=(0,H._1)(k,"x","cast");if(!Q.LP(A))throw new Error(`Failed to cast to unknown dtype ${A}`);if("string"===A&&"string"!==X.dtype||"string"!==A&&"string"===X.dtype)throw new Error("Only strings can be casted to strings");return $.BV.runKernel(V.RFZ,{x:X},{dtype:A})}})},9723:(Lt,ut,y)=>{"use strict";y.d(ut,{m:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({ceil_:function Y(W){const A={x:(0,H._1)(W,"x","ceil","float32")};return $.BV.runKernel(V.gJX,A)}})},6672:(Lt,ut,y)=>{"use strict";y.d(ut,{i:()=>k});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(2787);const k=(0,y(4195).op)({clipByValue_:function W(A,X,Z){const G=(0,H._1)(A,"x","clipByValue");return Q.hu(X<=Z,()=>`Error in clip: min (${X}) must be less than or equal to max (${Z}).`),X===Z?(0,Y.h)(G.shape,X,G.dtype):$.BV.runKernel(V.xnO,{x:G},{clipValueMin:X,clipValueMax:Z})}})},7315:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({clone_:function Y(W){const A={x:(0,H._1)(W,"x","clone","string_or_numeric")};return $.BV.runKernel(V.iJz,A)}})},3037:(Lt,ut,y)=>{"use strict";y.d(ut,{P:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({complex_:function R(k,A){const X=(0,H._1)(k,"real","complex"),Z=(0,H._1)(A,"imag","complex");return Q.k5(X.shape,Z.shape,`real and imag shapes, ${X.shape} and ${Z.shape}, must match in call to tf.complex().`),$.BV.runKernel(V.Zz9,{real:X,imag:Z})}})},4111:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>k});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(7315);const k=(0,y(4195).op)({concat_:function W(A,X=0){(0,Q.hu)(A.length>=1,()=>"Pass at least one tensor to concat");const Z=(0,H.sI)(A,"tensors","concat","string_or_numeric");return"complex64"===Z[0].dtype&&Z.forEach(wt=>{if("complex64"!==wt.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${wt.dtype}. `)}),1===Z.length?(0,Y.d)(Z[0]):$.BV.runKernel(V.Eh3,Z,{axis:X})}})},8577:(Lt,ut,y)=>{"use strict";y.d(ut,{P:()=>k});var $=y(1257),V=y(5359),H=y(4451),Q=y(5551),Y=y(4195),R=y(5715);const k=(0,Y.op)({conv1d_:function W(A,X,Z,G,it="NWC",wt=1,K){const st=(0,$._1)(A,"x","conv1d"),et=(0,$._1)(X,"filter","conv1d");let dt=st,lt=!1;2===st.rank&&(lt=!0,dt=(0,R.X)(st,[1,st.shape[0],st.shape[1]])),V.hu(3===dt.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${dt.rank}.`),V.hu(3===et.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${et.rank}.`),Q.m("conv1d",G,K),V.hu(dt.shape[2]===et.shape[1],()=>`Error in conv1d: depth of input (${dt.shape[2]}) must match input depth for filter ${et.shape[1]}.`),V.hu(Q.jT(Z,wt),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${Z} and dilation '${wt}'`),V.hu(Q.U3(wt),()=>"Error in conv1D: Dilated rates should be larger than 0."),V.hu(Q.U3(Z),()=>"Error in conv1D: Stride should be larger than 0."),V.hu("NWC"===it,()=>`Error in conv1d: got dataFormat of ${it} but only NWC is currently supported.`);const St=(0,R.X)(et,[1,et.shape[0],et.shape[1],et.shape[2]]),q=(0,R.X)(dt,[dt.shape[0],1,dt.shape[1],dt.shape[2]]),ot=(0,H.T)(q,St,[1,Z],G,"NHWC",[1,wt],K);return(0,R.X)(ot,lt?[ot.shape[2],ot.shape[3]]:[ot.shape[0],ot.shape[2],ot.shape[3]])}})},4451:(Lt,ut,y)=>{"use strict";y.d(ut,{T:()=>A});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(5551),R=y(4195),W=y(5715);const A=(0,R.op)({conv2d_:function k(X,Z,G,it,wt="NHWC",K=[1,1],st){const et=(0,H._1)(X,"x","conv2d","float32"),dt=(0,H._1)(Z,"filter","conv2d","float32");let lt=et,St=!1;3===et.rank&&(St=!0,lt=(0,W.X)(et,[1,et.shape[0],et.shape[1],et.shape[2]])),Q.hu(4===lt.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${lt.rank}.`),Q.hu(4===dt.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${dt.rank}.`),Y.m("conv2d",it,st);const q="NHWC"===wt?lt.shape[3]:lt.shape[1];Q.hu(q===dt.shape[2],()=>`Error in conv2d: depth of input (${q}) must match input depth for filter ${dt.shape[2]}.`),Q.hu(Y.jT(G,K),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${G} and dilations '${K}'`),Q.hu(Y.U3(K),()=>"Error in conv2D: Dilated rates should be larger than 0."),Q.hu(Y.U3(G),()=>"Error in conv2D: Strides should be larger than 0.");const B=$.BV.runKernel(V.mhS,{x:lt,filter:dt},{strides:G,pad:it,dataFormat:wt,dilations:K,dimRoundingMode:st});return St?(0,W.X)(B,[B.shape[1],B.shape[2],B.shape[3]]):B}})},443:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>k});var $=y(687),V=y(4251),H=y(5359),Q=y(5551),Y=y(4195),R=y(5715);const k=(0,Y.op)({conv2DBackpropFilter_:function W(A,X,Z,G,it,wt="NHWC",K){let st=A;3===A.rank&&(st=(0,R.X)(A,[1,A.shape[0],A.shape[1],A.shape[2]]));let et=X;3===et.rank&&(et=(0,R.X)(X,[1,X.shape[0],X.shape[1],X.shape[2]])),H.hu(4===st.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${st.shape}.`),H.hu(4===et.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${et.shape}.`),H.hu(4===Z.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${Z}.`);const dt="NHWC"===wt?st.shape[3]:st.shape[1],lt="NHWC"===wt?et.shape[3]:et.shape[1];return H.hu(dt===Z[2],()=>`Error in conv2dDerFilter: depth of input ${dt}) must match input depth in filter (${Z[2]}.`),H.hu(lt===Z[3],()=>`Error in conv2dDerFilter: depth of dy (${lt}) must match output depth for filter (${Z[3]}).`),Q.m("conv2dDerFilter",it,K),$.BV.runKernel(V.wUP,{x:st,dy:et},{strides:G,pad:it,dataFormat:wt,dimRoundingMode:K,filterShape:Z})}})},5743:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>k});var $=y(687),V=y(4251),H=y(5359),Q=y(5551),Y=y(4195),R=y(5715);const k=(0,Y.op)({conv2DBackpropInput_:function W(A,X,Z,G,it,wt="NHWC",K){H.hu(A.length===X.rank,()=>`Length of inShape (${A.length}) and rank of dy (${X.rank}) must match`);let st=A,et=X,dt=!1;3===X.rank&&(dt=!0,et=(0,R.X)(X,[1,X.shape[0],X.shape[1],X.shape[2]]),st=[1,A[0],A[1],A[2]]),H.hu(4===st.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${st.length}.`),H.hu(4===et.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${et.rank}`),H.hu(4===Z.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${Z.rank}`);const lt="NHWC"===wt?st[3]:st[1],St="NHWC"===wt?et.shape[3]:et.shape[1];H.hu(lt===Z.shape[2],()=>`Error in conv2dDerInput: depth of input (${lt}) must match input depth for filter ${Z.shape[2]}.`),H.hu(St===Z.shape[3],()=>`Error in conv2dDerInput: depth of output (${St}) must match output depth for filter ${Z.shape[3]}.`),Q.m("conv2dDerInput",it,K);const pt=$.BV.runKernel(V.wm,{dy:et,filter:Z},{strides:G,pad:it,dataFormat:wt,dimRoundingMode:K,inputShape:st});return dt?(0,R.X)(pt,[pt.shape[1],pt.shape[2],pt.shape[3]]):pt}})},8554:(Lt,ut,y)=>{"use strict";y.d(ut,{b:()=>Y});var $=y(1257),V=y(5743);const Y=(0,y(4195).op)({conv2dTranspose_:function Q(R,W,k,A,X,Z){const G=(0,$._1)(R,"x","conv2dTranspose"),it=(0,$._1)(W,"filter","conv2dTranspose");return(0,V._)(k,G,it,A,X,"NHWC",Z)}})},7022:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>W});var $=y(687),V=y(4251),H=y(5359),Q=y(4195),Y=y(5715);const W=(0,Q.op)({conv3DBackpropInput_:function R(k,A,X,Z,G){H.hu(k.length===A.rank,()=>`Length of inShape (${k.length}) and rank of dy (${A.rank}) must match`);let it=k,wt=A,K=!1;4===A.rank&&(K=!0,wt=(0,Y.X)(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]]),it=[1,k[0],k[1],k[2],k[3]]);const st=it[4],et=wt.shape[4];H.hu(5===it.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${it.length}.`),H.hu(5===wt.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${wt.rank}`),H.hu(5===X.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${X.rank}`),H.hu(st===X.shape[3],()=>`Error in conv3dDerInput: depth of input (${st}) must match input depth for filter ${X.shape[3]}.`),H.hu(et===X.shape[4],()=>`Error in conv3dDerInput: depth of output (${et}) must match output depth for filter ${X.shape[4]}.`);const St=$.BV.runKernel(V.ik2,{dy:wt,filter:X},{pad:G,strides:Z,inputShape:it});return K?(0,Y.X)(St,[St.shape[1],St.shape[2],St.shape[3],St.shape[4]]):St}})},5551:(Lt,ut,y)=>{"use strict";y.d(ut,{I0:()=>st,Ix:()=>Y,Rf:()=>V,U3:()=>dt,Xw:()=>H,aO:()=>A,jT:()=>et,jw:()=>R,m:()=>St,pl:()=>Q,sl:()=>lt});var $=y(5359);function V(q,ft,pt,B,ot="NHWC",P){return Y(q,[...ft,q[3]],pt,P,B,null,null,lt(ot))}function H(q,ft,pt,B,ot,P,at="channelsLast"){const[nt,Gt]=X(ft);let O;if("channelsLast"===at)O=[nt,Gt,q[3],q[3]];else{if("channelsFirst"!==at)throw new Error(`Unknown dataFormat ${at}`);O=[nt,Gt,q[1],q[1]]}return Y(q,O,pt,B,ot,P,!1,at)}function Q(q,ft,pt,B,ot,P,at="NDHWC"){const[nt,Gt,O]=Z(ft);let Ct,yt;if("NDHWC"===at)yt="channelsLast",Ct=[nt,Gt,O,q[4],q[4]];else{if("NCDHW"!==at)throw new Error(`Unknown dataFormat ${at}`);yt="channelsFirst",Ct=[nt,Gt,O,q[1],q[1]]}return R(q,Ct,pt,B,ot,!1,yt,P)}function Y(q,ft,pt,B,ot,P,at=!1,nt="channelsLast"){let[Gt,O,Ct,yt]=[-1,-1,-1,-1];if("channelsLast"===nt)[Gt,O,Ct,yt]=q;else{if("channelsFirst"!==nt)throw new Error(`Unknown dataFormat ${nt}`);[Gt,yt,O,Ct]=q}const[vt,xt,,Mt]=ft,[It,re]=X(pt),[Bt,ee]=X(B),jt=G(vt,Bt),se=G(xt,ee),{padInfo:we,outHeight:Me,outWidth:Xe}=function it(q,ft,pt,B,ot,P,at,nt,Gt){let O,Ct,yt;if("number"==typeof q){O={top:q,bottom:q,left:q,right:q,type:0===q?"VALID":"NUMBER"};const xt=function W(q,ft,pt,B,ot){null==B&&(B=A(q,ft,pt));const at=q[1];return[K((q[0]-ft+2*B)/pt+1,ot),K((at-ft+2*B)/pt+1,ot)]}([ft,pt],P,B,q,nt);Ct=xt[0],yt=xt[1]}else if("same"===q){Ct=Math.ceil(ft/B),yt=Math.ceil(pt/ot);const vt=Math.max(0,(Ct-1)*B+P-ft),xt=Math.max(0,(yt-1)*ot+at-pt),Mt=Math.floor(vt/2),It=vt-Mt,re=Math.floor(xt/2);O={top:Mt,bottom:It,left:re,right:xt-re,type:"SAME"}}else if("valid"===q)O={top:0,bottom:0,left:0,right:0,type:"VALID"},Ct=Math.ceil((ft-P+1)/B),yt=Math.ceil((pt-at+1)/ot);else{if("object"!=typeof q)throw Error(`Unknown padding parameter: ${q}`);{const vt="channelsLast"===Gt?q[1][0]:q[2][0],xt="channelsLast"===Gt?q[1][1]:q[2][1],Mt="channelsLast"===Gt?q[2][0]:q[3][0],It="channelsLast"===Gt?q[2][1]:q[3][1];O={top:vt,bottom:xt,left:Mt,right:It,type:0===vt&&0===xt&&0===Mt&&0===It?"VALID":"EXPLICIT"},Ct=K((ft-P+vt+xt)/B+1,nt),yt=K((pt-at+Mt+It)/ot+1,nt)}}return{padInfo:O,outHeight:Ct,outWidth:yt}}(ot,O,Ct,It,re,jt,se,P,nt),Ue=at?Mt*yt:Mt;let De;return"channelsFirst"===nt?De=[Gt,Ue,Me,Xe]:"channelsLast"===nt&&(De=[Gt,Me,Xe,Ue]),{batchSize:Gt,dataFormat:nt,inHeight:O,inWidth:Ct,inChannels:yt,outHeight:Me,outWidth:Xe,outChannels:Ue,padInfo:we,strideHeight:It,strideWidth:re,filterHeight:vt,filterWidth:xt,effectiveFilterHeight:jt,effectiveFilterWidth:se,dilationHeight:Bt,dilationWidth:ee,inShape:q,outShape:De,filterShape:ft}}function R(q,ft,pt,B,ot,P=!1,at="channelsLast",nt){let[Gt,O,Ct,yt,vt]=[-1,-1,-1,-1,-1];if("channelsLast"===at)[Gt,O,Ct,yt,vt]=q;else{if("channelsFirst"!==at)throw new Error(`Unknown dataFormat ${at}`);[Gt,vt,O,Ct,yt]=q}const[xt,Mt,It,,re]=ft,[Bt,ee,jt]=Z(pt),[se,we,Me]=Z(B),Xe=G(xt,se),Ue=G(Mt,we),De=G(It,Me),{padInfo:Tn,outDepth:On,outHeight:ne,outWidth:pe}=function wt(q,ft,pt,B,ot,P,at,nt,Gt,O,Ct){let yt,vt,xt,Mt;if("valid"===q&&(q=0),"number"==typeof q){yt={top:q,bottom:q,left:q,right:q,front:q,back:q,type:0===q?"VALID":"NUMBER"};const re=function k(q,ft,pt,B,ot,P){null==ot&&(ot=A(q,ft[0],B[0]));const at=[0,0,0,pt];for(let nt=0;nt<3;nt++)q[nt]+2*ot>=ft[nt]&&(at[nt]=K((q[nt]-ft[nt]+2*ot)/B[nt]+1,P));return at}([ft,pt,B,1],[nt,Gt,O],1,[ot,P,at],q,Ct);vt=re[0],xt=re[1],Mt=re[2]}else{if("same"!==q)throw Error(`Unknown padding parameter: ${q}`);{vt=Math.ceil(ft/ot),xt=Math.ceil(pt/P),Mt=Math.ceil(B/at);const It=(vt-1)*ot+nt-ft,re=(xt-1)*P+Gt-pt,Bt=(Mt-1)*at+O-B,ee=Math.floor(It/2),jt=It-ee,se=Math.floor(re/2),we=re-se,Me=Math.floor(Bt/2);yt={top:se,bottom:we,left:Me,right:Bt-Me,front:ee,back:jt,type:"SAME"}}}return{padInfo:yt,outDepth:vt,outHeight:xt,outWidth:Mt}}(ot,O,Ct,yt,Bt,ee,jt,Xe,Ue,De,nt),Ie=P?re*vt:re;let Je;return"channelsFirst"===at?Je=[Gt,Ie,On,ne,pe]:"channelsLast"===at&&(Je=[Gt,On,ne,pe,Ie]),{batchSize:Gt,dataFormat:at,inDepth:O,inHeight:Ct,inWidth:yt,inChannels:vt,outDepth:On,outHeight:ne,outWidth:pe,outChannels:Ie,padInfo:Tn,strideDepth:Bt,strideHeight:ee,strideWidth:jt,filterDepth:xt,filterHeight:Mt,filterWidth:It,effectiveFilterDepth:Xe,effectiveFilterHeight:Ue,effectiveFilterWidth:De,dilationDepth:se,dilationHeight:we,dilationWidth:Me,inShape:q,outShape:Je,filterShape:ft}}function A(q,ft,pt,B=1){const ot=G(ft,B);return Math.floor((q[0]*(pt-1)-pt+ot)/2)}function X(q){return"number"==typeof q?[q,q,q]:2===q.length?[q[0],q[1],1]:q}function Z(q){return"number"==typeof q?[q,q,q]:q}function G(q,ft){return ft<=1?q:q+(q-1)*(ft-1)}function K(q,ft){if(!ft)return Math.trunc(q);switch(ft){case"round":return Math.round(q);case"ceil":return Math.ceil(q);case"floor":return Math.floor(q);default:throw new Error(`Unknown roundingMode ${ft}`)}}function st(q){const[ft,pt,B]=X(q);return 1===ft&&1===pt&&1===B}function et(q,ft){return st(q)||st(ft)}function dt(q){return X(q).every(ft=>ft>0)}function lt(q){if("NHWC"===q)return"channelsLast";if("NCHW"===q)return"channelsFirst";throw new Error(`Unknown dataFormat ${q}`)}function St(q,ft,pt){if(null!=pt){if("string"==typeof ft)throw Error(`Error in ${q}: pad must be an integer when using dimRoundingMode ${pt} but got pad ${ft}.`);if("number"==typeof ft)$.hu($.GN(ft),()=>`Error in ${q}: pad must be an integer when using dimRoundingMode ${pt} but got pad ${ft}.`);else{if("object"!=typeof ft)throw Error(`Error in ${q}: Unknown padding parameter: ${ft}`);ft.forEach(B=>{B.forEach(ot=>{$.hu($.GN(ot),()=>`Error in ${q}: pad must be an integer when using dimRoundingMode ${pt} but got pad ${ot}.`)})})}}}},9018:(Lt,ut,y)=>{"use strict";y.d(ut,{m:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({cos_:function Y(W){const A={x:(0,H._1)(W,"x","cos","float32")};return $.BV.runKernel(V.mc4,A)}})},3237:(Lt,ut,y)=>{"use strict";y.d(ut,{f:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({cosh_:function Y(W){const A={x:(0,H._1)(W,"x","cosh","float32")};return $.BV.runKernel(V.TR1,A)}})},9267:(Lt,ut,y)=>{"use strict";y.d(ut,{$:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({cumprod_:function Y(W,k=0,A=!1,X=!1){const G={x:(0,H._1)(W,"x","cumprod")};return $.BV.runKernel(V.Byc,G,{axis:k,exclusive:A,reverse:X})}})},7157:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({cumsum_:function Y(W,k=0,A=!1,X=!1){const G={x:(0,H._1)(W,"x","cumsum")};return $.BV.runKernel(V.iHb,G,{axis:k,exclusive:A,reverse:X})}})},3961:(Lt,ut,y)=>{"use strict";y.d(ut,{n:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({depthToSpace_:function R(k,A,X="NHWC"){const Z=(0,H._1)(k,"x","depthToSpace","float32"),G="NHWC"===X?Z.shape[1]:Z.shape[2],it="NHWC"===X?Z.shape[2]:Z.shape[3],wt="NHWC"===X?Z.shape[3]:Z.shape[1];return Q.hu(A>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${A}`),Q.hu(G*A>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${G} and ${A}  for depthToSpace with input shape\n    ${Z.shape}`),Q.hu(it*A>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${it} and ${A} for depthToSpace with input shape\n        ${Z.shape}`),Q.hu(wt%(A*A)==0,()=>`Dimension size must be evenly divisible by ${A*A} but is ${wt} for depthToSpace with input shape ${Z.shape}`),$.BV.runKernel(V.T0n,{x:Z},{blockSize:A,dataFormat:X})}})},1172:(Lt,ut,y)=>{"use strict";y.d(ut,{B:()=>A});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(5551),R=y(4195),W=y(5715);const A=(0,R.op)({depthwiseConv2d_:function k(X,Z,G,it,wt="NHWC",K=[1,1],st){const et=(0,H._1)(X,"x","depthwiseConv2d","float32"),dt=(0,H._1)(Z,"filter","depthwiseConv2d","float32");let lt=et,St=!1;3===et.rank&&(St=!0,lt=(0,W.X)(et,[1,et.shape[0],et.shape[1],et.shape[2]])),Q.hu(4===lt.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${lt.rank}.`),Q.hu(4===dt.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${dt.rank}.`);const q="NHWC"===wt?lt.shape[3]:lt.shape[1];Q.hu(q===dt.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${q}) must match the inChannels dimension in filter ${dt.shape[2]}.`),Y.m("depthwiseConv2d",it,st);const B=$.BV.runKernel(V.cie,{x:lt,filter:dt},{strides:G,pad:it,dataFormat:wt,dilations:K,dimRoundingMode:st});return St?(0,W.X)(B,[B.shape[1],B.shape[2],B.shape[3]]):B}})},366:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>R});var $=y(687),V=y(4251),H=y(4195),Q=y(5715);const R=(0,H.op)({depthwiseConv2dNativeBackpropFilter_:function Y(W,k,A,X,Z,G=[1,1],it){let wt=W;3===W.rank&&(wt=(0,Q.X)(W,[1,W.shape[0],W.shape[1],W.shape[2]]));let K=k;return 3===K.rank&&(K=(0,Q.X)(k,[1,k.shape[0],k.shape[1],k.shape[2]])),$.BV.runKernel(V.sL$,{x:wt,dy:K},{strides:X,pad:Z,dimRoundingMode:it,dilations:G,filterShape:A})}})},519:(Lt,ut,y)=>{"use strict";y.d(ut,{v:()=>R});var $=y(687),V=y(4251),H=y(4195),Q=y(5715);const R=(0,H.op)({depthwiseConv2dNativeBackpropInput_:function Y(W,k,A,X,Z,G=[1,1],it){let wt=k,K=!1;3===k.rank&&(K=!0,wt=(0,Q.X)(k,[1,k.shape[0],k.shape[1],k.shape[2]]));const dt=$.BV.runKernel(V.y7R,{dy:wt,filter:A},{strides:X,pad:Z,dimRoundingMode:it,dilations:G,inputShape:W});return K?(0,Q.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3]]):dt}})},2395:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>k});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(4195),R=y(5715);const k=(0,Y.op)({dilation2d_:function W(A,X,Z,G,it=[1,1],wt="NHWC"){const K=(0,H._1)(A,"x","dilation2d"),st=(0,H._1)(X,"filter","dilation2d");Q.hu(3===K.rank||4===K.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${K.rank}.`),Q.hu(3===st.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${st.rank}.`),Q.hu("NHWC"===wt,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${wt}`);let et=K,dt=!1;3===K.rank&&(et=(0,R.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]]),dt=!0),Q.hu(et.shape[3]===st.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${et.shape[3]} vs ${st.shape[2]}`);const q=$.BV.runKernel(V.p4S,{x:et,filter:st},{strides:Z,pad:G,dilations:it});return dt?(0,R.X)(q,[q.shape[1],q.shape[2],q.shape[3]]):q}})},3530:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>k});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(1030);const k=(0,y(4195).op)({div_:function W(A,X){let Z=(0,Q._1)(A,"a","div"),G=(0,Q._1)(X,"b","div");return[Z,G]=(0,H.makeTypesMatch)(Z,G),"int32"===Z.dtype&&"int32"===G.dtype?(0,Y.q)(Z,G):$.BV.runKernel(V.oHH,{a:Z,b:G},{})}})},4373:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>A});var $=y(7664),V=y(1257),H=y(3530),Q=y(4456),Y=y(4195),R=y(2190),W=y(3143);const A=(0,Y.op)({divNoNan_:function k(X,Z){let G=(0,V._1)(X,"a","div"),it=(0,V._1)(Z,"b","div");[G,it]=(0,$.makeTypesMatch)(G,it);const wt=(0,H.h)(G,it),K=(0,W.P)(wt),st=(0,Q.D)(it,K);return(0,R.a)(st,K,wt)}})},5106:(Lt,ut,y)=>{"use strict";y.d(ut,{A:()=>W});var $=y(1257),V=y(5359),H=y(5592),Q=y(4195),Y=y(5715);const W=(0,Q.op)({dot_:function R(k,A){const X=(0,$._1)(k,"t1","dot"),Z=(0,$._1)(A,"t2","dot");V.hu(!(1!==X.rank&&2!==X.rank||1!==Z.rank&&2!==Z.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${X.rank} and ${Z.rank}.`);const G=1===X.rank?X.size:X.shape[1],it=1===Z.rank?Z.size:Z.shape[0];if(V.hu(G===it,()=>`Error in dot: inner dimensions of inputs must match, but got ${G} and ${it}.`),1===X.rank&&1===Z.rank){const wt=(0,Y.X)(X,[1,-1]),K=(0,Y.X)(Z,[-1,1]),st=(0,H.O)(wt,K);return(0,Y.X)(st,[])}if(1===X.rank&&2===Z.rank){const wt=(0,Y.X)(X,[1,-1]),K=(0,Y.X)(Z,[Z.shape[0],Z.shape[1]]),st=(0,H.O)(wt,K);return(0,Y.X)(st,[st.size])}if(2===X.rank&&1===Z.rank){const wt=(0,Y.X)(Z,[-1,1]),K=(0,H.O)(X,wt);return(0,Y.X)(K,[K.size])}{const wt=(0,Y.X)(Z,[Z.shape[0],Z.shape[1]]);return(0,H.O)(X,wt)}}})},9529:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({elu_:function Y(W){const A={x:(0,H._1)(W,"x","elu","float32")};return $.BV.runKernel(V.SX0,A)}})},4456:(Lt,ut,y)=>{"use strict";y.d(ut,{D:()=>k});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239);const k=(0,y(4195).op)({equal_:function W(A,X){let Z=(0,Q._1)(A,"a","equal","string_or_numeric"),G=(0,Q._1)(X,"b","equal","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.hdR,{a:Z,b:G})}})},4634:(Lt,ut,y)=>{"use strict";y.d(ut,{q:()=>k});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(3062);const k=(0,y(4195).op)({erf_:function W(A){let X=(0,H._1)(A,"x","erf");return Q.hu("int32"===X.dtype||"float32"===X.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===X.dtype&&(X=(0,Y.p)(X,"float32")),$.BV.runKernel(V.Omj,{x:X})}})},4279:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>Q});var $=y(3717);const Q=(0,y(4195).op)({euclideanNorm_:function H(Y,R=null,W=!1){return(0,$.K)(Y,"euclidean",R,W)}})},5109:(Lt,ut,y)=>{"use strict";y.d(ut,{Q:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({exp_:function Y(W){const A={x:(0,H._1)(W,"x","exp")};return $.BV.runKernel(V.NEP,A)}})},7228:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({expandDims_:function R(k,A=0){const X=(0,H._1)(k,"x","expandDims","string_or_numeric");return Q.hu(A<=X.rank,()=>"Axis must be <= rank of the tensor"),$.BV.runKernel(V.YFo,{input:X},{dim:A})}})},5748:(Lt,ut,y)=>{"use strict";y.d(ut,{t:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({expm1_:function Y(W){const A={x:(0,H._1)(W,"x","expm1")};return $.BV.runKernel(V.Y0y,A)}})},2787:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>Q});var $=y(687),V=y(4251),H=y(5359);function Q(Y,R,W){return(0,H.Mu)(Y),W=W||(0,H.D2)(R),$.BV.runKernel(V.deh,{},{shape:Y,value:R,dtype:W})}},8208:(Lt,ut,y)=>{"use strict";y.d(ut,{G:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({floor_:function Y(W){const A={x:(0,H._1)(W,"x","floor","float32")};return $.BV.runKernel(V.OR,A)}})},1030:(Lt,ut,y)=>{"use strict";y.d(ut,{q:()=>W});var $=y(687),V=y(4251),H=y(7664),Q=y(1257);const W=(0,y(4195).op)({floorDiv_:function R(k,A){let X=(0,Q._1)(k,"a","floorDiv"),Z=(0,Q._1)(A,"b","floorDiv");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.jeX,{a:X,b:Z})}})},6254:(Lt,ut,y)=>{"use strict";y.d(ut,{Fr:()=>G,QH:()=>wt,pf:()=>it,uy:()=>K});var $=y(3239),V=y(9529),H=y(9424),Q=y(8737),Y=y(1584),R=y(8586),W=y(4917),k=y(5715),A=y(6139),X=y(6034),Z=y(9929);function G(st,et,dt){if(null==dt||"linear"===dt)return st;if("relu"===dt)return(0,Q.d)(st,(0,X.N)(et));throw new Error(`Cannot compute gradient for fused activation ${dt}.`)}function it(st,et){let dt=et;const lt=$.getReductionAxes(st.shape,et.shape);return lt.length>0&&(dt=(0,Z.S)(dt,lt)),(0,k.X)(dt,st.shape)}function wt(st,et,dt,lt){if("linear"===et)return st;if("relu"===et)return(0,R.U)(st);if("elu"===et)return(0,V.p)(st);if("relu6"===et)return(0,W.b)(st);if("prelu"===et)return(0,Y.A)(st,dt);if("leakyrelu"===et)return(0,H.h)(st,lt);if("sigmoid"===et)return(0,A.X)(st);throw new Error(`Unknown fused activation ${et}.`)}const K=(st,et)=>!(st>0)||"linear"===et},6117:(Lt,ut,y)=>{"use strict";y.d(ut,{I:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({gather_:function Y(W,k,A=0,X=0){const Z=(0,H._1)(W,"x","gather"),G=(0,H._1)(k,"indices","gather","int32");return $.BV.runKernel(V.qi_,{x:Z,indices:G},{axis:A,batchDims:X})}})},4803:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>k});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239);const k=(0,y(4195).op)({greater_:function W(A,X){let Z=(0,Q._1)(A,"a","greater","string_or_numeric"),G=(0,Q._1)(X,"b","greater","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.iZT,{a:Z,b:G})}})},9886:(Lt,ut,y)=>{"use strict";y.d(ut,{b:()=>k});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239);const k=(0,y(4195).op)({greaterEqual_:function W(A,X){let Z=(0,Q._1)(A,"a","greaterEqual","string_or_numeric"),G=(0,Q._1)(X,"b","greaterEqual","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.Acj,{a:Z,b:G})}})},1844:(Lt,ut,y)=>{"use strict";y.d(ut,{a:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({imag_:function Y(W){const A={input:(0,H._1)(W,"input","imag")};return $.BV.runKernel(V.J_u,A)}})},1265:(Lt,ut,y)=>{"use strict";y.d(ut,{I:()=>k});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(4195),R=y(5715);const k=(0,Y.op)({resizeBilinear_:function W(A,X,Z=!1,G=!1){const it=(0,H._1)(A,"images","resizeBilinear");Q.hu(3===it.rank||4===it.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${it.rank}.`),Q.hu(2===X.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${X}.`),Q.hu(!1===G||!1===Z,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let wt=it,K=!1;3===it.rank&&(K=!0,wt=(0,R.X)(it,[1,it.shape[0],it.shape[1],it.shape[2]]));const[]=X,dt=$.BV.runKernel(V._Yw,{images:wt},{alignCorners:Z,halfPixelCenters:G,size:X});return K?(0,R.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3]]):dt}})},7373:(Lt,ut,y)=>{"use strict";y.d(ut,{j:()=>k});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(4195),R=y(5715);const k=(0,Y.op)({resizeNearestNeighbor_:function W(A,X,Z=!1,G=!1){const it=(0,H._1)(A,"images","resizeNearestNeighbor");Q.hu(3===it.rank||4===it.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${it.rank}.`),Q.hu(2===X.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${X}.`),Q.hu("float32"===it.dtype||"int32"===it.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Q.hu(!1===G||!1===Z,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let wt=it,K=!1;3===it.rank&&(K=!0,wt=(0,R.X)(it,[1,it.shape[0],it.shape[1],it.shape[2]]));const[]=X,dt=$.BV.runKernel(V.dpD,{images:wt},{alignCorners:Z,halfPixelCenters:G,size:X});return K?(0,R.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3]]):dt}})},8821:(Lt,ut,y)=>{"use strict";y.d(ut,{x:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({isFinite_:function Y(W){const A={x:(0,H._1)(W,"x","isFinite")};return $.BV.runKernel(V.avt,A)}})},8381:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({isInf_:function Y(W){const A={x:(0,H._1)(W,"x","isInf")};return $.BV.runKernel(V.iWB,A)}})},6483:(Lt,ut,y)=>{"use strict";y.d(ut,{i:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({isNaN_:function Y(W){const A={x:(0,H._1)(W,"x","isNaN")};return $.BV.runKernel(V.r7n,A)}})},9424:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({leakyRelu_:function Y(W,k=.2){const X={x:(0,H._1)(W,"x","leakyRelu")};return $.BV.runKernel(V.J$2,X,{alpha:k})}})},2761:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>k});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239);const k=(0,y(4195).op)({less_:function W(A,X){let Z=(0,Q._1)(A,"a","less","string_or_numeric"),G=(0,Q._1)(X,"b","less","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.vtC,{a:Z,b:G})}})},2223:(Lt,ut,y)=>{"use strict";y.d(ut,{z:()=>k});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239);const k=(0,y(4195).op)({lessEqual_:function W(A,X){let Z=(0,Q._1)(A,"a","lessEqual","string_or_numeric"),G=(0,Q._1)(X,"b","lessEqual","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.CAk,{a:Z,b:G})}})},1523:(Lt,ut,y)=>{"use strict";y.d(ut,{G:()=>k});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(4195),R=y(5715);const k=(0,Y.op)({localResponseNormalization_:function W(A,X=5,Z=1,G=1,it=.5){const wt=(0,H._1)(A,"x","localResponseNormalization");Q.hu(4===wt.rank||3===wt.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${wt.rank}.`),Q.hu(Q.GN(X),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${X}.`);let K=wt,st=!1;3===wt.rank&&(st=!0,K=(0,R.X)(wt,[1,wt.shape[0],wt.shape[1],wt.shape[2]]));const lt=$.BV.runKernel(V.eZ0,{x:K},{depthRadius:X,bias:Z,alpha:G,beta:it});return st?(0,R.X)(lt,[lt.shape[1],lt.shape[2],lt.shape[3]]):lt}})},5919:(Lt,ut,y)=>{"use strict";y.d(ut,{c:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({log_:function Y(W){const A={x:(0,H._1)(W,"x","log","float32")};return $.BV.runKernel(V.ZbH,A)}})},4088:(Lt,ut,y)=>{"use strict";y.d(ut,{K:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({log1p_:function Y(W){const A={x:(0,H._1)(W,"x","log1p")};return $.BV.runKernel(V.kU,A)}})},4034:(Lt,ut,y)=>{"use strict";y.d(ut,{e:()=>A});var $=y(3537),V=y(1257),H=y(8737),Q=y(5048),Y=y(4195),R=y(6139),W=y(4487);const A=(0,Y.op)({logSigmoid_:function k(X){const Z=(0,V._1)(X,"x","logSigmoid");return(0,$.cb)(it=>({value:(0,Q.W)((0,W.W)((0,Q.W)(it))),gradFunc:st=>(0,H.d)(st,(0,R.X)((0,Q.W)(it)))}))(Z)}})},6455:(Lt,ut,y)=>{"use strict";y.d(ut,{C:()=>G});var $=y(3537),V=y(1257),H=y(3062),Q=y(5109),Y=y(5919),R=y(3043),W=y(8737),k=y(4195),A=y(1191),X=y(9929);const G=(0,k.op)({logSoftmax_:function Z(it,wt=-1){const K=(0,V._1)(it,"logits","logSoftmax");if(-1===wt&&(wt=K.rank-1),wt!==K.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${K.rank} and axis was ${wt}`);return(0,$.cb)((et,dt)=>{const St=(0,R.F)(et,wt,!0),q=(0,A.l)(et,St),ft=(0,A.l)((0,H.p)(q,"float32"),(0,Y.c)((0,X.S)((0,Q.Q)(q),wt,!0)));return dt([ft]),{value:ft,gradFunc:(B,ot)=>{const[P]=ot,nt=(0,Q.Q)(P);return(0,A.l)(B,(0,W.d)((0,X.S)(B,wt,!0),nt))}}})(K)}})},6735:(Lt,ut,y)=>{"use strict";y.d(ut,{l:()=>it});var $=y(1257),V=y(5359),H=y(7066),Q=y(929),Y=y(5109),R=y(5919),W=y(3043),k=y(4195),A=y(5715),X=y(1191),Z=y(9929);const it=(0,k.op)({logSumExp_:function G(wt,K=null,st=!1){const et=(0,$._1)(wt,"x","logSumExp"),dt=(0,V.EC)(K,et.shape),lt=(0,W.F)(et,dt,!0),St=(0,X.l)(et,lt),q=(0,Y.Q)(St),ft=(0,Z.S)(q,dt),pt=(0,R.c)(ft),B=(0,H.I)((0,A.X)(lt,pt.shape),pt);if(st){const ot=(0,Q.rv)(B.shape,dt);return(0,A.X)(B,ot)}return B}})},3080:(Lt,ut,y)=>{"use strict";y.d(ut,{H:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(3239);const W=(0,y(4195).op)({logicalAnd_:function R(k,A){const X=(0,H._1)(k,"a","logicalAnd","bool"),Z=(0,H._1)(A,"b","logicalAnd","bool");return(0,Q.assertAndGetBroadcastShape)(X.shape,Z.shape),$.BV.runKernel(V.PYm,{a:X,b:Z})}})},6399:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({logicalNot_:function Y(W){const A={x:(0,H._1)(W,"x","logicalNot","bool")};return $.BV.runKernel(V.VfG,A)}})},2693:(Lt,ut,y)=>{"use strict";y.d(ut,{K:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(3239);const W=(0,y(4195).op)({logicalOr_:function R(k,A){const X=(0,H._1)(k,"a","logicalOr","bool"),Z=(0,H._1)(A,"b","logicalOr","bool");return(0,Q.assertAndGetBroadcastShape)(X.shape,Z.shape),$.BV.runKernel(V.MZg,{a:X,b:Z})}})},4574:(Lt,ut,y)=>{"use strict";y.d(ut,{e:()=>k});var $=y(1257),V=y(3239),H=y(3080),Q=y(6399),Y=y(2693);const k=(0,y(4195).op)({logicalXor_:function W(A,X){const Z=(0,$._1)(A,"a","logicalXor","bool"),G=(0,$._1)(X,"b","logicalXor","bool");return(0,V.assertAndGetBroadcastShape)(Z.shape,G.shape),(0,H.H)((0,Y.K)(A,X),(0,Q.h)((0,H.H)(A,X)))}})},4839:(Lt,ut,y)=>{"use strict";y.d(ut,{I:()=>$});var $=function(V){return V[V.NONE=0]="NONE",V[V.MEAN=1]="MEAN",V[V.SUM=2]="SUM",V[V.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",V}($||{})},5592:(Lt,ut,y)=>{"use strict";y.d(ut,{O:()=>W});var $=y(687),V=y(4251),H=y(7664),Q=y(1257);const W=(0,y(4195).op)({matMul_:function R(k,A,X=!1,Z=!1){let G=(0,Q._1)(k,"a","matMul"),it=(0,Q._1)(A,"b","matMul");return[G,it]=(0,H.makeTypesMatch)(G,it),$.BV.runKernel(V.XLW,{a:G,b:it},{transposeA:X,transposeB:Z})}})},3043:(Lt,ut,y)=>{"use strict";y.d(ut,{F:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({max_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","max")};return $.BV.runKernel(V.YoZ,Z,{reductionIndices:k,keepDims:A})}})},2444:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>A});var $=y(687),V=y(4251),H=y(1257),Q=y(5359),Y=y(5551),R=y(4195),W=y(5715);const A=(0,R.op)({maxPool_:function k(X,Z,G,it,wt){const K=(0,H._1)(X,"x","maxPool");let et=K,dt=!1;3===K.rank&&(dt=!0,et=(0,W.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]])),Q.hu(4===et.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${et.rank}.`),Q.hu(Y.jT(G,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${G} and dilations '1'`),Y.m("maxPool",it,wt);const q=$.BV.runKernel(V.mTV,{x:et},{filterSize:Z,strides:G,pad:it,dimRoundingMode:wt});return dt?(0,W.X)(q,[q.shape[1],q.shape[2],q.shape[3]]):q}})},765:(Lt,ut,y)=>{"use strict";y.d(ut,{g:()=>A});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239),R=y(3062);const A=(0,y(4195).op)({maximum_:function k(X,Z){let G=(0,Q._1)(X,"a","maximum"),it=(0,Q._1)(Z,"b","maximum");return[G,it]=(0,H.makeTypesMatch)(G,it),"bool"===G.dtype&&(G=(0,R.p)(G,"int32"),it=(0,R.p)(it,"int32")),(0,Y.assertAndGetBroadcastShape)(G.shape,it.shape),$.BV.runKernel(V.BMI,{a:G,b:it})}})},9357:(Lt,ut,y)=>{"use strict";y.d(ut,{J:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({mean_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","mean")};return $.BV.runKernel(V.q2K,Z,{axis:k,keepDims:A})}})},9602:(Lt,ut,y)=>{"use strict";y.d(ut,{V:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({min_:function Y(W,k=null,A=!1){const Z={x:(0,H._1)(W,"x","min")};return $.BV.runKernel(V.c17,Z,{axis:k,keepDims:A})}})},2684:(Lt,ut,y)=>{"use strict";y.d(ut,{L:()=>A});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239),R=y(3062);const A=(0,y(4195).op)({minimum_:function k(X,Z){let G=(0,Q._1)(X,"a","minimum"),it=(0,Q._1)(Z,"b","minimum");return[G,it]=(0,H.makeTypesMatch)(G,it),"bool"===G.dtype&&(G=(0,R.p)(G,"int32"),it=(0,R.p)(it,"int32")),(0,Y.assertAndGetBroadcastShape)(G.shape,it.shape),$.BV.runKernel(V.q8u,{a:G,b:it})}})},4639:(Lt,ut,y)=>{"use strict";y.d(ut,{V:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({mirrorPad_:function R(k,A,X){Q.hu("reflect"===X||"symmetric"===X,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${X}.`);const Z=(0,H._1)(k,"x","mirrorPad");if(0===Z.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Q.hu(A.length===Z.rank,()=>`Padding doesn't match input. Must be ${Z.rank}. Got ${A.length}.`);const G="reflect"===X?1:0;for(let K=0;K<Z.rank;K++)Q.hu(2===A[K].length,()=>"Invalid number of paddings. Must be length of 2 each."),Q.hu(A[K][0]>=0&&A[K][0]<=Z.shape[K]-G&&A[K][1]>=0&&A[K][1]<=Z.shape[K]-G,()=>`Padding in dimension ${K} cannot be greater than or equal to ${Z.shape[K]-G} or less than 0 for input of shape ${Z.shape}`);return $.BV.runKernel(V.jQs,{x:Z},{paddings:A,mode:X})}})},1612:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>W});var $=y(687),V=y(4251),H=y(7664),Q=y(1257);const W=(0,y(4195).op)({mod_:function R(k,A){let X=(0,Q._1)(k,"a","mod"),Z=(0,Q._1)(A,"b","mod");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.Vbg,{a:X,b:Z})}})},8737:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>W});var $=y(687),V=y(4251),H=y(7664),Q=y(1257);const W=(0,y(4195).op)({mul_:function R(k,A){let X=(0,Q._1)(k,"a","mul"),Z=(0,Q._1)(A,"b","mul");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.wYn,{a:X,b:Z})}})},5048:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({neg_:function Y(W){const A={x:(0,H._1)(W,"x","neg")};return $.BV.runKernel(V.kuV,A)}})},3717:(Lt,ut,y)=>{"use strict";y.d(ut,{K:()=>st});var $=y(1257),V=y(5359),H=y(6989),Q=y(929),Y=y(3043),R=y(9602),W=y(4195),k=y(2962),A=y(5715),X=y(8661),Z=y(930),G=y(7527),it=y(9929);function K(et,dt,lt=null){if(0===et.rank)return(0,H.W)(et);if(1!==et.rank&&null===lt)return K((0,A.X)(et,[-1]),dt,lt);if(1===et.rank||"number"==typeof lt||Array.isArray(lt)&&1===lt.length){if(1===dt)return(0,it.S)((0,H.W)(et),lt);if(dt===1/0)return(0,Y.F)((0,H.W)(et),lt);if(dt===-1/0)return(0,R.V)((0,H.W)(et),lt);if("euclidean"===dt||2===dt)return(0,Z._)((0,it.S)((0,k.s)((0,H.W)(et),(0,X.i)(2,"int32")),lt));throw new Error(`Error in norm: invalid ord value: ${dt}`)}if(Array.isArray(lt)&&2===lt.length){if(1===dt)return(0,Y.F)((0,it.S)((0,H.W)(et),lt[0]),lt[1]-1);if(dt===1/0)return(0,Y.F)((0,it.S)((0,H.W)(et),lt[1]),lt[0]);if(dt===-1/0)return(0,R.V)((0,it.S)((0,H.W)(et),lt[1]),lt[0]);if("fro"===dt||"euclidean"===dt)return(0,Z._)((0,it.S)((0,G.h)(et),lt));throw new Error(`Error in norm: invalid ord value: ${dt}`)}throw new Error(`Error in norm: invalid axis: ${lt}`)}const st=(0,W.op)({norm_:function wt(et,dt="euclidean",lt=null,St=!1){const q=K(et=(0,$._1)(et,"x","norm"),dt,lt);let ft=q.shape;if(St){const pt=(0,V.EC)(lt,et.shape);ft=Q.rv(q.shape,pt)}return(0,A.X)(q,ft)}})},4015:(Lt,ut,y)=>{"use strict";y.d(ut,{Q:()=>k});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239);const k=(0,y(4195).op)({notEqual_:function W(A,X){let Z=(0,Q._1)(A,"a","notEqual","string_or_numeric"),G=(0,Q._1)(X,"b","notEqual","string_or_numeric");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V.yQU,{a:Z,b:G})}})},5618:(Lt,ut,y)=>{"use strict";y.d(ut,{l:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({oneHot_:function Y(W,k,A=1,X=0,Z="int32"){if(k<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${k}`);const it={indices:(0,H._1)(W,"indices","oneHot","int32")};return $.BV.runKernel(V.we_,it,{dtype:Z,depth:k,onValue:A,offValue:X})}})},4968:(Lt,ut,y)=>{"use strict";y.d(ut,{i:()=>Y});var $=y(687),V=y(5359),H=y(3037),Q=y(6467);function Y(R,W="float32"){if((0,V.Mu)(R),"complex64"===W){const A=Y(R,"float32"),X=(0,Q.l)(R,"float32");return(0,H.P)(A,X)}const k=(0,V.p8)((0,V.NA)(R),W);return $.BV.makeTensor(k,R,W)}},5034:(Lt,ut,y)=>{"use strict";y.d(ut,{J:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({onesLike_:function Y(W){const A={x:(0,H._1)(W,"x","onesLike")};return $.BV.runKernel(V.qWM,A)}})},4195:(Lt,ut,y)=>{"use strict";y.d(ut,{op:()=>Q,z:()=>H});var $=y(687),V=y(5359);const H="__op";function Q(Y){const R=Object.keys(Y);if(1!==R.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${R.length} keys.`);let W=R[0];const k=Y[W];W.endsWith("_")&&(W=W.substring(0,W.length-1)),W+=H;const A=(...X)=>{$.BV.startScope(W);try{const Z=k(...X);return(0,V.tI)(Z)&&console.error("Cannot return a Promise inside of tidy."),$.BV.endScope(Z),Z}catch(Z){throw $.BV.endScope(null),Z}};return Object.defineProperty(A,"name",{value:W,configurable:!0}),A}},3667:(Lt,ut,y)=>{"use strict";y.d(ut,{zvA:()=>X.z,WnP:()=>V.W,Khb:()=>H.K,__u:()=>Q._,IHx:()=>Y.I,QBD:()=>G,$6P:()=>it.$,YjB:()=>wt.Y,NqF:()=>K.N,vHJ:()=>st.v,ZRM:()=>et.Z,VfV:()=>dt.V,z4N:()=>lt.z,fvJ:()=>St.f,C80:()=>q.C,wS1:()=>ft.w,uR5:()=>at,zEQ:()=>Mt,tgs:()=>re.t,Dxk:()=>ee,JY5:()=>se,p3b:()=>Me,E4h:()=>It.E,yE8:()=>Ue,ycw:()=>Tn,anm:()=>D,XsQ:()=>ne,UFq:()=>pe.U,f3b:()=>Ie.f,pju:()=>pt.p,mDi:()=>Je.m,iUl:()=>Wn.i,d9v:()=>Er.d,PYB:()=>Nn.P,zoF:()=>nt.z,gME:()=>hi,Izb:()=>to,MNy:()=>yn,ZaL:()=>xo,PAt:()=>Gn.P,Tek:()=>Hs.T,bc:()=>Ce.b,pdZ:()=>Rt,$QV:()=>ie,mCk:()=>ze.m,f9Y:()=>Oe.f,mew:()=>cr,$Gn:()=>je.$,zbp:()=>Xt.z,ppE:()=>ue,nTT:()=>en.n,B10:()=>mn.B,Ka3:()=>ir,WmZ:()=>dr.W,hiC:()=>zn.h,NTj:()=>_n.N,AKD:()=>sr.A,rvX:()=>ea,WYO:()=>qn,pyx:()=>br.p,GRh:()=>da,EDe:()=>si,DgJ:()=>kr.D,qNN:()=>tr.q,d2q:()=>Zi.d,Qqt:()=>fi.Q,dt4:()=>oi.d,t$B:()=>zr.t,iyy:()=>Es,kp_:()=>Ha.k,hlL:()=>Ks.h,GWj:()=>Rs.G,qPi:()=>ti.q,imm:()=>$,Iqj:()=>Vr.I,dbB:()=>qi,pjt:()=>Eo.p,brS:()=>Ls.b,Sxn:()=>Ca.S,asL:()=>Ma.a,BHj:()=>tl,V3u:()=>Il,wx0:()=>Qs.w,xVT:()=>rs.x,UWc:()=>Pa.U,i2d:()=>eo.i,hi7:()=>Co.h,d9m:()=>gs.d,zN1:()=>Ua.z,$r2:()=>z1,SX3:()=>bu,G9k:()=>Oa.G,cM7:()=>$r.c,Krr:()=>pr.K,e_t:()=>du.e,CmS:()=>Xs.C,l_t:()=>Wa.l,HvI:()=>ys.H,hJK:()=>An.h,K5V:()=>Gr.K,egP:()=>Qn.e,MB5:()=>V1,eab:()=>Yu,OI3:()=>Gt.O,Fp7:()=>ga.F,_sB:()=>Xn._,YQQ:()=>Yi,Ip$:()=>an,gWQ:()=>ei.g,J69:()=>Fn.J,ry_:()=>ks,VV$:()=>Ur.V,LTh:()=>We.L,VdP:()=>Kr.V,wQq:()=>mr.w,Gi7:()=>Wr,p_:()=>ye,dC7:()=>O.d,rq4:()=>ss,SJ_:()=>Fo,W76:()=>Or.W,KOy:()=>mt.K,Quu:()=>os.Q,lfX:()=>_e.l,iUs:()=>Ss.i,JpU:()=>z.J,op:()=>X.op,N2O:()=>M,vku:()=>tt.v,pNR:()=>At,koy:()=>kt,t1L:()=>nn,lGY:()=>$e,d_R:()=>Cn.d,sQ3:()=>$n.s,AL3:()=>Vn.A,S0v:()=>vr.S,WVs:()=>bn.W,$gW:()=>ni,VT$:()=>Xr,N89:()=>Iu,TN_:()=>Qi,wzB:()=>Ir,nGf:()=>Hr,ruB:()=>he,LGj:()=>Hl,pe5:()=>Br,w6H:()=>es,kwC:()=>nu.k,M25:()=>ru.M,UYe:()=>us.U,btT:()=>Fs.b,XLQ:()=>ot.X,GYS:()=>ya.G,SDf:()=>va,diP:()=>qo,sx7:()=>Ao,mG2:()=>ua,QEs:()=>ta.Q,NMM:()=>_a.N,bp0:()=>ls.b,iD$:()=>mo.i,snQ:()=>sn,zcT:()=>bo,U8D:()=>iu.U,U_I:()=>Ys.U,ODp:()=>mi,XD2:()=>Ct.X,Xxe:()=>yi.X,tdS:()=>Mh,O$l:()=>La.O,R_K:()=>Su.R,tPi:()=>yt.t,jZU:()=>pl,SmN:()=>Uo,CnO:()=>Du,p0P:()=>Wo,XAC:()=>Ea.X,Wvh:()=>Tu.W,fBT:()=>mu.f,rVs:()=>U1,ers:()=>Nr,uN7:()=>wy,Vl2:()=>go.V,_b3:()=>ka._,h62:()=>Kn.h,$i:()=>gu.$,L9e:()=>Io.L,knu:()=>cs.k,Nbs:()=>So.N,NXj:()=>la.N,Z_8:()=>Lc,luU:()=>Pr.l,Smz:()=>ns.S,ORZ:()=>wl.O,AEp:()=>vt.A,XeE:()=>Nu.X,RRF:()=>hs,odF:()=>ca,wOQ:()=>no.w,yXz:()=>jl,Bfx:()=>ja,xZs:()=>Yr,Pg0:()=>or,Gg6:()=>js.G,hg7:()=>bs.h,p4s:()=>j.p,Xu6:()=>ri,Two:()=>ds.T,pUJ:()=>gt.p,HHK:()=>ct.H,GaM:()=>_t,VD$:()=>Nt,arb:()=>Kt.a,itS:()=>xe,lls:()=>Pe.l,P84:()=>fn.P});var $={};y.r($),y.d($,{conv2d:()=>l,depthwiseConv2d:()=>C,matMul:()=>rt});var V=y(6989),H=y(1184),Q=y(5622),Y=y(7066),R=y(687),W=y(4251),k=y(1257),A=y(5359),X=y(4195);const G=(0,X.op)({addN_:function Z(Ht){A.hu(Array.isArray(Ht),()=>"The argument passed to tf.addN() must be a list of tensors"),A.hu(Ht.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${Ht.length}`);const Vt=Ht.map((Zt,Jt)=>(0,k._1)(Zt,`tensors${Jt}`,"addN")),$t=Vt[0];return Vt.forEach(Zt=>{if(Zt.dtype!==$t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),Vt.forEach(Zt=>{if(!A.cO(Zt.shape,$t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),R.BV.runKernel(W.Xze,Vt)}});var it=y(1862),wt=y(876),K=y(5784),st=y(8340),et=y(586),dt=y(8355),lt=y(7881),St=y(5825),q=y(7932),ft=y(6903),pt=y(3062),B=y(5551),ot=y(5715);const at=(0,X.op)({avgPool3d_:function P(Ht,Vt,$t,Ut,Zt,Jt="NDHWC"){const Qt=(0,k._1)(Ht,"x","avgPool3d","float32");let me=Qt,Fe=!1;4===Qt.rank&&(Fe=!0,me=(0,ot.X)(Qt,[1,Qt.shape[0],Qt.shape[1],Qt.shape[2],Qt.shape[3]])),A.hu(5===me.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${me.rank}.`),A.hu("NDHWC"===Jt,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${Jt}`),A.hu("number"==typeof $t&&$t>0||Array.isArray($t)&&$t[0]>0&&$t[1]>0&&$t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${$t}'`),(0,B.m)("avgPool3d",Ut,Zt);let hn=R.BV.runKernel(W._k9,{x:me},{filterSize:Vt,strides:$t,pad:Ut,dimRoundingMode:Zt,dataFormat:Jt});return hn=(0,pt.p)(hn,me.dtype),Fe?(0,ot.X)(hn,[hn.shape[1],hn.shape[2],hn.shape[3],hn.shape[4]]):hn}});var nt=y(4111),Gt=y(5592),O=y(8737),Ct=y(6139),yt=y(8317),vt=y(5987);const Mt=(0,X.op)({basicLSTMCell_:function xt(Ht,Vt,$t,Ut,Zt,Jt){const Qt=(0,k._1)(Ht,"forgetBias","basicLSTMCell"),me=(0,k._1)(Vt,"lstmKernel","basicLSTMCell"),Fe=(0,k._1)($t,"lstmBias","basicLSTMCell"),He=(0,k._1)(Ut,"data","basicLSTMCell"),ln=(0,k._1)(Zt,"c","basicLSTMCell"),hn=(0,k._1)(Jt,"h","basicLSTMCell"),nr=(0,nt.z)([He,hn],1),fr=(0,Gt.O)(nr,me),vi=(0,Y.I)(fr,Fe),Ei=vi.shape[1]/4,fs=[vi.shape[0],Ei],ou=(0,yt.t)(vi,[0,0],fs),Qe=(0,yt.t)(vi,[0,Ei],fs),Lr=(0,yt.t)(vi,[0,2*Ei],fs),ba=(0,yt.t)(vi,[0,3*Ei],fs),Ci=(0,Y.I)((0,O.d)((0,Ct.X)(ou),(0,vt.A)(Qe)),(0,O.d)(ln,(0,Ct.X)((0,Y.I)(Qt,Lr))));return[Ci,(0,O.d)((0,vt.A)(Ci),(0,Ct.X)(ba))]}});var It=y(2782),re=y(5307);const ee=(0,X.op)({batchNorm2d_:function Bt(Ht,Vt,$t,Ut,Zt,Jt){const Qt=(0,k._1)(Ht,"x","batchNorm"),me=(0,k._1)(Vt,"mean","batchNorm"),Fe=(0,k._1)($t,"variance","batchNorm");let He,ln;return null!=Zt&&(He=(0,k._1)(Zt,"scale","batchNorm")),null!=Ut&&(ln=(0,k._1)(Ut,"offset","batchNorm")),A.hu(2===Qt.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${Qt.rank}.`),A.hu(2===me.rank||1===me.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${me.rank}.`),A.hu(2===Fe.rank||1===Fe.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${Fe.rank}.`),null!=He&&A.hu(2===He.rank||1===He.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${He.rank}.`),null!=ln&&A.hu(2===ln.rank||1===ln.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${ln.rank}.`),(0,re.t)(Qt,me,Fe,ln,He,Jt)}}),se=(0,X.op)({batchNorm3d_:function jt(Ht,Vt,$t,Ut,Zt,Jt){const Qt=(0,k._1)(Ht,"x","batchNorm"),me=(0,k._1)(Vt,"mean","batchNorm"),Fe=(0,k._1)($t,"variance","batchNorm");let He,ln;return null!=Zt&&(He=(0,k._1)(Zt,"scale","batchNorm")),null!=Ut&&(ln=(0,k._1)(Ut,"offset","batchNorm")),A.hu(3===Qt.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${Qt.rank}.`),A.hu(3===me.rank||1===me.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${me.rank}.`),A.hu(3===Fe.rank||1===Fe.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${Fe.rank}.`),null!=He&&A.hu(3===He.rank||1===He.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${He.rank}.`),null!=ln&&A.hu(3===ln.rank||1===ln.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${ln.rank}.`),(0,re.t)(Qt,me,Fe,ln,He,Jt)}}),Me=(0,X.op)({batchNorm4d_:function we(Ht,Vt,$t,Ut,Zt,Jt){const Qt=(0,k._1)(Ht,"x","batchNorm"),me=(0,k._1)(Vt,"mean","batchNorm"),Fe=(0,k._1)($t,"variance","batchNorm");let He,ln;return null!=Zt&&(He=(0,k._1)(Zt,"scale","batchNorm")),null!=Ut&&(ln=(0,k._1)(Ut,"offset","batchNorm")),A.hu(4===Qt.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${Qt.rank}.`),A.hu(4===me.rank||1===me.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${me.rank}.`),A.hu(4===Fe.rank||1===Fe.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${Fe.rank}.`),null!=He&&A.hu(4===He.rank||1===He.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${He.rank}.`),null!=ln&&A.hu(4===ln.rank||1===ln.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${ln.rank}.`),(0,re.t)(Qt,me,Fe,ln,He,Jt)}}),Ue=(0,X.op)({bincount_:function Xe(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","bincount"),Zt=(0,k._1)(Vt,"weights","bincount");return A.hu("int32"===Ut.dtype,()=>`Error in bincount: input dtype must be int32, but got ${Ut.dtype}`),A.hu($t>=0,()=>`size must be non-negative, but got ${$t}.`),A.hu(Zt.size===Ut.size||0===Zt.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${Ut.shape}, weights shape: ${Zt.shape}.`),R.BV.runKernel(W.zvY,{x:Ut,weights:Zt},{size:$t})}}),Tn=(0,X.op)({bitwiseAnd_:function De(Ht,Vt){const $t=(0,k._1)(Ht,"x","bitwiseAnd"),Ut=(0,k._1)(Vt,"y","bitwiseAnd");if(!(0,A.cO)($t.shape,Ut.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${$t.shape}, y: ${Ut.shape}`);if("int32"!==$t.dtype||"int32"!==Ut.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${$t.dtype} and type of y: ${Ut.dtype}`);return R.BV.runKernel(W.hCO,{a:$t,b:Ut})}}),ne=(0,X.op)({broadcastArgs_:function On(Ht,Vt){const $t=(0,k._1)(Ht,"s0","broadcastArgs","int32"),Ut=(0,k._1)(Vt,"s1","broadcastArgs","int32");if(1!==$t.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${$t.rank}`);if(1!==Ut.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${Ut.rank}`);return R.BV.runKernel(W.eEB,{s0:$t,s1:Ut})}});var pe=y(983),Ie=y(582),Je=y(9723),Wn=y(6672),Er=y(7315),Nn=y(3037);const hi=(0,X.op)({concat1d_:function Yn(Ht){return(0,nt.z)(Ht,0)}}),to=(0,X.op)({concat2d_:function di(Ht,Vt){return(0,nt.z)(Ht,Vt)}}),yn=(0,X.op)({concat3d_:function ii(Ht,Vt){return(0,nt.z)(Ht,Vt)}}),xo=(0,X.op)({concat4d_:function Qo(Ht,Vt){return(0,nt.z)(Ht,Vt)}});var Gn=y(8577),Hs=y(4451),Ce=y(8554);const Rt=(0,X.op)({conv3d_:function Et(Ht,Vt,$t,Ut,Zt="NDHWC",Jt=[1,1,1]){const Qt=(0,k._1)(Ht,"x","conv3d"),me=(0,k._1)(Vt,"filter","conv3d");let Fe=Qt,He=!1;4===Qt.rank&&(He=!0,Fe=(0,ot.X)(Qt,[1,Qt.shape[0],Qt.shape[1],Qt.shape[2],Qt.shape[3]])),A.hu(5===Fe.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${Fe.rank}.`),A.hu(5===me.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${me.rank}.`),A.hu(Fe.shape[4]===me.shape[3],()=>`Error in conv3d: depth of input (${Fe.shape[4]}) must match input depth for filter ${me.shape[3]}.`),A.hu((0,B.jT)($t,Jt),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${$t} and dilations '${Jt}'`),A.hu("NDHWC"===Zt,()=>`Error in conv3d: got dataFormat of ${Zt} but only NDHWC is currently supported.`),A.hu((0,B.U3)(Jt),()=>"Error in conv3D: Dilated rates should be larger than 0."),A.hu((0,B.U3)($t),()=>"Error in conv3D: Strides should be larger than 0.");const nr=R.BV.runKernel(W.x12,{x:Fe,filter:me},{strides:$t,pad:Ut,dataFormat:Zt,dilations:Jt});return He?(0,ot.X)(nr,[nr.shape[1],nr.shape[2],nr.shape[3],nr.shape[4]]):nr}});var te=y(7022);const ie=(0,X.op)({conv3dTranspose_:function oe(Ht,Vt,$t,Ut,Zt){const Jt=(0,k._1)(Ht,"x","conv3dTranspose"),Qt=(0,k._1)(Vt,"filter","conv3dTranspose");return(0,te._)($t,Jt,Qt,Ut,Zt)}});var ze=y(9018),Oe=y(3237),je=y(9267),Xt=y(7157);const ue=(0,X.op)({denseBincount_:function En(Ht,Vt,$t,Ut=!1){const Zt=(0,k._1)(Ht,"x","denseBincount"),Jt=(0,k._1)(Vt,"weights","denseBincount");return A.hu("int32"===Zt.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${Zt.dtype}`),A.hu(Zt.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${Zt.rank}.`),A.hu($t>=0,()=>`size must be non-negative, but got ${$t}.`),A.hu(Jt.size===Zt.size||0===Jt.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${Zt.shape}, weights shape: ${Jt.shape}.`),R.BV.runKernel(W.QRR,{x:Zt,weights:Jt},{size:$t,binaryOutput:Ut})}});var en=y(3961),mn=y(1172);const ir=(0,X.op)({diag_:function un(Ht){const $t={x:(0,k._1)(Ht,"x","diag")};return R.BV.runKernel(W.$w,$t)}});var dr=y(2395),zn=y(3530),_n=y(4373),sr=y(5106);const qn=(0,X.op)({einsum_:function Jr(Ht,...Vt){const $t=Vt.map((Zt,Jt)=>(0,k._1)(Zt,`tensors${Jt}`,"einsum"));return R.BV.runKernel(W.$g6,$t,{equation:Ht})}});var br=y(9529);const si=(0,X.op)({ensureShape_:function Dn(Ht,Vt){const $t=(0,k._1)(Ht,"x","ensureShape","string_or_numeric");if(!(0,A.DK)($t.shape,Vt))throw new Error(`EnsureShape: Shape of tensor ${$t.shape} is not compatible with expected shape ${Vt}`);return Ht}});var kr=y(4456),tr=y(4634),Zi=y(4279),fi=y(5109),oi=y(7228),zr=y(5748),js=y(2005);const Es=(0,X.op)({eye_:function ho(Ht,Vt,$t,Ut="float32"){null==Vt&&(Vt=Ht);const Zt=(0,Ie.f)([Ht,Vt],Ut),Jt=Ht<=Vt?Ht:Vt;for(let me=0;me<Jt;++me)Zt.set(1,me,me);const Qt=(0,ot.X)(Zt.toTensor(),[Ht,Vt]);if(null==$t)return Qt;if(1===$t.length)return(0,js.G)((0,oi.d)(Qt,0),[$t[0],1,1]);if(2===$t.length)return(0,js.G)((0,oi.d)((0,oi.d)(Qt,0),0),[$t[0],$t[1],1,1]);if(3===$t.length)return(0,js.G)((0,oi.d)((0,oi.d)((0,oi.d)(Qt,0),0),0),[$t[0],$t[1],$t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${$t.length}D.`)}});var Ks=y(2787),Rs=y(8208),ti=y(1030),Vr=y(6117),Eo=y(4803),Ls=y(9886),Ma=y(1844),rs=y(8821),Pa=y(8381),eo=y(6483),Co=y(9424),gs=y(2761),Ua=y(2223);function bu(Ht,Vt,$t){if($t<=0)throw new Error("The number of values should be positive.");return R.BV.runKernel(W.e7N,{},{start:Ht,stop:Vt,num:$t})}var Oa=y(1523),$r=y(5919),pr=y(4088),du=y(4034),Xs=y(6455),Wa=y(6735),ys=y(3080),An=y(6399),Gr=y(2693),Qn=y(4574);const ma=2147483648,bo=(0,X.op)({searchSorted_:function er(Ht,Vt,$t="left"){const Ut=(0,k._1)(Ht,"sortedSequence","searchSorted"),Zt=(0,k._1)(Vt,"values","searchSorted"),Qt=Zt.shape[Zt.shape.length-1],me=(0,ot.X)(Ut,[-1,Ut.shape[Ut.shape.length-1]]),Fe=(0,ot.X)(Zt,[-1,Qt]);if(me.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(me.shape[0]!==Fe.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,A.NA)(Fe.shape)>=ma)throw new Error(`values tensor size must less than ${ma}`);if(me.shape[1]>=ma)throw new Error(`trailing dim_size must less than ${ma} for int32 output type, was ${me.shape[1]}`);return R.BV.runKernel(W.nr8,{sortedSequence:me,values:Fe},{side:$t})}});function Yu(Ht,Vt){return bo(Ht,Vt,"left")}var ga=y(3043),Xn=y(2444);const Yi=(0,X.op)({maxPool3d_:function Cs(Ht,Vt=[1,1,1],$t,Ut,Zt,Jt="NDHWC"){const Qt=(0,k._1)(Ht,"x","maxPool3d");let me=Qt,Fe=!1;4===Qt.rank&&(Fe=!0,me=(0,ot.X)(Qt,[1,Qt.shape[0],Qt.shape[1],Qt.shape[2],Qt.shape[3]])),A.hu(5===me.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${me.rank}.`),A.hu("NDHWC"===Jt,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${Jt}`),(0,B.m)("maxPool3d",Ut,Zt);const hn=R.BV.runKernel(W.OAf,{x:me},{filterSize:Vt,strides:$t,pad:Ut,dimRoundingMode:Zt,dataFormat:Jt});return Fe?(0,ot.X)(hn,[hn.shape[1],hn.shape[2],hn.shape[3],hn.shape[4]]):hn}}),an=(0,X.op)({maxPoolWithArgmax_:function Ra(Ht,Vt,$t,Ut,Zt=!1){const Qt={x:(0,k._1)(Ht,"x","maxPoolWithArgmax")},Fe=R.BV.runKernel(W.vFR,Qt,{filterSize:Vt,strides:$t,pad:Ut,includeBatchInIndex:Zt});return{result:Fe[0],indexes:Fe[1]}}});var ei=y(765),Fn=y(9357),Ss=y(4968),wo=y(4945);function ks(Ht,Vt,{indexing:$t="xy"}={}){if("xy"!==$t&&"ij"!==$t)throw new TypeError(`${$t} is not a valid third argument to meshgrid`);if(void 0===Ht)return[];let Ut=(0,k._1)(Ht,"x","meshgrid",Ht instanceof wo.es?Ht.dtype:"float32");if(void 0===Vt)return[Ut];let Zt=(0,k._1)(Vt,"y","meshgrid",Vt instanceof wo.es?Vt.dtype:"float32");const Jt=(0,A.NA)(Ut.shape),Qt=(0,A.NA)(Zt.shape);return"xy"===$t?(Ut=(0,ot.X)(Ut,[1,-1]),Zt=(0,ot.X)(Zt,[-1,1]),[(0,Gt.O)((0,Ss.i)([Qt,1],Ut.dtype),Ut),(0,Gt.O)(Zt,(0,Ss.i)([1,Jt],Zt.dtype))]):(Ut=(0,ot.X)(Ut,[-1,1]),Zt=(0,ot.X)(Zt,[1,-1]),[(0,Gt.O)(Ut,(0,Ss.i)([1,Qt],Ut.dtype)),(0,Gt.O)((0,Ss.i)([Jt,1],Zt.dtype),Zt)])}var Ur=y(9602),We=y(2684),Kr=y(4639),mr=y(1612),ai=y(929),Kn=y(7527),Pr=y(1191);const Wr=(0,X.op)({moments_:function wr(Ht,Vt=null,$t=!1){Ht=(0,k._1)(Ht,"x","moments");const Ut=(0,A.EC)(Vt,Ht.shape),Zt=(0,Fn.J)(Ht,Ut,$t);let Jt=Zt.shape;$t||(Jt=(0,ai.rv)(Zt.shape,Ut));const Qt=(0,Kn.h)((0,Pr.l)((0,pt.p)(Ht,"float32"),(0,ot.X)(Zt,Jt)));return{mean:Zt,variance:(0,Fn.J)(Qt,Ut,$t)}}}),ss=(0,X.op)({multiRNNCell_:function Ds(Ht,Vt,$t,Ut){const Zt=(0,k._1)(Vt,"data","multiRNNCell"),Jt=(0,k.sI)($t,"c","multiRNNCell"),Qt=(0,k.sI)(Ut,"h","multiRNNCell");let me=Zt;const Fe=[];for(let hn=0;hn<Ht.length;hn++){const nr=Ht[hn](me,Jt[hn],Qt[hn]);Fe.push(nr[0]),Fe.push(nr[1]),me=nr[1]}const He=[],ln=[];for(let hn=0;hn<Fe.length;hn+=2)He.push(Fe[hn]),ln.push(Fe[hn+1]);return[He,ln]}}),Fo=(0,X.op)({multinomial_:function wu(Ht,Vt,$t,Ut=!1){const Zt=(0,k._1)(Ht,"logits","multinomial"),Jt=Zt.size,Qt=Zt.rank;if(Jt<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${Jt}.`);if(Qt>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${Qt}`);$t=$t||Math.random();const Fe={logits:1===Qt?(0,ot.X)(Zt,[1,-1]):Zt},ln=R.BV.runKernel(W.NZg,Fe,{numSamples:Vt,seed:$t,normalized:Ut});return 1===Qt?(0,ot.X)(ln,[ln.size]):ln}});var Or=y(5048),os=y(4015),_e=y(5618),z=y(5034);const M=(0,X.op)({outerProduct_:function I(Ht,Vt){const $t=(0,k._1)(Ht,"v1","outerProduct"),Ut=(0,k._1)(Vt,"v2","outerProduct");A.hu(1===$t.rank&&1===Ut.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${$t.rank} and ${Ut.rank}.`);const Zt=(0,ot.X)($t,[-1,1]),Jt=(0,ot.X)(Ut,[1,-1]);return(0,Gt.O)(Zt,Jt)}});var tt=y(404);const At=(0,X.op)({pad1d_:function bt(Ht,Vt,$t=0){return(0,A.hu)(2===Vt.length,()=>"Invalid number of paddings. Must be length of 2."),(0,tt.v)(Ht,[Vt],$t)}}),kt=(0,X.op)({pad2d_:function Yt(Ht,Vt,$t=0){return(0,A.hu)(2===Vt.length&&2===Vt[0].length&&2===Vt[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,tt.v)(Ht,Vt,$t)}}),nn=(0,X.op)({pad3d_:function ae(Ht,Vt,$t=0){return(0,A.hu)(3===Vt.length&&2===Vt[0].length&&2===Vt[1].length&&2===Vt[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,tt.v)(Ht,Vt,$t)}}),$e=(0,X.op)({pad4d_:function Ye(Ht,Vt,$t=0){return(0,A.hu)(4===Vt.length&&2===Vt[0].length&&2===Vt[1].length&&2===Vt[2].length&&2===Vt[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,tt.v)(Ht,Vt,$t)}});var Cn=y(1640),$n=y(2962),Vn=y(1584),vr=y(3006),bn=y(794);const ni=(0,X.op)({raggedGather_:function _r(Ht,Vt,$t,Ut){const Zt=Ht.map((ln,hn)=>(0,k._1)(ln,`tensors${hn}`,"raggedGather","int32")),Jt=(0,k._1)(Vt,"paramsDenseValues","raggedGather"),Qt=(0,k._1)($t,"indices","raggedGather","int32"),He=R.BV.runKernel(W.dDz,{paramsNestedSplits:Zt,paramsDenseValues:Jt,indices:Qt},{outputRaggedRank:Ut});return{outputNestedSplits:He.slice(0,He.length-1),outputDenseValues:He[He.length-1]}}}),Xr=(0,X.op)({raggedRange_:function Zs(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"starts","raggedRange"),Zt=(0,k._1)(Vt,"limits","raggedRange",Ut.dtype),Jt=(0,k._1)($t,"deltas","raggedRange",Ut.dtype),me=R.BV.runKernel(W.CQl,{starts:Ut,limits:Zt,deltas:Jt});return{rtNestedSplits:me[0],rtDenseValues:me[1]}}}),Iu=(0,X.op)({raggedTensorToTensor_:function tn(Ht,Vt,$t,Ut,Zt){const Jt=(0,k._1)(Ht,"shape","raggedTensorToTensor","int32"),Qt=(0,k._1)(Vt,"values","raggedTensorToTensor"),me=(0,k._1)($t,"defaultValue","raggedTensorToTensor",Qt.dtype),Fe=Ut.map((hn,nr)=>(0,k._1)(hn,`tensors${nr}`,"raggedTensorToTensor","int32"));return R.BV.runKernel(W.BiW,{shape:Jt,values:Qt,defaultValue:me,rowPartitionTensors:Fe},{rowPartitionTypes:Zt})}}),Qi=(0,X.op)({rand_:function xr(Ht,Vt,$t){(0,A.Mu)(Ht);const Ut=(0,A.NA)(Ht);let Zt=null;if(null==$t||"float32"===$t)Zt=new Float32Array(Ut);else if("int32"===$t)Zt=new Int32Array(Ut);else{if("bool"!==$t)throw new Error(`Unknown data type ${$t}`);Zt=new Uint8Array(Ut)}for(let Jt=0;Jt<Ut;Jt++)Zt[Jt]=Vt();return R.BV.makeTensor(Zt,Ht,$t)}});var fo=y(9128);class vs{constructor(Vt,$t,Ut,Zt,Jt){this.mean=Vt,this.stdDev=$t,this.dtype=Ut,this.nextVal=NaN,this.truncated=Zt,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const Qt=Jt||Math.random();this.random=fo.alea(Qt.toString())}nextValue(){if(!isNaN(this.nextVal)){const Zt=this.nextVal;return this.nextVal=NaN,Zt}let Vt,$t,Ut=!1;for(;!Ut;){let Zt,Jt,Qt;do{Zt=2*this.random()-1,Jt=2*this.random()-1,Qt=Zt*Zt+Jt*Jt}while(Qt>=1||0===Qt);const me=Math.sqrt(-2*Math.log(Qt)/Qt);Vt=this.mean+this.stdDev*Zt*me,$t=this.mean+this.stdDev*Jt*me,(!this.truncated||this.isValidTruncated(Vt))&&(Ut=!0)}return(!this.truncated||this.isValidTruncated($t))&&(this.nextVal=this.convertValue($t)),this.convertValue(Vt)}convertValue(Vt){return null==this.dtype||"float32"===this.dtype?Vt:Math.round(Vt)}isValidTruncated(Vt){return Vt<=this.upper&&Vt>=this.lower}}class Lu{constructor(Vt,$t,Ut,Zt){this.alpha=Vt,this.beta=1/$t,this.dtype=Ut;const Jt=Zt||Math.random();this.randu=fo.alea(Jt.toString()),this.randn=new vs(0,1,Ut,!1,this.randu()),this.d=Vt<1?Vt+2/3:Vt-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let Vt,$t,Ut,Zt,Jt,Qt;for(;;){do{Zt=this.randn.nextValue(),Qt=1+this.c*Zt}while(Qt<=0);if(Qt*=Qt*Qt,Vt=Zt*Zt,$t=1-.331*Vt*Vt,Ut=.5*Vt+this.d*(1-Qt+Math.log(Qt)),Jt=this.randu(),Jt<$t||Math.log(Jt)<Ut)break}return Qt*=1/this.beta*this.d,this.alpha<1&&(Qt*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(Qt)}convertValue(Vt){return"float32"===this.dtype?Vt:Math.round(Vt)}}class Oc{constructor(Vt=0,$t=1,Ut,Zt){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=Vt,this.range=$t-Vt,this.dtype=Ut,null==Zt&&(Zt=Math.random()),"number"==typeof Zt&&(Zt=Zt.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${Vt} - ${$t} <= 1 and dtype is not float`);this.random=fo.alea(Zt)}convertValue(Vt){return this.canReturnFloat()?Vt:Math.round(Vt)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ir=(0,X.op)({randomGamma_:function Gl(Ht,Vt,$t=1,Ut="float32",Zt){if((0,A.Mu)(Ht),null==$t&&($t=1),null==Ut&&(Ut="float32"),"float32"!==Ut&&"int32"!==Ut)throw new Error(`Unsupported data type ${Ut}`);const Jt=new Lu(Vt,$t,Ut,Zt),Qt=(0,Ie.f)(Ht,Ut);for(let me=0;me<Qt.values.length;me++)Qt.values[me]=Jt.nextValue();return Qt.toTensor()}}),Hr=(0,X.op)({randomNormal_:function pu(Ht,Vt=0,$t=1,Ut,Zt){if((0,A.Mu)(Ht),null!=Ut&&"bool"===Ut)throw new Error(`Unsupported data type ${Ut}`);const Jt=new vs(Vt,$t,Ut,!1,Zt),Qt=(0,Ie.f)(Ht,Ut);for(let me=0;me<Qt.values.length;me++)Qt.values[me]=Jt.nextValue();return Qt.toTensor()}}),he=(0,X.op)({randomStandardNormal_:function Qu(Ht,Vt,$t){if(null!=Vt&&"bool"===Vt)throw new Error(`Unsupported data type ${Vt}`);return Hr(Ht,0,1,Vt,$t)}}),Hl=(0,X.op)({randomUniform_:function Bo(Ht,Vt=0,$t=1,Ut="float32",Zt){(0,A.Mu)(Ht);const Jt=(0,Ie.f)(Ht,Ut),Qt=new Oc(Vt,$t,null,Zt);for(let me=0;me<Jt.values.length;me++)Jt.values[me]=Qt.nextValue();return Jt.toTensor()}}),Br=(0,X.op)({randomUniformInt_:function ku(Ht,Vt,$t,Ut){return Hl(Ht,Vt,$t,"int32",Ut)}});function es(Ht,Vt,$t=1,Ut="float32"){if(0===$t)throw new Error("Cannot have a step of zero");return R.BV.runKernel(W.e6w,{},{start:Ht,stop:Vt,step:$t,dtype:Ut})}var nu=y(6027),ru=y(4831),us=y(8586),Fs=y(4917),ya=y(6825);const va=(0,X.op)({reverse1d_:function zo(Ht){const Vt=(0,k._1)(Ht,"x","reverse");return A.hu(1===Vt.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${Vt.rank}.`),(0,ya.G)(Vt,0)}}),qo=(0,X.op)({reverse2d_:function po(Ht,Vt){const $t=(0,k._1)(Ht,"x","reverse");return A.hu(2===$t.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${$t.rank}.`),(0,ya.G)($t,Vt)}}),Ao=(0,X.op)({reverse3d_:function Hn(Ht,Vt){const $t=(0,k._1)(Ht,"x","reverse");return A.hu(3===$t.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${$t.rank}.`),(0,ya.G)($t,Vt)}}),ua=(0,X.op)({reverse4d_:function Mn(Ht,Vt){const $t=(0,k._1)(Ht,"x","reverse");return A.hu(4===$t.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${$t.rank}.`),(0,ya.G)($t,Vt)}});var _a=y(1974),ls=y(8893),mo=y(8661),iu=y(9614),Ys=y(6762),$s=y(5861);function xa(){return(xa=(0,$s.Z)(function*(Ht,Vt){const $t=(0,k._1)(Ht,"x","setdiff1d"),Ut=(0,k._1)(Vt,"y","setdiff1d");A.hu($t.dtype===Ut.dtype,()=>`x and y should have the same dtype, but got x (${$t.dtype}) and y (${Ut.dtype}).`),A.hu(1===$t.rank,()=>`x should be 1D tensor, but got x (${$t.shape}).`),A.hu(1===Ut.rank,()=>`y should be 1D tensor, but got y (${Ut.shape}).`);const Zt=yield $t.data(),Jt=yield Ut.data(),Qt=new Set(Jt);let me=0;for(let ln=0;ln<Zt.length;ln++)Qt.has(Zt[ln])||me++;const Fe=new wo.YD([me],$t.dtype),He=new wo.YD([me],"int32");for(let ln=0,hn=0;ln<Zt.length;ln++)Qt.has(Zt[ln])||(Fe.values[hn]=Zt[ln],He.values[hn]=ln,hn++);return[Fe.toTensor(),He.toTensor()]})).apply(this,arguments)}const mi=function Vo(Ht,Vt){return xa.apply(this,arguments)};var yi=y(4058),La=y(2438),Su=y(319);const pl=(0,X.op)({slice1d_:function Ga(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","slice1d");return A.hu(1===Ut.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${Ut.rank} tensor`),(0,yt.t)(Ut,[Vt],[$t])}}),Uo=(0,X.op)({slice2d_:function Jo(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","slice2d");return A.hu(2===Ut.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${Ut.rank} tensor`),(0,yt.t)(Ut,Vt,$t)}}),Du=(0,X.op)({slice3d_:function Ts(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","slice3d");return A.hu(3===Ut.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${Ut.rank} tensor`),(0,yt.t)(Ut,Vt,$t)}}),Wo=(0,X.op)({slice4d_:function Bs(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"x","slice4d");return A.hu(4===Ut.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${Ut.rank} tensor`),(0,yt.t)(Ut,Vt,$t)}});var Ea=y(8683),Tu=y(4487),mu=y(9619),Ha=y(9738),Ca=y(527),Qs=y(6065),ta=y(1638),go=y(8874),ka=y(930),gu=y(9539),Io=y(2494),cs=y(7958),So=y(6034),la=y(5367),ns=y(9929),wl=y(2500),Nu=y(3905),Go=y(7431);function hs(Ht,Vt){(0,A.Cq)(Ht);const $t=(0,k.C)(Ht,Vt);if(1!==$t.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,Go.H)(Ht,null,$t,Vt)}function ca(Ht,Vt,$t){if((0,A.Cq)(Ht),null!=Vt&&2!==Vt.length)throw new Error("tensor2d() requires shape to have two numbers");const Ut=(0,k.C)(Ht,$t);if(2!==Ut.length&&1!==Ut.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===Ut.length&&null==Vt)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,Go.H)(Ht,Vt,Ut,$t)}var no=y(2786);function jl(Ht,Vt,$t){if((0,A.Cq)(Ht),null!=Vt&&4!==Vt.length)throw new Error("tensor4d() requires shape to have four numbers");const Ut=(0,k.C)(Ht,$t);if(4!==Ut.length&&1!==Ut.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===Ut.length&&null==Vt)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,Go.H)(Ht,Vt,Ut,$t)}function ja(Ht,Vt,$t){if((0,A.Cq)(Ht),null!=Vt&&5!==Vt.length)throw new Error("tensor5d() requires shape to have five numbers");const Ut=(0,k.C)(Ht,$t);if(5!==Ut.length&&1!==Ut.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===Ut.length&&null==Vt)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,Go.H)(Ht,Vt,Ut,$t)}function Yr(Ht,Vt,$t){if((0,A.Cq)(Ht),null!=Vt&&6!==Vt.length)throw new Error("tensor6d() requires shape to have six numbers");const Ut=(0,k.C)(Ht,$t);if(6!==Ut.length&&1!==Ut.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===Ut.length&&null==Vt)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return(0,Go.H)(Ht,Vt=Vt||Ut,Ut,$t)}var ha=y(1876);const or=(0,X.op)({tensorScatterUpdate_:function yu(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"tensor","tensorScatterupdate"),Zt=(0,k._1)(Vt,"indices","tensorScatterupdate","int32"),Jt=(0,k._1)($t,"updates","tensorScatterupdate");if(ha.validateInput(Jt,Zt,Ut.shape),Ut.dtype!==Jt.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${Ut.dtype} and ${Jt.dtype}.`);return R.BV.runKernel(W.SIB,{tensor:Ut,indices:Zt,updates:Jt},{})}});var bs=y(4927);const ri=(0,X.op)({truncatedNormal_:function Tr(Ht,Vt=0,$t=1,Ut,Zt){if((0,A.Mu)(Ht),null!=Ut&&"bool"===Ut)throw new Error("Unsupported data type $ { dtype }");const Jt=new vs(Vt,$t,Ut,!0,Zt),Qt=(0,Ie.f)(Ht,Ut);for(let me=0;me<Qt.values.length;me++)Qt.values[me]=Jt.nextValue();return Qt.toTensor()}});var ds=y(8130),gt=y(7715),ct=y(2219);function _t(Ht,Vt){return bo(Ht,Vt,"right")}function Nt(Ht,Vt=!0,$t,Ut){return R.BV.makeVariable(Ht,Vt,$t,Ut)}var Kt=y(2190),de=y(7349);function Te(){return(Te=(0,$s.Z)(function*(Ht){const Vt=(0,k._1)(Ht,"condition","whereAsync","bool"),$t=yield Vt.data(),Ut=(0,de.Z)(Vt.shape,$t);return Ht!==Vt&&Vt.dispose(),Ut})).apply(this,arguments)}const xe=function Ee(Ht){return Te.apply(this,arguments)};var Pe=y(6467),fn=y(3143);function E(){return(E=(0,$s.Z)(function*(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"tensor","boolMask"),Zt=(0,k._1)(Vt,"mask","boolMask","bool"),Jt=$t??0,Qt=Zt.rank,me=Ut.shape;A.hu(Qt>0,()=>"mask cannot be scalar"),A.k5(me.slice(Jt,Jt+Qt),Zt.shape,"mask's shape must match the first K dimensions of tensor's shape,");let Fe=1;for(let is=Jt;is<Jt+Qt;is++)Fe*=me[is];const He=me.slice(0,Jt).concat([Fe],me.slice(Jt+Qt)),ln=(0,ot.X)(Ut,He),hn=(0,ot.X)(Zt,[-1]),nr=yield xe(hn),fr=(0,Io.L)(nr,[1]),vi=(0,Vr.I)(ln,fr,Jt);return Ht!==Ut&&Ut.dispose(),Vt!==Zt&&Zt.dispose(),fr.dispose(),ln.dispose(),hn.dispose(),nr.dispose(),vi})).apply(this,arguments)}const D=function f(Ht,Vt,$t){return E.apply(this,arguments)};var j=y(9194),mt=y(3717),Ft=y(7664);const ye=(0,X.op)({movingAverage_:function ce(Ht,Vt,$t,Ut,Zt=!0){const Jt=(0,k._1)(Ht,"v","movingAverage"),Qt=(0,k._1)(Vt,"x","movingAverage"),me=(0,k._1)($t,"decay","movingAverage");(0,Ft.assertTypesMatch)(Jt,Qt),A.hu(A.cO(Jt.shape,Qt.shape),()=>"Shape mismatch in v and x");const Fe=(0,mo.i)(1),He=(0,Pr.l)(Fe,me);let ln=(0,O.d)((0,Pr.l)(Qt,Jt),He);if(Zt){A.hu(null!=Ut,()=>"When using zeroDebias: true, step is required.");const hn=(0,k._1)(Ut,"step","movingAverage");ln=(0,zn.h)(ln,(0,Pr.l)(Fe,(0,$n.s)(me,hn)))}return(0,Y.I)(Jt,ln)}}),sn=(0,X.op)({scatterND_:function Ve(Ht,Vt,$t){(0,A.Mu)($t);const Ut=(0,k._1)(Ht,"indices","scatterND","int32"),Zt=(0,k._1)(Vt,"updates","scatterND");return ha.validateInput(Zt,Ut,$t),R.BV.runKernel(W.xQA,{indices:Ut,updates:Zt},{shape:$t})}}),Nr=(0,X.op)({sparseToDense_:function Pn(Ht,Vt,$t,Ut=0){(0,A.Mu)($t);const Zt=(0,k._1)(Ht,"sparseIndices","sparseToDense","int32"),Jt=(0,k._1)(Vt,"sparseValues","sparseToDense","string_or_numeric"),Qt=(0,k._1)(Ut,"defaultValue","sparseToDense",Jt.dtype);return function wn(Ht,Vt,$t,Ut){if("int32"!==Ht.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${Ht.dtype}.`);if(Ht.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${Ht.shape}.`);const Zt=Ht.rank>0?Ht.shape[0]:1,Jt=Ht.rank>1?Ht.shape[1]:1;if($t.length!==Jt)throw new Error(`outputShape has incorrect number of elements:, ${$t.length}, should be: ${Jt}.`);if(0!==Vt.rank&&(1!==Vt.rank||Vt.size!==Zt))throw new Error(`sparseValues has incorrect shape ${Vt.shape}, should be [] or [${Zt}]`);if(Vt.dtype!==Ut.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(Zt,Jt,$t,Qt),R.BV.runKernel(W.D2d,{sparseIndices:Zt,sparseValues:Jt,defaultValue:Qt},{outputShape:$t})}}),qi=(0,X.op)({gatherND_:function yo(Ht,Vt){const $t=(0,k._1)(Vt,"indices","gatherND","int32"),Zt={params:(0,k._1)(Ht,"x","gatherND","string_or_numeric"),indices:$t};return R.BV.runKernel(W.q1x,Zt)}}),ea=(0,X.op)({dropout_:function Ho(Ht,Vt,$t,Ut){const Zt=(0,k._1)(Ht,"x","dropout");if(A.hu("float32"===Zt.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${Zt.dtype} tensor instead.`),A.hu(Vt>=0&&Vt<1,()=>`rate must be a float in the range [0, 1), but got ${Vt}.`),0===Vt)return Ht instanceof wo.es?Zt.clone():Zt;const Jt=function ro(Ht,Vt){if(null==Vt)return Ht.shape.slice();if(A.cO(Ht.shape,Vt))return Vt;if(Ht.shape.length===Vt.length){const $t=[];for(let Ut=0;Ut<Ht.shape.length;Ut++)$t.push(null==Vt[Ut]&&null!=Ht.shape[Ut]?Ht.shape[Ut]:Vt[Ut]);return $t}return Vt}(Zt,$t),Qt=1-Vt,me=(0,zn.h)((0,Rs.G)((0,Y.I)(Hl(Jt,0,1,"float32",Ut),Qt)),Qt);return(0,O.d)(Zt,me)}});function da(Ht){return Math.floor(Math.pow(2,Math.ceil(Math.log(Ht)/Math.log(2))))}function cr(Ht,Vt,$t){const Ut=1-Ht%2,Zt=new Float32Array(Ht);for(let Jt=0;Jt<Ht;++Jt){const Qt=2*Math.PI*Jt/(Ht+Ut-1);Zt[Jt]=Vt-$t*Math.cos(Qt)}return hs(Zt,"float32")}function Rr(){return(Rr=(0,$s.Z)(function*(Ht,Vt,$t=1){const Ut=(0,k._1)(Ht,"predictions","inTopK"),Zt=(0,k._1)(Vt,"targets","inTopK");(0,A.hu)(Ut.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${Ut.rank}`),(0,A.hu)(Ut.rank-1===Zt.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${Ut.rank} and targets rank ${Zt.rank}`),(0,A.k5)(Ut.shape.slice(0,Ut.shape.length-1),Zt.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const Jt=Ut.shape[Ut.shape.length-1];(0,A.hu)($t>0&&$t<=Jt,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${Jt}), but got ${$t}`);const Qt=yield Ut.data(),me=yield Zt.data(),[Fe,He]=[Qt.length/Jt,Jt],ln=(0,A.WP)("bool",Fe);for(let hn=0;hn<Fe;hn++){const nr=hn*He,fr=Qt.subarray(nr,nr+He),vi=[];for(let is=0;is<fr.length;is++)vi.push({value:fr[is],index:is});vi.sort((is,Ei)=>Ei.value-is.value),ln[hn]=0;for(let is=0;is<$t;is++)if(vi[is].index===me[hn]){ln[hn]=1;break}}return Ht!==Ut&&Ut.dispose(),Vt!==Zt&&Zt.dispose(),(0,Nu.X)(ln,Zt.shape,"bool")})).apply(this,arguments)}const Il=function su(Ht,Vt){return Rr.apply(this,arguments)};var qs=y(3537),Ns=y(3239),ws=y(443),Is=y(5743),na=y(6254);const l=(0,X.op)({fusedConv2d_:function qu({x:Ht,filter:Vt,strides:$t,pad:Ut,dataFormat:Zt="NHWC",dilations:Jt=[1,1],dimRoundingMode:Qt,bias:me,activation:Fe="linear",preluActivationWeights:He,leakyreluAlpha:ln}){if(!1===(0,na.uy)(R.BV.state.gradientDepth,Fe=Fe||"linear")){A.hu("NHWC"===Zt,()=>`Error in fused conv2d: got dataFormat of ${Zt} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Ci=(0,Hs.T)(Ht,Vt,$t,Ut,Zt,Jt,Qt);return null!=me&&(Ci=(0,Y.I)(Ci,me)),(0,na.QH)(Ci,Fe,He,ln)}const hn=(0,k._1)(Ht,"x","conv2d","float32"),nr=(0,k._1)(Vt,"filter","conv2d","float32");let fr=hn,vi=!1;3===hn.rank&&(vi=!0,fr=(0,ot.X)(hn,[1,hn.shape[0],hn.shape[1],hn.shape[2]])),A.hu(4===fr.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${fr.rank}.`),A.hu(4===nr.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${nr.rank}.`),B.m("fused conv2d",Ut,Qt);const is="NHWC"===Zt?fr.shape[3]:fr.shape[1];A.hu(nr.shape[2]===is,()=>`Error in conv2d: depth of input (${is}) must match input depth for filter ${nr.shape[2]}.`),A.hu(B.jT($t,Jt),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${$t} and dilations '${Jt}'`);const Ei=B.Ix(fr.shape,nr.shape,$t,Jt,Ut,Qt);let fs,ou;if(null!=me&&(fs=(0,k._1)(me,"bias","fused conv2d"),[fs]=(0,Ft.makeTypesMatch)(fs,hn),"NHWC"===Zt?Ns.assertAndGetBroadcastShape(Ei.outShape,fs.shape):(A.hu(fs.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${fs.shape.length}.`),A.hu(0===fs.shape.length||fs.shape[0]===Ei.outChannels||1===fs.shape[0],()=>`Error in fused conv2d: bias shape (${fs.shape}) is not compatible with the number of output channels (${Ei.outChannels})`))),null!=He){const Ci=He.shape;if(A.hu(Ci.length<=1||3===Ci.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Ci.length}.`),1===Ci.length)A.hu(1===Ci[0]||Ci[0]===Ei.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Ci}) is not compatible with the number of output channels (${Ei.outChannels}).`);else if(3===Ci.length)try{Ns.assertAndGetBroadcastShape(Ci,Ei.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${Ci}) is not compatible with the output shape of the conv2d (${Ei.outShape}).`)}ou=(0,k._1)(He,"prelu weights","fused conv2d")}const Qe=(Ci,bi)=>{A.hu("NHWC"===Zt,()=>`Error in gradient of fused conv2D: got dataFormat of ${Zt} but only NHWC is currently supported.`);const[Mo,zs,ps,Po]=bi,$u=(0,na.Fr)(Ci,ps,Fe);A.hu(B.I0(Jt),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${Jt}'`);const Dl=[(0,Is._)(zs.shape,$u,Mo,$t,Ut),(0,ws.p)(zs,$u,Mo.shape,$t,Ut)];if(null!=Po){const wa=(0,na.pf)(Po,$u);Dl.push(wa)}return Dl},Lr={x:fr,filter:nr,bias:fs,preluActivationWeights:ou},ba={strides:$t,pad:Ut,dataFormat:Zt,dilations:Jt,dimRoundingMode:Qt,activation:Fe,leakyreluAlpha:ln};return null==me?(0,qs.cb)((bi,Mo,zs)=>{let ps=R.BV.runKernel(W._V0,Lr,ba);return zs([Mo,bi,ps]),vi&&(ps=(0,ot.X)(ps,[ps.shape[1],ps.shape[2],ps.shape[3]])),{value:ps,gradFunc:Qe}})(fr,nr):(0,qs.cb)((bi,Mo,zs,ps)=>{let Po=R.BV.runKernel(W._V0,Lr,ba);return ps([Mo,bi,Po,zs]),vi&&(Po=(0,ot.X)(Po,[Po.shape[1],Po.shape[2],Po.shape[3]])),{value:Po,gradFunc:Qe}})(fr,nr,fs)}});var h=y(366),m=y(519);const C=(0,X.op)({fusedDepthwiseConv2d_:function _({x:Ht,filter:Vt,strides:$t,pad:Ut,dataFormat:Zt="NHWC",dilations:Jt=[1,1],dimRoundingMode:Qt,bias:me,activation:Fe="linear",preluActivationWeights:He,leakyreluAlpha:ln}){if(!1===(0,na.uy)(R.BV.state.gradientDepth,Fe)){let ba=(0,mn.B)(Ht,Vt,$t,Ut,Zt,Jt,Qt);return null!=me&&(ba=(0,Y.I)(ba,me)),(0,na.QH)(ba,Fe,He,ln)}const hn=(0,k._1)(Ht,"x","depthwiseConv2d","float32"),nr=(0,k._1)(Vt,"filter","depthwiseConv2d","float32");let fr=hn,vi=!1;3===hn.rank&&(vi=!0,fr=(0,ot.X)(hn,[1,hn.shape[0],hn.shape[1],hn.shape[2]])),A.hu(4===fr.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${fr.rank}.`),A.hu(4===nr.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${nr.rank}.`),A.hu(fr.shape[3]===nr.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${fr.shape[3]}) must match the inChannels dimension in filter ${nr.shape[2]}.`),null==Jt&&(Jt=[1,1]),A.hu(B.jT($t,Jt),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${$t} and dilations '${Jt}'`),B.m("fused depthwiseConv2d",Ut,Qt);const is=B.Ix(fr.shape,nr.shape,$t,Jt,Ut,Qt,!0);let Ei,fs;null!=me&&(Ei=(0,k._1)(me,"bias","fused conv2d"),[Ei]=(0,Ft.makeTypesMatch)(Ei,hn),Ns.assertAndGetBroadcastShape(is.outShape,Ei.shape)),null!=He&&(fs=(0,k._1)(He,"prelu weights","fused depthwiseConv2d"));const ou=(ba,Ci)=>{A.hu(B.I0(Jt),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${Jt}'`);const[bi,Mo,zs,ps]=Ci,Po=(0,na.Fr)(ba,zs,Fe),$u=(0,m.v)(Mo.shape,Po,bi,$t,Ut,Jt,Qt),el=(0,h.z)(Mo,Po,bi.shape,$t,Ut,Jt,Qt);return null!=ps?[$u,el,(0,na.pf)(Ei,Po)]:[$u,el]},Qe={x:fr,filter:nr,bias:Ei,preluActivationWeights:fs},Lr={strides:$t,pad:Ut,dataFormat:Zt,dilations:Jt,dimRoundingMode:Qt,activation:Fe,leakyreluAlpha:ln};return null==me?(0,qs.cb)((Ci,bi,Mo)=>{let zs=R.BV.runKernel(W.luS,Qe,Lr);return Mo([bi,Ci,zs]),vi&&(zs=(0,ot.X)(zs,[zs.shape[1],zs.shape[2],zs.shape[3]])),{value:zs,gradFunc:ou}})(fr,nr):(0,qs.cb)((Ci,bi,Mo,zs)=>{let ps=R.BV.runKernel(W.luS,Qe,Lr);return zs([bi,Ci,ps,Mo]),vi&&(ps=(0,ot.X)(ps,[ps.shape[1],ps.shape[2],ps.shape[3]])),{value:ps,gradFunc:ou}})(fr,nr,Ei)}}),rt=(0,X.op)({fusedMatMul_:function F({a:Ht,b:Vt,transposeA:$t=!1,transposeB:Ut=!1,bias:Zt,activation:Jt="linear",preluActivationWeights:Qt,leakyreluAlpha:me=.2}){if(!1===(0,na.uy)(R.BV.state.gradientDepth,Jt)){let Po=(0,Gt.O)(Ht,Vt,$t,Ut);return null!=Zt&&(Po=(0,Y.I)(Po,Zt)),(0,na.QH)(Po,Jt,Qt,me)}let Fe=(0,k._1)(Ht,"a","fused matMul"),He=(0,k._1)(Vt,"b","fused matMul");[Fe,He]=(0,Ft.makeTypesMatch)(Fe,He);const ln=$t?Fe.shape[Fe.rank-2]:Fe.shape[Fe.rank-1],hn=Ut?He.shape[He.rank-1]:He.shape[He.rank-2],nr=$t?Fe.shape[Fe.rank-1]:Fe.shape[Fe.rank-2],fr=Ut?He.shape[He.rank-2]:He.shape[He.rank-1],vi=Fe.shape.slice(0,-2),is=He.shape.slice(0,-2),Ei=A.NA(vi),fs=A.NA(is);A.hu(ln===hn,()=>`Error in fused matMul: inner shapes (${ln}) and (${hn}) of Tensors with shapes ${Fe.shape} and ${He.shape} and transposeA=${$t} and transposeB=${Ut} must match.`);const Qe=Ns.assertAndGetBroadcastShape(Fe.shape.slice(0,-2),He.shape.slice(0,-2)).concat([nr,fr]),Lr=(0,ot.X)(Fe,$t?[Ei,ln,nr]:[Ei,nr,ln]),ba=(0,ot.X)(He,Ut?[fs,fr,hn]:[fs,hn,fr]);let Ci,bi;null!=Zt&&(Ci=(0,k._1)(Zt,"bias","fused matMul"),[Ci]=(0,Ft.makeTypesMatch)(Ci,Fe),Ns.assertAndGetBroadcastShape(Qe,Ci.shape)),null!=Qt&&(bi=(0,k._1)(Qt,"prelu weights","fused matMul"));const Mo=(Po,$u)=>{const[el,Sl,Dl,wa]=$u,au=(0,na.Fr)((0,ot.X)(Po,Dl.shape),Dl,Jt);let ah,Tl;return $t||Ut?!$t&&Ut?(ah=(0,Gt.O)(au,Sl,!1,!1),Tl=(0,Gt.O)(au,el,!0,!1)):$t&&!Ut?(ah=(0,Gt.O)(Sl,au,!1,!0),Tl=(0,Gt.O)(el,au,!1,!1)):(ah=(0,Gt.O)(Sl,au,!0,!0),Tl=(0,Gt.O)(au,el,!0,!0)):(ah=(0,Gt.O)(au,Sl,!1,!0),Tl=(0,Gt.O)(el,au,!0,!1)),null!=Zt?[ah,Tl,(0,na.pf)(wa,au)]:[ah,Tl]},zs={a:Lr,b:ba,bias:Ci,preluActivationWeights:bi},ps={transposeA:$t,transposeB:Ut,activation:Jt,leakyreluAlpha:me};return null==Zt?(0,qs.cb)(($u,el,Sl)=>{const Dl=R.BV.runKernel(W.usg,zs,ps);return Sl([$u,el,Dl]),{value:(0,ot.X)(Dl,Qe),gradFunc:Mo}})(Lr,ba):(0,qs.cb)(($u,el,Sl,Dl)=>{const wa=R.BV.runKernel(W.usg,zs,ps);return Dl([$u,el,wa,Sl]),{value:(0,ot.X)(wa,Qe),gradFunc:Mo}})(Lr,ba,Ci)}}),qt=(0,X.op)({hammingWindow_:function Dt(Ht){return cr(Ht,.54,.46)}}),ke=(0,X.op)({hannWindow_:function fe(Ht){return cr(Ht,.5,.5)}}),xn=(0,X.op)({frame_:function Ge(Ht,Vt,$t,Ut=!1,Zt=0){let Jt=0;const Qt=[];for(;Jt+Vt<=Ht.size;)Qt.push((0,yt.t)(Ht,Jt,Vt)),Jt+=$t;if(Ut)for(;Jt<Ht.size;){const me=Jt+Vt-Ht.size,Fe=(0,nt.z)([(0,yt.t)(Ht,Jt,Vt-me),(0,Ks.h)([me],Zt)]);Qt.push(Fe),Jt+=$t}return 0===Qt.length?ca([],[0,Vt]):(0,ot.X)((0,nt.z)(Qt),[Qt.length,Vt])}}),Un=(0,X.op)({stft_:function Sn(Ht,Vt,$t,Ut,Zt=ke){null==Ut&&(Ut=da(Vt));const Jt=xn(Ht,Vt,$t),Qt=(0,O.d)(Jt,Zt(Vt));return(0,ta.Q)(Qt,Ut)}}),Ji=(0,X.op)({cropAndResize_:function ur(Ht,Vt,$t,Ut,Zt="bilinear",Jt=0){const Qt=(0,k._1)(Ht,"image","cropAndResize"),me=(0,k._1)(Vt,"boxes","cropAndResize","float32"),Fe=(0,k._1)($t,"boxInd","cropAndResize","int32"),He=me.shape[0];return A.hu(4===Qt.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${Qt.rank}.`),A.hu(2===me.rank&&4===me.shape[1],()=>`Error in cropAndResize: boxes must be have size [${He},4] but had shape ${me.shape}.`),A.hu(1===Fe.rank&&Fe.shape[0]===He,()=>`Error in cropAndResize: boxInd must be have size [${He}] but had shape ${me.shape}.`),A.hu(2===Ut.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${Ut.length}.`),A.hu(Ut[0]>=1&&Ut[1]>=1,()=>`cropSize must be atleast [1,1], but was ${Ut}`),A.hu("bilinear"===Zt||"nearest"===Zt,()=>`method must be bilinear or nearest, but was ${Zt}`),R.BV.runKernel(W.VcC,{image:Qt,boxes:me,boxInd:Fe},{method:Zt,extrapolationValue:Jt,cropSize:Ut})}}),Fa=(0,X.op)({flipLeftRight_:function Do(Ht){const Vt=(0,k._1)(Ht,"image","flipLeftRight","float32");return A.hu(4===Vt.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${Vt.rank}.`),R.BV.runKernel(W.Uyb,{image:Vt},{})}}),Kl=(0,X.op)({grayscaleToRGB_:function ml(Ht){const Vt=(0,k._1)(Ht,"image","grayscaleToRGB"),$t=Vt.rank-1,Ut=Vt.shape[$t];A.hu(Vt.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${Vt.rank}.`),A.hu(1===Ut,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${Ut}.`);const Zt=new Array(Vt.rank);return Zt.fill(1,0,$t),Zt[$t]=3,(0,js.G)(Vt,Zt)}}),vS=(0,X.op)({rgbToGrayscale_:function rf(Ht){const Vt=(0,k._1)(Ht,"image","RGBToGrayscale"),Ut=Vt.shape[Vt.rank-1];A.hu(Vt.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${Vt.rank}.`),A.hu(3===Ut,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${Ut}.`);const Zt=Vt.dtype,Jt=(0,pt.p)(Vt,"float32"),Qt=hs([.2989,.587,.114]);let me;switch(Vt.rank){case 2:me=qn("ij,j->i",Jt,Qt);break;case 3:me=qn("ijk,k->ij",Jt,Qt);break;case 4:me=qn("ijkl,l->ijk",Jt,Qt);break;case 5:me=qn("ijklm,m->ijkl",Jt,Qt);break;case 6:me=qn("ijklmn,n->ijklm",Jt,Qt);break;default:throw new Error("Not a valid tensor rank.")}return me=(0,oi.d)(me,-1),(0,pt.p)(me,Zt)}}),xS=(0,X.op)({rotateWithOffset_:function _S(Ht,Vt,$t=0,Ut=.5){const Zt=(0,k._1)(Ht,"image","rotateWithOffset","float32");return A.hu(4===Zt.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${Zt.rank}.`),R.BV.runKernel(W.b9H,{image:Zt},{radians:Vt,fillValue:$t,center:Ut})}});function md(Ht,Vt,$t,Ut,Zt,Jt){null==Ut&&(Ut=.5),null==Zt&&(Zt=Number.NEGATIVE_INFINITY),null==Jt&&(Jt=0);const Qt=Ht.shape[0];return $t=Math.min($t,Qt),A.hu(0<=Ut&&Ut<=1,()=>`iouThreshold must be in [0, 1], but was '${Ut}'`),A.hu(2===Ht.rank,()=>`boxes must be a 2D tensor, but was of rank '${Ht.rank}'`),A.hu(4===Ht.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${Ht.shape[1]}`),A.hu(1===Vt.rank,()=>"scores must be a 1D tensor"),A.hu(Vt.shape[0]===Qt,()=>`scores has incompatible shape with boxes. Expected ${Qt}, but was ${Vt.shape[0]}`),A.hu(0<=Jt&&Jt<=1,()=>`softNmsSigma must be in [0, 1], but was '${Jt}'`),{maxOutputSize:$t,iouThreshold:Ut,scoreThreshold:Zt,softNmsSigma:Jt}}const iy=(0,X.op)({nonMaxSuppression_:function ry(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY){const Jt=(0,k._1)(Ht,"boxes","nonMaxSuppression","float32"),Qt=(0,k._1)(Vt,"scores","nonMaxSuppression","float32"),me=md(Jt,Qt,$t,Ut,Zt);return R.BV.runKernel(W.uv1,{boxes:Jt,scores:Qt},{maxOutputSize:$t=me.maxOutputSize,iouThreshold:Ut=me.iouThreshold,scoreThreshold:Zt=me.scoreThreshold})}});var sy=y(5672);function oy(){return(oy=(0,$s.Z)(function*(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY){const Jt=(0,k._1)(Ht,"boxes","nonMaxSuppressionAsync"),Qt=(0,k._1)(Vt,"scores","nonMaxSuppressionAsync"),me=md(Jt,Qt,$t,Ut,Zt);$t=me.maxOutputSize,Ut=me.iouThreshold,Zt=me.scoreThreshold;const Fe=yield Promise.all([Jt.data(),Qt.data()]),He=Fe[0],ln=Fe[1],{selectedIndices:hn}=(0,sy.GP)(He,ln,$t,Ut,Zt);return Jt!==Ht&&Jt.dispose(),Qt!==Vt&&Qt.dispose(),hs(hn,"int32")})).apply(this,arguments)}const CS=(0,X.op)({nonMaxSuppressionWithScore_:function Rc(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY,Jt=0){const Qt=(0,k._1)(Ht,"boxes","nonMaxSuppression"),me=(0,k._1)(Vt,"scores","nonMaxSuppression"),Fe=md(Qt,me,$t,Ut,Zt,Jt),hn=R.BV.runKernel(W.W0H,{boxes:Qt,scores:me},{maxOutputSize:$t=Fe.maxOutputSize,iouThreshold:Ut=Fe.iouThreshold,scoreThreshold:Zt=Fe.scoreThreshold,softNmsSigma:Jt=Fe.softNmsSigma});return{selectedIndices:hn[0],selectedScores:hn[1]}}});function $a(){return($a=(0,$s.Z)(function*(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY,Jt=0){const Qt=(0,k._1)(Ht,"boxes","nonMaxSuppressionAsync"),me=(0,k._1)(Vt,"scores","nonMaxSuppressionAsync"),Fe=md(Qt,me,$t,Ut,Zt,Jt);$t=Fe.maxOutputSize,Ut=Fe.iouThreshold,Zt=Fe.scoreThreshold,Jt=Fe.softNmsSigma;const He=yield Promise.all([Qt.data(),me.data()]),ln=He[0],hn=He[1],{selectedIndices:nr,selectedScores:fr}=(0,sy.pA)(ln,hn,$t,Ut,Zt,Jt);return Qt!==Ht&&Qt.dispose(),me!==Vt&&me.dispose(),{selectedIndices:hs(nr,"int32"),selectedScores:hs(fr)}})).apply(this,arguments)}const ay=(0,X.op)({nonMaxSuppressionPadded_:function gl(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY,Jt=!1){const Qt=(0,k._1)(Ht,"boxes","nonMaxSuppression"),me=(0,k._1)(Vt,"scores","nonMaxSuppression"),Fe=md(Qt,me,$t,Ut,Zt,null),vi=R.BV.runKernel(W.cye,{boxes:Qt,scores:me},{maxOutputSize:Fe.maxOutputSize,iouThreshold:Fe.iouThreshold,scoreThreshold:Fe.scoreThreshold,padToMaxOutputSize:Jt});return{selectedIndices:vi[0],validOutputs:vi[1]}}});function af(){return(af=(0,$s.Z)(function*(Ht,Vt,$t,Ut=.5,Zt=Number.NEGATIVE_INFINITY,Jt=!1){const Qt=(0,k._1)(Ht,"boxes","nonMaxSuppressionAsync"),me=(0,k._1)(Vt,"scores","nonMaxSuppressionAsync"),Fe=md(Qt,me,$t,Ut,Zt,null),He=Fe.maxOutputSize,ln=Fe.iouThreshold,hn=Fe.scoreThreshold,[nr,fr]=yield Promise.all([Qt.data(),me.data()]),{selectedIndices:vi,validOutputs:is}=(0,sy.qP)(nr,fr,He,ln,hn,Jt);return Qt!==Ht&&Qt.dispose(),me!==Vt&&me.dispose(),{selectedIndices:hs(vi,"int32"),validOutputs:(0,mo.i)(is,"int32")}})).apply(this,arguments)}var Hp=y(1265),cy=y(7373);const hy=(0,X.op)({threshold_:function jp(Ht,Vt="binary",$t=!1,Ut=.5){const Zt=(0,k._1)(Ht,"image","threshold"),Fe=Zt.shape[0]*Zt.shape[1];let ln,hn,nr,fr,He=(0,O.d)(hs([Ut]),255);if(A.hu(3===Zt.rank,()=>`Error in threshold: image must be rank 3,but got rank ${Zt.rank}.`),A.hu(3===Zt.shape[2]||1===Zt.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${Zt.shape[2]}.`),A.hu("int32"===Zt.dtype||"float32"===Zt.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${Zt.dtype}.`),A.hu("otsu"===Vt||"binary"===Vt,()=>`Method must be binary or otsu, but was ${Vt}`),3===Zt.shape[2]){[ln,hn,nr]=(0,go.V)(Zt,[1,1,1],-1);const Ei=(0,O.d)(ln,.2989),fs=(0,O.d)(hn,.587),ou=(0,O.d)(nr,.114);fr=(0,Y.I)((0,Y.I)(Ei,fs),ou)}else fr=Ht;"otsu"===Vt&&(He=function Kp(Ht,Vt){let Jt,Qt,me,Fe,He,ln,$t=hs([-1]),Ut=hs([0]),Zt=hs([0]);for(let hn=0;hn<Ht.size-1;hn++){Jt=(0,yt.t)(Ht,0,hn+1),Qt=(0,yt.t)(Ht,hn+1),He=(0,zn.h)((0,ns.S)(Jt),Vt),ln=(0,zn.h)((0,ns.S)(Qt),Vt);const nr=(0,ns.S)((0,O.d)(Jt,es(0,Jt.size)));me=(0,zn.h)(nr,(0,ns.S)(Jt));const fr=(0,Ks.h)(Qt.shape,Jt.size),vi=(0,Y.I)(es(0,Qt.size),fr),is=(0,O.d)(Qt,vi);Fe=(0,zn.h)((0,ns.S)(is),(0,ns.S)(Qt));const Ei=(0,Pr.l)(me,Fe),fs=(0,Pr.l)(me,Fe),ou=(0,O.d)(He,ln);Zt=(0,O.d)((0,O.d)(ou,Ei),fs);const Qe=(0,Eo.p)(Zt,Ut);Ut=(0,Kt.a)(Qe,Zt,Ut),$t=(0,Kt.a)(Qe,hs([hn]),$t)}return $t}(Ue((0,pt.p)((0,_a.N)(fr),"int32"),(0,Nu.X)([]),256),Fe));const vi=$t?(0,Ua.z)(fr,He):(0,Eo.p)(fr,He);return(0,pt.p)((0,O.d)(vi,255),"int32")}}),fy=(0,X.op)({transform_:function dy(Ht,Vt,$t="nearest",Ut="constant",Zt=0,Jt){const Qt=(0,k._1)(Ht,"image","transform","float32"),me=(0,k._1)(Vt,"transforms","transform","float32");return A.hu(4===Qt.rank,()=>`Error in transform: image must be rank 4,but got rank ${Qt.rank}.`),A.hu(2===me.rank&&(me.shape[0]===Qt.shape[0]||1===me.shape[0])&&8===me.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A.hu(null==Jt||2===Jt.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${Jt}.`),R.BV.runKernel(W.wx7,{image:Qt,transforms:me},{interpolation:$t,fillMode:Ut,fillValue:Zt,outputShape:Jt})}}),gd=(0,X.op)({bandPart_:function uf(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"a","bandPart");(0,A.hu)(Ut.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${Ut.rank}.`);const Zt=Ut.shape,[Jt,Qt]=Ut.shape.slice(-2);let me,Fe;"number"==typeof Vt?((0,A.hu)(Vt%1==0,()=>`bandPart(): numLower must be an integer, got ${Vt}.`),(0,A.hu)(Vt<=Jt,()=>`bandPart(): numLower (${Vt}) must not be greater than the number of rows (${Jt}).`),me=(0,k._1)(Vt<0?Jt:Vt,"numLower","bandPart")):((0,A.hu)("int32"===Vt.dtype,()=>"bandPart(): numLower's dtype must be an int32."),me=(0,Kt.a)((0,gs.d)(Vt,0),Jt,(0,We.L)(Vt,Jt))),"number"==typeof $t?((0,A.hu)($t%1==0,()=>`bandPart(): numUpper must be an integer, got ${$t}.`),(0,A.hu)($t<=Qt,()=>`bandPart(): numUpper (${$t}) must not be greater than the number of columns (${Qt}).`),Fe=(0,k._1)($t<0?Qt:$t,"numUpper","bandPart")):((0,A.hu)("int32"===$t.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),Fe=(0,Kt.a)((0,gs.d)($t,0),Qt,(0,We.L)($t,Qt)));const He=(0,ot.X)(es(0,Jt,1,"int32"),[-1,1]),ln=es(0,Qt,1,"int32"),hn=(0,Pr.l)(He,ln),nr=(0,ys.H)((0,Ua.z)(hn,me),(0,Ls.b)(hn,(0,Or.W)(Fe))),fr=(0,Pe.l)([Jt,Qt],Ut.dtype);return(0,ot.X)((0,cs.k)((0,ct.H)((0,ot.X)(Ut,[-1,Jt,Qt])).map(vi=>(0,Kt.a)(nr,vi,fr))),Zt)}}),py=(0,X.op)({gramSchmidt_:function Ah(Ht){let Vt;if(Array.isArray(Ht)){Vt=!1,(0,A.hu)(null!=Ht&&Ht.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const Zt=Ht[0].shape[0];for(let Jt=1;Jt<Ht.length;++Jt)(0,A.hu)(Ht[Jt].shape[0]===Zt,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${Ht[Jt].shape[0]} vs. ${Zt})`)}else Vt=!0,Ht=(0,go.V)(Ht,Ht.shape[0],0).map(Zt=>(0,Io.L)(Zt,[0]));(0,A.hu)(Ht.length<=Ht[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${Ht.length}) exceeds number of dimensions (${Ht[0].shape[0]}).`);const $t=[],Ut=Ht;for(let Zt=0;Zt<Ht.length;++Zt)$t.push(R.BV.tidy(()=>{let Jt=Ut[Zt];if(Zt>0)for(let Qt=0;Qt<Zt;++Qt){const me=(0,O.d)((0,ns.S)((0,O.d)($t[Qt],Jt)),$t[Qt]);Jt=(0,Pr.l)(Jt,me)}return(0,zn.h)(Jt,(0,mt.K)(Jt,"euclidean"))}));return Vt?(0,cs.k)($t,0):$t}});var wS=y(2773);function I1(Ht,Vt=!1){return R.BV.tidy(()=>{(0,A.hu)(2===Ht.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${Ht.shape.length}D Tensor.`);const $t=Ht.shape[0],Ut=Ht.shape[1];let Zt=Es($t),Jt=(0,Er.d)(Ht);const Qt=ca([[1]],[1,1]);let me=(0,Er.d)(Qt);const Fe=$t>=Ut?Ut:$t;for(let He=0;He<Fe;++He){const ln=Jt,hn=me,nr=Zt;[me,Jt,Zt]=R.BV.tidy(()=>{const fr=(0,yt.t)(Jt,[He,He],[$t-He,1]),vi=(0,mt.K)(fr),is=(0,yt.t)(Jt,[He,He],[1,1]),Ei=(0,Kt.a)((0,Eo.p)(is,0),ca([[-1]]),ca([[1]])),fs=(0,Pr.l)(is,(0,O.d)(Ei,vi)),ou=(0,zn.h)(fr,fs);me=1===ou.shape[0]?(0,Er.d)(Qt):(0,nt.z)([Qt,(0,yt.t)(ou,[1,0],[ou.shape[0]-1,ou.shape[1]])],0);const Qe=(0,Or.W)((0,zn.h)((0,Gt.O)(Ei,fs),vi)),Lr=(0,yt.t)(Jt,[He,0],[$t-He,Ut]),ba=(0,O.d)(Qe,me),Ci=(0,j.p)(me);if(0===He)Jt=(0,Pr.l)(Lr,(0,Gt.O)(ba,(0,Gt.O)(Ci,Lr)));else{const zs=(0,Pr.l)(Lr,(0,Gt.O)(ba,(0,Gt.O)(Ci,Lr)));Jt=(0,nt.z)([(0,yt.t)(Jt,[0,0],[He,Ut]),zs],0)}const bi=(0,j.p)(ba),Mo=(0,yt.t)(Zt,[0,He],[$t,Zt.shape[1]-He]);if(0===He)Zt=(0,Pr.l)(Mo,(0,Gt.O)((0,Gt.O)(Mo,me),bi));else{const zs=(0,Pr.l)(Mo,(0,Gt.O)((0,Gt.O)(Mo,me),bi));Zt=(0,nt.z)([(0,yt.t)(Zt,[0,0],[$t,He]),zs],1)}return[me,Jt,Zt]}),(0,wS.B9)([ln,hn,nr])}return!Vt&&$t>Ut&&(Zt=(0,yt.t)(Zt,[0,0],[$t,Ut]),Jt=(0,yt.t)(Jt,[0,0],[Ut,Ut])),[Zt,Jt]})}const S1=(0,X.op)({qr_:function IS(Ht,Vt=!1){if((0,A.hu)(Ht.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${Ht.rank}`),2===Ht.rank)return I1(Ht,Vt);{const $t=Ht.shape.slice(0,Ht.shape.length-2).reduce((Fe,He)=>Fe*He),Ut=(0,ct.H)((0,ot.X)(Ht,[$t,Ht.shape[Ht.shape.length-2],Ht.shape[Ht.shape.length-1]]),0),Zt=[],Jt=[];return Ut.forEach(Fe=>{const[He,ln]=I1(Fe,Vt);Zt.push(He),Jt.push(ln)}),[(0,ot.X)((0,cs.k)(Zt,0),Ht.shape),(0,ot.X)((0,cs.k)(Jt,0),Ht.shape)]}}});var Ju=y(4839);const Xl=(0,X.op)({computeWeightedLoss_:function SS(Ht,Vt,$t=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Ut=(0,k._1)(Ht,"losses","computeWeightedLoss");let Zt=null;null!=Vt&&(Zt=(0,k._1)(Vt,"weights","computeWeightedLoss"));const Jt=null==Zt?Ut:(0,O.d)(Ut,Zt);if($t===Ju.I.NONE)return Jt;if($t===Ju.I.SUM)return(0,ns.S)(Jt);if($t===Ju.I.MEAN){if(null==Zt)return(0,Fn.J)(Jt);{const Qt=Ut.size/Zt.size,me=(0,zn.h)((0,ns.S)(Jt),(0,ns.S)(Zt));return Qt>1?(0,zn.h)(me,(0,mo.i)(Qt)):me}}if($t===Ju.I.SUM_BY_NONZERO_WEIGHTS){if(null==Zt)return(0,zn.h)((0,ns.S)(Jt),(0,mo.i)(Ut.size));{const Qt=(0,O.d)(Zt,(0,Ss.i)(Ut.shape)),me=(0,pt.p)((0,ns.S)((0,os.Q)(Qt,(0,mo.i)(0))),"float32");return(0,zn.h)((0,ns.S)(Jt),me)}}throw Error(`Unknown reduction: ${$t}`)}}),D1=(0,X.op)({absoluteDifference_:function Xp(Ht,Vt,$t,Ut=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Zt=(0,k._1)(Ht,"labels","absoluteDifference"),Jt=(0,k._1)(Vt,"predictions","absoluteDifference");let Qt=null;null!=$t&&(Qt=(0,k._1)($t,"weights","absoluteDifference")),(0,A.k5)(Zt.shape,Jt.shape,"Error in absoluteDifference: ");const me=(0,V.W)((0,Pr.l)(Zt,Jt));return Xl(me,Qt,Ut)}}),DS=(0,X.op)({cosineDistance_:function Zp(Ht,Vt,$t,Ut,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Jt=(0,k._1)(Ht,"labels","cosineDistance"),Qt=(0,k._1)(Vt,"predictions","cosineDistance");let me=null;null!=Ut&&(me=(0,k._1)(Ut,"weights","cosineDistance")),(0,A.k5)(Jt.shape,Qt.shape,"Error in cosineDistance: ");const Fe=(0,mo.i)(1),He=(0,Pr.l)(Fe,(0,ns.S)((0,O.d)(Jt,Qt),$t,!0));return Xl(He,me,Zt)}}),T1=(0,X.op)({hingeLoss_:function TS(Ht,Vt,$t,Ut=Ju.I.SUM_BY_NONZERO_WEIGHTS){let Zt=(0,k._1)(Ht,"labels","hingeLoss");const Jt=(0,k._1)(Vt,"predictions","hingeLoss");let Qt=null;null!=$t&&(Qt=(0,k._1)($t,"weights","hingeLoss")),(0,A.k5)(Zt.shape,Jt.shape,"Error in hingeLoss: ");const me=(0,mo.i)(1);Zt=(0,Pr.l)((0,O.d)((0,mo.i)(2),Zt),me);const Fe=(0,us.U)((0,Pr.l)(me,(0,O.d)(Zt,Jt)));return Xl(Fe,Qt,Ut)}}),gy=(0,X.op)({huberLoss_:function my(Ht,Vt,$t,Ut=1,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Jt=(0,k._1)(Ht,"labels","huberLoss"),Qt=(0,k._1)(Vt,"predictions","huberLoss");let me=null;null!=$t&&(me=(0,k._1)($t,"weights","huberLoss")),(0,A.k5)(Jt.shape,Qt.shape,"Error in huberLoss: ");const Fe=(0,mo.i)(Ut),He=(0,V.W)((0,Pr.l)(Qt,Jt)),ln=(0,We.L)(He,Fe),hn=(0,Pr.l)(He,ln),nr=(0,Y.I)((0,O.d)((0,mo.i)(.5),(0,Kn.h)(ln)),(0,O.d)(Fe,hn));return Xl(nr,me,Zt)}}),A1=(0,X.op)({logLoss_:function N1(Ht,Vt,$t,Ut=1e-7,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Jt=(0,k._1)(Ht,"labels","logLoss"),Qt=(0,k._1)(Vt,"predictions","logLoss");let me=null;null!=$t&&(me=(0,k._1)($t,"weights","logLoss")),(0,A.k5)(Jt.shape,Qt.shape,"Error in logLoss: ");const Fe=(0,mo.i)(1),He=(0,mo.i)(Ut),ln=(0,Or.W)((0,O.d)(Jt,(0,$r.c)((0,Y.I)(Qt,He)))),hn=(0,O.d)((0,Pr.l)(Fe,Jt),(0,$r.c)((0,Y.I)((0,Pr.l)(Fe,Qt),He))),nr=(0,Pr.l)(ln,hn);return Xl(nr,me,Zt)}}),yy=(0,X.op)({meanSquaredError_:function M1(Ht,Vt,$t,Ut=Ju.I.SUM_BY_NONZERO_WEIGHTS){const Zt=(0,k._1)(Ht,"labels","meanSquaredError"),Jt=(0,k._1)(Vt,"predictions","meanSquaredError");let Qt=null;null!=$t&&(Qt=(0,k._1)($t,"weights","meanSquaredError")),(0,A.k5)(Zt.shape,Jt.shape,"Error in meanSquaredError: ");const me=(0,gu.$)(Zt,Jt);return Xl(me,Qt,Ut)}}),O1=(0,X.op)({sigmoidCrossEntropy_:function vy(Ht,Vt,$t,Ut=0,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){let Jt=(0,k._1)(Ht,"multiClassLabels","sigmoidCrossEntropy");const Qt=(0,k._1)(Vt,"logits","sigmoidCrossEntropy");let me=null;if(null!=$t&&(me=(0,k._1)($t,"weights","sigmoidCrossEntropy")),(0,A.k5)(Jt.shape,Qt.shape,"Error in sigmoidCrossEntropy: "),Ut>0){const He=(0,mo.i)(Ut),ln=(0,mo.i)(1),hn=(0,mo.i)(.5);Jt=(0,Y.I)((0,O.d)(Jt,(0,Pr.l)(ln,He)),(0,O.d)(hn,He))}const Fe=function P1(Ht,Vt){const $t=(0,k._1)(Ht,"labels","sigmoidCrossEntropyWithLogits"),Ut=(0,k._1)(Vt,"logits","sigmoidCrossEntropyWithLogits");(0,A.k5)($t.shape,Ut.shape,"Error in sigmoidCrossEntropyWithLogits: ");const Zt=(0,us.U)(Ut),Jt=(0,O.d)(Ut,$t),Qt=(0,pr.K)((0,fi.Q)((0,Or.W)((0,V.W)(Ut))));return(0,Y.I)((0,Pr.l)(Zt,Jt),Qt)}(Jt,Qt);return Xl(Fe,me,Zt)}}),yl=(0,X.op)({softmaxCrossEntropy_:function R1(Ht,Vt,$t,Ut=0,Zt=Ju.I.SUM_BY_NONZERO_WEIGHTS){let Jt=(0,k._1)(Ht,"onehotLabels","softmaxCrossEntropy");const Qt=(0,k._1)(Vt,"logits","softmaxCrossEntropy");let me=null;if(null!=$t&&(me=(0,k._1)($t,"weights","softmaxCrossEntropy")),(0,A.k5)(Jt.shape,Qt.shape,"Error in softmaxCrossEntropy: "),Ut>0){const He=(0,mo.i)(Ut),ln=(0,mo.i)(1),hn=(0,mo.i)(Jt.shape[1]);Jt=(0,Y.I)((0,O.d)(Jt,(0,Pr.l)(ln,He)),(0,zn.h)(He,hn))}const Fe=function NS(Ht,Vt,$t=-1){if(-1===$t&&($t=Vt.rank-1),$t!==Vt.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${Vt.rank} and dim was ${$t}`);return(0,qs.cb)((Zt,Jt,Qt)=>{const Fe=(0,Wa.l)(Jt,[$t],!0),He=(0,Pr.l)((0,pt.p)(Jt,"float32"),Fe);Qt([Zt,He]);const ln=(0,Or.W)((0,O.d)(He,Zt));return{value:(0,ns.S)(ln,[$t]),gradFunc:(fr,vi)=>{const[is,Ei]=vi,fs=(0,ai.rv)(fr.shape,[$t]);return[(0,O.d)((0,ot.X)(fr,fs),(0,Pr.l)((0,pt.p)(is,"float32"),(0,fi.Q)(Ei))),(0,O.d)((0,ot.X)(fr,fs),(0,Pr.l)((0,fi.Q)(Ei),(0,pt.p)(is,"float32")))]}}})(Ht,Vt)}(Jt,Qt);return Xl(Fe,me,Zt)}}),wy={fft:Ha.k,ifft:Ca.S,rfft:ta.Q,irfft:Qs.w},Mh={hammingWindow:qt,hannWindow:ke,frame:xn,stft:Un},tl={flipLeftRight:Fa,grayscaleToRGB:Kl,resizeNearestNeighbor:cy.j,resizeBilinear:Hp.I,rgbToGrayscale:vS,rotateWithOffset:xS,cropAndResize:Ji,nonMaxSuppression:iy,nonMaxSuppressionAsync:function ES(Ht,Vt,$t){return oy.apply(this,arguments)},nonMaxSuppressionWithScore:CS,nonMaxSuppressionWithScoreAsync:function bS(Ht,Vt,$t){return $a.apply(this,arguments)},nonMaxSuppressionPadded:ay,nonMaxSuppressionPaddedAsync:function uy(Ht,Vt,$t){return af.apply(this,arguments)},threshold:hy,transform:fy},z1={bandPart:gd,gramSchmidt:py,qr:S1},V1={absoluteDifference:D1,computeWeightedLoss:Xl,cosineDistance:DS,hingeLoss:T1,huberLoss:gy,logLoss:A1,meanSquaredError:yy,sigmoidCrossEntropy:O1,softmaxCrossEntropy:yl},U1={sparseFillEmptyRows:(0,X.op)({sparseFillEmptyRows_:function _y(Ht,Vt,$t,Ut){const Zt=(0,k._1)(Ht,"indices","sparseFillEmptyRows","int32"),Jt=(0,k._1)(Vt,"values","sparseFillEmptyRows"),Qt=(0,k._1)($t,"denseShape","sparseFillEmptyRows","int32"),me=(0,k._1)(Ut,"defaultValue","sparseFillEmptyRows",Jt.dtype);if(2!==Zt.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${Zt.shape}`);if(1!==Jt.rank)throw new Error(`Values should be Tensor1D but received shape ${Jt.shape}`);if(1!==Qt.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${Qt.shape}`);if(0!==me.rank)throw new Error(`Default value should be a scalar but received shape ${me.shape}`);const He=R.BV.runKernel(W.O3z,{indices:Zt,values:Jt,denseShape:Qt,defaultValue:me});return{outputIndices:He[0],outputValues:He[1],emptyRowIndicator:He[2],reverseIndexMap:He[3]}}}),sparseReshape:(0,X.op)({sparseReshape_:function k1(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"inputIndices","sparseReshape","int32"),Zt=(0,k._1)(Vt,"inputShape","sparseReshape","int32"),Jt=(0,k._1)($t,"newShape","sparseReshape","int32");if(2!==Ut.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${Ut.shape}`);if(1!==Zt.rank)throw new Error(`Input shape should be Tensor1D but received shape ${Zt.shape}`);if(1!==Jt.rank)throw new Error(`New shape should be Tensor1D but received shape ${Jt.shape}`);const me=R.BV.runKernel(W.nhH,{inputIndices:Ut,inputShape:Zt,newShape:Jt});return{outputIndices:me[0],outputShape:me[1]}}}),sparseSegmentMean:(0,X.op)({sparseSegmentMean_:function Ey(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"data","sparseSegmentMean"),Zt=(0,k._1)(Vt,"indices","sparseSegmentMean","int32"),Jt=(0,k._1)($t,"segmentIds","sparseSegmentMean","int32");if(Ut.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==Zt.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${Zt.shape}`);if(1!==Jt.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${Jt.shape}`);return R.BV.runKernel(W.w3H,{data:Ut,indices:Zt,segmentIds:Jt})}}),sparseSegmentSum:(0,X.op)({sparseSegmentSum_:function Yp(Ht,Vt,$t){const Ut=(0,k._1)(Ht,"data","sparseSegmentSum"),Zt=(0,k._1)(Vt,"indices","sparseSegmentSum","int32"),Jt=(0,k._1)($t,"segmentIds","sparseSegmentSum","int32");if(Ut.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==Zt.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${Zt.shape}`);if(1!==Jt.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${Jt.shape}`);return R.BV.runKernel(W.ZjV,{data:Ut,indices:Zt,segmentIds:Jt})}})},Lc={stringNGrams:(0,X.op)({stringNGrams_:function Zl(Ht,Vt,$t,Ut,Zt,Jt,Qt,me){const Fe=(0,k._1)(Ht,"data","stringNGrams","string");if("string"!==Fe.dtype)throw new Error("Data must be of datatype string");if(1!==Fe.shape.length)throw new Error(`Data must be a vector, saw: ${Fe.shape}`);const He=(0,k._1)(Vt,"dataSplits","stringNGrams");if("int32"!==He.dtype)throw new Error("Data splits must be of datatype int32");const nr=R.BV.runKernel(W._JP,{data:Fe,dataSplits:He},{separator:$t,nGramWidths:Ut,leftPad:Zt,rightPad:Jt,padWidth:Qt,preserveShortSequences:me});return{nGrams:nr[0],nGramsSplits:nr[1]}}}),stringSplit:(0,X.op)({stringSplit_:function by(Ht,Vt,$t=!0){const Ut=(0,k._1)(Ht,"input","stringSplit","string"),Zt=(0,k._1)(Vt,"delimiter","stringSplit","string");if(1!==Ut.rank)throw new Error(`Input should be Tensor1D but received shape ${Ut.shape}`);if(0!==Zt.rank)throw new Error(`Delimiter should be a scalar but received shape ${Zt.shape}`);const me=R.BV.runKernel(W.s1s,{input:Ut,delimiter:Zt},{skipEmpty:$t});return{indices:me[0],values:me[1],shape:me[2]}}}),stringToHashBucketFast:(0,X.op)({stringToHashBucketFast_:function Qp(Ht,Vt){const $t=(0,k._1)(Ht,"input","stringToHashBucketFast","string"),Ut={numBuckets:Vt};if(Vt<=0)throw new Error("Number of buckets must be at least 1");return R.BV.runKernel(W.XkS,{input:$t},Ut)}}),staticRegexReplace:(0,X.op)({staticRegexReplace_:function Fu(Ht,Vt,$t,Ut=!0){const Zt=(0,k._1)(Ht,"input","staticRegexReplace","string");return R.BV.runKernel(W.e0R,{x:Zt},{pattern:Vt,rewrite:$t,replaceGlobal:Ut})}})}},404:(Lt,ut,y)=>{"use strict";y.d(ut,{v:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({pad_:function Y(W,k,A=0){const X=(0,H._1)(W,"x","pad");if(0===X.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return $.BV.runKernel(V.lyA,{x:X},{paddings:k,constantValue:A})}})},1640:(Lt,ut,y)=>{"use strict";y.d(ut,{d:()=>it});var $=y(1257),V=y(5359),H=y(6903),Q=y(2782),Y=y(5551),R=y(2444),W=y(4195),k=y(5715),A=y(9619);const it=(0,W.op)({pool_:function X(wt,K,st,et,dt,lt,St){null==dt&&(dt=[1,1]),null==lt&&(lt=1),0===et&&(et="valid");const q=(0,$._1)(wt,"x","maxPool");let ft=q,pt=!1;3===q.rank&&(pt=!0,ft=(0,k.X)(q,[1,q.shape[0],q.shape[1],q.shape[2]])),V.hu(Y.jT(lt,dt),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${lt} and dilations '${dt}'`);const B=Y.Xw(ft.shape,K,lt,dt,et),ot=[B.dilationHeight,B.dilationWidth];let P;P="same"===et?function G(wt,K){const et=wt.map((St,q)=>St+(St-1)*(K[q]-1)).map(St=>St-1),dt=et.map(St=>Math.floor(St/2)),lt=et.map((St,q)=>St-dt[q]);return et.map((St,q)=>[dt[q],lt[q]])}([B.filterHeight,B.filterWidth],ot):[[0,0],[0,0]];const at=1===ot[0]&&1===ot[1],[nt,Gt]=function Z(wt,K,st){const et=st.map(B=>B[0]),dt=st.map(B=>B[1]),lt=wt.concat(et,dt),St=K.map((B,ot)=>(B-lt[ot]%B)%B),q=dt.map((B,ot)=>B+St[ot]),ft=K.map((B,ot)=>[et[ot],q[ot]]),pt=K.map((B,ot)=>[0,St[ot]]);return[ft,pt]}([B.inHeight,B.inWidth],ot,P),O=at?et:"valid",Ct=at?ft:(0,A.f)(ft,ot,nt),vt=("avg"===st?()=>(0,H.w)(Ct,K,lt,O,St):()=>(0,R._)(Ct,K,lt,O,St))(),xt=at?vt:(0,Q.E)(vt,ot,Gt);return pt?(0,k.X)(xt,[xt.shape[1],xt.shape[2],xt.shape[3]]):xt}})},2962:(Lt,ut,y)=>{"use strict";y.d(ut,{s:()=>W});var $=y(687),V=y(4251),H=y(7664),Q=y(1257);const W=(0,y(4195).op)({pow_:function R(k,A){let X=(0,Q._1)(k,"base","pow"),Z=(0,Q._1)(A,"exp","pow");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.pe_,{a:X,b:Z})}})},1584:(Lt,ut,y)=>{"use strict";y.d(ut,{A:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({prelu_:function Y(W,k){const A=(0,H._1)(W,"x","prelu"),X=(0,H._1)(k,"alpha","prelu");return $.BV.runKernel(V.o0g,{x:A,alpha:X})}})},3006:(Lt,ut,y)=>{"use strict";function $(V,H=!1){console.log(V.toString(H))}y.d(ut,{S:()=>$})},794:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(3062);const W=(0,y(4195).op)({prod_:function R(k,A=null,X=!1){let Z=(0,H._1)(k,"x","prod");return"bool"===Z.dtype&&(Z=(0,Q.p)(Z,"int32")),$.BV.runKernel(V.DlI,{x:Z},{axis:A,keepDims:X})}})},6027:(Lt,ut,y)=>{"use strict";y.d(ut,{k:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({real_:function Y(W){const A={input:(0,H._1)(W,"input","real")};return $.BV.runKernel(V.xJR,A)}})},4831:(Lt,ut,y)=>{"use strict";y.d(ut,{M:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({reciprocal_:function Y(W){const A={x:(0,H._1)(W,"x","reciprocal")};return $.BV.runKernel(V.$HU,A)}})},8586:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({relu_:function Y(W){const A={x:(0,H._1)(W,"x","relu")};return $.BV.runKernel(V.qkr,A)}})},4917:(Lt,ut,y)=>{"use strict";y.d(ut,{b:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({relu6_:function Y(W){const A={x:(0,H._1)(W,"x","relu6")};return $.BV.runKernel(V.SbG,A)}})},5715:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({reshape_:function Y(W,k){const X={x:(0,H._1)(W,"x","reshape","string_or_numeric")};return $.BV.runKernel(V.HZH,X,{shape:k})}})},6825:(Lt,ut,y)=>{"use strict";y.d(ut,{G:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({reverse_:function Y(W,k){const X={x:(0,H._1)(W,"x","reverse")};return $.BV.runKernel(V.mKl,X,{dims:k})}})},1974:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({round_:function Y(W){const A={x:(0,H._1)(W,"x","round")};return $.BV.runKernel(V.e07,A)}})},8893:(Lt,ut,y)=>{"use strict";y.d(ut,{b:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({rsqrt_:function Y(W){const A={x:(0,H._1)(W,"x","rsqrt","float32")};return $.BV.runKernel(V.bV0,A)}})},8661:(Lt,ut,y)=>{"use strict";y.d(ut,{i:()=>H});var $=y(1153),V=y(7431);function H(Q,Y){if(((0,$.isTypedArray)(Q)&&"string"!==Y||Array.isArray(Q))&&"complex64"!==Y)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===Y&&(0,$.isTypedArray)(Q)&&!(Q instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,V.H)(Q,[],[],Y)}},1876:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{calculateShapes:()=>Q,validateInput:()=>H,validateUpdateShape:()=>V});var $=y(5359);function V(Y,R,W){const k=R.rank>1?R.shape[R.rank-1]:1,A=R.rank>1?R.rank-1:1,X=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${W.shape}, indices.shape: ${R.shape}, shape: ${Y}, sliceDim: ${k}, and batchDim: ${A}.`;if(W.rank<A)throw new Error(X+` update.rank < ${A}. `);if(Y.length<k+(W.rank-A))throw new Error(X+` Output shape length < ${k+(W.rank-A)}`);if(W.rank!==A+Y.length-k)throw new Error(X+" update.rank != "+(A+Y.length-k));for(let Z=0;Z<A;++Z)if(W.shape[Z]!==R.shape[Z])throw new Error(X+` updates.shape[${Z}] (${W.shape[Z]}) != indices.shape[${Z}] (${R.shape[Z]}).`);for(let Z=0;Z<W.rank-A;++Z)if(W.shape[Z+A]!==Y[Z+k])throw new Error(X+` updates.shape[${Z+A}] (${W.shape[Z+A]}) != shape[${Z+A}] (${Y[Z+A]})`)}function H(Y,R,W){if(R.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${R.rank}.`);if(Y.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${Y.rank}.`);if("int32"!==R.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${R.dtype}`);if(W.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${W}`);if(0===W.length){if(0===R.size)throw new Error(`Indices specified for empty output. indices shape: ${R.shape}`);if(0===Y.size)throw new Error(`Updates specified for empty output. updates shape: ${Y.shape}`)}V(W,R,Y)}function Q(Y,R,W){const k=R.shape.length,A=k>1?R.shape[k-1]:1,X=W.length;let Z=1;for(let st=A;st<X;++st)Z*=W[st];const G=A<1?1:A;return{sliceRank:A,numUpdates:(0,$.NA)(R.shape)/G,sliceSize:Z,strides:[...(0,$.e3)(W.slice(0,A)),1],outputSize:(0,$.NA)(W)}}},9614:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({selu_:function Y(W){const A={x:(0,H._1)(W,"x","selu")};return $.BV.runKernel(V.oFR,A)}})},2152:(Lt,ut,y)=>{"use strict";y.d(ut,{$:()=>V,y:()=>$});const $=1.7580993408473768,V=1.0507009873554805},6762:(Lt,ut,y)=>{"use strict";y.d(ut,{U:()=>k});var $=y(1257),V=y(5359),H=y(4451),Q=y(1172),Y=y(4195),R=y(5715);const k=(0,Y.op)({separableConv2d_:function W(A,X,Z,G,it,wt=[1,1],K="NHWC"){const st=(0,$._1)(A,"x","separableConv2d"),et=(0,$._1)(X,"depthwiseFilter","separableConv2d"),dt=(0,$._1)(Z,"pointwiseFilter","separableConv2d");let lt=st,St=!1;if(3===st.rank&&(St=!0,lt=(0,R.X)(st,[1,st.shape[0],st.shape[1],st.shape[2]])),"NCHW"===K)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");V.hu(4===lt.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${lt.rank}.`),V.hu(4===et.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${et.rank}.`),V.hu(4===dt.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${et.rank}.`),V.hu(1===dt.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${dt.shape[0]}.`),V.hu(1===dt.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${dt.shape[1]}.`);const q=et.shape[2],ft=et.shape[3];V.hu(dt.shape[2]===q*ft,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${q*ft}, but got ${dt.shape[2]}.`);const pt=(0,Q.B)(lt,et,G,it,K,wt),ot=(0,H.T)(pt,dt,1,"valid",K);return St?(0,R.X)(ot,[ot.shape[1],ot.shape[2],ot.shape[3]]):ot}})},6139:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sigmoid_:function Y(W){const A={x:(0,H._1)(W,"x","sigmoid","float32")};return $.BV.runKernel(V.a5O,A)}})},4058:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sign_:function Y(W){const A={x:(0,H._1)(W,"x","sign")};return $.BV.runKernel(V.i5y,A)}})},2438:(Lt,ut,y)=>{"use strict";y.d(ut,{O:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sin_:function Y(W){const A={x:(0,H._1)(W,"x","sin","float32")};return $.BV.runKernel(V.RQH,A)}})},319:(Lt,ut,y)=>{"use strict";y.d(ut,{R:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sinh_:function Y(W){const A={x:(0,H._1)(W,"x","sinh")};return $.BV.runKernel(V.wYB,A)}})},8317:(Lt,ut,y)=>{"use strict";y.d(ut,{t:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({slice_:function Y(W,k,A){const X=(0,H._1)(W,"x","slice","string_or_numeric");if(0===X.rank)throw new Error("Slicing scalar is not possible");return $.BV.runKernel(V.p2w,{x:X},{begin:k,size:A})}})},2320:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{assertParamsValid:()=>Q,computeFlatOffset:()=>et,computeOutShape:()=>R,getNormalizedAxes:()=>X,isSliceContinous:()=>st,maskToAxes:()=>Y,parseSliceParams:()=>dt,sliceInfo:()=>lt,startForAxis:()=>wt,startIndicesWithElidedDims:()=>Z,stopForAxis:()=>K,stopIndicesWithElidedDims:()=>G,stridesForAxis:()=>it,stridesWithElidedDims:()=>W});var $=y(5359);const V=-2,H=-1;function Q(ft,pt,B){const ot=ft.shape.length;$.hu(ot===pt.length,()=>`Error in slice${ot}D: Length of begin ${pt} must match the rank of the array (${ot}).`),$.hu(ot===B.length,()=>`Error in slice${ot}D: Length of size ${B} must match the rank of the array (${ot}).`);for(let P=0;P<ot;++P)$.hu(pt[P]+B[P]<=ft.shape[P],()=>`Error in slice${ot}D: begin[${P}] + size[${P}] (${pt[P]+B[P]}) would overflow input.shape[${P}] (${ft.shape[P]})`)}function Y(ft){const pt=[];let B=0;for(;ft>0;)1&ft&&pt.push(B),ft/=2,B++;return pt}function R(ft,pt,B){const ot=[];for(let P=0;P<ft.length;P++)ot[P]=Math.ceil((pt[P]-ft[P])/B[P]);return ot}function W(ft,pt,B,ot){const P=[...ft];for(let at=P.length;at<ot.length;at++)P.push(1);for(let at=0;at<B;at++)0===at?P[pt]=1:(P.splice(pt,0,1),P.pop());return P}function k(ft,pt,B){return B<=ft?B:B-(pt-1)}function A(ft,pt){const B=[];for(let ot=0;ot<ft;ot++)B.push(pt+ot);return B}function X(ft,pt,B,ot,P,at,nt,Gt,O){const Ct=ft.length;let yt=new Array(Ct),vt=new Array(Ct),xt=new Array(Ct);if(pt.length&&B>0){const Mt=pt[0],It=B+1;yt=Z(nt,Mt,It,ot,ft),vt=G(Gt,Mt,It,P,ft),xt=W(at,Mt,It,ft)}else for(let Mt=0;Mt<Ct;Mt++)yt[Mt]=wt(nt,ot,at,ft,Mt,O),vt[Mt]=K(Gt,P,at,ft,Mt,O),xt[Mt]=it(at,Mt,O);return{begin:yt,end:vt,strides:xt}}function Z(ft,pt,B,ot,P){const at=[...P],nt=A(B,pt);for(let Gt=0;Gt<at.length;Gt++)if(nt.indexOf(Gt)>-1)at[Gt]=0;else{const O=k(pt,B,Gt);let Ct=ot[O];ft&1<<O&&(Ct=0),at[Gt]=Ct}return at}function G(ft,pt,B,ot,P){const at=[...P],nt=A(B,pt);for(let Gt=0;Gt<at.length;Gt++)if(nt.indexOf(Gt)>-1)at[Gt]=Number.MAX_SAFE_INTEGER;else{const O=k(pt,B,Gt);let Ct=ot[O];ft&1<<O&&(Ct=Number.MAX_SAFE_INTEGER),at[Gt]=Ct}for(let Gt=0;Gt<at.length;Gt++)at[Gt]<0&&(at[Gt]+=P[Gt]),at[Gt]=$.uZ(0,at[Gt],P[Gt]);return at}function it(ft,pt,B){let ot=ft[pt];return(B&1<<pt||null==ot)&&(ot=1),ot}function wt(ft,pt,B,ot,P,at){let nt=pt[P];(ft&1<<P||at&1<<P||null==nt)&&(nt=(B[P]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const O=ot[P];return nt<0&&(nt+=O),nt=$.uZ(0,nt,O-1),nt}function K(ft,pt,B,ot,P,at){let nt=pt[P];const Gt=B[P]||1;(ft&1<<P||at&1<<P||null==nt)&&(nt=Gt>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const O=ot[P];return nt<0&&(nt+=O),nt=Gt>0?$.uZ(0,nt,O):$.uZ(-1,nt,O-1),nt}function st(ft,pt,B){let ot=B.length;for(let P=0;P<B.length;P++)if(B[P]>1){ot=P;break}for(let P=ot+1;P<B.length;P++)if(pt[P]>0||B[P]!==ft[P])return!1;return!0}function et(ft,pt){let B=ft.length>0?ft[ft.length-1]:1;for(let ot=0;ot<ft.length-1;ot++)B+=ft[ot]*pt[ot];return B}function dt(ft,pt,B){let ot;const P=ft.shape.length;let at;return ot="number"==typeof pt?[pt,...new Array(P-1).fill(0)]:pt.length<P?pt.concat(new Array(P-pt.length).fill(0)):pt.slice(),ot.forEach(nt=>{$.hu(-1!==nt,()=>"slice() does not support negative begin indexing.")}),at=null==B?new Array(P).fill(-1):"number"==typeof B?[B,...new Array(P-1).fill(-1)]:B.length<P?B.concat(new Array(P-B.length).fill(-1)):B,at=at.map((nt,Gt)=>nt>=0?nt:($.hu(-1===nt,()=>`Negative size values should be exactly -1 but got ${nt} for the slice() size at index ${Gt}.`),ft.shape[Gt]-ot[Gt])),[ot,at]}function lt(ft,pt,B,ot,P,at,nt,Gt,O){let Ct;if(null==ot?(Ct=new Array(pt.length),Ct.fill(1)):Ct=ot,null!=nt&&nt&nt-1)throw new Error("Multiple ellipses in slice is not allowed.");let yt=!1;const vt={dims:Ct.length,numAddAxisAfterEllipsis:0,begin:pt.slice(),end:B.slice(),strides:Ct.slice(),beginMask:P,endMask:at,ellipsisMask:nt,newAxisMask:Gt,shrinkAxisMask:O};for(let se=0;se<vt.dims;se++)yt&&1<<se&Gt&&vt.numAddAxisAfterEllipsis++,1<<se&nt&&(yt=!0);yt||(vt.ellipsisMask|=1<<vt.dims,vt.dims++);const xt={dims:ft.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function St(ft,pt){pt.beginMask=0,pt.endMask=0,pt.shrinkAxisMask=0;let B=0;pt.beginValid=null!=ft.begin,pt.endValid=null!=ft.end,pt.begin=new Array(pt.dims),pt.end=new Array(pt.dims),pt.strides=new Array(pt.dims),pt.finalShapeGatherIndices=[],pt.finalShapeGatherIndicesSparse=[],pt.inputShapeGatherIndicesSparse=new Array(pt.dims);for(let ot=0;ot<ft.dims;ot++)if(1<<ot&ft.ellipsisMask){const P=Math.min(pt.dims-(ft.dims-ot)+1+ft.numAddAxisAfterEllipsis,pt.dims);for(;B<P;B++)pt.begin[B]=0,pt.end[B]=0,pt.strides[B]=1,pt.beginMask|=1<<B,pt.endMask|=1<<B,pt.finalShapeGatherIndices.push(B),pt.finalShapeGatherIndicesSparse.push(-1),pt.inputShapeGatherIndicesSparse[B]=ot}else if(1<<ot&ft.newAxisMask)pt.finalShapeGatherIndices.push(V),pt.finalShapeGatherIndicesSparse.push(-1);else{if(B===pt.begin.length)throw Error(`Index out of range using input dim ${B}; input has only ${pt.dims} dims, ${pt.begin.length}.`);null!=ft.begin&&(pt.begin[B]=ft.begin[ot]),null!=ft.end&&(pt.end[B]=ft.end[ot]),pt.strides[B]=ft.strides[ot],ft.beginMask&1<<ot&&(pt.beginMask|=1<<B),ft.endMask&1<<ot&&(pt.endMask|=1<<B),ft.shrinkAxisMask&1<<ot?(pt.finalShapeGatherIndices.push(H),pt.finalShapeGatherIndicesSparse.push(-1),pt.shrinkAxisMask|=1<<B):(pt.finalShapeGatherIndices.push(B),pt.finalShapeGatherIndicesSparse.push(ot)),pt.inputShapeGatherIndicesSparse[B]=ot,B++}}(vt,xt);let Mt=!0,It=!0,re=!0;const Bt=[],ee=[];for(let se=0;se<ft.length;++se){if(0===xt.strides[se])throw Error(`strides[${se}] must be non-zero`);const we=!!(xt.shrinkAxisMask&1<<se),Me=ft[se];if(-1===Me){Bt.push(we?1:-1);continue}const Xe=[xt.beginMask&1<<se,xt.endMask&1<<se],Ue=[xt.strides[se]>0?0:-1,xt.strides[se]>0?Me:Me-1];if(we&&xt.strides[se]<=0)throw Error("only stride 1 allowed on non-range indexing.");re=re&&1===xt.strides[se];const De=!!(xt.beginMask&1<<se&&xt.endMask&1<<se);if(xt.beginValid&&xt.endValid){if(we){const pe=xt.begin[se]<0?Me+xt.begin[se]:xt.begin[se];if(xt.begin[se]=pe,xt.end[se]=xt.begin[se]+1,pe<0||pe>=Me)throw Error(`slice index ${xt.begin[se]} of dimension ${se} out of bounds.`)}else xt.begin[se]=q(xt.begin[se],0,xt.strides[se],Me,Xe,Ue),xt.end[se]=q(xt.end[se],1,xt.strides[se],Me,Xe,Ue);const ne=1===xt.strides[se]&&0===xt.begin[se]&&xt.end[se]===Me;Mt=Mt&&ne,It=It&&(0===se&&1===xt.strides[se]||ne)}else Mt=Mt&&1===xt.strides[se]&&De,It=It&&(0===se&&1===xt.strides[se]||De);let Tn,On=!1;if(xt.beginValid&&xt.endValid?(Tn=xt.end[se]-xt.begin[se],On=!0):we?(Tn=1,On=!0):De&&Me>=0&&(Tn=xt.strides[se]<0?-Me:Me,On=!0),On){let ne;ne=0===Tn||Tn<0!=xt.strides[se]<0?0:Math.trunc(Tn/xt.strides[se])+(Tn%xt.strides[se]!=0?1:0),Bt.push(ne)}else Bt.push(-1)}for(let se=0;se<xt.finalShapeGatherIndices.length;++se){const we=xt.finalShapeGatherIndices[se];we>=0?ee.push(Bt[we]):we===V&&ee.push(1)}return{finalShapeSparse:ee.filter((se,we)=>xt.finalShapeGatherIndices[we]!==V),finalShape:ee,isIdentity:Mt,sliceDim0:It,isSimpleSlice:re,begin:xt.begin,end:xt.end,strides:xt.strides}}function q(ft,pt,B,ot,P,at){if(P[pt])return B>0?at[pt]:at[pt+1&1];{const nt=ft<0?ot+ft:ft;return nt<at[0]?at[0]:nt>at[1]?at[1]:nt}}},8683:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({softmax_:function Y(W,k=-1){const A=(0,H._1)(W,"logits","softmax","float32");if(-1===k&&(k=A.rank-1),k!==A.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${A.rank} and dim was ${k}`);return $.BV.runKernel(V.Gcp,{logits:A},{dim:k})}})},4487:(Lt,ut,y)=>{"use strict";y.d(ut,{W:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({softplus_:function Y(W){const A={x:(0,H._1)(W,"x","softplus")};return $.BV.runKernel(V.MRv,A)}})},9619:(Lt,ut,y)=>{"use strict";y.d(ut,{f:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({spaceToBatchND_:function R(k,A,X){const Z=(0,H._1)(k,"x","spaceToBatchND");return Q.hu(Z.rank>=1+A.length,()=>`input rank ${Z.rank} should be > than [blockShape] ${A.length}`),Q.hu(X.length===A.length,()=>`paddings.shape[0] ${X.length} must be equal to [blockShape] ${A.length}`),Q.hu(Z.shape.reduce((wt,K,st)=>st>0&&st<=A.length?wt&&(K+X[st-1][0]+X[st-1][1])%A[st-1]==0:wt,!0),()=>`input spatial dimensions ${Z.shape.slice(1)} with paddings ${X.toString()} must be divisible by blockShapes ${A.toString()}`),$.BV.runKernel(V.TQc,{x:Z},{blockShape:A,paddings:X})}})},9738:(Lt,ut,y)=>{"use strict";y.d(ut,{k:()=>R});var $=y(687),V=y(4251),H=y(5359);const R=(0,y(4195).op)({fft_:function Y(W){return(0,H.hu)("complex64"===W.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${W.dtype}.`),$.BV.runKernel(V.vwp,{input:W})}})},527:(Lt,ut,y)=>{"use strict";y.d(ut,{S:()=>R});var $=y(687),V=y(4251),H=y(5359);const R=(0,y(4195).op)({ifft_:function Y(W){return(0,H.hu)("complex64"===W.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${W.dtype}.`),$.BV.runKernel(V.Qg5,{input:W})}})},6065:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>it});var $=y(3037),V=y(4111),H=y(1844),Q=y(8737),Y=y(4195),R=y(6027),W=y(5715),k=y(6825),A=y(8661),X=y(8317),Z=y(527);const it=(0,Y.op)({irfft_:function G(wt){const K=wt.shape[wt.shape.length-1],st=wt.size/K;let et;if(K<=2){const dt=(0,W.X)(wt,[st,K]);et=(0,Z.S)(dt)}else{const dt=[st,2*(K-1)],lt=(0,W.X)((0,R.k)(wt),[st,K]),St=(0,W.X)((0,H.a)(wt),[st,K]),q=(0,k.G)((0,X.t)(lt,[0,1],[st,K-2]),1),ft=(0,Q.d)((0,k.G)((0,X.t)(St,[0,1],[st,K-2]),1),(0,A.i)(-1)),pt=(0,V.z)([lt,q],1),B=(0,V.z)([St,ft],1),ot=(0,W.X)((0,$.P)(pt,B),[dt[0],dt[1]]);et=(0,Z.S)(ot)}if(et=(0,R.k)(et),3===wt.rank&&0!==wt.shape[0]){const dt=et,lt=wt.shape[0];et=(0,W.X)(et,[lt,et.shape[0]/lt,et.shape[1]]),dt.dispose()}return et}})},1638:(Lt,ut,y)=>{"use strict";y.d(ut,{Q:()=>wt});var $=y(5359),V=y(3037),H=y(4111),Q=y(1844),Y=y(4195),R=y(6027),W=y(5715),k=y(8317),A=y(8874),X=y(6467),Z=y(3143),G=y(9738);const wt=(0,Y.op)({rfft_:function it(K,st){(0,$.hu)("float32"===K.dtype,()=>`The dtype for rfft() must be real value but got ${K.dtype}`);let et=K.shape[K.shape.length-1];const dt=K.size/et;let lt;if(null!=st&&st<et){const Gt=K.shape.map(Ct=>0),O=K.shape.map(Ct=>Ct);O[K.shape.length-1]=st,lt=(0,k.t)(K,Gt,O),et=st}else if(null!=st&&st>et){const Gt=K.shape.map(O=>O);Gt[K.shape.length-1]=st-et,lt=(0,H.z)([K,(0,X.l)(Gt)],K.shape.length-1),et=st}else lt=K;const St=(0,Z.P)(lt),q=(0,W.X)((0,V.P)(lt,St),[dt,et]),ft=(0,G.k)(q),pt=Math.floor(et/2)+1,B=(0,R.k)(ft),ot=(0,Q.a)(ft),P=(0,A.V)(B,[pt,et-pt],B.shape.length-1),at=(0,A.V)(ot,[pt,et-pt],ot.shape.length-1),nt=lt.shape.slice();return nt[lt.shape.length-1]=pt,(0,W.X)((0,V.P)(P[0],at[0]),nt)}})},8874:(Lt,ut,y)=>{"use strict";y.d(ut,{V:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({split_:function Y(W,k,A=0){const Z={x:(0,H._1)(W,"x","split")};return $.BV.runKernel(V.L8s,Z,{numOrSizeSplits:k,axis:A})}})},930:(Lt,ut,y)=>{"use strict";y.d(ut,{_:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({sqrt_:function Y(W){const A={x:(0,H._1)(W,"x","sqrt","float32")};return $.BV.runKernel(V.FKq,A)}})},7527:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>Y});var $=y(687),V=y(1257);const Y=(0,y(4195).op)({square_:function Q(R){const W=(0,V._1)(R,"x","square");return $.BV.runKernel("Square",{x:W},{})}})},9539:(Lt,ut,y)=>{"use strict";y.d(ut,{$:()=>k});var $=y(687),V=y(4251),H=y(7664),Q=y(1257),Y=y(3239);const k=(0,y(4195).op)({squaredDifference_:function W(A,X){let Z=(0,Q._1)(A,"a","squaredDifference"),G=(0,Q._1)(X,"b","squaredDifference");return[Z,G]=(0,H.makeTypesMatch)(Z,G),(0,Y.assertAndGetBroadcastShape)(Z.shape,G.shape),$.BV.runKernel(V._tC,{a:Z,b:G},{})}})},2494:(Lt,ut,y)=>{"use strict";y.d(ut,{L:()=>R});var $=y(1257),V=y(5359),H=y(4195),Q=y(5715);const R=(0,H.op)({squeeze_:function Y(W,k){const A=(0,$._1)(W,"x","squeeze","string_or_numeric");return(0,Q.X)(A,(0,V.bp)(A.shape,k).newShape)}})},7958:(Lt,ut,y)=>{"use strict";y.d(ut,{k:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({stack_:function R(k,A=0){const X=(0,H.sI)(k,"tensors","stack","string_or_numeric");return Q.hu(X.length>=1,()=>"Pass at least one tensor to tf.stack"),X.length>0&&Q.hu(A<=X[0].rank,()=>"Axis must be <= rank of the tensor"),$.BV.runKernel(V.QiL,X,{axis:A})}})},6034:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({step_:function Y(W,k=0){const X={x:(0,H._1)(W,"x","step")};return $.BV.runKernel(V.h8e,X,{alpha:k})}})},5367:(Lt,ut,y)=>{"use strict";y.d(ut,{N:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({stridedSlice_:function Y(W,k,A,X,Z=0,G=0,it=0,wt=0,K=0){const et={x:(0,H._1)(W,"x","stridedSlice","string_or_numeric")};return $.BV.runKernel(V.jQk,et,{begin:k,end:A,strides:X,beginMask:Z,endMask:G,ellipsisMask:it,newAxisMask:wt,shrinkAxisMask:K})}})},1191:(Lt,ut,y)=>{"use strict";y.d(ut,{l:()=>W});var $=y(687),V=y(4251),H=y(7664),Q=y(1257);const W=(0,y(4195).op)({sub_:function R(k,A){let X=(0,Q._1)(k,"a","sub"),Z=(0,Q._1)(A,"b","sub");return[X,Z]=(0,H.makeTypesMatch)(X,Z),$.BV.runKernel(V.Tr8,{a:X,b:Z})}})},9929:(Lt,ut,y)=>{"use strict";y.d(ut,{S:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(3062);const W=(0,y(4195).op)({sum_:function R(k,A=null,X=!1){let Z=(0,H._1)(k,"x","sum");return"bool"===Z.dtype&&(Z=(0,Q.p)(Z,"int32")),$.BV.runKernel(V.GBy,{x:Z},{axis:A,keepDims:X})}})},2500:(Lt,ut,y)=>{"use strict";y.d(ut,{O:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({tan_:function Y(W){const A={x:(0,H._1)(W,"x","tan","float32")};return $.BV.runKernel(V.sEM,A)}})},5987:(Lt,ut,y)=>{"use strict";y.d(ut,{A:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({tanh_:function Y(W){const A={x:(0,H._1)(W,"x","tanh","float32")};return $.BV.runKernel(V.MIZ,A)}})},3905:(Lt,ut,y)=>{"use strict";y.d(ut,{X:()=>H});var $=y(1257),V=y(7431);function H(Q,Y,R){const W=(0,$.C)(Q,R);return(0,V.H)(Q,Y,W,R)}},2786:(Lt,ut,y)=>{"use strict";y.d(ut,{w:()=>Q});var $=y(1257),V=y(5359),H=y(7431);function Q(Y,R,W){if((0,V.Cq)(Y),null!=R&&3!==R.length)throw new Error("tensor3d() requires shape to have three numbers");const k=(0,$.C)(Y,W);if(3!==k.length&&1!==k.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===k.length&&null==R)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,H.H)(Y,R,k,W)}},7431:(Lt,ut,y)=>{"use strict";y.d(ut,{H:()=>Y});var $=y(687),V=y(1216),H=y(5359),Q=y(1153);function Y(R,W,k,A){if(null==A)A=(0,H.D2)(R);else if("complex64"===A)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,V.$F)(R)||(0,V.Oq)(R)){if("float32"!==A&&"int32"!==A)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${A}.`);return $.BV.backend.createTensorFromGPUData(R,W||k,A)}if(!(0,Q.isTypedArray)(R)&&!Array.isArray(R)&&"number"!=typeof R&&"boolean"!=typeof R&&"string"!=typeof R)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=W){(0,H.Mu)(W);const X=(0,H.NA)(W),Z=(0,H.NA)(k);(0,H.hu)(X===Z,()=>`Based on the provided shape, [${W}], the tensor should have ${X} values but has ${Z}`);for(let G=0;G<k.length;++G){const wt=G!==k.length-1||k[G]!==(0,H.NA)(W.slice(G));(0,H.hu)(k[G]===W[G]||!wt,()=>`Error creating a new Tensor. Inferred shape (${k}) does not match the provided shape (${W}). `)}}return!(0,Q.isTypedArray)(R)&&!Array.isArray(R)&&(R=[R]),W=W||k,R="string"!==A?(0,Q.toTypedArray)(R,A):(0,Q.flatten)(R,[],!0),$.BV.makeTensor(R,W,A)}},2005:(Lt,ut,y)=>{"use strict";y.d(ut,{G:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({tile_:function R(k,A){const X=(0,H._1)(k,"x","tile","string_or_numeric");return Q.hu(X.rank===A.length,()=>`Error in transpose: rank of input ${X.rank} must match length of reps ${A}.`),$.BV.runKernel(V.n9L,{x:X},{reps:A})}})},4927:(Lt,ut,y)=>{"use strict";y.d(ut,{h:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({topk_:function Y(W,k=1,A=!0){const X=(0,H._1)(W,"x","topk");if(0===X.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const Z=X.shape[X.shape.length-1];if(k<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${k}`);if(k>Z)throw new Error(`'k' passed to topk() must be <= the last dimension (${Z}) but got ${k}`);const G={x:X},it={k,sorted:A},[wt,K]=$.BV.runKernel(V.cWu,G,it);return{values:wt,indices:K}}})},9194:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>G});var $=y(687),V=y(2773),H=y(4251),Q=y(1257),Y=y(5359),R=y(3037),W=y(1844),k=y(5048),A=y(4195),X=y(6027);const G=(0,A.op)({transpose_:function Z(it,wt,K){const st=(0,Q._1)(it,"x","transpose");if(null==wt&&(wt=st.shape.map((lt,St)=>St).reverse()),Y.hu(st.rank===wt.length,()=>`Error in transpose: rank of input ${st.rank} must match length of perm ${wt}.`),wt.forEach(lt=>{Y.hu(lt>=0&&lt<st.rank,()=>`All entries in 'perm' must be between 0 and ${st.rank-1} but got ${wt}`)}),st.rank<=1)return st.clone();const et={x:st},dt={perm:wt};return"complex64"===st.dtype?(0,V.lu)(()=>{let lt=(0,X.k)(st),St=(0,W.a)(st);return lt=$.BV.runKernel(H.G3Y,{x:lt},dt),St=$.BV.runKernel(H.G3Y,{x:St},dt),K&&(St=(0,k.W)(St)),(0,R.P)(lt,St)}):$.BV.runKernel(H.G3Y,et,dt)}})},8130:(Lt,ut,y)=>{"use strict";y.d(ut,{T:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({unique_:function R(k,A=0){const X=(0,H._1)(k,"x","unique","string_or_numeric");(0,Q.hu)(X.rank>0,()=>"The input tensor must be at least 1D");const Z={x:X},G={axis:A},[it,wt]=$.BV.runKernel(V.kpP,Z,G);return{values:it,indices:wt}}})},7715:(Lt,ut,y)=>{"use strict";y.d(ut,{p:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({unsortedSegmentSum_:function R(k,A,X){const Z=(0,H._1)(k,"x","unsortedSegmentSum"),G=(0,H._1)(A,"segmentIds","unsortedSegmentSum","int32");return(0,Q.hu)((0,Q.GN)(X),()=>"numSegments must be of dtype int"),$.BV.runKernel(V.Qvg,{x:Z,segmentIds:G},{numSegments:X})}})},2219:(Lt,ut,y)=>{"use strict";y.d(ut,{H:()=>W});var $=y(687),V=y(4251),H=y(1257),Q=y(5359);const W=(0,y(4195).op)({unstack_:function R(k,A=0){const X=(0,H._1)(k,"x","unstack","string_or_numeric");return Q.hu(A>=-X.shape.length&&A<X.shape.length,()=>`Axis = ${A} is not in [-${X.shape.length}, ${X.shape.length})`),$.BV.runKernel(V.ToN,{value:X},{axis:A})}})},2190:(Lt,ut,y)=>{"use strict";y.d(ut,{a:()=>k});var $=y(687),V=y(4251),H=y(1257),Q=y(983),Y=y(3239);const k=(0,y(4195).op)({where_:function W(A,X,Z){const G=(0,H._1)(X,"a","where"),it=(0,H._1)(Z,"b","where"),wt=(0,H._1)(A,"condition","where","bool"),K=(0,Y.assertAndGetBroadcastShape)((0,Y.assertAndGetBroadcastShape)(wt.shape,G.shape),it.shape),st=(0,Q.U)(wt,K),et=(0,Q.U)(G,K),dt=(0,Q.U)(it,K);return $.BV.runKernel(V.PhF,{condition:st,t:et,e:dt})}})},6467:(Lt,ut,y)=>{"use strict";y.d(ut,{l:()=>Q});var $=y(687),V=y(5359),H=y(3037);function Q(Y,R="float32"){if((0,V.Mu)(Y),"complex64"===R){const k=Q(Y,"float32"),A=Q(Y,"float32");return(0,H.P)(k,A)}const W=(0,V.wT)((0,V.NA)(Y),R);return $.BV.makeTensor(W,Y,R)}},3143:(Lt,ut,y)=>{"use strict";y.d(ut,{P:()=>R});var $=y(687),V=y(4251),H=y(1257);const R=(0,y(4195).op)({zerosLike_:function Y(W){const A={x:(0,H._1)(W,"x","zerosLike")};return $.BV.runKernel(V.RuY,A)}})},4705:(Lt,ut,y)=>{"use strict";function $(V){return V instanceof Float32Array||V instanceof Int32Array||V instanceof Uint8Array||V instanceof Uint8ClampedArray}y.d(ut,{j:()=>$})},4945:(Lt,ut,y)=>{"use strict";y.d(ut,{es:()=>q,YD:()=>wt,_w:()=>pt,t3:()=>ft,FZ:()=>St,Vp:()=>lt,Vi:()=>dt});var $=y(5861),V=y(2918),H=y(5359);const Q=20,Y=3,R=7;function W(B,ot,P,at){const nt=(0,H.e3)(ot),Gt=function k(B,ot,P,at){const nt=(0,H.NA)(ot),Gt=at[at.length-1],O=new Array(Gt).fill(0),Ct=ot.length,yt="complex64"===P?G(B):B;if(Ct>1)for(let vt=0;vt<nt/Gt;vt++){const xt=vt*Gt;for(let Mt=0;Mt<Gt;Mt++)O[Mt]=Math.max(O[Mt],A(yt[xt+Mt],0,P).length)}return O}(B,ot,P,nt),O=ot.length,Ct=Z(B,ot,P,nt,Gt),yt=["Tensor"];return at&&(yt.push(`  dtype: ${P}`),yt.push(`  rank: ${O}`),yt.push(`  shape: [${ot}]`),yt.push("  values:")),yt.push(Ct.map(vt=>"    "+vt).join("\n")),yt.join("\n")}function A(B,ot,P){let at;return at=Array.isArray(B)?`${parseFloat(B[0].toFixed(R))} + ${parseFloat(B[1].toFixed(R))}j`:(0,H.HD)(B)?`'${B}'`:"bool"===P?X(B):parseFloat(B.toFixed(R)).toString(),(0,H.oj)(at,ot)}function X(B){return 0===B?"false":"true"}function Z(B,ot,P,at,nt,Gt=!0){const O="complex64"===P?2:1,Ct=ot[0],yt=ot.length;if(0===yt)return"complex64"===P?[A(G(B)[0],0,P)]:"bool"===P?[X(B[0])]:[B[0].toString()];if(1===yt){if(Ct>Q){let se=Array.from(B.slice(0,Y*O)),we=Array.from(B.slice((Ct-Y)*O,Ct*O));return"complex64"===P&&(se=G(se),we=G(we)),["["+se.map((Me,Xe)=>A(Me,nt[Xe],P)).join(", ")+", ..., "+we.map((Me,Xe)=>A(Me,nt[Ct-Y+Xe],P)).join(", ")+"]"]}return["["+("complex64"===P?G(B):Array.from(B)).map((jt,se)=>A(jt,nt[se],P)).join(", ")+"]"]}const vt=ot.slice(1),xt=at.slice(1),Mt=at[0]*O,It=[];if(Ct>Q){for(let ee=0;ee<Y;ee++){const jt=ee*Mt;It.push(...Z(B.slice(jt,jt+Mt),vt,P,xt,nt,!1))}It.push("...");for(let ee=Ct-Y;ee<Ct;ee++){const jt=ee*Mt;It.push(...Z(B.slice(jt,jt+Mt),vt,P,xt,nt,ee===Ct-1))}}else for(let ee=0;ee<Ct;ee++){const jt=ee*Mt;It.push(...Z(B.slice(jt,jt+Mt),vt,P,xt,nt,ee===Ct-1))}const re=2===yt?",":"";It[0]="["+(Ct>0?It[0]+re:"");for(let ee=1;ee<It.length-1;ee++)It[ee]=" "+It[ee]+re;let Bt=",\n";for(let ee=2;ee<yt;ee++)Bt+="\n";return It[It.length-1]=" "+It[It.length-1]+"]"+(Gt?"":Bt),It}function G(B){const ot=[];for(let P=0;P<B.length;P+=2)ot.push([B[P],B[P+1]]);return ot}var it=y(1153);class wt{constructor(ot,P,at){if(this.dtype=P,this.shape=ot.slice(),this.size=H.NA(ot),null!=at){const nt=at.length;H.hu(nt===this.size,()=>`Length of values '${nt}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===P)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=at||H.rQ(P,this.size),this.strides=(0,H.e3)(ot)}set(ot,...P){0===P.length&&(P=[0]),H.hu(P.length===this.rank,()=>`The number of provided coordinates (${P.length}) must match the rank (${this.rank})`);const at=this.locToIndex(P);this.values[at]=ot}get(...ot){0===ot.length&&(ot=[0]);let P=0;for(const nt of ot){if(nt<0||nt>=this.shape[P])throw new Error(`Requested out of range element at ${ot}.   Buffer shape=${this.shape}`);P++}let at=ot[ot.length-1];for(let nt=0;nt<ot.length-1;++nt)at+=this.strides[nt]*ot[nt];return this.values[at]}locToIndex(ot){if(0===this.rank)return 0;if(1===this.rank)return ot[0];let P=ot[ot.length-1];for(let at=0;at<ot.length-1;++at)P+=this.strides[at]*ot[at];return P}indexToLoc(ot){if(0===this.rank)return[];if(1===this.rank)return[ot];const P=new Array(this.shape.length);for(let at=0;at<P.length-1;++at)P[at]=Math.floor(ot/this.strides[at]),ot-=P[at]*this.strides[at];return P[P.length-1]=ot,P}get rank(){return this.shape.length}toTensor(){return K().makeTensor(this.values,this.shape,this.dtype)}}let K=null,st=null,et=null;function dt(B){K=B}function lt(B){st=B}function St(B){et=B}class q{constructor(ot,P,at,nt){this.kept=!1,this.isDisposedInternal=!1,this.shape=ot.slice(),this.dtype=P||"float32",this.size=H.NA(ot),this.strides=(0,H.e3)(ot),this.dataId=at,this.id=nt,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var ot=this;return(0,$.Z)(function*(){const P=yield ot.data();return st.buffer(ot.shape,ot.dtype,P)})()}bufferSync(){return st.buffer(this.shape,this.dtype,this.dataSync())}array(){var ot=this;return(0,$.Z)(function*(){const P=yield ot.data();return(0,H.GX)(ot.shape,P,"complex64"===ot.dtype)})()}arraySync(){return(0,H.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var ot=this;return(0,$.Z)(function*(){ot.throwIfDisposed();const P=K().read(ot.dataId);if("string"===ot.dtype){const at=yield P;try{return at.map(nt=>it.decodeString(nt))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return P})()}dataToGPU(ot){return this.throwIfDisposed(),K().readToGPU(this.dataId,ot)}dataSync(){this.throwIfDisposed();const ot=K().readSync(this.dataId);if("string"===this.dtype)try{return ot.map(P=>it.decodeString(P))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return ot}bytes(){var ot=this;return(0,$.Z)(function*(){ot.throwIfDisposed();const P=yield K().read(ot.dataId);return"string"===ot.dtype?P:new Uint8Array(P.buffer)})()}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),K().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(ot=!1){return st.print(this,ot)}clone(){return this.throwIfDisposed(),st.clone(this)}toString(ot=!1){return W(this.dataSync(),this.shape,this.dtype,ot)}cast(ot){return this.throwIfDisposed(),st.cast(this,ot)}variable(ot=!0,P,at){return this.throwIfDisposed(),K().makeVariable(this,ot,P,at)}}function ft(){return(0,V.R)("Tensor",()=>q)}Object.defineProperty(q,Symbol.hasInstance,{value:B=>!!B&&null!=B.data&&null!=B.dataSync&&null!=B.throwIfDisposed}),ft();class pt extends q{constructor(ot,P,at,nt){super(ot.shape,ot.dtype,ot.dataId,nt),this.trainable=P,this.name=at}assign(ot){if(ot.dtype!==this.dtype)throw new Error(`dtype of the new value (${ot.dtype}) and previous value (${this.dtype}) must match`);if(!H.cO(ot.shape,this.shape))throw new Error(`shape of the new value (${ot.shape}) and previous value (${this.shape}) must match`);K().disposeTensor(this),this.dataId=ot.dataId,K().incRef(this,null)}dispose(){K().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(pt,Symbol.hasInstance,{value:B=>B instanceof q&&null!=B.assign&&B.assign instanceof Function})},7664:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{assertTypesMatch:()=>Y,getTensorsInContainer:()=>W,isTensorInList:()=>R,makeTypesMatch:()=>Q});var $=y(4945),V=y(1216),H=y(5359);function Q(X,Z){if(X.dtype===Z.dtype)return[X,Z];const G=(0,V.x8)(X.dtype,Z.dtype);return[X.cast(G),Z.cast(G)]}function Y(X,Z){(0,H.hu)(X.dtype===Z.dtype,()=>`The dtypes of the first(${X.dtype}) and second(${Z.dtype}) input must match`)}function R(X,Z){return Z.some(G=>G.id===X.id)}function W(X){const Z=[];return k(X,Z,new Set),Z}function k(X,Z,G){if(null==X)return;if(X instanceof $.es)return void Z.push(X);if(!function A(X){return Array.isArray(X)||"object"==typeof X}(X))return;const it=X;for(const wt in it){const K=it[wt];G.has(K)||(G.add(K),k(K,Z,G))}}},1257:(Lt,ut,y)=>{"use strict";y.d(ut,{C:()=>W,_1:()=>X,sI:()=>Z});var $=y(687),V=y(5527),H=y(4945),Q=y(1216),Y=y(1153),R=y(5359);function W(G,it){let wt=G;if((0,Y.isTypedArray)(G))return"string"===it?[]:[G.length];if((0,Q.Oq)(G))return[G.height,G.width*(G.channels||"RGBA").length];if((0,Q.$F)(G))return[G.buffer.size/(null==it?4:(0,R.bT)(it))];if(!Array.isArray(G))return[];const K=[];for(;Array.isArray(wt)||(0,Y.isTypedArray)(wt)&&"string"!==it;)K.push(wt.length),wt=wt[0];return Array.isArray(G)&&(0,V.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&k(G,K,[]),K}function k(G,it,wt){if(wt=wt||[],!Array.isArray(G)&&!(0,Y.isTypedArray)(G))return void(0,R.hu)(0===it.length,()=>`Element arr[${wt.join("][")}] is a primitive, but should be an array/TypedArray of ${it[0]} elements`);(0,R.hu)(it.length>0,()=>`Element arr[${wt.join("][")}] should be a primitive, but is an array of ${G.length} elements`),(0,R.hu)(G.length===it[0],()=>`Element arr[${wt.join("][")}] should have ${it[0]} elements, but has ${G.length} elements`);const K=it.slice(1);for(let st=0;st<G.length;++st)k(G[st],K,wt.concat(st))}function A(G,it,wt,K){if("string_or_numeric"!==G){if(null==G)throw new Error("Expected dtype cannot be null.");if("numeric"!==G&&G!==it||"numeric"===G&&"string"===it)throw new Error(`Argument '${wt}' passed to '${K}' must be ${G} tensor, but got ${it} tensor`)}}function X(G,it,wt,K="numeric"){if(G instanceof(0,H.t3)())return A(K,G.dtype,it,wt),G;let st=(0,R.D2)(G);if("string"!==st&&["bool","int32","float32"].indexOf(K)>=0&&(st=K),A(K,st,it,wt),null==G||!(0,Y.isTypedArray)(G)&&!Array.isArray(G)&&"number"!=typeof G&&"boolean"!=typeof G&&"string"!=typeof G)throw new Error(`Argument '${it}' passed to '${wt}' must be a Tensor or TensorLike, but got '${null==G?"null":G.constructor.name}'`);const et=W(G,st);!(0,Y.isTypedArray)(G)&&!Array.isArray(G)&&(G=[G]);const lt="string"!==st?(0,Y.toTypedArray)(G,st):(0,Y.flatten)(G,[],!0);return $.BV.makeTensor(lt,et,st)}function Z(G,it,wt,K="numeric"){if(!Array.isArray(G))throw new Error(`Argument ${it} passed to ${wt} must be a \`Tensor[]\` or \`TensorLike[]\``);return G.map((et,dt)=>X(et,`${it}[${dt}]`,wt,K))}},1216:(Lt,ut,y)=>{"use strict";y.d(ut,{$F:()=>X,Oq:()=>A,x8:()=>W,yw:()=>$,z4:()=>k});var $=function(Z){return Z.R0="R0",Z.R1="R1",Z.R2="R2",Z.R3="R3",Z.R4="R4",Z.R5="R5",Z.R6="R6",Z}($||{}),V=function(Z){return Z.float32="float32",Z.int32="int32",Z.bool="int32",Z.complex64="complex64",Z}(V||{}),H=function(Z){return Z.float32="float32",Z.int32="int32",Z.bool="bool",Z.complex64="complex64",Z}(H||{}),Q=function(Z){return Z.float32="float32",Z.int32="float32",Z.bool="float32",Z.complex64="complex64",Z}(Q||{}),Y=function(Z){return Z.float32="complex64",Z.int32="complex64",Z.bool="complex64",Z.complex64="complex64",Z}(Y||{});const R={float32:Q,int32:V,bool:H,complex64:Y};function W(Z,G){if("string"===Z||"string"===G){if("string"===Z&&"string"===G)return"string";throw new Error(`Can not upcast ${Z} with ${G}`)}return R[Z][G]}function k(Z){return W(Z,"int32")}function A(Z){return null!=Z&&"object"==typeof Z&&"texture"in Z&&Z.texture instanceof WebGLTexture}function X(Z){return typeof GPUBuffer<"u"&&null!=Z&&"object"==typeof Z&&"buffer"in Z&&Z.buffer instanceof GPUBuffer}},1153:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{arraysEqual:()=>H.cO,arraysEqualWithNull:()=>H.DK,assert:()=>H.hu,assertNonNegativeIntegerDimensions:()=>H.Mu,assertNonNull:()=>H.Cq,assertShapesMatch:()=>H.k5,bytesFromStringArray:()=>H.Ub,bytesPerElement:()=>H.bT,checkConversionForErrors:()=>H.D5,clamp:()=>H.uZ,computeStrides:()=>H.e3,convertBackendValuesAndArrayBuffer:()=>H.KS,createScalarValue:()=>pt,createShuffledIndices:()=>H.U$,decodeString:()=>Gt,distSquared:()=>H.E7,encodeString:()=>nt,fetch:()=>at,fingerPrint64:()=>ft,flatten:()=>Ct,getArrayFromDType:()=>H.rQ,getTypedArrayFromDType:()=>H.WP,hasEncodingLoss:()=>H.QB,hexToLong:()=>W,indexToLoc:()=>H.NE,inferDtype:()=>H.D2,inferFromImplicitShape:()=>H.JZ,isBoolean:()=>H.jn,isFunction:()=>H.mf,isInt:()=>H.GN,isNumber:()=>H.hj,isPromise:()=>H.tI,isScalarShape:()=>H.xH,isString:()=>H.HD,isTypedArray:()=>O,isValidDtype:()=>H.LP,locToIndex:()=>H.qy,makeOnesTypedArray:()=>H.p8,makeZerosNestedTypedArray:()=>H.l6,makeZerosTypedArray:()=>H.wT,nearestDivisor:()=>H.jP,nearestLargerEven:()=>H.nY,now:()=>P,parseAxisParam:()=>H.EC,randUniform:()=>H.bj,repeatedTry:()=>H.WD,rightPad:()=>H.oj,shuffle:()=>H.TV,shuffleCombo:()=>H.d7,sizeFromShape:()=>H.NA,sizeToSquarishShape:()=>H.YP,squeezeShape:()=>H.bp,sum:()=>H.Sm,swap:()=>H.LF,tanh:()=>H.AE,toNestedArray:()=>H.GX,toTypedArray:()=>ot});var $=y(5527),V=y(4705),H=y(5359),Q=y(186);const R=y.n(Q)()||Q;function W(yt){return R.fromString(yt,!0,16)}const k=W("c3a5c85c97cb3127"),A=W("b492b66fbe98f273"),X=W("9ae16a3b2f90404f");function Z(yt){return yt.xor(yt.shru(47))}function G(yt,vt,xt){const Mt=yt.slice(vt,vt+xt);return R.fromBytes(Array.from(Mt),!0,!0)}function it(yt,vt){return G(yt,vt,8)}function wt(yt,vt){return G(yt,vt,4)}function K(yt,vt){return 0===vt?yt:yt.shru(vt).or(yt.shl(64-vt))}function st(yt,vt,xt=W("9ddfea08eb382d69")){let Mt=yt.xor(vt).mul(xt);Mt=Mt.xor(Mt.shru(47));let It=vt.xor(Mt).mul(xt);return It=It.xor(It.shru(47)),It=It.mul(xt),It}function dt(yt,vt,xt,Mt){return function et(yt,vt,xt,Mt,It,re){It=It.add(yt),re=K(re.add(It).add(Mt),21);const Bt=It;return It=(It=It.add(vt)).add(xt),re=re.add(K(It,44)),[It.add(Mt),re.add(Bt)]}(it(yt,vt),it(yt,vt+8),it(yt,vt+16),it(yt,vt+24),xt,Mt)}function ft(yt,vt=yt.length){const xt=R.fromNumber(81,!0);if(vt<=32)return vt<=16?function lt(yt,vt=yt.length){if(vt>=8){const xt=X.add(2*vt),Mt=it(yt,0).add(X),It=it(yt,vt-8);return st(K(It,37).mul(xt).add(Mt),K(Mt,25).add(It).mul(xt),xt)}if(vt>=4){const xt=X.add(2*vt);return st(wt(yt,0).shl(3).add(vt),wt(yt,vt-4),xt)}if(vt>0){const Bt=vt+(yt[vt-1]<<2);return Z(X.mul(yt[0]+(yt[vt>>1]<<8)).xor(k.mul(Bt))).mul(X)}return X}(yt,vt):function St(yt,vt=yt.length){const xt=X.add(2*vt),Mt=it(yt,0).mul(A),It=it(yt,8),re=it(yt,vt-8).mul(xt),Bt=it(yt,vt-16).mul(X);return st(K(Mt.add(It),43).add(K(re,30)).add(Bt),Mt.add(K(It.add(X),18)).add(re),xt)}(yt,vt);if(vt<=64)return function q(yt,vt=yt.length){const xt=X.add(2*vt),Mt=it(yt,0).mul(X),It=it(yt,8),re=it(yt,vt-8).mul(xt),Bt=it(yt,vt-16).mul(X),ee=K(Mt.add(It),43).add(K(re,30)).add(Bt),jt=st(ee,Mt.add(K(It.add(X),18)).add(re),xt),se=it(yt,16).mul(xt),we=it(yt,24),Me=ee.add(it(yt,vt-32)).mul(xt),Xe=jt.add(it(yt,vt-24)).mul(xt);return st(K(se.add(we),43).add(K(Me,30)).add(Xe),se.add(K(we.add(Mt),18)).add(Me),xt)}(yt,vt);let Mt=xt,It=xt.mul(A).add(113),re=Z(It.mul(X).add(113)).mul(X),Bt=[R.UZERO,R.UZERO],ee=[R.UZERO,R.UZERO];Mt=Mt.mul(X).add(it(yt,0));let jt=0;const se=64*(vt-1>>6),we=se+(vt-1&63)-63;do{Mt=K(Mt.add(It).add(Bt[0]).add(it(yt,jt+8)),37).mul(A),It=K(It.add(Bt[1]).add(it(yt,jt+48)),42).mul(A),Mt=Mt.xor(ee[1]),It=It.add(Bt[0]).add(it(yt,jt+40)),re=K(re.add(ee[0]),33).mul(A),Bt=dt(yt,jt,Bt[1].mul(A),Mt.add(ee[0])),ee=dt(yt,jt+32,re.add(ee[1]),It.add(it(yt,jt+16))),[re,Mt]=[Mt,re],jt+=64}while(jt!==se);const Me=A.add(re.and(255).shl(1));return jt=we,ee[0]=ee[0].add(vt-1&63),Bt[0]=Bt[0].add(ee[0]),ee[0]=ee[0].add(Bt[0]),Mt=K(Mt.add(It).add(Bt[0]).add(it(yt,jt+8)),37).mul(Me),It=K(It.add(Bt[1]).add(it(yt,jt+48)),42).mul(Me),Mt=Mt.xor(ee[1].mul(9)),It=It.add(Bt[0].mul(9).add(it(yt,jt+40))),re=K(re.add(ee[0]),33).mul(Me),Bt=dt(yt,jt,Bt[1].mul(Me),Mt.add(ee[0])),ee=dt(yt,jt+32,re.add(ee[1]),It.add(it(yt,jt+16))),[re,Mt]=[Mt,re],st(st(Bt[0],ee[0],Me).add(Z(It).mul(k)).add(re),st(Bt[1],ee[1],Me).add(Mt),Me)}function pt(yt,vt){return"string"===vt?nt(yt):ot([yt],vt)}function ot(yt,vt){if("string"===vt)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(yt)&&(yt=Ct(yt)),(0,$.OB)().getBool("DEBUG")&&H.D5(yt,vt),function B(yt,vt){return yt instanceof Float32Array&&"float32"===vt||yt instanceof Int32Array&&"int32"===vt||yt instanceof Uint8Array&&"bool"===vt}(yt,vt))return yt;if(null==vt||"float32"===vt||"complex64"===vt)return new Float32Array(yt);if("int32"===vt)return new Int32Array(yt);if("bool"===vt){const xt=new Uint8Array(yt.length);for(let Mt=0;Mt<xt.length;++Mt)0!==Math.round(yt[Mt])&&(xt[Mt]=1);return xt}throw new Error(`Unknown data type ${vt}`)}function P(){return(0,$.OB)().platform.now()}function at(yt,vt){return(0,$.OB)().platform.fetch(yt,vt)}function nt(yt,vt="utf-8"){return vt=vt||"utf-8",(0,$.OB)().platform.encode(yt,vt)}function Gt(yt,vt="utf-8"){return vt=vt||"utf-8",(0,$.OB)().platform.decode(yt,vt)}function O(yt){return null!=(0,$.OB)().platform.isTypedArray?(0,$.OB)().platform.isTypedArray(yt):(0,V.j)(yt)}function Ct(yt,vt=[],xt=!1){if(null==vt&&(vt=[]),"boolean"==typeof yt||"number"==typeof yt||"string"==typeof yt||H.tI(yt)||null==yt||O(yt)&&xt)vt.push(yt);else if(Array.isArray(yt)||O(yt))for(let Mt=0;Mt<yt.length;++Mt)Ct(yt[Mt],vt,xt);else{let Mt=-1;for(const It of Object.keys(yt))/^([1-9]+[0-9]*|0)$/.test(It)&&(Mt=Math.max(Mt,Number(It)));for(let It=0;It<=Mt;It++)Ct(yt[It],vt,xt)}return vt}},5359:(Lt,ut,y)=>{"use strict";function $(ne){let pe=ne.length,Ie=0;for(;pe>0;)Ie=Math.random()*pe|0,pe--,Y(ne,pe,Ie)}function V(ne,pe){if(ne.length!==pe.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${ne.length}Second array length was ${pe.length}`);let Ie=ne.length,Je=0;for(;Ie>0;)Je=Math.random()*Ie|0,Ie--,Y(ne,Ie,Je),Y(pe,Ie,Je)}function H(ne,pe,Ie){return Math.max(ne,Math.min(pe,Ie))}function Q(ne){return ne%2==0?ne:ne+1}function Y(ne,pe,Ie){const Je=ne[pe];ne[pe]=ne[Ie],ne[Ie]=Je}function R(ne){let pe=0;for(let Ie=0;Ie<ne.length;Ie++)pe+=ne[Ie];return pe}function W(ne,pe){const Ie=Math.random();return pe*Ie+(1-Ie)*ne}function k(ne,pe){let Ie=0;for(let Je=0;Je<ne.length;Je++){const Wn=Number(ne[Je])-Number(pe[Je]);Ie+=Wn*Wn}return Ie}function A(ne,pe){if(!ne)throw new Error("string"==typeof pe?pe:pe())}function X(ne,pe,Ie=""){A(K(ne,pe),()=>Ie+` Shapes ${ne} and ${pe} must match`)}function Z(ne){A(null!=ne,()=>"The input to the tensor constructor must be a non-null value.")}function G(ne){if(0===ne.length)return 1;let pe=ne[0];for(let Ie=1;Ie<ne.length;Ie++)pe*=ne[Ie];return pe}function it(ne){return 0===ne.length}function wt(ne,pe){if(ne===pe)return!0;if(null==ne||null==pe||ne.length!==pe.length)return!1;for(let Ie=0;Ie<ne.length;Ie++)if(null!==ne[Ie]&&null!==pe[Ie]&&ne[Ie]!==pe[Ie])return!1;return!0}function K(ne,pe){if(ne===pe)return!0;if(null==ne||null==pe||ne.length!==pe.length)return!1;for(let Ie=0;Ie<ne.length;Ie++)if(ne[Ie]!==pe[Ie])return!1;return!0}function st(ne){return ne%1==0}function et(ne){if(null!=Math.tanh)return Math.tanh(ne);if(ne===1/0)return 1;if(ne===-1/0)return-1;{const pe=Math.exp(2*ne);return(pe-1)/(pe+1)}}function dt(ne){const pe=Math.ceil(Math.sqrt(ne));return[pe,Math.ceil(ne/pe)]}function lt(ne){const pe=new Uint32Array(ne);for(let Ie=0;Ie<ne;++Ie)pe[Ie]=Ie;return $(pe),pe}function St(ne,pe){return pe<=ne.length?ne:ne+" ".repeat(pe-ne.length)}function q(ne,pe=(Wn=>0),Ie,Je){return new Promise((Wn,Er)=>{let Nn=0;const Yn=()=>{if(ne())return void Wn();Nn++;const hi=pe(Nn);null!=Ie&&Nn>=Ie?Er():null!=Je?Je(Yn,hi):setTimeout(Yn,hi)};Yn()})}function ft(ne,pe){let Ie=1,Je=-1;for(let Er=0;Er<ne.length;++Er)if(ne[Er]>=0)Ie*=ne[Er];else if(-1===ne[Er]){if(-1!==Je)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Je} and dim ${Er}`);Je=Er}else if(ne[Er]<0)throw Error(`Shapes can not be < 0. Found ${ne[Er]} at dim ${Er}`);if(-1===Je){if(pe>0&&pe!==Ie)throw Error(`Size(${pe}) must match the product of shape ${ne}`);return ne}if(0===Ie)throw Error(`Cannot infer the missing size in [${ne}] when there are 0 elements`);if(pe%Ie!=0)throw Error(`The implicit shape can't be a fractional number. Got ${pe} / ${Ie}`);const Wn=ne.slice();return Wn[Je]=pe/Ie,Wn}function pt(ne,pe){const Ie=pe.length;return A((ne=null==ne?pe.map((Je,Wn)=>Wn):[].concat(ne)).every(Je=>Je>=-Ie&&Je<Ie),()=>`All values in axis param must be in range [-${Ie}, ${Ie}) but got axis ${ne}`),A(ne.every(Je=>st(Je)),()=>`All values in axis param must be integers but got axis ${ne}`),ne.map(Je=>Je<0?Ie+Je:Je)}function B(ne,pe){const Ie=[],Je=[],Wn=null!=pe&&Array.isArray(pe)&&0===pe.length,Er=null==pe||Wn?null:pt(pe,ne).sort();let Nn=0;for(let Yn=0;Yn<ne.length;++Yn){if(null!=Er){if(Er[Nn]===Yn&&1!==ne[Yn])throw new Error(`Can't squeeze axis ${Yn} since its dim '${ne[Yn]}' is not 1`);(null==Er[Nn]||Er[Nn]>Yn)&&1===ne[Yn]&&(Ie.push(ne[Yn]),Je.push(Yn)),Er[Nn]<=Yn&&Nn++}1!==ne[Yn]&&(Ie.push(ne[Yn]),Je.push(Yn))}return{newShape:Ie,keptDims:Je}}function ot(ne,pe){return P(ne,pe)}function P(ne,pe){let Ie=null;if(null==ne||"float32"===ne)Ie=new Float32Array(pe);else if("int32"===ne)Ie=new Int32Array(pe);else if("bool"===ne)Ie=new Uint8Array(pe);else{if("string"!==ne)throw new Error(`Unknown data type ${ne}`);Ie=new Array(pe)}return Ie}function at(ne,pe){for(let Ie=0;Ie<ne.length;Ie++){const Je=ne[Ie];if(isNaN(Je)||!isFinite(Je))throw Error(`A tensor of type ${pe} being uploaded contains ${Je}.`)}}function nt(ne){return"bool"===ne||"complex64"===ne||"float32"===ne||"int32"===ne||"string"===ne}function Gt(ne,pe){return!("complex64"===pe||"float32"===pe&&"complex64"!==ne||"int32"===pe&&"float32"!==ne&&"complex64"!==ne||"bool"===pe&&"bool"===ne)}function O(ne){if("float32"===ne||"int32"===ne)return 4;if("complex64"===ne)return 8;if("bool"===ne)return 1;throw new Error(`Unknown dtype ${ne}`)}function Ct(ne){if(null==ne)return 0;let pe=0;return ne.forEach(Ie=>pe+=Ie.length),pe}function yt(ne){return"string"==typeof ne||ne instanceof String}function vt(ne){return"boolean"==typeof ne}function xt(ne){return"number"==typeof ne}function Mt(ne){return Array.isArray(ne)?Mt(ne[0]):ne instanceof Float32Array?"float32":ne instanceof Int32Array||ne instanceof Uint8Array||ne instanceof Uint8ClampedArray?"int32":xt(ne)?"float32":yt(ne)?"string":vt(ne)?"bool":"float32"}function It(ne){return!!(ne&&ne.constructor&&ne.call&&ne.apply)}function re(ne,pe){for(let Ie=pe;Ie<ne;++Ie)if(ne%Ie==0)return Ie;return ne}function Bt(ne){const pe=ne.length;if(pe<2)return[];const Ie=new Array(pe-1);Ie[pe-2]=ne[pe-1];for(let Je=pe-3;Je>=0;--Je)Ie[Je]=Ie[Je+1]*ne[Je+1];return Ie}function ee(ne,pe,Ie,Je=!1){const Wn=new Array;if(1===pe.length){const Er=pe[0]*(Je?2:1);for(let Nn=0;Nn<Er;Nn++)Wn[Nn]=Ie[ne+Nn]}else{const Er=pe[0],Nn=pe.slice(1),Yn=Nn.reduce((hi,di)=>hi*di)*(Je?2:1);for(let hi=0;hi<Er;hi++)Wn[hi]=ee(ne+hi*Yn,Nn,Ie,Je)}return Wn}function jt(ne,pe,Ie=!1){if(0===ne.length)return pe[0];const Je=ne.reduce((Wn,Er)=>Wn*Er)*(Ie?2:1);if(0===Je)return[];if(Je!==pe.length)throw new Error(`[${ne}] does not match the input size ${pe.length}${Ie?" for a complex tensor":""}.`);return ee(0,ne,pe,Ie)}function se(ne,pe){if(Array.isArray(ne))return ne;if("float32"===pe)return ne instanceof Float32Array?ne:new Float32Array(ne);if("int32"===pe)return ne instanceof Int32Array?ne:new Int32Array(ne);if("bool"===pe||"string"===pe)return Uint8Array.from(new Int32Array(ne));throw new Error(`Unknown dtype ${pe}`)}function we(ne,pe){const Ie=Me(ne,pe);for(let Je=0;Je<Ie.length;Je++)Ie[Je]=1;return Ie}function Me(ne,pe){if(null==pe||"float32"===pe||"complex64"===pe)return new Float32Array(ne);if("int32"===pe)return new Int32Array(ne);if("bool"===pe)return new Uint8Array(ne);throw new Error(`Unknown data type ${pe}`)}function Xe(ne,pe){const Ie=ne.reduce((Je,Wn)=>Je*Wn,1);if(null==pe||"float32"===pe)return jt(ne,new Float32Array(Ie));if("int32"===pe)return jt(ne,new Int32Array(Ie));if("bool"===pe)return jt(ne,new Uint8Array(Ie));throw new Error(`Unknown data type ${pe}`)}function Ue(ne){ne.forEach(pe=>{A(Number.isInteger(pe)&&pe>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${ne}].`)})}function De(ne,pe,Ie){if(0===pe)return 0;if(1===pe)return ne[0];let Je=ne[ne.length-1];for(let Wn=0;Wn<ne.length-1;++Wn)Je+=Ie[Wn]*ne[Wn];return Je}function Tn(ne,pe,Ie){if(0===pe)return[];if(1===pe)return[ne];const Je=new Array(pe);for(let Wn=0;Wn<Je.length-1;++Wn)Je[Wn]=Math.floor(ne/Ie[Wn]),ne-=Je[Wn]*Ie[Wn];return Je[Je.length-1]=ne,Je}function On(ne){return ne&&ne.then&&"function"==typeof ne.then}y.d(ut,{AE:()=>et,Cq:()=>Z,D2:()=>Mt,D5:()=>at,DK:()=>wt,E7:()=>k,EC:()=>pt,GN:()=>st,GX:()=>jt,HD:()=>yt,JZ:()=>ft,KS:()=>se,LF:()=>Y,LP:()=>nt,Mu:()=>Ue,NA:()=>G,NE:()=>Tn,QB:()=>Gt,Sm:()=>R,TV:()=>$,U$:()=>lt,Ub:()=>Ct,WD:()=>q,WP:()=>ot,YP:()=>dt,bT:()=>O,bj:()=>W,bp:()=>B,cO:()=>K,d7:()=>V,e3:()=>Bt,hj:()=>xt,hu:()=>A,jP:()=>re,jn:()=>vt,k5:()=>X,l6:()=>Xe,mf:()=>It,nY:()=>Q,oj:()=>St,p8:()=>we,qy:()=>De,rQ:()=>P,tI:()=>On,uZ:()=>H,wT:()=>Me,xH:()=>it})},1568:(Lt,ut,y)=>{"use strict";var V=y(8570);function H(Q){var Y=[1/0,1/0,-1/0,-1/0];return V.coordEach(Q,function(R){Y[0]>R[0]&&(Y[0]=R[0]),Y[1]>R[1]&&(Y[1]=R[1]),Y[2]<R[0]&&(Y[2]=R[0]),Y[3]<R[1]&&(Y[3]=R[1])}),Y}H.default=H,ut.Z=H},621:(Lt,ut)=>{"use strict";function y(P,at,nt){void 0===nt&&(nt={});var Gt={type:"Feature"};return(0===nt.id||nt.id)&&(Gt.id=nt.id),nt.bbox&&(Gt.bbox=nt.bbox),Gt.properties=at||{},Gt.geometry=P,Gt}function V(P,at,nt){if(void 0===nt&&(nt={}),!P)throw new Error("coordinates is required");if(!Array.isArray(P))throw new Error("coordinates must be an Array");if(P.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!ft(P[0])||!ft(P[1]))throw new Error("coordinates must contain numbers");return y({type:"Point",coordinates:P},at,nt)}function Q(P,at,nt){void 0===nt&&(nt={});for(var Gt=0,O=P;Gt<O.length;Gt++){var Ct=O[Gt];if(Ct.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var yt=0;yt<Ct[Ct.length-1].length;yt++)if(Ct[Ct.length-1][yt]!==Ct[0][yt])throw new Error("First and last Position are not equivalent.")}return y({type:"Polygon",coordinates:P},at,nt)}function R(P,at,nt){if(void 0===nt&&(nt={}),P.length<2)throw new Error("coordinates must be an array of two or more positions");return y({type:"LineString",coordinates:P},at,nt)}function k(P,at){void 0===at&&(at={});var nt={type:"FeatureCollection"};return at.id&&(nt.id=at.id),at.bbox&&(nt.bbox=at.bbox),nt.features=P,nt}function A(P,at,nt){return void 0===nt&&(nt={}),y({type:"MultiLineString",coordinates:P},at,nt)}function X(P,at,nt){return void 0===nt&&(nt={}),y({type:"MultiPoint",coordinates:P},at,nt)}function Z(P,at,nt){return void 0===nt&&(nt={}),y({type:"MultiPolygon",coordinates:P},at,nt)}function wt(P,at){void 0===at&&(at="kilometers");var nt=ut.factors[at];if(!nt)throw new Error(at+" units is invalid");return P*nt}function K(P,at){void 0===at&&(at="kilometers");var nt=ut.factors[at];if(!nt)throw new Error(at+" units is invalid");return P/nt}function dt(P){return P%(2*Math.PI)*180/Math.PI}function ft(P){return!isNaN(P)&&null!==P&&!Array.isArray(P)}Object.defineProperty(ut,"__esModule",{value:!0}),ut.earthRadius=6371008.8,ut.factors={centimeters:100*ut.earthRadius,centimetres:100*ut.earthRadius,degrees:ut.earthRadius/111325,feet:3.28084*ut.earthRadius,inches:39.37*ut.earthRadius,kilometers:ut.earthRadius/1e3,kilometres:ut.earthRadius/1e3,meters:ut.earthRadius,metres:ut.earthRadius,miles:ut.earthRadius/1609.344,millimeters:1e3*ut.earthRadius,millimetres:1e3*ut.earthRadius,nauticalmiles:ut.earthRadius/1852,radians:1,yards:1.0936*ut.earthRadius},ut.unitsFactors={centimeters:100,centimetres:100,degrees:1/111325,feet:3.28084,inches:39.37,kilometers:.001,kilometres:.001,meters:1,metres:1,miles:1/1609.344,millimeters:1e3,millimetres:1e3,nauticalmiles:1/1852,radians:1/ut.earthRadius,yards:1.0936133},ut.areaFactors={acres:247105e-9,centimeters:1e4,centimetres:1e4,feet:10.763910417,hectares:1e-4,inches:1550.003100006,kilometers:1e-6,kilometres:1e-6,meters:1,metres:1,miles:386e-9,millimeters:1e6,millimetres:1e6,yards:1.195990046},ut.feature=y,ut.geometry=function $(P,at,nt){switch(void 0===nt&&(nt={}),P){case"Point":return V(at).geometry;case"LineString":return R(at).geometry;case"Polygon":return Q(at).geometry;case"MultiPoint":return X(at).geometry;case"MultiLineString":return A(at).geometry;case"MultiPolygon":return Z(at).geometry;default:throw new Error(P+" is invalid")}},ut.point=V,ut.points=function H(P,at,nt){return void 0===nt&&(nt={}),k(P.map(function(Gt){return V(Gt,at)}),nt)},ut.polygon=Q,ut.polygons=function Y(P,at,nt){return void 0===nt&&(nt={}),k(P.map(function(Gt){return Q(Gt,at)}),nt)},ut.lineString=R,ut.lineStrings=function W(P,at,nt){return void 0===nt&&(nt={}),k(P.map(function(Gt){return R(Gt,at)}),nt)},ut.featureCollection=k,ut.multiLineString=A,ut.multiPoint=X,ut.multiPolygon=Z,ut.geometryCollection=function G(P,at,nt){return void 0===nt&&(nt={}),y({type:"GeometryCollection",geometries:P},at,nt)},ut.round=function it(P,at){if(void 0===at&&(at=0),at&&!(at>=0))throw new Error("precision must be a positive number");var nt=Math.pow(10,at||0);return Math.round(P*nt)/nt},ut.radiansToLength=wt,ut.lengthToRadians=K,ut.lengthToDegrees=function st(P,at){return dt(K(P,at))},ut.bearingToAzimuth=function et(P){var at=P%360;return at<0&&(at+=360),at},ut.radiansToDegrees=dt,ut.degreesToRadians=function lt(P){return P%360*Math.PI/180},ut.convertLength=function St(P,at,nt){if(void 0===at&&(at="kilometers"),void 0===nt&&(nt="kilometers"),!(P>=0))throw new Error("length must be a positive number");return wt(K(P,at),nt)},ut.convertArea=function q(P,at,nt){if(void 0===at&&(at="meters"),void 0===nt&&(nt="kilometers"),!(P>=0))throw new Error("area must be a positive number");var Gt=ut.areaFactors[at];if(!Gt)throw new Error("invalid original units");var O=ut.areaFactors[nt];if(!O)throw new Error("invalid final units");return P/Gt*O},ut.isNumber=ft,ut.isObject=function pt(P){return!!P&&P.constructor===Object},ut.validateBBox=function B(P){if(!P)throw new Error("bbox is required");if(!Array.isArray(P))throw new Error("bbox must be an Array");if(4!==P.length&&6!==P.length)throw new Error("bbox must be an Array of 4 or 6 numbers");P.forEach(function(at){if(!ft(at))throw new Error("bbox must only contain numbers")})},ut.validateId=function ot(P){if(!P)throw new Error("id is required");if(-1===["string","number"].indexOf(typeof P))throw new Error("id must be a number or a string")}},8570:(Lt,ut,y)=>{"use strict";Object.defineProperty(ut,"__esModule",{value:!0});var $=y(621);function V(lt,St,q){if(null!==lt)for(var ft,pt,B,ot,P,at,nt,Ct,Gt=0,O=0,yt=lt.type,vt="FeatureCollection"===yt,xt="Feature"===yt,Mt=vt?lt.features.length:1,It=0;It<Mt;It++){P=(Ct=!!(nt=vt?lt.features[It].geometry:xt?lt.geometry:lt)&&"GeometryCollection"===nt.type)?nt.geometries.length:1;for(var re=0;re<P;re++){var Bt=0,ee=0;if(null!==(ot=Ct?nt.geometries[re]:nt)){at=ot.coordinates;var jt=ot.type;switch(Gt=!q||"Polygon"!==jt&&"MultiPolygon"!==jt?0:1,jt){case null:break;case"Point":if(!1===St(at,O,It,Bt,ee))return!1;O++,Bt++;break;case"LineString":case"MultiPoint":for(ft=0;ft<at.length;ft++){if(!1===St(at[ft],O,It,Bt,ee))return!1;O++,"MultiPoint"===jt&&Bt++}"LineString"===jt&&Bt++;break;case"Polygon":case"MultiLineString":for(ft=0;ft<at.length;ft++){for(pt=0;pt<at[ft].length-Gt;pt++){if(!1===St(at[ft][pt],O,It,Bt,ee))return!1;O++}"MultiLineString"===jt&&Bt++,"Polygon"===jt&&ee++}"Polygon"===jt&&Bt++;break;case"MultiPolygon":for(ft=0;ft<at.length;ft++){for(ee=0,pt=0;pt<at[ft].length;pt++){for(B=0;B<at[ft][pt].length-Gt;B++){if(!1===St(at[ft][pt][B],O,It,Bt,ee))return!1;O++}ee++}Bt++}break;case"GeometryCollection":for(ft=0;ft<ot.geometries.length;ft++)if(!1===V(ot.geometries[ft],St,q))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function Q(lt,St){var q;switch(lt.type){case"FeatureCollection":for(q=0;q<lt.features.length&&!1!==St(lt.features[q].properties,q);q++);break;case"Feature":St(lt.properties,0)}}function R(lt,St){if("Feature"===lt.type)St(lt,0);else if("FeatureCollection"===lt.type)for(var q=0;q<lt.features.length&&!1!==St(lt.features[q],q);q++);}function A(lt,St){var q,ft,pt,B,ot,P,at,nt,Gt,O,Ct=0,yt="FeatureCollection"===lt.type,vt="Feature"===lt.type,xt=yt?lt.features.length:1;for(q=0;q<xt;q++){for(nt=yt?lt.features[q].properties:vt?lt.properties:{},Gt=yt?lt.features[q].bbox:vt?lt.bbox:void 0,O=yt?lt.features[q].id:vt?lt.id:void 0,ot=(at=!!(P=yt?lt.features[q].geometry:vt?lt.geometry:lt)&&"GeometryCollection"===P.type)?P.geometries.length:1,pt=0;pt<ot;pt++)if(null!==(B=at?P.geometries[pt]:P))switch(B.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===St(B,Ct,nt,Gt,O))return!1;break;case"GeometryCollection":for(ft=0;ft<B.geometries.length;ft++)if(!1===St(B.geometries[ft],Ct,nt,Gt,O))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===St(null,Ct,nt,Gt,O))return!1;Ct++}}function Z(lt,St){A(lt,function(q,ft,pt,B,ot){var at,P=null===q?null:q.type;switch(P){case null:case"Point":case"LineString":case"Polygon":return!1!==St($.feature(q,pt,{bbox:B,id:ot}),ft,0)&&void 0}switch(P){case"MultiPoint":at="Point";break;case"MultiLineString":at="LineString";break;case"MultiPolygon":at="Polygon"}for(var nt=0;nt<q.coordinates.length;nt++)if(!1===St($.feature({type:at,coordinates:q.coordinates[nt]},pt),ft,nt))return!1})}function it(lt,St){Z(lt,function(q,ft,pt){var B=0;if(q.geometry){var ot=q.geometry.type;if("Point"!==ot&&"MultiPoint"!==ot){var P,at=0,nt=0,Gt=0;if(!1===V(q,function(O,Ct,yt,vt,xt){if(void 0===P||ft>at||vt>nt||xt>Gt)return P=O,at=ft,nt=vt,Gt=xt,void(B=0);var Mt=$.lineString([P,O],q.properties);if(!1===St(Mt,ft,pt,xt,B))return!1;B++,P=O}))return!1}}})}function K(lt,St){if(!lt)throw new Error("geojson is required");Z(lt,function(q,ft,pt){if(null!==q.geometry){var ot=q.geometry.coordinates;switch(q.geometry.type){case"LineString":if(!1===St(q,ft,pt,0,0))return!1;break;case"Polygon":for(var P=0;P<ot.length;P++)if(!1===St($.lineString(ot[P],q.properties),ft,pt,P))return!1}}})}ut.coordAll=function k(lt){var St=[];return V(lt,function(q){St.push(q)}),St},ut.coordEach=V,ut.coordReduce=function H(lt,St,q,ft){var pt=q;return V(lt,function(B,ot,P,at,nt){pt=0===ot&&void 0===q?B:St(pt,B,ot,P,at,nt)},ft),pt},ut.featureEach=R,ut.featureReduce=function W(lt,St,q){var ft=q;return R(lt,function(pt,B){ft=0===B&&void 0===q?pt:St(ft,pt,B)}),ft},ut.findPoint=function dt(lt,St){if(!$.isObject(St=St||{}))throw new Error("options is invalid");var P,q=St.featureIndex||0,ft=St.multiFeatureIndex||0,pt=St.geometryIndex||0,B=St.coordIndex||0,ot=St.properties;switch(lt.type){case"FeatureCollection":q<0&&(q=lt.features.length+q),ot=ot||lt.features[q].properties,P=lt.features[q].geometry;break;case"Feature":ot=ot||lt.properties,P=lt.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":P=lt;break;default:throw new Error("geojson is invalid")}if(null===P)return null;var at=P.coordinates;switch(P.type){case"Point":return $.point(at,ot,St);case"MultiPoint":return ft<0&&(ft=at.length+ft),$.point(at[ft],ot,St);case"LineString":return B<0&&(B=at.length+B),$.point(at[B],ot,St);case"Polygon":return pt<0&&(pt=at.length+pt),B<0&&(B=at[pt].length+B),$.point(at[pt][B],ot,St);case"MultiLineString":return ft<0&&(ft=at.length+ft),B<0&&(B=at[ft].length+B),$.point(at[ft][B],ot,St);case"MultiPolygon":return ft<0&&(ft=at.length+ft),pt<0&&(pt=at[ft].length+pt),B<0&&(B=at[ft][pt].length-B),$.point(at[ft][pt][B],ot,St)}throw new Error("geojson is invalid")},ut.findSegment=function et(lt,St){if(!$.isObject(St=St||{}))throw new Error("options is invalid");var P,q=St.featureIndex||0,ft=St.multiFeatureIndex||0,pt=St.geometryIndex||0,B=St.segmentIndex||0,ot=St.properties;switch(lt.type){case"FeatureCollection":q<0&&(q=lt.features.length+q),ot=ot||lt.features[q].properties,P=lt.features[q].geometry;break;case"Feature":ot=ot||lt.properties,P=lt.geometry;break;case"Point":case"MultiPoint":return null;case"LineString":case"Polygon":case"MultiLineString":case"MultiPolygon":P=lt;break;default:throw new Error("geojson is invalid")}if(null===P)return null;var at=P.coordinates;switch(P.type){case"Point":case"MultiPoint":return null;case"LineString":return B<0&&(B=at.length+B-1),$.lineString([at[B],at[B+1]],ot,St);case"Polygon":return pt<0&&(pt=at.length+pt),B<0&&(B=at[pt].length+B-1),$.lineString([at[pt][B],at[pt][B+1]],ot,St);case"MultiLineString":return ft<0&&(ft=at.length+ft),B<0&&(B=at[ft].length+B-1),$.lineString([at[ft][B],at[ft][B+1]],ot,St);case"MultiPolygon":return ft<0&&(ft=at.length+ft),pt<0&&(pt=at[ft].length+pt),B<0&&(B=at[ft][pt].length-B-1),$.lineString([at[ft][pt][B],at[ft][pt][B+1]],ot,St)}throw new Error("geojson is invalid")},ut.flattenEach=Z,ut.flattenReduce=function G(lt,St,q){var ft=q;return Z(lt,function(pt,B,ot){ft=0===B&&0===ot&&void 0===q?pt:St(ft,pt,B,ot)}),ft},ut.geomEach=A,ut.geomReduce=function X(lt,St,q){var ft=q;return A(lt,function(pt,B,ot,P,at){ft=0===B&&void 0===q?pt:St(ft,pt,B,ot,P,at)}),ft},ut.lineEach=K,ut.lineReduce=function st(lt,St,q){var ft=q;return K(lt,function(pt,B,ot,P){ft=0===B&&void 0===q?pt:St(ft,pt,B,ot,P)}),ft},ut.propEach=Q,ut.propReduce=function Y(lt,St,q){var ft=q;return Q(lt,function(pt,B){ft=0===B&&void 0===q?pt:St(ft,pt,B)}),ft},ut.segmentEach=it,ut.segmentReduce=function wt(lt,St,q){var ft=q,pt=!1;return it(lt,function(B,ot,P,at,nt){ft=!1===pt&&void 0===q?B:St(ft,B,ot,P,at,nt),pt=!0}),ft}},1098:(Lt,ut,y)=>{"use strict";var $=y(491),V=y(5436),H=V($("String.prototype.indexOf"));Lt.exports=function(Y,R){var W=$(Y,!!R);return"function"==typeof W&&H(Y,".prototype.")>-1?V(W):W}},5436:(Lt,ut,y)=>{"use strict";var $=y(5333),V=y(491),H=y(2245),Q=y(5223),Y=V("%Function.prototype.apply%"),R=V("%Function.prototype.call%"),W=V("%Reflect.apply%",!0)||$.call(R,Y),k=y(474),A=V("%Math.max%");Lt.exports=function(G){if("function"!=typeof G)throw new Q("a function is required");var it=W($,R,arguments);return H(it,1+A(0,G.length-(arguments.length-1)),!0)};var X=function(){return W($,Y,arguments)};k?k(Lt.exports,"apply",{value:X}):Lt.exports.apply=X},3664:(Lt,ut,y)=>{"use strict";var $=y(938),V=y(7935),H=y(4179),Q=y(6138).orient2d;function Y(q,ft,pt){ft=Math.max(0,void 0===ft?2:ft),pt=pt||0;var B=function wt(q){for(var ft=q[0],pt=q[0],B=q[0],ot=q[0],P=0;P<q.length;P++){var at=q[P];at[0]<ft[0]&&(ft=at),at[0]>B[0]&&(B=at),at[1]<pt[1]&&(pt=at),at[1]>ot[1]&&(ot=at)}var nt=[ft,pt,B,ot],Gt=nt.slice();for(P=0;P<q.length;P++)H(q[P],nt)||Gt.push(q[P]);return function St(q){q.sort(lt);for(var ft=[],pt=0;pt<q.length;pt++){for(;ft.length>=2&&Z(ft[ft.length-2],ft[ft.length-1],q[pt])<=0;)ft.pop();ft.push(q[pt])}for(var B=[],ot=q.length-1;ot>=0;ot--){for(;B.length>=2&&Z(B[B.length-2],B[B.length-1],q[ot])<=0;)B.pop();B.push(q[ot])}return B.pop(),ft.pop(),ft.concat(B)}(Gt)}(q),ot=new $(16);ot.toBBox=function(ee){return{minX:ee[0],minY:ee[1],maxX:ee[0],maxY:ee[1]}},ot.compareMinX=function(ee,jt){return ee[0]-jt[0]},ot.compareMinY=function(ee,jt){return ee[1]-jt[1]},ot.load(q);for(var nt,P=[],at=0;at<B.length;at++){var Gt=B[at];ot.remove(Gt),nt=K(Gt,nt),P.push(nt)}var O=new $(16);for(at=0;at<P.length;at++)O.insert(it(P[at]));for(var Ct=ft*ft,yt=pt*pt;P.length;){var vt=P.shift(),xt=vt.p,Mt=vt.next.p,It=st(xt,Mt);if(!(It<yt)){var re=It/Ct;(Gt=R(ot,vt.prev.p,xt,Mt,vt.next.next.p,re,O))&&Math.min(st(Gt,xt),st(Gt,Mt))<=re&&(P.push(vt),P.push(K(Gt,vt)),ot.remove(Gt),O.remove(vt),O.insert(it(vt)),O.insert(it(vt.next)))}}vt=nt;var Bt=[];do{Bt.push(vt.p),vt=vt.next}while(vt!==nt);return Bt.push(vt.p),Bt}function R(q,ft,pt,B,ot,P,at){for(var nt=new V([],W),Gt=q.data;Gt;){for(var O=0;O<Gt.children.length;O++){var Ct=Gt.children[O],yt=Gt.leaf?et(Ct,pt,B):k(pt,B,Ct);yt>P||nt.push({node:Ct,dist:yt})}for(;nt.length&&!nt.peek().node.children;){var vt=nt.pop(),xt=vt.node,Mt=et(xt,ft,pt),It=et(xt,B,ot);if(vt.dist<Mt&&vt.dist<It&&X(pt,xt,at)&&X(B,xt,at))return xt}(Gt=nt.pop())&&(Gt=Gt.node)}return null}function W(q,ft){return q.dist-ft.dist}function k(q,ft,pt){if(A(q,pt)||A(ft,pt))return 0;var B=dt(q[0],q[1],ft[0],ft[1],pt.minX,pt.minY,pt.maxX,pt.minY);if(0===B)return 0;var ot=dt(q[0],q[1],ft[0],ft[1],pt.minX,pt.minY,pt.minX,pt.maxY);if(0===ot)return 0;var P=dt(q[0],q[1],ft[0],ft[1],pt.maxX,pt.minY,pt.maxX,pt.maxY);if(0===P)return 0;var at=dt(q[0],q[1],ft[0],ft[1],pt.minX,pt.maxY,pt.maxX,pt.maxY);return 0===at?0:Math.min(B,ot,P,at)}function A(q,ft){return q[0]>=ft.minX&&q[0]<=ft.maxX&&q[1]>=ft.minY&&q[1]<=ft.maxY}function X(q,ft,pt){for(var B=Math.min(q[0],ft[0]),ot=Math.min(q[1],ft[1]),P=Math.max(q[0],ft[0]),at=Math.max(q[1],ft[1]),nt=pt.search({minX:B,minY:ot,maxX:P,maxY:at}),Gt=0;Gt<nt.length;Gt++)if(G(nt[Gt].p,nt[Gt].next.p,q,ft))return!1;return!0}function Z(q,ft,pt){return Q(q[0],q[1],ft[0],ft[1],pt[0],pt[1])}function G(q,ft,pt,B){return q!==B&&ft!==pt&&Z(q,ft,pt)>0!=Z(q,ft,B)>0&&Z(pt,B,q)>0!=Z(pt,B,ft)>0}function it(q){var ft=q.p,pt=q.next.p;return q.minX=Math.min(ft[0],pt[0]),q.minY=Math.min(ft[1],pt[1]),q.maxX=Math.max(ft[0],pt[0]),q.maxY=Math.max(ft[1],pt[1]),q}function K(q,ft){var pt={p:q,prev:null,next:null,minX:0,minY:0,maxX:0,maxY:0};return ft?(pt.next=ft.next,pt.prev=ft,ft.next.prev=pt,ft.next=pt):(pt.prev=pt,pt.next=pt),pt}function st(q,ft){var pt=q[0]-ft[0],B=q[1]-ft[1];return pt*pt+B*B}function et(q,ft,pt){var B=ft[0],ot=ft[1],P=pt[0]-B,at=pt[1]-ot;if(0!==P||0!==at){var nt=((q[0]-B)*P+(q[1]-ot)*at)/(P*P+at*at);nt>1?(B=pt[0],ot=pt[1]):nt>0&&(B+=P*nt,ot+=at*nt)}return(P=q[0]-B)*P+(at=q[1]-ot)*at}function dt(q,ft,pt,B,ot,P,at,nt){var se,we,Me,Xe,Gt=pt-q,O=B-ft,Ct=at-ot,yt=nt-P,vt=q-ot,xt=ft-P,Mt=Gt*Gt+O*O,It=Gt*Ct+O*yt,re=Ct*Ct+yt*yt,Bt=Gt*vt+O*xt,ee=Ct*vt+yt*xt,jt=Mt*re-It*It,Ue=jt,De=jt;0===jt?(we=0,Ue=1,Xe=ee,De=re):(Xe=Mt*ee-It*Bt,(we=It*ee-re*Bt)<0?(we=0,Xe=ee,De=re):we>Ue&&(we=Ue,Xe=ee+It,De=re)),Xe<0?(Xe=0,-Bt<0?we=0:-Bt>Mt?we=Ue:(we=-Bt,Ue=Mt)):Xe>De&&(Xe=De,-Bt+It<0?we=0:-Bt+It>Mt?we=Ue:(we=-Bt+It,Ue=Mt));var Ie=(1-(Me=0===Xe?0:Xe/De))*ot+Me*at-((1-(se=0===we?0:we/Ue))*q+se*pt),Je=(1-Me)*P+Me*nt-((1-se)*ft+se*B);return Ie*Ie+Je*Je}function lt(q,ft){return q[0]===ft[0]?q[1]-ft[1]:q[0]-ft[0]}V.default&&(V=V.default),Lt.exports=Y,Lt.exports.default=Y},938:function(Lt){Lt.exports=function(){"use strict";function ut(K,st,et,dt,lt){!function St(q,ft,pt,B,ot){for(;B>pt;){if(B-pt>600){var P=B-pt+1,at=ft-pt+1,nt=Math.log(P),Gt=.5*Math.exp(2*nt/3),O=.5*Math.sqrt(nt*Gt*(P-Gt)/P)*(at-P/2<0?-1:1);St(q,ft,Math.max(pt,Math.floor(ft-at*Gt/P+O)),Math.min(B,Math.floor(ft+(P-at)*Gt/P+O)),ot)}var vt=q[ft],xt=pt,Mt=B;for(y(q,pt,ft),ot(q[B],vt)>0&&y(q,pt,B);xt<Mt;){for(y(q,xt,Mt),xt++,Mt--;ot(q[xt],vt)<0;)xt++;for(;ot(q[Mt],vt)>0;)Mt--}0===ot(q[pt],vt)?y(q,pt,Mt):y(q,++Mt,B),Mt<=ft&&(pt=Mt+1),ft<=Mt&&(B=Mt-1)}}(K,st,et||0,dt||K.length-1,lt||$)}function y(K,st,et){var dt=K[st];K[st]=K[et],K[et]=dt}function $(K,st){return K<st?-1:K>st?1:0}var V=function(K){void 0===K&&(K=9),this._maxEntries=Math.max(4,K),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function H(K,st,et){if(!et)return st.indexOf(K);for(var dt=0;dt<st.length;dt++)if(et(K,st[dt]))return dt;return-1}function Q(K,st){Y(K,0,K.children.length,st,K)}function Y(K,st,et,dt,lt){lt||(lt=it(null)),lt.minX=1/0,lt.minY=1/0,lt.maxX=-1/0,lt.maxY=-1/0;for(var St=st;St<et;St++){var q=K.children[St];R(lt,K.leaf?dt(q):q)}return lt}function R(K,st){return K.minX=Math.min(K.minX,st.minX),K.minY=Math.min(K.minY,st.minY),K.maxX=Math.max(K.maxX,st.maxX),K.maxY=Math.max(K.maxY,st.maxY),K}function W(K,st){return K.minX-st.minX}function k(K,st){return K.minY-st.minY}function A(K){return(K.maxX-K.minX)*(K.maxY-K.minY)}function X(K){return K.maxX-K.minX+(K.maxY-K.minY)}function Z(K,st){return K.minX<=st.minX&&K.minY<=st.minY&&st.maxX<=K.maxX&&st.maxY<=K.maxY}function G(K,st){return st.minX<=K.maxX&&st.minY<=K.maxY&&st.maxX>=K.minX&&st.maxY>=K.minY}function it(K){return{children:K,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function wt(K,st,et,dt,lt){for(var St=[st,et];St.length;)if(!((et=St.pop())-(st=St.pop())<=dt)){var q=st+Math.ceil((et-st)/dt/2)*dt;ut(K,q,st,et,lt),St.push(st,q,q,et)}}return V.prototype.all=function(){return this._all(this.data,[])},V.prototype.search=function(K){var st=this.data,et=[];if(!G(K,st))return et;for(var dt=this.toBBox,lt=[];st;){for(var St=0;St<st.children.length;St++){var q=st.children[St],ft=st.leaf?dt(q):q;G(K,ft)&&(st.leaf?et.push(q):Z(K,ft)?this._all(q,et):lt.push(q))}st=lt.pop()}return et},V.prototype.collides=function(K){var st=this.data;if(!G(K,st))return!1;for(var et=[];st;){for(var dt=0;dt<st.children.length;dt++){var lt=st.children[dt],St=st.leaf?this.toBBox(lt):lt;if(G(K,St)){if(st.leaf||Z(K,St))return!0;et.push(lt)}}st=et.pop()}return!1},V.prototype.load=function(K){if(!K||!K.length)return this;if(K.length<this._minEntries){for(var st=0;st<K.length;st++)this.insert(K[st]);return this}var et=this._build(K.slice(),0,K.length-1,0);if(this.data.children.length)if(this.data.height===et.height)this._splitRoot(this.data,et);else{if(this.data.height<et.height){var dt=this.data;this.data=et,et=dt}this._insert(et,this.data.height-et.height-1,!0)}else this.data=et;return this},V.prototype.insert=function(K){return K&&this._insert(K,this.data.height-1),this},V.prototype.clear=function(){return this.data=it([]),this},V.prototype.remove=function(K,st){if(!K)return this;for(var et,dt,lt,St=this.data,q=this.toBBox(K),ft=[],pt=[];St||ft.length;){if(St||(St=ft.pop(),dt=ft[ft.length-1],et=pt.pop(),lt=!0),St.leaf){var B=H(K,St.children,st);if(-1!==B)return St.children.splice(B,1),ft.push(St),this._condense(ft),this}lt||St.leaf||!Z(St,q)?dt?(et++,St=dt.children[et],lt=!1):St=null:(ft.push(St),pt.push(et),et=0,dt=St,St=St.children[0])}return this},V.prototype.toBBox=function(K){return K},V.prototype.compareMinX=function(K,st){return K.minX-st.minX},V.prototype.compareMinY=function(K,st){return K.minY-st.minY},V.prototype.toJSON=function(){return this.data},V.prototype.fromJSON=function(K){return this.data=K,this},V.prototype._all=function(K,st){for(var et=[];K;)K.leaf?st.push.apply(st,K.children):et.push.apply(et,K.children),K=et.pop();return st},V.prototype._build=function(K,st,et,dt){var lt,St=et-st+1,q=this._maxEntries;if(St<=q)return Q(lt=it(K.slice(st,et+1)),this.toBBox),lt;dt||(dt=Math.ceil(Math.log(St)/Math.log(q)),q=Math.ceil(St/Math.pow(q,dt-1))),(lt=it([])).leaf=!1,lt.height=dt;var ft=Math.ceil(St/q),pt=ft*Math.ceil(Math.sqrt(q));wt(K,st,et,pt,this.compareMinX);for(var B=st;B<=et;B+=pt){var ot=Math.min(B+pt-1,et);wt(K,B,ot,ft,this.compareMinY);for(var P=B;P<=ot;P+=ft){var at=Math.min(P+ft-1,ot);lt.children.push(this._build(K,P,at,dt-1))}}return Q(lt,this.toBBox),lt},V.prototype._chooseSubtree=function(K,st,et,dt){for(;dt.push(st),!st.leaf&&dt.length-1!==et;){for(var lt=1/0,St=1/0,q=void 0,ft=0;ft<st.children.length;ft++){var pt=st.children[ft],B=A(pt),ot=(P=K,at=pt,(Math.max(at.maxX,P.maxX)-Math.min(at.minX,P.minX))*(Math.max(at.maxY,P.maxY)-Math.min(at.minY,P.minY))-B);ot<St?(St=ot,lt=B<lt?B:lt,q=pt):ot===St&&B<lt&&(lt=B,q=pt)}st=q||st.children[0]}var P,at;return st},V.prototype._insert=function(K,st,et){var dt=et?K:this.toBBox(K),lt=[],St=this._chooseSubtree(dt,this.data,st,lt);for(St.children.push(K),R(St,dt);st>=0&&lt[st].children.length>this._maxEntries;)this._split(lt,st),st--;this._adjustParentBBoxes(dt,lt,st)},V.prototype._split=function(K,st){var et=K[st],dt=et.children.length,lt=this._minEntries;this._chooseSplitAxis(et,lt,dt);var St=this._chooseSplitIndex(et,lt,dt),q=it(et.children.splice(St,et.children.length-St));q.height=et.height,q.leaf=et.leaf,Q(et,this.toBBox),Q(q,this.toBBox),st?K[st-1].children.push(q):this._splitRoot(et,q)},V.prototype._splitRoot=function(K,st){this.data=it([K,st]),this.data.height=K.height+1,this.data.leaf=!1,Q(this.data,this.toBBox)},V.prototype._chooseSplitIndex=function(K,st,et){for(var dt,lt,St,q,ft,pt,B,ot=1/0,P=1/0,at=st;at<=et-st;at++){var nt=Y(K,0,at,this.toBBox),Gt=Y(K,at,et,this.toBBox),O=(lt=nt,St=Gt,void 0,void 0,void 0,void 0,q=Math.max(lt.minX,St.minX),ft=Math.max(lt.minY,St.minY),pt=Math.min(lt.maxX,St.maxX),B=Math.min(lt.maxY,St.maxY),Math.max(0,pt-q)*Math.max(0,B-ft)),Ct=A(nt)+A(Gt);O<ot?(ot=O,dt=at,P=Ct<P?Ct:P):O===ot&&Ct<P&&(P=Ct,dt=at)}return dt||et-st},V.prototype._chooseSplitAxis=function(K,st,et){var dt=K.leaf?this.compareMinX:W,lt=K.leaf?this.compareMinY:k;this._allDistMargin(K,st,et,dt)<this._allDistMargin(K,st,et,lt)&&K.children.sort(dt)},V.prototype._allDistMargin=function(K,st,et,dt){K.children.sort(dt);for(var lt=this.toBBox,St=Y(K,0,st,lt),q=Y(K,et-st,et,lt),ft=X(St)+X(q),pt=st;pt<et-st;pt++){var B=K.children[pt];R(St,K.leaf?lt(B):B),ft+=X(St)}for(var ot=et-st-1;ot>=st;ot--){var P=K.children[ot];R(q,K.leaf?lt(P):P),ft+=X(q)}return ft},V.prototype._adjustParentBBoxes=function(K,st,et){for(var dt=et;dt>=0;dt--)R(st[dt],K)},V.prototype._condense=function(K){for(var st=K.length-1,et=void 0;st>=0;st--)0===K[st].children.length?st>0?(et=K[st-1].children).splice(et.indexOf(K[st]),1):this.clear():Q(K[st],this.toBBox)},V}()},3970:(Lt,ut,y)=>{var $=y(7809),V=y(8147),H=y(314),Q=y(4720),Y=y(1139),R=y(2365),W=Date.prototype.getTime;function A(G){return null==G}function X(G){return!(!G||"object"!=typeof G||"number"!=typeof G.length||"function"!=typeof G.copy||"function"!=typeof G.slice||G.length>0&&"number"!=typeof G[0])}Lt.exports=function k(G,it,wt){var K=wt||{};return!!(K.strict?H(G,it):G===it)||(!G||!it||"object"!=typeof G&&"object"!=typeof it?K.strict?H(G,it):G==it:function Z(G,it,wt){var K,st;if(typeof G!=typeof it||A(G)||A(it)||G.prototype!==it.prototype||V(G)!==V(it))return!1;var et=Q(G),dt=Q(it);if(et!==dt)return!1;if(et||dt)return G.source===it.source&&Y(G)===Y(it);if(R(G)&&R(it))return W.call(G)===W.call(it);var lt=X(G),St=X(it);if(lt!==St)return!1;if(lt||St){if(G.length!==it.length)return!1;for(K=0;K<G.length;K++)if(G[K]!==it[K])return!1;return!0}if(typeof G!=typeof it)return!1;try{var q=$(G),ft=$(it)}catch{return!1}if(q.length!==ft.length)return!1;for(q.sort(),ft.sort(),K=q.length-1;K>=0;K--)if(q[K]!=ft[K])return!1;for(K=q.length-1;K>=0;K--)if(!k(G[st=q[K]],it[st],wt))return!1;return!0}(G,it,K))}},9224:(Lt,ut,y)=>{"use strict";var $=y(474),V=y(4203),H=y(5223),Q=y(9262);Lt.exports=function(R,W,k){if(!R||"object"!=typeof R&&"function"!=typeof R)throw new H("`obj` must be an object or a function`");if("string"!=typeof W&&"symbol"!=typeof W)throw new H("`property` must be a string or a symbol`");if(arguments.length>3&&"boolean"!=typeof arguments[3]&&null!==arguments[3])throw new H("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&"boolean"!=typeof arguments[4]&&null!==arguments[4])throw new H("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&"boolean"!=typeof arguments[5]&&null!==arguments[5])throw new H("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&"boolean"!=typeof arguments[6])throw new H("`loose`, if provided, must be a boolean");var A=arguments.length>3?arguments[3]:null,X=arguments.length>4?arguments[4]:null,Z=arguments.length>5?arguments[5]:null,G=arguments.length>6&&arguments[6],it=!!Q&&Q(R,W);if($)$(R,W,{configurable:null===Z&&it?it.configurable:!Z,enumerable:null===A&&it?it.enumerable:!A,value:k,writable:null===X&&it?it.writable:!X});else{if(!G&&(A||X||Z))throw new V("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");R[W]=k}}},1648:(Lt,ut,y)=>{"use strict";var $=y(7809),V="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),H=Object.prototype.toString,Q=Array.prototype.concat,Y=y(9224),W=y(2486)(),k=function(X,Z,G,it){if(Z in X)if(!0===it){if(X[Z]===G)return}else if(!function(X){return"function"==typeof X&&"[object Function]"===H.call(X)}(it)||!it())return;W?Y(X,Z,G,!0):Y(X,Z,G)},A=function(X,Z){var G=arguments.length>2?arguments[2]:{},it=$(Z);V&&(it=Q.call(it,Object.getOwnPropertySymbols(Z)));for(var wt=0;wt<it.length;wt+=1)k(X,it[wt],Z[it[wt]],G[it[wt]])};A.supportsDescriptors=!!W,Lt.exports=A},7649:Lt=>{function ut(y,$,V,H){this.dataset=[],this.epsilon=1,this.minPts=2,this.distance=this._euclideanDistance,this.clusters=[],this.noise=[],this._visited=[],this._assigned=[],this._datasetLength=0,this._init(y,$,V,H)}ut.prototype.run=function(y,$,V,H){this._init(y,$,V,H);for(var Q=0;Q<this._datasetLength;Q++)if(1!==this._visited[Q]){this._visited[Q]=1;var Y=this._regionQuery(Q);if(Y.length<this.minPts)this.noise.push(Q);else{var R=this.clusters.length;this.clusters.push([]),this._addToCluster(Q,R),this._expandCluster(R,Y)}}return this.clusters},ut.prototype._init=function(y,$,V,H){if(y){if(!(y instanceof Array))throw Error("Dataset must be of type array, "+typeof y+" given");this.dataset=y,this.clusters=[],this.noise=[],this._datasetLength=y.length,this._visited=new Array(this._datasetLength),this._assigned=new Array(this._datasetLength)}$&&(this.epsilon=$),V&&(this.minPts=V),H&&(this.distance=H)},ut.prototype._expandCluster=function(y,$){for(var V=0;V<$.length;V++){var H=$[V];if(1!==this._visited[H]){this._visited[H]=1;var Q=this._regionQuery(H);Q.length>=this.minPts&&($=this._mergeArrays($,Q))}1!==this._assigned[H]&&this._addToCluster(H,y)}},ut.prototype._addToCluster=function(y,$){this.clusters[$].push(y),this._assigned[y]=1},ut.prototype._regionQuery=function(y){for(var $=[],V=0;V<this._datasetLength;V++)this.distance(this.dataset[y],this.dataset[V])<this.epsilon&&$.push(V);return $},ut.prototype._mergeArrays=function(y,$){for(var V=$.length,H=0;H<V;H++){var Q=$[H];y.indexOf(Q)<0&&y.push(Q)}return y},ut.prototype._euclideanDistance=function(y,$){for(var V=0,H=Math.min(y.length,$.length);H--;)V+=(y[H]-$[H])*(y[H]-$[H]);return Math.sqrt(V)},Lt.exports&&(Lt.exports=ut)},442:Lt=>{function ut(y,$,V){this.k=3,this.dataset=[],this.assignments=[],this.centroids=[],this.init(y,$,V)}ut.prototype.init=function(y,$,V){this.assignments=[],this.centroids=[],typeof y<"u"&&(this.dataset=y),typeof $<"u"&&(this.k=$),typeof V<"u"&&(this.distance=V)},ut.prototype.run=function(y,$){this.init(y,$);for(var V=this.dataset.length,H=0;H<this.k;H++)this.centroids[H]=this.randomCentroid();for(var Q=!0;Q;){Q=this.assign();for(var Y=0;Y<this.k;Y++){for(var R=new Array(X),W=0,k=0;k<X;k++)R[k]=0;for(var A=0;A<V;A++){var X=this.dataset[A].length;if(Y===this.assignments[A]){for(k=0;k<X;k++)R[k]+=this.dataset[A][k];W++}}if(W>0){for(k=0;k<X;k++)R[k]/=W;this.centroids[Y]=R}else this.centroids[Y]=this.randomCentroid(),Q=!0}}return this.getClusters()},ut.prototype.randomCentroid=function(){var $,V,y=this.dataset.length-1;do{V=Math.round(Math.random()*y),$=this.dataset[V]}while(this.centroids.indexOf($)>=0);return $},ut.prototype.assign=function(){for(var V,y=!1,$=this.dataset.length,H=0;H<$;H++)(V=this.argmin(this.dataset[H],this.centroids,this.distance))!=this.assignments[H]&&(this.assignments[H]=V,y=!0);return y},ut.prototype.getClusters=function(){for(var $,y=new Array(this.k),V=0;V<this.assignments.length;V++)typeof y[$=this.assignments[V]]>"u"&&(y[$]=[]),y[$].push(V);return y},ut.prototype.argmin=function(y,$,V){for(var R,H=Number.MAX_VALUE,Q=0,Y=$.length,W=0;W<Y;W++)(R=V(y,$[W]))<H&&(H=R,Q=W);return Q},ut.prototype.distance=function(y,$){for(var V=0,H=Math.min(y.length,$.length);H--;){var Q=y[H]-$[H];V+=Q*Q}return Math.sqrt(V)},Lt.exports&&(Lt.exports=ut)},2195:(Lt,ut,y)=>{if(Lt.exports)var $=y(6216);function V(H,Q,Y,R){this.epsilon=1,this.minPts=1,this.distance=this._euclideanDistance,this._reachability=[],this._processed=[],this._coreDistance=0,this._orderedList=[],this._init(H,Q,Y,R)}V.prototype.run=function(H,Q,Y,R){this._init(H,Q,Y,R);for(var W=0,k=this.dataset.length;W<k;W++)if(1!==this._processed[W]){this._processed[W]=1,this.clusters.push([W]);var A=this.clusters.length-1;this._orderedList.push(W);var X=new $(null,null,"asc"),Z=this._regionQuery(W);void 0!==this._distanceToCore(W)&&(this._updateQueue(W,Z,X),this._expandCluster(A,X))}return this.clusters},V.prototype.getReachabilityPlot=function(){for(var H=[],Q=0,Y=this._orderedList.length;Q<Y;Q++){var R=this._orderedList[Q];H.push([R,this._reachability[R]])}return H},V.prototype._init=function(H,Q,Y,R){if(H){if(!(H instanceof Array))throw Error("Dataset must be of type array, "+typeof H+" given");this.dataset=H,this.clusters=[],this._reachability=new Array(this.dataset.length),this._processed=new Array(this.dataset.length),this._coreDistance=0,this._orderedList=[]}Q&&(this.epsilon=Q),Y&&(this.minPts=Y),R&&(this.distance=R)},V.prototype._updateQueue=function(H,Q,Y){var R=this;this._coreDistance=this._distanceToCore(H),Q.forEach(function(W){if(void 0===R._processed[W]){var k=R.distance(R.dataset[H],R.dataset[W]),A=Math.max(R._coreDistance,k);void 0===R._reachability[W]?(R._reachability[W]=A,Y.insert(W,A)):A<R._reachability[W]&&(R._reachability[W]=A,Y.remove(W),Y.insert(W,A))}})},V.prototype._expandCluster=function(H,Q){for(var Y=Q.getElements(),R=0,W=Y.length;R<W;R++){var k=Y[R];if(void 0===this._processed[k]){var A=this._regionQuery(k);this._processed[k]=1,this.clusters[H].push(k),this._orderedList.push(k),void 0!==this._distanceToCore(k)&&(this._updateQueue(k,A,Q),this._expandCluster(H,Q))}}},V.prototype._distanceToCore=function(H){for(var Q=this.epsilon,Y=0;Y<Q;Y++)if(this._regionQuery(H,Y).length>=this.minPts)return Y},V.prototype._regionQuery=function(H,Q){Q=Q||this.epsilon;for(var Y=[],R=0,W=this.dataset.length;R<W;R++)this.distance(this.dataset[H],this.dataset[R])<Q&&Y.push(R);return Y},V.prototype._euclideanDistance=function(H,Q){for(var Y=0,R=Math.min(H.length,Q.length);R--;)Y+=(H[R]-Q[R])*(H[R]-Q[R]);return Math.sqrt(Y)},Lt.exports&&(Lt.exports=V)},6216:Lt=>{function ut(y,$,V){this._queue=[],this._priorities=[],this._sorting="desc",this._init(y,$,V)}ut.prototype.insert=function(y,$){for(var V=this._queue.length,H=V;H--;){var Q=this._priorities[H];"desc"===this._sorting?$>Q&&(V=H):$<Q&&(V=H)}this._insertAt(y,$,V)},ut.prototype.remove=function(y){for(var $=this._queue.length;$--;)if(y===this._queue[$]){this._queue.splice($,1),this._priorities.splice($,1);break}},ut.prototype.forEach=function(y){this._queue.forEach(y)},ut.prototype.getElements=function(){return this._queue},ut.prototype.getElementPriority=function(y){return this._priorities[y]},ut.prototype.getPriorities=function(){return this._priorities},ut.prototype.getElementsWithPriorities=function(){for(var y=[],$=0,V=this._queue.length;$<V;$++)y.push([this._queue[$],this._priorities[$]]);return y},ut.prototype._init=function(y,$,V){if(y&&$){if(this._queue=[],this._priorities=[],y.length!==$.length)throw new Error("Arrays must have the same length");for(var H=0;H<y.length;H++)this.insert(y[H],$[H])}V&&(this._sorting=V)},ut.prototype._insertAt=function(y,$,V){this._queue.length===V?(this._queue.push(y),this._priorities.push($)):(this._queue.splice(V,0,y),this._priorities.splice(V,0,$))},Lt.exports&&(Lt.exports=ut)},3367:(Lt,ut,y)=>{Lt.exports&&(Lt.exports={DBSCAN:y(7649),KMEANS:y(442),OPTICS:y(2195),PriorityQueue:y(6216)})},9145:Lt=>{"use strict";function ut(Ct,yt,vt){vt=vt||2;var Bt,ee,jt,se,we,Me,Xe,xt=yt&&yt.length,Mt=xt?yt[0]*vt:Ct.length,It=y(Ct,0,Mt,vt,!0),re=[];if(!It||It.next===It.prev)return re;if(xt&&(It=function W(Ct,yt,vt,xt){var It,re,jt,Mt=[];for(It=0,re=yt.length;It<re;It++)(jt=y(Ct,yt[It]*xt,It<re-1?yt[It+1]*xt:Ct.length,xt,!1))===jt.next&&(jt.steiner=!0),Mt.push(K(jt));for(Mt.sort(k),It=0;It<Mt.length;It++)vt=A(Mt[It],vt);return vt}(Ct,yt,It,vt)),Ct.length>80*vt){Bt=jt=Ct[0],ee=se=Ct[1];for(var Ue=vt;Ue<Mt;Ue+=vt)(we=Ct[Ue])<Bt&&(Bt=we),(Me=Ct[Ue+1])<ee&&(ee=Me),we>jt&&(jt=we),Me>se&&(se=Me);Xe=0!==(Xe=Math.max(jt-Bt,se-ee))?32767/Xe:0}return V(It,re,vt,Bt,ee,Xe,0),re}function y(Ct,yt,vt,xt,Mt){var It,re;if(Mt===O(Ct,yt,vt,xt)>0)for(It=yt;It<vt;It+=xt)re=at(It,Ct[It],Ct[It+1],re);else for(It=vt-xt;It>=yt;It-=xt)re=at(It,Ct[It],Ct[It+1],re);return re&&lt(re,re.next)&&(nt(re),re=re.next),re}function $(Ct,yt){if(!Ct)return Ct;yt||(yt=Ct);var xt,vt=Ct;do{if(xt=!1,vt.steiner||!lt(vt,vt.next)&&0!==dt(vt.prev,vt,vt.next))vt=vt.next;else{if(nt(vt),(vt=yt=vt.prev)===vt.next)break;xt=!0}}while(xt||vt!==yt);return yt}function V(Ct,yt,vt,xt,Mt,It,re){if(Ct){!re&&It&&function G(Ct,yt,vt,xt){var Mt=Ct;do{0===Mt.z&&(Mt.z=wt(Mt.x,Mt.y,yt,vt,xt)),Mt.prevZ=Mt.prev,Mt.nextZ=Mt.next,Mt=Mt.next}while(Mt!==Ct);Mt.prevZ.nextZ=null,Mt.prevZ=null,function it(Ct){var yt,vt,xt,Mt,It,re,Bt,ee,jt=1;do{for(vt=Ct,Ct=null,It=null,re=0;vt;){for(re++,xt=vt,Bt=0,yt=0;yt<jt&&(Bt++,xt=xt.nextZ);yt++);for(ee=jt;Bt>0||ee>0&&xt;)0!==Bt&&(0===ee||!xt||vt.z<=xt.z)?(Mt=vt,vt=vt.nextZ,Bt--):(Mt=xt,xt=xt.nextZ,ee--),It?It.nextZ=Mt:Ct=Mt,Mt.prevZ=It,It=Mt;vt=xt}It.nextZ=null,jt*=2}while(re>1)}(Mt)}(Ct,xt,Mt,It);for(var ee,jt,Bt=Ct;Ct.prev!==Ct.next;)if(ee=Ct.prev,jt=Ct.next,It?Q(Ct,xt,Mt,It):H(Ct))yt.push(ee.i/vt|0),yt.push(Ct.i/vt|0),yt.push(jt.i/vt|0),nt(Ct),Ct=jt.next,Bt=jt.next;else if((Ct=jt)===Bt){re?1===re?V(Ct=Y($(Ct),yt,vt),yt,vt,xt,Mt,It,2):2===re&&R(Ct,yt,vt,xt,Mt,It):V($(Ct),yt,vt,xt,Mt,It,1);break}}}function H(Ct){var yt=Ct.prev,vt=Ct,xt=Ct.next;if(dt(yt,vt,xt)>=0)return!1;for(var Mt=yt.x,It=vt.x,re=xt.x,Bt=yt.y,ee=vt.y,jt=xt.y,se=Mt<It?Mt<re?Mt:re:It<re?It:re,we=Bt<ee?Bt<jt?Bt:jt:ee<jt?ee:jt,Me=Mt>It?Mt>re?Mt:re:It>re?It:re,Xe=Bt>ee?Bt>jt?Bt:jt:ee>jt?ee:jt,Ue=xt.next;Ue!==yt;){if(Ue.x>=se&&Ue.x<=Me&&Ue.y>=we&&Ue.y<=Xe&&st(Mt,Bt,It,ee,re,jt,Ue.x,Ue.y)&&dt(Ue.prev,Ue,Ue.next)>=0)return!1;Ue=Ue.next}return!0}function Q(Ct,yt,vt,xt){var Mt=Ct.prev,It=Ct,re=Ct.next;if(dt(Mt,It,re)>=0)return!1;for(var Bt=Mt.x,ee=It.x,jt=re.x,se=Mt.y,we=It.y,Me=re.y,Xe=Bt<ee?Bt<jt?Bt:jt:ee<jt?ee:jt,Ue=se<we?se<Me?se:Me:we<Me?we:Me,De=Bt>ee?Bt>jt?Bt:jt:ee>jt?ee:jt,Tn=se>we?se>Me?se:Me:we>Me?we:Me,On=wt(Xe,Ue,yt,vt,xt),ne=wt(De,Tn,yt,vt,xt),pe=Ct.prevZ,Ie=Ct.nextZ;pe&&pe.z>=On&&Ie&&Ie.z<=ne;){if(pe.x>=Xe&&pe.x<=De&&pe.y>=Ue&&pe.y<=Tn&&pe!==Mt&&pe!==re&&st(Bt,se,ee,we,jt,Me,pe.x,pe.y)&&dt(pe.prev,pe,pe.next)>=0||(pe=pe.prevZ,Ie.x>=Xe&&Ie.x<=De&&Ie.y>=Ue&&Ie.y<=Tn&&Ie!==Mt&&Ie!==re&&st(Bt,se,ee,we,jt,Me,Ie.x,Ie.y)&&dt(Ie.prev,Ie,Ie.next)>=0))return!1;Ie=Ie.nextZ}for(;pe&&pe.z>=On;){if(pe.x>=Xe&&pe.x<=De&&pe.y>=Ue&&pe.y<=Tn&&pe!==Mt&&pe!==re&&st(Bt,se,ee,we,jt,Me,pe.x,pe.y)&&dt(pe.prev,pe,pe.next)>=0)return!1;pe=pe.prevZ}for(;Ie&&Ie.z<=ne;){if(Ie.x>=Xe&&Ie.x<=De&&Ie.y>=Ue&&Ie.y<=Tn&&Ie!==Mt&&Ie!==re&&st(Bt,se,ee,we,jt,Me,Ie.x,Ie.y)&&dt(Ie.prev,Ie,Ie.next)>=0)return!1;Ie=Ie.nextZ}return!0}function Y(Ct,yt,vt){var xt=Ct;do{var Mt=xt.prev,It=xt.next.next;!lt(Mt,It)&&St(Mt,xt,xt.next,It)&&B(Mt,It)&&B(It,Mt)&&(yt.push(Mt.i/vt|0),yt.push(xt.i/vt|0),yt.push(It.i/vt|0),nt(xt),nt(xt.next),xt=Ct=It),xt=xt.next}while(xt!==Ct);return $(xt)}function R(Ct,yt,vt,xt,Mt,It){var re=Ct;do{for(var Bt=re.next.next;Bt!==re.prev;){if(re.i!==Bt.i&&et(re,Bt)){var ee=P(re,Bt);return re=$(re,re.next),ee=$(ee,ee.next),V(re,yt,vt,xt,Mt,It,0),void V(ee,yt,vt,xt,Mt,It,0)}Bt=Bt.next}re=re.next}while(re!==Ct)}function k(Ct,yt){return Ct.x-yt.x}function A(Ct,yt){var vt=function X(Ct,yt){var re,vt=yt,xt=Ct.x,Mt=Ct.y,It=-1/0;do{if(Mt<=vt.y&&Mt>=vt.next.y&&vt.next.y!==vt.y){var Bt=vt.x+(Mt-vt.y)*(vt.next.x-vt.x)/(vt.next.y-vt.y);if(Bt<=xt&&Bt>It&&(It=Bt,re=vt.x<vt.next.x?vt:vt.next,Bt===xt))return re}vt=vt.next}while(vt!==yt);if(!re)return null;var Me,ee=re,jt=re.x,se=re.y,we=1/0;vt=re;do{xt>=vt.x&&vt.x>=jt&&xt!==vt.x&&st(Mt<se?xt:It,Mt,jt,se,Mt<se?It:xt,Mt,vt.x,vt.y)&&(Me=Math.abs(Mt-vt.y)/(xt-vt.x),B(vt,Ct)&&(Me<we||Me===we&&(vt.x>re.x||vt.x===re.x&&Z(re,vt)))&&(re=vt,we=Me)),vt=vt.next}while(vt!==ee);return re}(Ct,yt);if(!vt)return yt;var xt=P(vt,Ct);return $(xt,xt.next),$(vt,vt.next)}function Z(Ct,yt){return dt(Ct.prev,Ct,yt.prev)<0&&dt(yt.next,Ct,Ct.next)<0}function wt(Ct,yt,vt,xt,Mt){return(Ct=1431655765&((Ct=858993459&((Ct=252645135&((Ct=16711935&((Ct=(Ct-vt)*Mt|0)|Ct<<8))|Ct<<4))|Ct<<2))|Ct<<1))|(yt=1431655765&((yt=858993459&((yt=252645135&((yt=16711935&((yt=(yt-xt)*Mt|0)|yt<<8))|yt<<4))|yt<<2))|yt<<1))<<1}function K(Ct){var yt=Ct,vt=Ct;do{(yt.x<vt.x||yt.x===vt.x&&yt.y<vt.y)&&(vt=yt),yt=yt.next}while(yt!==Ct);return vt}function st(Ct,yt,vt,xt,Mt,It,re,Bt){return(Mt-re)*(yt-Bt)>=(Ct-re)*(It-Bt)&&(Ct-re)*(xt-Bt)>=(vt-re)*(yt-Bt)&&(vt-re)*(It-Bt)>=(Mt-re)*(xt-Bt)}function et(Ct,yt){return Ct.next.i!==yt.i&&Ct.prev.i!==yt.i&&!function pt(Ct,yt){var vt=Ct;do{if(vt.i!==Ct.i&&vt.next.i!==Ct.i&&vt.i!==yt.i&&vt.next.i!==yt.i&&St(vt,vt.next,Ct,yt))return!0;vt=vt.next}while(vt!==Ct);return!1}(Ct,yt)&&(B(Ct,yt)&&B(yt,Ct)&&function ot(Ct,yt){var vt=Ct,xt=!1,Mt=(Ct.x+yt.x)/2,It=(Ct.y+yt.y)/2;do{vt.y>It!=vt.next.y>It&&vt.next.y!==vt.y&&Mt<(vt.next.x-vt.x)*(It-vt.y)/(vt.next.y-vt.y)+vt.x&&(xt=!xt),vt=vt.next}while(vt!==Ct);return xt}(Ct,yt)&&(dt(Ct.prev,Ct,yt.prev)||dt(Ct,yt.prev,yt))||lt(Ct,yt)&&dt(Ct.prev,Ct,Ct.next)>0&&dt(yt.prev,yt,yt.next)>0)}function dt(Ct,yt,vt){return(yt.y-Ct.y)*(vt.x-yt.x)-(yt.x-Ct.x)*(vt.y-yt.y)}function lt(Ct,yt){return Ct.x===yt.x&&Ct.y===yt.y}function St(Ct,yt,vt,xt){var Mt=ft(dt(Ct,yt,vt)),It=ft(dt(Ct,yt,xt)),re=ft(dt(vt,xt,Ct)),Bt=ft(dt(vt,xt,yt));return!!(Mt!==It&&re!==Bt||0===Mt&&q(Ct,vt,yt)||0===It&&q(Ct,xt,yt)||0===re&&q(vt,Ct,xt)||0===Bt&&q(vt,yt,xt))}function q(Ct,yt,vt){return yt.x<=Math.max(Ct.x,vt.x)&&yt.x>=Math.min(Ct.x,vt.x)&&yt.y<=Math.max(Ct.y,vt.y)&&yt.y>=Math.min(Ct.y,vt.y)}function ft(Ct){return Ct>0?1:Ct<0?-1:0}function B(Ct,yt){return dt(Ct.prev,Ct,Ct.next)<0?dt(Ct,yt,Ct.next)>=0&&dt(Ct,Ct.prev,yt)>=0:dt(Ct,yt,Ct.prev)<0||dt(Ct,Ct.next,yt)<0}function P(Ct,yt){var vt=new Gt(Ct.i,Ct.x,Ct.y),xt=new Gt(yt.i,yt.x,yt.y),Mt=Ct.next,It=yt.prev;return Ct.next=yt,yt.prev=Ct,vt.next=Mt,Mt.prev=vt,xt.next=vt,vt.prev=xt,It.next=xt,xt.prev=It,xt}function at(Ct,yt,vt,xt){var Mt=new Gt(Ct,yt,vt);return xt?(Mt.next=xt.next,Mt.prev=xt,xt.next.prev=Mt,xt.next=Mt):(Mt.prev=Mt,Mt.next=Mt),Mt}function nt(Ct){Ct.next.prev=Ct.prev,Ct.prev.next=Ct.next,Ct.prevZ&&(Ct.prevZ.nextZ=Ct.nextZ),Ct.nextZ&&(Ct.nextZ.prevZ=Ct.prevZ)}function Gt(Ct,yt,vt){this.i=Ct,this.x=yt,this.y=vt,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function O(Ct,yt,vt,xt){for(var Mt=0,It=yt,re=vt-xt;It<vt;It+=xt)Mt+=(Ct[re]-Ct[It])*(Ct[It+1]+Ct[re+1]),re=It;return Mt}Lt.exports=ut,Lt.exports.default=ut,ut.deviation=function(Ct,yt,vt,xt){var Mt=yt&&yt.length,re=Math.abs(O(Ct,0,Mt?yt[0]*vt:Ct.length,vt));if(Mt)for(var Bt=0,ee=yt.length;Bt<ee;Bt++)re-=Math.abs(O(Ct,yt[Bt]*vt,Bt<ee-1?yt[Bt+1]*vt:Ct.length,vt));var we=0;for(Bt=0;Bt<xt.length;Bt+=3){var Me=xt[Bt]*vt,Xe=xt[Bt+1]*vt,Ue=xt[Bt+2]*vt;we+=Math.abs((Ct[Me]-Ct[Ue])*(Ct[Xe+1]-Ct[Me+1])-(Ct[Me]-Ct[Xe])*(Ct[Ue+1]-Ct[Me+1]))}return 0===re&&0===we?0:Math.abs((we-re)/re)},ut.flatten=function(Ct){for(var yt=Ct[0][0].length,vt={vertices:[],holes:[],dimensions:yt},xt=0,Mt=0;Mt<Ct.length;Mt++){for(var It=0;It<Ct[Mt].length;It++)for(var re=0;re<yt;re++)vt.vertices.push(Ct[Mt][It][re]);Mt>0&&vt.holes.push(xt+=Ct[Mt-1].length)}return vt}},474:(Lt,ut,y)=>{"use strict";var V=y(491)("%Object.defineProperty%",!0)||!1;if(V)try{V({},"a",{value:1})}catch{V=!1}Lt.exports=V},4500:Lt=>{"use strict";Lt.exports=EvalError},2050:Lt=>{"use strict";Lt.exports=Error},2992:Lt=>{"use strict";Lt.exports=RangeError},3944:Lt=>{"use strict";Lt.exports=ReferenceError},4203:Lt=>{"use strict";Lt.exports=SyntaxError},5223:Lt=>{"use strict";Lt.exports=TypeError},6130:Lt=>{"use strict";Lt.exports=URIError},238:Lt=>{"use strict";var y=Object.prototype.toString,$=Math.max,H=function(W,k){for(var A=[],X=0;X<W.length;X+=1)A[X]=W[X];for(var Z=0;Z<k.length;Z+=1)A[Z+W.length]=k[Z];return A};Lt.exports=function(W){var k=this;if("function"!=typeof k||"[object Function]"!==y.apply(k))throw new TypeError("Function.prototype.bind called on incompatible "+k);for(var X,A=function(W,k){for(var A=[],X=1,Z=0;X<W.length;X+=1,Z+=1)A[Z]=W[X];return A}(arguments),G=$(0,k.length-A.length),it=[],wt=0;wt<G;wt++)it[wt]="$"+wt;if(X=Function("binder","return function ("+function(R,W){for(var k="",A=0;A<R.length;A+=1)k+=R[A],A+1<R.length&&(k+=",");return k}(it)+"){ return binder.apply(this,arguments); }")(function(){if(this instanceof X){var st=k.apply(this,H(A,arguments));return Object(st)===st?st:this}return k.apply(W,H(A,arguments))}),k.prototype){var K=function(){};K.prototype=k.prototype,X.prototype=new K,K.prototype=null}return X}},5333:(Lt,ut,y)=>{"use strict";var $=y(238);Lt.exports=Function.prototype.bind||$},1552:Lt=>{"use strict";var ut=function(){return"string"==typeof function(){}.name},y=Object.getOwnPropertyDescriptor;if(y)try{y([],"length")}catch{y=null}ut.functionsHaveConfigurableNames=function(){if(!ut()||!y)return!1;var H=y(function(){},"name");return!!H&&!!H.configurable};var $=Function.prototype.bind;ut.boundFunctionsHaveNames=function(){return ut()&&"function"==typeof $&&""!==function(){}.bind().name},Lt.exports=ut},3198:(Lt,ut,y)=>{var $=y(3970),V=function(R){this.precision=R&&R.precision?R.precision:17,this.direction=!(!R||!R.direction)&&R.direction,this.pseudoNode=!(!R||!R.pseudoNode)&&R.pseudoNode,this.objectComparator=R&&R.objectComparator?R.objectComparator:Y};function H(R){return R.coordinates.map(function(W){return{type:R.type.replace("Multi",""),coordinates:W}})}function Q(R,W){return R.hasOwnProperty("coordinates")?R.coordinates.length===W.coordinates.length:R.length===W.length}function Y(R,W){return $(R,W,{strict:!0})}V.prototype.compare=function(R,W){if(R.type!==W.type||!Q(R,W))return!1;switch(R.type){case"Point":return this.compareCoord(R.coordinates,W.coordinates);case"LineString":return this.compareLine(R.coordinates,W.coordinates,0,!1);case"Polygon":return this.comparePolygon(R,W);case"Feature":return this.compareFeature(R,W);default:if(0===R.type.indexOf("Multi")){var k=this,A=H(R),X=H(W);return A.every(function(Z){return this.some(function(G){return k.compare(Z,G)})},X)}}return!1},V.prototype.compareCoord=function(R,W){if(R.length!==W.length)return!1;for(var k=0;k<R.length;k++)if(R[k].toFixed(this.precision)!==W[k].toFixed(this.precision))return!1;return!0},V.prototype.compareLine=function(R,W,k,A){if(!Q(R,W))return!1;var X=this.pseudoNode?R:this.removePseudo(R),Z=this.pseudoNode?W:this.removePseudo(W);if(!A||this.compareCoord(X[0],Z[0])||(Z=this.fixStartIndex(Z,X))){var G=this.compareCoord(X[k],Z[k]);return this.direction||G?this.comparePath(X,Z):!!this.compareCoord(X[k],Z[Z.length-(1+k)])&&this.comparePath(X.slice().reverse(),Z)}},V.prototype.fixStartIndex=function(R,W){for(var k,A=-1,X=0;X<R.length;X++)if(this.compareCoord(R[X],W[0])){A=X;break}return A>=0&&(k=[].concat(R.slice(A,R.length),R.slice(1,A+1))),k},V.prototype.comparePath=function(R,W){var k=this;return R.every(function(A,X){return k.compareCoord(A,this[X])},W)},V.prototype.comparePolygon=function(R,W){if(this.compareLine(R.coordinates[0],W.coordinates[0],1,!0)){var k=R.coordinates.slice(1,R.coordinates.length),A=W.coordinates.slice(1,W.coordinates.length),X=this;return k.every(function(Z){return this.some(function(G){return X.compareLine(Z,G,1,!0)})},A)}return!1},V.prototype.compareFeature=function(R,W){return!(R.id!==W.id||!this.objectComparator(R.properties,W.properties)||!this.compareBBox(R,W))&&this.compare(R.geometry,W.geometry)},V.prototype.compareBBox=function(R,W){return!!(!R.bbox&&!W.bbox||R.bbox&&W.bbox&&this.compareCoord(R.bbox,W.bbox))},V.prototype.removePseudo=function(R){return R},Lt.exports=V},5665:(Lt,ut,y)=>{var $=y(7571),V=y(621),H=y(8570),Q=y(1568).Z,Y=H.featureEach,k=V.featureCollection;function A(X){var Z=new $(X);return Z.insert=function(G){if("Feature"!==G.type)throw new Error("invalid feature");return G.bbox=G.bbox?G.bbox:Q(G),$.prototype.insert.call(this,G)},Z.load=function(G){var it=[];return Array.isArray(G)?G.forEach(function(wt){if("Feature"!==wt.type)throw new Error("invalid features");wt.bbox=wt.bbox?wt.bbox:Q(wt),it.push(wt)}):Y(G,function(wt){if("Feature"!==wt.type)throw new Error("invalid features");wt.bbox=wt.bbox?wt.bbox:Q(wt),it.push(wt)}),$.prototype.load.call(this,it)},Z.remove=function(G,it){if("Feature"!==G.type)throw new Error("invalid feature");return G.bbox=G.bbox?G.bbox:Q(G),$.prototype.remove.call(this,G,it)},Z.clear=function(){return $.prototype.clear.call(this)},Z.search=function(G){var it=$.prototype.search.call(this,this.toBBox(G));return k(it)},Z.collides=function(G){return $.prototype.collides.call(this,this.toBBox(G))},Z.all=function(){var G=$.prototype.all.call(this);return k(G)},Z.toJSON=function(){return $.prototype.toJSON.call(this)},Z.fromJSON=function(G){return $.prototype.fromJSON.call(this,G)},Z.toBBox=function(G){var it;if(G.bbox)it=G.bbox;else if(Array.isArray(G)&&4===G.length)it=G;else if(Array.isArray(G)&&6===G.length)it=[G[0],G[1],G[3],G[4]];else if("Feature"===G.type)it=Q(G);else{if("FeatureCollection"!==G.type)throw new Error("invalid geojson");it=Q(G)}return{minX:it[0],minY:it[1],maxX:it[2],maxY:it[3]}},Z}Lt.exports=A,Lt.exports.default=A},7571:function(Lt){Lt.exports=function(){"use strict";function ut(K,st,et,dt,lt){!function St(q,ft,pt,B,ot){for(;B>pt;){if(B-pt>600){var P=B-pt+1,at=ft-pt+1,nt=Math.log(P),Gt=.5*Math.exp(2*nt/3),O=.5*Math.sqrt(nt*Gt*(P-Gt)/P)*(at-P/2<0?-1:1);St(q,ft,Math.max(pt,Math.floor(ft-at*Gt/P+O)),Math.min(B,Math.floor(ft+(P-at)*Gt/P+O)),ot)}var vt=q[ft],xt=pt,Mt=B;for(y(q,pt,ft),ot(q[B],vt)>0&&y(q,pt,B);xt<Mt;){for(y(q,xt,Mt),xt++,Mt--;ot(q[xt],vt)<0;)xt++;for(;ot(q[Mt],vt)>0;)Mt--}0===ot(q[pt],vt)?y(q,pt,Mt):y(q,++Mt,B),Mt<=ft&&(pt=Mt+1),ft<=Mt&&(B=Mt-1)}}(K,st,et||0,dt||K.length-1,lt||$)}function y(K,st,et){var dt=K[st];K[st]=K[et],K[et]=dt}function $(K,st){return K<st?-1:K>st?1:0}var V=function(K){void 0===K&&(K=9),this._maxEntries=Math.max(4,K),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function H(K,st,et){if(!et)return st.indexOf(K);for(var dt=0;dt<st.length;dt++)if(et(K,st[dt]))return dt;return-1}function Q(K,st){Y(K,0,K.children.length,st,K)}function Y(K,st,et,dt,lt){lt||(lt=it(null)),lt.minX=1/0,lt.minY=1/0,lt.maxX=-1/0,lt.maxY=-1/0;for(var St=st;St<et;St++){var q=K.children[St];R(lt,K.leaf?dt(q):q)}return lt}function R(K,st){return K.minX=Math.min(K.minX,st.minX),K.minY=Math.min(K.minY,st.minY),K.maxX=Math.max(K.maxX,st.maxX),K.maxY=Math.max(K.maxY,st.maxY),K}function W(K,st){return K.minX-st.minX}function k(K,st){return K.minY-st.minY}function A(K){return(K.maxX-K.minX)*(K.maxY-K.minY)}function X(K){return K.maxX-K.minX+(K.maxY-K.minY)}function Z(K,st){return K.minX<=st.minX&&K.minY<=st.minY&&st.maxX<=K.maxX&&st.maxY<=K.maxY}function G(K,st){return st.minX<=K.maxX&&st.minY<=K.maxY&&st.maxX>=K.minX&&st.maxY>=K.minY}function it(K){return{children:K,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function wt(K,st,et,dt,lt){for(var St=[st,et];St.length;)if(!((et=St.pop())-(st=St.pop())<=dt)){var q=st+Math.ceil((et-st)/dt/2)*dt;ut(K,q,st,et,lt),St.push(st,q,q,et)}}return V.prototype.all=function(){return this._all(this.data,[])},V.prototype.search=function(K){var st=this.data,et=[];if(!G(K,st))return et;for(var dt=this.toBBox,lt=[];st;){for(var St=0;St<st.children.length;St++){var q=st.children[St],ft=st.leaf?dt(q):q;G(K,ft)&&(st.leaf?et.push(q):Z(K,ft)?this._all(q,et):lt.push(q))}st=lt.pop()}return et},V.prototype.collides=function(K){var st=this.data;if(!G(K,st))return!1;for(var et=[];st;){for(var dt=0;dt<st.children.length;dt++){var lt=st.children[dt],St=st.leaf?this.toBBox(lt):lt;if(G(K,St)){if(st.leaf||Z(K,St))return!0;et.push(lt)}}st=et.pop()}return!1},V.prototype.load=function(K){if(!K||!K.length)return this;if(K.length<this._minEntries){for(var st=0;st<K.length;st++)this.insert(K[st]);return this}var et=this._build(K.slice(),0,K.length-1,0);if(this.data.children.length)if(this.data.height===et.height)this._splitRoot(this.data,et);else{if(this.data.height<et.height){var dt=this.data;this.data=et,et=dt}this._insert(et,this.data.height-et.height-1,!0)}else this.data=et;return this},V.prototype.insert=function(K){return K&&this._insert(K,this.data.height-1),this},V.prototype.clear=function(){return this.data=it([]),this},V.prototype.remove=function(K,st){if(!K)return this;for(var et,dt,lt,St=this.data,q=this.toBBox(K),ft=[],pt=[];St||ft.length;){if(St||(St=ft.pop(),dt=ft[ft.length-1],et=pt.pop(),lt=!0),St.leaf){var B=H(K,St.children,st);if(-1!==B)return St.children.splice(B,1),ft.push(St),this._condense(ft),this}lt||St.leaf||!Z(St,q)?dt?(et++,St=dt.children[et],lt=!1):St=null:(ft.push(St),pt.push(et),et=0,dt=St,St=St.children[0])}return this},V.prototype.toBBox=function(K){return K},V.prototype.compareMinX=function(K,st){return K.minX-st.minX},V.prototype.compareMinY=function(K,st){return K.minY-st.minY},V.prototype.toJSON=function(){return this.data},V.prototype.fromJSON=function(K){return this.data=K,this},V.prototype._all=function(K,st){for(var et=[];K;)K.leaf?st.push.apply(st,K.children):et.push.apply(et,K.children),K=et.pop();return st},V.prototype._build=function(K,st,et,dt){var lt,St=et-st+1,q=this._maxEntries;if(St<=q)return Q(lt=it(K.slice(st,et+1)),this.toBBox),lt;dt||(dt=Math.ceil(Math.log(St)/Math.log(q)),q=Math.ceil(St/Math.pow(q,dt-1))),(lt=it([])).leaf=!1,lt.height=dt;var ft=Math.ceil(St/q),pt=ft*Math.ceil(Math.sqrt(q));wt(K,st,et,pt,this.compareMinX);for(var B=st;B<=et;B+=pt){var ot=Math.min(B+pt-1,et);wt(K,B,ot,ft,this.compareMinY);for(var P=B;P<=ot;P+=ft){var at=Math.min(P+ft-1,ot);lt.children.push(this._build(K,P,at,dt-1))}}return Q(lt,this.toBBox),lt},V.prototype._chooseSubtree=function(K,st,et,dt){for(;dt.push(st),!st.leaf&&dt.length-1!==et;){for(var lt=1/0,St=1/0,q=void 0,ft=0;ft<st.children.length;ft++){var pt=st.children[ft],B=A(pt),ot=(P=K,at=pt,(Math.max(at.maxX,P.maxX)-Math.min(at.minX,P.minX))*(Math.max(at.maxY,P.maxY)-Math.min(at.minY,P.minY))-B);ot<St?(St=ot,lt=B<lt?B:lt,q=pt):ot===St&&B<lt&&(lt=B,q=pt)}st=q||st.children[0]}var P,at;return st},V.prototype._insert=function(K,st,et){var dt=et?K:this.toBBox(K),lt=[],St=this._chooseSubtree(dt,this.data,st,lt);for(St.children.push(K),R(St,dt);st>=0&&lt[st].children.length>this._maxEntries;)this._split(lt,st),st--;this._adjustParentBBoxes(dt,lt,st)},V.prototype._split=function(K,st){var et=K[st],dt=et.children.length,lt=this._minEntries;this._chooseSplitAxis(et,lt,dt);var St=this._chooseSplitIndex(et,lt,dt),q=it(et.children.splice(St,et.children.length-St));q.height=et.height,q.leaf=et.leaf,Q(et,this.toBBox),Q(q,this.toBBox),st?K[st-1].children.push(q):this._splitRoot(et,q)},V.prototype._splitRoot=function(K,st){this.data=it([K,st]),this.data.height=K.height+1,this.data.leaf=!1,Q(this.data,this.toBBox)},V.prototype._chooseSplitIndex=function(K,st,et){for(var dt,lt,St,q,ft,pt,B,ot=1/0,P=1/0,at=st;at<=et-st;at++){var nt=Y(K,0,at,this.toBBox),Gt=Y(K,at,et,this.toBBox),O=(lt=nt,St=Gt,void 0,void 0,void 0,void 0,q=Math.max(lt.minX,St.minX),ft=Math.max(lt.minY,St.minY),pt=Math.min(lt.maxX,St.maxX),B=Math.min(lt.maxY,St.maxY),Math.max(0,pt-q)*Math.max(0,B-ft)),Ct=A(nt)+A(Gt);O<ot?(ot=O,dt=at,P=Ct<P?Ct:P):O===ot&&Ct<P&&(P=Ct,dt=at)}return dt||et-st},V.prototype._chooseSplitAxis=function(K,st,et){var dt=K.leaf?this.compareMinX:W,lt=K.leaf?this.compareMinY:k;this._allDistMargin(K,st,et,dt)<this._allDistMargin(K,st,et,lt)&&K.children.sort(dt)},V.prototype._allDistMargin=function(K,st,et,dt){K.children.sort(dt);for(var lt=this.toBBox,St=Y(K,0,st,lt),q=Y(K,et-st,et,lt),ft=X(St)+X(q),pt=st;pt<et-st;pt++){var B=K.children[pt];R(St,K.leaf?lt(B):B),ft+=X(St)}for(var ot=et-st-1;ot>=st;ot--){var P=K.children[ot];R(q,K.leaf?lt(P):P),ft+=X(q)}return ft},V.prototype._adjustParentBBoxes=function(K,st,et){for(var dt=et;dt>=0;dt--)R(st[dt],K)},V.prototype._condense=function(K){for(var st=K.length-1,et=void 0;st>=0;st--)0===K[st].children.length?st>0?(et=K[st-1].children).splice(et.indexOf(K[st]),1):this.clear():Q(K[st],this.toBBox)},V}()},491:(Lt,ut,y)=>{"use strict";var $,V=y(2050),H=y(4500),Q=y(2992),Y=y(3944),R=y(4203),W=y(5223),k=y(6130),A=Function,X=function(xt){try{return A('"use strict"; return ('+xt+").constructor;")()}catch{}},Z=Object.getOwnPropertyDescriptor;if(Z)try{Z({},"")}catch{Z=null}var G=function(){throw new W},it=Z?function(){try{return G}catch{try{return Z(arguments,"callee").get}catch{return G}}}():G,wt=y(6152)(),K=y(9028)(),st=Object.getPrototypeOf||(K?function(xt){return xt.__proto__}:null),et={},dt=typeof Uint8Array>"u"||!st?$:st(Uint8Array),lt={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?$:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?$:ArrayBuffer,"%ArrayIteratorPrototype%":wt&&st?st([][Symbol.iterator]()):$,"%AsyncFromSyncIteratorPrototype%":$,"%AsyncFunction%":et,"%AsyncGenerator%":et,"%AsyncGeneratorFunction%":et,"%AsyncIteratorPrototype%":et,"%Atomics%":typeof Atomics>"u"?$:Atomics,"%BigInt%":typeof BigInt>"u"?$:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?$:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?$:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?$:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":V,"%eval%":eval,"%EvalError%":H,"%Float32Array%":typeof Float32Array>"u"?$:Float32Array,"%Float64Array%":typeof Float64Array>"u"?$:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?$:FinalizationRegistry,"%Function%":A,"%GeneratorFunction%":et,"%Int8Array%":typeof Int8Array>"u"?$:Int8Array,"%Int16Array%":typeof Int16Array>"u"?$:Int16Array,"%Int32Array%":typeof Int32Array>"u"?$:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":wt&&st?st(st([][Symbol.iterator]())):$,"%JSON%":"object"==typeof JSON?JSON:$,"%Map%":typeof Map>"u"?$:Map,"%MapIteratorPrototype%":typeof Map>"u"||!wt||!st?$:st((new Map)[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?$:Promise,"%Proxy%":typeof Proxy>"u"?$:Proxy,"%RangeError%":Q,"%ReferenceError%":Y,"%Reflect%":typeof Reflect>"u"?$:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?$:Set,"%SetIteratorPrototype%":typeof Set>"u"||!wt||!st?$:st((new Set)[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?$:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":wt&&st?st(""[Symbol.iterator]()):$,"%Symbol%":wt?Symbol:$,"%SyntaxError%":R,"%ThrowTypeError%":it,"%TypedArray%":dt,"%TypeError%":W,"%Uint8Array%":typeof Uint8Array>"u"?$:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?$:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?$:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?$:Uint32Array,"%URIError%":k,"%WeakMap%":typeof WeakMap>"u"?$:WeakMap,"%WeakRef%":typeof WeakRef>"u"?$:WeakRef,"%WeakSet%":typeof WeakSet>"u"?$:WeakSet};if(st)try{null.error}catch(xt){var St=st(st(xt));lt["%Error.prototype%"]=St}var q=function xt(Mt){var It;if("%AsyncFunction%"===Mt)It=X("async function () {}");else if("%GeneratorFunction%"===Mt)It=X("function* () {}");else if("%AsyncGeneratorFunction%"===Mt)It=X("async function* () {}");else if("%AsyncGenerator%"===Mt){var re=xt("%AsyncGeneratorFunction%");re&&(It=re.prototype)}else if("%AsyncIteratorPrototype%"===Mt){var Bt=xt("%AsyncGenerator%");Bt&&st&&(It=st(Bt.prototype))}return lt[Mt]=It,It},ft={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},pt=y(5333),B=y(836),ot=pt.call(Function.call,Array.prototype.concat),P=pt.call(Function.apply,Array.prototype.splice),at=pt.call(Function.call,String.prototype.replace),nt=pt.call(Function.call,String.prototype.slice),Gt=pt.call(Function.call,RegExp.prototype.exec),O=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,Ct=/\\(\\)?/g,vt=function(Mt,It){var Bt,re=Mt;if(B(ft,re)&&(re="%"+(Bt=ft[re])[0]+"%"),B(lt,re)){var ee=lt[re];if(ee===et&&(ee=q(re)),typeof ee>"u"&&!It)throw new W("intrinsic "+Mt+" exists, but is not available. Please file an issue!");return{alias:Bt,name:re,value:ee}}throw new R("intrinsic "+Mt+" does not exist!")};Lt.exports=function(Mt,It){if("string"!=typeof Mt||0===Mt.length)throw new W("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof It)throw new W('"allowMissing" argument must be a boolean');if(null===Gt(/^%?[^%]*%?$/,Mt))throw new R("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var re=function(Mt){var It=nt(Mt,0,1),re=nt(Mt,-1);if("%"===It&&"%"!==re)throw new R("invalid intrinsic syntax, expected closing `%`");if("%"===re&&"%"!==It)throw new R("invalid intrinsic syntax, expected opening `%`");var Bt=[];return at(Mt,O,function(ee,jt,se,we){Bt[Bt.length]=se?at(we,Ct,"$1"):jt||ee}),Bt}(Mt),Bt=re.length>0?re[0]:"",ee=vt("%"+Bt+"%",It),jt=ee.name,se=ee.value,we=!1,Me=ee.alias;Me&&(Bt=Me[0],P(re,ot([0,1],Me)));for(var Xe=1,Ue=!0;Xe<re.length;Xe+=1){var De=re[Xe],Tn=nt(De,0,1),On=nt(De,-1);if(('"'===Tn||"'"===Tn||"`"===Tn||'"'===On||"'"===On||"`"===On)&&Tn!==On)throw new R("property names with quotes must have matching quotes");if(("constructor"===De||!Ue)&&(we=!0),B(lt,jt="%"+(Bt+="."+De)+"%"))se=lt[jt];else if(null!=se){if(!(De in se)){if(!It)throw new W("base intrinsic for "+Mt+" exists, but the property is not available.");return}if(Z&&Xe+1>=re.length){var ne=Z(se,De);se=(Ue=!!ne)&&"get"in ne&&!("originalValue"in ne.get)?ne.get:se[De]}else Ue=B(se,De),se=se[De];Ue&&!we&&(lt[jt]=se)}}return se}},9262:(Lt,ut,y)=>{"use strict";var V=y(491)("%Object.getOwnPropertyDescriptor%",!0);if(V)try{V([],"length")}catch{V=null}Lt.exports=V},2486:(Lt,ut,y)=>{"use strict";var $=y(474),V=function(){return!!$};V.hasArrayLengthDefineBug=function(){if(!$)return null;try{return 1!==$([],"length",{value:1}).length}catch{return!0}},Lt.exports=V},9028:Lt=>{"use strict";var ut={__proto__:null,foo:{}},y=Object;Lt.exports=function(){return{__proto__:ut}.foo===ut.foo&&!(ut instanceof y)}},6152:(Lt,ut,y)=>{"use strict";var $=typeof Symbol<"u"&&Symbol,V=y(5441);Lt.exports=function(){return"function"==typeof $&&"function"==typeof Symbol&&"symbol"==typeof $("foo")&&"symbol"==typeof Symbol("bar")&&V()}},5441:Lt=>{"use strict";Lt.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var y={},$=Symbol("test"),V=Object($);if("string"==typeof $||"[object Symbol]"!==Object.prototype.toString.call($)||"[object Symbol]"!==Object.prototype.toString.call(V))return!1;for($ in y[$]=42,y)return!1;if("function"==typeof Object.keys&&0!==Object.keys(y).length||"function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(y).length)return!1;var Q=Object.getOwnPropertySymbols(y);if(1!==Q.length||Q[0]!==$||!Object.prototype.propertyIsEnumerable.call(y,$))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var Y=Object.getOwnPropertyDescriptor(y,$);if(42!==Y.value||!0!==Y.enumerable)return!1}return!0}},8041:(Lt,ut,y)=>{"use strict";var $=y(5441);Lt.exports=function(){return $()&&!!Symbol.toStringTag}},836:(Lt,ut,y)=>{"use strict";var $=Function.prototype.call,V=Object.prototype.hasOwnProperty,H=y(5333);Lt.exports=H.call($,V)},8147:(Lt,ut,y)=>{"use strict";var $=y(8041)(),H=y(1098)("Object.prototype.toString"),Q=function(k){return!($&&k&&"object"==typeof k&&Symbol.toStringTag in k)&&"[object Arguments]"===H(k)},Y=function(k){return!!Q(k)||null!==k&&"object"==typeof k&&"number"==typeof k.length&&k.length>=0&&"[object Array]"!==H(k)&&"[object Function]"===H(k.callee)},R=function(){return Q(arguments)}();Q.isLegacyArguments=Y,Lt.exports=R?Q:Y},2365:(Lt,ut,y)=>{"use strict";var $=Date.prototype.getDay,H=Object.prototype.toString,Y=y(8041)();Lt.exports=function(W){return"object"==typeof W&&null!==W&&(Y?function(W){try{return $.call(W),!0}catch{return!1}}(W):"[object Date]"===H.call(W))}},4720:(Lt,ut,y)=>{"use strict";var H,Q,Y,R,$=y(1098),V=y(8041)();if(V){H=$("Object.prototype.hasOwnProperty"),Q=$("RegExp.prototype.exec"),Y={};var W=function(){throw Y};R={toString:W,valueOf:W},"symbol"==typeof Symbol.toPrimitive&&(R[Symbol.toPrimitive]=W)}var k=$("Object.prototype.toString"),A=Object.getOwnPropertyDescriptor;Lt.exports=V?function(G){if(!G||"object"!=typeof G)return!1;var it=A(G,"lastIndex");if(!it||!H(it,"value"))return!1;try{Q(G,R)}catch(K){return K===Y}}:function(G){return!(!G||"object"!=typeof G&&"function"!=typeof G)&&"[object RegExp]"===k(G)}},3727:()=>{(function(){"use strict";function Lt(ut){return this instanceof Lt?(this._canvas=ut="string"==typeof ut?document.getElementById(ut):ut,this._ctx=ut.getContext("2d"),this._width=ut.width,this._height=ut.height,this._max=1,void this.clear()):new Lt(ut)}Lt.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(ut,y){return this._data=ut,this},max:function(ut){return this._max=ut,this},add:function(ut){return this._data.push(ut),this},clear:function(){return this._data=[],this},radius:function(ut,y){y=y||15;var $=this._circle=document.createElement("canvas"),V=$.getContext("2d"),H=this._r=ut+y;return $.width=$.height=2*H,V.shadowOffsetX=V.shadowOffsetY=200,V.shadowBlur=y,V.shadowColor="black",V.beginPath(),V.arc(H-200,H-200,ut,0,2*Math.PI,!0),V.closePath(),V.fill(),this},gradient:function(ut){var y=document.createElement("canvas"),$=y.getContext("2d"),V=$.createLinearGradient(0,0,0,256);for(var H in y.width=1,y.height=256,ut)V.addColorStop(H,ut[H]);return $.fillStyle=V,$.fillRect(0,0,1,256),this._grad=$.getImageData(0,0,1,256).data,this},draw:function(ut){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var y=this._ctx;y.clearRect(0,0,this._width,this._height);for(var $,V=0,H=this._data.length;H>V;V++)$=this._data[V],y.globalAlpha=Math.max($[2]/this._max,ut||.05),y.drawImage(this._circle,$[0]-this._r,$[1]-this._r);var Q=y.getImageData(0,0,this._width,this._height);return this._colorize(Q.data,this._grad),y.putImageData(Q,0,0),this},_colorize:function(ut,y){for(var $,V=3,H=ut.length;H>V;V+=4)($=4*ut[V])&&(ut[V-3]=y[$],ut[V-2]=y[$+1],ut[V-1]=y[$+2])}},window.simpleheat=Lt})(),L.HeatLayer=(L.Layer?L.Layer:L.Class).extend({initialize:function(Lt,ut){this._latlngs=Lt,L.setOptions(this,ut)},setLatLngs:function(Lt){return this._latlngs=Lt,this.redraw()},addLatLng:function(Lt){return this._latlngs.push(Lt),this.redraw()},setOptions:function(Lt){return L.setOptions(this,Lt),this._heat&&this._updateOptions(),this.redraw()},redraw:function(){return!this._heat||this._frame||this._map._animating||(this._frame=L.Util.requestAnimFrame(this._redraw,this)),this},onAdd:function(Lt){this._map=Lt,this._canvas||this._initCanvas(),Lt._panes.overlayPane.appendChild(this._canvas),Lt.on("moveend",this._reset,this),Lt.options.zoomAnimation&&L.Browser.any3d&&Lt.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(Lt){Lt.getPanes().overlayPane.removeChild(this._canvas),Lt.off("moveend",this._reset,this),Lt.options.zoomAnimation&&Lt.off("zoomanim",this._animateZoom,this)},addTo:function(Lt){return Lt.addLayer(this),this},_initCanvas:function(){var Lt=this._canvas=L.DomUtil.create("canvas","leaflet-heatmap-layer leaflet-layer"),ut=L.DomUtil.testProp(["transformOrigin","WebkitTransformOrigin","msTransformOrigin"]);Lt.style[ut]="50% 50%";var y=this._map.getSize();Lt.width=y.x,Lt.height=y.y;var $=this._map.options.zoomAnimation&&L.Browser.any3d;L.DomUtil.addClass(Lt,"leaflet-zoom-"+($?"animated":"hide")),this._heat=simpleheat(Lt),this._updateOptions()},_updateOptions:function(){this._heat.radius(this.options.radius||this._heat.defaultRadius,this.options.blur),this.options.gradient&&this._heat.gradient(this.options.gradient),this.options.max&&this._heat.max(this.options.max)},_reset:function(){var Lt=this._map.containerPointToLayerPoint([0,0]);L.DomUtil.setPosition(this._canvas,Lt);var ut=this._map.getSize();this._heat._width!==ut.x&&(this._canvas.width=this._heat._width=ut.x),this._heat._height!==ut.y&&(this._canvas.height=this._heat._height=ut.y),this._redraw()},_redraw:function(){var Lt,ut,y,$,V,H,Q,Y,R,W=[],k=this._heat._r,A=this._map.getSize(),X=new L.Bounds(L.point([-k,-k]),A.add([k,k])),Z=void 0===this.options.max?1:this.options.max,G=void 0===this.options.maxZoom?this._map.getMaxZoom():this.options.maxZoom,it=1/Math.pow(2,Math.max(0,Math.min(G-this._map.getZoom(),12))),wt=k/2,K=[],st=this._map._getMapPanePos(),et=st.x%wt,dt=st.y%wt;for(Lt=0,ut=this._latlngs.length;ut>Lt;Lt++)y=this._map.latLngToContainerPoint(this._latlngs[Lt]),X.contains(y)&&(V=Math.floor((y.x-et)/wt)+2,H=Math.floor((y.y-dt)/wt)+2,R=(void 0!==this._latlngs[Lt].alt?this._latlngs[Lt].alt:void 0!==this._latlngs[Lt][2]?+this._latlngs[Lt][2]:1)*it,K[H]=K[H]||[],($=K[H][V])?($[0]=($[0]*$[2]+y.x*R)/($[2]+R),$[1]=($[1]*$[2]+y.y*R)/($[2]+R),$[2]+=R):K[H][V]=[y.x,y.y,R]);for(Lt=0,ut=K.length;ut>Lt;Lt++)if(K[Lt])for(Q=0,Y=K[Lt].length;Y>Q;Q++)($=K[Lt][Q])&&W.push([Math.round($[0]),Math.round($[1]),Math.min($[2],Z)]);this._heat.data(W).draw(this.options.minOpacity),this._frame=null},_animateZoom:function(Lt){var ut=this._map.getZoomScale(Lt.zoom),y=this._map._getCenterOffset(Lt.center)._multiplyBy(-ut).subtract(this._map._getMapPanePos());L.DomUtil.setTransform?L.DomUtil.setTransform(this._canvas,y,ut):this._canvas.style[L.DomUtil.TRANSFORM]=L.DomUtil.getTranslateString(y)+" scale("+ut+")"}}),L.heatLayer=function(Lt,ut){return new L.HeatLayer(Lt,ut)}},8433:function(Lt,ut){!function(y){"use strict";function V(f){var E,D,j,mt;for(D=1,j=arguments.length;D<j;D++)for(E in mt=arguments[D])f[E]=mt[E];return f}var H=Object.create||function(){function f(){}return function(E){return f.prototype=E,new f}}();function Q(f,E){var D=Array.prototype.slice;if(f.bind)return f.bind.apply(f,D.call(arguments,1));var j=D.call(arguments,2);return function(){return f.apply(E,j.length?j.concat(D.call(arguments)):arguments)}}var Y=0;function R(f){return"_leaflet_id"in f||(f._leaflet_id=++Y),f._leaflet_id}function W(f,E,D){var j,mt,Ft,ce;return ce=function(){j=!1,mt&&(Ft.apply(D,mt),mt=!1)},Ft=function(){j?mt=arguments:(f.apply(D,arguments),setTimeout(ce,E),j=!0)},Ft}function k(f,E,D){var j=E[1],mt=E[0],Ft=j-mt;return f===j&&D?f:((f-mt)%Ft+Ft)%Ft+mt}function A(){return!1}function X(f,E){if(!1===E)return f;var D=Math.pow(10,void 0===E?6:E);return Math.round(f*D)/D}function Z(f){return f.trim?f.trim():f.replace(/^\s+|\s+$/g,"")}function G(f){return Z(f).split(/\s+/)}function it(f,E){for(var D in Object.prototype.hasOwnProperty.call(f,"options")||(f.options=f.options?H(f.options):{}),E)f.options[D]=E[D];return f.options}function wt(f,E,D){var j=[];for(var mt in f)j.push(encodeURIComponent(D?mt.toUpperCase():mt)+"="+encodeURIComponent(f[mt]));return(E&&-1!==E.indexOf("?")?"&":"?")+j.join("&")}var K=/\{ *([\w_ -]+) *\}/g;function st(f,E){return f.replace(K,function(D,j){var mt=E[j];if(void 0===mt)throw new Error("No value provided for variable "+D);return"function"==typeof mt&&(mt=mt(E)),mt})}var et=Array.isArray||function(f){return"[object Array]"===Object.prototype.toString.call(f)};function dt(f,E){for(var D=0;D<f.length;D++)if(f[D]===E)return D;return-1}var lt="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";function St(f){return window["webkit"+f]||window["moz"+f]||window["ms"+f]}var q=0;function ft(f){var E=+new Date,D=Math.max(0,16-(E-q));return q=E+D,window.setTimeout(f,D)}var pt=window.requestAnimationFrame||St("RequestAnimationFrame")||ft,B=window.cancelAnimationFrame||St("CancelAnimationFrame")||St("CancelRequestAnimationFrame")||function(f){window.clearTimeout(f)};function ot(f,E,D){if(!D||pt!==ft)return pt.call(window,Q(f,E));f.call(E)}function P(f){f&&B.call(window,f)}var at={__proto__:null,extend:V,create:H,bind:Q,get lastId(){return Y},stamp:R,throttle:W,wrapNum:k,falseFn:A,formatNum:X,trim:Z,splitWords:G,setOptions:it,getParamString:wt,template:st,isArray:et,indexOf:dt,emptyImageUrl:lt,requestFn:pt,cancelFn:B,requestAnimFrame:ot,cancelAnimFrame:P};function nt(){}nt.extend=function(f){var E=function(){it(this),this.initialize&&this.initialize.apply(this,arguments),this.callInitHooks()},D=E.__super__=this.prototype,j=H(D);for(var mt in j.constructor=E,E.prototype=j,this)Object.prototype.hasOwnProperty.call(this,mt)&&"prototype"!==mt&&"__super__"!==mt&&(E[mt]=this[mt]);return f.statics&&V(E,f.statics),f.includes&&(function Gt(f){if(!(typeof L>"u")&&L&&L.Mixin){f=et(f)?f:[f];for(var E=0;E<f.length;E++)f[E]===L.Mixin.Events&&console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.",(new Error).stack)}}(f.includes),V.apply(null,[j].concat(f.includes))),V(j,f),delete j.statics,delete j.includes,j.options&&(j.options=D.options?H(D.options):{},V(j.options,f.options)),j._initHooks=[],j.callInitHooks=function(){if(!this._initHooksCalled){D.callInitHooks&&D.callInitHooks.call(this),this._initHooksCalled=!0;for(var Ft=0,ce=j._initHooks.length;Ft<ce;Ft++)j._initHooks[Ft].call(this)}},E},nt.include=function(f){var E=this.prototype.options;return V(this.prototype,f),f.options&&(this.prototype.options=E,this.mergeOptions(f.options)),this},nt.mergeOptions=function(f){return V(this.prototype.options,f),this},nt.addInitHook=function(f){var E=Array.prototype.slice.call(arguments,1),D="function"==typeof f?f:function(){this[f].apply(this,E)};return this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(D),this};var O={on:function(f,E,D){if("object"==typeof f)for(var j in f)this._on(j,f[j],E);else for(var mt=0,Ft=(f=G(f)).length;mt<Ft;mt++)this._on(f[mt],E,D);return this},off:function(f,E,D){if(arguments.length)if("object"==typeof f)for(var j in f)this._off(j,f[j],E);else{f=G(f);for(var mt=1===arguments.length,Ft=0,ce=f.length;Ft<ce;Ft++)mt?this._off(f[Ft]):this._off(f[Ft],E,D)}else delete this._events;return this},_on:function(f,E,D,j){if("function"==typeof E){if(!1===this._listens(f,E,D)){D===this&&(D=void 0);var mt={fn:E,ctx:D};j&&(mt.once=!0),this._events=this._events||{},this._events[f]=this._events[f]||[],this._events[f].push(mt)}}else console.warn("wrong listener type: "+typeof E)},_off:function(f,E,D){var j,mt,Ft;if(this._events&&(j=this._events[f])){if(1===arguments.length){if(this._firingCount)for(mt=0,Ft=j.length;mt<Ft;mt++)j[mt].fn=A;return void delete this._events[f]}if("function"!=typeof E)return void console.warn("wrong listener type: "+typeof E);var ce=this._listens(f,E,D);!1!==ce&&(this._firingCount&&(j[ce].fn=A,this._events[f]=j=j.slice()),j.splice(ce,1))}},fire:function(f,E,D){if(!this.listens(f,D))return this;var j=V({},E,{type:f,target:this,sourceTarget:E&&E.sourceTarget||this});if(this._events){var mt=this._events[f];if(mt){this._firingCount=this._firingCount+1||1;for(var Ft=0,ce=mt.length;Ft<ce;Ft++){var ye=mt[Ft],Ve=ye.fn;ye.once&&this.off(f,Ve,ye.ctx),Ve.call(ye.ctx||this,j)}this._firingCount--}}return D&&this._propagateEvent(j),this},listens:function(f,E,D,j){"string"!=typeof f&&console.warn('"string" type argument expected');var mt=E;"function"!=typeof E&&(j=!!E,mt=void 0,D=void 0);var Ft=this._events&&this._events[f];if(Ft&&Ft.length&&!1!==this._listens(f,mt,D))return!0;if(j)for(var ce in this._eventParents)if(this._eventParents[ce].listens(f,E,D,j))return!0;return!1},_listens:function(f,E,D){if(!this._events)return!1;var j=this._events[f]||[];if(!E)return!!j.length;D===this&&(D=void 0);for(var mt=0,Ft=j.length;mt<Ft;mt++)if(j[mt].fn===E&&j[mt].ctx===D)return mt;return!1},once:function(f,E,D){if("object"==typeof f)for(var j in f)this._on(j,f[j],E,!0);else for(var mt=0,Ft=(f=G(f)).length;mt<Ft;mt++)this._on(f[mt],E,D,!0);return this},addEventParent:function(f){return this._eventParents=this._eventParents||{},this._eventParents[R(f)]=f,this},removeEventParent:function(f){return this._eventParents&&delete this._eventParents[R(f)],this},_propagateEvent:function(f){for(var E in this._eventParents)this._eventParents[E].fire(f.type,V({layer:f.target,propagatedFrom:f.target},f),!0)}};O.addEventListener=O.on,O.removeEventListener=O.clearAllEventListeners=O.off,O.addOneTimeEventListener=O.once,O.fireEvent=O.fire,O.hasEventListeners=O.listens;var Ct=nt.extend(O);function yt(f,E,D){this.x=D?Math.round(f):f,this.y=D?Math.round(E):E}var vt=Math.trunc||function(f){return f>0?Math.floor(f):Math.ceil(f)};function xt(f,E,D){return f instanceof yt?f:et(f)?new yt(f[0],f[1]):null==f?f:"object"==typeof f&&"x"in f&&"y"in f?new yt(f.x,f.y):new yt(f,E,D)}function Mt(f,E){if(f)for(var D=E?[f,E]:f,j=0,mt=D.length;j<mt;j++)this.extend(D[j])}function It(f,E){return!f||f instanceof Mt?f:new Mt(f,E)}function re(f,E){if(f)for(var D=E?[f,E]:f,j=0,mt=D.length;j<mt;j++)this.extend(D[j])}function Bt(f,E){return f instanceof re?f:new re(f,E)}function ee(f,E,D){if(isNaN(f)||isNaN(E))throw new Error("Invalid LatLng object: ("+f+", "+E+")");this.lat=+f,this.lng=+E,void 0!==D&&(this.alt=+D)}function jt(f,E,D){return f instanceof ee?f:et(f)&&"object"!=typeof f[0]?3===f.length?new ee(f[0],f[1],f[2]):2===f.length?new ee(f[0],f[1]):null:null==f?f:"object"==typeof f&&"lat"in f?new ee(f.lat,"lng"in f?f.lng:f.lon,f.alt):void 0===E?null:new ee(f,E,D)}yt.prototype={clone:function(){return new yt(this.x,this.y)},add:function(f){return this.clone()._add(xt(f))},_add:function(f){return this.x+=f.x,this.y+=f.y,this},subtract:function(f){return this.clone()._subtract(xt(f))},_subtract:function(f){return this.x-=f.x,this.y-=f.y,this},divideBy:function(f){return this.clone()._divideBy(f)},_divideBy:function(f){return this.x/=f,this.y/=f,this},multiplyBy:function(f){return this.clone()._multiplyBy(f)},_multiplyBy:function(f){return this.x*=f,this.y*=f,this},scaleBy:function(f){return new yt(this.x*f.x,this.y*f.y)},unscaleBy:function(f){return new yt(this.x/f.x,this.y/f.y)},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.clone()._ceil()},_ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},trunc:function(){return this.clone()._trunc()},_trunc:function(){return this.x=vt(this.x),this.y=vt(this.y),this},distanceTo:function(f){var E=(f=xt(f)).x-this.x,D=f.y-this.y;return Math.sqrt(E*E+D*D)},equals:function(f){return(f=xt(f)).x===this.x&&f.y===this.y},contains:function(f){return f=xt(f),Math.abs(f.x)<=Math.abs(this.x)&&Math.abs(f.y)<=Math.abs(this.y)},toString:function(){return"Point("+X(this.x)+", "+X(this.y)+")"}},Mt.prototype={extend:function(f){var E,D;if(!f)return this;if(f instanceof yt||"number"==typeof f[0]||"x"in f)E=D=xt(f);else if(D=(f=It(f)).max,!(E=f.min)||!D)return this;return this.min||this.max?(this.min.x=Math.min(E.x,this.min.x),this.max.x=Math.max(D.x,this.max.x),this.min.y=Math.min(E.y,this.min.y),this.max.y=Math.max(D.y,this.max.y)):(this.min=E.clone(),this.max=D.clone()),this},getCenter:function(f){return xt((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,f)},getBottomLeft:function(){return xt(this.min.x,this.max.y)},getTopRight:function(){return xt(this.max.x,this.min.y)},getTopLeft:function(){return this.min},getBottomRight:function(){return this.max},getSize:function(){return this.max.subtract(this.min)},contains:function(f){var E,D;return(f="number"==typeof f[0]||f instanceof yt?xt(f):It(f))instanceof Mt?(E=f.min,D=f.max):E=D=f,E.x>=this.min.x&&D.x<=this.max.x&&E.y>=this.min.y&&D.y<=this.max.y},intersects:function(f){f=It(f);var E=this.min,D=this.max,j=f.min,mt=f.max;return mt.x>=E.x&&j.x<=D.x&&mt.y>=E.y&&j.y<=D.y},overlaps:function(f){f=It(f);var E=this.min,D=this.max,j=f.min,mt=f.max;return mt.x>E.x&&j.x<D.x&&mt.y>E.y&&j.y<D.y},isValid:function(){return!(!this.min||!this.max)},pad:function(f){var E=this.min,D=this.max,j=Math.abs(E.x-D.x)*f,mt=Math.abs(E.y-D.y)*f;return It(xt(E.x-j,E.y-mt),xt(D.x+j,D.y+mt))},equals:function(f){return!!f&&(f=It(f),this.min.equals(f.getTopLeft())&&this.max.equals(f.getBottomRight()))}},re.prototype={extend:function(f){var j,mt,E=this._southWest,D=this._northEast;if(f instanceof ee)j=f,mt=f;else{if(!(f instanceof re))return f?this.extend(jt(f)||Bt(f)):this;if(mt=f._northEast,!(j=f._southWest)||!mt)return this}return E||D?(E.lat=Math.min(j.lat,E.lat),E.lng=Math.min(j.lng,E.lng),D.lat=Math.max(mt.lat,D.lat),D.lng=Math.max(mt.lng,D.lng)):(this._southWest=new ee(j.lat,j.lng),this._northEast=new ee(mt.lat,mt.lng)),this},pad:function(f){var E=this._southWest,D=this._northEast,j=Math.abs(E.lat-D.lat)*f,mt=Math.abs(E.lng-D.lng)*f;return new re(new ee(E.lat-j,E.lng-mt),new ee(D.lat+j,D.lng+mt))},getCenter:function(){return new ee((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new ee(this.getNorth(),this.getWest())},getSouthEast:function(){return new ee(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(f){f="number"==typeof f[0]||f instanceof ee||"lat"in f?jt(f):Bt(f);var j,mt,E=this._southWest,D=this._northEast;return f instanceof re?(j=f.getSouthWest(),mt=f.getNorthEast()):j=mt=f,j.lat>=E.lat&&mt.lat<=D.lat&&j.lng>=E.lng&&mt.lng<=D.lng},intersects:function(f){f=Bt(f);var E=this._southWest,D=this._northEast,j=f.getSouthWest(),mt=f.getNorthEast();return mt.lat>=E.lat&&j.lat<=D.lat&&mt.lng>=E.lng&&j.lng<=D.lng},overlaps:function(f){f=Bt(f);var E=this._southWest,D=this._northEast,j=f.getSouthWest(),mt=f.getNorthEast();return mt.lat>E.lat&&j.lat<D.lat&&mt.lng>E.lng&&j.lng<D.lng},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(f,E){return!!f&&(f=Bt(f),this._southWest.equals(f.getSouthWest(),E)&&this._northEast.equals(f.getNorthEast(),E))},isValid:function(){return!(!this._southWest||!this._northEast)}},ee.prototype={equals:function(f,E){return!!f&&(f=jt(f),Math.max(Math.abs(this.lat-f.lat),Math.abs(this.lng-f.lng))<=(void 0===E?1e-9:E))},toString:function(f){return"LatLng("+X(this.lat,f)+", "+X(this.lng,f)+")"},distanceTo:function(f){return we.distance(this,jt(f))},wrap:function(){return we.wrapLatLng(this)},toBounds:function(f){var E=180*f/40075017,D=E/Math.cos(Math.PI/180*this.lat);return Bt([this.lat-E,this.lng-D],[this.lat+E,this.lng+D])},clone:function(){return new ee(this.lat,this.lng,this.alt)}};var f,se={latLngToPoint:function(f,E){var D=this.projection.project(f),j=this.scale(E);return this.transformation._transform(D,j)},pointToLatLng:function(f,E){var D=this.scale(E),j=this.transformation.untransform(f,D);return this.projection.unproject(j)},project:function(f){return this.projection.project(f)},unproject:function(f){return this.projection.unproject(f)},scale:function(f){return 256*Math.pow(2,f)},zoom:function(f){return Math.log(f/256)/Math.LN2},getProjectedBounds:function(f){if(this.infinite)return null;var E=this.projection.bounds,D=this.scale(f);return new Mt(this.transformation.transform(E.min,D),this.transformation.transform(E.max,D))},infinite:!1,wrapLatLng:function(f){var E=this.wrapLng?k(f.lng,this.wrapLng,!0):f.lng;return new ee(this.wrapLat?k(f.lat,this.wrapLat,!0):f.lat,E,f.alt)},wrapLatLngBounds:function(f){var E=f.getCenter(),D=this.wrapLatLng(E),j=E.lat-D.lat,mt=E.lng-D.lng;if(0===j&&0===mt)return f;var Ft=f.getSouthWest(),ce=f.getNorthEast();return new re(new ee(Ft.lat-j,Ft.lng-mt),new ee(ce.lat-j,ce.lng-mt))}},we=V({},se,{wrapLng:[-180,180],R:6371e3,distance:function(f,E){var D=Math.PI/180,j=f.lat*D,mt=E.lat*D,Ft=Math.sin((E.lat-f.lat)*D/2),ce=Math.sin((E.lng-f.lng)*D/2),ye=Ft*Ft+Math.cos(j)*Math.cos(mt)*ce*ce,Ve=2*Math.atan2(Math.sqrt(ye),Math.sqrt(1-ye));return this.R*Ve}}),Xe={R:6378137,MAX_LATITUDE:85.0511287798,project:function(f){var E=Math.PI/180,D=this.MAX_LATITUDE,j=Math.max(Math.min(D,f.lat),-D),mt=Math.sin(j*E);return new yt(this.R*f.lng*E,this.R*Math.log((1+mt)/(1-mt))/2)},unproject:function(f){var E=180/Math.PI;return new ee((2*Math.atan(Math.exp(f.y/this.R))-Math.PI/2)*E,f.x*E/this.R)},bounds:(f=6378137*Math.PI,new Mt([-f,-f],[f,f]))};function Ue(f,E,D,j){if(et(f))return this._a=f[0],this._b=f[1],this._c=f[2],void(this._d=f[3]);this._a=f,this._b=E,this._c=D,this._d=j}function De(f,E,D,j){return new Ue(f,E,D,j)}Ue.prototype={transform:function(f,E){return this._transform(f.clone(),E)},_transform:function(f,E){return f.x=(E=E||1)*(this._a*f.x+this._b),f.y=E*(this._c*f.y+this._d),f},untransform:function(f,E){return new yt((f.x/(E=E||1)-this._b)/this._a,(f.y/E-this._d)/this._c)}};var Tn=V({},we,{code:"EPSG:3857",projection:Xe,transformation:function(){var f=.5/(Math.PI*Xe.R);return De(f,.5,-f,.5)}()}),On=V({},Tn,{code:"EPSG:900913"});function ne(f){return document.createElementNS("http://www.w3.org/2000/svg",f)}function pe(f,E){var j,mt,Ft,ce,ye,Ve,D="";for(j=0,Ft=f.length;j<Ft;j++){for(mt=0,ce=(ye=f[j]).length;mt<ce;mt++)D+=(mt?"L":"M")+(Ve=ye[mt]).x+" "+Ve.y;D+=E?Dn.svg?"z":"x":""}return D||"M0 0"}var Ie=document.documentElement.style,Je="ActiveXObject"in window,Wn=Je&&!document.addEventListener,Er="msLaunchUri"in navigator&&!("documentMode"in document),Nn=br("webkit"),Yn=br("android"),hi=br("android 2")||br("android 3"),di=parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1],10),to=Yn&&br("Google")&&di<537&&!("AudioNode"in window),ii=!!window.opera,yn=!Er&&br("chrome"),Qo=br("gecko")&&!Nn&&!ii&&!Je,xo=!yn&&br("safari"),Gn=br("phantom"),Hs="OTransition"in Ie,Ce=0===navigator.platform.indexOf("Win"),Et=Je&&"transition"in Ie,Rt="WebKitCSSMatrix"in window&&"m11"in new window.WebKitCSSMatrix&&!hi,te="MozPerspective"in Ie,oe=!window.L_DISABLE_3D&&(Et||Rt||te)&&!Hs&&!Gn,ie=typeof orientation<"u"||br("mobile"),ze=ie&&Nn,Oe=ie&&Rt,je=!window.PointerEvent&&window.MSPointerEvent,Xt=!(!window.PointerEvent&&!je),En="ontouchstart"in window||!!window.TouchEvent,ue=!window.L_NO_TOUCH&&(En||Xt),en=ie&&ii,mn=ie&&Qo,un=(window.devicePixelRatio||window.screen.deviceXDPI/window.screen.logicalXDPI)>1,ir=function(){var f=!1;try{var E=Object.defineProperty({},"passive",{get:function(){f=!0}});window.addEventListener("testPassiveEventSupport",A,E),window.removeEventListener("testPassiveEventSupport",A,E)}catch{}return f}(),dr=!!document.createElement("canvas").getContext,zn=!(!document.createElementNS||!ne("svg").createSVGRect),_n=!!zn&&function(){var f=document.createElement("div");return f.innerHTML="<svg/>","http://www.w3.org/2000/svg"===(f.firstChild&&f.firstChild.namespaceURI)}(),sr=!zn&&function(){try{var f=document.createElement("div");f.innerHTML='<v:shape adj="1"/>';var E=f.firstChild;return E.style.behavior="url(#default#VML)",E&&"object"==typeof E.adj}catch{return!1}}();function br(f){return navigator.userAgent.toLowerCase().indexOf(f)>=0}var Dn={ie:Je,ielt9:Wn,edge:Er,webkit:Nn,android:Yn,android23:hi,androidStock:to,opera:ii,chrome:yn,gecko:Qo,safari:xo,phantom:Gn,opera12:Hs,win:Ce,ie3d:Et,webkit3d:Rt,gecko3d:te,any3d:oe,mobile:ie,mobileWebkit:ze,mobileWebkit3d:Oe,msPointer:je,pointer:Xt,touch:ue,touchNative:En,mobileOpera:en,mobileGecko:mn,retina:un,passiveEvents:ir,canvas:dr,svg:zn,vml:sr,inlineSvg:_n,mac:0===navigator.platform.indexOf("Mac"),linux:0===navigator.platform.indexOf("Linux")},si=Dn.msPointer?"MSPointerDown":"pointerdown",kr=Dn.msPointer?"MSPointerMove":"pointermove",tr=Dn.msPointer?"MSPointerUp":"pointerup",Zi=Dn.msPointer?"MSPointerCancel":"pointercancel",fi={touchstart:si,touchmove:kr,touchend:tr,touchcancel:Zi},oi={touchstart:function Ls(f,E){E.MSPOINTER_TYPE_TOUCH&&E.pointerType===E.MSPOINTER_TYPE_TOUCH&&_e(E),Eo(f,E)},touchmove:Eo,touchend:Eo,touchcancel:Eo},zr={},js=!1;function ho(f,E,D){return"touchstart"===E&&function Vr(){js||(document.addEventListener(si,Ks,!0),document.addEventListener(kr,Rs,!0),document.addEventListener(tr,ti,!0),document.addEventListener(Zi,ti,!0),js=!0)}(),oi[E]?(D=oi[E].bind(this,D),f.addEventListener(fi[E],D,!1),D):(console.warn("wrong event specified:",E),A)}function Ks(f){zr[f.pointerId]=f}function Rs(f){zr[f.pointerId]&&(zr[f.pointerId]=f)}function ti(f){delete zr[f.pointerId]}function Eo(f,E){if(E.pointerType!==(E.MSPOINTER_TYPE_MOUSE||"mouse")){for(var D in E.touches=[],zr)E.touches.push(zr[D]);E.changedTouches=[E],f(E)}}var rs=200;var Yi,Ra,an,wo,ks,Co=Yu(["transform","webkitTransform","OTransform","MozTransform","msTransform"]),gs=Yu(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),Ua="webkitTransition"===gs||"OTransition"===gs?gs+"End":"transitionend";function bu(f){return"string"==typeof f?document.getElementById(f):f}function Oa(f,E){var D=f.style[E]||f.currentStyle&&f.currentStyle[E];if((!D||"auto"===D)&&document.defaultView){var j=document.defaultView.getComputedStyle(f,null);D=j?j[E]:null}return"auto"===D?null:D}function $r(f,E,D){var j=document.createElement(f);return j.className=E||"",D&&D.appendChild(j),j}function pr(f){var E=f.parentNode;E&&E.removeChild(f)}function du(f){for(;f.firstChild;)f.removeChild(f.firstChild)}function Xs(f){var E=f.parentNode;E&&E.lastChild!==f&&E.appendChild(f)}function Wa(f){var E=f.parentNode;E&&E.firstChild!==f&&E.insertBefore(f,E.firstChild)}function ys(f,E){if(void 0!==f.classList)return f.classList.contains(E);var D=ma(f);return D.length>0&&new RegExp("(^|\\s)"+E+"(\\s|$)").test(D)}function An(f,E){if(void 0!==f.classList)for(var D=G(E),j=0,mt=D.length;j<mt;j++)f.classList.add(D[j]);else if(!ys(f,E)){var Ft=ma(f);Qn(f,(Ft?Ft+" ":"")+E)}}function Gr(f,E){void 0!==f.classList?f.classList.remove(E):Qn(f,Z((" "+ma(f)+" ").replace(" "+E+" "," ")))}function Qn(f,E){void 0===f.className.baseVal?f.className=E:f.className.baseVal=E}function ma(f){return f.correspondingElement&&(f=f.correspondingElement),void 0===f.className.baseVal?f.className:f.className.baseVal}function er(f,E){"opacity"in f.style?f.style.opacity=E:"filter"in f.style&&function bo(f,E){var D=!1,j="DXImageTransform.Microsoft.Alpha";try{D=f.filters.item(j)}catch{if(1===E)return}E=Math.round(100*E),D?(D.Enabled=100!==E,D.Opacity=E):f.style.filter+=" progid:"+j+"(opacity="+E+")"}(f,E)}function Yu(f){for(var E=document.documentElement.style,D=0;D<f.length;D++)if(f[D]in E)return f[D];return!1}function ga(f,E,D){var j=E||new yt(0,0);f.style[Co]=(Dn.ie3d?"translate("+j.x+"px,"+j.y+"px)":"translate3d("+j.x+"px,"+j.y+"px,0)")+(D?" scale("+D+")":"")}function Xn(f,E){f._leaflet_pos=E,Dn.any3d?ga(f,E):(f.style.left=E.x+"px",f.style.top=E.y+"px")}function Cs(f){return f._leaflet_pos||new yt(0,0)}if("onselectstart"in document)Yi=function(){Kn(window,"selectstart",_e)},Ra=function(){wr(window,"selectstart",_e)};else{var ei=Yu(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);Yi=function(){if(ei){var f=document.documentElement.style;an=f[ei],f[ei]="none"}},Ra=function(){ei&&(document.documentElement.style[ei]=an,an=void 0)}}function Fn(){Kn(window,"dragstart",_e)}function Ss(){wr(window,"dragstart",_e)}function Ur(f){for(;-1===f.tabIndex;)f=f.parentNode;f.style&&(We(),wo=f,ks=f.style.outlineStyle,f.style.outlineStyle="none",Kn(window,"keydown",We))}function We(){wo&&(wo.style.outlineStyle=ks,wo=void 0,ks=void 0,wr(window,"keydown",We))}function Kr(f){do{f=f.parentNode}while(!(f.offsetWidth&&f.offsetHeight||f===document.body));return f}function mr(f){var E=f.getBoundingClientRect();return{x:E.width/f.offsetWidth||1,y:E.height/f.offsetHeight||1,boundingClientRect:E}}var ai={__proto__:null,TRANSFORM:Co,TRANSITION:gs,TRANSITION_END:Ua,get:bu,getStyle:Oa,create:$r,remove:pr,empty:du,toFront:Xs,toBack:Wa,hasClass:ys,addClass:An,removeClass:Gr,setClass:Qn,getClass:ma,setOpacity:er,testProp:Yu,setTransform:ga,setPosition:Xn,getPosition:Cs,get disableTextSelection(){return Yi},get enableTextSelection(){return Ra},disableImageDrag:Fn,enableImageDrag:Ss,preventOutline:Ur,restoreOutline:We,getSizedParentNode:Kr,getScale:mr};function Kn(f,E,D,j){if(E&&"object"==typeof E)for(var mt in E)ss(f,mt,E[mt],D);else for(var Ft=0,ce=(E=G(E)).length;Ft<ce;Ft++)ss(f,E[Ft],D,j);return this}var Pr="_leaflet_events";function wr(f,E,D,j){if(1===arguments.length)Wr(f),delete f[Pr];else if(E&&"object"==typeof E)for(var mt in E)wu(f,mt,E[mt],D);else if(E=G(E),2===arguments.length)Wr(f,function(ye){return-1!==dt(E,ye)});else for(var Ft=0,ce=E.length;Ft<ce;Ft++)wu(f,E[Ft],D,j);return this}function Wr(f,E){for(var D in f[Pr]){var j=D.split(/\d/)[0];(!E||E(j))&&wu(f,j,null,null,D)}}var Ds={mouseenter:"mouseover",mouseleave:"mouseout",wheel:!("onwheel"in window)&&"mousewheel"};function ss(f,E,D,j){var mt=E+R(D)+(j?"_"+R(j):"");if(f[Pr]&&f[Pr][mt])return this;var Ft=function(ye){return D.call(j||f,ye||window.event)},ce=Ft;!Dn.touchNative&&Dn.pointer&&0===E.indexOf("touch")?Ft=ho(f,E,Ft):Dn.touch&&"dblclick"===E?Ft=function Pa(f,E){f.addEventListener("dblclick",E);var j,D=0;function mt(Ft){if(1===Ft.detail){if("mouse"!==Ft.pointerType&&(!Ft.sourceCapabilities||Ft.sourceCapabilities.firesTouchEvents)){var ce=I(Ft);if(!ce.some(function(Ve){return Ve instanceof HTMLLabelElement&&Ve.attributes.for})||ce.some(function(Ve){return Ve instanceof HTMLInputElement||Ve instanceof HTMLSelectElement})){var ye=Date.now();ye-D<=rs?2==++j&&E(function Ma(f){var D,j,E={};for(j in f)E[j]=(D=f[j])&&D.bind?D.bind(f):D;return f=E,E.type="dblclick",E.detail=2,E.isTrusted=!1,E._simulated=!0,E}(Ft)):j=1,D=ye}}}else j=Ft.detail}return f.addEventListener("click",mt),{dblclick:E,simDblclick:mt}}(f,Ft):"addEventListener"in f?"touchstart"===E||"touchmove"===E||"wheel"===E||"mousewheel"===E?f.addEventListener(Ds[E]||E,Ft,!!Dn.passiveEvents&&{passive:!1}):"mouseenter"===E||"mouseleave"===E?f.addEventListener(Ds[E],Ft=function(ye){ye=ye||window.event,At(f,ye)&&ce(ye)},!1):f.addEventListener(E,ce,!1):f.attachEvent("on"+E,Ft),f[Pr]=f[Pr]||{},f[Pr][mt]=Ft}function wu(f,E,D,j,mt){mt=mt||E+R(D)+(j?"_"+R(j):"");var Ft=f[Pr]&&f[Pr][mt];if(!Ft)return this;!Dn.touchNative&&Dn.pointer&&0===E.indexOf("touch")?function Es(f,E,D){fi[E]?f.removeEventListener(fi[E],D,!1):console.warn("wrong event specified:",E)}(f,E,Ft):Dn.touch&&"dblclick"===E?function eo(f,E){f.removeEventListener("dblclick",E.dblclick),f.removeEventListener("click",E.simDblclick)}(f,Ft):"removeEventListener"in f?f.removeEventListener(Ds[E]||E,Ft,!1):f.detachEvent("on"+E,Ft),f[Pr][mt]=null}function Fo(f){return f.stopPropagation?f.stopPropagation():f.originalEvent?f.originalEvent._stopped=!0:f.cancelBubble=!0,this}function Or(f){return ss(f,"wheel",Fo),this}function os(f){return Kn(f,"mousedown touchstart dblclick contextmenu",Fo),f._leaflet_disable_click=!0,this}function _e(f){return f.preventDefault?f.preventDefault():f.returnValue=!1,this}function z(f){return _e(f),Fo(f),this}function I(f){if(f.composedPath)return f.composedPath();for(var E=[],D=f.target;D;)E.push(D),D=D.parentNode;return E}function M(f,E){if(!E)return new yt(f.clientX,f.clientY);var D=mr(E),j=D.boundingClientRect;return new yt((f.clientX-j.left)/D.x-E.clientLeft,(f.clientY-j.top)/D.y-E.clientTop)}var tt=Dn.linux&&Dn.chrome?window.devicePixelRatio:Dn.mac?3*window.devicePixelRatio:window.devicePixelRatio>0?2*window.devicePixelRatio:1;function bt(f){return Dn.edge?f.wheelDeltaY/2:f.deltaY&&0===f.deltaMode?-f.deltaY/tt:f.deltaY&&1===f.deltaMode?20*-f.deltaY:f.deltaY&&2===f.deltaMode?60*-f.deltaY:f.deltaX||f.deltaZ?0:f.wheelDelta?(f.wheelDeltaY||f.wheelDelta)/2:f.detail&&Math.abs(f.detail)<32765?20*-f.detail:f.detail?f.detail/-32765*60:0}function At(f,E){var D=E.relatedTarget;if(!D)return!0;try{for(;D&&D!==f;)D=D.parentNode}catch{return!1}return D!==f}var Yt={__proto__:null,on:Kn,off:wr,stopPropagation:Fo,disableScrollPropagation:Or,disableClickPropagation:os,preventDefault:_e,stop:z,getPropagationPath:I,getMousePosition:M,getWheelDelta:bt,isExternalTarget:At,addListener:Kn,removeListener:wr},kt=Ct.extend({run:function(f,E,D,j){this.stop(),this._el=f,this._inProgress=!0,this._duration=D||.25,this._easeOutPower=1/Math.max(j||.5,.2),this._startPos=Cs(f),this._offset=E.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(!0),this._complete())},_animate:function(){this._animId=ot(this._animate,this),this._step()},_step:function(f){var E=+new Date-this._startTime,D=1e3*this._duration;E<D?this._runFrame(this._easeOut(E/D),f):(this._runFrame(1),this._complete())},_runFrame:function(f,E){var D=this._startPos.add(this._offset.multiplyBy(f));E&&D._round(),Xn(this._el,D),this.fire("step")},_complete:function(){P(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(f){return 1-Math.pow(1-f,this._easeOutPower)}}),ae=Ct.extend({options:{crs:Tn,center:void 0,zoom:void 0,minZoom:void 0,maxZoom:void 0,layers:[],maxBounds:void 0,renderer:void 0,zoomAnimation:!0,zoomAnimationThreshold:4,fadeAnimation:!0,markerZoomAnimation:!0,transform3DLimit:8388608,zoomSnap:1,zoomDelta:1,trackResize:!0},initialize:function(f,E){E=it(this,E),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._sizeChanged=!0,this._initContainer(f),this._initLayout(),this._onResize=Q(this._onResize,this),this._initEvents(),E.maxBounds&&this.setMaxBounds(E.maxBounds),void 0!==E.zoom&&(this._zoom=this._limitZoom(E.zoom)),E.center&&void 0!==E.zoom&&this.setView(jt(E.center),E.zoom,{reset:!0}),this.callInitHooks(),this._zoomAnimated=gs&&Dn.any3d&&!Dn.mobileOpera&&this.options.zoomAnimation,this._zoomAnimated&&(this._createAnimProxy(),Kn(this._proxy,Ua,this._catchTransitionEnd,this)),this._addLayers(this.options.layers)},setView:function(f,E,D){return E=void 0===E?this._zoom:this._limitZoom(E),f=this._limitCenter(jt(f),E,this.options.maxBounds),D=D||{},this._stop(),this._loaded&&!D.reset&&!0!==D&&(void 0!==D.animate&&(D.zoom=V({animate:D.animate},D.zoom),D.pan=V({animate:D.animate,duration:D.duration},D.pan)),this._zoom!==E?this._tryAnimatedZoom&&this._tryAnimatedZoom(f,E,D.zoom):this._tryAnimatedPan(f,D.pan))?(clearTimeout(this._sizeTimer),this):(this._resetView(f,E,D.pan&&D.pan.noMoveStart),this)},setZoom:function(f,E){return this._loaded?this.setView(this.getCenter(),f,{zoom:E}):(this._zoom=f,this)},zoomIn:function(f,E){return this.setZoom(this._zoom+(f=f||(Dn.any3d?this.options.zoomDelta:1)),E)},zoomOut:function(f,E){return this.setZoom(this._zoom-(f=f||(Dn.any3d?this.options.zoomDelta:1)),E)},setZoomAround:function(f,E,D){var j=this.getZoomScale(E),mt=this.getSize().divideBy(2),ce=(f instanceof yt?f:this.latLngToContainerPoint(f)).subtract(mt).multiplyBy(1-1/j),ye=this.containerPointToLatLng(mt.add(ce));return this.setView(ye,E,{zoom:D})},_getBoundsCenterZoom:function(f,E){E=E||{},f=f.getBounds?f.getBounds():Bt(f);var D=xt(E.paddingTopLeft||E.padding||[0,0]),j=xt(E.paddingBottomRight||E.padding||[0,0]),mt=this.getBoundsZoom(f,!1,D.add(j));if((mt="number"==typeof E.maxZoom?Math.min(E.maxZoom,mt):mt)===1/0)return{center:f.getCenter(),zoom:mt};var Ft=j.subtract(D).divideBy(2),ce=this.project(f.getSouthWest(),mt),ye=this.project(f.getNorthEast(),mt);return{center:this.unproject(ce.add(ye).divideBy(2).add(Ft),mt),zoom:mt}},fitBounds:function(f,E){if(!(f=Bt(f)).isValid())throw new Error("Bounds are not valid.");var D=this._getBoundsCenterZoom(f,E);return this.setView(D.center,D.zoom,E)},fitWorld:function(f){return this.fitBounds([[-90,-180],[90,180]],f)},panTo:function(f,E){return this.setView(f,this._zoom,{pan:E})},panBy:function(f,E){if(E=E||{},!(f=xt(f).round()).x&&!f.y)return this.fire("moveend");if(!0!==E.animate&&!this.getSize().contains(f))return this._resetView(this.unproject(this.project(this.getCenter()).add(f)),this.getZoom()),this;if(this._panAnim||(this._panAnim=new kt,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),E.noMoveStart||this.fire("movestart"),!1!==E.animate){An(this._mapPane,"leaflet-pan-anim");var D=this._getMapPanePos().subtract(f).round();this._panAnim.run(this._mapPane,D,E.duration||.25,E.easeLinearity)}else this._rawPanBy(f),this.fire("move").fire("moveend");return this},flyTo:function(f,E,D){if(!1===(D=D||{}).animate||!Dn.any3d)return this.setView(f,E,D);this._stop();var j=this.project(this.getCenter()),mt=this.project(f),Ft=this.getSize(),ce=this._zoom;f=jt(f),E=void 0===E?ce:E;var ye=Math.max(Ft.x,Ft.y),Ve=ye*this.getZoomScale(ce,E),sn=mt.distanceTo(j)||1,wn=1.42,Pn=wn*wn;function Nr(Ns){var l=(Ve*Ve-ye*ye+(Ns?-1:1)*Pn*Pn*sn*sn)/(2*(Ns?Ve:ye)*Pn*sn),h=Math.sqrt(l*l+1)-l;return h<1e-9?-18:Math.log(h)}function yo(Ns){return(Math.exp(Ns)-Math.exp(-Ns))/2}function qi(Ns){return(Math.exp(Ns)+Math.exp(-Ns))/2}var Ho=Nr(0);function da(Ns){return ye*(qi(Ho)*function ro(Ns){return yo(Ns)/qi(Ns)}(Ho+wn*Ns)-yo(Ho))/Pn}var su=Date.now(),Rr=(Nr(1)-Ho)/wn,Il=D.duration?1e3*D.duration:1e3*Rr*.8;return this._moveStart(!0,D.noMoveStart),function qs(){var Ns=(Date.now()-su)/Il,ws=function cr(Ns){return 1-Math.pow(1-Ns,1.5)}(Ns)*Rr;Ns<=1?(this._flyToFrame=ot(qs,this),this._move(this.unproject(j.add(mt.subtract(j).multiplyBy(da(ws)/sn)),ce),this.getScaleZoom(ye/function ea(Ns){return ye*(qi(Ho)/qi(Ho+wn*Ns))}(ws),ce),{flyTo:!0})):this._move(f,E)._moveEnd(!0)}.call(this),this},flyToBounds:function(f,E){var D=this._getBoundsCenterZoom(f,E);return this.flyTo(D.center,D.zoom,E)},setMaxBounds:function(f){return f=Bt(f),this.listens("moveend",this._panInsideMaxBounds)&&this.off("moveend",this._panInsideMaxBounds),f.isValid()?(this.options.maxBounds=f,this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds)):(this.options.maxBounds=null,this)},setMinZoom:function(f){var E=this.options.minZoom;return this.options.minZoom=f,this._loaded&&E!==f&&(this.fire("zoomlevelschange"),this.getZoom()<this.options.minZoom)?this.setZoom(f):this},setMaxZoom:function(f){var E=this.options.maxZoom;return this.options.maxZoom=f,this._loaded&&E!==f&&(this.fire("zoomlevelschange"),this.getZoom()>this.options.maxZoom)?this.setZoom(f):this},panInsideBounds:function(f,E){this._enforcingBounds=!0;var D=this.getCenter(),j=this._limitCenter(D,this._zoom,Bt(f));return D.equals(j)||this.panTo(j,E),this._enforcingBounds=!1,this},panInside:function(f,E){var D=xt((E=E||{}).paddingTopLeft||E.padding||[0,0]),j=xt(E.paddingBottomRight||E.padding||[0,0]),mt=this.project(this.getCenter()),Ft=this.project(f),ce=this.getPixelBounds(),ye=It([ce.min.add(D),ce.max.subtract(j)]),Ve=ye.getSize();if(!ye.contains(Ft)){this._enforcingBounds=!0;var sn=Ft.subtract(ye.getCenter()),wn=ye.extend(Ft).getSize().subtract(Ve);mt.x+=sn.x<0?-wn.x:wn.x,mt.y+=sn.y<0?-wn.y:wn.y,this.panTo(this.unproject(mt),E),this._enforcingBounds=!1}return this},invalidateSize:function(f){if(!this._loaded)return this;f=V({animate:!1,pan:!0},!0===f?{animate:!0}:f);var E=this.getSize();this._sizeChanged=!0,this._lastCenter=null;var D=this.getSize(),j=E.divideBy(2).round(),mt=D.divideBy(2).round(),Ft=j.subtract(mt);return Ft.x||Ft.y?(f.animate&&f.pan?this.panBy(Ft):(f.pan&&this._rawPanBy(Ft),this.fire("move"),f.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(Q(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:E,newSize:D})):this},stop:function(){return this.setZoom(this._limitZoom(this._zoom)),this.options.zoomSnap||this.fire("viewreset"),this._stop()},locate:function(f){if(f=this._locateOptions=V({timeout:1e4,watch:!1},f),!("geolocation"in navigator))return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var E=Q(this._handleGeolocationResponse,this),D=Q(this._handleGeolocationError,this);return f.watch?this._locationWatchId=navigator.geolocation.watchPosition(E,D,f):navigator.geolocation.getCurrentPosition(E,D,f),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(f){if(this._container._leaflet_id){var E=f.code,D=f.message||(1===E?"permission denied":2===E?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:E,message:"Geolocation error: "+D+"."})}},_handleGeolocationResponse:function(f){if(this._container._leaflet_id){var j=new ee(f.coords.latitude,f.coords.longitude),mt=j.toBounds(2*f.coords.accuracy),Ft=this._locateOptions;if(Ft.setView){var ce=this.getBoundsZoom(mt);this.setView(j,Ft.maxZoom?Math.min(ce,Ft.maxZoom):ce)}var ye={latlng:j,bounds:mt,timestamp:f.timestamp};for(var Ve in f.coords)"number"==typeof f.coords[Ve]&&(ye[Ve]=f.coords[Ve]);this.fire("locationfound",ye)}},addHandler:function(f,E){if(!E)return this;var D=this[f]=new E(this);return this._handlers.push(D),this.options[f]&&D.enable(),this},remove:function(){if(this._initEvents(!0),this.options.maxBounds&&this.off("moveend",this._panInsideMaxBounds),this._containerId!==this._container._leaflet_id)throw new Error("Map container is being reused by another instance");try{delete this._container._leaflet_id,delete this._containerId}catch{this._container._leaflet_id=void 0,this._containerId=void 0}var f;for(f in void 0!==this._locationWatchId&&this.stopLocate(),this._stop(),pr(this._mapPane),this._clearControlPos&&this._clearControlPos(),this._resizeRequest&&(P(this._resizeRequest),this._resizeRequest=null),this._clearHandlers(),this._loaded&&this.fire("unload"),this._layers)this._layers[f].remove();for(f in this._panes)pr(this._panes[f]);return this._layers=[],this._panes=[],delete this._mapPane,delete this._renderer,this},createPane:function(f,E){var j=$r("div","leaflet-pane"+(f?" leaflet-"+f.replace("Pane","")+"-pane":""),E||this._mapPane);return f&&(this._panes[f]=j),j},getCenter:function(){return this._checkIfLoaded(),this._lastCenter&&!this._moved()?this._lastCenter.clone():this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var f=this.getPixelBounds();return new re(this.unproject(f.getBottomLeft()),this.unproject(f.getTopRight()))},getMinZoom:function(){return void 0===this.options.minZoom?this._layersMinZoom||0:this.options.minZoom},getMaxZoom:function(){return void 0===this.options.maxZoom?void 0===this._layersMaxZoom?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(f,E,D){f=Bt(f),D=xt(D||[0,0]);var j=this.getZoom()||0,mt=this.getMinZoom(),Ft=this.getMaxZoom(),ce=f.getNorthWest(),ye=f.getSouthEast(),Ve=this.getSize().subtract(D),sn=It(this.project(ye,j),this.project(ce,j)).getSize(),wn=Dn.any3d?this.options.zoomSnap:1,Pn=Ve.x/sn.x,Nr=Ve.y/sn.y,yo=E?Math.max(Pn,Nr):Math.min(Pn,Nr);return j=this.getScaleZoom(yo,j),wn&&(j=Math.round(j/(wn/100))*(wn/100),j=E?Math.ceil(j/wn)*wn:Math.floor(j/wn)*wn),Math.max(mt,Math.min(Ft,j))},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new yt(this._container.clientWidth||0,this._container.clientHeight||0),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(f,E){var D=this._getTopLeftPoint(f,E);return new Mt(D,D.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._pixelOrigin},getPixelWorldBounds:function(f){return this.options.crs.getProjectedBounds(void 0===f?this.getZoom():f)},getPane:function(f){return"string"==typeof f?this._panes[f]:f},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(f,E){var D=this.options.crs;return E=void 0===E?this._zoom:E,D.scale(f)/D.scale(E)},getScaleZoom:function(f,E){var D=this.options.crs,j=D.zoom(f*D.scale(E=void 0===E?this._zoom:E));return isNaN(j)?1/0:j},project:function(f,E){return E=void 0===E?this._zoom:E,this.options.crs.latLngToPoint(jt(f),E)},unproject:function(f,E){return E=void 0===E?this._zoom:E,this.options.crs.pointToLatLng(xt(f),E)},layerPointToLatLng:function(f){var E=xt(f).add(this.getPixelOrigin());return this.unproject(E)},latLngToLayerPoint:function(f){return this.project(jt(f))._round()._subtract(this.getPixelOrigin())},wrapLatLng:function(f){return this.options.crs.wrapLatLng(jt(f))},wrapLatLngBounds:function(f){return this.options.crs.wrapLatLngBounds(Bt(f))},distance:function(f,E){return this.options.crs.distance(jt(f),jt(E))},containerPointToLayerPoint:function(f){return xt(f).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(f){return xt(f).add(this._getMapPanePos())},containerPointToLatLng:function(f){var E=this.containerPointToLayerPoint(xt(f));return this.layerPointToLatLng(E)},latLngToContainerPoint:function(f){return this.layerPointToContainerPoint(this.latLngToLayerPoint(jt(f)))},mouseEventToContainerPoint:function(f){return M(f,this._container)},mouseEventToLayerPoint:function(f){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(f))},mouseEventToLatLng:function(f){return this.layerPointToLatLng(this.mouseEventToLayerPoint(f))},_initContainer:function(f){var E=this._container=bu(f);if(!E)throw new Error("Map container not found.");if(E._leaflet_id)throw new Error("Map container is already initialized.");Kn(E,"scroll",this._onScroll,this),this._containerId=R(E)},_initLayout:function(){var f=this._container;this._fadeAnimated=this.options.fadeAnimation&&Dn.any3d,An(f,"leaflet-container"+(Dn.touch?" leaflet-touch":"")+(Dn.retina?" leaflet-retina":"")+(Dn.ielt9?" leaflet-oldie":"")+(Dn.safari?" leaflet-safari":"")+(this._fadeAnimated?" leaflet-fade-anim":""));var E=Oa(f,"position");"absolute"!==E&&"relative"!==E&&"fixed"!==E&&"sticky"!==E&&(f.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var f=this._panes={};this._paneRenderers={},this._mapPane=this.createPane("mapPane",this._container),Xn(this._mapPane,new yt(0,0)),this.createPane("tilePane"),this.createPane("overlayPane"),this.createPane("shadowPane"),this.createPane("markerPane"),this.createPane("tooltipPane"),this.createPane("popupPane"),this.options.markerZoomAnimation||(An(f.markerPane,"leaflet-zoom-hide"),An(f.shadowPane,"leaflet-zoom-hide"))},_resetView:function(f,E,D){Xn(this._mapPane,new yt(0,0));var j=!this._loaded;this._loaded=!0,E=this._limitZoom(E),this.fire("viewprereset");var mt=this._zoom!==E;this._moveStart(mt,D)._move(f,E)._moveEnd(mt),this.fire("viewreset"),j&&this.fire("load")},_moveStart:function(f,E){return f&&this.fire("zoomstart"),E||this.fire("movestart"),this},_move:function(f,E,D,j){void 0===E&&(E=this._zoom);var mt=this._zoom!==E;return this._zoom=E,this._lastCenter=f,this._pixelOrigin=this._getNewPixelOrigin(f),j?D&&D.pinch&&this.fire("zoom",D):((mt||D&&D.pinch)&&this.fire("zoom",D),this.fire("move",D)),this},_moveEnd:function(f){return f&&this.fire("zoomend"),this.fire("moveend")},_stop:function(){return P(this._flyToFrame),this._panAnim&&this._panAnim.stop(),this},_rawPanBy:function(f){Xn(this._mapPane,this._getMapPanePos().subtract(f))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_panInsideMaxBounds:function(){this._enforcingBounds||this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(f){this._targets={},this._targets[R(this._container)]=this;var E=f?wr:Kn;E(this._container,"click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup",this._handleDOMEvent,this),this.options.trackResize&&E(window,"resize",this._onResize,this),Dn.any3d&&this.options.transform3DLimit&&(f?this.off:this.on).call(this,"moveend",this._onMoveEnd)},_onResize:function(){P(this._resizeRequest),this._resizeRequest=ot(function(){this.invalidateSize({debounceMoveend:!0})},this)},_onScroll:function(){this._container.scrollTop=0,this._container.scrollLeft=0},_onMoveEnd:function(){var f=this._getMapPanePos();Math.max(Math.abs(f.x),Math.abs(f.y))>=this.options.transform3DLimit&&this._resetView(this.getCenter(),this.getZoom())},_findEventTargets:function(f,E){for(var j,D=[],mt="mouseout"===E||"mouseover"===E,Ft=f.target||f.srcElement,ce=!1;Ft;){if((j=this._targets[R(Ft)])&&("click"===E||"preclick"===E)&&this._draggableMoved(j)){ce=!0;break}if(j&&j.listens(E,!0)&&(mt&&!At(Ft,f)||(D.push(j),mt))||Ft===this._container)break;Ft=Ft.parentNode}return!D.length&&!ce&&!mt&&this.listens(E,!0)&&(D=[this]),D},_isClickDisabled:function(f){for(;f&&f!==this._container;){if(f._leaflet_disable_click)return!0;f=f.parentNode}},_handleDOMEvent:function(f){var E=f.target||f.srcElement;if(!(!this._loaded||E._leaflet_disable_events||"click"===f.type&&this._isClickDisabled(E))){var D=f.type;"mousedown"===D&&Ur(E),this._fireDOMEvent(f,D)}},_mouseEvents:["click","dblclick","mouseover","mouseout","contextmenu"],_fireDOMEvent:function(f,E,D){if("click"===f.type){var j=V({},f);j.type="preclick",this._fireDOMEvent(j,j.type,D)}var mt=this._findEventTargets(f,E);if(D){for(var Ft=[],ce=0;ce<D.length;ce++)D[ce].listens(E,!0)&&Ft.push(D[ce]);mt=Ft.concat(mt)}if(mt.length){"contextmenu"===E&&_e(f);var ye=mt[0],Ve={originalEvent:f};if("keypress"!==f.type&&"keydown"!==f.type&&"keyup"!==f.type){var sn=ye.getLatLng&&(!ye._radius||ye._radius<=10);Ve.containerPoint=sn?this.latLngToContainerPoint(ye.getLatLng()):this.mouseEventToContainerPoint(f),Ve.layerPoint=this.containerPointToLayerPoint(Ve.containerPoint),Ve.latlng=sn?ye.getLatLng():this.layerPointToLatLng(Ve.layerPoint)}for(ce=0;ce<mt.length;ce++)if(mt[ce].fire(E,Ve,!0),Ve.originalEvent._stopped||!1===mt[ce].options.bubblingMouseEvents&&-1!==dt(this._mouseEvents,E))return}},_draggableMoved:function(f){return(f=f.dragging&&f.dragging.enabled()?f:this).dragging&&f.dragging.moved()||this.boxZoom&&this.boxZoom.moved()},_clearHandlers:function(){for(var f=0,E=this._handlers.length;f<E;f++)this._handlers[f].disable()},whenReady:function(f,E){return this._loaded?f.call(E||this,{target:this}):this.on("load",f,E),this},_getMapPanePos:function(){return Cs(this._mapPane)||new yt(0,0)},_moved:function(){var f=this._getMapPanePos();return f&&!f.equals([0,0])},_getTopLeftPoint:function(f,E){return(f&&void 0!==E?this._getNewPixelOrigin(f,E):this.getPixelOrigin()).subtract(this._getMapPanePos())},_getNewPixelOrigin:function(f,E){var D=this.getSize()._divideBy(2);return this.project(f,E)._subtract(D)._add(this._getMapPanePos())._round()},_latLngToNewLayerPoint:function(f,E,D){var j=this._getNewPixelOrigin(D,E);return this.project(f,E)._subtract(j)},_latLngBoundsToNewLayerBounds:function(f,E,D){var j=this._getNewPixelOrigin(D,E);return It([this.project(f.getSouthWest(),E)._subtract(j),this.project(f.getNorthWest(),E)._subtract(j),this.project(f.getSouthEast(),E)._subtract(j),this.project(f.getNorthEast(),E)._subtract(j)])},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(f){return this.latLngToLayerPoint(f).subtract(this._getCenterLayerPoint())},_limitCenter:function(f,E,D){if(!D)return f;var j=this.project(f,E),mt=this.getSize().divideBy(2),Ft=new Mt(j.subtract(mt),j.add(mt)),ce=this._getBoundsOffset(Ft,D,E);return Math.abs(ce.x)<=1&&Math.abs(ce.y)<=1?f:this.unproject(j.add(ce),E)},_limitOffset:function(f,E){if(!E)return f;var D=this.getPixelBounds(),j=new Mt(D.min.add(f),D.max.add(f));return f.add(this._getBoundsOffset(j,E))},_getBoundsOffset:function(f,E,D){var j=It(this.project(E.getNorthEast(),D),this.project(E.getSouthWest(),D)),mt=j.min.subtract(f.min),Ft=j.max.subtract(f.max);return new yt(this._rebound(mt.x,-Ft.x),this._rebound(mt.y,-Ft.y))},_rebound:function(f,E){return f+E>0?Math.round(f-E)/2:Math.max(0,Math.ceil(f))-Math.max(0,Math.floor(E))},_limitZoom:function(f){var E=this.getMinZoom(),D=this.getMaxZoom(),j=Dn.any3d?this.options.zoomSnap:1;return j&&(f=Math.round(f/j)*j),Math.max(E,Math.min(D,f))},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){Gr(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(f,E){var D=this._getCenterOffset(f)._trunc();return!(!0!==(E&&E.animate)&&!this.getSize().contains(D)||(this.panBy(D,E),0))},_createAnimProxy:function(){var f=this._proxy=$r("div","leaflet-proxy leaflet-zoom-animated");this._panes.mapPane.appendChild(f),this.on("zoomanim",function(E){var D=Co,j=this._proxy.style[D];ga(this._proxy,this.project(E.center,E.zoom),this.getZoomScale(E.zoom,1)),j===this._proxy.style[D]&&this._animatingZoom&&this._onZoomTransitionEnd()},this),this.on("load moveend",this._animMoveEnd,this),this._on("unload",this._destroyAnimProxy,this)},_destroyAnimProxy:function(){pr(this._proxy),this.off("load moveend",this._animMoveEnd,this),delete this._proxy},_animMoveEnd:function(){var f=this.getCenter(),E=this.getZoom();ga(this._proxy,this.project(f,E),this.getZoomScale(E,1))},_catchTransitionEnd:function(f){this._animatingZoom&&f.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(f,E,D){if(this._animatingZoom)return!0;if(D=D||{},!this._zoomAnimated||!1===D.animate||this._nothingToAnimate()||Math.abs(E-this._zoom)>this.options.zoomAnimationThreshold)return!1;var j=this.getZoomScale(E),mt=this._getCenterOffset(f)._divideBy(1-1/j);return!(!0!==D.animate&&!this.getSize().contains(mt)||(ot(function(){this._moveStart(!0,D.noMoveStart||!1)._animateZoom(f,E,!0)},this),0))},_animateZoom:function(f,E,D,j){this._mapPane&&(D&&(this._animatingZoom=!0,this._animateToCenter=f,this._animateToZoom=E,An(this._mapPane,"leaflet-zoom-anim")),this.fire("zoomanim",{center:f,zoom:E,noUpdate:j}),this._tempFireZoomEvent||(this._tempFireZoomEvent=this._zoom!==this._animateToZoom),this._move(this._animateToCenter,this._animateToZoom,void 0,!0),setTimeout(Q(this._onZoomTransitionEnd,this),250))},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._mapPane&&Gr(this._mapPane,"leaflet-zoom-anim"),this._animatingZoom=!1,this._move(this._animateToCenter,this._animateToZoom,void 0,!0),this._tempFireZoomEvent&&this.fire("zoom"),delete this._tempFireZoomEvent,this.fire("move"),this._moveEnd(!0))}});var Ye=nt.extend({options:{position:"topright"},initialize:function(f){it(this,f)},getPosition:function(){return this.options.position},setPosition:function(f){var E=this._map;return E&&E.removeControl(this),this.options.position=f,E&&E.addControl(this),this},getContainer:function(){return this._container},addTo:function(f){this.remove(),this._map=f;var E=this._container=this.onAdd(f),D=this.getPosition(),j=f._controlCorners[D];return An(E,"leaflet-control"),-1!==D.indexOf("bottom")?j.insertBefore(E,j.firstChild):j.appendChild(E),this._map.on("unload",this.remove,this),this},remove:function(){return this._map?(pr(this._container),this.onRemove&&this.onRemove(this._map),this._map.off("unload",this.remove,this),this._map=null,this):this},_refocusOnMap:function(f){this._map&&f&&f.screenX>0&&f.screenY>0&&this._map.getContainer().focus()}}),$e=function(f){return new Ye(f)};ae.include({addControl:function(f){return f.addTo(this),this},removeControl:function(f){return f.remove(),this},_initControlPos:function(){var f=this._controlCorners={},E="leaflet-",D=this._controlContainer=$r("div",E+"control-container",this._container);function j(mt,Ft){f[mt+Ft]=$r("div",E+mt+" "+E+Ft,D)}j("top","left"),j("top","right"),j("bottom","left"),j("bottom","right")},_clearControlPos:function(){for(var f in this._controlCorners)pr(this._controlCorners[f]);pr(this._controlContainer),delete this._controlCorners,delete this._controlContainer}});var Cn=Ye.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0,hideSingleBase:!1,sortLayers:!1,sortFunction:function(f,E,D,j){return D<j?-1:j<D?1:0}},initialize:function(f,E,D){for(var j in it(this,D),this._layerControlInputs=[],this._layers=[],this._lastZIndex=0,this._handlingClick=!1,this._preventClick=!1,f)this._addLayer(f[j],j);for(j in E)this._addLayer(E[j],j,!0)},onAdd:function(f){this._initLayout(),this._update(),this._map=f,f.on("zoomend",this._checkDisabledLayers,this);for(var E=0;E<this._layers.length;E++)this._layers[E].layer.on("add remove",this._onLayerChange,this);return this._container},addTo:function(f){return Ye.prototype.addTo.call(this,f),this._expandIfNotCollapsed()},onRemove:function(){this._map.off("zoomend",this._checkDisabledLayers,this);for(var f=0;f<this._layers.length;f++)this._layers[f].layer.off("add remove",this._onLayerChange,this)},addBaseLayer:function(f,E){return this._addLayer(f,E),this._map?this._update():this},addOverlay:function(f,E){return this._addLayer(f,E,!0),this._map?this._update():this},removeLayer:function(f){f.off("add remove",this._onLayerChange,this);var E=this._getLayer(R(f));return E&&this._layers.splice(this._layers.indexOf(E),1),this._map?this._update():this},expand:function(){An(this._container,"leaflet-control-layers-expanded"),this._section.style.height=null;var f=this._map.getSize().y-(this._container.offsetTop+50);return f<this._section.clientHeight?(An(this._section,"leaflet-control-layers-scrollbar"),this._section.style.height=f+"px"):Gr(this._section,"leaflet-control-layers-scrollbar"),this._checkDisabledLayers(),this},collapse:function(){return Gr(this._container,"leaflet-control-layers-expanded"),this},_initLayout:function(){var f="leaflet-control-layers",E=this._container=$r("div",f),D=this.options.collapsed;E.setAttribute("aria-haspopup",!0),os(E),Or(E);var j=this._section=$r("section",f+"-list");D&&(this._map.on("click",this.collapse,this),Kn(E,{mouseenter:this._expandSafely,mouseleave:this.collapse},this));var mt=this._layersLink=$r("a",f+"-toggle",E);mt.href="#",mt.title="Layers",mt.setAttribute("role","button"),Kn(mt,{keydown:function(Ft){13===Ft.keyCode&&this._expandSafely()},click:function(Ft){_e(Ft),this._expandSafely()}},this),D||this.expand(),this._baseLayersList=$r("div",f+"-base",j),this._separator=$r("div",f+"-separator",j),this._overlaysList=$r("div",f+"-overlays",j),E.appendChild(j)},_getLayer:function(f){for(var E=0;E<this._layers.length;E++)if(this._layers[E]&&R(this._layers[E].layer)===f)return this._layers[E]},_addLayer:function(f,E,D){this._map&&f.on("add remove",this._onLayerChange,this),this._layers.push({layer:f,name:E,overlay:D}),this.options.sortLayers&&this._layers.sort(Q(function(j,mt){return this.options.sortFunction(j.layer,mt.layer,j.name,mt.name)},this)),this.options.autoZIndex&&f.setZIndex&&(this._lastZIndex++,f.setZIndex(this._lastZIndex)),this._expandIfNotCollapsed()},_update:function(){if(!this._container)return this;du(this._baseLayersList),du(this._overlaysList),this._layerControlInputs=[];var f,E,D,j,mt=0;for(D=0;D<this._layers.length;D++)this._addItem(j=this._layers[D]),E=E||j.overlay,f=f||!j.overlay,mt+=j.overlay?0:1;return this.options.hideSingleBase&&(this._baseLayersList.style.display=(f=f&&mt>1)?"":"none"),this._separator.style.display=E&&f?"":"none",this},_onLayerChange:function(f){this._handlingClick||this._update();var E=this._getLayer(R(f.target)),D=E.overlay?"add"===f.type?"overlayadd":"overlayremove":"add"===f.type?"baselayerchange":null;D&&this._map.fire(D,E)},_createRadioElement:function(f,E){var D='<input type="radio" class="leaflet-control-layers-selector" name="'+f+'"'+(E?' checked="checked"':"")+"/>",j=document.createElement("div");return j.innerHTML=D,j.firstChild},_addItem:function(f){var j,E=document.createElement("label"),D=this._map.hasLayer(f.layer);f.overlay?((j=document.createElement("input")).type="checkbox",j.className="leaflet-control-layers-selector",j.defaultChecked=D):j=this._createRadioElement("leaflet-base-layers_"+R(this),D),this._layerControlInputs.push(j),j.layerId=R(f.layer),Kn(j,"click",this._onInputClick,this);var mt=document.createElement("span");mt.innerHTML=" "+f.name;var Ft=document.createElement("span");return E.appendChild(Ft),Ft.appendChild(j),Ft.appendChild(mt),(f.overlay?this._overlaysList:this._baseLayersList).appendChild(E),this._checkDisabledLayers(),E},_onInputClick:function(){if(!this._preventClick){var E,D,f=this._layerControlInputs,j=[],mt=[];this._handlingClick=!0;for(var Ft=f.length-1;Ft>=0;Ft--)D=this._getLayer((E=f[Ft]).layerId).layer,E.checked?j.push(D):E.checked||mt.push(D);for(Ft=0;Ft<mt.length;Ft++)this._map.hasLayer(mt[Ft])&&this._map.removeLayer(mt[Ft]);for(Ft=0;Ft<j.length;Ft++)this._map.hasLayer(j[Ft])||this._map.addLayer(j[Ft]);this._handlingClick=!1,this._refocusOnMap()}},_checkDisabledLayers:function(){for(var E,D,f=this._layerControlInputs,j=this._map.getZoom(),mt=f.length-1;mt>=0;mt--)D=this._getLayer((E=f[mt]).layerId).layer,E.disabled=void 0!==D.options.minZoom&&j<D.options.minZoom||void 0!==D.options.maxZoom&&j>D.options.maxZoom},_expandIfNotCollapsed:function(){return this._map&&!this.options.collapsed&&this.expand(),this},_expandSafely:function(){var f=this._section;this._preventClick=!0,Kn(f,"click",_e),this.expand();var E=this;setTimeout(function(){wr(f,"click",_e),E._preventClick=!1})}}),Vn=Ye.extend({options:{position:"topleft",zoomInText:'<span aria-hidden="true">+</span>',zoomInTitle:"Zoom in",zoomOutText:'<span aria-hidden="true">&#x2212;</span>',zoomOutTitle:"Zoom out"},onAdd:function(f){var E="leaflet-control-zoom",D=$r("div",E+" leaflet-bar"),j=this.options;return this._zoomInButton=this._createButton(j.zoomInText,j.zoomInTitle,E+"-in",D,this._zoomIn),this._zoomOutButton=this._createButton(j.zoomOutText,j.zoomOutTitle,E+"-out",D,this._zoomOut),this._updateDisabled(),f.on("zoomend zoomlevelschange",this._updateDisabled,this),D},onRemove:function(f){f.off("zoomend zoomlevelschange",this._updateDisabled,this)},disable:function(){return this._disabled=!0,this._updateDisabled(),this},enable:function(){return this._disabled=!1,this._updateDisabled(),this},_zoomIn:function(f){!this._disabled&&this._map._zoom<this._map.getMaxZoom()&&this._map.zoomIn(this._map.options.zoomDelta*(f.shiftKey?3:1))},_zoomOut:function(f){!this._disabled&&this._map._zoom>this._map.getMinZoom()&&this._map.zoomOut(this._map.options.zoomDelta*(f.shiftKey?3:1))},_createButton:function(f,E,D,j,mt){var Ft=$r("a",D,j);return Ft.innerHTML=f,Ft.href="#",Ft.title=E,Ft.setAttribute("role","button"),Ft.setAttribute("aria-label",E),os(Ft),Kn(Ft,"click",z),Kn(Ft,"click",mt,this),Kn(Ft,"click",this._refocusOnMap,this),Ft},_updateDisabled:function(){var f=this._map,E="leaflet-disabled";Gr(this._zoomInButton,E),Gr(this._zoomOutButton,E),this._zoomInButton.setAttribute("aria-disabled","false"),this._zoomOutButton.setAttribute("aria-disabled","false"),(this._disabled||f._zoom===f.getMinZoom())&&(An(this._zoomOutButton,E),this._zoomOutButton.setAttribute("aria-disabled","true")),(this._disabled||f._zoom===f.getMaxZoom())&&(An(this._zoomInButton,E),this._zoomInButton.setAttribute("aria-disabled","true"))}});ae.mergeOptions({zoomControl:!0}),ae.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new Vn,this.addControl(this.zoomControl))});var bn=Ye.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0},onAdd:function(f){var E="leaflet-control-scale",D=$r("div",E),j=this.options;return this._addScales(j,E+"-line",D),f.on(j.updateWhenIdle?"moveend":"move",this._update,this),f.whenReady(this._update,this),D},onRemove:function(f){f.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(f,E,D){f.metric&&(this._mScale=$r("div",E,D)),f.imperial&&(this._iScale=$r("div",E,D))},_update:function(){var f=this._map,E=f.getSize().y/2,D=f.distance(f.containerPointToLatLng([0,E]),f.containerPointToLatLng([this.options.maxWidth,E]));this._updateScales(D)},_updateScales:function(f){this.options.metric&&f&&this._updateMetric(f),this.options.imperial&&f&&this._updateImperial(f)},_updateMetric:function(f){var E=this._getRoundNum(f);this._updateScale(this._mScale,E<1e3?E+" m":E/1e3+" km",E/f)},_updateImperial:function(f){var D,j,mt,E=3.2808399*f;E>5280?(j=this._getRoundNum(D=E/5280),this._updateScale(this._iScale,j+" mi",j/D)):(mt=this._getRoundNum(E),this._updateScale(this._iScale,mt+" ft",mt/E))},_updateScale:function(f,E,D){f.style.width=Math.round(this.options.maxWidth*D)+"px",f.innerHTML=E},_getRoundNum:function(f){var E=Math.pow(10,(Math.floor(f)+"").length-1),D=f/E;return E*(D>=10?10:D>=5?5:D>=3?3:D>=2?2:1)}}),Zs=Ye.extend({options:{position:"bottomright",prefix:'<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">'+(Dn.inlineSvg?'<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg> ':"")+"Leaflet</a>"},initialize:function(f){it(this,f),this._attributions={}},onAdd:function(f){for(var E in f.attributionControl=this,this._container=$r("div","leaflet-control-attribution"),os(this._container),f._layers)f._layers[E].getAttribution&&this.addAttribution(f._layers[E].getAttribution());return this._update(),f.on("layeradd",this._addAttribution,this),this._container},onRemove:function(f){f.off("layeradd",this._addAttribution,this)},_addAttribution:function(f){f.layer.getAttribution&&(this.addAttribution(f.layer.getAttribution()),f.layer.once("remove",function(){this.removeAttribution(f.layer.getAttribution())},this))},setPrefix:function(f){return this.options.prefix=f,this._update(),this},addAttribution:function(f){return f?(this._attributions[f]||(this._attributions[f]=0),this._attributions[f]++,this._update(),this):this},removeAttribution:function(f){return f?(this._attributions[f]&&(this._attributions[f]--,this._update()),this):this},_update:function(){if(this._map){var f=[];for(var E in this._attributions)this._attributions[E]&&f.push(E);var D=[];this.options.prefix&&D.push(this.options.prefix),f.length&&D.push(f.join(", ")),this._container.innerHTML=D.join(' <span aria-hidden="true">|</span> ')}}});ae.mergeOptions({attributionControl:!0}),ae.addInitHook(function(){this.options.attributionControl&&(new Zs).addTo(this)});Ye.Layers=Cn,Ye.Zoom=Vn,Ye.Scale=bn,Ye.Attribution=Zs,$e.layers=function(f,E,D){return new Cn(f,E,D)},$e.zoom=function(f){return new Vn(f)},$e.scale=function(f){return new bn(f)},$e.attribution=function(f){return new Zs(f)};var tn=nt.extend({initialize:function(f){this._map=f},enable:function(){return this._enabled||(this._enabled=!0,this.addHooks()),this},disable:function(){return this._enabled?(this._enabled=!1,this.removeHooks(),this):this},enabled:function(){return!!this._enabled}});tn.addTo=function(f,E){return f.addHandler(E,this),this};var Iu={Events:O},xr=Dn.touch?"touchstart mousedown":"mousedown",Qi=Ct.extend({options:{clickTolerance:3},initialize:function(f,E,D,j){it(this,j),this._element=f,this._dragStartTarget=E||f,this._preventOutline=D},enable:function(){this._enabled||(Kn(this._dragStartTarget,xr,this._onDown,this),this._enabled=!0)},disable:function(){this._enabled&&(Qi._dragging===this&&this.finishDrag(!0),wr(this._dragStartTarget,xr,this._onDown,this),this._enabled=!1,this._moved=!1)},_onDown:function(f){if(this._enabled&&(this._moved=!1,!ys(this._element,"leaflet-zoom-anim"))){if(f.touches&&1!==f.touches.length)return void(Qi._dragging===this&&this.finishDrag());if(!(Qi._dragging||f.shiftKey||1!==f.which&&1!==f.button&&!f.touches||(Qi._dragging=this,this._preventOutline&&Ur(this._element),Fn(),Yi(),this._moving))){this.fire("down");var E=f.touches?f.touches[0]:f,D=Kr(this._element);this._startPoint=new yt(E.clientX,E.clientY),this._startPos=Cs(this._element),this._parentScale=mr(D);var j="mousedown"===f.type;Kn(document,j?"mousemove":"touchmove",this._onMove,this),Kn(document,j?"mouseup":"touchend touchcancel",this._onUp,this)}}},_onMove:function(f){if(this._enabled){if(f.touches&&f.touches.length>1)return void(this._moved=!0);var E=f.touches&&1===f.touches.length?f.touches[0]:f,D=new yt(E.clientX,E.clientY)._subtract(this._startPoint);!D.x&&!D.y||Math.abs(D.x)+Math.abs(D.y)<this.options.clickTolerance||(D.x/=this._parentScale.x,D.y/=this._parentScale.y,_e(f),this._moved||(this.fire("dragstart"),this._moved=!0,An(document.body,"leaflet-dragging"),this._lastTarget=f.target||f.srcElement,window.SVGElementInstance&&this._lastTarget instanceof window.SVGElementInstance&&(this._lastTarget=this._lastTarget.correspondingUseElement),An(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(D),this._moving=!0,this._lastEvent=f,this._updatePosition())}},_updatePosition:function(){var f={originalEvent:this._lastEvent};this.fire("predrag",f),Xn(this._element,this._newPos),this.fire("drag",f)},_onUp:function(){this._enabled&&this.finishDrag()},finishDrag:function(f){Gr(document.body,"leaflet-dragging"),this._lastTarget&&(Gr(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null),wr(document,"mousemove touchmove",this._onMove,this),wr(document,"mouseup touchend touchcancel",this._onUp,this),Ss(),Ra();var E=this._moved&&this._moving;this._moving=!1,Qi._dragging=!1,E&&this.fire("dragend",{noInertia:f,distance:this._newPos.distanceTo(this._startPos)})}});function fo(f,E,D){var j,Ft,ce,ye,Ve,sn,wn,Pn,Nr,mt=[1,4,2,8];for(Ft=0,wn=f.length;Ft<wn;Ft++)f[Ft]._code=Hr(f[Ft],E);for(ye=0;ye<4;ye++){for(Pn=mt[ye],j=[],Ft=0,ce=(wn=f.length)-1;Ft<wn;ce=Ft++)sn=f[ce],(Ve=f[Ft])._code&Pn?sn._code&Pn||((Nr=pu(sn,Ve,Pn,E,D))._code=Hr(Nr,E),j.push(Nr)):(sn._code&Pn&&((Nr=pu(sn,Ve,Pn,E,D))._code=Hr(Nr,E),j.push(Nr)),j.push(Ve));f=j}return f}function vs(f,E){var D,j,mt,Ft,ce,ye,Ve,sn;if(!f||0===f.length)throw new Error("latlngs not passed");Bo(f)||(console.warn("latlngs are not flat! Only the first ring will be used"),f=f[0]);var Pn=jt([0,0]),Nr=Bt(f);Nr.getNorthWest().distanceTo(Nr.getSouthWest())*Nr.getNorthEast().distanceTo(Nr.getNorthWest())<1700&&(Pn=Lu(f));var qi=f.length,ro=[];for(D=0;D<qi;D++){var Ho=jt(f[D]);ro.push(E.project(jt([Ho.lat-Pn.lat,Ho.lng-Pn.lng])))}for(ye=Ve=sn=0,D=0,j=qi-1;D<qi;j=D++)Ve+=((mt=ro[D]).x+(Ft=ro[j]).x)*(ce=mt.y*Ft.x-Ft.y*mt.x),sn+=(mt.y+Ft.y)*ce,ye+=3*ce;var ea=E.unproject(xt(0===ye?ro[0]:[Ve/ye,sn/ye]));return jt([ea.lat+Pn.lat,ea.lng+Pn.lng])}function Lu(f){for(var E=0,D=0,j=0,mt=0;mt<f.length;mt++){var Ft=jt(f[mt]);E+=Ft.lat,D+=Ft.lng,j++}return jt([E/j,D/j])}var Gl,Oc={__proto__:null,clipPolygon:fo,polygonCenter:vs,centroid:Lu};function as(f,E){if(!E||!f.length)return f.slice();var D=E*E;return function In(f,E){var D=f.length,mt=new(typeof Uint8Array!=void 0+""?Uint8Array:Array)(D);mt[0]=mt[D-1]=1,fu(f,mt,E,0,D-1);var Ft,ce=[];for(Ft=0;Ft<D;Ft++)mt[Ft]&&ce.push(f[Ft]);return ce}(f=function $o(f,E){for(var D=[f[0]],j=1,mt=0,Ft=f.length;j<Ft;j++)Qu(f[j],f[mt])>E&&(D.push(f[j]),mt=j);return mt<Ft-1&&D.push(f[Ft-1]),D}(f,D),D)}function Zr(f,E,D){return Math.sqrt(he(f,E,D,!0))}function fu(f,E,D,j,mt){var ce,ye,Ve,Ft=0;for(ye=j+1;ye<=mt-1;ye++)(Ve=he(f[ye],f[j],f[mt],!0))>Ft&&(ce=ye,Ft=Ve);Ft>D&&(E[ce]=1,fu(f,E,D,j,ce),fu(f,E,D,ce,mt))}function Ir(f,E,D,j,mt){var ye,Ve,sn,Ft=j?Gl:Hr(f,D),ce=Hr(E,D);for(Gl=ce;;){if(!(Ft|ce))return[f,E];if(Ft&ce)return!1;sn=Hr(Ve=pu(f,E,ye=Ft||ce,D,mt),D),ye===Ft?(f=Ve,Ft=sn):(E=Ve,ce=sn)}}function pu(f,E,D,j,mt){var sn,wn,Ft=E.x-f.x,ce=E.y-f.y,ye=j.min,Ve=j.max;return 8&D?(sn=f.x+Ft*(Ve.y-f.y)/ce,wn=Ve.y):4&D?(sn=f.x+Ft*(ye.y-f.y)/ce,wn=ye.y):2&D?(sn=Ve.x,wn=f.y+ce*(Ve.x-f.x)/Ft):1&D&&(sn=ye.x,wn=f.y+ce*(ye.x-f.x)/Ft),new yt(sn,wn,mt)}function Hr(f,E){var D=0;return f.x<E.min.x?D|=1:f.x>E.max.x&&(D|=2),f.y<E.min.y?D|=4:f.y>E.max.y&&(D|=8),D}function Qu(f,E){var D=E.x-f.x,j=E.y-f.y;return D*D+j*j}function he(f,E,D,j){var sn,mt=E.x,Ft=E.y,ce=D.x-mt,ye=D.y-Ft,Ve=ce*ce+ye*ye;return Ve>0&&((sn=((f.x-mt)*ce+(f.y-Ft)*ye)/Ve)>1?(mt=D.x,Ft=D.y):sn>0&&(mt+=ce*sn,Ft+=ye*sn)),ce=f.x-mt,ye=f.y-Ft,j?ce*ce+ye*ye:new yt(mt,Ft)}function Bo(f){return!et(f[0])||"object"!=typeof f[0][0]&&typeof f[0][0]<"u"}function Hl(f){return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."),Bo(f)}function ku(f,E){var D,j,mt,Ft,ce,ye,Ve,sn;if(!f||0===f.length)throw new Error("latlngs not passed");Bo(f)||(console.warn("latlngs are not flat! Only the first ring will be used"),f=f[0]);var wn=jt([0,0]),Pn=Bt(f);Pn.getNorthWest().distanceTo(Pn.getSouthWest())*Pn.getNorthEast().distanceTo(Pn.getNorthWest())<1700&&(wn=Lu(f));var yo=f.length,qi=[];for(D=0;D<yo;D++){var ro=jt(f[D]);qi.push(E.project(jt([ro.lat-wn.lat,ro.lng-wn.lng])))}for(D=0,j=0;D<yo-1;D++)j+=qi[D].distanceTo(qi[D+1])/2;if(0===j)sn=qi[0];else for(D=0,Ft=0;D<yo-1;D++)if((Ft+=mt=(ce=qi[D]).distanceTo(ye=qi[D+1]))>j){sn=[ye.x-(Ve=(Ft-j)/mt)*(ye.x-ce.x),ye.y-Ve*(ye.y-ce.y)];break}var Ho=E.unproject(xt(sn));return jt([Ho.lat+wn.lat,Ho.lng+wn.lng])}var Br={__proto__:null,simplify:as,pointToSegmentDistance:Zr,closestPointOnSegment:function eu(f,E,D){return he(f,E,D)},clipSegment:Ir,_getEdgeIntersection:pu,_getBitCode:Hr,_sqClosestPointOnSegment:he,isFlat:Bo,_flat:Hl,polylineCenter:ku},es={project:function(f){return new yt(f.lng,f.lat)},unproject:function(f){return new ee(f.y,f.x)},bounds:new Mt([-180,-90],[180,90])},nu={R:6378137,R_MINOR:6356752.314245179,bounds:new Mt([-20037508.34279,-15496570.73972],[20037508.34279,18764656.23138]),project:function(f){var E=Math.PI/180,D=this.R,j=f.lat*E,mt=this.R_MINOR/D,Ft=Math.sqrt(1-mt*mt),ce=Ft*Math.sin(j),ye=Math.tan(Math.PI/4-j/2)/Math.pow((1-ce)/(1+ce),Ft/2);return j=-D*Math.log(Math.max(ye,1e-10)),new yt(f.lng*E*D,j)},unproject:function(f){for(var sn,E=180/Math.PI,D=this.R,j=this.R_MINOR/D,mt=Math.sqrt(1-j*j),Ft=Math.exp(-f.y/D),ce=Math.PI/2-2*Math.atan(Ft),ye=0,Ve=.1;ye<15&&Math.abs(Ve)>1e-7;ye++)sn=mt*Math.sin(ce),sn=Math.pow((1-sn)/(1+sn),mt/2),ce+=Ve=Math.PI/2-2*Math.atan(Ft*sn)-ce;return new ee(ce*E,f.x*E/D)}},ru={__proto__:null,LonLat:es,Mercator:nu,SphericalMercator:Xe},us=V({},we,{code:"EPSG:3395",projection:nu,transformation:function(){var f=.5/(Math.PI*nu.R);return De(f,.5,-f,.5)}()}),Fs=V({},we,{code:"EPSG:4326",projection:es,transformation:De(1/180,1,-1/180,.5)}),ya=V({},se,{projection:es,transformation:De(1,0,-1,0),scale:function(f){return Math.pow(2,f)},zoom:function(f){return Math.log(f)/Math.LN2},distance:function(f,E){var D=E.lng-f.lng,j=E.lat-f.lat;return Math.sqrt(D*D+j*j)},infinite:!0});se.Earth=we,se.EPSG3395=us,se.EPSG3857=Tn,se.EPSG900913=On,se.EPSG4326=Fs,se.Simple=ya;var zo=Ct.extend({options:{pane:"overlayPane",attribution:null,bubblingMouseEvents:!0},addTo:function(f){return f.addLayer(this),this},remove:function(){return this.removeFrom(this._map||this._mapToAdd)},removeFrom:function(f){return f&&f.removeLayer(this),this},getPane:function(f){return this._map.getPane(f?this.options[f]||f:this.options.pane)},addInteractiveTarget:function(f){return this._map._targets[R(f)]=this,this},removeInteractiveTarget:function(f){return delete this._map._targets[R(f)],this},getAttribution:function(){return this.options.attribution},_layerAdd:function(f){var E=f.target;if(E.hasLayer(this)){if(this._map=E,this._zoomAnimated=E._zoomAnimated,this.getEvents){var D=this.getEvents();E.on(D,this),this.once("remove",function(){E.off(D,this)},this)}this.onAdd(E),this.fire("add"),E.fire("layeradd",{layer:this})}}});ae.include({addLayer:function(f){if(!f._layerAdd)throw new Error("The provided object is not a Layer.");var E=R(f);return this._layers[E]||(this._layers[E]=f,f._mapToAdd=this,f.beforeAdd&&f.beforeAdd(this),this.whenReady(f._layerAdd,f)),this},removeLayer:function(f){var E=R(f);return this._layers[E]?(this._loaded&&f.onRemove(this),delete this._layers[E],this._loaded&&(this.fire("layerremove",{layer:f}),f.fire("remove")),f._map=f._mapToAdd=null,this):this},hasLayer:function(f){return R(f)in this._layers},eachLayer:function(f,E){for(var D in this._layers)f.call(E,this._layers[D]);return this},_addLayers:function(f){for(var E=0,D=(f=f?et(f)?f:[f]:[]).length;E<D;E++)this.addLayer(f[E])},_addZoomLimit:function(f){(!isNaN(f.options.maxZoom)||!isNaN(f.options.minZoom))&&(this._zoomBoundLayers[R(f)]=f,this._updateZoomLevels())},_removeZoomLimit:function(f){var E=R(f);this._zoomBoundLayers[E]&&(delete this._zoomBoundLayers[E],this._updateZoomLevels())},_updateZoomLevels:function(){var f=1/0,E=-1/0,D=this._getZoomSpan();for(var j in this._zoomBoundLayers){var mt=this._zoomBoundLayers[j].options;f=void 0===mt.minZoom?f:Math.min(f,mt.minZoom),E=void 0===mt.maxZoom?E:Math.max(E,mt.maxZoom)}this._layersMaxZoom=E===-1/0?void 0:E,this._layersMinZoom=f===1/0?void 0:f,D!==this._getZoomSpan()&&this.fire("zoomlevelschange"),void 0===this.options.maxZoom&&this._layersMaxZoom&&this.getZoom()>this._layersMaxZoom&&this.setZoom(this._layersMaxZoom),void 0===this.options.minZoom&&this._layersMinZoom&&this.getZoom()<this._layersMinZoom&&this.setZoom(this._layersMinZoom)}});var va=zo.extend({initialize:function(f,E){var D,j;if(it(this,E),this._layers={},f)for(D=0,j=f.length;D<j;D++)this.addLayer(f[D])},addLayer:function(f){var E=this.getLayerId(f);return this._layers[E]=f,this._map&&this._map.addLayer(f),this},removeLayer:function(f){var E=f in this._layers?f:this.getLayerId(f);return this._map&&this._layers[E]&&this._map.removeLayer(this._layers[E]),delete this._layers[E],this},hasLayer:function(f){return("number"==typeof f?f:this.getLayerId(f))in this._layers},clearLayers:function(){return this.eachLayer(this.removeLayer,this)},invoke:function(f){var D,j,E=Array.prototype.slice.call(arguments,1);for(D in this._layers)(j=this._layers[D])[f]&&j[f].apply(j,E);return this},onAdd:function(f){this.eachLayer(f.addLayer,f)},onRemove:function(f){this.eachLayer(f.removeLayer,f)},eachLayer:function(f,E){for(var D in this._layers)f.call(E,this._layers[D]);return this},getLayer:function(f){return this._layers[f]},getLayers:function(){var f=[];return this.eachLayer(f.push,f),f},setZIndex:function(f){return this.invoke("setZIndex",f)},getLayerId:function(f){return R(f)}}),qo=va.extend({addLayer:function(f){return this.hasLayer(f)?this:(f.addEventParent(this),va.prototype.addLayer.call(this,f),this.fire("layeradd",{layer:f}))},removeLayer:function(f){return this.hasLayer(f)?(f in this._layers&&(f=this._layers[f]),f.removeEventParent(this),va.prototype.removeLayer.call(this,f),this.fire("layerremove",{layer:f})):this},setStyle:function(f){return this.invoke("setStyle",f)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var f=new re;for(var E in this._layers){var D=this._layers[E];f.extend(D.getBounds?D.getBounds():D.getLatLng())}return f}}),Ao=nt.extend({options:{popupAnchor:[0,0],tooltipAnchor:[0,0],crossOrigin:!1},initialize:function(f){it(this,f)},createIcon:function(f){return this._createIcon("icon",f)},createShadow:function(f){return this._createIcon("shadow",f)},_createIcon:function(f,E){var D=this._getIconUrl(f);if(!D){if("icon"===f)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var j=this._createImg(D,E&&"IMG"===E.tagName?E:null);return this._setIconStyles(j,f),(this.options.crossOrigin||""===this.options.crossOrigin)&&(j.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),j},_setIconStyles:function(f,E){var D=this.options,j=D[E+"Size"];"number"==typeof j&&(j=[j,j]);var mt=xt(j),Ft=xt("shadow"===E&&D.shadowAnchor||D.iconAnchor||mt&&mt.divideBy(2,!0));f.className="leaflet-marker-"+E+" "+(D.className||""),Ft&&(f.style.marginLeft=-Ft.x+"px",f.style.marginTop=-Ft.y+"px"),mt&&(f.style.width=mt.x+"px",f.style.height=mt.y+"px")},_createImg:function(f,E){return(E=E||document.createElement("img")).src=f,E},_getIconUrl:function(f){return Dn.retina&&this.options[f+"RetinaUrl"]||this.options[f+"Url"]}});var ua=Ao.extend({options:{iconUrl:"marker-icon.png",iconRetinaUrl:"marker-icon-2x.png",shadowUrl:"marker-shadow.png",iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],tooltipAnchor:[16,-28],shadowSize:[41,41]},_getIconUrl:function(f){return"string"!=typeof ua.imagePath&&(ua.imagePath=this._detectIconPath()),(this.options.imagePath||ua.imagePath)+Ao.prototype._getIconUrl.call(this,f)},_stripUrl:function(f){var E=function(D,j,mt){var Ft=j.exec(D);return Ft&&Ft[mt]};return(f=E(f,/^url\((['"])?(.+)\1\)$/,2))&&E(f,/^(.*)marker-icon\.png$/,1)},_detectIconPath:function(){var f=$r("div","leaflet-default-icon-path",document.body),E=Oa(f,"background-image")||Oa(f,"backgroundImage");if(document.body.removeChild(f),E=this._stripUrl(E))return E;var D=document.querySelector('link[href$="leaflet.css"]');return D?D.href.substring(0,D.href.length-11-1):""}}),_a=tn.extend({initialize:function(f){this._marker=f},addHooks:function(){var f=this._marker._icon;this._draggable||(this._draggable=new Qi(f,f,!0)),this._draggable.on({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).enable(),An(f,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).disable(),this._marker._icon&&Gr(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_adjustPan:function(f){var E=this._marker,D=E._map,j=this._marker.options.autoPanSpeed,mt=this._marker.options.autoPanPadding,Ft=Cs(E._icon),ce=D.getPixelBounds(),ye=D.getPixelOrigin(),Ve=It(ce.min._subtract(ye).add(mt),ce.max._subtract(ye).subtract(mt));if(!Ve.contains(Ft)){var sn=xt((Math.max(Ve.max.x,Ft.x)-Ve.max.x)/(ce.max.x-Ve.max.x)-(Math.min(Ve.min.x,Ft.x)-Ve.min.x)/(ce.min.x-Ve.min.x),(Math.max(Ve.max.y,Ft.y)-Ve.max.y)/(ce.max.y-Ve.max.y)-(Math.min(Ve.min.y,Ft.y)-Ve.min.y)/(ce.min.y-Ve.min.y)).multiplyBy(j);D.panBy(sn,{animate:!1}),this._draggable._newPos._add(sn),this._draggable._startPos._add(sn),Xn(E._icon,this._draggable._newPos),this._onDrag(f),this._panRequest=ot(this._adjustPan.bind(this,f))}},_onDragStart:function(){this._oldLatLng=this._marker.getLatLng(),this._marker.closePopup&&this._marker.closePopup(),this._marker.fire("movestart").fire("dragstart")},_onPreDrag:function(f){this._marker.options.autoPan&&(P(this._panRequest),this._panRequest=ot(this._adjustPan.bind(this,f)))},_onDrag:function(f){var E=this._marker,D=E._shadow,j=Cs(E._icon),mt=E._map.layerPointToLatLng(j);D&&Xn(D,j),E._latlng=mt,f.latlng=mt,f.oldLatLng=this._oldLatLng,E.fire("move",f).fire("drag",f)},_onDragEnd:function(f){P(this._panRequest),delete this._oldLatLng,this._marker.fire("moveend").fire("dragend",f)}}),ls=zo.extend({options:{icon:new ua,interactive:!0,keyboard:!0,title:"",alt:"Marker",zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250,pane:"markerPane",shadowPane:"shadowPane",bubblingMouseEvents:!1,autoPanOnFocus:!0,draggable:!1,autoPan:!1,autoPanPadding:[50,50],autoPanSpeed:10},initialize:function(f,E){it(this,E),this._latlng=jt(f)},onAdd:function(f){this._zoomAnimated=this._zoomAnimated&&f.options.markerZoomAnimation,this._zoomAnimated&&f.on("zoomanim",this._animateZoom,this),this._initIcon(),this.update()},onRemove:function(f){this.dragging&&this.dragging.enabled()&&(this.options.draggable=!0,this.dragging.removeHooks()),delete this.dragging,this._zoomAnimated&&f.off("zoomanim",this._animateZoom,this),this._removeIcon(),this._removeShadow()},getEvents:function(){return{zoom:this.update,viewreset:this.update}},getLatLng:function(){return this._latlng},setLatLng:function(f){var E=this._latlng;return this._latlng=jt(f),this.update(),this.fire("move",{oldLatLng:E,latlng:this._latlng})},setZIndexOffset:function(f){return this.options.zIndexOffset=f,this.update()},getIcon:function(){return this.options.icon},setIcon:function(f){return this.options.icon=f,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup,this._popup.options),this},getElement:function(){return this._icon},update:function(){if(this._icon&&this._map){var f=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(f)}return this},_initIcon:function(){var f=this.options,E="leaflet-zoom-"+(this._zoomAnimated?"animated":"hide"),D=f.icon.createIcon(this._icon),j=!1;D!==this._icon&&(this._icon&&this._removeIcon(),j=!0,f.title&&(D.title=f.title),"IMG"===D.tagName&&(D.alt=f.alt||"")),An(D,E),f.keyboard&&(D.tabIndex="0",D.setAttribute("role","button")),this._icon=D,f.riseOnHover&&this.on({mouseover:this._bringToFront,mouseout:this._resetZIndex}),this.options.autoPanOnFocus&&Kn(D,"focus",this._panOnFocus,this);var mt=f.icon.createShadow(this._shadow),Ft=!1;mt!==this._shadow&&(this._removeShadow(),Ft=!0),mt&&(An(mt,E),mt.alt=""),this._shadow=mt,f.opacity<1&&this._updateOpacity(),j&&this.getPane().appendChild(this._icon),this._initInteraction(),mt&&Ft&&this.getPane(f.shadowPane).appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&this.off({mouseover:this._bringToFront,mouseout:this._resetZIndex}),this.options.autoPanOnFocus&&wr(this._icon,"focus",this._panOnFocus,this),pr(this._icon),this.removeInteractiveTarget(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&pr(this._shadow),this._shadow=null},_setPos:function(f){this._icon&&Xn(this._icon,f),this._shadow&&Xn(this._shadow,f),this._zIndex=f.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(f){this._icon&&(this._icon.style.zIndex=this._zIndex+f)},_animateZoom:function(f){var E=this._map._latLngToNewLayerPoint(this._latlng,f.zoom,f.center).round();this._setPos(E)},_initInteraction:function(){if(this.options.interactive&&(An(this._icon,"leaflet-interactive"),this.addInteractiveTarget(this._icon),_a)){var f=this.options.draggable;this.dragging&&(f=this.dragging.enabled(),this.dragging.disable()),this.dragging=new _a(this),f&&this.dragging.enable()}},setOpacity:function(f){return this.options.opacity=f,this._map&&this._updateOpacity(),this},_updateOpacity:function(){var f=this.options.opacity;this._icon&&er(this._icon,f),this._shadow&&er(this._shadow,f)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)},_panOnFocus:function(){var f=this._map;if(f){var E=this.options.icon.options,D=E.iconSize?xt(E.iconSize):xt(0,0),j=E.iconAnchor?xt(E.iconAnchor):xt(0,0);f.panInside(this._latlng,{paddingTopLeft:j,paddingBottomRight:D.subtract(j)})}},_getPopupAnchor:function(){return this.options.icon.options.popupAnchor},_getTooltipAnchor:function(){return this.options.icon.options.tooltipAnchor}});var iu=zo.extend({options:{stroke:!0,color:"#3388ff",weight:3,opacity:1,lineCap:"round",lineJoin:"round",dashArray:null,dashOffset:null,fill:!1,fillColor:null,fillOpacity:.2,fillRule:"evenodd",interactive:!0,bubblingMouseEvents:!0},beforeAdd:function(f){this._renderer=f.getRenderer(this)},onAdd:function(){this._renderer._initPath(this),this._reset(),this._renderer._addPath(this)},onRemove:function(){this._renderer._removePath(this)},redraw:function(){return this._map&&this._renderer._updatePath(this),this},setStyle:function(f){return it(this,f),this._renderer&&(this._renderer._updateStyle(this),this.options.stroke&&f&&Object.prototype.hasOwnProperty.call(f,"weight")&&this._updateBounds()),this},bringToFront:function(){return this._renderer&&this._renderer._bringToFront(this),this},bringToBack:function(){return this._renderer&&this._renderer._bringToBack(this),this},getElement:function(){return this._path},_reset:function(){this._project(),this._update()},_clickTolerance:function(){return(this.options.stroke?this.options.weight/2:0)+(this._renderer.options.tolerance||0)}}),Ys=iu.extend({options:{fill:!0,radius:10},initialize:function(f,E){it(this,E),this._latlng=jt(f),this._radius=this.options.radius},setLatLng:function(f){var E=this._latlng;return this._latlng=jt(f),this.redraw(),this.fire("move",{oldLatLng:E,latlng:this._latlng})},getLatLng:function(){return this._latlng},setRadius:function(f){return this.options.radius=this._radius=f,this.redraw()},getRadius:function(){return this._radius},setStyle:function(f){var E=f&&f.radius||this._radius;return iu.prototype.setStyle.call(this,f),this.setRadius(E),this},_project:function(){this._point=this._map.latLngToLayerPoint(this._latlng),this._updateBounds()},_updateBounds:function(){var f=this._radius,E=this._radiusY||f,D=this._clickTolerance(),j=[f+D,E+D];this._pxBounds=new Mt(this._point.subtract(j),this._point.add(j))},_update:function(){this._map&&this._updatePath()},_updatePath:function(){this._renderer._updateCircle(this)},_empty:function(){return this._radius&&!this._renderer._bounds.intersects(this._pxBounds)},_containsPoint:function(f){return f.distanceTo(this._point)<=this._radius+this._clickTolerance()}});var Vo=Ys.extend({initialize:function(f,E,D){if("number"==typeof E&&(E=V({},D,{radius:E})),it(this,E),this._latlng=jt(f),isNaN(this.options.radius))throw new Error("Circle radius cannot be NaN");this._mRadius=this.options.radius},setRadius:function(f){return this._mRadius=f,this.redraw()},getRadius:function(){return this._mRadius},getBounds:function(){var f=[this._radius,this._radiusY||this._radius];return new re(this._map.layerPointToLatLng(this._point.subtract(f)),this._map.layerPointToLatLng(this._point.add(f)))},setStyle:iu.prototype.setStyle,_project:function(){var f=this._latlng.lng,E=this._latlng.lat,D=this._map,j=D.options.crs;if(j.distance===we.distance){var mt=Math.PI/180,Ft=this._mRadius/we.R/mt,ce=D.project([E+Ft,f]),ye=D.project([E-Ft,f]),Ve=ce.add(ye).divideBy(2),sn=D.unproject(Ve).lat,wn=Math.acos((Math.cos(Ft*mt)-Math.sin(E*mt)*Math.sin(sn*mt))/(Math.cos(E*mt)*Math.cos(sn*mt)))/mt;(isNaN(wn)||0===wn)&&(wn=Ft/Math.cos(Math.PI/180*E)),this._point=Ve.subtract(D.getPixelOrigin()),this._radius=isNaN(wn)?0:Ve.x-D.project([sn,f-wn]).x,this._radiusY=Ve.y-ce.y}else{var Pn=j.unproject(j.project(this._latlng).subtract([this._mRadius,0]));this._point=D.latLngToLayerPoint(this._latlng),this._radius=this._point.x-D.latLngToLayerPoint(Pn).x}this._updateBounds()}});var mi=iu.extend({options:{smoothFactor:1,noClip:!1},initialize:function(f,E){it(this,E),this._setLatLngs(f)},getLatLngs:function(){return this._latlngs},setLatLngs:function(f){return this._setLatLngs(f),this.redraw()},isEmpty:function(){return!this._latlngs.length},closestLayerPoint:function(f){for(var mt,Ft,E=1/0,D=null,j=he,ce=0,ye=this._parts.length;ce<ye;ce++)for(var Ve=this._parts[ce],sn=1,wn=Ve.length;sn<wn;sn++){var Pn=j(f,mt=Ve[sn-1],Ft=Ve[sn],!0);Pn<E&&(E=Pn,D=j(f,mt,Ft))}return D&&(D.distance=Math.sqrt(E)),D},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");return ku(this._defaultShape(),this._map.options.crs)},getBounds:function(){return this._bounds},addLatLng:function(f,E){return E=E||this._defaultShape(),f=jt(f),E.push(f),this._bounds.extend(f),this.redraw()},_setLatLngs:function(f){this._bounds=new re,this._latlngs=this._convertLatLngs(f)},_defaultShape:function(){return Bo(this._latlngs)?this._latlngs:this._latlngs[0]},_convertLatLngs:function(f){for(var E=[],D=Bo(f),j=0,mt=f.length;j<mt;j++)D?(E[j]=jt(f[j]),this._bounds.extend(E[j])):E[j]=this._convertLatLngs(f[j]);return E},_project:function(){var f=new Mt;this._rings=[],this._projectLatlngs(this._latlngs,this._rings,f),this._bounds.isValid()&&f.isValid()&&(this._rawPxBounds=f,this._updateBounds())},_updateBounds:function(){var f=this._clickTolerance(),E=new yt(f,f);this._rawPxBounds&&(this._pxBounds=new Mt([this._rawPxBounds.min.subtract(E),this._rawPxBounds.max.add(E)]))},_projectLatlngs:function(f,E,D){var Ft,ce,mt=f.length;if(f[0]instanceof ee){for(ce=[],Ft=0;Ft<mt;Ft++)ce[Ft]=this._map.latLngToLayerPoint(f[Ft]),D.extend(ce[Ft]);E.push(ce)}else for(Ft=0;Ft<mt;Ft++)this._projectLatlngs(f[Ft],E,D)},_clipPoints:function(){var f=this._renderer._bounds;if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(f)){if(this.options.noClip)return void(this._parts=this._rings);var D,j,mt,Ft,ce,ye,Ve,E=this._parts;for(D=0,mt=0,Ft=this._rings.length;D<Ft;D++)for(j=0,ce=(Ve=this._rings[D]).length;j<ce-1;j++)(ye=Ir(Ve[j],Ve[j+1],f,j,!0))&&(E[mt]=E[mt]||[],E[mt].push(ye[0]),(ye[1]!==Ve[j+1]||j===ce-2)&&(E[mt].push(ye[1]),mt++))}},_simplifyPoints:function(){for(var f=this._parts,E=this.options.smoothFactor,D=0,j=f.length;D<j;D++)f[D]=as(f[D],E)},_update:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),this._updatePath())},_updatePath:function(){this._renderer._updatePoly(this)},_containsPoint:function(f,E){var D,j,mt,Ft,ce,ye,Ve=this._clickTolerance();if(!this._pxBounds||!this._pxBounds.contains(f))return!1;for(D=0,Ft=this._parts.length;D<Ft;D++)for(j=0,mt=(ce=(ye=this._parts[D]).length)-1;j<ce;mt=j++)if((E||0!==j)&&Zr(f,ye[mt],ye[j])<=Ve)return!0;return!1}});mi._flat=Hl;var La=mi.extend({options:{fill:!0},isEmpty:function(){return!this._latlngs.length||!this._latlngs[0].length},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");return vs(this._defaultShape(),this._map.options.crs)},_convertLatLngs:function(f){var E=mi.prototype._convertLatLngs.call(this,f),D=E.length;return D>=2&&E[0]instanceof ee&&E[0].equals(E[D-1])&&E.pop(),E},_setLatLngs:function(f){mi.prototype._setLatLngs.call(this,f),Bo(this._latlngs)&&(this._latlngs=[this._latlngs])},_defaultShape:function(){return Bo(this._latlngs[0])?this._latlngs[0]:this._latlngs[0][0]},_clipPoints:function(){var f=this._renderer._bounds,E=this.options.weight,D=new yt(E,E);if(f=new Mt(f.min.subtract(D),f.max.add(D)),this._parts=[],this._pxBounds&&this._pxBounds.intersects(f)){if(this.options.noClip)return void(this._parts=this._rings);for(var Ft,j=0,mt=this._rings.length;j<mt;j++)(Ft=fo(this._rings[j],f,!0)).length&&this._parts.push(Ft)}},_updatePath:function(){this._renderer._updatePoly(this,!0)},_containsPoint:function(f){var D,j,mt,Ft,ce,ye,Ve,sn,E=!1;if(!this._pxBounds||!this._pxBounds.contains(f))return!1;for(Ft=0,Ve=this._parts.length;Ft<Ve;Ft++)for(ce=0,ye=(sn=(D=this._parts[Ft]).length)-1;ce<sn;ye=ce++)(j=D[ce]).y>f.y!=(mt=D[ye]).y>f.y&&f.x<(mt.x-j.x)*(f.y-j.y)/(mt.y-j.y)+j.x&&(E=!E);return E||mi.prototype._containsPoint.call(this,f,!0)}});var Ga=qo.extend({initialize:function(f,E){it(this,E),this._layers={},f&&this.addData(f)},addData:function(f){var D,j,mt,E=et(f)?f:f.features;if(E){for(D=0,j=E.length;D<j;D++)((mt=E[D]).geometries||mt.geometry||mt.features||mt.coordinates)&&this.addData(mt);return this}var Ft=this.options;if(Ft.filter&&!Ft.filter(f))return this;var ce=pl(f,Ft);return ce?(ce.feature=Ea(f),ce.defaultOptions=ce.options,this.resetStyle(ce),Ft.onEachFeature&&Ft.onEachFeature(f,ce),this.addLayer(ce)):this},resetStyle:function(f){return void 0===f?this.eachLayer(this.resetStyle,this):(f.options=V({},f.defaultOptions),this._setLayerStyle(f,this.options.style),this)},setStyle:function(f){return this.eachLayer(function(E){this._setLayerStyle(E,f)},this)},_setLayerStyle:function(f,E){f.setStyle&&("function"==typeof E&&(E=E(f.feature)),f.setStyle(E))}});function pl(f,E){var ye,Ve,sn,wn,D="Feature"===f.type?f.geometry:f,j=D?D.coordinates:null,mt=[],Ft=E&&E.pointToLayer,ce=E&&E.coordsToLatLng||Uo;if(!j&&!D)return null;switch(D.type){case"Point":return Jo(Ft,f,ye=ce(j),E);case"MultiPoint":for(sn=0,wn=j.length;sn<wn;sn++)ye=ce(j[sn]),mt.push(Jo(Ft,f,ye,E));return new qo(mt);case"LineString":case"MultiLineString":return Ve=Ts(j,"LineString"===D.type?0:1,ce),new mi(Ve,E);case"Polygon":case"MultiPolygon":return Ve=Ts(j,"Polygon"===D.type?1:2,ce),new La(Ve,E);case"GeometryCollection":for(sn=0,wn=D.geometries.length;sn<wn;sn++){var Pn=pl({geometry:D.geometries[sn],type:"Feature",properties:f.properties},E);Pn&&mt.push(Pn)}return new qo(mt);case"FeatureCollection":for(sn=0,wn=D.features.length;sn<wn;sn++){var Nr=pl(D.features[sn],E);Nr&&mt.push(Nr)}return new qo(mt);default:throw new Error("Invalid GeoJSON object.")}}function Jo(f,E,D,j){return f?f(E,D):new ls(D,j&&j.markersInheritOptions&&j)}function Uo(f){return new ee(f[1],f[0],f[2])}function Ts(f,E,D){for(var ce,j=[],mt=0,Ft=f.length;mt<Ft;mt++)ce=E?Ts(f[mt],E-1,D):(D||Uo)(f[mt]),j.push(ce);return j}function Du(f,E){return void 0!==(f=jt(f)).alt?[X(f.lng,E),X(f.lat,E),X(f.alt,E)]:[X(f.lng,E),X(f.lat,E)]}function Bs(f,E,D,j){for(var mt=[],Ft=0,ce=f.length;Ft<ce;Ft++)mt.push(E?Bs(f[Ft],Bo(f[Ft])?0:E-1,D,j):Du(f[Ft],j));return!E&&D&&mt.length>0&&mt.push(mt[0].slice()),mt}function Wo(f,E){return f.feature?V({},f.feature,{geometry:E}):Ea(E)}function Ea(f){return"Feature"===f.type||"FeatureCollection"===f.type?f:{type:"Feature",properties:{},geometry:f}}var Tu={toGeoJSON:function(f){return Wo(this,{type:"Point",coordinates:Du(this.getLatLng(),f)})}};function mu(f,E){return new Ga(f,E)}ls.include(Tu),Vo.include(Tu),Ys.include(Tu),mi.include({toGeoJSON:function(f){var E=!Bo(this._latlngs);return Wo(this,{type:(E?"Multi":"")+"LineString",coordinates:Bs(this._latlngs,E?1:0,!1,f)})}}),La.include({toGeoJSON:function(f){var E=!Bo(this._latlngs),D=E&&!Bo(this._latlngs[0]),j=Bs(this._latlngs,D?2:E?1:0,!0,f);return E||(j=[j]),Wo(this,{type:(D?"Multi":"")+"Polygon",coordinates:j})}}),va.include({toMultiPoint:function(f){var E=[];return this.eachLayer(function(D){E.push(D.toGeoJSON(f).geometry.coordinates)}),Wo(this,{type:"MultiPoint",coordinates:E})},toGeoJSON:function(f){var E=this.feature&&this.feature.geometry&&this.feature.geometry.type;if("MultiPoint"===E)return this.toMultiPoint(f);var D="GeometryCollection"===E,j=[];return this.eachLayer(function(mt){if(mt.toGeoJSON){var Ft=mt.toGeoJSON(f);if(D)j.push(Ft.geometry);else{var ce=Ea(Ft);"FeatureCollection"===ce.type?j.push.apply(j,ce.features):j.push(ce)}}}),D?Wo(this,{geometries:j,type:"GeometryCollection"}):{type:"FeatureCollection",features:j}}});var Ha=mu,Ca=zo.extend({options:{opacity:1,alt:"",interactive:!1,crossOrigin:!1,errorOverlayUrl:"",zIndex:1,className:""},initialize:function(f,E,D){this._url=f,this._bounds=Bt(E),it(this,D)},onAdd:function(){this._image||(this._initImage(),this.options.opacity<1&&this._updateOpacity()),this.options.interactive&&(An(this._image,"leaflet-interactive"),this.addInteractiveTarget(this._image)),this.getPane().appendChild(this._image),this._reset()},onRemove:function(){pr(this._image),this.options.interactive&&this.removeInteractiveTarget(this._image)},setOpacity:function(f){return this.options.opacity=f,this._image&&this._updateOpacity(),this},setStyle:function(f){return f.opacity&&this.setOpacity(f.opacity),this},bringToFront:function(){return this._map&&Xs(this._image),this},bringToBack:function(){return this._map&&Wa(this._image),this},setUrl:function(f){return this._url=f,this._image&&(this._image.src=f),this},setBounds:function(f){return this._bounds=Bt(f),this._map&&this._reset(),this},getEvents:function(){var f={zoom:this._reset,viewreset:this._reset};return this._zoomAnimated&&(f.zoomanim=this._animateZoom),f},setZIndex:function(f){return this.options.zIndex=f,this._updateZIndex(),this},getBounds:function(){return this._bounds},getElement:function(){return this._image},_initImage:function(){var f="IMG"===this._url.tagName,E=this._image=f?this._url:$r("img");An(E,"leaflet-image-layer"),this._zoomAnimated&&An(E,"leaflet-zoom-animated"),this.options.className&&An(E,this.options.className),E.onselectstart=A,E.onmousemove=A,E.onload=Q(this.fire,this,"load"),E.onerror=Q(this._overlayOnError,this,"error"),(this.options.crossOrigin||""===this.options.crossOrigin)&&(E.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),this.options.zIndex&&this._updateZIndex(),f?this._url=E.src:(E.src=this._url,E.alt=this.options.alt)},_animateZoom:function(f){var E=this._map.getZoomScale(f.zoom),D=this._map._latLngBoundsToNewLayerBounds(this._bounds,f.zoom,f.center).min;ga(this._image,D,E)},_reset:function(){var f=this._image,E=new Mt(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast())),D=E.getSize();Xn(f,E.min),f.style.width=D.x+"px",f.style.height=D.y+"px"},_updateOpacity:function(){er(this._image,this.options.opacity)},_updateZIndex:function(){this._image&&null!=this.options.zIndex&&(this._image.style.zIndex=this.options.zIndex)},_overlayOnError:function(){this.fire("error");var f=this.options.errorOverlayUrl;f&&this._url!==f&&(this._url=f,this._image.src=f)},getCenter:function(){return this._bounds.getCenter()}}),ta=Ca.extend({options:{autoplay:!0,loop:!0,keepAspectRatio:!0,muted:!1,playsInline:!0},_initImage:function(){var f="VIDEO"===this._url.tagName,E=this._image=f?this._url:$r("video");if(An(E,"leaflet-image-layer"),this._zoomAnimated&&An(E,"leaflet-zoom-animated"),this.options.className&&An(E,this.options.className),E.onselectstart=A,E.onmousemove=A,E.onloadeddata=Q(this.fire,this,"load"),f){for(var D=E.getElementsByTagName("source"),j=[],mt=0;mt<D.length;mt++)j.push(D[mt].src);this._url=D.length>0?j:[E.src]}else{et(this._url)||(this._url=[this._url]),!this.options.keepAspectRatio&&Object.prototype.hasOwnProperty.call(E.style,"objectFit")&&(E.style.objectFit="fill"),E.autoplay=!!this.options.autoplay,E.loop=!!this.options.loop,E.muted=!!this.options.muted,E.playsInline=!!this.options.playsInline;for(var Ft=0;Ft<this._url.length;Ft++){var ce=$r("source");ce.src=this._url[Ft],E.appendChild(ce)}}}});var ka=Ca.extend({_initImage:function(){var f=this._image=this._url;An(f,"leaflet-image-layer"),this._zoomAnimated&&An(f,"leaflet-zoom-animated"),this.options.className&&An(f,this.options.className),f.onselectstart=A,f.onmousemove=A}});var Io=zo.extend({options:{interactive:!1,offset:[0,0],className:"",pane:void 0,content:""},initialize:function(f,E){f&&(f instanceof ee||et(f))?(this._latlng=jt(f),it(this,E)):(it(this,f),this._source=E),this.options.content&&(this._content=this.options.content)},openOn:function(f){return(f=arguments.length?f:this._source._map).hasLayer(this)||f.addLayer(this),this},close:function(){return this._map&&this._map.removeLayer(this),this},toggle:function(f){return this._map?this.close():(arguments.length?this._source=f:f=this._source,this._prepareOpen(),this.openOn(f._map)),this},onAdd:function(f){this._zoomAnimated=f._zoomAnimated,this._container||this._initLayout(),f._fadeAnimated&&er(this._container,0),clearTimeout(this._removeTimeout),this.getPane().appendChild(this._container),this.update(),f._fadeAnimated&&er(this._container,1),this.bringToFront(),this.options.interactive&&(An(this._container,"leaflet-interactive"),this.addInteractiveTarget(this._container))},onRemove:function(f){f._fadeAnimated?(er(this._container,0),this._removeTimeout=setTimeout(Q(pr,void 0,this._container),200)):pr(this._container),this.options.interactive&&(Gr(this._container,"leaflet-interactive"),this.removeInteractiveTarget(this._container))},getLatLng:function(){return this._latlng},setLatLng:function(f){return this._latlng=jt(f),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(f){return this._content=f,this.update(),this},getElement:function(){return this._container},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},getEvents:function(){var f={zoom:this._updatePosition,viewreset:this._updatePosition};return this._zoomAnimated&&(f.zoomanim=this._animateZoom),f},isOpen:function(){return!!this._map&&this._map.hasLayer(this)},bringToFront:function(){return this._map&&Xs(this._container),this},bringToBack:function(){return this._map&&Wa(this._container),this},_prepareOpen:function(f){var E=this._source;if(!E._map)return!1;if(E instanceof qo){E=null;var D=this._source._layers;for(var j in D)if(D[j]._map){E=D[j];break}if(!E)return!1;this._source=E}if(!f)if(E.getCenter)f=E.getCenter();else if(E.getLatLng)f=E.getLatLng();else{if(!E.getBounds)throw new Error("Unable to get source layer LatLng.");f=E.getBounds().getCenter()}return this.setLatLng(f),this._map&&this.update(),!0},_updateContent:function(){if(this._content){var f=this._contentNode,E="function"==typeof this._content?this._content(this._source||this):this._content;if("string"==typeof E)f.innerHTML=E;else{for(;f.hasChildNodes();)f.removeChild(f.firstChild);f.appendChild(E)}this.fire("contentupdate")}},_updatePosition:function(){if(this._map){var f=this._map.latLngToLayerPoint(this._latlng),E=xt(this.options.offset),D=this._getAnchor();this._zoomAnimated?Xn(this._container,f.add(D)):E=E.add(f).add(D);var j=this._containerBottom=-E.y,mt=this._containerLeft=-Math.round(this._containerWidth/2)+E.x;this._container.style.bottom=j+"px",this._container.style.left=mt+"px"}},_getAnchor:function(){return[0,0]}});ae.include({_initOverlay:function(f,E,D,j){var mt=E;return mt instanceof f||(mt=new f(j).setContent(E)),D&&mt.setLatLng(D),mt}}),zo.include({_initOverlay:function(f,E,D,j){var mt=D;return mt instanceof f?(it(mt,j),mt._source=this):(mt=E&&!j?E:new f(j,this)).setContent(D),mt}});var cs=Io.extend({options:{pane:"popupPane",offset:[0,7],maxWidth:300,minWidth:50,maxHeight:null,autoPan:!0,autoPanPaddingTopLeft:null,autoPanPaddingBottomRight:null,autoPanPadding:[5,5],keepInView:!1,closeButton:!0,autoClose:!0,closeOnEscapeKey:!0,className:""},openOn:function(f){return!(f=arguments.length?f:this._source._map).hasLayer(this)&&f._popup&&f._popup.options.autoClose&&f.removeLayer(f._popup),f._popup=this,Io.prototype.openOn.call(this,f)},onAdd:function(f){Io.prototype.onAdd.call(this,f),f.fire("popupopen",{popup:this}),this._source&&(this._source.fire("popupopen",{popup:this},!0),this._source instanceof iu||this._source.on("preclick",Fo))},onRemove:function(f){Io.prototype.onRemove.call(this,f),f.fire("popupclose",{popup:this}),this._source&&(this._source.fire("popupclose",{popup:this},!0),this._source instanceof iu||this._source.off("preclick",Fo))},getEvents:function(){var f=Io.prototype.getEvents.call(this);return(void 0!==this.options.closeOnClick?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(f.preclick=this.close),this.options.keepInView&&(f.moveend=this._adjustPan),f},_initLayout:function(){var f="leaflet-popup",E=this._container=$r("div",f+" "+(this.options.className||"")+" leaflet-zoom-animated"),D=this._wrapper=$r("div",f+"-content-wrapper",E);if(this._contentNode=$r("div",f+"-content",D),os(E),Or(this._contentNode),Kn(E,"contextmenu",Fo),this._tipContainer=$r("div",f+"-tip-container",E),this._tip=$r("div",f+"-tip",this._tipContainer),this.options.closeButton){var j=this._closeButton=$r("a",f+"-close-button",E);j.setAttribute("role","button"),j.setAttribute("aria-label","Close popup"),j.href="#close",j.innerHTML='<span aria-hidden="true">&#215;</span>',Kn(j,"click",function(mt){_e(mt),this.close()},this)}},_updateLayout:function(){var f=this._contentNode,E=f.style;E.width="",E.whiteSpace="nowrap";var D=f.offsetWidth;D=Math.min(D,this.options.maxWidth),D=Math.max(D,this.options.minWidth),E.width=D+1+"px",E.whiteSpace="",E.height="";var mt=this.options.maxHeight,Ft="leaflet-popup-scrolled";mt&&f.offsetHeight>mt?(E.height=mt+"px",An(f,Ft)):Gr(f,Ft),this._containerWidth=this._container.offsetWidth},_animateZoom:function(f){var E=this._map._latLngToNewLayerPoint(this._latlng,f.zoom,f.center),D=this._getAnchor();Xn(this._container,E.add(D))},_adjustPan:function(){if(this.options.autoPan){if(this._map._panAnim&&this._map._panAnim.stop(),this._autopanning)return void(this._autopanning=!1);var f=this._map,E=parseInt(Oa(this._container,"marginBottom"),10)||0,D=this._container.offsetHeight+E,j=this._containerWidth,mt=new yt(this._containerLeft,-D-this._containerBottom);mt._add(Cs(this._container));var Ft=f.layerPointToContainerPoint(mt),ce=xt(this.options.autoPanPadding),ye=xt(this.options.autoPanPaddingTopLeft||ce),Ve=xt(this.options.autoPanPaddingBottomRight||ce),sn=f.getSize(),wn=0,Pn=0;Ft.x+j+Ve.x>sn.x&&(wn=Ft.x+j-sn.x+Ve.x),Ft.x-wn-ye.x<0&&(wn=Ft.x-ye.x),Ft.y+D+Ve.y>sn.y&&(Pn=Ft.y+D-sn.y+Ve.y),Ft.y-Pn-ye.y<0&&(Pn=Ft.y-ye.y),(wn||Pn)&&(this.options.keepInView&&(this._autopanning=!0),f.fire("autopanstart").panBy([wn,Pn]))}},_getAnchor:function(){return xt(this._source&&this._source._getPopupAnchor?this._source._getPopupAnchor():[0,0])}});ae.mergeOptions({closePopupOnClick:!0}),ae.include({openPopup:function(f,E,D){return this._initOverlay(cs,f,E,D).openOn(this),this},closePopup:function(f){return(f=arguments.length?f:this._popup)&&f.close(),this}}),zo.include({bindPopup:function(f,E){return this._popup=this._initOverlay(cs,this._popup,f,E),this._popupHandlersAdded||(this.on({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this.off({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!1,this._popup=null),this},openPopup:function(f){return this._popup&&(this instanceof qo||(this._popup._source=this),this._popup._prepareOpen(f||this._latlng)&&this._popup.openOn(this._map)),this},closePopup:function(){return this._popup&&this._popup.close(),this},togglePopup:function(){return this._popup&&this._popup.toggle(this),this},isPopupOpen:function(){return!!this._popup&&this._popup.isOpen()},setPopupContent:function(f){return this._popup&&this._popup.setContent(f),this},getPopup:function(){return this._popup},_openPopup:function(f){if(this._popup&&this._map){z(f);var E=f.layer||f.target;if(this._popup._source===E&&!(E instanceof iu))return void(this._map.hasLayer(this._popup)?this.closePopup():this.openPopup(f.latlng));this._popup._source=E,this.openPopup(f.latlng)}},_movePopup:function(f){this._popup.setLatLng(f.latlng)},_onKeyPress:function(f){13===f.originalEvent.keyCode&&this._openPopup(f)}});var la=Io.extend({options:{pane:"tooltipPane",offset:[0,0],direction:"auto",permanent:!1,sticky:!1,opacity:.9},onAdd:function(f){Io.prototype.onAdd.call(this,f),this.setOpacity(this.options.opacity),f.fire("tooltipopen",{tooltip:this}),this._source&&(this.addEventParent(this._source),this._source.fire("tooltipopen",{tooltip:this},!0))},onRemove:function(f){Io.prototype.onRemove.call(this,f),f.fire("tooltipclose",{tooltip:this}),this._source&&(this.removeEventParent(this._source),this._source.fire("tooltipclose",{tooltip:this},!0))},getEvents:function(){var f=Io.prototype.getEvents.call(this);return this.options.permanent||(f.preclick=this.close),f},_initLayout:function(){this._contentNode=this._container=$r("div","leaflet-tooltip "+(this.options.className||"")+" leaflet-zoom-"+(this._zoomAnimated?"animated":"hide")),this._container.setAttribute("role","tooltip"),this._container.setAttribute("id","leaflet-tooltip-"+R(this))},_updateLayout:function(){},_adjustPan:function(){},_setPosition:function(f){var E,D,j=this._map,mt=this._container,Ft=j.latLngToContainerPoint(j.getCenter()),ce=j.layerPointToContainerPoint(f),ye=this.options.direction,Ve=mt.offsetWidth,sn=mt.offsetHeight,wn=xt(this.options.offset),Pn=this._getAnchor();"top"===ye?(E=Ve/2,D=sn):"bottom"===ye?(E=Ve/2,D=0):"center"===ye?(E=Ve/2,D=sn/2):"right"===ye?(E=0,D=sn/2):"left"===ye?(E=Ve,D=sn/2):ce.x<Ft.x?(ye="right",E=0,D=sn/2):(ye="left",E=Ve+2*(wn.x+Pn.x),D=sn/2),f=f.subtract(xt(E,D,!0)).add(wn).add(Pn),Gr(mt,"leaflet-tooltip-right"),Gr(mt,"leaflet-tooltip-left"),Gr(mt,"leaflet-tooltip-top"),Gr(mt,"leaflet-tooltip-bottom"),An(mt,"leaflet-tooltip-"+ye),Xn(mt,f)},_updatePosition:function(){var f=this._map.latLngToLayerPoint(this._latlng);this._setPosition(f)},setOpacity:function(f){this.options.opacity=f,this._container&&er(this._container,f)},_animateZoom:function(f){var E=this._map._latLngToNewLayerPoint(this._latlng,f.zoom,f.center);this._setPosition(E)},_getAnchor:function(){return xt(this._source&&this._source._getTooltipAnchor&&!this.options.sticky?this._source._getTooltipAnchor():[0,0])}});ae.include({openTooltip:function(f,E,D){return this._initOverlay(la,f,E,D).openOn(this),this},closeTooltip:function(f){return f.close(),this}}),zo.include({bindTooltip:function(f,E){return this._tooltip&&this.isTooltipOpen()&&this.unbindTooltip(),this._tooltip=this._initOverlay(la,this._tooltip,f,E),this._initTooltipInteractions(),this._tooltip.options.permanent&&this._map&&this._map.hasLayer(this)&&this.openTooltip(),this},unbindTooltip:function(){return this._tooltip&&(this._initTooltipInteractions(!0),this.closeTooltip(),this._tooltip=null),this},_initTooltipInteractions:function(f){if(f||!this._tooltipHandlersAdded){var E=f?"off":"on",D={remove:this.closeTooltip,move:this._moveTooltip};this._tooltip.options.permanent?D.add=this._openTooltip:(D.mouseover=this._openTooltip,D.mouseout=this.closeTooltip,D.click=this._openTooltip,this._map?this._addFocusListeners():D.add=this._addFocusListeners),this._tooltip.options.sticky&&(D.mousemove=this._moveTooltip),this[E](D),this._tooltipHandlersAdded=!f}},openTooltip:function(f){return this._tooltip&&(this instanceof qo||(this._tooltip._source=this),this._tooltip._prepareOpen(f)&&(this._tooltip.openOn(this._map),this.getElement?this._setAriaDescribedByOnLayer(this):this.eachLayer&&this.eachLayer(this._setAriaDescribedByOnLayer,this))),this},closeTooltip:function(){if(this._tooltip)return this._tooltip.close()},toggleTooltip:function(){return this._tooltip&&this._tooltip.toggle(this),this},isTooltipOpen:function(){return this._tooltip.isOpen()},setTooltipContent:function(f){return this._tooltip&&this._tooltip.setContent(f),this},getTooltip:function(){return this._tooltip},_addFocusListeners:function(){this.getElement?this._addFocusListenersOnLayer(this):this.eachLayer&&this.eachLayer(this._addFocusListenersOnLayer,this)},_addFocusListenersOnLayer:function(f){var E="function"==typeof f.getElement&&f.getElement();E&&(Kn(E,"focus",function(){this._tooltip._source=f,this.openTooltip()},this),Kn(E,"blur",this.closeTooltip,this))},_setAriaDescribedByOnLayer:function(f){var E="function"==typeof f.getElement&&f.getElement();E&&E.setAttribute("aria-describedby",this._tooltip._container.id)},_openTooltip:function(f){if(this._tooltip&&this._map){if(this._map.dragging&&this._map.dragging.moving()&&!this._openOnceFlag){this._openOnceFlag=!0;var E=this;return void this._map.once("moveend",function(){E._openOnceFlag=!1,E._openTooltip(f)})}this._tooltip._source=f.layer||f.target,this.openTooltip(this._tooltip.options.sticky?f.latlng:void 0)}},_moveTooltip:function(f){var D,j,E=f.latlng;this._tooltip.options.sticky&&f.originalEvent&&(D=this._map.mouseEventToContainerPoint(f.originalEvent),j=this._map.containerPointToLayerPoint(D),E=this._map.layerPointToLatLng(j)),this._tooltip.setLatLng(E)}});var wl=Ao.extend({options:{iconSize:[12,12],html:!1,bgPos:null,className:"leaflet-div-icon"},createIcon:function(f){var E=f&&"DIV"===f.tagName?f:document.createElement("div"),D=this.options;if(D.html instanceof Element?(du(E),E.appendChild(D.html)):E.innerHTML=!1!==D.html?D.html:"",D.bgPos){var j=xt(D.bgPos);E.style.backgroundPosition=-j.x+"px "+-j.y+"px"}return this._setIconStyles(E,"icon"),E},createShadow:function(){return null}});Ao.Default=ua;var Go=zo.extend({options:{tileSize:256,opacity:1,updateWhenIdle:Dn.mobile,updateWhenZooming:!0,updateInterval:200,zIndex:1,bounds:null,minZoom:0,maxZoom:void 0,maxNativeZoom:void 0,minNativeZoom:void 0,noWrap:!1,pane:"tilePane",className:"",keepBuffer:2},initialize:function(f){it(this,f)},onAdd:function(){this._initContainer(),this._levels={},this._tiles={},this._resetView()},beforeAdd:function(f){f._addZoomLimit(this)},onRemove:function(f){this._removeAllTiles(),pr(this._container),f._removeZoomLimit(this),this._container=null,this._tileZoom=void 0},bringToFront:function(){return this._map&&(Xs(this._container),this._setAutoZIndex(Math.max)),this},bringToBack:function(){return this._map&&(Wa(this._container),this._setAutoZIndex(Math.min)),this},getContainer:function(){return this._container},setOpacity:function(f){return this.options.opacity=f,this._updateOpacity(),this},setZIndex:function(f){return this.options.zIndex=f,this._updateZIndex(),this},isLoading:function(){return this._loading},redraw:function(){if(this._map){this._removeAllTiles();var f=this._clampZoom(this._map.getZoom());f!==this._tileZoom&&(this._tileZoom=f,this._updateLevels()),this._update()}return this},getEvents:function(){var f={viewprereset:this._invalidateAll,viewreset:this._resetView,zoom:this._resetView,moveend:this._onMoveEnd};return this.options.updateWhenIdle||(this._onMove||(this._onMove=W(this._onMoveEnd,this.options.updateInterval,this)),f.move=this._onMove),this._zoomAnimated&&(f.zoomanim=this._animateZoom),f},createTile:function(){return document.createElement("div")},getTileSize:function(){var f=this.options.tileSize;return f instanceof yt?f:new yt(f,f)},_updateZIndex:function(){this._container&&null!=this.options.zIndex&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(f){for(var Ft,E=this.getPane().children,D=-f(-1/0,1/0),j=0,mt=E.length;j<mt;j++)Ft=E[j].style.zIndex,E[j]!==this._container&&Ft&&(D=f(D,+Ft));isFinite(D)&&(this.options.zIndex=D+f(-1,1),this._updateZIndex())},_updateOpacity:function(){if(this._map&&!Dn.ielt9){er(this._container,this.options.opacity);var f=+new Date,E=!1,D=!1;for(var j in this._tiles){var mt=this._tiles[j];if(mt.current&&mt.loaded){var Ft=Math.min(1,(f-mt.loaded)/200);er(mt.el,Ft),Ft<1?E=!0:(mt.active?D=!0:this._onOpaqueTile(mt),mt.active=!0)}}D&&!this._noPrune&&this._pruneTiles(),E&&(P(this._fadeFrame),this._fadeFrame=ot(this._updateOpacity,this))}},_onOpaqueTile:A,_initContainer:function(){this._container||(this._container=$r("div","leaflet-layer "+(this.options.className||"")),this._updateZIndex(),this.options.opacity<1&&this._updateOpacity(),this.getPane().appendChild(this._container))},_updateLevels:function(){var f=this._tileZoom,E=this.options.maxZoom;if(void 0!==f){for(var D in this._levels)D=Number(D),this._levels[D].el.children.length||D===f?(this._levels[D].el.style.zIndex=E-Math.abs(f-D),this._onUpdateLevel(D)):(pr(this._levels[D].el),this._removeTilesAtZoom(D),this._onRemoveLevel(D),delete this._levels[D]);var j=this._levels[f],mt=this._map;return j||((j=this._levels[f]={}).el=$r("div","leaflet-tile-container leaflet-zoom-animated",this._container),j.el.style.zIndex=E,j.origin=mt.project(mt.unproject(mt.getPixelOrigin()),f).round(),j.zoom=f,this._setZoomTransform(j,mt.getCenter(),mt.getZoom()),this._onCreateLevel(j)),this._level=j,j}},_onUpdateLevel:A,_onRemoveLevel:A,_onCreateLevel:A,_pruneTiles:function(){if(this._map){var f,E,D=this._map.getZoom();if(D>this.options.maxZoom||D<this.options.minZoom)return void this._removeAllTiles();for(f in this._tiles)(E=this._tiles[f]).retain=E.current;for(f in this._tiles)if((E=this._tiles[f]).current&&!E.active){var j=E.coords;this._retainParent(j.x,j.y,j.z,j.z-5)||this._retainChildren(j.x,j.y,j.z,j.z+2)}for(f in this._tiles)this._tiles[f].retain||this._removeTile(f)}},_removeTilesAtZoom:function(f){for(var E in this._tiles)this._tiles[E].coords.z===f&&this._removeTile(E)},_removeAllTiles:function(){for(var f in this._tiles)this._removeTile(f)},_invalidateAll:function(){for(var f in this._levels)pr(this._levels[f].el),this._onRemoveLevel(Number(f)),delete this._levels[f];this._removeAllTiles(),this._tileZoom=void 0},_retainParent:function(f,E,D,j){var mt=Math.floor(f/2),Ft=Math.floor(E/2),ce=D-1,ye=new yt(+mt,+Ft);ye.z=+ce;var Ve=this._tileCoordsToKey(ye),sn=this._tiles[Ve];return sn&&sn.active?(sn.retain=!0,!0):(sn&&sn.loaded&&(sn.retain=!0),ce>j&&this._retainParent(mt,Ft,ce,j))},_retainChildren:function(f,E,D,j){for(var mt=2*f;mt<2*f+2;mt++)for(var Ft=2*E;Ft<2*E+2;Ft++){var ce=new yt(mt,Ft);ce.z=D+1;var ye=this._tileCoordsToKey(ce),Ve=this._tiles[ye];Ve&&Ve.active?Ve.retain=!0:(Ve&&Ve.loaded&&(Ve.retain=!0),D+1<j&&this._retainChildren(mt,Ft,D+1,j))}},_resetView:function(f){var E=f&&(f.pinch||f.flyTo);this._setView(this._map.getCenter(),this._map.getZoom(),E,E)},_animateZoom:function(f){this._setView(f.center,f.zoom,!0,f.noUpdate)},_clampZoom:function(f){var E=this.options;return void 0!==E.minNativeZoom&&f<E.minNativeZoom?E.minNativeZoom:void 0!==E.maxNativeZoom&&E.maxNativeZoom<f?E.maxNativeZoom:f},_setView:function(f,E,D,j){var mt=Math.round(E);mt=void 0!==this.options.maxZoom&&mt>this.options.maxZoom||void 0!==this.options.minZoom&&mt<this.options.minZoom?void 0:this._clampZoom(mt),(!j||this.options.updateWhenZooming&&mt!==this._tileZoom)&&(this._tileZoom=mt,this._abortLoading&&this._abortLoading(),this._updateLevels(),this._resetGrid(),void 0!==mt&&this._update(f),D||this._pruneTiles(),this._noPrune=!!D),this._setZoomTransforms(f,E)},_setZoomTransforms:function(f,E){for(var D in this._levels)this._setZoomTransform(this._levels[D],f,E)},_setZoomTransform:function(f,E,D){var j=this._map.getZoomScale(D,f.zoom),mt=f.origin.multiplyBy(j).subtract(this._map._getNewPixelOrigin(E,D)).round();Dn.any3d?ga(f.el,mt,j):Xn(f.el,mt)},_resetGrid:function(){var f=this._map,E=f.options.crs,D=this._tileSize=this.getTileSize(),j=this._tileZoom,mt=this._map.getPixelWorldBounds(this._tileZoom);mt&&(this._globalTileRange=this._pxBoundsToTileRange(mt)),this._wrapX=E.wrapLng&&!this.options.noWrap&&[Math.floor(f.project([0,E.wrapLng[0]],j).x/D.x),Math.ceil(f.project([0,E.wrapLng[1]],j).x/D.y)],this._wrapY=E.wrapLat&&!this.options.noWrap&&[Math.floor(f.project([E.wrapLat[0],0],j).y/D.x),Math.ceil(f.project([E.wrapLat[1],0],j).y/D.y)]},_onMoveEnd:function(){!this._map||this._map._animatingZoom||this._update()},_getTiledPixelBounds:function(f){var E=this._map,D=E._animatingZoom?Math.max(E._animateToZoom,E.getZoom()):E.getZoom(),j=E.getZoomScale(D,this._tileZoom),mt=E.project(f,this._tileZoom).floor(),Ft=E.getSize().divideBy(2*j);return new Mt(mt.subtract(Ft),mt.add(Ft))},_update:function(f){var E=this._map;if(E){var D=this._clampZoom(E.getZoom());if(void 0===f&&(f=E.getCenter()),void 0!==this._tileZoom){var j=this._getTiledPixelBounds(f),mt=this._pxBoundsToTileRange(j),Ft=mt.getCenter(),ce=[],ye=this.options.keepBuffer,Ve=new Mt(mt.getBottomLeft().subtract([ye,-ye]),mt.getTopRight().add([ye,-ye]));if(!(isFinite(mt.min.x)&&isFinite(mt.min.y)&&isFinite(mt.max.x)&&isFinite(mt.max.y)))throw new Error("Attempted to load an infinite number of tiles");for(var sn in this._tiles){var wn=this._tiles[sn].coords;(wn.z!==this._tileZoom||!Ve.contains(new yt(wn.x,wn.y)))&&(this._tiles[sn].current=!1)}if(Math.abs(D-this._tileZoom)>1)return void this._setView(f,D);for(var Pn=mt.min.y;Pn<=mt.max.y;Pn++)for(var Nr=mt.min.x;Nr<=mt.max.x;Nr++){var yo=new yt(Nr,Pn);if(yo.z=this._tileZoom,this._isValidTile(yo)){var qi=this._tiles[this._tileCoordsToKey(yo)];qi?qi.current=!0:ce.push(yo)}}if(ce.sort(function(Ho,ea){return Ho.distanceTo(Ft)-ea.distanceTo(Ft)}),0!==ce.length){this._loading||(this._loading=!0,this.fire("loading"));var ro=document.createDocumentFragment();for(Nr=0;Nr<ce.length;Nr++)this._addTile(ce[Nr],ro);this._level.el.appendChild(ro)}}}},_isValidTile:function(f){var E=this._map.options.crs;if(!E.infinite){var D=this._globalTileRange;if(!E.wrapLng&&(f.x<D.min.x||f.x>D.max.x)||!E.wrapLat&&(f.y<D.min.y||f.y>D.max.y))return!1}if(!this.options.bounds)return!0;var j=this._tileCoordsToBounds(f);return Bt(this.options.bounds).overlaps(j)},_keyToBounds:function(f){return this._tileCoordsToBounds(this._keyToTileCoords(f))},_tileCoordsToNwSe:function(f){var E=this._map,D=this.getTileSize(),j=f.scaleBy(D),mt=j.add(D);return[E.unproject(j,f.z),E.unproject(mt,f.z)]},_tileCoordsToBounds:function(f){var E=this._tileCoordsToNwSe(f),D=new re(E[0],E[1]);return this.options.noWrap||(D=this._map.wrapLatLngBounds(D)),D},_tileCoordsToKey:function(f){return f.x+":"+f.y+":"+f.z},_keyToTileCoords:function(f){var E=f.split(":"),D=new yt(+E[0],+E[1]);return D.z=+E[2],D},_removeTile:function(f){var E=this._tiles[f];E&&(pr(E.el),delete this._tiles[f],this.fire("tileunload",{tile:E.el,coords:this._keyToTileCoords(f)}))},_initTile:function(f){An(f,"leaflet-tile");var E=this.getTileSize();f.style.width=E.x+"px",f.style.height=E.y+"px",f.onselectstart=A,f.onmousemove=A,Dn.ielt9&&this.options.opacity<1&&er(f,this.options.opacity)},_addTile:function(f,E){var D=this._getTilePos(f),j=this._tileCoordsToKey(f),mt=this.createTile(this._wrapCoords(f),Q(this._tileReady,this,f));this._initTile(mt),this.createTile.length<2&&ot(Q(this._tileReady,this,f,null,mt)),Xn(mt,D),this._tiles[j]={el:mt,coords:f,current:!0},E.appendChild(mt),this.fire("tileloadstart",{tile:mt,coords:f})},_tileReady:function(f,E,D){E&&this.fire("tileerror",{error:E,tile:D,coords:f});var j=this._tileCoordsToKey(f);(D=this._tiles[j])&&(D.loaded=+new Date,this._map._fadeAnimated?(er(D.el,0),P(this._fadeFrame),this._fadeFrame=ot(this._updateOpacity,this)):(D.active=!0,this._pruneTiles()),E||(An(D.el,"leaflet-tile-loaded"),this.fire("tileload",{tile:D.el,coords:f})),this._noTilesToLoad()&&(this._loading=!1,this.fire("load"),Dn.ielt9||!this._map._fadeAnimated?ot(this._pruneTiles,this):setTimeout(Q(this._pruneTiles,this),250)))},_getTilePos:function(f){return f.scaleBy(this.getTileSize()).subtract(this._level.origin)},_wrapCoords:function(f){var E=new yt(this._wrapX?k(f.x,this._wrapX):f.x,this._wrapY?k(f.y,this._wrapY):f.y);return E.z=f.z,E},_pxBoundsToTileRange:function(f){var E=this.getTileSize();return new Mt(f.min.unscaleBy(E).floor(),f.max.unscaleBy(E).ceil().subtract([1,1]))},_noTilesToLoad:function(){for(var f in this._tiles)if(!this._tiles[f].loaded)return!1;return!0}});var ca=Go.extend({options:{minZoom:0,maxZoom:18,subdomains:"abc",errorTileUrl:"",zoomOffset:0,tms:!1,zoomReverse:!1,detectRetina:!1,crossOrigin:!1,referrerPolicy:!1},initialize:function(f,E){this._url=f,(E=it(this,E)).detectRetina&&Dn.retina&&E.maxZoom>0?(E.tileSize=Math.floor(E.tileSize/2),E.zoomReverse?(E.zoomOffset--,E.minZoom=Math.min(E.maxZoom,E.minZoom+1)):(E.zoomOffset++,E.maxZoom=Math.max(E.minZoom,E.maxZoom-1)),E.minZoom=Math.max(0,E.minZoom)):E.zoomReverse?E.minZoom=Math.min(E.maxZoom,E.minZoom):E.maxZoom=Math.max(E.minZoom,E.maxZoom),"string"==typeof E.subdomains&&(E.subdomains=E.subdomains.split("")),this.on("tileunload",this._onTileRemove)},setUrl:function(f,E){return this._url===f&&void 0===E&&(E=!0),this._url=f,E||this.redraw(),this},createTile:function(f,E){var D=document.createElement("img");return Kn(D,"load",Q(this._tileOnLoad,this,E,D)),Kn(D,"error",Q(this._tileOnError,this,E,D)),(this.options.crossOrigin||""===this.options.crossOrigin)&&(D.crossOrigin=!0===this.options.crossOrigin?"":this.options.crossOrigin),"string"==typeof this.options.referrerPolicy&&(D.referrerPolicy=this.options.referrerPolicy),D.alt="",D.src=this.getTileUrl(f),D},getTileUrl:function(f){var E={r:Dn.retina?"@2x":"",s:this._getSubdomain(f),x:f.x,y:f.y,z:this._getZoomForUrl()};if(this._map&&!this._map.options.crs.infinite){var D=this._globalTileRange.max.y-f.y;this.options.tms&&(E.y=D),E["-y"]=D}return st(this._url,V(E,this.options))},_tileOnLoad:function(f,E){Dn.ielt9?setTimeout(Q(f,this,null,E),0):f(null,E)},_tileOnError:function(f,E,D){var j=this.options.errorTileUrl;j&&E.getAttribute("src")!==j&&(E.src=j),f(D,E)},_onTileRemove:function(f){f.tile.onload=null},_getZoomForUrl:function(){var f=this._tileZoom;return this.options.zoomReverse&&(f=this.options.maxZoom-f),f+this.options.zoomOffset},_getSubdomain:function(f){var E=Math.abs(f.x+f.y)%this.options.subdomains.length;return this.options.subdomains[E]},_abortLoading:function(){var f,E;for(f in this._tiles)if(this._tiles[f].coords.z!==this._tileZoom&&((E=this._tiles[f].el).onload=A,E.onerror=A,!E.complete)){E.src=lt;var D=this._tiles[f].coords;pr(E),delete this._tiles[f],this.fire("tileabort",{tile:E,coords:D})}},_removeTile:function(f){var E=this._tiles[f];if(E)return E.el.setAttribute("src",lt),Go.prototype._removeTile.call(this,f)},_tileReady:function(f,E,D){if(this._map&&(!D||D.getAttribute("src")!==lt))return Go.prototype._tileReady.call(this,f,E,D)}});function no(f,E){return new ca(f,E)}var jl=ca.extend({defaultWmsParams:{service:"WMS",request:"GetMap",layers:"",styles:"",format:"image/jpeg",transparent:!1,version:"1.1.1"},options:{crs:null,uppercase:!1},initialize:function(f,E){this._url=f;var D=V({},this.defaultWmsParams);for(var j in E)j in this.options||(D[j]=E[j]);var mt=(E=it(this,E)).detectRetina&&Dn.retina?2:1,Ft=this.getTileSize();D.width=Ft.x*mt,D.height=Ft.y*mt,this.wmsParams=D},onAdd:function(f){this._crs=this.options.crs||f.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version),this.wmsParams[this._wmsVersion>=1.3?"crs":"srs"]=this._crs.code,ca.prototype.onAdd.call(this,f)},getTileUrl:function(f){var E=this._tileCoordsToNwSe(f),D=this._crs,j=It(D.project(E[0]),D.project(E[1])),mt=j.min,Ft=j.max,ce=(this._wmsVersion>=1.3&&this._crs===Fs?[mt.y,mt.x,Ft.y,Ft.x]:[mt.x,mt.y,Ft.x,Ft.y]).join(","),ye=ca.prototype.getTileUrl.call(this,f);return ye+wt(this.wmsParams,ye,this.options.uppercase)+(this.options.uppercase?"&BBOX=":"&bbox=")+ce},setParams:function(f,E){return V(this.wmsParams,f),E||this.redraw(),this}});ca.WMS=jl,no.wms=function ja(f,E){return new jl(f,E)};var Yr=zo.extend({options:{padding:.1},initialize:function(f){it(this,f),R(this),this._layers=this._layers||{}},onAdd:function(){this._container||(this._initContainer(),An(this._container,"leaflet-zoom-animated")),this.getPane().appendChild(this._container),this._update(),this.on("update",this._updatePaths,this)},onRemove:function(){this.off("update",this._updatePaths,this),this._destroyContainer()},getEvents:function(){var f={viewreset:this._reset,zoom:this._onZoom,moveend:this._update,zoomend:this._onZoomEnd};return this._zoomAnimated&&(f.zoomanim=this._onAnimZoom),f},_onAnimZoom:function(f){this._updateTransform(f.center,f.zoom)},_onZoom:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom())},_updateTransform:function(f,E){var D=this._map.getZoomScale(E,this._zoom),j=this._map.getSize().multiplyBy(.5+this.options.padding),mt=this._map.project(this._center,E),Ft=j.multiplyBy(-D).add(mt).subtract(this._map._getNewPixelOrigin(f,E));Dn.any3d?ga(this._container,Ft,D):Xn(this._container,Ft)},_reset:function(){for(var f in this._update(),this._updateTransform(this._center,this._zoom),this._layers)this._layers[f]._reset()},_onZoomEnd:function(){for(var f in this._layers)this._layers[f]._project()},_updatePaths:function(){for(var f in this._layers)this._layers[f]._update()},_update:function(){var f=this.options.padding,E=this._map.getSize(),D=this._map.containerPointToLayerPoint(E.multiplyBy(-f)).round();this._bounds=new Mt(D,D.add(E.multiplyBy(1+2*f)).round()),this._center=this._map.getCenter(),this._zoom=this._map.getZoom()}}),ha=Yr.extend({options:{tolerance:0},getEvents:function(){var f=Yr.prototype.getEvents.call(this);return f.viewprereset=this._onViewPreReset,f},_onViewPreReset:function(){this._postponeUpdatePaths=!0},onAdd:function(){Yr.prototype.onAdd.call(this),this._draw()},_initContainer:function(){var f=this._container=document.createElement("canvas");Kn(f,"mousemove",this._onMouseMove,this),Kn(f,"click dblclick mousedown mouseup contextmenu",this._onClick,this),Kn(f,"mouseout",this._handleMouseOut,this),f._leaflet_disable_events=!0,this._ctx=f.getContext("2d")},_destroyContainer:function(){P(this._redrawRequest),delete this._ctx,pr(this._container),wr(this._container),delete this._container},_updatePaths:function(){if(!this._postponeUpdatePaths){for(var E in this._redrawBounds=null,this._layers)this._layers[E]._update();this._redraw()}},_update:function(){if(!this._map._animatingZoom||!this._bounds){Yr.prototype._update.call(this);var f=this._bounds,E=this._container,D=f.getSize(),j=Dn.retina?2:1;Xn(E,f.min),E.width=j*D.x,E.height=j*D.y,E.style.width=D.x+"px",E.style.height=D.y+"px",Dn.retina&&this._ctx.scale(2,2),this._ctx.translate(-f.min.x,-f.min.y),this.fire("update")}},_reset:function(){Yr.prototype._reset.call(this),this._postponeUpdatePaths&&(this._postponeUpdatePaths=!1,this._updatePaths())},_initPath:function(f){this._updateDashArray(f),this._layers[R(f)]=f;var E=f._order={layer:f,prev:this._drawLast,next:null};this._drawLast&&(this._drawLast.next=E),this._drawLast=E,this._drawFirst=this._drawFirst||this._drawLast},_addPath:function(f){this._requestRedraw(f)},_removePath:function(f){var E=f._order,D=E.next,j=E.prev;D?D.prev=j:this._drawLast=j,j?j.next=D:this._drawFirst=D,delete f._order,delete this._layers[R(f)],this._requestRedraw(f)},_updatePath:function(f){this._extendRedrawBounds(f),f._project(),f._update(),this._requestRedraw(f)},_updateStyle:function(f){this._updateDashArray(f),this._requestRedraw(f)},_updateDashArray:function(f){if("string"==typeof f.options.dashArray){var j,mt,E=f.options.dashArray.split(/[, ]+/),D=[];for(mt=0;mt<E.length;mt++){if(j=Number(E[mt]),isNaN(j))return;D.push(j)}f.options._dashArray=D}else f.options._dashArray=f.options.dashArray},_requestRedraw:function(f){this._map&&(this._extendRedrawBounds(f),this._redrawRequest=this._redrawRequest||ot(this._redraw,this))},_extendRedrawBounds:function(f){if(f._pxBounds){var E=(f.options.weight||0)+1;this._redrawBounds=this._redrawBounds||new Mt,this._redrawBounds.extend(f._pxBounds.min.subtract([E,E])),this._redrawBounds.extend(f._pxBounds.max.add([E,E]))}},_redraw:function(){this._redrawRequest=null,this._redrawBounds&&(this._redrawBounds.min._floor(),this._redrawBounds.max._ceil()),this._clear(),this._draw(),this._redrawBounds=null},_clear:function(){var f=this._redrawBounds;if(f){var E=f.getSize();this._ctx.clearRect(f.min.x,f.min.y,E.x,E.y)}else this._ctx.save(),this._ctx.setTransform(1,0,0,1,0,0),this._ctx.clearRect(0,0,this._container.width,this._container.height),this._ctx.restore()},_draw:function(){var f,E=this._redrawBounds;if(this._ctx.save(),E){var D=E.getSize();this._ctx.beginPath(),this._ctx.rect(E.min.x,E.min.y,D.x,D.y),this._ctx.clip()}this._drawing=!0;for(var j=this._drawFirst;j;j=j.next)f=j.layer,(!E||f._pxBounds&&f._pxBounds.intersects(E))&&f._updatePath();this._drawing=!1,this._ctx.restore()},_updatePoly:function(f,E){if(this._drawing){var D,j,mt,Ft,ce=f._parts,ye=ce.length,Ve=this._ctx;if(ye){for(Ve.beginPath(),D=0;D<ye;D++){for(j=0,mt=ce[D].length;j<mt;j++)Ve[j?"lineTo":"moveTo"]((Ft=ce[D][j]).x,Ft.y);E&&Ve.closePath()}this._fillStroke(Ve,f)}}},_updateCircle:function(f){if(this._drawing&&!f._empty()){var E=f._point,D=this._ctx,j=Math.max(Math.round(f._radius),1),mt=(Math.max(Math.round(f._radiusY),1)||j)/j;1!==mt&&(D.save(),D.scale(1,mt)),D.beginPath(),D.arc(E.x,E.y/mt,j,0,2*Math.PI,!1),1!==mt&&D.restore(),this._fillStroke(D,f)}},_fillStroke:function(f,E){var D=E.options;D.fill&&(f.globalAlpha=D.fillOpacity,f.fillStyle=D.fillColor||D.color,f.fill(D.fillRule||"evenodd")),D.stroke&&0!==D.weight&&(f.setLineDash&&f.setLineDash(E.options&&E.options._dashArray||[]),f.globalAlpha=D.opacity,f.lineWidth=D.weight,f.strokeStyle=D.color,f.lineCap=D.lineCap,f.lineJoin=D.lineJoin,f.stroke())},_onClick:function(f){for(var D,j,E=this._map.mouseEventToLayerPoint(f),mt=this._drawFirst;mt;mt=mt.next)(D=mt.layer).options.interactive&&D._containsPoint(E)&&("click"!==f.type&&"preclick"!==f.type||!this._map._draggableMoved(D))&&(j=D);this._fireEvent(!!j&&[j],f)},_onMouseMove:function(f){if(this._map&&!this._map.dragging.moving()&&!this._map._animatingZoom){var E=this._map.mouseEventToLayerPoint(f);this._handleMouseHover(f,E)}},_handleMouseOut:function(f){var E=this._hoveredLayer;E&&(Gr(this._container,"leaflet-interactive"),this._fireEvent([E],f,"mouseout"),this._hoveredLayer=null,this._mouseHoverThrottled=!1)},_handleMouseHover:function(f,E){if(!this._mouseHoverThrottled){for(var D,j,mt=this._drawFirst;mt;mt=mt.next)(D=mt.layer).options.interactive&&D._containsPoint(E)&&(j=D);j!==this._hoveredLayer&&(this._handleMouseOut(f),j&&(An(this._container,"leaflet-interactive"),this._fireEvent([j],f,"mouseover"),this._hoveredLayer=j)),this._fireEvent(!!this._hoveredLayer&&[this._hoveredLayer],f),this._mouseHoverThrottled=!0,setTimeout(Q(function(){this._mouseHoverThrottled=!1},this),32)}},_fireEvent:function(f,E,D){this._map._fireDOMEvent(E,D||E.type,f)},_bringToFront:function(f){var E=f._order;if(E){var D=E.next,j=E.prev;if(!D)return;D.prev=j,j?j.next=D:D&&(this._drawFirst=D),E.prev=this._drawLast,this._drawLast.next=E,E.next=null,this._drawLast=E,this._requestRedraw(f)}},_bringToBack:function(f){var E=f._order;if(E){var D=E.next,j=E.prev;if(!j)return;j.next=D,D?D.prev=j:j&&(this._drawLast=j),E.prev=null,E.next=this._drawFirst,this._drawFirst.prev=E,this._drawFirst=E,this._requestRedraw(f)}}});function yu(f){return Dn.canvas?new ha(f):null}var or=function(){try{return document.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(f){return document.createElement("<lvml:"+f+' class="lvml">')}}catch{}return function(f){return document.createElement("<"+f+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}(),bs={_initContainer:function(){this._container=$r("div","leaflet-vml-container")},_update:function(){this._map._animatingZoom||(Yr.prototype._update.call(this),this.fire("update"))},_initPath:function(f){var E=f._container=or("shape");An(E,"leaflet-vml-shape "+(this.options.className||"")),E.coordsize="1 1",f._path=or("path"),E.appendChild(f._path),this._updateStyle(f),this._layers[R(f)]=f},_addPath:function(f){var E=f._container;this._container.appendChild(E),f.options.interactive&&f.addInteractiveTarget(E)},_removePath:function(f){var E=f._container;pr(E),f.removeInteractiveTarget(E),delete this._layers[R(f)]},_updateStyle:function(f){var E=f._stroke,D=f._fill,j=f.options,mt=f._container;mt.stroked=!!j.stroke,mt.filled=!!j.fill,j.stroke?(E||(E=f._stroke=or("stroke")),mt.appendChild(E),E.weight=j.weight+"px",E.color=j.color,E.opacity=j.opacity,E.dashStyle=j.dashArray?et(j.dashArray)?j.dashArray.join(" "):j.dashArray.replace(/( *, *)/g," "):"",E.endcap=j.lineCap.replace("butt","flat"),E.joinstyle=j.lineJoin):E&&(mt.removeChild(E),f._stroke=null),j.fill?(D||(D=f._fill=or("fill")),mt.appendChild(D),D.color=j.fillColor||j.color,D.opacity=j.fillOpacity):D&&(mt.removeChild(D),f._fill=null)},_updateCircle:function(f){var E=f._point.round(),D=Math.round(f._radius),j=Math.round(f._radiusY||D);this._setPath(f,f._empty()?"M0 0":"AL "+E.x+","+E.y+" "+D+","+j+" 0,23592600")},_setPath:function(f,E){f._path.v=E},_bringToFront:function(f){Xs(f._container)},_bringToBack:function(f){Wa(f._container)}},Tr=Dn.vml?or:ne,ri=Yr.extend({_initContainer:function(){this._container=Tr("svg"),this._container.setAttribute("pointer-events","none"),this._rootGroup=Tr("g"),this._container.appendChild(this._rootGroup)},_destroyContainer:function(){pr(this._container),wr(this._container),delete this._container,delete this._rootGroup,delete this._svgSize},_update:function(){if(!this._map._animatingZoom||!this._bounds){Yr.prototype._update.call(this);var f=this._bounds,E=f.getSize(),D=this._container;(!this._svgSize||!this._svgSize.equals(E))&&(this._svgSize=E,D.setAttribute("width",E.x),D.setAttribute("height",E.y)),Xn(D,f.min),D.setAttribute("viewBox",[f.min.x,f.min.y,E.x,E.y].join(" ")),this.fire("update")}},_initPath:function(f){var E=f._path=Tr("path");f.options.className&&An(E,f.options.className),f.options.interactive&&An(E,"leaflet-interactive"),this._updateStyle(f),this._layers[R(f)]=f},_addPath:function(f){this._rootGroup||this._initContainer(),this._rootGroup.appendChild(f._path),f.addInteractiveTarget(f._path)},_removePath:function(f){pr(f._path),f.removeInteractiveTarget(f._path),delete this._layers[R(f)]},_updatePath:function(f){f._project(),f._update()},_updateStyle:function(f){var E=f._path,D=f.options;E&&(D.stroke?(E.setAttribute("stroke",D.color),E.setAttribute("stroke-opacity",D.opacity),E.setAttribute("stroke-width",D.weight),E.setAttribute("stroke-linecap",D.lineCap),E.setAttribute("stroke-linejoin",D.lineJoin),D.dashArray?E.setAttribute("stroke-dasharray",D.dashArray):E.removeAttribute("stroke-dasharray"),D.dashOffset?E.setAttribute("stroke-dashoffset",D.dashOffset):E.removeAttribute("stroke-dashoffset")):E.setAttribute("stroke","none"),D.fill?(E.setAttribute("fill",D.fillColor||D.color),E.setAttribute("fill-opacity",D.fillOpacity),E.setAttribute("fill-rule",D.fillRule||"evenodd")):E.setAttribute("fill","none"))},_updatePoly:function(f,E){this._setPath(f,pe(f._parts,E))},_updateCircle:function(f){var E=f._point,D=Math.max(Math.round(f._radius),1),mt="a"+D+","+(Math.max(Math.round(f._radiusY),1)||D)+" 0 1,0 ",Ft=f._empty()?"M0 0":"M"+(E.x-D)+","+E.y+mt+2*D+",0 "+mt+2*-D+",0 ";this._setPath(f,Ft)},_setPath:function(f,E){f._path.setAttribute("d",E)},_bringToFront:function(f){Xs(f._path)},_bringToBack:function(f){Wa(f._path)}});function ds(f){return Dn.svg||Dn.vml?new ri(f):null}Dn.vml&&ri.include(bs),ae.include({getRenderer:function(f){var E=f.options.renderer||this._getPaneRenderer(f.options.pane)||this.options.renderer||this._renderer;return E||(E=this._renderer=this._createRenderer()),this.hasLayer(E)||this.addLayer(E),E},_getPaneRenderer:function(f){if("overlayPane"===f||void 0===f)return!1;var E=this._paneRenderers[f];return void 0===E&&(E=this._createRenderer({pane:f}),this._paneRenderers[f]=E),E},_createRenderer:function(f){return this.options.preferCanvas&&yu(f)||ds(f)}});var gt=La.extend({initialize:function(f,E){La.prototype.initialize.call(this,this._boundsToLatLngs(f),E)},setBounds:function(f){return this.setLatLngs(this._boundsToLatLngs(f))},_boundsToLatLngs:function(f){return[(f=Bt(f)).getSouthWest(),f.getNorthWest(),f.getNorthEast(),f.getSouthEast()]}});ri.create=Tr,ri.pointsToPath=pe,Ga.geometryToLayer=pl,Ga.coordsToLatLng=Uo,Ga.coordsToLatLngs=Ts,Ga.latLngToCoords=Du,Ga.latLngsToCoords=Bs,Ga.getFeature=Wo,Ga.asFeature=Ea,ae.mergeOptions({boxZoom:!0});var _t=tn.extend({initialize:function(f){this._map=f,this._container=f._container,this._pane=f._panes.overlayPane,this._resetStateTimeout=0,f.on("unload",this._destroy,this)},addHooks:function(){Kn(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){wr(this._container,"mousedown",this._onMouseDown,this)},moved:function(){return this._moved},_destroy:function(){pr(this._pane),delete this._pane},_resetState:function(){this._resetStateTimeout=0,this._moved=!1},_clearDeferredResetState:function(){0!==this._resetStateTimeout&&(clearTimeout(this._resetStateTimeout),this._resetStateTimeout=0)},_onMouseDown:function(f){if(!f.shiftKey||1!==f.which&&1!==f.button)return!1;this._clearDeferredResetState(),this._resetState(),Yi(),Fn(),this._startPoint=this._map.mouseEventToContainerPoint(f),Kn(document,{contextmenu:z,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseMove:function(f){this._moved||(this._moved=!0,this._box=$r("div","leaflet-zoom-box",this._container),An(this._container,"leaflet-crosshair"),this._map.fire("boxzoomstart")),this._point=this._map.mouseEventToContainerPoint(f);var E=new Mt(this._point,this._startPoint),D=E.getSize();Xn(this._box,E.min),this._box.style.width=D.x+"px",this._box.style.height=D.y+"px"},_finish:function(){this._moved&&(pr(this._box),Gr(this._container,"leaflet-crosshair")),Ra(),Ss(),wr(document,{contextmenu:z,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseUp:function(f){if((1===f.which||1===f.button)&&(this._finish(),this._moved)){this._clearDeferredResetState(),this._resetStateTimeout=setTimeout(Q(this._resetState,this),0);var E=new re(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point));this._map.fitBounds(E).fire("boxzoomend",{boxZoomBounds:E})}},_onKeyDown:function(f){27===f.keyCode&&(this._finish(),this._clearDeferredResetState(),this._resetState())}});ae.addInitHook("addHandler","boxZoom",_t),ae.mergeOptions({doubleClickZoom:!0});var Nt=tn.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(f){var E=this._map,D=E.getZoom(),j=E.options.zoomDelta,mt=f.originalEvent.shiftKey?D-j:D+j;"center"===E.options.doubleClickZoom?E.setZoom(mt):E.setZoomAround(f.containerPoint,mt)}});ae.addInitHook("addHandler","doubleClickZoom",Nt),ae.mergeOptions({dragging:!0,inertia:!0,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,easeLinearity:.2,worldCopyJump:!1,maxBoundsViscosity:0});var Kt=tn.extend({addHooks:function(){if(!this._draggable){var f=this._map;this._draggable=new Qi(f._mapPane,f._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),this._draggable.on("predrag",this._onPreDragLimit,this),f.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDragWrap,this),f.on("zoomend",this._onZoomEnd,this),f.whenReady(this._onZoomEnd,this))}An(this._map._container,"leaflet-grab leaflet-touch-drag"),this._draggable.enable(),this._positions=[],this._times=[]},removeHooks:function(){Gr(this._map._container,"leaflet-grab"),Gr(this._map._container,"leaflet-touch-drag"),this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},moving:function(){return this._draggable&&this._draggable._moving},_onDragStart:function(){var f=this._map;if(f._stop(),this._map.options.maxBounds&&this._map.options.maxBoundsViscosity){var E=Bt(this._map.options.maxBounds);this._offsetLimit=It(this._map.latLngToContainerPoint(E.getNorthWest()).multiplyBy(-1),this._map.latLngToContainerPoint(E.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),this._viscosity=Math.min(1,Math.max(0,this._map.options.maxBoundsViscosity))}else this._offsetLimit=null;f.fire("movestart").fire("dragstart"),f.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(f){if(this._map.options.inertia){var E=this._lastTime=+new Date,D=this._lastPos=this._draggable._absPos||this._draggable._newPos;this._positions.push(D),this._times.push(E),this._prunePositions(E)}this._map.fire("move",f).fire("drag",f)},_prunePositions:function(f){for(;this._positions.length>1&&f-this._times[0]>50;)this._positions.shift(),this._times.shift()},_onZoomEnd:function(){var f=this._map.getSize().divideBy(2),E=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=E.subtract(f).x,this._worldWidth=this._map.getPixelWorldBounds().getSize().x},_viscousLimit:function(f,E){return f-(f-E)*this._viscosity},_onPreDragLimit:function(){if(this._viscosity&&this._offsetLimit){var f=this._draggable._newPos.subtract(this._draggable._startPos),E=this._offsetLimit;f.x<E.min.x&&(f.x=this._viscousLimit(f.x,E.min.x)),f.y<E.min.y&&(f.y=this._viscousLimit(f.y,E.min.y)),f.x>E.max.x&&(f.x=this._viscousLimit(f.x,E.max.x)),f.y>E.max.y&&(f.y=this._viscousLimit(f.y,E.max.y)),this._draggable._newPos=this._draggable._startPos.add(f)}},_onPreDragWrap:function(){var f=this._worldWidth,E=Math.round(f/2),D=this._initialWorldOffset,j=this._draggable._newPos.x,mt=(j-E+D)%f+E-D,Ft=(j+E+D)%f-E-D,ce=Math.abs(mt+D)<Math.abs(Ft+D)?mt:Ft;this._draggable._absPos=this._draggable._newPos.clone(),this._draggable._newPos.x=ce},_onDragEnd:function(f){var E=this._map,D=E.options,j=!D.inertia||f.noInertia||this._times.length<2;if(E.fire("dragend",f),j)E.fire("moveend");else{this._prunePositions(+new Date);var mt=this._lastPos.subtract(this._positions[0]),ce=D.easeLinearity,ye=mt.multiplyBy(ce/((this._lastTime-this._times[0])/1e3)),Ve=ye.distanceTo([0,0]),sn=Math.min(D.inertiaMaxSpeed,Ve),wn=ye.multiplyBy(sn/Ve),Pn=sn/(D.inertiaDeceleration*ce),Nr=wn.multiplyBy(-Pn/2).round();Nr.x||Nr.y?(Nr=E._limitOffset(Nr,E.options.maxBounds),ot(function(){E.panBy(Nr,{duration:Pn,easeLinearity:ce,noMoveStart:!0,animate:!0})})):E.fire("moveend")}}});ae.addInitHook("addHandler","dragging",Kt),ae.mergeOptions({keyboard:!0,keyboardPanDelta:80});var de=tn.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,54,173]},initialize:function(f){this._map=f,this._setPanDelta(f.options.keyboardPanDelta),this._setZoomDelta(f.options.zoomDelta)},addHooks:function(){var f=this._map._container;f.tabIndex<=0&&(f.tabIndex="0"),Kn(f,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.on({focus:this._addHooks,blur:this._removeHooks},this)},removeHooks:function(){this._removeHooks(),wr(this._map._container,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.off({focus:this._addHooks,blur:this._removeHooks},this)},_onMouseDown:function(){if(!this._focused){var f=document.body,E=document.documentElement,D=f.scrollTop||E.scrollTop,j=f.scrollLeft||E.scrollLeft;this._map._container.focus(),window.scrollTo(j,D)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanDelta:function(f){var j,mt,E=this._panKeys={},D=this.keyCodes;for(j=0,mt=D.left.length;j<mt;j++)E[D.left[j]]=[-1*f,0];for(j=0,mt=D.right.length;j<mt;j++)E[D.right[j]]=[f,0];for(j=0,mt=D.down.length;j<mt;j++)E[D.down[j]]=[0,f];for(j=0,mt=D.up.length;j<mt;j++)E[D.up[j]]=[0,-1*f]},_setZoomDelta:function(f){var j,mt,E=this._zoomKeys={},D=this.keyCodes;for(j=0,mt=D.zoomIn.length;j<mt;j++)E[D.zoomIn[j]]=f;for(j=0,mt=D.zoomOut.length;j<mt;j++)E[D.zoomOut[j]]=-f},_addHooks:function(){Kn(document,"keydown",this._onKeyDown,this)},_removeHooks:function(){wr(document,"keydown",this._onKeyDown,this)},_onKeyDown:function(f){if(!(f.altKey||f.ctrlKey||f.metaKey)){var j,E=f.keyCode,D=this._map;if(E in this._panKeys){if(!D._panAnim||!D._panAnim._inProgress)if(j=this._panKeys[E],f.shiftKey&&(j=xt(j).multiplyBy(3)),D.options.maxBounds&&(j=D._limitOffset(xt(j),D.options.maxBounds)),D.options.worldCopyJump){var mt=D.wrapLatLng(D.unproject(D.project(D.getCenter()).add(j)));D.panTo(mt)}else D.panBy(j)}else if(E in this._zoomKeys)D.setZoom(D.getZoom()+(f.shiftKey?3:1)*this._zoomKeys[E]);else{if(27!==E||!D._popup||!D._popup.options.closeOnEscapeKey)return;D.closePopup()}z(f)}}});ae.addInitHook("addHandler","keyboard",de),ae.mergeOptions({scrollWheelZoom:!0,wheelDebounceTime:40,wheelPxPerZoomLevel:60});var Ee=tn.extend({addHooks:function(){Kn(this._map._container,"wheel",this._onWheelScroll,this),this._delta=0},removeHooks:function(){wr(this._map._container,"wheel",this._onWheelScroll,this)},_onWheelScroll:function(f){var E=bt(f),D=this._map.options.wheelDebounceTime;this._delta+=E,this._lastMousePos=this._map.mouseEventToContainerPoint(f),this._startTime||(this._startTime=+new Date);var j=Math.max(D-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(Q(this._performZoom,this),j),z(f)},_performZoom:function(){var f=this._map,E=f.getZoom(),D=this._map.options.zoomSnap||0;f._stop();var mt=4*Math.log(2/(1+Math.exp(-Math.abs(this._delta/(4*this._map.options.wheelPxPerZoomLevel)))))/Math.LN2,Ft=D?Math.ceil(mt/D)*D:mt,ce=f._limitZoom(E+(this._delta>0?Ft:-Ft))-E;this._delta=0,this._startTime=null,ce&&("center"===f.options.scrollWheelZoom?f.setZoom(E+ce):f.setZoomAround(this._lastMousePos,E+ce))}});ae.addInitHook("addHandler","scrollWheelZoom",Ee);ae.mergeOptions({tapHold:Dn.touchNative&&Dn.safari&&Dn.mobile,tapTolerance:15});var xe=tn.extend({addHooks:function(){Kn(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){wr(this._map._container,"touchstart",this._onDown,this)},_onDown:function(f){if(clearTimeout(this._holdTimeout),1===f.touches.length){var E=f.touches[0];this._startPos=this._newPos=new yt(E.clientX,E.clientY),this._holdTimeout=setTimeout(Q(function(){this._cancel(),this._isTapValid()&&(Kn(document,"touchend",_e),Kn(document,"touchend touchcancel",this._cancelClickPrevent),this._simulateEvent("contextmenu",E))},this),600),Kn(document,"touchend touchcancel contextmenu",this._cancel,this),Kn(document,"touchmove",this._onMove,this)}},_cancelClickPrevent:function f(){wr(document,"touchend",_e),wr(document,"touchend touchcancel",f)},_cancel:function(){clearTimeout(this._holdTimeout),wr(document,"touchend touchcancel contextmenu",this._cancel,this),wr(document,"touchmove",this._onMove,this)},_onMove:function(f){var E=f.touches[0];this._newPos=new yt(E.clientX,E.clientY)},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_simulateEvent:function(f,E){var D=new MouseEvent(f,{bubbles:!0,cancelable:!0,view:window,screenX:E.screenX,screenY:E.screenY,clientX:E.clientX,clientY:E.clientY});D._simulated=!0,E.target.dispatchEvent(D)}});ae.addInitHook("addHandler","tapHold",xe),ae.mergeOptions({touchZoom:Dn.touch,bounceAtZoomLimits:!0});var Pe=tn.extend({addHooks:function(){An(this._map._container,"leaflet-touch-zoom"),Kn(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){Gr(this._map._container,"leaflet-touch-zoom"),wr(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(f){var E=this._map;if(f.touches&&2===f.touches.length&&!E._animatingZoom&&!this._zooming){var D=E.mouseEventToContainerPoint(f.touches[0]),j=E.mouseEventToContainerPoint(f.touches[1]);this._centerPoint=E.getSize()._divideBy(2),this._startLatLng=E.containerPointToLatLng(this._centerPoint),"center"!==E.options.touchZoom&&(this._pinchStartLatLng=E.containerPointToLatLng(D.add(j)._divideBy(2))),this._startDist=D.distanceTo(j),this._startZoom=E.getZoom(),this._moved=!1,this._zooming=!0,E._stop(),Kn(document,"touchmove",this._onTouchMove,this),Kn(document,"touchend touchcancel",this._onTouchEnd,this),_e(f)}},_onTouchMove:function(f){if(f.touches&&2===f.touches.length&&this._zooming){var E=this._map,D=E.mouseEventToContainerPoint(f.touches[0]),j=E.mouseEventToContainerPoint(f.touches[1]),mt=D.distanceTo(j)/this._startDist;if(this._zoom=E.getScaleZoom(mt,this._startZoom),!E.options.bounceAtZoomLimits&&(this._zoom<E.getMinZoom()&&mt<1||this._zoom>E.getMaxZoom()&&mt>1)&&(this._zoom=E._limitZoom(this._zoom)),"center"===E.options.touchZoom){if(this._center=this._startLatLng,1===mt)return}else{var Ft=D._add(j)._divideBy(2)._subtract(this._centerPoint);if(1===mt&&0===Ft.x&&0===Ft.y)return;this._center=E.unproject(E.project(this._pinchStartLatLng,this._zoom).subtract(Ft),this._zoom)}this._moved||(E._moveStart(!0,!1),this._moved=!0),P(this._animRequest);var ce=Q(E._move,E,this._center,this._zoom,{pinch:!0,round:!1},void 0);this._animRequest=ot(ce,this,!0),_e(f)}},_onTouchEnd:function(){this._moved&&this._zooming?(this._zooming=!1,P(this._animRequest),wr(document,"touchmove",this._onTouchMove,this),wr(document,"touchend touchcancel",this._onTouchEnd,this),this._map.options.zoomAnimation?this._map._animateZoom(this._center,this._map._limitZoom(this._zoom),!0,this._map.options.zoomSnap):this._map._resetView(this._center,this._map._limitZoom(this._zoom))):this._zooming=!1}});ae.addInitHook("addHandler","touchZoom",Pe),ae.BoxZoom=_t,ae.DoubleClickZoom=Nt,ae.Drag=Kt,ae.Keyboard=de,ae.ScrollWheelZoom=Ee,ae.TapHold=xe,ae.TouchZoom=Pe,y.Bounds=Mt,y.Browser=Dn,y.CRS=se,y.Canvas=ha,y.Circle=Vo,y.CircleMarker=Ys,y.Class=nt,y.Control=Ye,y.DivIcon=wl,y.DivOverlay=Io,y.DomEvent=Yt,y.DomUtil=ai,y.Draggable=Qi,y.Evented=Ct,y.FeatureGroup=qo,y.GeoJSON=Ga,y.GridLayer=Go,y.Handler=tn,y.Icon=Ao,y.ImageOverlay=Ca,y.LatLng=ee,y.LatLngBounds=re,y.Layer=zo,y.LayerGroup=va,y.LineUtil=Br,y.Map=ae,y.Marker=ls,y.Mixin=Iu,y.Path=iu,y.Point=yt,y.PolyUtil=Oc,y.Polygon=La,y.Polyline=mi,y.Popup=cs,y.PosAnimation=kt,y.Projection=ru,y.Rectangle=gt,y.Renderer=Yr,y.SVG=ri,y.SVGOverlay=ka,y.TileLayer=ca,y.Tooltip=la,y.Transformation=Ue,y.Util=at,y.VideoOverlay=ta,y.bind=Q,y.bounds=It,y.canvas=yu,y.circle=function xa(f,E,D){return new Vo(f,E,D)},y.circleMarker=function $s(f,E){return new Ys(f,E)},y.control=$e,y.divIcon=function Nu(f){return new wl(f)},y.extend=V,y.featureGroup=function(f,E){return new qo(f,E)},y.geoJSON=mu,y.geoJson=Ha,y.gridLayer=function hs(f){return new Go(f)},y.icon=function Mn(f){return new Ao(f)},y.imageOverlay=function(f,E,D){return new Ca(f,E,D)},y.latLng=jt,y.latLngBounds=Bt,y.layerGroup=function(f,E){return new va(f,E)},y.map=function nn(f,E){return new ae(f,E)},y.marker=function mo(f,E){return new ls(f,E)},y.point=xt,y.polygon=function Su(f,E){return new La(f,E)},y.polyline=function yi(f,E){return new mi(f,E)},y.popup=function(f,E){return new cs(f,E)},y.rectangle=function ct(f,E){return new gt(f,E)},y.setOptions=it,y.stamp=R,y.svg=ds,y.svgOverlay=function gu(f,E,D){return new ka(f,E,D)},y.tileLayer=no,y.tooltip=function(f,E){return new la(f,E)},y.transformation=De,y.version="1.9.4",y.videoOverlay=function go(f,E,D){return new ta(f,E,D)};var fn=window.L;y.noConflict=function(){return window.L=fn,this},window.L=y}(ut)},186:Lt=>{Lt.exports=y;var ut=null;try{ut=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function y(ot,P,at){this.low=0|ot,this.high=0|P,this.unsigned=!!at}function $(ot){return!0===(ot&&ot.__isLong__)}Object.defineProperty(y.prototype,"__isLong__",{value:!0}),y.isLong=$;var V={},H={};function Q(ot,P){var at,nt,Gt;return P?(Gt=0<=(ot>>>=0)&&ot<256)&&(nt=H[ot])?nt:(at=R(ot,(0|ot)<0?-1:0,!0),Gt&&(H[ot]=at),at):(Gt=-128<=(ot|=0)&&ot<128)&&(nt=V[ot])?nt:(at=R(ot,ot<0?-1:0,!1),Gt&&(V[ot]=at),at)}function Y(ot,P){if(isNaN(ot))return P?et:st;if(P){if(ot<0)return et;if(ot>=it)return ft}else{if(ot<=-wt)return pt;if(ot+1>=wt)return q}return ot<0?Y(-ot,P).neg():R(ot%G|0,ot/G|0,P)}function R(ot,P,at){return new y(ot,P,at)}y.fromInt=Q,y.fromNumber=Y,y.fromBits=R;var W=Math.pow;function k(ot,P,at){if(0===ot.length)throw Error("empty string");if("NaN"===ot||"Infinity"===ot||"+Infinity"===ot||"-Infinity"===ot)return st;if("number"==typeof P?(at=P,P=!1):P=!!P,(at=at||10)<2||36<at)throw RangeError("radix");var nt;if((nt=ot.indexOf("-"))>0)throw Error("interior hyphen");if(0===nt)return k(ot.substring(1),P,at).neg();for(var Gt=Y(W(at,8)),O=st,Ct=0;Ct<ot.length;Ct+=8){var yt=Math.min(8,ot.length-Ct),vt=parseInt(ot.substring(Ct,Ct+yt),at);if(yt<8){var xt=Y(W(at,yt));O=O.mul(xt).add(Y(vt))}else O=(O=O.mul(Gt)).add(Y(vt))}return O.unsigned=P,O}function A(ot,P){return"number"==typeof ot?Y(ot,P):"string"==typeof ot?k(ot,P):R(ot.low,ot.high,"boolean"==typeof P?P:ot.unsigned)}y.fromString=k,y.fromValue=A;var G=4294967296,it=G*G,wt=it/2,K=Q(1<<24),st=Q(0);y.ZERO=st;var et=Q(0,!0);y.UZERO=et;var dt=Q(1);y.ONE=dt;var lt=Q(1,!0);y.UONE=lt;var St=Q(-1);y.NEG_ONE=St;var q=R(-1,2147483647,!1);y.MAX_VALUE=q;var ft=R(-1,-1,!0);y.MAX_UNSIGNED_VALUE=ft;var pt=R(0,-2147483648,!1);y.MIN_VALUE=pt;var B=y.prototype;B.toInt=function(){return this.unsigned?this.low>>>0:this.low},B.toNumber=function(){return this.unsigned?(this.high>>>0)*G+(this.low>>>0):this.high*G+(this.low>>>0)},B.toString=function(P){if((P=P||10)<2||36<P)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(pt)){var at=Y(P),nt=this.div(at),Gt=nt.mul(at).sub(this);return nt.toString(P)+Gt.toInt().toString(P)}return"-"+this.neg().toString(P)}for(var O=Y(W(P,6),this.unsigned),Ct=this,yt="";;){var vt=Ct.div(O),Mt=(Ct.sub(vt.mul(O)).toInt()>>>0).toString(P);if((Ct=vt).isZero())return Mt+yt;for(;Mt.length<6;)Mt="0"+Mt;yt=""+Mt+yt}},B.getHighBits=function(){return this.high},B.getHighBitsUnsigned=function(){return this.high>>>0},B.getLowBits=function(){return this.low},B.getLowBitsUnsigned=function(){return this.low>>>0},B.getNumBitsAbs=function(){if(this.isNegative())return this.eq(pt)?64:this.neg().getNumBitsAbs();for(var P=0!=this.high?this.high:this.low,at=31;at>0&&!(P&1<<at);at--);return 0!=this.high?at+33:at+1},B.isZero=function(){return 0===this.high&&0===this.low},B.eqz=B.isZero,B.isNegative=function(){return!this.unsigned&&this.high<0},B.isPositive=function(){return this.unsigned||this.high>=0},B.isOdd=function(){return 1==(1&this.low)},B.isEven=function(){return 0==(1&this.low)},B.equals=function(P){return $(P)||(P=A(P)),(this.unsigned===P.unsigned||this.high>>>31!=1||P.high>>>31!=1)&&this.high===P.high&&this.low===P.low},B.eq=B.equals,B.notEquals=function(P){return!this.eq(P)},B.neq=B.notEquals,B.ne=B.notEquals,B.lessThan=function(P){return this.comp(P)<0},B.lt=B.lessThan,B.lessThanOrEqual=function(P){return this.comp(P)<=0},B.lte=B.lessThanOrEqual,B.le=B.lessThanOrEqual,B.greaterThan=function(P){return this.comp(P)>0},B.gt=B.greaterThan,B.greaterThanOrEqual=function(P){return this.comp(P)>=0},B.gte=B.greaterThanOrEqual,B.ge=B.greaterThanOrEqual,B.compare=function(P){if($(P)||(P=A(P)),this.eq(P))return 0;var at=this.isNegative(),nt=P.isNegative();return at&&!nt?-1:!at&&nt?1:this.unsigned?P.high>>>0>this.high>>>0||P.high===this.high&&P.low>>>0>this.low>>>0?-1:1:this.sub(P).isNegative()?-1:1},B.comp=B.compare,B.negate=function(){return!this.unsigned&&this.eq(pt)?pt:this.not().add(dt)},B.neg=B.negate,B.add=function(P){$(P)||(P=A(P));var Mt=0,It=0,re=0,Bt=0;return re+=(Bt+=(65535&this.low)+(65535&P.low))>>>16,It+=(re+=(this.low>>>16)+(P.low>>>16))>>>16,Mt+=(It+=(65535&this.high)+(65535&P.high))>>>16,Mt+=(this.high>>>16)+(P.high>>>16),R((re&=65535)<<16|(Bt&=65535),(Mt&=65535)<<16|(It&=65535),this.unsigned)},B.subtract=function(P){return $(P)||(P=A(P)),this.add(P.neg())},B.sub=B.subtract,B.multiply=function(P){if(this.isZero())return st;if($(P)||(P=A(P)),ut)return R(ut.mul(this.low,this.high,P.low,P.high),ut.get_high(),this.unsigned);if(P.isZero())return st;if(this.eq(pt))return P.isOdd()?pt:st;if(P.eq(pt))return this.isOdd()?pt:st;if(this.isNegative())return P.isNegative()?this.neg().mul(P.neg()):this.neg().mul(P).neg();if(P.isNegative())return this.mul(P.neg()).neg();if(this.lt(K)&&P.lt(K))return Y(this.toNumber()*P.toNumber(),this.unsigned);var Gt=65535&this.high,O=this.low>>>16,Ct=65535&this.low,vt=65535&P.high,xt=P.low>>>16,Mt=65535&P.low,It=0,re=0,Bt=0,ee=0;return Bt+=(ee+=Ct*Mt)>>>16,re+=(Bt+=O*Mt)>>>16,Bt&=65535,re+=(Bt+=Ct*xt)>>>16,It+=(re+=Gt*Mt)>>>16,re&=65535,It+=(re+=O*xt)>>>16,re&=65535,It+=(re+=Ct*vt)>>>16,It+=(this.high>>>16)*Mt+Gt*xt+O*vt+Ct*(P.high>>>16),R((Bt&=65535)<<16|(ee&=65535),(It&=65535)<<16|(re&=65535),this.unsigned)},B.mul=B.multiply,B.divide=function(P){if($(P)||(P=A(P)),P.isZero())throw Error("division by zero");var nt,Gt,O;if(ut)return this.unsigned||-2147483648!==this.high||-1!==P.low||-1!==P.high?R((this.unsigned?ut.div_u:ut.div_s)(this.low,this.high,P.low,P.high),ut.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?et:st;if(this.unsigned){if(P.unsigned||(P=P.toUnsigned()),P.gt(this))return et;if(P.gt(this.shru(1)))return lt;O=et}else{if(this.eq(pt))return P.eq(dt)||P.eq(St)?pt:P.eq(pt)?dt:(nt=this.shr(1).div(P).shl(1)).eq(st)?P.isNegative()?dt:St:(Gt=this.sub(P.mul(nt)),O=nt.add(Gt.div(P)));if(P.eq(pt))return this.unsigned?et:st;if(this.isNegative())return P.isNegative()?this.neg().div(P.neg()):this.neg().div(P).neg();if(P.isNegative())return this.div(P.neg()).neg();O=st}for(Gt=this;Gt.gte(P);){nt=Math.max(1,Math.floor(Gt.toNumber()/P.toNumber()));for(var yt=Math.ceil(Math.log(nt)/Math.LN2),vt=yt<=48?1:W(2,yt-48),xt=Y(nt),Mt=xt.mul(P);Mt.isNegative()||Mt.gt(Gt);)Mt=(xt=Y(nt-=vt,this.unsigned)).mul(P);xt.isZero()&&(xt=dt),O=O.add(xt),Gt=Gt.sub(Mt)}return O},B.div=B.divide,B.modulo=function(P){return $(P)||(P=A(P)),ut?R((this.unsigned?ut.rem_u:ut.rem_s)(this.low,this.high,P.low,P.high),ut.get_high(),this.unsigned):this.sub(this.div(P).mul(P))},B.mod=B.modulo,B.rem=B.modulo,B.not=function(){return R(~this.low,~this.high,this.unsigned)},B.and=function(P){return $(P)||(P=A(P)),R(this.low&P.low,this.high&P.high,this.unsigned)},B.or=function(P){return $(P)||(P=A(P)),R(this.low|P.low,this.high|P.high,this.unsigned)},B.xor=function(P){return $(P)||(P=A(P)),R(this.low^P.low,this.high^P.high,this.unsigned)},B.shiftLeft=function(P){return $(P)&&(P=P.toInt()),0==(P&=63)?this:P<32?R(this.low<<P,this.high<<P|this.low>>>32-P,this.unsigned):R(0,this.low<<P-32,this.unsigned)},B.shl=B.shiftLeft,B.shiftRight=function(P){return $(P)&&(P=P.toInt()),0==(P&=63)?this:P<32?R(this.low>>>P|this.high<<32-P,this.high>>P,this.unsigned):R(this.high>>P-32,this.high>=0?0:-1,this.unsigned)},B.shr=B.shiftRight,B.shiftRightUnsigned=function(P){if($(P)&&(P=P.toInt()),0==(P&=63))return this;var at=this.high;return P<32?R(this.low>>>P|at<<32-P,at>>>P,this.unsigned):R(32===P?at:at>>>P-32,0,this.unsigned)},B.shru=B.shiftRightUnsigned,B.shr_u=B.shiftRightUnsigned,B.toSigned=function(){return this.unsigned?R(this.low,this.high,!1):this},B.toUnsigned=function(){return this.unsigned?this:R(this.low,this.high,!0)},B.toBytes=function(P){return P?this.toBytesLE():this.toBytesBE()},B.toBytesLE=function(){var P=this.high,at=this.low;return[255&at,at>>>8&255,at>>>16&255,at>>>24,255&P,P>>>8&255,P>>>16&255,P>>>24]},B.toBytesBE=function(){var P=this.high,at=this.low;return[P>>>24,P>>>16&255,P>>>8&255,255&P,at>>>24,at>>>16&255,at>>>8&255,255&at]},y.fromBytes=function(P,at,nt){return nt?y.fromBytesLE(P,at):y.fromBytesBE(P,at)},y.fromBytesLE=function(P,at){return new y(P[0]|P[1]<<8|P[2]<<16|P[3]<<24,P[4]|P[5]<<8|P[6]<<16|P[7]<<24,at)},y.fromBytesBE=function(P,at){return new y(P[4]<<24|P[5]<<16|P[6]<<8|P[7],P[0]<<24|P[1]<<16|P[2]<<8|P[3],at)}},4772:Lt=>{"use strict";var ut=Object.getOwnPropertySymbols,y=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable;Lt.exports=function H(){try{if(!Object.assign)return!1;var Q=new String("abc");if(Q[5]="de","5"===Object.getOwnPropertyNames(Q)[0])return!1;for(var Y={},R=0;R<10;R++)Y["_"+String.fromCharCode(R)]=R;if("0123456789"!==Object.getOwnPropertyNames(Y).map(function(A){return Y[A]}).join(""))return!1;var k={};return"abcdefghijklmnopqrst".split("").forEach(function(A){k[A]=A}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},k)).join("")}catch{return!1}}()?Object.assign:function(Q,Y){for(var R,k,W=function V(Q){if(null==Q)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(Q)}(Q),A=1;A<arguments.length;A++){for(var X in R=Object(arguments[A]))y.call(R,X)&&(W[X]=R[X]);if(ut){k=ut(R);for(var Z=0;Z<k.length;Z++)$.call(R,k[Z])&&(W[k[Z]]=R[k[Z]])}}return W}},4246:Lt=>{"use strict";var ut=function(y){return y!=y};Lt.exports=function($,V){return 0===$&&0===V?1/$==1/V:!!($===V||ut($)&&ut(V))}},314:(Lt,ut,y)=>{"use strict";var $=y(1648),V=y(5436),H=y(4246),Q=y(1353),Y=y(3090),R=V(Q(),Object);$(R,{getPolyfill:Q,implementation:H,shim:Y}),Lt.exports=R},1353:(Lt,ut,y)=>{"use strict";var $=y(4246);Lt.exports=function(){return"function"==typeof Object.is?Object.is:$}},3090:(Lt,ut,y)=>{"use strict";var $=y(1353),V=y(1648);Lt.exports=function(){var Q=$();return V(Object,{is:Q},{is:function(){return Object.is!==Q}}),Q}},7972:(Lt,ut,y)=>{"use strict";var $;if(!Object.keys){var V=Object.prototype.hasOwnProperty,H=Object.prototype.toString,Q=y(9637),Y=Object.prototype.propertyIsEnumerable,R=!Y.call({toString:null},"toString"),W=Y.call(function(){},"prototype"),k=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],A=function(it){var wt=it.constructor;return wt&&wt.prototype===it},X={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},Z=function(){if(typeof window>"u")return!1;for(var it in window)try{if(!X["$"+it]&&V.call(window,it)&&null!==window[it]&&"object"==typeof window[it])try{A(window[it])}catch{return!0}}catch{return!0}return!1}();$=function(wt){var K=null!==wt&&"object"==typeof wt,st="[object Function]"===H.call(wt),et=Q(wt),dt=K&&"[object String]"===H.call(wt),lt=[];if(!K&&!st&&!et)throw new TypeError("Object.keys called on a non-object");var St=W&&st;if(dt&&wt.length>0&&!V.call(wt,0))for(var q=0;q<wt.length;++q)lt.push(String(q));if(et&&wt.length>0)for(var ft=0;ft<wt.length;++ft)lt.push(String(ft));else for(var pt in wt)(!St||"prototype"!==pt)&&V.call(wt,pt)&&lt.push(String(pt));if(R)for(var B=function(it){if(typeof window>"u"||!Z)return A(it);try{return A(it)}catch{return!1}}(wt),ot=0;ot<k.length;++ot)(!B||"constructor"!==k[ot])&&V.call(wt,k[ot])&&lt.push(k[ot]);return lt}}Lt.exports=$},7809:(Lt,ut,y)=>{"use strict";var $=Array.prototype.slice,V=y(9637),H=Object.keys,Q=H?function(W){return H(W)}:y(7972),Y=Object.keys;Q.shim=function(){if(Object.keys){var W=function(){var k=Object.keys(arguments);return k&&k.length===arguments.length}(1,2);W||(Object.keys=function(A){return V(A)?Y($.call(A)):Y(A)})}else Object.keys=Q;return Object.keys||Q},Lt.exports=Q},9637:Lt=>{"use strict";var ut=Object.prototype.toString;Lt.exports=function($){var V=ut.call($),H="[object Arguments]"===V;return H||(H="[object Array]"!==V&&null!==$&&"object"==typeof $&&"number"==typeof $.length&&$.length>=0&&"[object Function]"===ut.call($.callee)),H}},4018:Lt=>{Lt.exports=function(y,$,V,H){var Q=y[0],Y=y[1],R=!1;void 0===V&&(V=0),void 0===H&&(H=$.length);for(var W=(H-V)/2,k=0,A=W-1;k<W;A=k++){var X=$[V+2*k+0],Z=$[V+2*k+1],it=$[V+2*A+1];Z>Y!=it>Y&&Q<($[V+2*A+0]-X)*(Y-Z)/(it-Z)+X&&(R=!R)}return R}},4179:(Lt,ut,y)=>{var $=y(4018),V=y(8875);Lt.exports=function(Q,Y,R,W){return Y.length>0&&Array.isArray(Y[0])?V(Q,Y,R,W):$(Q,Y,R,W)},Lt.exports.nested=V,Lt.exports.flat=$},8875:Lt=>{Lt.exports=function(y,$,V,H){var Q=y[0],Y=y[1],R=!1;void 0===V&&(V=0),void 0===H&&(H=$.length);for(var W=H-V,k=0,A=W-1;k<W;A=k++){var X=$[k+V][0],Z=$[k+V][1],it=$[A+V][1];Z>Y!=it>Y&&Q<($[A+V][0]-X)*(Y-Z)/(it-Z)+X&&(R=!R)}return R}},8464:function(Lt){Lt.exports=function(){"use strict";function ut(Ce,Et){var te,oe,ie,ze,Rt={label:0,sent:function(){if(1&ie[0])throw ie[1];return ie[1]},trys:[],ops:[]};return ze={next:Oe(0),throw:Oe(1),return:Oe(2)},"function"==typeof Symbol&&(ze[Symbol.iterator]=function(){return this}),ze;function Oe(Xt){return function(En){return function je(Xt){if(te)throw new TypeError("Generator is already executing.");for(;Rt;)try{if(te=1,oe&&(ie=2&Xt[0]?oe.return:Xt[0]?oe.throw||((ie=oe.return)&&ie.call(oe),0):oe.next)&&!(ie=ie.call(oe,Xt[1])).done)return ie;switch(oe=0,ie&&(Xt=[2&Xt[0],ie.value]),Xt[0]){case 0:case 1:ie=Xt;break;case 4:return Rt.label++,{value:Xt[1],done:!1};case 5:Rt.label++,oe=Xt[1],Xt=[0];continue;case 7:Xt=Rt.ops.pop(),Rt.trys.pop();continue;default:if(!(ie=(ie=Rt.trys).length>0&&ie[ie.length-1])&&(6===Xt[0]||2===Xt[0])){Rt=0;continue}if(3===Xt[0]&&(!ie||Xt[1]>ie[0]&&Xt[1]<ie[3])){Rt.label=Xt[1];break}if(6===Xt[0]&&Rt.label<ie[1]){Rt.label=ie[1],ie=Xt;break}if(ie&&Rt.label<ie[2]){Rt.label=ie[2],Rt.ops.push(Xt);break}ie[2]&&Rt.ops.pop(),Rt.trys.pop();continue}Xt=Et.call(Ce,Rt)}catch(En){Xt=[6,En],oe=0}finally{te=ie=0}if(5&Xt[0])throw Xt[1];return{value:Xt[0]?Xt[1]:void 0,done:!0}}([Xt,En])}}}var y=function Ce(Et,Rt){this.next=null,this.key=Et,this.data=Rt,this.left=null,this.right=null};function $(Ce,Et){return Ce>Et?1:Ce<Et?-1:0}function V(Ce,Et,Rt){for(var te=new y(null,null),oe=te,ie=te;;){var ze=Rt(Ce,Et.key);if(ze<0){if(null===Et.left)break;if(Rt(Ce,Et.left.key)<0&&(Et.left=(Oe=Et.left).right,Oe.right=Et,null===(Et=Oe).left))break;ie.left=Et,ie=Et,Et=Et.left}else{if(!(ze>0))break;if(null===Et.right)break;var Oe;if(Rt(Ce,Et.right.key)>0&&(Et.right=(Oe=Et.right).left,Oe.left=Et,null===(Et=Oe).right))break;oe.right=Et,oe=Et,Et=Et.right}}return oe.right=Et.left,ie.left=Et.right,Et.left=te.right,Et.right=te.left,Et}function H(Ce,Et,Rt,te){var oe=new y(Ce,Et);if(null===Rt)return oe.left=oe.right=null,oe;var ie=te(Ce,(Rt=V(Ce,Rt,te)).key);return ie<0?(oe.left=Rt.left,oe.right=Rt,Rt.left=null):ie>=0&&(oe.right=Rt.right,oe.left=Rt,Rt.right=null),oe}function Q(Ce,Et,Rt){var te=null,oe=null;if(Et){var ie=Rt((Et=V(Ce,Et,Rt)).key,Ce);0===ie?(te=Et.left,oe=Et.right):ie<0?(oe=Et.right,Et.right=null,te=Et):(te=Et.left,Et.left=null,oe=Et)}return{left:te,right:oe}}function R(Ce,Et,Rt,te,oe){if(Ce){te(Et+(Rt?"\u2514\u2500\u2500 ":"\u251c\u2500\u2500 ")+oe(Ce)+"\n");var ie=Et+(Rt?"    ":"\u2502   ");Ce.left&&R(Ce.left,ie,!1,te,oe),Ce.right&&R(Ce.right,ie,!0,te,oe)}}var W=function(){function Ce(Et){void 0===Et&&(Et=$),this._root=null,this._size=0,this._comparator=Et}return Ce.prototype.insert=function(Et,Rt){return this._size++,this._root=H(Et,Rt,this._root,this._comparator)},Ce.prototype.add=function(Et,Rt){var te=new y(Et,Rt);null===this._root&&(te.left=te.right=null,this._size++,this._root=te);var oe=this._comparator,ie=V(Et,this._root,oe),ze=oe(Et,ie.key);return 0===ze?this._root=ie:(ze<0?(te.left=ie.left,te.right=ie,ie.left=null):ze>0&&(te.right=ie.right,te.left=ie,ie.right=null),this._size++,this._root=te),this._root},Ce.prototype.remove=function(Et){this._root=this._remove(Et,this._root,this._comparator)},Ce.prototype._remove=function(Et,Rt,te){var oe;return null===Rt?null:0===te(Et,(Rt=V(Et,Rt,te)).key)?(null===Rt.left?oe=Rt.right:(oe=V(Et,Rt.left,te)).right=Rt.right,this._size--,oe):Rt},Ce.prototype.pop=function(){var Et=this._root;if(Et){for(;Et.left;)Et=Et.left;return this._root=V(Et.key,this._root,this._comparator),this._root=this._remove(Et.key,this._root,this._comparator),{key:Et.key,data:Et.data}}return null},Ce.prototype.findStatic=function(Et){for(var Rt=this._root,te=this._comparator;Rt;){var oe=te(Et,Rt.key);if(0===oe)return Rt;Rt=oe<0?Rt.left:Rt.right}return null},Ce.prototype.find=function(Et){return this._root&&(this._root=V(Et,this._root,this._comparator),0!==this._comparator(Et,this._root.key))?null:this._root},Ce.prototype.contains=function(Et){for(var Rt=this._root,te=this._comparator;Rt;){var oe=te(Et,Rt.key);if(0===oe)return!0;Rt=oe<0?Rt.left:Rt.right}return!1},Ce.prototype.forEach=function(Et,Rt){for(var te=this._root,oe=[],ie=!1;!ie;)null!==te?(oe.push(te),te=te.left):0!==oe.length?(te=oe.pop(),Et.call(Rt,te),te=te.right):ie=!0;return this},Ce.prototype.range=function(Et,Rt,te,oe){for(var ie=[],ze=this._comparator,Oe=this._root;0!==ie.length||Oe;)if(Oe)ie.push(Oe),Oe=Oe.left;else{if(ze((Oe=ie.pop()).key,Rt)>0)break;if(ze(Oe.key,Et)>=0&&te.call(oe,Oe))return this;Oe=Oe.right}return this},Ce.prototype.keys=function(){var Et=[];return this.forEach(function(Rt){return Et.push(Rt.key)}),Et},Ce.prototype.values=function(){var Et=[];return this.forEach(function(Rt){return Et.push(Rt.data)}),Et},Ce.prototype.min=function(){return this._root?this.minNode(this._root).key:null},Ce.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},Ce.prototype.minNode=function(Et){if(void 0===Et&&(Et=this._root),Et)for(;Et.left;)Et=Et.left;return Et},Ce.prototype.maxNode=function(Et){if(void 0===Et&&(Et=this._root),Et)for(;Et.right;)Et=Et.right;return Et},Ce.prototype.at=function(Et){for(var Rt=this._root,te=!1,oe=0,ie=[];!te;)if(Rt)ie.push(Rt),Rt=Rt.left;else if(ie.length>0){if(Rt=ie.pop(),oe===Et)return Rt;oe++,Rt=Rt.right}else te=!0;return null},Ce.prototype.next=function(Et){var Rt=this._root,te=null;if(Et.right){for(te=Et.right;te.left;)te=te.left;return te}for(var oe=this._comparator;Rt;){var ie=oe(Et.key,Rt.key);if(0===ie)break;ie<0?(te=Rt,Rt=Rt.left):Rt=Rt.right}return te},Ce.prototype.prev=function(Et){var Rt=this._root,te=null;if(null!==Et.left){for(te=Et.left;te.right;)te=te.right;return te}for(var oe=this._comparator;Rt;){var ie=oe(Et.key,Rt.key);if(0===ie)break;ie<0?Rt=Rt.left:(te=Rt,Rt=Rt.right)}return te},Ce.prototype.clear=function(){return this._root=null,this._size=0,this},Ce.prototype.toList=function(){return function X(Ce){for(var Et=Ce,Rt=[],te=!1,oe=new y(null,null),ie=oe;!te;)Et?(Rt.push(Et),Et=Et.left):Rt.length>0?Et=(Et=ie=ie.next=Rt.pop()).right:te=!0;return ie.next=null,oe.next}(this._root)},Ce.prototype.load=function(Et,Rt,te){void 0===Rt&&(Rt=[]),void 0===te&&(te=!1);var oe=Et.length,ie=this._comparator;if(te&&it(Et,Rt,0,oe-1,ie),null===this._root)this._root=k(Et,Rt,0,oe),this._size=oe;else{var ze=function G(Ce,Et,Rt){for(var te=new y(null,null),oe=te,ie=Ce,ze=Et;null!==ie&&null!==ze;)Rt(ie.key,ze.key)<0?(oe.next=ie,ie=ie.next):(oe.next=ze,ze=ze.next),oe=oe.next;return null!==ie?oe.next=ie:null!==ze&&(oe.next=ze),te.next}(this.toList(),function A(Ce,Et){for(var Rt=new y(null,null),te=Rt,oe=0;oe<Ce.length;oe++)te=te.next=new y(Ce[oe],Et[oe]);return te.next=null,Rt.next}(Et,Rt),ie);this._root=Z({head:ze},0,oe=this._size+oe)}return this},Ce.prototype.isEmpty=function(){return null===this._root},Object.defineProperty(Ce.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(Ce.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),Ce.prototype.toString=function(Et){void 0===Et&&(Et=function(te){return String(te.key)});var Rt=[];return R(this._root,"",!0,function(te){return Rt.push(te)},Et),Rt.join("")},Ce.prototype.update=function(Et,Rt,te){var oe=this._comparator,ie=Q(Et,this._root,oe),ze=ie.left,Oe=ie.right;oe(Et,Rt)<0?Oe=H(Rt,te,Oe,oe):ze=H(Rt,te,ze,oe),this._root=function Y(Ce,Et,Rt){return null===Et?Ce:(null===Ce||((Et=V(Ce.key,Et,Rt)).left=Ce),Et)}(ze,Oe,oe)},Ce.prototype.split=function(Et){return Q(Et,this._root,this._comparator)},Ce.prototype[Symbol.iterator]=function(){var Et,Rt,te;return ut(this,function(oe){switch(oe.label){case 0:Et=this._root,Rt=[],te=!1,oe.label=1;case 1:return te?[3,6]:null===Et?[3,2]:(Rt.push(Et),Et=Et.left,[3,5]);case 2:return 0===Rt.length?[3,4]:[4,Et=Rt.pop()];case 3:return oe.sent(),Et=Et.right,[3,5];case 4:te=!0,oe.label=5;case 5:return[3,1];case 6:return[2]}})},Ce}();function k(Ce,Et,Rt,te){var oe=te-Rt;if(oe>0){var ie=Rt+Math.floor(oe/2),je=new y(Ce[ie],Et[ie]);return je.left=k(Ce,Et,Rt,ie),je.right=k(Ce,Et,ie+1,te),je}return null}function Z(Ce,Et,Rt){var te=Rt-Et;if(te>0){var oe=Et+Math.floor(te/2),ie=Z(Ce,Et,oe),ze=Ce.head;return ze.left=ie,Ce.head=Ce.head.next,ze.right=Z(Ce,oe+1,Rt),ze}return null}function it(Ce,Et,Rt,te,oe){if(!(Rt>=te)){for(var ie=Ce[Rt+te>>1],ze=Rt-1,Oe=te+1;;){do{ze++}while(oe(Ce[ze],ie)<0);do{Oe--}while(oe(Ce[Oe],ie)>0);if(ze>=Oe)break;var je=Ce[ze];Ce[ze]=Ce[Oe],Ce[Oe]=je,je=Et[ze],Et[ze]=Et[Oe],Et[Oe]=je}it(Ce,Et,Rt,Oe,oe),it(Ce,Et,Oe+1,te,oe)}}const wt=(Ce,Et)=>Ce.ll.x<=Et.x&&Et.x<=Ce.ur.x&&Ce.ll.y<=Et.y&&Et.y<=Ce.ur.y,K=(Ce,Et)=>Et.ur.x<Ce.ll.x||Ce.ur.x<Et.ll.x||Et.ur.y<Ce.ll.y||Ce.ur.y<Et.ll.y?null:{ll:{x:Ce.ll.x<Et.ll.x?Et.ll.x:Ce.ll.x,y:Ce.ll.y<Et.ll.y?Et.ll.y:Ce.ll.y},ur:{x:Ce.ur.x<Et.ur.x?Ce.ur.x:Et.ur.x,y:Ce.ur.y<Et.ur.y?Ce.ur.y:Et.ur.y}};let st=Number.EPSILON;void 0===st&&(st=Math.pow(2,-52));const et=st*st,dt=(Ce,Et)=>{if(-st<Ce&&Ce<st&&-st<Et&&Et<st)return 0;const Rt=Ce-Et;return Rt*Rt<et*Ce*Et?0:Ce<Et?-1:1};class St{constructor(){this.tree=new W,this.round(0)}round(Et){const Rt=this.tree.add(Et),te=this.tree.prev(Rt);if(null!==te&&0===dt(Rt.key,te.key))return this.tree.remove(Et),te.key;const oe=this.tree.next(Rt);return null!==oe&&0===dt(Rt.key,oe.key)?(this.tree.remove(Et),oe.key):Et}}const q=new class lt{constructor(){this.reset()}reset(){this.xRounder=new St,this.yRounder=new St}round(Et,Rt){return{x:this.xRounder.round(Et),y:this.yRounder.round(Rt)}}},ft=11102230246251565e-32,pt=134217729,B=(3+8*ft)*ft;function ot(Ce,Et,Rt,te,oe){let ie,ze,Oe,je,Xt=Et[0],En=te[0],ue=0,en=0;En>Xt==En>-Xt?(ie=Xt,Xt=Et[++ue]):(ie=En,En=te[++en]);let mn=0;if(ue<Ce&&en<Rt)for(En>Xt==En>-Xt?(ze=Xt+ie,Oe=ie-(ze-Xt),Xt=Et[++ue]):(ze=En+ie,Oe=ie-(ze-En),En=te[++en]),ie=ze,0!==Oe&&(oe[mn++]=Oe);ue<Ce&&en<Rt;)En>Xt==En>-Xt?(ze=ie+Xt,je=ze-ie,Oe=ie-(ze-je)+(Xt-je),Xt=Et[++ue]):(ze=ie+En,je=ze-ie,Oe=ie-(ze-je)+(En-je),En=te[++en]),ie=ze,0!==Oe&&(oe[mn++]=Oe);for(;ue<Ce;)ze=ie+Xt,je=ze-ie,Oe=ie-(ze-je)+(Xt-je),Xt=Et[++ue],ie=ze,0!==Oe&&(oe[mn++]=Oe);for(;en<Rt;)ze=ie+En,je=ze-ie,Oe=ie-(ze-je)+(En-je),En=te[++en],ie=ze,0!==Oe&&(oe[mn++]=Oe);return(0!==ie||0===mn)&&(oe[mn++]=ie),mn}function at(Ce){return new Float64Array(Ce)}const Gt=(2+12*ft)*ft,O=(9+64*ft)*ft*ft,Ct=at(4),yt=at(8),vt=at(12),xt=at(16),Mt=at(4);function re(Ce,Et,Rt,te,oe,ie){const ze=(Et-ie)*(Rt-oe),Oe=(Ce-oe)*(te-ie),je=ze-Oe,Xt=Math.abs(ze+Oe);return Math.abs(je)>=33306690738754716e-32*Xt?je:-function It(Ce,Et,Rt,te,oe,ie,ze){let Oe,je,Xt,En,ue,en,mn,un,ir,dr,zn,_n,sr,Jr,qn,br,Dn,si;const kr=Ce-oe,tr=Rt-oe,Zi=Et-ie,fi=te-ie;Jr=kr*fi,en=pt*kr,mn=en-(en-kr),un=kr-mn,en=pt*fi,ir=en-(en-fi),dr=fi-ir,qn=un*dr-(Jr-mn*ir-un*ir-mn*dr),br=Zi*tr,en=pt*Zi,mn=en-(en-Zi),un=Zi-mn,en=pt*tr,ir=en-(en-tr),dr=tr-ir,Dn=un*dr-(br-mn*ir-un*ir-mn*dr),zn=qn-Dn,ue=qn-zn,Ct[0]=qn-(zn+ue)+(ue-Dn),_n=Jr+zn,ue=_n-Jr,sr=Jr-(_n-ue)+(zn-ue),zn=sr-br,ue=sr-zn,Ct[1]=sr-(zn+ue)+(ue-br),si=_n+zn,ue=si-_n,Ct[2]=_n-(si-ue)+(zn-ue),Ct[3]=si;let oi=function P(Ce,Et){let Rt=Et[0];for(let te=1;te<Ce;te++)Rt+=Et[te];return Rt}(4,Ct),zr=Gt*ze;if(oi>=zr||-oi>=zr||(ue=Ce-kr,Oe=Ce-(kr+ue)+(ue-oe),ue=Rt-tr,Xt=Rt-(tr+ue)+(ue-oe),ue=Et-Zi,je=Et-(Zi+ue)+(ue-ie),ue=te-fi,En=te-(fi+ue)+(ue-ie),0===Oe&&0===je&&0===Xt&&0===En)||(zr=O*ze+B*Math.abs(oi),oi+=kr*En+fi*Oe-(Zi*Xt+tr*je),oi>=zr||-oi>=zr))return oi;Jr=Oe*fi,en=pt*Oe,mn=en-(en-Oe),un=Oe-mn,en=pt*fi,ir=en-(en-fi),dr=fi-ir,qn=un*dr-(Jr-mn*ir-un*ir-mn*dr),br=je*tr,en=pt*je,mn=en-(en-je),un=je-mn,en=pt*tr,ir=en-(en-tr),dr=tr-ir,Dn=un*dr-(br-mn*ir-un*ir-mn*dr),zn=qn-Dn,ue=qn-zn,Mt[0]=qn-(zn+ue)+(ue-Dn),_n=Jr+zn,ue=_n-Jr,sr=Jr-(_n-ue)+(zn-ue),zn=sr-br,ue=sr-zn,Mt[1]=sr-(zn+ue)+(ue-br),si=_n+zn,ue=si-_n,Mt[2]=_n-(si-ue)+(zn-ue),Mt[3]=si;const js=ot(4,Ct,4,Mt,yt);Jr=kr*En,en=pt*kr,mn=en-(en-kr),un=kr-mn,en=pt*En,ir=en-(en-En),dr=En-ir,qn=un*dr-(Jr-mn*ir-un*ir-mn*dr),br=Zi*Xt,en=pt*Zi,mn=en-(en-Zi),un=Zi-mn,en=pt*Xt,ir=en-(en-Xt),dr=Xt-ir,Dn=un*dr-(br-mn*ir-un*ir-mn*dr),zn=qn-Dn,ue=qn-zn,Mt[0]=qn-(zn+ue)+(ue-Dn),_n=Jr+zn,ue=_n-Jr,sr=Jr-(_n-ue)+(zn-ue),zn=sr-br,ue=sr-zn,Mt[1]=sr-(zn+ue)+(ue-br),si=_n+zn,ue=si-_n,Mt[2]=_n-(si-ue)+(zn-ue),Mt[3]=si;const ho=ot(js,yt,4,Mt,vt);Jr=Oe*En,en=pt*Oe,mn=en-(en-Oe),un=Oe-mn,en=pt*En,ir=en-(en-En),dr=En-ir,qn=un*dr-(Jr-mn*ir-un*ir-mn*dr),br=je*Xt,en=pt*je,mn=en-(en-je),un=je-mn,en=pt*Xt,ir=en-(en-Xt),dr=Xt-ir,Dn=un*dr-(br-mn*ir-un*ir-mn*dr),zn=qn-Dn,ue=qn-zn,Mt[0]=qn-(zn+ue)+(ue-Dn),_n=Jr+zn,ue=_n-Jr,sr=Jr-(_n-ue)+(zn-ue),zn=sr-br,ue=sr-zn,Mt[1]=sr-(zn+ue)+(ue-br),si=_n+zn,ue=si-_n,Mt[2]=_n-(si-ue)+(zn-ue),Mt[3]=si;const Es=ot(ho,vt,4,Mt,xt);return xt[Es-1]}(Ce,Et,Rt,te,oe,ie,Xt)}const Bt=(Ce,Et)=>Ce.x*Et.y-Ce.y*Et.x,ee=(Ce,Et)=>Ce.x*Et.x+Ce.y*Et.y,jt=(Ce,Et,Rt)=>{const te=re(Ce.x,Ce.y,Et.x,Et.y,Rt.x,Rt.y);return te>0?-1:te<0?1:0},se=Ce=>Math.sqrt(ee(Ce,Ce)),we=(Ce,Et,Rt)=>{const te={x:Et.x-Ce.x,y:Et.y-Ce.y},oe={x:Rt.x-Ce.x,y:Rt.y-Ce.y};return Bt(oe,te)/se(oe)/se(te)},Me=(Ce,Et,Rt)=>{const te={x:Et.x-Ce.x,y:Et.y-Ce.y},oe={x:Rt.x-Ce.x,y:Rt.y-Ce.y};return ee(oe,te)/se(oe)/se(te)},Xe=(Ce,Et,Rt)=>0===Et.y?null:{x:Ce.x+Et.x/Et.y*(Rt-Ce.y),y:Rt},Ue=(Ce,Et,Rt)=>0===Et.x?null:{x:Rt,y:Ce.y+Et.y/Et.x*(Rt-Ce.x)};class Tn{static compare(Et,Rt){const te=Tn.comparePoints(Et.point,Rt.point);return 0!==te?te:(Et.point!==Rt.point&&Et.link(Rt),Et.isLeft!==Rt.isLeft?Et.isLeft?1:-1:ne.compare(Et.segment,Rt.segment))}static comparePoints(Et,Rt){return Et.x<Rt.x?-1:Et.x>Rt.x?1:Et.y<Rt.y?-1:Et.y>Rt.y?1:0}constructor(Et,Rt){void 0===Et.events?Et.events=[this]:Et.events.push(this),this.point=Et,this.isLeft=Rt}link(Et){if(Et.point===this.point)throw new Error("Tried to link already linked events");const Rt=Et.point.events;for(let te=0,oe=Rt.length;te<oe;te++){const ie=Rt[te];this.point.events.push(ie),ie.point=this.point}this.checkForConsuming()}checkForConsuming(){const Et=this.point.events.length;for(let Rt=0;Rt<Et;Rt++){const te=this.point.events[Rt];if(void 0===te.segment.consumedBy)for(let oe=Rt+1;oe<Et;oe++){const ie=this.point.events[oe];void 0===ie.consumedBy&&te.otherSE.point.events===ie.otherSE.point.events&&te.segment.consume(ie.segment)}}}getAvailableLinkedEvents(){const Et=[];for(let Rt=0,te=this.point.events.length;Rt<te;Rt++){const oe=this.point.events[Rt];oe!==this&&!oe.segment.ringOut&&oe.segment.isInResult()&&Et.push(oe)}return Et}getLeftmostComparator(Et){const Rt=new Map,te=oe=>{const ie=oe.otherSE;Rt.set(oe,{sine:we(this.point,Et.point,ie.point),cosine:Me(this.point,Et.point,ie.point)})};return(oe,ie)=>{Rt.has(oe)||te(oe),Rt.has(ie)||te(ie);const{sine:ze,cosine:Oe}=Rt.get(oe),{sine:je,cosine:Xt}=Rt.get(ie);return ze>=0&&je>=0?Oe<Xt?1:Oe>Xt?-1:0:ze<0&&je<0?Oe<Xt?-1:Oe>Xt?1:0:je<ze?-1:je>ze?1:0}}}let On=0;class ne{static compare(Et,Rt){const te=Et.leftSE.point.x,oe=Rt.leftSE.point.x,ie=Et.rightSE.point.x,ze=Rt.rightSE.point.x;if(ze<te)return 1;if(ie<oe)return-1;const Oe=Et.leftSE.point.y,je=Rt.leftSE.point.y,Xt=Et.rightSE.point.y,En=Rt.rightSE.point.y;if(te<oe){if(je<Oe&&je<Xt)return 1;if(je>Oe&&je>Xt)return-1;const ue=Et.comparePoint(Rt.leftSE.point);if(ue<0)return 1;if(ue>0)return-1;const en=Rt.comparePoint(Et.rightSE.point);return 0!==en?en:-1}if(te>oe){if(Oe<je&&Oe<En)return-1;if(Oe>je&&Oe>En)return 1;const ue=Rt.comparePoint(Et.leftSE.point);if(0!==ue)return ue;const en=Et.comparePoint(Rt.rightSE.point);return en<0?1:en>0?-1:1}if(Oe<je)return-1;if(Oe>je)return 1;if(ie<ze){const ue=Rt.comparePoint(Et.rightSE.point);if(0!==ue)return ue}if(ie>ze){const ue=Et.comparePoint(Rt.rightSE.point);if(ue<0)return 1;if(ue>0)return-1}if(ie!==ze){const ue=Xt-Oe,en=ie-te,mn=En-je,un=ze-oe;if(ue>en&&mn<un)return 1;if(ue<en&&mn>un)return-1}return ie>ze?1:ie<ze||Xt<En?-1:Xt>En?1:Et.id<Rt.id?-1:Et.id>Rt.id?1:0}constructor(Et,Rt,te,oe){this.id=++On,this.leftSE=Et,Et.segment=this,Et.otherSE=Rt,this.rightSE=Rt,Rt.segment=this,Rt.otherSE=Et,this.rings=te,this.windings=oe}static fromRing(Et,Rt,te){let oe,ie,ze;const Oe=Tn.comparePoints(Et,Rt);if(Oe<0)oe=Et,ie=Rt,ze=1;else{if(!(Oe>0))throw new Error(`Tried to create degenerate segment at [${Et.x}, ${Et.y}]`);oe=Rt,ie=Et,ze=-1}const je=new Tn(oe,!0),Xt=new Tn(ie,!1);return new ne(je,Xt,[te],[ze])}replaceRightSE(Et){this.rightSE=Et,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const Et=this.leftSE.point.y,Rt=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:Et<Rt?Et:Rt},ur:{x:this.rightSE.point.x,y:Et>Rt?Et:Rt}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(Et){return Et.x===this.leftSE.point.x&&Et.y===this.leftSE.point.y||Et.x===this.rightSE.point.x&&Et.y===this.rightSE.point.y}comparePoint(Et){if(this.isAnEndpoint(Et))return 0;const Rt=this.leftSE.point,te=this.rightSE.point,oe=this.vector();if(Rt.x===te.x)return Et.x===Rt.x?0:Et.x<Rt.x?1:-1;if(Et.x===Rt.x+(Et.y-Rt.y)/oe.y*oe.x)return 0;const je=Rt.y+(Et.x-Rt.x)/oe.x*oe.y;return Et.y===je?0:Et.y<je?-1:1}getIntersection(Et){const Rt=this.bbox(),te=Et.bbox(),oe=K(Rt,te);if(null===oe)return null;const ie=this.leftSE.point,ze=this.rightSE.point,Oe=Et.leftSE.point,je=Et.rightSE.point,Xt=wt(Rt,Oe)&&0===this.comparePoint(Oe),En=wt(te,ie)&&0===Et.comparePoint(ie),ue=wt(Rt,je)&&0===this.comparePoint(je),en=wt(te,ze)&&0===Et.comparePoint(ze);if(En&&Xt)return en&&!ue?ze:!en&&ue?je:null;if(En)return ue&&ie.x===je.x&&ie.y===je.y?null:ie;if(Xt)return en&&ze.x===Oe.x&&ze.y===Oe.y?null:Oe;if(en&&ue)return null;if(en)return ze;if(ue)return je;const mn=((Ce,Et,Rt,te)=>{if(0===Et.x)return Ue(Rt,te,Ce.x);if(0===te.x)return Ue(Ce,Et,Rt.x);if(0===Et.y)return Xe(Rt,te,Ce.y);if(0===te.y)return Xe(Ce,Et,Rt.y);const oe=Bt(Et,te);if(0==oe)return null;const ie={x:Rt.x-Ce.x,y:Rt.y-Ce.y},ze=Bt(ie,Et)/oe,Oe=Bt(ie,te)/oe;return{x:(Ce.x+Oe*Et.x+(Rt.x+ze*te.x))/2,y:(Ce.y+Oe*Et.y+(Rt.y+ze*te.y))/2}})(ie,this.vector(),Oe,Et.vector());return null!==mn&&wt(oe,mn)?q.round(mn.x,mn.y):null}split(Et){const Rt=[],te=void 0!==Et.events,oe=new Tn(Et,!0),ie=new Tn(Et,!1),ze=this.rightSE;this.replaceRightSE(ie),Rt.push(ie),Rt.push(oe);const Oe=new ne(oe,ze,this.rings.slice(),this.windings.slice());return Tn.comparePoints(Oe.leftSE.point,Oe.rightSE.point)>0&&Oe.swapEvents(),Tn.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),te&&(oe.checkForConsuming(),ie.checkForConsuming()),Rt}swapEvents(){const Et=this.rightSE;this.rightSE=this.leftSE,this.leftSE=Et,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let Rt=0,te=this.windings.length;Rt<te;Rt++)this.windings[Rt]*=-1}consume(Et){let Rt=this,te=Et;for(;Rt.consumedBy;)Rt=Rt.consumedBy;for(;te.consumedBy;)te=te.consumedBy;const oe=ne.compare(Rt,te);if(0!==oe){if(oe>0){const ie=Rt;Rt=te,te=ie}if(Rt.prev===te){const ie=Rt;Rt=te,te=ie}for(let ie=0,ze=te.rings.length;ie<ze;ie++){const Oe=te.rings[ie],je=te.windings[ie],Xt=Rt.rings.indexOf(Oe);-1===Xt?(Rt.rings.push(Oe),Rt.windings.push(je)):Rt.windings[Xt]+=je}te.rings=null,te.windings=null,te.consumedBy=Rt,te.leftSE.consumedBy=Rt.leftSE,te.rightSE.consumedBy=Rt.rightSE}}prevInResult(){return void 0!==this._prevInResult||(this._prevInResult=this.prev?this.prev.isInResult()?this.prev:this.prev.prevInResult():null),this._prevInResult}beforeState(){return void 0!==this._beforeState||(this._beforeState=this.prev?(this.prev.consumedBy||this.prev).afterState():{rings:[],windings:[],multiPolys:[]}),this._beforeState}afterState(){if(void 0!==this._afterState)return this._afterState;const Et=this.beforeState();this._afterState={rings:Et.rings.slice(0),windings:Et.windings.slice(0),multiPolys:[]};const Rt=this._afterState.rings,te=this._afterState.windings,oe=this._afterState.multiPolys;for(let Oe=0,je=this.rings.length;Oe<je;Oe++){const Xt=this.rings[Oe],En=this.windings[Oe],ue=Rt.indexOf(Xt);-1===ue?(Rt.push(Xt),te.push(En)):te[ue]+=En}const ie=[],ze=[];for(let Oe=0,je=Rt.length;Oe<je;Oe++){if(0===te[Oe])continue;const Xt=Rt[Oe],En=Xt.poly;if(-1===ze.indexOf(En))if(Xt.isExterior)ie.push(En);else{-1===ze.indexOf(En)&&ze.push(En);const ue=ie.indexOf(Xt.poly);-1!==ue&&ie.splice(ue,1)}}for(let Oe=0,je=ie.length;Oe<je;Oe++){const Xt=ie[Oe].multiPoly;-1===oe.indexOf(Xt)&&oe.push(Xt)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;const Et=this.beforeState().multiPolys,Rt=this.afterState().multiPolys;switch(ii.type){case"union":this._isInResult=0===Et.length!=(0===Rt.length);break;case"intersection":{let te,oe;Et.length<Rt.length?(te=Et.length,oe=Rt.length):(te=Rt.length,oe=Et.length),this._isInResult=oe===ii.numMultiPolys&&te<oe;break}case"xor":{const te=Math.abs(Et.length-Rt.length);this._isInResult=te%2==1;break}case"difference":{const te=oe=>1===oe.length&&oe[0].isSubject;this._isInResult=te(Et)!==te(Rt);break}default:throw new Error(`Unrecognized operation type found ${ii.type}`)}return this._isInResult}}class pe{constructor(Et,Rt,te){if(!Array.isArray(Et)||0===Et.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=Rt,this.isExterior=te,this.segments=[],"number"!=typeof Et[0][0]||"number"!=typeof Et[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const oe=q.round(Et[0][0],Et[0][1]);this.bbox={ll:{x:oe.x,y:oe.y},ur:{x:oe.x,y:oe.y}};let ie=oe;for(let ze=1,Oe=Et.length;ze<Oe;ze++){if("number"!=typeof Et[ze][0]||"number"!=typeof Et[ze][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let je=q.round(Et[ze][0],Et[ze][1]);je.x===ie.x&&je.y===ie.y||(this.segments.push(ne.fromRing(ie,je,this)),je.x<this.bbox.ll.x&&(this.bbox.ll.x=je.x),je.y<this.bbox.ll.y&&(this.bbox.ll.y=je.y),je.x>this.bbox.ur.x&&(this.bbox.ur.x=je.x),je.y>this.bbox.ur.y&&(this.bbox.ur.y=je.y),ie=je)}(oe.x!==ie.x||oe.y!==ie.y)&&this.segments.push(ne.fromRing(ie,oe,this))}getSweepEvents(){const Et=[];for(let Rt=0,te=this.segments.length;Rt<te;Rt++){const oe=this.segments[Rt];Et.push(oe.leftSE),Et.push(oe.rightSE)}return Et}}class Ie{constructor(Et,Rt){if(!Array.isArray(Et))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new pe(Et[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let te=1,oe=Et.length;te<oe;te++){const ie=new pe(Et[te],this,!1);ie.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=ie.bbox.ll.x),ie.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=ie.bbox.ll.y),ie.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=ie.bbox.ur.x),ie.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=ie.bbox.ur.y),this.interiorRings.push(ie)}this.multiPoly=Rt}getSweepEvents(){const Et=this.exteriorRing.getSweepEvents();for(let Rt=0,te=this.interiorRings.length;Rt<te;Rt++){const oe=this.interiorRings[Rt].getSweepEvents();for(let ie=0,ze=oe.length;ie<ze;ie++)Et.push(oe[ie])}return Et}}class Je{constructor(Et,Rt){if(!Array.isArray(Et))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof Et[0][0][0]&&(Et=[Et])}catch{}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let te=0,oe=Et.length;te<oe;te++){const ie=new Ie(Et[te],this);ie.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=ie.bbox.ll.x),ie.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=ie.bbox.ll.y),ie.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=ie.bbox.ur.x),ie.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=ie.bbox.ur.y),this.polys.push(ie)}this.isSubject=Rt}getSweepEvents(){const Et=[];for(let Rt=0,te=this.polys.length;Rt<te;Rt++){const oe=this.polys[Rt].getSweepEvents();for(let ie=0,ze=oe.length;ie<ze;ie++)Et.push(oe[ie])}return Et}}class Wn{static factory(Et){const Rt=[];for(let te=0,oe=Et.length;te<oe;te++){const ie=Et[te];if(!ie.isInResult()||ie.ringOut)continue;let ze=null,Oe=ie.leftSE,je=ie.rightSE;const Xt=[Oe],En=Oe.point,ue=[];for(;ze=Oe,Oe=je,Xt.push(Oe),Oe.point!==En;)for(;;){const en=Oe.getAvailableLinkedEvents();if(0===en.length){const ir=Xt[0].point,dr=Xt[Xt.length-1].point;throw new Error(`Unable to complete output ring starting at [${ir.x}, ${ir.y}]. Last matching segment found ends at [${dr.x}, ${dr.y}].`)}if(1===en.length){je=en[0].otherSE;break}let mn=null;for(let ir=0,dr=ue.length;ir<dr;ir++)if(ue[ir].point===Oe.point){mn=ir;break}if(null!==mn){const ir=ue.splice(mn)[0],dr=Xt.splice(ir.index);dr.unshift(dr[0].otherSE),Rt.push(new Wn(dr.reverse()));continue}ue.push({index:Xt.length,point:Oe.point});const un=Oe.getLeftmostComparator(ze);je=en.sort(un)[0].otherSE;break}Rt.push(new Wn(Xt))}return Rt}constructor(Et){this.events=Et;for(let Rt=0,te=Et.length;Rt<te;Rt++)Et[Rt].segment.ringOut=this;this.poly=null}getGeom(){let Et=this.events[0].point;const Rt=[Et];for(let Xt=1,En=this.events.length-1;Xt<En;Xt++){const ue=this.events[Xt].point;0!==jt(ue,Et,this.events[Xt+1].point)&&(Rt.push(ue),Et=ue)}if(1===Rt.length)return null;0===jt(Rt[0],Et,Rt[1])&&Rt.shift(),Rt.push(Rt[0]);const ie=this.isExteriorRing()?1:-1,ze=this.isExteriorRing()?0:Rt.length-1,Oe=this.isExteriorRing()?Rt.length:-1,je=[];for(let Xt=ze;Xt!=Oe;Xt+=ie)je.push([Rt[Xt].x,Rt[Xt].y]);return je}isExteriorRing(){if(void 0===this._isExteriorRing){const Et=this.enclosingRing();this._isExteriorRing=!Et||!Et.isExteriorRing()}return this._isExteriorRing}enclosingRing(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let Et=this.events[0];for(let oe=1,ie=this.events.length;oe<ie;oe++){const ze=this.events[oe];Tn.compare(Et,ze)>0&&(Et=ze)}let Rt=Et.segment.prevInResult(),te=Rt?Rt.prevInResult():null;for(;;){if(!Rt)return null;if(!te)return Rt.ringOut;if(te.ringOut!==Rt.ringOut)return te.ringOut.enclosingRing()!==Rt.ringOut?Rt.ringOut:Rt.ringOut.enclosingRing();Rt=te.prevInResult(),te=Rt?Rt.prevInResult():null}}}class Er{constructor(Et){this.exteriorRing=Et,Et.poly=this,this.interiorRings=[]}addInterior(Et){this.interiorRings.push(Et),Et.poly=this}getGeom(){const Et=[this.exteriorRing.getGeom()];if(null===Et[0])return null;for(let Rt=0,te=this.interiorRings.length;Rt<te;Rt++){const oe=this.interiorRings[Rt].getGeom();null!==oe&&Et.push(oe)}return Et}}class Nn{constructor(Et){this.rings=Et,this.polys=this._composePolys(Et)}getGeom(){const Et=[];for(let Rt=0,te=this.polys.length;Rt<te;Rt++){const oe=this.polys[Rt].getGeom();null!==oe&&Et.push(oe)}return Et}_composePolys(Et){const Rt=[];for(let te=0,oe=Et.length;te<oe;te++){const ie=Et[te];if(!ie.poly)if(ie.isExteriorRing())Rt.push(new Er(ie));else{const ze=ie.enclosingRing();ze.poly||Rt.push(new Er(ze)),ze.poly.addInterior(ie)}}return Rt}}class Yn{constructor(Et){let Rt=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ne.compare;this.queue=Et,this.tree=new W(Rt),this.segments=[]}process(Et){const Rt=Et.segment,te=[];if(Et.consumedBy)return Et.isLeft?this.queue.remove(Et.otherSE):this.tree.remove(Rt),te;const oe=Et.isLeft?this.tree.add(Rt):this.tree.find(Rt);if(!oe)throw new Error(`Unable to find segment #${Rt.id} [${Rt.leftSE.point.x}, ${Rt.leftSE.point.y}] -> [${Rt.rightSE.point.x}, ${Rt.rightSE.point.y}] in SweepLine tree.`);let Oe,je,ie=oe,ze=oe;for(;void 0===Oe;)ie=this.tree.prev(ie),null===ie?Oe=null:void 0===ie.key.consumedBy&&(Oe=ie.key);for(;void 0===je;)ze=this.tree.next(ze),null===ze?je=null:void 0===ze.key.consumedBy&&(je=ze.key);if(Et.isLeft){let Xt=null;if(Oe){const ue=Oe.getIntersection(Rt);if(null!==ue&&(Rt.isAnEndpoint(ue)||(Xt=ue),!Oe.isAnEndpoint(ue))){const en=this._splitSafely(Oe,ue);for(let mn=0,un=en.length;mn<un;mn++)te.push(en[mn])}}let En=null;if(je){const ue=je.getIntersection(Rt);if(null!==ue&&(Rt.isAnEndpoint(ue)||(En=ue),!je.isAnEndpoint(ue))){const en=this._splitSafely(je,ue);for(let mn=0,un=en.length;mn<un;mn++)te.push(en[mn])}}if(null!==Xt||null!==En){let ue=null;ue=null===Xt?En:null===En||Tn.comparePoints(Xt,En)<=0?Xt:En,this.queue.remove(Rt.rightSE),te.push(Rt.rightSE);const en=Rt.split(ue);for(let mn=0,un=en.length;mn<un;mn++)te.push(en[mn])}te.length>0?(this.tree.remove(Rt),te.push(Et)):(this.segments.push(Rt),Rt.prev=Oe)}else{if(Oe&&je){const Xt=Oe.getIntersection(je);if(null!==Xt){if(!Oe.isAnEndpoint(Xt)){const En=this._splitSafely(Oe,Xt);for(let ue=0,en=En.length;ue<en;ue++)te.push(En[ue])}if(!je.isAnEndpoint(Xt)){const En=this._splitSafely(je,Xt);for(let ue=0,en=En.length;ue<en;ue++)te.push(En[ue])}}}this.tree.remove(Rt)}return te}_splitSafely(Et,Rt){this.tree.remove(Et);const te=Et.rightSE;this.queue.remove(te);const oe=Et.split(Rt);return oe.push(te),void 0===Et.consumedBy&&this.tree.add(Et),oe}}const hi=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,di=typeof process<"u"&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;const ii=new class to{run(Et,Rt,te){ii.type=Et,q.reset();const oe=[new Je(Rt,!0)];for(let ue=0,en=te.length;ue<en;ue++)oe.push(new Je(te[ue],!1));if(ii.numMultiPolys=oe.length,"difference"===ii.type){const ue=oe[0];let en=1;for(;en<oe.length;)null!==K(oe[en].bbox,ue.bbox)?en++:oe.splice(en,1)}if("intersection"===ii.type)for(let ue=0,en=oe.length;ue<en;ue++){const mn=oe[ue];for(let un=ue+1,ir=oe.length;un<ir;un++)if(null===K(mn.bbox,oe[un].bbox))return[]}const ie=new W(Tn.compare);for(let ue=0,en=oe.length;ue<en;ue++){const mn=oe[ue].getSweepEvents();for(let un=0,ir=mn.length;un<ir;un++)if(ie.insert(mn[un]),ie.size>hi)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const ze=new Yn(ie);let Oe=ie.size,je=ie.pop();for(;je;){const ue=je.key;if(ie.size===Oe){const mn=ue.segment;throw new Error(`Unable to pop() ${ue.isLeft?"left":"right"} SweepEvent [${ue.point.x}, ${ue.point.y}] from segment #${mn.id} [${mn.leftSE.point.x}, ${mn.leftSE.point.y}] -> [${mn.rightSE.point.x}, ${mn.rightSE.point.y}] from queue.`)}if(ie.size>hi)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(ze.segments.length>di)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const en=ze.process(ue);for(let mn=0,un=en.length;mn<un;mn++){const ir=en[mn];void 0===ir.consumedBy&&ie.insert(ir)}Oe=ie.size,je=ie.pop()}q.reset();const Xt=Wn.factory(ze.segments);return new Nn(Xt).getGeom()}};var Hs={union:function(Ce){for(var Et=arguments.length,Rt=new Array(Et>1?Et-1:0),te=1;te<Et;te++)Rt[te-1]=arguments[te];return ii.run("union",Ce,Rt)},intersection:function(Ce){for(var Et=arguments.length,Rt=new Array(Et>1?Et-1:0),te=1;te<Et;te++)Rt[te-1]=arguments[te];return ii.run("intersection",Ce,Rt)},xor:function(Ce){for(var Et=arguments.length,Rt=new Array(Et>1?Et-1:0),te=1;te<Et;te++)Rt[te-1]=arguments[te];return ii.run("xor",Ce,Rt)},difference:function(Ce){for(var Et=arguments.length,Rt=new Array(Et>1?Et-1:0),te=1;te<Et;te++)Rt[te-1]=arguments[te];return ii.run("difference",Ce,Rt)}};return Hs}()},5262:function(Lt){Lt.exports=function(){"use strict";function y(H,Q,Y,R,W){for(;R>Y;){if(R-Y>600){var k=R-Y+1,A=Q-Y+1,X=Math.log(k),Z=.5*Math.exp(2*X/3),G=.5*Math.sqrt(X*Z*(k-Z)/k)*(A-k/2<0?-1:1);y(H,Q,Math.max(Y,Math.floor(Q-A*Z/k+G)),Math.min(R,Math.floor(Q+(k-A)*Z/k+G)),W)}var K=H[Q],st=Y,et=R;for($(H,Y,Q),W(H[R],K)>0&&$(H,Y,R);st<et;){for($(H,st,et),st++,et--;W(H[st],K)<0;)st++;for(;W(H[et],K)>0;)et--}0===W(H[Y],K)?$(H,Y,et):$(H,++et,R),et<=Q&&(Y=et+1),Q<=et&&(R=et-1)}}function $(H,Q,Y){var R=H[Q];H[Q]=H[Y],H[Y]=R}function V(H,Q){return H<Q?-1:H>Q?1:0}return function ut(H,Q,Y,R,W){y(H,Q,Y||0,R||H.length-1,W||V)}}()},7861:(Lt,ut,y)=>{"use strict";Lt.exports=V,Lt.exports.default=V;var $=y(5262);function V(et,dt){if(!(this instanceof V))return new V(et,dt);this._maxEntries=Math.max(4,et||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),dt&&this._initFormat(dt),this.clear()}function H(et,dt,lt){if(!lt)return dt.indexOf(et);for(var St=0;St<dt.length;St++)if(lt(et,dt[St]))return St;return-1}function Q(et,dt){Y(et,0,et.children.length,dt,et)}function Y(et,dt,lt,St,q){q||(q=K(null)),q.minX=1/0,q.minY=1/0,q.maxX=-1/0,q.maxY=-1/0;for(var pt,ft=dt;ft<lt;ft++)pt=et.children[ft],R(q,et.leaf?St(pt):pt);return q}function R(et,dt){return et.minX=Math.min(et.minX,dt.minX),et.minY=Math.min(et.minY,dt.minY),et.maxX=Math.max(et.maxX,dt.maxX),et.maxY=Math.max(et.maxY,dt.maxY),et}function W(et,dt){return et.minX-dt.minX}function k(et,dt){return et.minY-dt.minY}function A(et){return(et.maxX-et.minX)*(et.maxY-et.minY)}function X(et){return et.maxX-et.minX+(et.maxY-et.minY)}function Z(et,dt){return(Math.max(dt.maxX,et.maxX)-Math.min(dt.minX,et.minX))*(Math.max(dt.maxY,et.maxY)-Math.min(dt.minY,et.minY))}function G(et,dt){var lt=Math.max(et.minX,dt.minX),St=Math.max(et.minY,dt.minY),q=Math.min(et.maxX,dt.maxX),ft=Math.min(et.maxY,dt.maxY);return Math.max(0,q-lt)*Math.max(0,ft-St)}function it(et,dt){return et.minX<=dt.minX&&et.minY<=dt.minY&&dt.maxX<=et.maxX&&dt.maxY<=et.maxY}function wt(et,dt){return dt.minX<=et.maxX&&dt.minY<=et.maxY&&dt.maxX>=et.minX&&dt.maxY>=et.minY}function K(et){return{children:et,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function st(et,dt,lt,St,q){for(var pt,ft=[dt,lt];ft.length;)!((lt=ft.pop())-(dt=ft.pop())<=St)&&(pt=dt+Math.ceil((lt-dt)/St/2)*St,$(et,pt,dt,lt,q),ft.push(dt,pt,pt,lt))}V.prototype={all:function(){return this._all(this.data,[])},search:function(et){var dt=this.data,lt=[],St=this.toBBox;if(!wt(et,dt))return lt;for(var ft,pt,B,ot,q=[];dt;){for(ft=0,pt=dt.children.length;ft<pt;ft++)B=dt.children[ft],wt(et,ot=dt.leaf?St(B):B)&&(dt.leaf?lt.push(B):it(et,ot)?this._all(B,lt):q.push(B));dt=q.pop()}return lt},collides:function(et){var dt=this.data,lt=this.toBBox;if(!wt(et,dt))return!1;for(var q,ft,pt,B,St=[];dt;){for(q=0,ft=dt.children.length;q<ft;q++)if(pt=dt.children[q],wt(et,B=dt.leaf?lt(pt):pt)){if(dt.leaf||it(et,B))return!0;St.push(pt)}dt=St.pop()}return!1},load:function(et){if(!et||!et.length)return this;if(et.length<this._minEntries){for(var dt=0,lt=et.length;dt<lt;dt++)this.insert(et[dt]);return this}var St=this._build(et.slice(),0,et.length-1,0);if(this.data.children.length)if(this.data.height===St.height)this._splitRoot(this.data,St);else{if(this.data.height<St.height){var q=this.data;this.data=St,St=q}this._insert(St,this.data.height-St.height-1,!0)}else this.data=St;return this},insert:function(et){return et&&this._insert(et,this.data.height-1),this},clear:function(){return this.data=K([]),this},remove:function(et,dt){if(!et)return this;for(var pt,B,ot,P,lt=this.data,St=this.toBBox(et),q=[],ft=[];lt||q.length;){if(lt||(lt=q.pop(),B=q[q.length-1],pt=ft.pop(),P=!0),lt.leaf&&-1!==(ot=H(et,lt.children,dt)))return lt.children.splice(ot,1),q.push(lt),this._condense(q),this;P||lt.leaf||!it(lt,St)?B?(pt++,lt=B.children[pt],P=!1):lt=null:(q.push(lt),ft.push(pt),pt=0,B=lt,lt=lt.children[0])}return this},toBBox:function(et){return et},compareMinX:W,compareMinY:k,toJSON:function(){return this.data},fromJSON:function(et){return this.data=et,this},_all:function(et,dt){for(var lt=[];et;)et.leaf?dt.push.apply(dt,et.children):lt.push.apply(lt,et.children),et=lt.pop();return dt},_build:function(et,dt,lt,St){var pt,q=lt-dt+1,ft=this._maxEntries;if(q<=ft)return Q(pt=K(et.slice(dt,lt+1)),this.toBBox),pt;St||(St=Math.ceil(Math.log(q)/Math.log(ft)),ft=Math.ceil(q/Math.pow(ft,St-1))),(pt=K([])).leaf=!1,pt.height=St;var P,at,nt,Gt,B=Math.ceil(q/ft),ot=B*Math.ceil(Math.sqrt(ft));for(st(et,dt,lt,ot,this.compareMinX),P=dt;P<=lt;P+=ot)for(st(et,P,nt=Math.min(P+ot-1,lt),B,this.compareMinY),at=P;at<=nt;at+=B)Gt=Math.min(at+B-1,nt),pt.children.push(this._build(et,at,Gt,St-1));return Q(pt,this.toBBox),pt},_chooseSubtree:function(et,dt,lt,St){for(var q,ft,pt,B,ot,P,at,nt;St.push(dt),!dt.leaf&&St.length-1!==lt;){for(at=nt=1/0,q=0,ft=dt.children.length;q<ft;q++)ot=A(pt=dt.children[q]),(P=Z(et,pt)-ot)<nt?(nt=P,at=ot<at?ot:at,B=pt):P===nt&&ot<at&&(at=ot,B=pt);dt=B||dt.children[0]}return dt},_insert:function(et,dt,lt){var q=lt?et:(0,this.toBBox)(et),ft=[],pt=this._chooseSubtree(q,this.data,dt,ft);for(pt.children.push(et),R(pt,q);dt>=0&&ft[dt].children.length>this._maxEntries;)this._split(ft,dt),dt--;this._adjustParentBBoxes(q,ft,dt)},_split:function(et,dt){var lt=et[dt],St=lt.children.length,q=this._minEntries;this._chooseSplitAxis(lt,q,St);var ft=this._chooseSplitIndex(lt,q,St),pt=K(lt.children.splice(ft,lt.children.length-ft));pt.height=lt.height,pt.leaf=lt.leaf,Q(lt,this.toBBox),Q(pt,this.toBBox),dt?et[dt-1].children.push(pt):this._splitRoot(lt,pt)},_splitRoot:function(et,dt){this.data=K([et,dt]),this.data.height=et.height+1,this.data.leaf=!1,Q(this.data,this.toBBox)},_chooseSplitIndex:function(et,dt,lt){var St,q,ft,pt,B,ot,P,at;for(ot=P=1/0,St=dt;St<=lt-dt;St++)pt=G(q=Y(et,0,St,this.toBBox),ft=Y(et,St,lt,this.toBBox)),B=A(q)+A(ft),pt<ot?(ot=pt,at=St,P=B<P?B:P):pt===ot&&B<P&&(P=B,at=St);return at},_chooseSplitAxis:function(et,dt,lt){var St=et.leaf?this.compareMinX:W,q=et.leaf?this.compareMinY:k;this._allDistMargin(et,dt,lt,St)<this._allDistMargin(et,dt,lt,q)&&et.children.sort(St)},_allDistMargin:function(et,dt,lt,St){et.children.sort(St);var ot,P,q=this.toBBox,ft=Y(et,0,dt,q),pt=Y(et,lt-dt,lt,q),B=X(ft)+X(pt);for(ot=dt;ot<lt-dt;ot++)P=et.children[ot],R(ft,et.leaf?q(P):P),B+=X(ft);for(ot=lt-dt-1;ot>=dt;ot--)P=et.children[ot],R(pt,et.leaf?q(P):P),B+=X(pt);return B},_adjustParentBBoxes:function(et,dt,lt){for(var St=lt;St>=0;St--)R(dt[St],et)},_condense:function(et){for(var lt,dt=et.length-1;dt>=0;dt--)0===et[dt].children.length?dt>0?(lt=et[dt-1].children).splice(lt.indexOf(et[dt]),1):this.clear():Q(et[dt],this.toBBox)},_initFormat:function(et){var dt=["return a"," - b",";"];this.compareMinX=new Function("a","b",dt.join(et[0])),this.compareMinY=new Function("a","b",dt.join(et[1])),this.toBBox=new Function("a","return {minX: a"+et[0]+", minY: a"+et[1]+", maxX: a"+et[2]+", maxY: a"+et[3]+"};")}}},3817:(Lt,ut,y)=>{"use strict";var $=y(9789),V=y(5223),H=Object;Lt.exports=$(function(){if(null==this||this!==H(this))throw new V("RegExp.prototype.flags getter called on non-object");var Y="";return this.hasIndices&&(Y+="d"),this.global&&(Y+="g"),this.ignoreCase&&(Y+="i"),this.multiline&&(Y+="m"),this.dotAll&&(Y+="s"),this.unicode&&(Y+="u"),this.unicodeSets&&(Y+="v"),this.sticky&&(Y+="y"),Y},"get flags",!0)},1139:(Lt,ut,y)=>{"use strict";var $=y(1648),V=y(5436),H=y(3817),Q=y(4861),Y=y(6002),R=V(Q());$(R,{getPolyfill:Q,implementation:H,shim:Y}),Lt.exports=R},4861:(Lt,ut,y)=>{"use strict";var $=y(3817),V=y(1648).supportsDescriptors,H=Object.getOwnPropertyDescriptor;Lt.exports=function(){if(V&&"gim"===/a/gim.flags){var Y=H(RegExp.prototype,"flags");if(Y&&"function"==typeof Y.get&&"boolean"==typeof RegExp.prototype.dotAll&&"boolean"==typeof RegExp.prototype.hasIndices){var R="",W={};if(Object.defineProperty(W,"hasIndices",{get:function(){R+="d"}}),Object.defineProperty(W,"sticky",{get:function(){R+="y"}}),"dy"===R)return Y.get}}return $}},6002:(Lt,ut,y)=>{"use strict";var $=y(1648).supportsDescriptors,V=y(4861),H=Object.getOwnPropertyDescriptor,Q=Object.defineProperty,Y=TypeError,R=Object.getPrototypeOf,W=/a/;Lt.exports=function(){if(!$||!R)throw new Y("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");var A=V(),X=R(W),Z=H(X,"flags");return(!Z||Z.get!==A)&&Q(X,"flags",{configurable:!0,enumerable:!1,get:A}),A}},6138:function(Lt,ut){!function(y){"use strict";function H(it,wt,K,st,et){let dt,lt,St,q,ft=wt[0],pt=st[0],B=0,ot=0;pt>ft==pt>-ft?(dt=ft,ft=wt[++B]):(dt=pt,pt=st[++ot]);let P=0;if(B<it&&ot<K)for(pt>ft==pt>-ft?(St=dt-((lt=ft+dt)-ft),ft=wt[++B]):(St=dt-((lt=pt+dt)-pt),pt=st[++ot]),dt=lt,0!==St&&(et[P++]=St);B<it&&ot<K;)pt>ft==pt>-ft?(St=dt-((lt=dt+ft)-(q=lt-dt))+(ft-q),ft=wt[++B]):(St=dt-((lt=dt+pt)-(q=lt-dt))+(pt-q),pt=st[++ot]),dt=lt,0!==St&&(et[P++]=St);for(;B<it;)St=dt-((lt=dt+ft)-(q=lt-dt))+(ft-q),ft=wt[++B],dt=lt,0!==St&&(et[P++]=St);for(;ot<K;)St=dt-((lt=dt+pt)-(q=lt-dt))+(pt-q),pt=st[++ot],dt=lt,0!==St&&(et[P++]=St);return 0===dt&&0!==P||(et[P++]=dt),P}function Q(it){return new Float64Array(it)}const k=Q(4),A=Q(8),X=Q(12),Z=Q(16),G=Q(4);y.orient2d=function(it,wt,K,st,et,dt){const lt=(wt-dt)*(K-et),St=(it-et)*(st-dt),q=lt-St;if(0===lt||0===St||lt>0!=St>0)return q;const ft=Math.abs(lt+St);return Math.abs(q)>=33306690738754716e-32*ft?q:-function(pt,B,ot,P,at,nt,Gt){let O,Ct,yt,vt,xt,Mt,It,re,Bt,ee,jt,se,we,Me,Xe,Ue,De,Tn;const On=pt-at,ne=ot-at,pe=B-nt,Ie=P-nt;xt=(Xe=(re=On-(It=(Mt=134217729*On)-(Mt-On)))*(ee=Ie-(Bt=(Mt=134217729*Ie)-(Mt-Ie)))-((Me=On*Ie)-It*Bt-re*Bt-It*ee))-(jt=Xe-(De=(re=pe-(It=(Mt=134217729*pe)-(Mt-pe)))*(ee=ne-(Bt=(Mt=134217729*ne)-(Mt-ne)))-((Ue=pe*ne)-It*Bt-re*Bt-It*ee))),k[0]=Xe-(jt+xt)+(xt-De),xt=(we=Me-((se=Me+jt)-(xt=se-Me))+(jt-xt))-(jt=we-Ue),k[1]=we-(jt+xt)+(xt-Ue),xt=(Tn=se+jt)-se,k[2]=se-(Tn-xt)+(jt-xt),k[3]=Tn;let Je=function(hi,di){let to=di[0];for(let ii=1;ii<4;ii++)to+=di[ii];return to}(0,k),Wn=22204460492503146e-32*Gt;if(Je>=Wn||-Je>=Wn||(O=pt-(On+(xt=pt-On))+(xt-at),yt=ot-(ne+(xt=ot-ne))+(xt-at),Ct=B-(pe+(xt=B-pe))+(xt-nt),vt=P-(Ie+(xt=P-Ie))+(xt-nt),0===O&&0===Ct&&0===yt&&0===vt)||(Wn=11093356479670487e-47*Gt+33306690738754706e-32*Math.abs(Je),(Je+=On*vt+Ie*O-(pe*yt+ne*Ct))>=Wn||-Je>=Wn))return Je;xt=(Xe=(re=O-(It=(Mt=134217729*O)-(Mt-O)))*(ee=Ie-(Bt=(Mt=134217729*Ie)-(Mt-Ie)))-((Me=O*Ie)-It*Bt-re*Bt-It*ee))-(jt=Xe-(De=(re=Ct-(It=(Mt=134217729*Ct)-(Mt-Ct)))*(ee=ne-(Bt=(Mt=134217729*ne)-(Mt-ne)))-((Ue=Ct*ne)-It*Bt-re*Bt-It*ee))),G[0]=Xe-(jt+xt)+(xt-De),xt=(we=Me-((se=Me+jt)-(xt=se-Me))+(jt-xt))-(jt=we-Ue),G[1]=we-(jt+xt)+(xt-Ue),xt=(Tn=se+jt)-se,G[2]=se-(Tn-xt)+(jt-xt),G[3]=Tn;const Er=H(4,k,4,G,A);xt=(Xe=(re=On-(It=(Mt=134217729*On)-(Mt-On)))*(ee=vt-(Bt=(Mt=134217729*vt)-(Mt-vt)))-((Me=On*vt)-It*Bt-re*Bt-It*ee))-(jt=Xe-(De=(re=pe-(It=(Mt=134217729*pe)-(Mt-pe)))*(ee=yt-(Bt=(Mt=134217729*yt)-(Mt-yt)))-((Ue=pe*yt)-It*Bt-re*Bt-It*ee))),G[0]=Xe-(jt+xt)+(xt-De),xt=(we=Me-((se=Me+jt)-(xt=se-Me))+(jt-xt))-(jt=we-Ue),G[1]=we-(jt+xt)+(xt-Ue),xt=(Tn=se+jt)-se,G[2]=se-(Tn-xt)+(jt-xt),G[3]=Tn;const Nn=H(Er,A,4,G,X);xt=(Xe=(re=O-(It=(Mt=134217729*O)-(Mt-O)))*(ee=vt-(Bt=(Mt=134217729*vt)-(Mt-vt)))-((Me=O*vt)-It*Bt-re*Bt-It*ee))-(jt=Xe-(De=(re=Ct-(It=(Mt=134217729*Ct)-(Mt-Ct)))*(ee=yt-(Bt=(Mt=134217729*yt)-(Mt-yt)))-((Ue=Ct*yt)-It*Bt-re*Bt-It*ee))),G[0]=Xe-(jt+xt)+(xt-De),xt=(we=Me-((se=Me+jt)-(xt=se-Me))+(jt-xt))-(jt=we-Ue),G[1]=we-(jt+xt)+(xt-Ue),xt=(Tn=se+jt)-se,G[2]=se-(Tn-xt)+(jt-xt),G[3]=Tn;const Yn=H(Nn,X,4,G,Z);return Z[Yn-1]}(it,wt,K,st,et,dt,ft)},y.orient2dfast=function(it,wt,K,st,et,dt){return(wt-dt)*(K-et)-(it-et)*(st-dt)},Object.defineProperty(y,"__esModule",{value:!0})}(ut)},9128:(Lt,ut,y)=>{var $=y(9864),V=y(3919),H=y(3263),Q=y(5353),Y=y(3358),R=y(3789),W=y(2508);W.alea=$,W.xor128=V,W.xorwow=H,W.xorshift7=Q,W.xor4096=Y,W.tychei=R,Lt.exports=W},9864:function(Lt,ut,y){var $;!function(V,H,Q){function Y(A){var X=this,Z=function k(){var A=4022871197;return function(Z){Z=String(Z);for(var G=0;G<Z.length;G++){var it=.02519603282416938*(A+=Z.charCodeAt(G));it-=A=it>>>0,A=(it*=A)>>>0,A+=4294967296*(it-=A)}return 2.3283064365386963e-10*(A>>>0)}}();X.next=function(){var G=2091639*X.s0+2.3283064365386963e-10*X.c;return X.s0=X.s1,X.s1=X.s2,X.s2=G-(X.c=0|G)},X.c=1,X.s0=Z(" "),X.s1=Z(" "),X.s2=Z(" "),X.s0-=Z(A),X.s0<0&&(X.s0+=1),X.s1-=Z(A),X.s1<0&&(X.s1+=1),X.s2-=Z(A),X.s2<0&&(X.s2+=1),Z=null}function R(A,X){return X.c=A.c,X.s0=A.s0,X.s1=A.s1,X.s2=A.s2,X}function W(A,X){var Z=new Y(A),G=X&&X.state,it=Z.next;return it.int32=function(){return 4294967296*Z.next()|0},it.double=function(){return it()+11102230246251565e-32*(2097152*it()|0)},it.quick=it,G&&("object"==typeof G&&R(G,Z),it.state=function(){return R(Z,{})}),it}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.alea=W}(0,Lt=y.nmd(Lt))},3789:function(Lt,ut,y){var $;!function(V,H,Q){function Y(k){var A=this,X="";A.next=function(){var G=A.b,it=A.c,wt=A.d,K=A.a;return G=G<<25^G>>>7^it,it=it-wt|0,wt=wt<<24^wt>>>8^K,K=K-G|0,A.b=G=G<<20^G>>>12^it,A.c=it=it-wt|0,A.d=wt<<16^it>>>16^K,A.a=K-G|0},A.a=0,A.b=0,A.c=-1640531527,A.d=1367130551,k===Math.floor(k)?(A.a=k/4294967296|0,A.b=0|k):X+=k;for(var Z=0;Z<X.length+20;Z++)A.b^=0|X.charCodeAt(Z),A.next()}function R(k,A){return A.a=k.a,A.b=k.b,A.c=k.c,A.d=k.d,A}function W(k,A){var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&("object"==typeof Z&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.tychei=W}(0,Lt=y.nmd(Lt))},3919:function(Lt,ut,y){var $;!function(V,H,Q){function Y(k){var A=this,X="";A.x=0,A.y=0,A.z=0,A.w=0,A.next=function(){var G=A.x^A.x<<11;return A.x=A.y,A.y=A.z,A.z=A.w,A.w^=A.w>>>19^G^G>>>8},k===(0|k)?A.x=k:X+=k;for(var Z=0;Z<X.length+64;Z++)A.x^=0|X.charCodeAt(Z),A.next()}function R(k,A){return A.x=k.x,A.y=k.y,A.z=k.z,A.w=k.w,A}function W(k,A){var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&("object"==typeof Z&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.xor128=W}(0,Lt=y.nmd(Lt))},3358:function(Lt,ut,y){var $;!function(V,H,Q){function Y(k){var A=this;A.next=function(){var wt,K,Z=A.w,G=A.X,it=A.i;return A.w=Z=Z+1640531527|0,K=G[it+34&127],wt=G[it=it+1&127],K^=K<<13,wt^=wt<<17,K=G[it]=(K^=K>>>15)^(wt^=wt>>>12),A.i=it,K+(Z^Z>>>16)|0},function X(Z,G){var it,wt,K,st,et,dt=[],lt=128;for(G===(0|G)?(wt=G,G=null):(G+="\0",wt=0,lt=Math.max(lt,G.length)),K=0,st=-32;st<lt;++st)G&&(wt^=G.charCodeAt((st+32)%G.length)),0===st&&(et=wt),wt^=wt<<10,wt^=wt>>>15,wt^=wt<<4,wt^=wt>>>13,st>=0&&(K=0==(it=dt[127&st]^=wt+(et=et+1640531527|0))?K+1:0);for(K>=128&&(dt[127&(G&&G.length||0)]=-1),K=127,st=512;st>0;--st)wt=dt[K+34&127],it=dt[K=K+1&127],wt^=wt<<13,it^=it<<17,dt[K]=(wt^=wt>>>15)^(it^=it>>>12);Z.w=et,Z.X=dt,Z.i=K}(A,k)}function R(k,A){return A.i=k.i,A.w=k.w,A.X=k.X.slice(),A}function W(k,A){null==k&&(k=+new Date);var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&(Z.X&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.xor4096=W}(0,Lt=y.nmd(Lt))},5353:function(Lt,ut,y){var $;!function(V,H,Q){function Y(k){var A=this;A.next=function(){var it,wt,Z=A.x,G=A.i;return it=Z[G],wt=(it^=it>>>7)^it<<24,wt^=(it=Z[G+1&7])^it>>>10,wt^=(it=Z[G+3&7])^it>>>3,wt^=(it=Z[G+4&7])^it<<7,it=Z[G+7&7],Z[G]=wt^=(it^=it<<13)^it<<9,A.i=G+1&7,wt},function X(Z,G){var it,K=[];if(G===(0|G))K[0]=G;else for(G=""+G,it=0;it<G.length;++it)K[7&it]=K[7&it]<<15^G.charCodeAt(it)+K[it+1&7]<<13;for(;K.length<8;)K.push(0);for(it=0;it<8&&0===K[it];++it);for(8==it&&(K[7]=-1),Z.x=K,Z.i=0,it=256;it>0;--it)Z.next()}(A,k)}function R(k,A){return A.x=k.x.slice(),A.i=k.i,A}function W(k,A){null==k&&(k=+new Date);var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&(Z.x&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.xorshift7=W}(0,Lt=y.nmd(Lt))},3263:function(Lt,ut,y){var $;!function(V,H,Q){function Y(k){var A=this,X="";A.next=function(){var G=A.x^A.x>>>2;return A.x=A.y,A.y=A.z,A.z=A.w,A.w=A.v,(A.d=A.d+362437|0)+(A.v=A.v^A.v<<4^G^G<<1)|0},A.x=0,A.y=0,A.z=0,A.w=0,A.v=0,k===(0|k)?A.x=k:X+=k;for(var Z=0;Z<X.length+64;Z++)A.x^=0|X.charCodeAt(Z),Z==X.length&&(A.d=A.x<<10^A.x>>>4),A.next()}function R(k,A){return A.x=k.x,A.y=k.y,A.z=k.z,A.w=k.w,A.v=k.v,A.d=k.d,A}function W(k,A){var X=new Y(k),Z=A&&A.state,G=function(){return(X.next()>>>0)/4294967296};return G.double=function(){do{var K=((X.next()>>>11)+(X.next()>>>0)/4294967296)/(1<<21)}while(0===K);return K},G.int32=X.next,G.quick=G,Z&&("object"==typeof Z&&R(Z,X),G.state=function(){return R(X,{})}),G}H&&H.exports?H.exports=W:y.amdD&&y.amdO?void 0!==($=function(){return W}.call(ut,y,ut,H))&&(H.exports=$):this.xorwow=W}(0,Lt=y.nmd(Lt))},2508:function(Lt,ut,y){var $;!function(V,H,Q){var it,Y=256,A=Q.pow(Y,6),X=Q.pow(2,52),Z=2*X,G=Y-1;function wt(q,ft,pt){var B=[],ot=dt(et((ft=1==ft?{entropy:!0}:ft||{}).entropy?[q,St(H)]:q??function lt(){try{var q;return it&&(q=it.randomBytes)?q=q(Y):(q=new Uint8Array(Y),(V.crypto||V.msCrypto).getRandomValues(q)),St(q)}catch{var ft=V.navigator,pt=ft&&ft.plugins;return[+new Date,V,pt,V.screen,St(H)]}}(),3),B),P=new K(B),at=function(){for(var nt=P.g(6),Gt=A,O=0;nt<X;)nt=(nt+O)*Y,Gt*=Y,O=P.g(1);for(;nt>=Z;)nt/=2,Gt/=2,O>>>=1;return(nt+O)/Gt};return at.int32=function(){return 0|P.g(4)},at.quick=function(){return P.g(4)/4294967296},at.double=at,dt(St(P.S),H),(ft.pass||pt||function(nt,Gt,O,Ct){return Ct&&(Ct.S&&st(Ct,P),nt.state=function(){return st(P,{})}),O?(Q.random=nt,Gt):nt})(at,ot,"global"in ft?ft.global:this==Q,ft.state)}function K(q){var ft,pt=q.length,B=this,ot=0,P=B.i=B.j=0,at=B.S=[];for(pt||(q=[pt++]);ot<Y;)at[ot]=ot++;for(ot=0;ot<Y;ot++)at[ot]=at[P=G&P+q[ot%pt]+(ft=at[ot])],at[P]=ft;(B.g=function(nt){for(var Gt,O=0,Ct=B.i,yt=B.j,vt=B.S;nt--;)Gt=vt[Ct=G&Ct+1],O=O*Y+vt[G&(vt[Ct]=vt[yt=G&yt+Gt])+(vt[yt]=Gt)];return B.i=Ct,B.j=yt,O})(Y)}function st(q,ft){return ft.i=q.i,ft.j=q.j,ft.S=q.S.slice(),ft}function et(q,ft){var ot,pt=[],B=typeof q;if(ft&&"object"==B)for(ot in q)try{pt.push(et(q[ot],ft-1))}catch{}return pt.length?pt:"string"==B?q:q+"\0"}function dt(q,ft){for(var B,pt=q+"",ot=0;ot<pt.length;)ft[G&ot]=G&(B^=19*ft[G&ot])+pt.charCodeAt(ot++);return St(ft)}function St(q){return String.fromCharCode.apply(0,q)}if(dt(Q.random(),H),Lt.exports){Lt.exports=wt;try{it=y(5042)}catch{}}else void 0!==($=function(){return wt}.call(ut,y,ut,Lt))&&(Lt.exports=$)}(typeof self<"u"?self:this,[],Math)},2245:(Lt,ut,y)=>{"use strict";var $=y(491),V=y(9224),H=y(2486)(),Q=y(9262),Y=y(5223),R=$("%Math.floor%");Lt.exports=function(k,A){if("function"!=typeof k)throw new Y("`fn` is not a function");if("number"!=typeof A||A<0||A>4294967295||R(A)!==A)throw new Y("`length` must be a positive 32-bit integer");var X=arguments.length>2&&!!arguments[2],Z=!0,G=!0;if("length"in k&&Q){var it=Q(k,"length");it&&!it.configurable&&(Z=!1),it&&!it.writable&&(G=!1)}return(Z||G||!X)&&(H?V(k,"length",A,!0,!0):V(k,"length",A)),k}},9789:(Lt,ut,y)=>{"use strict";var $=y(9224),V=y(2486)(),H=y(1552).functionsHaveConfigurableNames(),Q=y(5223);Lt.exports=function(R,W){if("function"!=typeof R)throw new Q("`fn` is not a function");return(!(arguments.length>2&&arguments[2])||H)&&(V?$(R,"name",W,!0,!0):$(R,"name",W)),R}},9579:Lt=>{"use strict";Lt.exports={eudist:function(y,$,V){for(var H=y.length,Q=0,Y=0;Y<H;Y++){var R=(y[Y]||0)-($[Y]||0);Q+=R*R}return V?Math.sqrt(Q):Q},mandist:function(y,$,V){for(var H=y.length,Q=0,Y=0;Y<H;Y++)Q+=Math.abs((y[Y]||0)-($[Y]||0));return V?Math.sqrt(Q):Q},dist:function(y,$,V){var H=Math.abs(y-$);return V?H:H*H}}},7180:(Lt,ut,y)=>{"use strict";var $=y(9579),V=$.eudist,H=$.dist;Lt.exports={kmrand:function(Y,R){for(var W={},k=[],A=R<<2,X=Y.length,Z=Y[0].length>0;k.length<R&&A-- >0;){var G=Y[Math.floor(Math.random()*X)],it=Z?G.join("_"):""+G;W[it]||(W[it]=!0,k.push(G))}if(k.length<R)throw new Error("Error initializating clusters");return k},kmpp:function(Y,R){var W=Y[0].length?V:H,k=[],A=Y.length,X=Y[0].length>0,G=Y[Math.floor(Math.random()*A)];for(X&&G.join("_"),k.push(G);k.length<R;){for(var wt=[],K=k.length,st=0,et=[],dt=0;dt<A;dt++){for(var lt=1/0,St=0;St<K;St++){var q=W(Y[dt],k[St]);q<=lt&&(lt=q)}wt[dt]=lt}for(var ft=0;ft<A;ft++)st+=wt[ft];for(var pt=0;pt<A;pt++)et[pt]={i:pt,v:Y[pt],pr:wt[pt]/st,cs:0};et.sort(function(at,nt){return at.pr-nt.pr}),et[0].cs=et[0].pr;for(var B=1;B<A;B++)et[B].cs=et[B-1].cs+et[B].pr;for(var ot=Math.random(),P=0;P<A-1&&et[P++].cs<ot;);k.push(et[P-1].v)}return k}}},3282:(Lt,ut,y)=>{"use strict";var $=y(9579),V=y(7180),H=$.eudist,R=V.kmrand,W=V.kmpp;function A(Z,G,it){it=it||[];for(var wt=0;wt<Z;wt++)it[wt]=G;return it}Lt.exports=function X(Z,G,it,wt){var K=[],st=[],et=[],dt=[],lt=!1,St=wt||1e4,q=Z.length,ft=Z[0].length,pt=ft>0,B=[];if(it)K="kmrand"==it?R(Z,G):"kmpp"==it?W(Z,G):it;else for(var ot={};K.length<G;){var P=Math.floor(Math.random()*q);ot[P]||(ot[P]=!0,K.push(Z[P]))}do{A(G,0,B);for(var at=0;at<q;at++){for(var nt=1/0,Gt=0,O=0;O<G;O++)(dt=pt?H(Z[at],K[O]):Math.abs(Z[at]-K[O]))<=nt&&(nt=dt,Gt=O);et[at]=Gt,B[Gt]++}for(var Ct=[],vt=(st=[],0);vt<G;vt++)Ct[vt]=pt?A(ft,0,Ct[vt]):0,st[vt]=K[vt];if(pt){for(var xt=0;xt<G;xt++)K[xt]=[];for(var Mt=0;Mt<q;Mt++)for(var re=Ct[et[Mt]],Bt=Z[Mt],ee=0;ee<ft;ee++)re[ee]+=Bt[ee];lt=!0;for(var jt=0;jt<G;jt++){for(var se=K[jt],we=Ct[jt],Me=st[jt],Xe=B[jt],Ue=0;Ue<ft;Ue++)se[Ue]=we[Ue]/Xe||0;if(lt)for(var De=0;De<ft;De++)if(Me[De]!=se[De]){lt=!1;break}}}else{for(var Tn=0;Tn<q;Tn++)Ct[et[Tn]]+=Z[Tn];for(var ne=0;ne<G;ne++)K[ne]=Ct[ne]/B[ne]||0;lt=!0;for(var pe=0;pe<G;pe++)if(st[pe]!=K[pe]){lt=!1;break}}lt=lt||--St<=0}while(!lt);return{it:1e4-St,k:G,idxs:et,centroids:K}}},7935:(Lt,ut,y)=>{"use strict";y.r(ut),y.d(ut,{default:()=>$});class ${constructor(Q=[],Y=V){if(this.data=Q,this.length=this.data.length,this.compare=Y,this.length>0)for(let R=(this.length>>1)-1;R>=0;R--)this._down(R)}push(Q){this.data.push(Q),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const Q=this.data[0],Y=this.data.pop();return this.length--,this.length>0&&(this.data[0]=Y,this._down(0)),Q}peek(){return this.data[0]}_up(Q){const{data:Y,compare:R}=this,W=Y[Q];for(;Q>0;){const k=Q-1>>1,A=Y[k];if(R(W,A)>=0)break;Y[Q]=A,Q=k}Y[Q]=W}_down(Q){const{data:Y,compare:R}=this,W=this.length>>1,k=Y[Q];for(;Q<W;){let A=1+(Q<<1),X=Y[A];const Z=A+1;if(Z<this.length&&R(Y[Z],X)<0&&(A=Z,X=Y[Z]),R(X,k)>=0)break;Y[Q]=X,Q=A}Y[Q]=k}}function V(H,Q){return H<Q?-1:H>Q?1:0}},4855:function(Lt,ut){!function(y){"use strict";function $(){}function V(l){this.message=l||""}function H(l){this.message=l||""}function Q(l){this.message=l||""}function Y(){}function R(l){return null===l?br:l.color}function W(l){return null===l?null:l.parent}function k(l,h){null!==l&&(l.color=h)}function A(l){return null===l?null:l.left}function X(l){return null===l?null:l.right}function Z(){this.root_=null,this.size_=0}function G(){}function it(){this.array_=[],arguments[0]instanceof je&&this.addAll(arguments[0])}function wt(){}function K(l){this.message=l||""}function st(){this.array_=[]}"fill"in Array.prototype||Object.defineProperty(Array.prototype,"fill",{configurable:!0,value:function(l){if(null==this)throw new TypeError(this+" is not an object");var h=Object(this),m=Math.max(Math.min(h.length,9007199254740991),0)||0,_=1 in arguments&&parseInt(Number(arguments[1]),10)||0;_=_<0?Math.max(m+_,0):Math.min(_,m);var C=2 in arguments&&void 0!==arguments[2]?parseInt(Number(arguments[2]),10)||0:m;for(C=C<0?Math.max(m+arguments[2],0):Math.min(C,m);_<C;)h[_]=l,++_;return h},writable:!0}),Number.isFinite=Number.isFinite||function(l){return"number"==typeof l&&isFinite(l)},Number.isInteger=Number.isInteger||function(l){return"number"==typeof l&&isFinite(l)&&Math.floor(l)===l},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(l){return l!=l},Math.trunc=Math.trunc||function(l){return l<0?Math.ceil(l):Math.floor(l)};var et=function(){};et.prototype.interfaces_=function(){return[]},et.prototype.getClass=function(){return et},et.prototype.equalsWithTolerance=function(l,h,m){return Math.abs(l-h)<=m};var dt=function(l){function h(m){l.call(this,m),this.name="IllegalArgumentException",this.message=m,this.stack=(new l).stack}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h}(Error),lt=function(){},St={MAX_VALUE:{configurable:!0}};lt.isNaN=function(l){return Number.isNaN(l)},lt.doubleToLongBits=function(l){return l},lt.longBitsToDouble=function(l){return l},lt.isInfinite=function(l){return!Number.isFinite(l)},St.MAX_VALUE.get=function(){return Number.MAX_VALUE},Object.defineProperties(lt,St);var q=function(){},ft=function(){},pt=function(){},B=function l(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)this.x=0,this.y=0,this.z=l.NULL_ORDINATE;else if(1===arguments.length){var h=arguments[0];this.x=h.x,this.y=h.y,this.z=h.z}else 2===arguments.length?(this.x=arguments[0],this.y=arguments[1],this.z=l.NULL_ORDINATE):3===arguments.length&&(this.x=arguments[0],this.y=arguments[1],this.z=arguments[2])},ot={DimensionalComparator:{configurable:!0},serialVersionUID:{configurable:!0},NULL_ORDINATE:{configurable:!0},X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0}};B.prototype.setOrdinate=function(l,h){switch(l){case B.X:this.x=h;break;case B.Y:this.y=h;break;case B.Z:this.z=h;break;default:throw new dt("Invalid ordinate index: "+l)}},B.prototype.equals2D=function(){if(1===arguments.length){var l=arguments[0];return this.x===l.x&&this.y===l.y}if(2===arguments.length){var h=arguments[0],m=arguments[1];return!!et.equalsWithTolerance(this.x,h.x,m)&&!!et.equalsWithTolerance(this.y,h.y,m)}},B.prototype.getOrdinate=function(l){switch(l){case B.X:return this.x;case B.Y:return this.y;case B.Z:return this.z}throw new dt("Invalid ordinate index: "+l)},B.prototype.equals3D=function(l){return this.x===l.x&&this.y===l.y&&(this.z===l.z||lt.isNaN(this.z))&&lt.isNaN(l.z)},B.prototype.equals=function(l){return l instanceof B&&this.equals2D(l)},B.prototype.equalInZ=function(l,h){return et.equalsWithTolerance(this.z,l.z,h)},B.prototype.compareTo=function(l){return this.x<l.x?-1:this.x>l.x?1:this.y<l.y?-1:this.y>l.y?1:0},B.prototype.clone=function(){},B.prototype.copy=function(){return new B(this)},B.prototype.toString=function(){return"("+this.x+", "+this.y+", "+this.z+")"},B.prototype.distance3D=function(l){var h=this.x-l.x,m=this.y-l.y,_=this.z-l.z;return Math.sqrt(h*h+m*m+_*_)},B.prototype.distance=function(l){var h=this.x-l.x,m=this.y-l.y;return Math.sqrt(h*h+m*m)},B.prototype.hashCode=function(){var l=17;return 37*(l=37*l+B.hashCode(this.x))+B.hashCode(this.y)},B.prototype.setCoordinate=function(l){this.x=l.x,this.y=l.y,this.z=l.z},B.prototype.interfaces_=function(){return[q,ft,$]},B.prototype.getClass=function(){return B},B.hashCode=function(){if(1===arguments.length){var h=lt.doubleToLongBits(arguments[0]);return Math.trunc((h^h)>>>32)}},ot.DimensionalComparator.get=function(){return P},ot.serialVersionUID.get=function(){return 0x5cbf2c235c7e5800},ot.NULL_ORDINATE.get=function(){return lt.NaN},ot.X.get=function(){return 0},ot.Y.get=function(){return 1},ot.Z.get=function(){return 2},Object.defineProperties(B,ot);var P=function(l){if(this._dimensionsToTest=2,0!==arguments.length&&1===arguments.length){var h=arguments[0];if(2!==h&&3!==h)throw new dt("only 2 or 3 dimensions may be specified");this._dimensionsToTest=h}};P.prototype.compare=function(l,h){var m=l,_=h,C=P.compare(m.x,_.x);if(0!==C)return C;var F=P.compare(m.y,_.y);return 0!==F?F:this._dimensionsToTest<=2?0:P.compare(m.z,_.z)},P.prototype.interfaces_=function(){return[pt]},P.prototype.getClass=function(){return P},P.compare=function(l,h){return l<h?-1:l>h?1:lt.isNaN(l)?lt.isNaN(h)?0:-1:lt.isNaN(h)?1:0};var at=function(){};at.prototype.create=function(){},at.prototype.interfaces_=function(){return[]},at.prototype.getClass=function(){return at};var nt=function(){},Gt={INTERIOR:{configurable:!0},BOUNDARY:{configurable:!0},EXTERIOR:{configurable:!0},NONE:{configurable:!0}};nt.prototype.interfaces_=function(){return[]},nt.prototype.getClass=function(){return nt},nt.toLocationSymbol=function(l){switch(l){case nt.EXTERIOR:return"e";case nt.BOUNDARY:return"b";case nt.INTERIOR:return"i";case nt.NONE:return"-"}throw new dt("Unknown location value: "+l)},Gt.INTERIOR.get=function(){return 0},Gt.BOUNDARY.get=function(){return 1},Gt.EXTERIOR.get=function(){return 2},Gt.NONE.get=function(){return-1},Object.defineProperties(nt,Gt);var O=function(l,h){return l.interfaces_&&l.interfaces_().indexOf(h)>-1},Ct=function(){},yt={LOG_10:{configurable:!0}};Ct.prototype.interfaces_=function(){return[]},Ct.prototype.getClass=function(){return Ct},Ct.log10=function(l){var h=Math.log(l);return lt.isInfinite(h)||lt.isNaN(h)?h:h/Ct.LOG_10},Ct.min=function(l,h,m,_){var C=l;return h<C&&(C=h),m<C&&(C=m),_<C&&(C=_),C},Ct.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var l=arguments[0],h=arguments[1],m=arguments[2];return l<h?h:l>m?m:l}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var _=arguments[0],C=arguments[1],F=arguments[2];return _<C?C:_>F?F:_}},Ct.wrap=function(l,h){return l<0?h- -l%h:l%h},Ct.max=function(){if(3===arguments.length){var h=arguments[1],m=arguments[2],_=arguments[0];return h>_&&(_=h),m>_&&(_=m),_}if(4===arguments.length){var F=arguments[1],rt=arguments[2],Dt=arguments[3],qt=arguments[0];return F>qt&&(qt=F),rt>qt&&(qt=rt),Dt>qt&&(qt=Dt),qt}},Ct.average=function(l,h){return(l+h)/2},yt.LOG_10.get=function(){return Math.log(10)},Object.defineProperties(Ct,yt);var vt=function(l){this.str=l};vt.prototype.append=function(l){this.str+=l},vt.prototype.setCharAt=function(l,h){this.str=this.str.substr(0,l)+h+this.str.substr(l+1)},vt.prototype.toString=function(l){return this.str};var xt=function(l){this.value=l};xt.prototype.intValue=function(){return this.value},xt.prototype.compareTo=function(l){return this.value<l?-1:this.value>l?1:0},xt.isNaN=function(l){return Number.isNaN(l)};var Mt=function(){};Mt.isWhitespace=function(l){return l<=32&&l>=0||127===l},Mt.toUpperCase=function(l){return l.toUpperCase()};var It=function l(){this._hi=0,this._lo=0,0===arguments.length?this.init(0):1===arguments.length?"number"==typeof arguments[0]||arguments[0]instanceof l?this.init(arguments[0]):"string"==typeof arguments[0]&&l.call(this,l.parse(arguments[0])):2===arguments.length&&this.init(arguments[0],arguments[1])},re={PI:{configurable:!0},TWO_PI:{configurable:!0},PI_2:{configurable:!0},E:{configurable:!0},NaN:{configurable:!0},EPS:{configurable:!0},SPLIT:{configurable:!0},MAX_PRINT_DIGITS:{configurable:!0},TEN:{configurable:!0},ONE:{configurable:!0},SCI_NOT_EXPONENT_CHAR:{configurable:!0},SCI_NOT_ZERO:{configurable:!0}};It.prototype.le=function(l){return(this._hi<l._hi||this._hi===l._hi)&&this._lo<=l._lo},It.prototype.extractSignificantDigits=function(l,h){var m=this.abs(),_=It.magnitude(m._hi),C=It.TEN.pow(_);(m=m.divide(C)).gt(It.TEN)?(m=m.divide(It.TEN),_+=1):m.lt(It.ONE)&&(m=m.multiply(It.TEN),_-=1);for(var F=_+1,rt=new vt,Dt=It.MAX_PRINT_DIGITS-1,qt=0;qt<=Dt;qt++){l&&qt===F&&rt.append(".");var fe=Math.trunc(m._hi);if(fe<0)break;var ke=!1,Ge=0;fe>9?(ke=!0,Ge="9"):Ge="0"+fe,rt.append(Ge),m=m.subtract(It.valueOf(fe)).multiply(It.TEN),ke&&m.selfAdd(It.TEN);var xn=!0,Sn=It.magnitude(m._hi);if(Sn<0&&Math.abs(Sn)>=Dt-qt&&(xn=!1),!xn)break}return h[0]=_,rt.toString()},It.prototype.sqr=function(){return this.multiply(this)},It.prototype.doubleValue=function(){return this._hi+this._lo},It.prototype.subtract=function(){return arguments[0]instanceof It?this.add(arguments[0].negate()):"number"==typeof arguments[0]?this.add(-arguments[0]):void 0},It.prototype.equals=function(){if(1===arguments.length){var l=arguments[0];return this._hi===l._hi&&this._lo===l._lo}},It.prototype.isZero=function(){return 0===this._hi&&0===this._lo},It.prototype.selfSubtract=function(){if(arguments[0]instanceof It){var l=arguments[0];return this.isNaN()?this:this.selfAdd(-l._hi,-l._lo)}if("number"==typeof arguments[0]){var h=arguments[0];return this.isNaN()?this:this.selfAdd(-h,0)}},It.prototype.getSpecialNumberString=function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},It.prototype.min=function(l){return this.le(l)?this:l},It.prototype.selfDivide=function(){if(1===arguments.length){if(arguments[0]instanceof It){var l=arguments[0];return this.selfDivide(l._hi,l._lo)}if("number"==typeof arguments[0])return this.selfDivide(arguments[0],0)}else if(2===arguments.length){var F,Dt,qt,ke,m=arguments[0],C=null,rt=null,fe=null,Ge=null;return this._hi=Ge=(qt=this._hi/m)+(fe=(this._hi-(ke=qt*m)-(Ge=(C=(fe=It.SPLIT*qt)-(C=fe-qt))*(rt=(Ge=It.SPLIT*m)-(rt=Ge-m))-ke+C*(Dt=m-rt)+(F=qt-C)*rt+F*Dt)+this._lo-qt*arguments[1])/m),this._lo=qt-Ge+fe,this}},It.prototype.dump=function(){return"DD<"+this._hi+", "+this._lo+">"},It.prototype.divide=function(){if(arguments[0]instanceof It){var m,C,F,Dt,l=arguments[0],h=null,_=null,rt=null,qt=null;return m=(F=this._hi/l._hi)-(h=(rt=It.SPLIT*F)-(h=rt-F)),qt=h*(_=(qt=It.SPLIT*l._hi)-(_=qt-l._hi))-(Dt=F*l._hi)+h*(C=l._hi-_)+m*_+m*C,new It(qt=F+(rt=(this._hi-Dt-qt+this._lo-F*l._lo)/l._hi),F-qt+rt)}if("number"==typeof arguments[0]){var fe=arguments[0];return lt.isNaN(fe)?It.createNaN():It.copy(this).selfDivide(fe,0)}},It.prototype.ge=function(l){return(this._hi>l._hi||this._hi===l._hi)&&this._lo>=l._lo},It.prototype.pow=function(l){if(0===l)return It.valueOf(1);var h=new It(this),m=It.valueOf(1),_=Math.abs(l);if(_>1)for(;_>0;)_%2==1&&m.selfMultiply(h),(_/=2)>0&&(h=h.sqr());else m=h;return l<0?m.reciprocal():m},It.prototype.ceil=function(){if(this.isNaN())return It.NaN;var l=Math.ceil(this._hi),h=0;return l===this._hi&&(h=Math.ceil(this._lo)),new It(l,h)},It.prototype.compareTo=function(l){return this._hi<l._hi?-1:this._hi>l._hi?1:this._lo<l._lo?-1:this._lo>l._lo?1:0},It.prototype.rint=function(){return this.isNaN()?this:this.add(.5).floor()},It.prototype.setValue=function(){return arguments[0]instanceof It||"number"==typeof arguments[0]?(this.init(arguments[0]),this):void 0},It.prototype.max=function(l){return this.ge(l)?this:l},It.prototype.sqrt=function(){if(this.isZero())return It.valueOf(0);if(this.isNegative())return It.NaN;var l=1/Math.sqrt(this._hi),m=It.valueOf(this._hi*l),_=this.subtract(m.sqr())._hi*(.5*l);return m.add(_)},It.prototype.selfAdd=function(){if(1===arguments.length){if(arguments[0]instanceof It){var l=arguments[0];return this.selfAdd(l._hi,l._lo)}if("number"==typeof arguments[0]){var m,_,C,rt,Dt,h=arguments[0];return this._hi=(m=(C=this._hi+h)+(Dt=h-(rt=C-this._hi)+(this._hi-(C-rt))+this._lo))+(_=Dt+(C-m)),this._lo=_+(m-this._hi),this}}else if(2===arguments.length){var ke,Ge,Sn,Ji,qt=arguments[0],fe=arguments[1],xn=null,Un=null,ur=null;Un=(Sn=this._hi+qt)-(ur=Sn-this._hi),xn=(Ge=this._lo+fe)-(Ji=Ge-this._lo);var Do=(ke=Sn+(ur=(Un=qt-ur+(this._hi-Un))+Ge))+(ur=(xn=fe-Ji+(this._lo-xn))+(ur+(Sn-ke))),Fa=ur+(ke-Do);return this._hi=Do,this._lo=Fa,this}},It.prototype.selfMultiply=function(){if(1===arguments.length){if(arguments[0]instanceof It){var l=arguments[0];return this.selfMultiply(l._hi,l._lo)}if("number"==typeof arguments[0])return this.selfMultiply(arguments[0],0)}else if(2===arguments.length){var F,Dt,m=arguments[0],C=null,rt=null,qt=null,fe=null;C=(qt=It.SPLIT*this._hi)-this._hi,C=qt-C;var ke=(qt=this._hi*m)+(fe=C*(rt=(fe=It.SPLIT*m)-(rt=fe-m))-qt+C*(Dt=m-rt)+(F=this._hi-C)*rt+F*Dt+(this._hi*arguments[1]+this._lo*m)),Ge=fe+(C=qt-ke);return this._hi=ke,this._lo=Ge,this}},It.prototype.selfSqr=function(){return this.selfMultiply(this)},It.prototype.floor=function(){if(this.isNaN())return It.NaN;var l=Math.floor(this._hi),h=0;return l===this._hi&&(h=Math.floor(this._lo)),new It(l,h)},It.prototype.negate=function(){return this.isNaN()?this:new It(-this._hi,-this._lo)},It.prototype.clone=function(){},It.prototype.multiply=function(){if(arguments[0]instanceof It){var l=arguments[0];return l.isNaN()?It.createNaN():It.copy(this).selfMultiply(l)}if("number"==typeof arguments[0]){var h=arguments[0];return lt.isNaN(h)?It.createNaN():It.copy(this).selfMultiply(h,0)}},It.prototype.isNaN=function(){return lt.isNaN(this._hi)},It.prototype.intValue=function(){return Math.trunc(this._hi)},It.prototype.toString=function(){var l=It.magnitude(this._hi);return l>=-3&&l<=20?this.toStandardNotation():this.toSciNotation()},It.prototype.toStandardNotation=function(){var l=this.getSpecialNumberString();if(null!==l)return l;var h=new Array(1).fill(null),m=this.extractSignificantDigits(!0,h),_=h[0]+1,C=m;return"."===m.charAt(0)?C="0"+m:_<0?C="0."+It.stringOfChar("0",-_)+m:-1===m.indexOf(".")&&(C=m+It.stringOfChar("0",_-m.length)+".0"),this.isNegative()?"-"+C:C},It.prototype.reciprocal=function(){var h,_,C,rt,l=null,m=null,F=null,Dt=null;h=(C=1/this._hi)-(l=(F=It.SPLIT*C)-(l=F-C)),m=(Dt=It.SPLIT*this._hi)-this._hi;var qt=C+(F=(1-(rt=C*this._hi)-(Dt=l*(m=Dt-m)-rt+l*(_=this._hi-m)+h*m+h*_)-C*this._lo)/this._hi);return new It(qt,C-qt+F)},It.prototype.toSciNotation=function(){if(this.isZero())return It.SCI_NOT_ZERO;var l=this.getSpecialNumberString();if(null!==l)return l;var h=new Array(1).fill(null),m=this.extractSignificantDigits(!1,h),_=It.SCI_NOT_EXPONENT_CHAR+h[0];if("0"===m.charAt(0))throw new Error("Found leading zero: "+m);var C="";m.length>1&&(C=m.substring(1));var F=m.charAt(0)+"."+C;return this.isNegative()?"-"+F+_:F+_},It.prototype.abs=function(){return this.isNaN()?It.NaN:this.isNegative()?this.negate():new It(this)},It.prototype.isPositive=function(){return(this._hi>0||0===this._hi)&&this._lo>0},It.prototype.lt=function(l){return(this._hi<l._hi||this._hi===l._hi)&&this._lo<l._lo},It.prototype.add=function(){if(arguments[0]instanceof It){var l=arguments[0];return It.copy(this).selfAdd(l)}if("number"==typeof arguments[0]){var h=arguments[0];return It.copy(this).selfAdd(h)}},It.prototype.init=function(){if(1===arguments.length){if("number"==typeof arguments[0])this._hi=arguments[0],this._lo=0;else if(arguments[0]instanceof It){var h=arguments[0];this._hi=h._hi,this._lo=h._lo}}else if(2===arguments.length){var _=arguments[1];this._hi=arguments[0],this._lo=_}},It.prototype.gt=function(l){return(this._hi>l._hi||this._hi===l._hi)&&this._lo>l._lo},It.prototype.isNegative=function(){return(this._hi<0||0===this._hi)&&this._lo<0},It.prototype.trunc=function(){return this.isNaN()?It.NaN:this.isPositive()?this.floor():this.ceil()},It.prototype.signum=function(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0},It.prototype.interfaces_=function(){return[$,q,ft]},It.prototype.getClass=function(){return It},It.sqr=function(l){return It.valueOf(l).selfMultiply(l)},It.valueOf=function(){return"string"==typeof arguments[0]?It.parse(arguments[0]):"number"==typeof arguments[0]?new It(arguments[0]):void 0},It.sqrt=function(l){return It.valueOf(l).sqrt()},It.parse=function(l){for(var h=0,m=l.length;Mt.isWhitespace(l.charAt(h));)h++;var _=!1;if(h<m){var C=l.charAt(h);"-"!==C&&"+"!==C||(h++,"-"===C&&(_=!0))}for(var F=new It,rt=0,Dt=0,qt=0;!(h>=m);){var fe=l.charAt(h);if(h++,Mt.isDigit(fe)){var ke=fe-"0";F.selfMultiply(It.TEN),F.selfAdd(ke),rt++}else{if("."!==fe){if("e"===fe||"E"===fe){var Ge=l.substring(h);try{qt=xt.parseInt(Ge)}catch(Ji){throw Ji instanceof Error?new Error("Invalid exponent "+Ge+" in string "+l):Ji}break}throw new Error("Unexpected character '"+fe+"' at position "+h+" in string "+l)}Dt=rt}}var xn=F,Sn=rt-Dt-qt;if(0===Sn)xn=F;else if(Sn>0){var Un=It.TEN.pow(Sn);xn=F.divide(Un)}else if(Sn<0){var ur=It.TEN.pow(-Sn);xn=F.multiply(ur)}return _?xn.negate():xn},It.createNaN=function(){return new It(lt.NaN,lt.NaN)},It.copy=function(l){return new It(l)},It.magnitude=function(l){var h=Math.abs(l),m=Math.log(h)/Math.log(10),_=Math.trunc(Math.floor(m));return 10*Math.pow(10,_)<=h&&(_+=1),_},It.stringOfChar=function(l,h){for(var m=new vt,_=0;_<h;_++)m.append(l);return m.toString()},re.PI.get=function(){return new It(3.141592653589793,12246467991473532e-32)},re.TWO_PI.get=function(){return new It(6.283185307179586,24492935982947064e-32)},re.PI_2.get=function(){return new It(1.5707963267948966,6123233995736766e-32)},re.E.get=function(){return new It(2.718281828459045,14456468917292502e-32)},re.NaN.get=function(){return new It(lt.NaN,lt.NaN)},re.EPS.get=function(){return 123259516440783e-46},re.SPLIT.get=function(){return 134217729},re.MAX_PRINT_DIGITS.get=function(){return 32},re.TEN.get=function(){return It.valueOf(10)},re.ONE.get=function(){return It.valueOf(1)},re.SCI_NOT_EXPONENT_CHAR.get=function(){return"E"},re.SCI_NOT_ZERO.get=function(){return"0.0E0"},Object.defineProperties(It,re);var Bt=function(){},ee={DP_SAFE_EPSILON:{configurable:!0}};Bt.prototype.interfaces_=function(){return[]},Bt.prototype.getClass=function(){return Bt},Bt.orientationIndex=function(l,h,m){var _=Bt.orientationIndexFilter(l,h,m);if(_<=1)return _;var C=It.valueOf(h.x).selfAdd(-l.x),F=It.valueOf(h.y).selfAdd(-l.y),rt=It.valueOf(m.x).selfAdd(-h.x),Dt=It.valueOf(m.y).selfAdd(-h.y);return C.selfMultiply(Dt).selfSubtract(F.selfMultiply(rt)).signum()},Bt.signOfDet2x2=function(l,h,m,_){return l.multiply(_).selfSubtract(h.multiply(m)).signum()},Bt.intersection=function(l,h,m,_){var C=It.valueOf(_.y).selfSubtract(m.y).selfMultiply(It.valueOf(h.x).selfSubtract(l.x)),F=It.valueOf(_.x).selfSubtract(m.x).selfMultiply(It.valueOf(h.y).selfSubtract(l.y)),rt=C.subtract(F),Dt=It.valueOf(_.x).selfSubtract(m.x).selfMultiply(It.valueOf(l.y).selfSubtract(m.y)),qt=It.valueOf(_.y).selfSubtract(m.y).selfMultiply(It.valueOf(l.x).selfSubtract(m.x)),fe=Dt.subtract(qt).selfDivide(rt).doubleValue(),ke=It.valueOf(l.x).selfAdd(It.valueOf(h.x).selfSubtract(l.x).selfMultiply(fe)).doubleValue(),Ge=It.valueOf(h.x).selfSubtract(l.x).selfMultiply(It.valueOf(l.y).selfSubtract(m.y)),xn=It.valueOf(h.y).selfSubtract(l.y).selfMultiply(It.valueOf(l.x).selfSubtract(m.x)),Sn=Ge.subtract(xn).selfDivide(rt).doubleValue(),Un=It.valueOf(m.y).selfAdd(It.valueOf(_.y).selfSubtract(m.y).selfMultiply(Sn)).doubleValue();return new B(ke,Un)},Bt.orientationIndexFilter=function(l,h,m){var _=null,C=(l.x-m.x)*(h.y-m.y),F=(l.y-m.y)*(h.x-m.x),rt=C-F;if(C>0){if(F<=0)return Bt.signum(rt);_=C+F}else{if(!(C<0)||F>=0)return Bt.signum(rt);_=-C-F}var Dt=Bt.DP_SAFE_EPSILON*_;return rt>=Dt||-rt>=Dt?Bt.signum(rt):2},Bt.signum=function(l){return l>0?1:l<0?-1:0},ee.DP_SAFE_EPSILON.get=function(){return 1e-15},Object.defineProperties(Bt,ee);var jt=function(){},se={X:{configurable:!0},Y:{configurable:!0},Z:{configurable:!0},M:{configurable:!0}};se.X.get=function(){return 0},se.Y.get=function(){return 1},se.Z.get=function(){return 2},se.M.get=function(){return 3},jt.prototype.setOrdinate=function(l,h,m){},jt.prototype.size=function(){},jt.prototype.getOrdinate=function(l,h){},jt.prototype.getCoordinate=function(){},jt.prototype.getCoordinateCopy=function(l){},jt.prototype.getDimension=function(){},jt.prototype.getX=function(l){},jt.prototype.clone=function(){},jt.prototype.expandEnvelope=function(l){},jt.prototype.copy=function(){},jt.prototype.getY=function(l){},jt.prototype.toCoordinateArray=function(){},jt.prototype.interfaces_=function(){return[ft]},jt.prototype.getClass=function(){return jt},Object.defineProperties(jt,se);var we=function(){},Me=function(l){function h(){l.call(this,"Projective point not representable on the Cartesian plane.")}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(we),Xe=function(){};Xe.arraycopy=function(l,h,m,_,C){for(var F=0,rt=h;rt<h+C;rt++)m[_+F]=l[rt],F++},Xe.getProperty=function(l){return{"line.separator":"\n"}[l]};var Ue=function l(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var h=arguments[0];this.x=h.x,this.y=h.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var _=arguments[1];this.x=arguments[0],this.y=_,this.w=1}else if(arguments[0]instanceof l&&arguments[1]instanceof l){var C=arguments[0],F=arguments[1];this.x=C.y*F.w-F.y*C.w,this.y=F.x*C.w-C.x*F.w,this.w=C.x*F.y-F.x*C.y}else if(arguments[0]instanceof B&&arguments[1]instanceof B){var rt=arguments[0],Dt=arguments[1];this.x=rt.y-Dt.y,this.y=Dt.x-rt.x,this.w=rt.x*Dt.y-Dt.x*rt.y}}else if(3===arguments.length){var fe=arguments[1],ke=arguments[2];this.x=arguments[0],this.y=fe,this.w=ke}else if(4===arguments.length){var Ge=arguments[0],xn=arguments[1],Sn=arguments[2],Un=arguments[3],ur=Ge.y-xn.y,Ji=xn.x-Ge.x,Do=Ge.x*xn.y-xn.x*Ge.y,Fa=Sn.y-Un.y,ml=Un.x-Sn.x,Kl=Sn.x*Un.y-Un.x*Sn.y;this.x=Ji*Kl-ml*Do,this.y=Fa*Do-ur*Kl,this.w=ur*ml-Fa*Ji}};Ue.prototype.getY=function(){var l=this.y/this.w;if(lt.isNaN(l)||lt.isInfinite(l))throw new Me;return l},Ue.prototype.getX=function(){var l=this.x/this.w;if(lt.isNaN(l)||lt.isInfinite(l))throw new Me;return l},Ue.prototype.getCoordinate=function(){var l=new B;return l.x=this.getX(),l.y=this.getY(),l},Ue.prototype.interfaces_=function(){return[]},Ue.prototype.getClass=function(){return Ue},Ue.intersection=function(l,h,m,_){var C=l.y-h.y,F=h.x-l.x,rt=l.x*h.y-h.x*l.y,Dt=m.y-_.y,qt=_.x-m.x,fe=m.x*_.y-_.x*m.y,ke=C*qt-Dt*F,Ge=(F*fe-qt*rt)/ke,xn=(Dt*rt-C*fe)/ke;if(lt.isNaN(Ge)||lt.isInfinite(Ge)||lt.isNaN(xn)||lt.isInfinite(xn))throw new Me;return new B(Ge,xn)};var De=function l(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length)if(arguments[0]instanceof B){var h=arguments[0];this.init(h.x,h.x,h.y,h.y)}else arguments[0]instanceof l&&this.init(arguments[0]);else if(2===arguments.length){var _=arguments[0],C=arguments[1];this.init(_.x,C.x,_.y,C.y)}else 4===arguments.length&&this.init(arguments[0],arguments[1],arguments[2],arguments[3])},Tn={serialVersionUID:{configurable:!0}};De.prototype.getArea=function(){return this.getWidth()*this.getHeight()},De.prototype.equals=function(l){if(!(l instanceof De))return!1;var h=l;return this.isNull()?h.isNull():this._maxx===h.getMaxX()&&this._maxy===h.getMaxY()&&this._minx===h.getMinX()&&this._miny===h.getMinY()},De.prototype.intersection=function(l){return this.isNull()||l.isNull()||!this.intersects(l)?new De:new De(this._minx>l._minx?this._minx:l._minx,this._maxx<l._maxx?this._maxx:l._maxx,this._miny>l._miny?this._miny:l._miny,this._maxy<l._maxy?this._maxy:l._maxy)},De.prototype.isNull=function(){return this._maxx<this._minx},De.prototype.getMaxX=function(){return this._maxx},De.prototype.covers=function(){if(1===arguments.length){if(arguments[0]instanceof B){var l=arguments[0];return this.covers(l.x,l.y)}if(arguments[0]instanceof De){var h=arguments[0];return!this.isNull()&&!h.isNull()&&h.getMinX()>=this._minx&&h.getMaxX()<=this._maxx&&h.getMinY()>=this._miny&&h.getMaxY()<=this._maxy}}else if(2===arguments.length){var m=arguments[0],_=arguments[1];return!this.isNull()&&m>=this._minx&&m<=this._maxx&&_>=this._miny&&_<=this._maxy}},De.prototype.intersects=function(){if(1===arguments.length){if(arguments[0]instanceof De){var l=arguments[0];return!this.isNull()&&!l.isNull()&&!(l._minx>this._maxx||l._maxx<this._minx||l._miny>this._maxy||l._maxy<this._miny)}if(arguments[0]instanceof B){var h=arguments[0];return this.intersects(h.x,h.y)}}else if(2===arguments.length){var m=arguments[0],_=arguments[1];return!this.isNull()&&!(m>this._maxx||m<this._minx||_>this._maxy||_<this._miny)}},De.prototype.getMinY=function(){return this._miny},De.prototype.getMinX=function(){return this._minx},De.prototype.expandToInclude=function(){if(1===arguments.length){if(arguments[0]instanceof B){var l=arguments[0];this.expandToInclude(l.x,l.y)}else if(arguments[0]instanceof De){var h=arguments[0];if(h.isNull())return null;this.isNull()?(this._minx=h.getMinX(),this._maxx=h.getMaxX(),this._miny=h.getMinY(),this._maxy=h.getMaxY()):(h._minx<this._minx&&(this._minx=h._minx),h._maxx>this._maxx&&(this._maxx=h._maxx),h._miny<this._miny&&(this._miny=h._miny),h._maxy>this._maxy&&(this._maxy=h._maxy))}}else if(2===arguments.length){var m=arguments[0],_=arguments[1];this.isNull()?(this._minx=m,this._maxx=m,this._miny=_,this._maxy=_):(m<this._minx&&(this._minx=m),m>this._maxx&&(this._maxx=m),_<this._miny&&(this._miny=_),_>this._maxy&&(this._maxy=_))}},De.prototype.minExtent=function(){if(this.isNull())return 0;var l=this.getWidth(),h=this.getHeight();return l<h?l:h},De.prototype.getWidth=function(){return this.isNull()?0:this._maxx-this._minx},De.prototype.compareTo=function(l){var h=l;return this.isNull()?h.isNull()?0:-1:h.isNull()?1:this._minx<h._minx?-1:this._minx>h._minx?1:this._miny<h._miny?-1:this._miny>h._miny?1:this._maxx<h._maxx?-1:this._maxx>h._maxx?1:this._maxy<h._maxy?-1:this._maxy>h._maxy?1:0},De.prototype.translate=function(l,h){if(this.isNull())return null;this.init(this.getMinX()+l,this.getMaxX()+l,this.getMinY()+h,this.getMaxY()+h)},De.prototype.toString=function(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"},De.prototype.setToNull=function(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1},De.prototype.getHeight=function(){return this.isNull()?0:this._maxy-this._miny},De.prototype.maxExtent=function(){if(this.isNull())return 0;var l=this.getWidth(),h=this.getHeight();return l>h?l:h},De.prototype.expandBy=function(){if(1===arguments.length){var l=arguments[0];this.expandBy(l,l)}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this.isNull())return null;this._minx-=h,this._maxx+=h,this._miny-=m,this._maxy+=m,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}},De.prototype.contains=function(){if(1===arguments.length){if(arguments[0]instanceof De)return this.covers(arguments[0]);if(arguments[0]instanceof B)return this.covers(arguments[0])}else if(2===arguments.length)return this.covers(arguments[0],arguments[1])},De.prototype.centre=function(){return this.isNull()?null:new B((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},De.prototype.init=function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof B){var l=arguments[0];this.init(l.x,l.x,l.y,l.y)}else if(arguments[0]instanceof De){var h=arguments[0];this._minx=h._minx,this._maxx=h._maxx,this._miny=h._miny,this._maxy=h._maxy}}else if(2===arguments.length){var m=arguments[0],_=arguments[1];this.init(m.x,_.x,m.y,_.y)}else if(4===arguments.length){var C=arguments[0],F=arguments[1],rt=arguments[2],Dt=arguments[3];C<F?(this._minx=C,this._maxx=F):(this._minx=F,this._maxx=C),rt<Dt?(this._miny=rt,this._maxy=Dt):(this._miny=Dt,this._maxy=rt)}},De.prototype.getMaxY=function(){return this._maxy},De.prototype.distance=function(l){if(this.intersects(l))return 0;var h=0;this._maxx<l._minx?h=l._minx-this._maxx:this._minx>l._maxx&&(h=this._minx-l._maxx);var m=0;return this._maxy<l._miny?m=l._miny-this._maxy:this._miny>l._maxy&&(m=this._miny-l._maxy),0===h?m:0===m?h:Math.sqrt(h*h+m*m)},De.prototype.hashCode=function(){var l=17;return 37*(l=37*(l=37*(l=37*l+B.hashCode(this._minx))+B.hashCode(this._maxx))+B.hashCode(this._miny))+B.hashCode(this._maxy)},De.prototype.interfaces_=function(){return[q,$]},De.prototype.getClass=function(){return De},De.intersects=function(){if(3===arguments.length){var l=arguments[0],h=arguments[1],m=arguments[2];return m.x>=(l.x<h.x?l.x:h.x)&&m.x<=(l.x>h.x?l.x:h.x)&&m.y>=(l.y<h.y?l.y:h.y)&&m.y<=(l.y>h.y?l.y:h.y)}if(4===arguments.length){var _=arguments[0],C=arguments[1],F=arguments[2],rt=arguments[3],Dt=Math.min(F.x,rt.x),qt=Math.max(F.x,rt.x),fe=Math.min(_.x,C.x),ke=Math.max(_.x,C.x);return!(fe>qt||ke<Dt||(Dt=Math.min(F.y,rt.y),qt=Math.max(F.y,rt.y),fe=Math.min(_.y,C.y),ke=Math.max(_.y,C.y),fe>qt||ke<Dt))}},Tn.serialVersionUID.get=function(){return 0x51845cd552189800},Object.defineProperties(De,Tn);var On={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/},ne=function(l){this.geometryFactory=l||new er};ne.prototype.read=function(l){var h,m;l=l.replace(/[\n\r]/g," ");var C=On.typeStr.exec(l);if(-1!==l.search("EMPTY")&&((C=On.emptyTypeStr.exec(l))[2]=void 0),C&&(m=C[1].toLowerCase(),Ie[m]&&(h=Ie[m].apply(this,[C[2]]))),void 0===h)throw new Error("Could not parse WKT "+l);return h},ne.prototype.write=function(l){return this.extractGeometry(l)},ne.prototype.extractGeometry=function(l){var h=l.getGeometryType().toLowerCase();if(!pe[h])return null;var m=h.toUpperCase();return l.isEmpty()?m+" EMPTY":m+"("+pe[h].apply(this,[l])+")"};var pe={coordinate:function(l){return l.x+" "+l.y},point:function(l){return pe.coordinate.call(this,l._coordinates._coordinates[0])},multipoint:function(l){for(var h=[],m=0,_=l._geometries.length;m<_;++m)h.push("("+pe.point.apply(this,[l._geometries[m]])+")");return h.join(",")},linestring:function(l){for(var h=[],m=0,_=l._points._coordinates.length;m<_;++m)h.push(pe.coordinate.apply(this,[l._points._coordinates[m]]));return h.join(",")},linearring:function(l){for(var h=[],m=0,_=l._points._coordinates.length;m<_;++m)h.push(pe.coordinate.apply(this,[l._points._coordinates[m]]));return h.join(",")},multilinestring:function(l){for(var h=[],m=0,_=l._geometries.length;m<_;++m)h.push("("+pe.linestring.apply(this,[l._geometries[m]])+")");return h.join(",")},polygon:function(l){var h=[];h.push("("+pe.linestring.apply(this,[l._shell])+")");for(var m=0,_=l._holes.length;m<_;++m)h.push("("+pe.linestring.apply(this,[l._holes[m]])+")");return h.join(",")},multipolygon:function(l){for(var h=[],m=0,_=l._geometries.length;m<_;++m)h.push("("+pe.polygon.apply(this,[l._geometries[m]])+")");return h.join(",")},geometrycollection:function(l){for(var h=[],m=0,_=l._geometries.length;m<_;++m)h.push(this.extractGeometry(l._geometries[m]));return h.join(",")}},Ie={point:function(l){if(void 0===l)return this.geometryFactory.createPoint();var h=l.trim().split(On.spaces);return this.geometryFactory.createPoint(new B(Number.parseFloat(h[0]),Number.parseFloat(h[1])))},multipoint:function(l){if(void 0===l)return this.geometryFactory.createMultiPoint();for(var h,m=l.trim().split(","),_=[],C=0,F=m.length;C<F;++C)h=m[C].replace(On.trimParens,"$1"),_.push(Ie.point.apply(this,[h]));return this.geometryFactory.createMultiPoint(_)},linestring:function(l){if(void 0===l)return this.geometryFactory.createLineString();for(var h,m=l.trim().split(","),_=[],C=0,F=m.length;C<F;++C)h=m[C].trim().split(On.spaces),_.push(new B(Number.parseFloat(h[0]),Number.parseFloat(h[1])));return this.geometryFactory.createLineString(_)},linearring:function(l){if(void 0===l)return this.geometryFactory.createLinearRing();for(var h,m=l.trim().split(","),_=[],C=0,F=m.length;C<F;++C)h=m[C].trim().split(On.spaces),_.push(new B(Number.parseFloat(h[0]),Number.parseFloat(h[1])));return this.geometryFactory.createLinearRing(_)},multilinestring:function(l){if(void 0===l)return this.geometryFactory.createMultiLineString();for(var h,m=l.trim().split(On.parenComma),_=[],C=0,F=m.length;C<F;++C)h=m[C].replace(On.trimParens,"$1"),_.push(Ie.linestring.apply(this,[h]));return this.geometryFactory.createMultiLineString(_)},polygon:function(l){if(void 0===l)return this.geometryFactory.createPolygon();for(var h,m,_,C,F=l.trim().split(On.parenComma),rt=[],Dt=0,qt=F.length;Dt<qt;++Dt)h=F[Dt].replace(On.trimParens,"$1"),m=Ie.linestring.apply(this,[h]),_=this.geometryFactory.createLinearRing(m._points),0===Dt?C=_:rt.push(_);return this.geometryFactory.createPolygon(C,rt)},multipolygon:function(l){if(void 0===l)return this.geometryFactory.createMultiPolygon();for(var h,m=l.trim().split(On.doubleParenComma),_=[],C=0,F=m.length;C<F;++C)h=m[C].replace(On.trimParens,"$1"),_.push(Ie.polygon.apply(this,[h]));return this.geometryFactory.createMultiPolygon(_)},geometrycollection:function(l){if(void 0===l)return this.geometryFactory.createGeometryCollection();for(var h=(l=l.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),m=[],_=0,C=h.length;_<C;++_)m.push(this.read(h[_]));return this.geometryFactory.createGeometryCollection(m)}},Je=function(l){this.parser=new ne(l)};Je.prototype.write=function(l){return this.parser.write(l)},Je.toLineString=function(l,h){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+l.x+" "+l.y+", "+h.x+" "+h.y+" )"};var Wn=function(l){function h(m){l.call(this,m),this.name="RuntimeException",this.message=m,this.stack=(new l).stack}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h}(Error),Er=function(l){function h(){l.call(this),0===arguments.length?l.call(this):1===arguments.length&&l.call(this,arguments[0])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Wn),Nn=function(){};Nn.prototype.interfaces_=function(){return[]},Nn.prototype.getClass=function(){return Nn},Nn.shouldNeverReachHere=function(){if(0===arguments.length)Nn.shouldNeverReachHere(null);else if(1===arguments.length){var l=arguments[0];throw new Er("Should never reach here"+(null!==l?": "+l:""))}},Nn.isTrue=function(){var h;if(1===arguments.length)Nn.isTrue(arguments[0],null);else if(2===arguments.length&&(h=arguments[1],!arguments[0]))throw null===h?new Er:new Er(h)},Nn.equals=function(){var l,h,m;if(2===arguments.length)Nn.equals(l=arguments[0],h=arguments[1],null);else if(3===arguments.length&&(m=arguments[2],!(h=arguments[1]).equals(l=arguments[0])))throw new Er("Expected "+l+" but encountered "+h+(null!==m?": "+m:""))};var Yn=function(){this._result=null,this._inputLines=Array(2).fill().map(function(){return Array(2)}),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new B,this._intPt[1]=new B,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},hi={DONT_INTERSECT:{configurable:!0},DO_INTERSECT:{configurable:!0},COLLINEAR:{configurable:!0},NO_INTERSECTION:{configurable:!0},POINT_INTERSECTION:{configurable:!0},COLLINEAR_INTERSECTION:{configurable:!0}};Yn.prototype.getIndexAlongSegment=function(l,h){return this.computeIntLineIndex(),this._intLineIndex[l][h]},Yn.prototype.getTopologySummary=function(){var l=new vt;return this.isEndPoint()&&l.append(" endpoint"),this._isProper&&l.append(" proper"),this.isCollinear()&&l.append(" collinear"),l.toString()},Yn.prototype.computeIntersection=function(l,h,m,_){this._inputLines[0][0]=l,this._inputLines[0][1]=h,this._inputLines[1][0]=m,this._inputLines[1][1]=_,this._result=this.computeIntersect(l,h,m,_)},Yn.prototype.getIntersectionNum=function(){return this._result},Yn.prototype.computeIntLineIndex=function(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var l=arguments[0];this.getEdgeDistance(l,0)>this.getEdgeDistance(l,1)?(this._intLineIndex[l][0]=0,this._intLineIndex[l][1]=1):(this._intLineIndex[l][0]=1,this._intLineIndex[l][1]=0)}},Yn.prototype.isProper=function(){return this.hasIntersection()&&this._isProper},Yn.prototype.setPrecisionModel=function(l){this._precisionModel=l},Yn.prototype.isInteriorIntersection=function(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){for(var l=arguments[0],h=0;h<this._result;h++)if(!this._intPt[h].equals2D(this._inputLines[l][0])&&!this._intPt[h].equals2D(this._inputLines[l][1]))return!0;return!1}},Yn.prototype.getIntersection=function(l){return this._intPt[l]},Yn.prototype.isEndPoint=function(){return this.hasIntersection()&&!this._isProper},Yn.prototype.hasIntersection=function(){return this._result!==Yn.NO_INTERSECTION},Yn.prototype.getEdgeDistance=function(l,h){return Yn.computeEdgeDistance(this._intPt[h],this._inputLines[l][0],this._inputLines[l][1])},Yn.prototype.isCollinear=function(){return this._result===Yn.COLLINEAR_INTERSECTION},Yn.prototype.toString=function(){return Je.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Je.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()},Yn.prototype.getEndpoint=function(l,h){return this._inputLines[l][h]},Yn.prototype.isIntersection=function(l){for(var h=0;h<this._result;h++)if(this._intPt[h].equals2D(l))return!0;return!1},Yn.prototype.getIntersectionAlongSegment=function(l,h){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[l][h]]},Yn.prototype.interfaces_=function(){return[]},Yn.prototype.getClass=function(){return Yn},Yn.computeEdgeDistance=function(l,h,m){var _=Math.abs(m.x-h.x),C=Math.abs(m.y-h.y),F=-1;if(l.equals(h))F=0;else if(l.equals(m))F=_>C?_:C;else{var rt=Math.abs(l.x-h.x),Dt=Math.abs(l.y-h.y);0!==(F=_>C?rt:Dt)||l.equals(h)||(F=Math.max(rt,Dt))}return Nn.isTrue(!(0===F&&!l.equals(h)),"Bad distance calculation"),F},Yn.nonRobustComputeEdgeDistance=function(l,h,m){var _=l.x-h.x,C=l.y-h.y,F=Math.sqrt(_*_+C*C);return Nn.isTrue(!(0===F&&!l.equals(h)),"Invalid distance calculation"),F},hi.DONT_INTERSECT.get=function(){return 0},hi.DO_INTERSECT.get=function(){return 1},hi.COLLINEAR.get=function(){return 2},hi.NO_INTERSECTION.get=function(){return 0},hi.POINT_INTERSECTION.get=function(){return 1},hi.COLLINEAR_INTERSECTION.get=function(){return 2},Object.defineProperties(Yn,hi);var di=function(l){function h(){l.apply(this,arguments)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.isInSegmentEnvelopes=function(m){var _=new De(this._inputLines[0][0],this._inputLines[0][1]),C=new De(this._inputLines[1][0],this._inputLines[1][1]);return _.contains(m)&&C.contains(m)},h.prototype.computeIntersection=function(){if(3!==arguments.length)return l.prototype.computeIntersection.apply(this,arguments);var m=arguments[0],_=arguments[1],C=arguments[2];if(this._isProper=!1,De.intersects(_,C,m)&&0===yn.orientationIndex(_,C,m)&&0===yn.orientationIndex(C,_,m))return this._isProper=!0,(m.equals(_)||m.equals(C))&&(this._isProper=!1),this._result=l.POINT_INTERSECTION,null;this._result=l.NO_INTERSECTION},h.prototype.normalizeToMinimum=function(m,_,C,F,rt){rt.x=this.smallestInAbsValue(m.x,_.x,C.x,F.x),rt.y=this.smallestInAbsValue(m.y,_.y,C.y,F.y),m.x-=rt.x,m.y-=rt.y,_.x-=rt.x,_.y-=rt.y,C.x-=rt.x,C.y-=rt.y,F.x-=rt.x,F.y-=rt.y},h.prototype.safeHCoordinateIntersection=function(m,_,C,F){var rt=null;try{rt=Ue.intersection(m,_,C,F)}catch(Dt){if(!(Dt instanceof Me))throw Dt;rt=h.nearestEndpoint(m,_,C,F)}return rt},h.prototype.intersection=function(m,_,C,F){var rt=this.intersectionWithNormalization(m,_,C,F);return this.isInSegmentEnvelopes(rt)||(rt=new B(h.nearestEndpoint(m,_,C,F))),null!==this._precisionModel&&this._precisionModel.makePrecise(rt),rt},h.prototype.smallestInAbsValue=function(m,_,C,F){var rt=m,Dt=Math.abs(rt);return Math.abs(_)<Dt&&(rt=_,Dt=Math.abs(_)),Math.abs(C)<Dt&&(rt=C,Dt=Math.abs(C)),Math.abs(F)<Dt&&(rt=F),rt},h.prototype.checkDD=function(m,_,C,F,rt){var Dt=Bt.intersection(m,_,C,F),qt=this.isInSegmentEnvelopes(Dt);Xe.out.println("DD in env = "+qt+"  --------------------- "+Dt),rt.distance(Dt)>1e-4&&Xe.out.println("Distance = "+rt.distance(Dt))},h.prototype.intersectionWithNormalization=function(m,_,C,F){var rt=new B(m),Dt=new B(_),qt=new B(C),fe=new B(F),ke=new B;this.normalizeToEnvCentre(rt,Dt,qt,fe,ke);var Ge=this.safeHCoordinateIntersection(rt,Dt,qt,fe);return Ge.x+=ke.x,Ge.y+=ke.y,Ge},h.prototype.computeCollinearIntersection=function(m,_,C,F){var rt=De.intersects(m,_,C),Dt=De.intersects(m,_,F),qt=De.intersects(C,F,m),fe=De.intersects(C,F,_);return rt&&Dt?(this._intPt[0]=C,this._intPt[1]=F,l.COLLINEAR_INTERSECTION):qt&&fe?(this._intPt[0]=m,this._intPt[1]=_,l.COLLINEAR_INTERSECTION):rt&&qt?(this._intPt[0]=C,this._intPt[1]=m,!C.equals(m)||Dt||fe?l.COLLINEAR_INTERSECTION:l.POINT_INTERSECTION):rt&&fe?(this._intPt[0]=C,this._intPt[1]=_,!C.equals(_)||Dt||qt?l.COLLINEAR_INTERSECTION:l.POINT_INTERSECTION):Dt&&qt?(this._intPt[0]=F,this._intPt[1]=m,!F.equals(m)||rt||fe?l.COLLINEAR_INTERSECTION:l.POINT_INTERSECTION):Dt&&fe?(this._intPt[0]=F,this._intPt[1]=_,!F.equals(_)||rt||qt?l.COLLINEAR_INTERSECTION:l.POINT_INTERSECTION):l.NO_INTERSECTION},h.prototype.normalizeToEnvCentre=function(m,_,C,F,rt){var Dt=m.x<_.x?m.x:_.x,qt=m.y<_.y?m.y:_.y,fe=m.x>_.x?m.x:_.x,ke=m.y>_.y?m.y:_.y,Ge=C.x<F.x?C.x:F.x,xn=C.y<F.y?C.y:F.y,Sn=C.x>F.x?C.x:F.x,Un=C.y>F.y?C.y:F.y,Ji=((qt>xn?qt:xn)+(ke<Un?ke:Un))/2;rt.x=((Dt>Ge?Dt:Ge)+(fe<Sn?fe:Sn))/2,rt.y=Ji,m.x-=rt.x,m.y-=rt.y,_.x-=rt.x,_.y-=rt.y,C.x-=rt.x,C.y-=rt.y,F.x-=rt.x,F.y-=rt.y},h.prototype.computeIntersect=function(m,_,C,F){if(this._isProper=!1,!De.intersects(m,_,C,F))return l.NO_INTERSECTION;var rt=yn.orientationIndex(m,_,C),Dt=yn.orientationIndex(m,_,F);if(rt>0&&Dt>0||rt<0&&Dt<0)return l.NO_INTERSECTION;var qt=yn.orientationIndex(C,F,m),fe=yn.orientationIndex(C,F,_);return qt>0&&fe>0||qt<0&&fe<0?l.NO_INTERSECTION:0===rt&&0===Dt&&0===qt&&0===fe?this.computeCollinearIntersection(m,_,C,F):(0===rt||0===Dt||0===qt||0===fe?(this._isProper=!1,m.equals2D(C)||m.equals2D(F)?this._intPt[0]=m:_.equals2D(C)||_.equals2D(F)?this._intPt[0]=_:0===rt?this._intPt[0]=new B(C):0===Dt?this._intPt[0]=new B(F):0===qt?this._intPt[0]=new B(m):0===fe&&(this._intPt[0]=new B(_))):(this._isProper=!0,this._intPt[0]=this.intersection(m,_,C,F)),l.POINT_INTERSECTION)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.nearestEndpoint=function(m,_,C,F){var rt=m,Dt=yn.distancePointLine(m,C,F),qt=yn.distancePointLine(_,C,F);return qt<Dt&&(Dt=qt,rt=_),(qt=yn.distancePointLine(C,m,_))<Dt&&(Dt=qt,rt=C),(qt=yn.distancePointLine(F,m,_))<Dt&&(Dt=qt,rt=F),rt},h}(Yn),to=function(){};to.prototype.interfaces_=function(){return[]},to.prototype.getClass=function(){return to},to.orientationIndex=function(l,h,m){return to.signOfDet2x2(h.x-l.x,h.y-l.y,m.x-h.x,m.y-h.y)},to.signOfDet2x2=function(l,h,m,_){var C=null,F=null,rt=null;if(C=1,0===l||0===_)return 0===h||0===m?0:h>0?m>0?-C:C:m>0?C:-C;if(0===h||0===m)return _>0?l>0?C:-C:l>0?-C:C;if(h>0?_>0?h<=_||(C=-C,F=l,l=m,m=F,F=h,h=_,_=F):h<=-_?(C=-C,m=-m,_=-_):(F=l,l=-m,m=F,F=h,h=-_,_=F):_>0?-h<=_?(C=-C,l=-l,h=-h):(F=-l,l=m,m=F,F=-h,h=_,_=F):h>=_?(l=-l,h=-h,m=-m,_=-_):(C=-C,F=-l,l=-m,m=F,F=-h,h=-_,_=F),l>0){if(!(m>0&&l<=m))return C}else{if(m>0||!(l>=m))return-C;C=-C,l=-l,m=-m}for(;;){if((_-=(rt=Math.floor(m/l))*h)<0)return-C;if(_>h)return C;if(l>(m-=rt*l)+m){if(h<_+_)return C}else{if(h>_+_)return-C;m=l-m,_=h-_,C=-C}if(0===_)return 0===m?0:-C;if(0===m||(l-=(rt=Math.floor(l/m))*m,(h-=rt*_)<0))return C;if(h>_)return-C;if(m>l+l){if(_<h+h)return-C}else{if(_>h+h)return C;l=m-l,h=_-h,C=-C}if(0===h)return 0===l?0:C;if(0===l)return-C}};var ii=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1,this._p=arguments[0]};ii.prototype.countSegment=function(l,h){if(l.x<this._p.x&&h.x<this._p.x)return null;if(this._p.x===h.x&&this._p.y===h.y)return this._isPointOnSegment=!0,null;if(l.y===this._p.y&&h.y===this._p.y){var m=l.x,_=h.x;return m>_&&(m=h.x,_=l.x),this._p.x>=m&&this._p.x<=_&&(this._isPointOnSegment=!0),null}if(l.y>this._p.y&&h.y<=this._p.y||h.y>this._p.y&&l.y<=this._p.y){var F=l.y-this._p.y,Dt=h.y-this._p.y,qt=to.signOfDet2x2(l.x-this._p.x,F,h.x-this._p.x,Dt);if(0===qt)return this._isPointOnSegment=!0,null;Dt<F&&(qt=-qt),qt>0&&this._crossingCount++}},ii.prototype.isPointInPolygon=function(){return this.getLocation()!==nt.EXTERIOR},ii.prototype.getLocation=function(){return this._isPointOnSegment?nt.BOUNDARY:this._crossingCount%2==1?nt.INTERIOR:nt.EXTERIOR},ii.prototype.isOnSegment=function(){return this._isPointOnSegment},ii.prototype.interfaces_=function(){return[]},ii.prototype.getClass=function(){return ii},ii.locatePointInRing=function(){if(arguments[0]instanceof B&&O(arguments[1],jt)){for(var h=arguments[1],m=new ii(arguments[0]),_=new B,C=new B,F=1;F<h.size();F++)if(h.getCoordinate(F,_),h.getCoordinate(F-1,C),m.countSegment(_,C),m.isOnSegment())return m.getLocation();return m.getLocation()}if(arguments[0]instanceof B&&arguments[1]instanceof Array){for(var Dt=arguments[1],qt=new ii(arguments[0]),fe=1;fe<Dt.length;fe++)if(qt.countSegment(Dt[fe],Dt[fe-1]),qt.isOnSegment())return qt.getLocation();return qt.getLocation()}};var yn=function(){},Qo={CLOCKWISE:{configurable:!0},RIGHT:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},LEFT:{configurable:!0},COLLINEAR:{configurable:!0},STRAIGHT:{configurable:!0}};yn.prototype.interfaces_=function(){return[]},yn.prototype.getClass=function(){return yn},yn.orientationIndex=function(l,h,m){return Bt.orientationIndex(l,h,m)},yn.signedArea=function(){if(arguments[0]instanceof Array){var l=arguments[0];if(l.length<3)return 0;for(var h=0,m=l[0].x,_=1;_<l.length-1;_++)h+=(l[_].x-m)*(l[_-1].y-l[_+1].y);return h/2}if(O(arguments[0],jt)){var rt=arguments[0],Dt=rt.size();if(Dt<3)return 0;var qt=new B,fe=new B,ke=new B;rt.getCoordinate(0,fe),rt.getCoordinate(1,ke);var Ge=fe.x;ke.x-=Ge;for(var xn=0,Sn=1;Sn<Dt-1;Sn++)qt.y=fe.y,fe.x=ke.x,fe.y=ke.y,rt.getCoordinate(Sn+1,ke),ke.x-=Ge,xn+=fe.x*(qt.y-ke.y);return xn/2}},yn.distanceLineLine=function(l,h,m,_){if(l.equals(h))return yn.distancePointLine(l,m,_);if(m.equals(_))return yn.distancePointLine(_,l,h);var C=!1;if(De.intersects(l,h,m,_)){var F=(h.x-l.x)*(_.y-m.y)-(h.y-l.y)*(_.x-m.x);if(0===F)C=!0;else{var Dt=((l.y-m.y)*(h.x-l.x)-(l.x-m.x)*(h.y-l.y))/F,qt=((l.y-m.y)*(_.x-m.x)-(l.x-m.x)*(_.y-m.y))/F;(qt<0||qt>1||Dt<0||Dt>1)&&(C=!0)}}else C=!0;return C?Ct.min(yn.distancePointLine(l,m,_),yn.distancePointLine(h,m,_),yn.distancePointLine(m,l,h),yn.distancePointLine(_,l,h)):0},yn.isPointInRing=function(l,h){return yn.locatePointInRing(l,h)!==nt.EXTERIOR},yn.computeLength=function(l){var h=l.size();if(h<=1)return 0;var m=0,_=new B;l.getCoordinate(0,_);for(var C=_.x,F=_.y,rt=1;rt<h;rt++){l.getCoordinate(rt,_);var Dt=_.x,qt=_.y,fe=Dt-C,ke=qt-F;m+=Math.sqrt(fe*fe+ke*ke),C=Dt,F=qt}return m},yn.isCCW=function(l){var h=l.length-1;if(h<3)throw new dt("Ring has fewer than 4 points, so orientation cannot be determined");for(var m=l[0],_=0,C=1;C<=h;C++){var F=l[C];F.y>m.y&&(m=F,_=C)}var rt=_;do{(rt-=1)<0&&(rt=h)}while(l[rt].equals2D(m)&&rt!==_);var Dt=_;do{Dt=(Dt+1)%h}while(l[Dt].equals2D(m)&&Dt!==_);var qt=l[rt],fe=l[Dt];if(qt.equals2D(m)||fe.equals2D(m)||qt.equals2D(fe))return!1;var ke=yn.computeOrientation(qt,m,fe);return 0===ke?qt.x>fe.x:ke>0},yn.locatePointInRing=function(l,h){return ii.locatePointInRing(l,h)},yn.distancePointLinePerpendicular=function(l,h,m){var _=(m.x-h.x)*(m.x-h.x)+(m.y-h.y)*(m.y-h.y);return Math.abs(((h.y-l.y)*(m.x-h.x)-(h.x-l.x)*(m.y-h.y))/_)*Math.sqrt(_)},yn.computeOrientation=function(l,h,m){return yn.orientationIndex(l,h,m)},yn.distancePointLine=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1];if(0===h.length)throw new dt("Line array must contain at least one vertex");for(var m=l.distance(h[0]),_=0;_<h.length-1;_++){var C=yn.distancePointLine(l,h[_],h[_+1]);C<m&&(m=C)}return m}if(3===arguments.length){var F=arguments[0],rt=arguments[1],Dt=arguments[2];if(rt.x===Dt.x&&rt.y===Dt.y)return F.distance(rt);var qt=(Dt.x-rt.x)*(Dt.x-rt.x)+(Dt.y-rt.y)*(Dt.y-rt.y),fe=((F.x-rt.x)*(Dt.x-rt.x)+(F.y-rt.y)*(Dt.y-rt.y))/qt;return fe<=0?F.distance(rt):fe>=1?F.distance(Dt):Math.abs(((rt.y-F.y)*(Dt.x-rt.x)-(rt.x-F.x)*(Dt.y-rt.y))/qt)*Math.sqrt(qt)}},yn.isOnLine=function(l,h){for(var m=new di,_=1;_<h.length;_++)if(m.computeIntersection(l,h[_-1],h[_]),m.hasIntersection())return!0;return!1},Qo.CLOCKWISE.get=function(){return-1},Qo.RIGHT.get=function(){return yn.CLOCKWISE},Qo.COUNTERCLOCKWISE.get=function(){return 1},Qo.LEFT.get=function(){return yn.COUNTERCLOCKWISE},Qo.COLLINEAR.get=function(){return 0},Qo.STRAIGHT.get=function(){return yn.COLLINEAR},Object.defineProperties(yn,Qo);var xo=function(){};xo.prototype.filter=function(l){},xo.prototype.interfaces_=function(){return[]},xo.prototype.getClass=function(){return xo};var Gn=function(){var l=arguments[0];this._envelope=null,this._factory=null,this._SRID=null,this._userData=null,this._factory=l,this._SRID=l.getSRID()},Hs={serialVersionUID:{configurable:!0},SORTINDEX_POINT:{configurable:!0},SORTINDEX_MULTIPOINT:{configurable:!0},SORTINDEX_LINESTRING:{configurable:!0},SORTINDEX_LINEARRING:{configurable:!0},SORTINDEX_MULTILINESTRING:{configurable:!0},SORTINDEX_POLYGON:{configurable:!0},SORTINDEX_MULTIPOLYGON:{configurable:!0},SORTINDEX_GEOMETRYCOLLECTION:{configurable:!0},geometryChangedFilter:{configurable:!0}};Gn.prototype.isGeometryCollection=function(){return this.getSortIndex()===Gn.SORTINDEX_GEOMETRYCOLLECTION},Gn.prototype.getFactory=function(){return this._factory},Gn.prototype.getGeometryN=function(l){return this},Gn.prototype.getArea=function(){return 0},Gn.prototype.isRectangle=function(){return!1},Gn.prototype.equals=function(){if(arguments[0]instanceof Gn){var l=arguments[0];return null!==l&&this.equalsTopo(l)}if(arguments[0]instanceof Object){var h=arguments[0];return h instanceof Gn&&this.equalsExact(h)}},Gn.prototype.equalsExact=function(l){return this===l||this.equalsExact(l,0)},Gn.prototype.geometryChanged=function(){this.apply(Gn.geometryChangedFilter)},Gn.prototype.geometryChangedAction=function(){this._envelope=null},Gn.prototype.equalsNorm=function(l){return null!==l&&this.norm().equalsExact(l.norm())},Gn.prototype.getLength=function(){return 0},Gn.prototype.getNumGeometries=function(){return 1},Gn.prototype.compareTo=function(){if(1===arguments.length){var l=arguments[0],h=l;return this.getSortIndex()!==h.getSortIndex()?this.getSortIndex()-h.getSortIndex():this.isEmpty()&&h.isEmpty()?0:this.isEmpty()?-1:h.isEmpty()?1:this.compareToSameClass(l)}if(2===arguments.length){var m=arguments[0],_=arguments[1];return this.getSortIndex()!==m.getSortIndex()?this.getSortIndex()-m.getSortIndex():this.isEmpty()&&m.isEmpty()?0:this.isEmpty()?-1:m.isEmpty()?1:this.compareToSameClass(m,_)}},Gn.prototype.getUserData=function(){return this._userData},Gn.prototype.getSRID=function(){return this._SRID},Gn.prototype.getEnvelope=function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},Gn.prototype.checkNotGeometryCollection=function(l){if(l.getSortIndex()===Gn.SORTINDEX_GEOMETRYCOLLECTION)throw new dt("This method does not support GeometryCollection arguments")},Gn.prototype.equal=function(l,h,m){return 0===m?l.equals(h):l.distance(h)<=m},Gn.prototype.norm=function(){var l=this.copy();return l.normalize(),l},Gn.prototype.getPrecisionModel=function(){return this._factory.getPrecisionModel()},Gn.prototype.getEnvelopeInternal=function(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new De(this._envelope)},Gn.prototype.setSRID=function(l){this._SRID=l},Gn.prototype.setUserData=function(l){this._userData=l},Gn.prototype.compare=function(l,h){for(var m=l.iterator(),_=h.iterator();m.hasNext()&&_.hasNext();){var C=m.next(),F=_.next(),rt=C.compareTo(F);if(0!==rt)return rt}return m.hasNext()?1:_.hasNext()?-1:0},Gn.prototype.hashCode=function(){return this.getEnvelopeInternal().hashCode()},Gn.prototype.isGeometryCollectionOrDerived=function(){return this.getSortIndex()===Gn.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===Gn.SORTINDEX_MULTIPOINT||this.getSortIndex()===Gn.SORTINDEX_MULTILINESTRING||this.getSortIndex()===Gn.SORTINDEX_MULTIPOLYGON},Gn.prototype.interfaces_=function(){return[ft,q,$]},Gn.prototype.getClass=function(){return Gn},Gn.hasNonEmptyElements=function(l){for(var h=0;h<l.length;h++)if(!l[h].isEmpty())return!0;return!1},Gn.hasNullElements=function(l){for(var h=0;h<l.length;h++)if(null===l[h])return!0;return!1},Hs.serialVersionUID.get=function(){return 0x799ea46522854c00},Hs.SORTINDEX_POINT.get=function(){return 0},Hs.SORTINDEX_MULTIPOINT.get=function(){return 1},Hs.SORTINDEX_LINESTRING.get=function(){return 2},Hs.SORTINDEX_LINEARRING.get=function(){return 3},Hs.SORTINDEX_MULTILINESTRING.get=function(){return 4},Hs.SORTINDEX_POLYGON.get=function(){return 5},Hs.SORTINDEX_MULTIPOLYGON.get=function(){return 6},Hs.SORTINDEX_GEOMETRYCOLLECTION.get=function(){return 7},Hs.geometryChangedFilter.get=function(){return Ce},Object.defineProperties(Gn,Hs);var Ce=function(){};Ce.interfaces_=function(){return[xo]},Ce.filter=function(l){l.geometryChangedAction()};var Et=function(){};Et.prototype.filter=function(l){},Et.prototype.interfaces_=function(){return[]},Et.prototype.getClass=function(){return Et};var Rt=function(){},te={Mod2BoundaryNodeRule:{configurable:!0},EndPointBoundaryNodeRule:{configurable:!0},MultiValentEndPointBoundaryNodeRule:{configurable:!0},MonoValentEndPointBoundaryNodeRule:{configurable:!0},MOD2_BOUNDARY_RULE:{configurable:!0},ENDPOINT_BOUNDARY_RULE:{configurable:!0},MULTIVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},MONOVALENT_ENDPOINT_BOUNDARY_RULE:{configurable:!0},OGC_SFS_BOUNDARY_RULE:{configurable:!0}};Rt.prototype.isInBoundary=function(l){},Rt.prototype.interfaces_=function(){return[]},Rt.prototype.getClass=function(){return Rt},te.Mod2BoundaryNodeRule.get=function(){return oe},te.EndPointBoundaryNodeRule.get=function(){return ie},te.MultiValentEndPointBoundaryNodeRule.get=function(){return ze},te.MonoValentEndPointBoundaryNodeRule.get=function(){return Oe},te.MOD2_BOUNDARY_RULE.get=function(){return new oe},te.ENDPOINT_BOUNDARY_RULE.get=function(){return new ie},te.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new ze},te.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get=function(){return new Oe},te.OGC_SFS_BOUNDARY_RULE.get=function(){return Rt.MOD2_BOUNDARY_RULE},Object.defineProperties(Rt,te);var oe=function(){};oe.prototype.isInBoundary=function(l){return l%2==1},oe.prototype.interfaces_=function(){return[Rt]},oe.prototype.getClass=function(){return oe};var ie=function(){};ie.prototype.isInBoundary=function(l){return l>0},ie.prototype.interfaces_=function(){return[Rt]},ie.prototype.getClass=function(){return ie};var ze=function(){};ze.prototype.isInBoundary=function(l){return l>1},ze.prototype.interfaces_=function(){return[Rt]},ze.prototype.getClass=function(){return ze};var Oe=function(){};Oe.prototype.isInBoundary=function(l){return 1===l},Oe.prototype.interfaces_=function(){return[Rt]},Oe.prototype.getClass=function(){return Oe};var je=function(){};je.prototype.add=function(){},je.prototype.addAll=function(){},je.prototype.isEmpty=function(){},je.prototype.iterator=function(){},je.prototype.size=function(){},je.prototype.toArray=function(){},je.prototype.remove=function(){},(V.prototype=new Error).name="IndexOutOfBoundsException";var Xt=function(){};Xt.prototype.hasNext=function(){},Xt.prototype.next=function(){},Xt.prototype.remove=function(){};var En=function(l){function h(){l.apply(this,arguments)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.get=function(){},h.prototype.set=function(){},h.prototype.isEmpty=function(){},h}(je);(H.prototype=new Error).name="NoSuchElementException";var ue=function(l){function h(){l.call(this),this.array_=[],arguments[0]instanceof je&&this.addAll(arguments[0])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.ensureCapacity=function(){},h.prototype.interfaces_=function(){return[l,je]},h.prototype.add=function(m){return 1===arguments.length?this.array_.push(m):this.array_.splice(arguments[0],arguments[1]),!0},h.prototype.clear=function(){this.array_=[]},h.prototype.addAll=function(m){for(var _=m.iterator();_.hasNext();)this.add(_.next());return!0},h.prototype.set=function(m,_){var C=this.array_[m];return this.array_[m]=_,C},h.prototype.iterator=function(){return new en(this)},h.prototype.get=function(m){if(m<0||m>=this.size())throw new V;return this.array_[m]},h.prototype.isEmpty=function(){return 0===this.array_.length},h.prototype.size=function(){return this.array_.length},h.prototype.toArray=function(){for(var m=[],_=0,C=this.array_.length;_<C;_++)m.push(this.array_[_]);return m},h.prototype.remove=function(m){for(var _=!1,C=0,F=this.array_.length;C<F;C++)if(this.array_[C]===m){this.array_.splice(C,1),_=!0;break}return _},h}(En),en=function(l){function h(m){l.call(this),this.arrayList_=m,this.position_=0}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new H;return this.arrayList_.get(this.position_++)},h.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},h.prototype.set=function(m){return this.arrayList_.set(this.position_-1,m)},h.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))},h}(Xt),mn=function(l){function h(){if(l.call(this),0!==arguments.length)if(1===arguments.length){var _=arguments[0];this.ensureCapacity(_.length),this.add(_,!0)}else if(2===arguments.length){var C=arguments[0],F=arguments[1];this.ensureCapacity(C.length),this.add(C,F)}}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={coordArrayType:{configurable:!0}};return m.coordArrayType.get=function(){return new Array(0).fill(null)},h.prototype.getCoordinate=function(_){return this.get(_)},h.prototype.addAll=function(){if(2===arguments.length){for(var C=arguments[1],F=!1,rt=arguments[0].iterator();rt.hasNext();)this.add(rt.next(),C),F=!0;return F}return l.prototype.addAll.apply(this,arguments)},h.prototype.clone=function(){for(var _=l.prototype.clone.call(this),C=0;C<this.size();C++)_.add(C,this.get(C).copy());return _},h.prototype.toCoordinateArray=function(){return this.toArray(h.coordArrayType)},h.prototype.add=function(){if(1===arguments.length)l.prototype.add.call(this,arguments[0]);else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1])return this.add(arguments[0],arguments[1],!0),!0;if(arguments[0]instanceof B&&"boolean"==typeof arguments[1]){var rt=arguments[0];if(!arguments[1]&&this.size()>=1&&this.get(this.size()-1).equals2D(rt))return null;l.prototype.add.call(this,rt)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1])return this.add(arguments[0],arguments[1]),!0}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var fe=arguments[0],ke=arguments[1];if(arguments[2])for(var Ge=0;Ge<fe.length;Ge++)this.add(fe[Ge],ke);else for(var xn=fe.length-1;xn>=0;xn--)this.add(fe[xn],ke);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof B){var Sn=arguments[0],Un=arguments[1];if(!arguments[2]){var ur=this.size();if(ur>0&&(Sn>0&&this.get(Sn-1).equals2D(Un)||Sn<ur&&this.get(Sn).equals2D(Un)))return null}l.prototype.add.call(this,Sn,Un)}}else if(4===arguments.length){var Ji=arguments[0],Do=arguments[1],Fa=arguments[2],ml=arguments[3],Kl=1;Fa>ml&&(Kl=-1);for(var rf=Fa;rf!==ml;rf+=Kl)this.add(Ji[rf],Do);return!0}},h.prototype.closeRing=function(){this.size()>0&&this.add(new B(this.get(0)),!1)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},Object.defineProperties(h,m),h}(ue),un=function(){},ir={ForwardComparator:{configurable:!0},BidirectionalComparator:{configurable:!0},coordArrayType:{configurable:!0}};ir.ForwardComparator.get=function(){return dr},ir.BidirectionalComparator.get=function(){return zn},ir.coordArrayType.get=function(){return new Array(0).fill(null)},un.prototype.interfaces_=function(){return[]},un.prototype.getClass=function(){return un},un.isRing=function(l){return!(l.length<4||!l[0].equals2D(l[l.length-1]))},un.ptNotInList=function(l,h){for(var m=0;m<l.length;m++){var _=l[m];if(un.indexOf(_,h)<0)return _}return null},un.scroll=function(l,h){var m=un.indexOf(h,l);if(m<0)return null;var _=new Array(l.length).fill(null);Xe.arraycopy(l,m,_,0,l.length-m),Xe.arraycopy(l,0,_,l.length-m,m),Xe.arraycopy(_,0,l,0,l.length)},un.equals=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1];if(l===h)return!0;if(null===l||null===h||l.length!==h.length)return!1;for(var m=0;m<l.length;m++)if(!l[m].equals(h[m]))return!1;return!0}if(3===arguments.length){var _=arguments[0],C=arguments[1],F=arguments[2];if(_===C)return!0;if(null===_||null===C||_.length!==C.length)return!1;for(var rt=0;rt<_.length;rt++)if(0!==F.compare(_[rt],C[rt]))return!1;return!0}},un.intersection=function(l,h){for(var m=new mn,_=0;_<l.length;_++)h.intersects(l[_])&&m.add(l[_],!0);return m.toCoordinateArray()},un.hasRepeatedPoints=function(l){for(var h=1;h<l.length;h++)if(l[h-1].equals(l[h]))return!0;return!1},un.removeRepeatedPoints=function(l){return un.hasRepeatedPoints(l)?new mn(l,!1).toCoordinateArray():l},un.reverse=function(l){for(var h=l.length-1,m=Math.trunc(h/2),_=0;_<=m;_++){var C=l[_];l[_]=l[h-_],l[h-_]=C}},un.removeNull=function(l){for(var h=0,m=0;m<l.length;m++)null!==l[m]&&h++;var _=new Array(h).fill(null);if(0===h)return _;for(var C=0,F=0;F<l.length;F++)null!==l[F]&&(_[C++]=l[F]);return _},un.copyDeep=function(){if(1===arguments.length){for(var l=arguments[0],h=new Array(l.length).fill(null),m=0;m<l.length;m++)h[m]=new B(l[m]);return h}if(5===arguments.length)for(var _=arguments[0],C=arguments[1],F=arguments[2],rt=arguments[3],Dt=arguments[4],qt=0;qt<Dt;qt++)F[rt+qt]=new B(_[C+qt])},un.isEqualReversed=function(l,h){for(var m=0;m<l.length;m++)if(0!==l[m].compareTo(h[l.length-m-1]))return!1;return!0},un.envelope=function(l){for(var h=new De,m=0;m<l.length;m++)h.expandToInclude(l[m]);return h},un.toCoordinateArray=function(l){return l.toArray(un.coordArrayType)},un.atLeastNCoordinatesOrNothing=function(l,h){return h.length>=l?h:[]},un.indexOf=function(l,h){for(var m=0;m<h.length;m++)if(l.equals(h[m]))return m;return-1},un.increasingDirection=function(l){for(var h=0;h<Math.trunc(l.length/2);h++){var _=l[h].compareTo(l[l.length-1-h]);if(0!==_)return _}return 1},un.compare=function(l,h){for(var m=0;m<l.length&&m<h.length;){var _=l[m].compareTo(h[m]);if(0!==_)return _;m++}return m<h.length?-1:m<l.length?1:0},un.minCoordinate=function(l){for(var h=null,m=0;m<l.length;m++)(null===h||h.compareTo(l[m])>0)&&(h=l[m]);return h},un.extract=function(l,h,m){h=Ct.clamp(h,0,l.length);var _=(m=Ct.clamp(m,-1,l.length))-h+1;m<0&&(_=0),h>=l.length&&(_=0),m<h&&(_=0);var C=new Array(_).fill(null);if(0===_)return C;for(var F=0,rt=h;rt<=m;rt++)C[F++]=l[rt];return C},Object.defineProperties(un,ir);var dr=function(){};dr.prototype.compare=function(l,h){return un.compare(l,h)},dr.prototype.interfaces_=function(){return[pt]},dr.prototype.getClass=function(){return dr};var zn=function(){};zn.prototype.compare=function(l,h){var m=l,_=h;if(m.length<_.length)return-1;if(m.length>_.length)return 1;if(0===m.length)return 0;var C=un.compare(m,_);return un.isEqualReversed(m,_)?0:C},zn.prototype.OLDcompare=function(l,h){var m=l,_=h;if(m.length<_.length)return-1;if(m.length>_.length)return 1;if(0===m.length)return 0;for(var C=un.increasingDirection(m),F=un.increasingDirection(_),rt=C>0?0:m.length-1,Dt=F>0?0:m.length-1,qt=0;qt<m.length;qt++){var fe=m[rt].compareTo(_[Dt]);if(0!==fe)return fe;rt+=C,Dt+=F}return 0},zn.prototype.interfaces_=function(){return[pt]},zn.prototype.getClass=function(){return zn};var _n=function(){};_n.prototype.get=function(){},_n.prototype.put=function(){},_n.prototype.size=function(){},_n.prototype.values=function(){},_n.prototype.entrySet=function(){};var sr=function(l){function h(){l.apply(this,arguments)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h}(_n);(Q.prototype=new Error).name="OperationNotSupported",(Y.prototype=new je).contains=function(){};var Jr=function(l){function h(){l.call(this),this.array_=[],arguments[0]instanceof je&&this.addAll(arguments[0])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.contains=function(m){for(var _=0,C=this.array_.length;_<C;_++)if(this.array_[_]===m)return!0;return!1},h.prototype.add=function(m){return!this.contains(m)&&(this.array_.push(m),!0)},h.prototype.addAll=function(m){for(var _=m.iterator();_.hasNext();)this.add(_.next());return!0},h.prototype.remove=function(m){throw new Error},h.prototype.size=function(){return this.array_.length},h.prototype.isEmpty=function(){return 0===this.array_.length},h.prototype.toArray=function(){for(var m=[],_=0,C=this.array_.length;_<C;_++)m.push(this.array_[_]);return m},h.prototype.iterator=function(){return new qn(this)},h}(Y),qn=function(l){function h(m){l.call(this),this.hashSet_=m,this.position_=0}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new H;return this.hashSet_.array_[this.position_++]},h.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},h.prototype.remove=function(){throw new Q},h}(Xt),br=0;(Z.prototype=new sr).get=function(l){for(var h=this.root_;null!==h;){var m=l.compareTo(h.key);if(m<0)h=h.left;else{if(!(m>0))return h.value;h=h.right}}return null},Z.prototype.put=function(l,h){if(null===this.root_)return this.root_={key:l,value:h,left:null,right:null,parent:null,color:br,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var m,_,C=this.root_;do{if(m=C,(_=l.compareTo(C.key))<0)C=C.left;else{if(!(_>0)){var F=C.value;return C.value=h,F}C=C.right}}while(null!==C);var rt={key:l,left:null,right:null,value:h,parent:m,color:br,getValue:function(){return this.value},getKey:function(){return this.key}};return _<0?m.left=rt:m.right=rt,this.fixAfterInsertion(rt),this.size_++,null},Z.prototype.fixAfterInsertion=function(l){for(l.color=1;null!=l&&l!==this.root_&&1===l.parent.color;)if(W(l)===A(W(W(l)))){var h=X(W(W(l)));1===R(h)?(k(W(l),br),k(h,br),k(W(W(l)),1),l=W(W(l))):(l===X(W(l))&&(l=W(l),this.rotateLeft(l)),k(W(l),br),k(W(W(l)),1),this.rotateRight(W(W(l))))}else{var m=A(W(W(l)));1===R(m)?(k(W(l),br),k(m,br),k(W(W(l)),1),l=W(W(l))):(l===A(W(l))&&(l=W(l),this.rotateRight(l)),k(W(l),br),k(W(W(l)),1),this.rotateLeft(W(W(l))))}this.root_.color=br},Z.prototype.values=function(){var l=new ue,h=this.getFirstEntry();if(null!==h)for(l.add(h.value);null!==(h=Z.successor(h));)l.add(h.value);return l},Z.prototype.entrySet=function(){var l=new Jr,h=this.getFirstEntry();if(null!==h)for(l.add(h);null!==(h=Z.successor(h));)l.add(h);return l},Z.prototype.rotateLeft=function(l){if(null!=l){var h=l.right;l.right=h.left,null!=h.left&&(h.left.parent=l),h.parent=l.parent,null===l.parent?this.root_=h:l.parent.left===l?l.parent.left=h:l.parent.right=h,h.left=l,l.parent=h}},Z.prototype.rotateRight=function(l){if(null!=l){var h=l.left;l.left=h.right,null!=h.right&&(h.right.parent=l),h.parent=l.parent,null===l.parent?this.root_=h:l.parent.right===l?l.parent.right=h:l.parent.left=h,h.right=l,l.parent=h}},Z.prototype.getFirstEntry=function(){var l=this.root_;if(null!=l)for(;null!=l.left;)l=l.left;return l},Z.successor=function(l){if(null===l)return null;if(null!==l.right){for(var h=l.right;null!==h.left;)h=h.left;return h}for(var m=l.parent,_=l;null!==m&&_===m.right;)_=m,m=m.parent;return m},Z.prototype.size=function(){return this.size_};var Dn=function(){};Dn.prototype.interfaces_=function(){return[]},Dn.prototype.getClass=function(){return Dn},G.prototype=new Y,(it.prototype=new G).contains=function(l){for(var h=0,m=this.array_.length;h<m;h++)if(0===this.array_[h].compareTo(l))return!0;return!1},it.prototype.add=function(l){if(this.contains(l))return!1;for(var h=0,m=this.array_.length;h<m;h++)if(1===this.array_[h].compareTo(l))return this.array_.splice(h,0,l),!0;return this.array_.push(l),!0},it.prototype.addAll=function(l){for(var h=l.iterator();h.hasNext();)this.add(h.next());return!0},it.prototype.remove=function(l){throw new Q},it.prototype.size=function(){return this.array_.length},it.prototype.isEmpty=function(){return 0===this.array_.length},it.prototype.toArray=function(){for(var l=[],h=0,m=this.array_.length;h<m;h++)l.push(this.array_[h]);return l},it.prototype.iterator=function(){return new si(this)};var si=function(l){this.treeSet_=l,this.position_=0};si.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new H;return this.treeSet_.array_[this.position_++]},si.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},si.prototype.remove=function(){throw new Q};var kr=function(){};kr.sort=function(){var l,h,m,C=arguments[0];if(1===arguments.length)C.sort(function(rt,Dt){return rt.compareTo(Dt)});else if(2===arguments.length)m=arguments[1],C.sort(function(rt,Dt){return m.compare(rt,Dt)});else if(3===arguments.length){(h=C.slice(arguments[1],arguments[2])).sort();var F=C.slice(0,arguments[1]).concat(h,C.slice(arguments[2],C.length));for(C.splice(0,C.length),l=0;l<F.length;l++)C.push(F[l])}else if(4===arguments.length)for(h=C.slice(arguments[1],arguments[2]),m=arguments[3],h.sort(function(rt,Dt){return m.compare(rt,Dt)}),F=C.slice(0,arguments[1]).concat(h,C.slice(arguments[2],C.length)),C.splice(0,C.length),l=0;l<F.length;l++)C.push(F[l])},kr.asList=function(l){for(var h=new ue,m=0,_=l.length;m<_;m++)h.add(l[m]);return h};var tr=function(){},Zi={P:{configurable:!0},L:{configurable:!0},A:{configurable:!0},FALSE:{configurable:!0},TRUE:{configurable:!0},DONTCARE:{configurable:!0},SYM_FALSE:{configurable:!0},SYM_TRUE:{configurable:!0},SYM_DONTCARE:{configurable:!0},SYM_P:{configurable:!0},SYM_L:{configurable:!0},SYM_A:{configurable:!0}};Zi.P.get=function(){return 0},Zi.L.get=function(){return 1},Zi.A.get=function(){return 2},Zi.FALSE.get=function(){return-1},Zi.TRUE.get=function(){return-2},Zi.DONTCARE.get=function(){return-3},Zi.SYM_FALSE.get=function(){return"F"},Zi.SYM_TRUE.get=function(){return"T"},Zi.SYM_DONTCARE.get=function(){return"*"},Zi.SYM_P.get=function(){return"0"},Zi.SYM_L.get=function(){return"1"},Zi.SYM_A.get=function(){return"2"},tr.prototype.interfaces_=function(){return[]},tr.prototype.getClass=function(){return tr},tr.toDimensionSymbol=function(l){switch(l){case tr.FALSE:return tr.SYM_FALSE;case tr.TRUE:return tr.SYM_TRUE;case tr.DONTCARE:return tr.SYM_DONTCARE;case tr.P:return tr.SYM_P;case tr.L:return tr.SYM_L;case tr.A:return tr.SYM_A}throw new dt("Unknown dimension value: "+l)},tr.toDimensionValue=function(l){switch(Mt.toUpperCase(l)){case tr.SYM_FALSE:return tr.FALSE;case tr.SYM_TRUE:return tr.TRUE;case tr.SYM_DONTCARE:return tr.DONTCARE;case tr.SYM_P:return tr.P;case tr.SYM_L:return tr.L;case tr.SYM_A:return tr.A}throw new dt("Unknown dimension symbol: "+l)},Object.defineProperties(tr,Zi);var fi=function(){};fi.prototype.filter=function(l){},fi.prototype.interfaces_=function(){return[]},fi.prototype.getClass=function(){return fi};var oi=function(){};oi.prototype.filter=function(l,h){},oi.prototype.isDone=function(){},oi.prototype.isGeometryChanged=function(){},oi.prototype.interfaces_=function(){return[]},oi.prototype.getClass=function(){return oi};var zr=function(l){function h(_,C){if(l.call(this,C),this._geometries=_||[],l.hasNullElements(this._geometries))throw new dt("geometries must not contain null elements")}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){for(var _=new De,C=0;C<this._geometries.length;C++)_.expandToInclude(this._geometries[C].getEnvelopeInternal());return _},h.prototype.getGeometryN=function(_){return this._geometries[_]},h.prototype.getSortIndex=function(){return l.SORTINDEX_GEOMETRYCOLLECTION},h.prototype.getCoordinates=function(){for(var _=new Array(this.getNumPoints()).fill(null),C=-1,F=0;F<this._geometries.length;F++)for(var rt=this._geometries[F].getCoordinates(),Dt=0;Dt<rt.length;Dt++)_[++C]=rt[Dt];return _},h.prototype.getArea=function(){for(var _=0,C=0;C<this._geometries.length;C++)_+=this._geometries[C].getArea();return _},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];if(!this.isEquivalentClass(_))return!1;var F=_;if(this._geometries.length!==F._geometries.length)return!1;for(var rt=0;rt<this._geometries.length;rt++)if(!this._geometries[rt].equalsExact(F._geometries[rt],C))return!1;return!0}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){for(var _=0;_<this._geometries.length;_++)this._geometries[_].normalize();kr.sort(this._geometries)},h.prototype.getCoordinate=function(){return this.isEmpty()?null:this._geometries[0].getCoordinate()},h.prototype.getBoundaryDimension=function(){for(var _=tr.FALSE,C=0;C<this._geometries.length;C++)_=Math.max(_,this._geometries[C].getBoundaryDimension());return _},h.prototype.getDimension=function(){for(var _=tr.FALSE,C=0;C<this._geometries.length;C++)_=Math.max(_,this._geometries[C].getDimension());return _},h.prototype.getLength=function(){for(var _=0,C=0;C<this._geometries.length;C++)_+=this._geometries[C].getLength();return _},h.prototype.getNumPoints=function(){for(var _=0,C=0;C<this._geometries.length;C++)_+=this._geometries[C].getNumPoints();return _},h.prototype.getNumGeometries=function(){return this._geometries.length},h.prototype.reverse=function(){for(var C=new Array(this._geometries.length).fill(null),F=0;F<this._geometries.length;F++)C[F]=this._geometries[F].reverse();return this.getFactory().createGeometryCollection(C)},h.prototype.compareToSameClass=function(){if(1===arguments.length){var _=arguments[0],C=new it(kr.asList(this._geometries)),F=new it(kr.asList(_._geometries));return this.compare(C,F)}if(2===arguments.length){for(var Dt=arguments[1],qt=arguments[0],fe=this.getNumGeometries(),ke=qt.getNumGeometries(),Ge=0;Ge<fe&&Ge<ke;){var xn=this.getGeometryN(Ge),Sn=qt.getGeometryN(Ge),Un=xn.compareToSameClass(Sn,Dt);if(0!==Un)return Un;Ge++}return Ge<fe?1:Ge<ke?-1:0}},h.prototype.apply=function(){if(O(arguments[0],Et))for(var _=arguments[0],C=0;C<this._geometries.length;C++)this._geometries[C].apply(_);else if(O(arguments[0],oi)){var F=arguments[0];if(0===this._geometries.length)return null;for(var rt=0;rt<this._geometries.length&&(this._geometries[rt].apply(F),!F.isDone());rt++);F.isGeometryChanged()&&this.geometryChanged()}else if(O(arguments[0],fi)){var Dt=arguments[0];Dt.filter(this);for(var qt=0;qt<this._geometries.length;qt++)this._geometries[qt].apply(Dt)}else if(O(arguments[0],xo)){var fe=arguments[0];fe.filter(this);for(var ke=0;ke<this._geometries.length;ke++)this._geometries[ke].apply(fe)}},h.prototype.getBoundary=function(){return this.checkNotGeometryCollection(this),Nn.shouldNeverReachHere(),null},h.prototype.clone=function(){var _=l.prototype.clone.call(this);_._geometries=new Array(this._geometries.length).fill(null);for(var C=0;C<this._geometries.length;C++)_._geometries[C]=this._geometries[C].clone();return _},h.prototype.getGeometryType=function(){return"GeometryCollection"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),C=0;C<_.length;C++)_[C]=this._geometries[C].copy();return new h(_,this._factory)},h.prototype.isEmpty=function(){for(var _=0;_<this._geometries.length;_++)if(!this._geometries[_].isEmpty())return!1;return!0},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return-0x4f07bcb1f857d800},Object.defineProperties(h,m),h}(Gn),js=function(l){function h(){l.apply(this,arguments)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Gn.SORTINDEX_MULTILINESTRING},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];return!!this.isEquivalentClass(_)&&l.prototype.equalsExact.call(this,_,C)}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return this.isClosed()?tr.FALSE:0},h.prototype.isClosed=function(){if(this.isEmpty())return!1;for(var _=0;_<this._geometries.length;_++)if(!this._geometries[_].isClosed())return!1;return!0},h.prototype.getDimension=function(){return 1},h.prototype.reverse=function(){for(var _=this._geometries.length,C=new Array(_).fill(null),F=0;F<this._geometries.length;F++)C[_-1-F]=this._geometries[F].reverse();return this.getFactory().createMultiLineString(C)},h.prototype.getBoundary=function(){return new ho(this).getBoundary()},h.prototype.getGeometryType=function(){return"MultiLineString"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),C=0;C<_.length;C++)_[C]=this._geometries[C].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[Dn]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return 0x7155d2ab4afa8000},Object.defineProperties(h,m),h}(zr),ho=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){var l=arguments[0],h=Rt.MOD2_BOUNDARY_RULE;this._geom=l,this._geomFact=l.getFactory(),this._bnRule=h}else if(2===arguments.length){var m=arguments[0],_=arguments[1];this._geom=m,this._geomFact=m.getFactory(),this._bnRule=_}};ho.prototype.boundaryMultiLineString=function(l){if(this._geom.isEmpty())return this.getEmptyMultiPoint();var h=this.computeBoundaryCoordinates(l);return 1===h.length?this._geomFact.createPoint(h[0]):this._geomFact.createMultiPointFromCoords(h)},ho.prototype.getBoundary=function(){return this._geom instanceof Vr?this.boundaryLineString(this._geom):this._geom instanceof js?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()},ho.prototype.boundaryLineString=function(l){return this._geom.isEmpty()?this.getEmptyMultiPoint():l.isClosed()?this._bnRule.isInBoundary(2)?l.getStartPoint():this._geomFact.createMultiPoint():this._geomFact.createMultiPoint([l.getStartPoint(),l.getEndPoint()])},ho.prototype.getEmptyMultiPoint=function(){return this._geomFact.createMultiPoint()},ho.prototype.computeBoundaryCoordinates=function(l){var h=new ue;this._endpointMap=new Z;for(var m=0;m<l.getNumGeometries();m++){var _=l.getGeometryN(m);0!==_.getNumPoints()&&(this.addEndpoint(_.getCoordinateN(0)),this.addEndpoint(_.getCoordinateN(_.getNumPoints()-1)))}for(var C=this._endpointMap.entrySet().iterator();C.hasNext();){var F=C.next(),rt=F.getValue().count;this._bnRule.isInBoundary(rt)&&h.add(F.getKey())}return un.toCoordinateArray(h)},ho.prototype.addEndpoint=function(l){var h=this._endpointMap.get(l);null===h&&(h=new Es,this._endpointMap.put(l,h)),h.count++},ho.prototype.interfaces_=function(){return[]},ho.prototype.getClass=function(){return ho},ho.getBoundary=function(){return 1===arguments.length?new ho(arguments[0]).getBoundary():2===arguments.length?new ho(arguments[0],arguments[1]).getBoundary():void 0};var Es=function(){this.count=null};Es.prototype.interfaces_=function(){return[]},Es.prototype.getClass=function(){return Es};var Ks=function(){},Rs={NEWLINE:{configurable:!0},SIMPLE_ORDINATE_FORMAT:{configurable:!0}};Ks.prototype.interfaces_=function(){return[]},Ks.prototype.getClass=function(){return Ks},Ks.chars=function(l,h){for(var m=new Array(h).fill(null),_=0;_<h;_++)m[_]=l;return String(m)},Ks.getStackTrace=function(){if(1===arguments.length){var l=arguments[0],h=new function(){},m=new function(){}(h);return l.printStackTrace(m),h.toString()}if(2===arguments.length){for(var C=arguments[1],F="",rt=new function(){}(new function(){}(Ks.getStackTrace(arguments[0]))),Dt=0;Dt<C;Dt++)try{F+=rt.readLine()+Ks.NEWLINE}catch(qt){if(!(qt instanceof wt))throw qt;Nn.shouldNeverReachHere()}return F}},Ks.split=function(l,h){for(var m=h.length,_=new ue,C=""+l,F=C.indexOf(h);F>=0;){var rt=C.substring(0,F);_.add(rt),F=(C=C.substring(F+m)).indexOf(h)}C.length>0&&_.add(C);for(var Dt=new Array(_.size()).fill(null),qt=0;qt<Dt.length;qt++)Dt[qt]=_.get(qt);return Dt},Ks.toString=function(){if(1===arguments.length)return Ks.SIMPLE_ORDINATE_FORMAT.format(arguments[0])},Ks.spaces=function(l){return Ks.chars(" ",l)},Rs.NEWLINE.get=function(){return Xe.getProperty("line.separator")},Rs.SIMPLE_ORDINATE_FORMAT.get=function(){return new function(){}("0.#")},Object.defineProperties(Ks,Rs);var ti=function(){};ti.prototype.interfaces_=function(){return[]},ti.prototype.getClass=function(){return ti},ti.copyCoord=function(l,h,m,_){for(var C=Math.min(l.getDimension(),m.getDimension()),F=0;F<C;F++)m.setOrdinate(_,F,l.getOrdinate(h,F))},ti.isRing=function(l){var h=l.size();return 0===h||!(h<=3)&&l.getOrdinate(0,jt.X)===l.getOrdinate(h-1,jt.X)&&l.getOrdinate(0,jt.Y)===l.getOrdinate(h-1,jt.Y)},ti.isEqual=function(l,h){var m=l.size();if(m!==h.size())return!1;for(var _=Math.min(l.getDimension(),h.getDimension()),C=0;C<m;C++)for(var F=0;F<_;F++){var rt=l.getOrdinate(C,F),Dt=h.getOrdinate(C,F);if(!(l.getOrdinate(C,F)===h.getOrdinate(C,F)||lt.isNaN(rt)&&lt.isNaN(Dt)))return!1}return!0},ti.extend=function(l,h,m){var _=l.create(m,h.getDimension()),C=h.size();if(ti.copy(h,0,_,0,C),C>0)for(var F=C;F<m;F++)ti.copy(h,C-1,_,F,1);return _},ti.reverse=function(l){for(var h=l.size()-1,m=Math.trunc(h/2),_=0;_<=m;_++)ti.swap(l,_,h-_)},ti.swap=function(l,h,m){if(h===m)return null;for(var _=0;_<l.getDimension();_++){var C=l.getOrdinate(h,_);l.setOrdinate(h,_,l.getOrdinate(m,_)),l.setOrdinate(m,_,C)}},ti.copy=function(l,h,m,_,C){for(var F=0;F<C;F++)ti.copyCoord(l,h+F,m,_+F)},ti.toString=function(){if(1===arguments.length){var l=arguments[0],h=l.size();if(0===h)return"()";var m=l.getDimension(),_=new vt;_.append("(");for(var C=0;C<h;C++){C>0&&_.append(" ");for(var F=0;F<m;F++)F>0&&_.append(","),_.append(Ks.toString(l.getOrdinate(C,F)))}return _.append(")"),_.toString()}},ti.ensureValidRing=function(l,h){var m=h.size();return 0===m?h:m<=3?ti.createClosedRing(l,h,4):h.getOrdinate(0,jt.X)===h.getOrdinate(m-1,jt.X)&&h.getOrdinate(0,jt.Y)===h.getOrdinate(m-1,jt.Y)?h:ti.createClosedRing(l,h,m+1)},ti.createClosedRing=function(l,h,m){var _=l.create(m,h.getDimension()),C=h.size();ti.copy(h,0,_,0,C);for(var F=C;F<m;F++)ti.copy(h,0,_,F,1);return _};var Vr=function(l){function h(_,C){l.call(this,C),this._points=null,this.init(_)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){return this.isEmpty()?new De:this._points.expandEnvelope(new De)},h.prototype.isRing=function(){return this.isClosed()&&this.isSimple()},h.prototype.getSortIndex=function(){return l.SORTINDEX_LINESTRING},h.prototype.getCoordinates=function(){return this._points.toCoordinateArray()},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];if(!this.isEquivalentClass(_))return!1;var F=_;if(this._points.size()!==F._points.size())return!1;for(var rt=0;rt<this._points.size();rt++)if(!this.equal(this._points.getCoordinate(rt),F._points.getCoordinate(rt),C))return!1;return!0}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){for(var _=0;_<Math.trunc(this._points.size()/2);_++){var C=this._points.size()-1-_;if(!this._points.getCoordinate(_).equals(this._points.getCoordinate(C)))return this._points.getCoordinate(_).compareTo(this._points.getCoordinate(C))>0&&ti.reverse(this._points),null}},h.prototype.getCoordinate=function(){return this.isEmpty()?null:this._points.getCoordinate(0)},h.prototype.getBoundaryDimension=function(){return this.isClosed()?tr.FALSE:0},h.prototype.isClosed=function(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},h.prototype.getEndPoint=function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},h.prototype.getDimension=function(){return 1},h.prototype.getLength=function(){return yn.computeLength(this._points)},h.prototype.getNumPoints=function(){return this._points.size()},h.prototype.reverse=function(){var _=this._points.copy();return ti.reverse(_),this.getFactory().createLineString(_)},h.prototype.compareToSameClass=function(){if(1===arguments.length){for(var _=arguments[0],C=0,F=0;C<this._points.size()&&F<_._points.size();){var rt=this._points.getCoordinate(C).compareTo(_._points.getCoordinate(F));if(0!==rt)return rt;C++,F++}return C<this._points.size()?1:F<_._points.size()?-1:0}if(2===arguments.length)return arguments[1].compare(this._points,arguments[0]._points)},h.prototype.apply=function(){if(O(arguments[0],Et))for(var _=arguments[0],C=0;C<this._points.size();C++)_.filter(this._points.getCoordinate(C));else if(O(arguments[0],oi)){var F=arguments[0];if(0===this._points.size())return null;for(var rt=0;rt<this._points.size()&&(F.filter(this._points,rt),!F.isDone());rt++);F.isGeometryChanged()&&this.geometryChanged()}else(O(arguments[0],fi)||O(arguments[0],xo))&&arguments[0].filter(this)},h.prototype.getBoundary=function(){return new ho(this).getBoundary()},h.prototype.isEquivalentClass=function(_){return _ instanceof h},h.prototype.clone=function(){var _=l.prototype.clone.call(this);return _._points=this._points.clone(),_},h.prototype.getCoordinateN=function(_){return this._points.getCoordinate(_)},h.prototype.getGeometryType=function(){return"LineString"},h.prototype.copy=function(){return new h(this._points.copy(),this._factory)},h.prototype.getCoordinateSequence=function(){return this._points},h.prototype.isEmpty=function(){return 0===this._points.size()},h.prototype.init=function(_){if(null===_&&(_=this.getFactory().getCoordinateSequenceFactory().create([])),1===_.size())throw new dt("Invalid number of points in LineString (found "+_.size()+" - must be 0 or >= 2)");this._points=_},h.prototype.isCoordinate=function(_){for(var C=0;C<this._points.size();C++)if(this._points.getCoordinate(C).equals(_))return!0;return!1},h.prototype.getStartPoint=function(){return this.isEmpty()?null:this.getPointN(0)},h.prototype.getPointN=function(_){return this.getFactory().createPoint(this._points.getCoordinate(_))},h.prototype.interfaces_=function(){return[Dn]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return 0x2b2b51ba435c8e00},Object.defineProperties(h,m),h}(Gn),Eo=function(){};Eo.prototype.interfaces_=function(){return[]},Eo.prototype.getClass=function(){return Eo};var Ls=function(l){function h(_,C){l.call(this,C),this._coordinates=_||null,this.init(this._coordinates)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){if(this.isEmpty())return new De;var _=new De;return _.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),_},h.prototype.getSortIndex=function(){return l.SORTINDEX_POINT},h.prototype.getCoordinates=function(){return this.isEmpty()?[]:[this.getCoordinate()]},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];return!!this.isEquivalentClass(_)&&(!(!this.isEmpty()||!_.isEmpty())||this.isEmpty()===_.isEmpty()&&this.equal(_.getCoordinate(),this.getCoordinate(),C))}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){},h.prototype.getCoordinate=function(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null},h.prototype.getBoundaryDimension=function(){return tr.FALSE},h.prototype.getDimension=function(){return 0},h.prototype.getNumPoints=function(){return this.isEmpty()?0:1},h.prototype.reverse=function(){return this.copy()},h.prototype.getX=function(){if(null===this.getCoordinate())throw new Error("getX called on empty Point");return this.getCoordinate().x},h.prototype.compareToSameClass=function(){if(1===arguments.length){var _=arguments[0];return this.getCoordinate().compareTo(_.getCoordinate())}if(2===arguments.length)return arguments[1].compare(this._coordinates,arguments[0]._coordinates)},h.prototype.apply=function(){if(O(arguments[0],Et)){var _=arguments[0];if(this.isEmpty())return null;_.filter(this.getCoordinate())}else if(O(arguments[0],oi)){var C=arguments[0];if(this.isEmpty())return null;C.filter(this._coordinates,0),C.isGeometryChanged()&&this.geometryChanged()}else(O(arguments[0],fi)||O(arguments[0],xo))&&arguments[0].filter(this)},h.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},h.prototype.clone=function(){var _=l.prototype.clone.call(this);return _._coordinates=this._coordinates.clone(),_},h.prototype.getGeometryType=function(){return"Point"},h.prototype.copy=function(){return new h(this._coordinates.copy(),this._factory)},h.prototype.getCoordinateSequence=function(){return this._coordinates},h.prototype.getY=function(){if(null===this.getCoordinate())throw new Error("getY called on empty Point");return this.getCoordinate().y},h.prototype.isEmpty=function(){return 0===this._coordinates.size()},h.prototype.init=function(_){null===_&&(_=this.getFactory().getCoordinateSequenceFactory().create([])),Nn.isTrue(_.size()<=1),this._coordinates=_},h.prototype.isSimple=function(){return!0},h.prototype.interfaces_=function(){return[Eo]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return 0x44077bad161cbc00},Object.defineProperties(h,m),h}(Gn),Ma=function(){};Ma.prototype.interfaces_=function(){return[]},Ma.prototype.getClass=function(){return Ma};var rs=function(l){function h(_,C,F){if(l.call(this,F),this._shell=null,this._holes=null,null===_&&(_=this.getFactory().createLinearRing()),null===C&&(C=[]),l.hasNullElements(C))throw new dt("holes must not contain null elements");if(_.isEmpty()&&l.hasNonEmptyElements(C))throw new dt("shell is empty but holes are not");this._shell=_,this._holes=C}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.computeEnvelopeInternal=function(){return this._shell.getEnvelopeInternal()},h.prototype.getSortIndex=function(){return l.SORTINDEX_POLYGON},h.prototype.getCoordinates=function(){if(this.isEmpty())return[];for(var _=new Array(this.getNumPoints()).fill(null),C=-1,F=this._shell.getCoordinates(),rt=0;rt<F.length;rt++)_[++C]=F[rt];for(var Dt=0;Dt<this._holes.length;Dt++)for(var qt=this._holes[Dt].getCoordinates(),fe=0;fe<qt.length;fe++)_[++C]=qt[fe];return _},h.prototype.getArea=function(){var _=0;_+=Math.abs(yn.signedArea(this._shell.getCoordinateSequence()));for(var C=0;C<this._holes.length;C++)_-=Math.abs(yn.signedArea(this._holes[C].getCoordinateSequence()));return _},h.prototype.isRectangle=function(){if(0!==this.getNumInteriorRing()||null===this._shell||5!==this._shell.getNumPoints())return!1;for(var _=this._shell.getCoordinateSequence(),C=this.getEnvelopeInternal(),F=0;F<5;F++){var rt=_.getX(F);if(rt!==C.getMinX()&&rt!==C.getMaxX())return!1;var Dt=_.getY(F);if(Dt!==C.getMinY()&&Dt!==C.getMaxY())return!1}for(var qt=_.getX(0),fe=_.getY(0),ke=1;ke<=4;ke++){var Ge=_.getX(ke),xn=_.getY(ke);if(Ge!==qt==(xn!==fe))return!1;qt=Ge,fe=xn}return!0},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];if(!this.isEquivalentClass(_))return!1;var F=_;if(!this._shell.equalsExact(F._shell,C)||this._holes.length!==F._holes.length)return!1;for(var qt=0;qt<this._holes.length;qt++)if(!this._holes[qt].equalsExact(F._holes[qt],C))return!1;return!0}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.normalize=function(){if(0===arguments.length){this.normalize(this._shell,!0);for(var _=0;_<this._holes.length;_++)this.normalize(this._holes[_],!1);kr.sort(this._holes)}else if(2===arguments.length){var C=arguments[0],F=arguments[1];if(C.isEmpty())return null;var rt=new Array(C.getCoordinates().length-1).fill(null);Xe.arraycopy(C.getCoordinates(),0,rt,0,rt.length);var Dt=un.minCoordinate(C.getCoordinates());un.scroll(rt,Dt),Xe.arraycopy(rt,0,C.getCoordinates(),0,rt.length),C.getCoordinates()[rt.length]=rt[0],yn.isCCW(C.getCoordinates())===F&&un.reverse(C.getCoordinates())}},h.prototype.getCoordinate=function(){return this._shell.getCoordinate()},h.prototype.getNumInteriorRing=function(){return this._holes.length},h.prototype.getBoundaryDimension=function(){return 1},h.prototype.getDimension=function(){return 2},h.prototype.getLength=function(){var _=0;_+=this._shell.getLength();for(var C=0;C<this._holes.length;C++)_+=this._holes[C].getLength();return _},h.prototype.getNumPoints=function(){for(var _=this._shell.getNumPoints(),C=0;C<this._holes.length;C++)_+=this._holes[C].getNumPoints();return _},h.prototype.reverse=function(){var _=this.copy();_._shell=this._shell.copy().reverse(),_._holes=new Array(this._holes.length).fill(null);for(var C=0;C<this._holes.length;C++)_._holes[C]=this._holes[C].copy().reverse();return _},h.prototype.convexHull=function(){return this.getExteriorRing().convexHull()},h.prototype.compareToSameClass=function(){if(1===arguments.length)return this._shell.compareToSameClass(arguments[0]._shell);if(2===arguments.length){var Dt=arguments[1],qt=arguments[0],Ge=this._shell.compareToSameClass(qt._shell,Dt);if(0!==Ge)return Ge;for(var xn=this.getNumInteriorRing(),Sn=qt.getNumInteriorRing(),Un=0;Un<xn&&Un<Sn;){var ur=this.getInteriorRingN(Un),Ji=qt.getInteriorRingN(Un),Do=ur.compareToSameClass(Ji,Dt);if(0!==Do)return Do;Un++}return Un<xn?1:Un<Sn?-1:0}},h.prototype.apply=function(_){if(O(_,Et)){this._shell.apply(_);for(var C=0;C<this._holes.length;C++)this._holes[C].apply(_)}else if(O(_,oi)){if(this._shell.apply(_),!_.isDone())for(var F=0;F<this._holes.length&&(this._holes[F].apply(_),!_.isDone());F++);_.isGeometryChanged()&&this.geometryChanged()}else if(O(_,fi))_.filter(this);else if(O(_,xo)){_.filter(this),this._shell.apply(_);for(var rt=0;rt<this._holes.length;rt++)this._holes[rt].apply(_)}},h.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var _=new Array(this._holes.length+1).fill(null);_[0]=this._shell;for(var C=0;C<this._holes.length;C++)_[C+1]=this._holes[C];return _.length<=1?this.getFactory().createLinearRing(_[0].getCoordinateSequence()):this.getFactory().createMultiLineString(_)},h.prototype.clone=function(){var _=l.prototype.clone.call(this);_._shell=this._shell.clone(),_._holes=new Array(this._holes.length).fill(null);for(var C=0;C<this._holes.length;C++)_._holes[C]=this._holes[C].clone();return _},h.prototype.getGeometryType=function(){return"Polygon"},h.prototype.copy=function(){for(var _=this._shell.copy(),C=new Array(this._holes.length).fill(null),F=0;F<C.length;F++)C[F]=this._holes[F].copy();return new h(_,C,this._factory)},h.prototype.getExteriorRing=function(){return this._shell},h.prototype.isEmpty=function(){return this._shell.isEmpty()},h.prototype.getInteriorRingN=function(_){return this._holes[_]},h.prototype.interfaces_=function(){return[Ma]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return-0x307ffefd8dc97200},Object.defineProperties(h,m),h}(Gn),Pa=function(l){function h(){l.apply(this,arguments)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Gn.SORTINDEX_MULTIPOINT},h.prototype.isValid=function(){return!0},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];return!!this.isEquivalentClass(_)&&l.prototype.equalsExact.call(this,_,C)}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.getCoordinate=function(){return 1===arguments.length?this._geometries[arguments[0]].getCoordinate():l.prototype.getCoordinate.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return tr.FALSE},h.prototype.getDimension=function(){return 0},h.prototype.getBoundary=function(){return this.getFactory().createGeometryCollection(null)},h.prototype.getGeometryType=function(){return"MultiPoint"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),C=0;C<_.length;C++)_[C]=this._geometries[C].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[Eo]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return-0x6fb1ed4162e0fc00},Object.defineProperties(h,m),h}(zr),eo=function(l){function h(_,C){_ instanceof B&&C instanceof er&&(_=C.getCoordinateSequenceFactory().create(_)),l.call(this,_,C),this.validateConstruction()}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={MINIMUM_VALID_SIZE:{configurable:!0},serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Gn.SORTINDEX_LINEARRING},h.prototype.getBoundaryDimension=function(){return tr.FALSE},h.prototype.isClosed=function(){return!!this.isEmpty()||l.prototype.isClosed.call(this)},h.prototype.reverse=function(){var _=this._points.copy();return ti.reverse(_),this.getFactory().createLinearRing(_)},h.prototype.validateConstruction=function(){if(!this.isEmpty()&&!l.prototype.isClosed.call(this))throw new dt("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<h.MINIMUM_VALID_SIZE)throw new dt("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},h.prototype.getGeometryType=function(){return"LinearRing"},h.prototype.copy=function(){return new h(this._points.copy(),this._factory)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},m.MINIMUM_VALID_SIZE.get=function(){return 4},m.serialVersionUID.get=function(){return-0x3b229e262367a600},Object.defineProperties(h,m),h}(Vr),Co=function(l){function h(){l.apply(this,arguments)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={serialVersionUID:{configurable:!0}};return h.prototype.getSortIndex=function(){return Gn.SORTINDEX_MULTIPOLYGON},h.prototype.equalsExact=function(){if(2===arguments.length){var _=arguments[0],C=arguments[1];return!!this.isEquivalentClass(_)&&l.prototype.equalsExact.call(this,_,C)}return l.prototype.equalsExact.apply(this,arguments)},h.prototype.getBoundaryDimension=function(){return 1},h.prototype.getDimension=function(){return 2},h.prototype.reverse=function(){for(var C=new Array(this._geometries.length).fill(null),F=0;F<this._geometries.length;F++)C[F]=this._geometries[F].reverse();return this.getFactory().createMultiPolygon(C)},h.prototype.getBoundary=function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var _=new ue,C=0;C<this._geometries.length;C++)for(var F=this._geometries[C].getBoundary(),rt=0;rt<F.getNumGeometries();rt++)_.add(F.getGeometryN(rt));var Dt=new Array(_.size()).fill(null);return this.getFactory().createMultiLineString(_.toArray(Dt))},h.prototype.getGeometryType=function(){return"MultiPolygon"},h.prototype.copy=function(){for(var _=new Array(this._geometries.length).fill(null),C=0;C<_.length;C++)_[C]=this._geometries[C].copy();return new h(_,this._factory)},h.prototype.interfaces_=function(){return[Ma]},h.prototype.getClass=function(){return h},m.serialVersionUID.get=function(){return-0x7a5aa1369171980},Object.defineProperties(h,m),h}(zr),gs=function(l){this._factory=l||null,this._isUserDataCopied=!1},Ua={NoOpGeometryOperation:{configurable:!0},CoordinateOperation:{configurable:!0},CoordinateSequenceOperation:{configurable:!0}};gs.prototype.setCopyUserData=function(l){this._isUserDataCopied=l},gs.prototype.edit=function(l,h){if(null===l)return null;var m=this.editInternal(l,h);return this._isUserDataCopied&&m.setUserData(l.getUserData()),m},gs.prototype.editInternal=function(l,h){return null===this._factory&&(this._factory=l.getFactory()),l instanceof zr?this.editGeometryCollection(l,h):l instanceof rs?this.editPolygon(l,h):l instanceof Ls||l instanceof Vr?h.edit(l,this._factory):(Nn.shouldNeverReachHere("Unsupported Geometry class: "+l.getClass().getName()),null)},gs.prototype.editGeometryCollection=function(l,h){for(var m=h.edit(l,this._factory),_=new ue,C=0;C<m.getNumGeometries();C++){var F=this.edit(m.getGeometryN(C),h);null===F||F.isEmpty()||_.add(F)}return m.getClass()===Pa?this._factory.createMultiPoint(_.toArray([])):m.getClass()===js?this._factory.createMultiLineString(_.toArray([])):m.getClass()===Co?this._factory.createMultiPolygon(_.toArray([])):this._factory.createGeometryCollection(_.toArray([]))},gs.prototype.editPolygon=function(l,h){var m=h.edit(l,this._factory);if(null===m&&(m=this._factory.createPolygon(null)),m.isEmpty())return m;var _=this.edit(m.getExteriorRing(),h);if(null===_||_.isEmpty())return this._factory.createPolygon();for(var C=new ue,F=0;F<m.getNumInteriorRing();F++){var rt=this.edit(m.getInteriorRingN(F),h);null===rt||rt.isEmpty()||C.add(rt)}return this._factory.createPolygon(_,C.toArray([]))},gs.prototype.interfaces_=function(){return[]},gs.prototype.getClass=function(){return gs},gs.GeometryEditorOperation=function(){},Ua.NoOpGeometryOperation.get=function(){return bu},Ua.CoordinateOperation.get=function(){return Oa},Ua.CoordinateSequenceOperation.get=function(){return $r},Object.defineProperties(gs,Ua);var bu=function(){};bu.prototype.edit=function(l,h){return l},bu.prototype.interfaces_=function(){return[gs.GeometryEditorOperation]},bu.prototype.getClass=function(){return bu};var Oa=function(){};Oa.prototype.edit=function(l,h){var m=this.editCoordinates(l.getCoordinates(),l);return null===m?l:l instanceof eo?h.createLinearRing(m):l instanceof Vr?h.createLineString(m):l instanceof Ls?m.length>0?h.createPoint(m[0]):h.createPoint():l},Oa.prototype.interfaces_=function(){return[gs.GeometryEditorOperation]},Oa.prototype.getClass=function(){return Oa};var $r=function(){};$r.prototype.edit=function(l,h){return l instanceof eo?h.createLinearRing(this.edit(l.getCoordinateSequence(),l)):l instanceof Vr?h.createLineString(this.edit(l.getCoordinateSequence(),l)):l instanceof Ls?h.createPoint(this.edit(l.getCoordinateSequence(),l)):l},$r.prototype.interfaces_=function(){return[gs.GeometryEditorOperation]},$r.prototype.getClass=function(){return $r};var pr=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array)this._coordinates=arguments[0],this._dimension=3;else if(Number.isInteger(arguments[0])){var l=arguments[0];this._coordinates=new Array(l).fill(null);for(var h=0;h<l;h++)this._coordinates[h]=new B}else if(O(arguments[0],jt)){var m=arguments[0];if(null===m)return this._coordinates=new Array(0).fill(null),null;this._dimension=m.getDimension(),this._coordinates=new Array(m.size()).fill(null);for(var _=0;_<this._coordinates.length;_++)this._coordinates[_]=m.getCoordinateCopy(_)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var C=arguments[0],F=arguments[1];this._coordinates=C,this._dimension=F,null===C&&(this._coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var rt=arguments[0],Dt=arguments[1];this._coordinates=new Array(rt).fill(null),this._dimension=Dt;for(var qt=0;qt<rt;qt++)this._coordinates[qt]=new B}},du={serialVersionUID:{configurable:!0}};pr.prototype.setOrdinate=function(l,h,m){switch(h){case jt.X:this._coordinates[l].x=m;break;case jt.Y:this._coordinates[l].y=m;break;case jt.Z:this._coordinates[l].z=m;break;default:throw new dt("invalid ordinateIndex")}},pr.prototype.size=function(){return this._coordinates.length},pr.prototype.getOrdinate=function(l,h){switch(h){case jt.X:return this._coordinates[l].x;case jt.Y:return this._coordinates[l].y;case jt.Z:return this._coordinates[l].z}return lt.NaN},pr.prototype.getCoordinate=function(){if(1===arguments.length)return this._coordinates[arguments[0]];if(2===arguments.length){var h=arguments[0],m=arguments[1];m.x=this._coordinates[h].x,m.y=this._coordinates[h].y,m.z=this._coordinates[h].z}},pr.prototype.getCoordinateCopy=function(l){return new B(this._coordinates[l])},pr.prototype.getDimension=function(){return this._dimension},pr.prototype.getX=function(l){return this._coordinates[l].x},pr.prototype.clone=function(){for(var l=new Array(this.size()).fill(null),h=0;h<this._coordinates.length;h++)l[h]=this._coordinates[h].clone();return new pr(l,this._dimension)},pr.prototype.expandEnvelope=function(l){for(var h=0;h<this._coordinates.length;h++)l.expandToInclude(this._coordinates[h]);return l},pr.prototype.copy=function(){for(var l=new Array(this.size()).fill(null),h=0;h<this._coordinates.length;h++)l[h]=this._coordinates[h].copy();return new pr(l,this._dimension)},pr.prototype.toString=function(){if(this._coordinates.length>0){var l=new vt(17*this._coordinates.length);l.append("("),l.append(this._coordinates[0]);for(var h=1;h<this._coordinates.length;h++)l.append(", "),l.append(this._coordinates[h]);return l.append(")"),l.toString()}return"()"},pr.prototype.getY=function(l){return this._coordinates[l].y},pr.prototype.toCoordinateArray=function(){return this._coordinates},pr.prototype.interfaces_=function(){return[jt,$]},pr.prototype.getClass=function(){return pr},du.serialVersionUID.get=function(){return-0xcb44a778db18e00},Object.defineProperties(pr,du);var Xs=function(){},Wa={serialVersionUID:{configurable:!0},instanceObject:{configurable:!0}};Xs.prototype.readResolve=function(){return Xs.instance()},Xs.prototype.create=function(){if(1===arguments.length){if(arguments[0]instanceof Array)return new pr(arguments[0]);if(O(arguments[0],jt))return new pr(arguments[0])}else if(2===arguments.length){var m=arguments[0],_=arguments[1];return _>3&&(_=3),_<2?new pr(m):new pr(m,_)}},Xs.prototype.interfaces_=function(){return[at,$]},Xs.prototype.getClass=function(){return Xs},Xs.instance=function(){return Xs.instanceObject},Wa.serialVersionUID.get=function(){return-0x38e49fa6cf6f2e00},Wa.instanceObject.get=function(){return new Xs},Object.defineProperties(Xs,Wa);var ys=function(l){function h(){l.call(this),this.map_=new Map}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.get=function(m){return this.map_.get(m)||null},h.prototype.put=function(m,_){return this.map_.set(m,_),_},h.prototype.values=function(){for(var m=new ue,_=this.map_.values(),C=_.next();!C.done;)m.add(C.value),C=_.next();return m},h.prototype.entrySet=function(){var m=new Jr;return this.map_.entries().forEach(function(_){return m.add(_)}),m},h.prototype.size=function(){return this.map_.size()},h}(_n),An=function l(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=l.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Qn){var h=arguments[0];this._modelType=h,h===l.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var m=arguments[0];this._modelType=l.FIXED,this.setScale(m)}else if(arguments[0]instanceof l){var _=arguments[0];this._modelType=_._modelType,this._scale=_._scale}},Gr={serialVersionUID:{configurable:!0},maximumPreciseValue:{configurable:!0}};An.prototype.equals=function(l){return l instanceof An&&this._modelType===l._modelType&&this._scale===l._scale},An.prototype.compareTo=function(l){var h=l,m=this.getMaximumSignificantDigits(),_=h.getMaximumSignificantDigits();return new xt(m).compareTo(new xt(_))},An.prototype.getScale=function(){return this._scale},An.prototype.isFloating=function(){return this._modelType===An.FLOATING||this._modelType===An.FLOATING_SINGLE},An.prototype.getType=function(){return this._modelType},An.prototype.toString=function(){var l="UNKNOWN";return this._modelType===An.FLOATING?l="Floating":this._modelType===An.FLOATING_SINGLE?l="Floating-Single":this._modelType===An.FIXED&&(l="Fixed (Scale="+this.getScale()+")"),l},An.prototype.makePrecise=function(){if("number"==typeof arguments[0]){var l=arguments[0];return lt.isNaN(l)||this._modelType===An.FLOATING_SINGLE?l:this._modelType===An.FIXED?Math.round(l*this._scale)/this._scale:l}if(arguments[0]instanceof B){var h=arguments[0];if(this._modelType===An.FLOATING)return null;h.x=this.makePrecise(h.x),h.y=this.makePrecise(h.y)}},An.prototype.getMaximumSignificantDigits=function(){var l=16;return this._modelType===An.FLOATING?l=16:this._modelType===An.FLOATING_SINGLE?l=6:this._modelType===An.FIXED&&(l=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),l},An.prototype.setScale=function(l){this._scale=Math.abs(l)},An.prototype.interfaces_=function(){return[$,q]},An.prototype.getClass=function(){return An},An.mostPrecise=function(l,h){return l.compareTo(h)>=0?l:h},Gr.serialVersionUID.get=function(){return 0x6bee6404e9a25c00},Gr.maximumPreciseValue.get=function(){return 9007199254740992},Object.defineProperties(An,Gr);var Qn=function l(h){this._name=h||null,l.nameToTypeMap.put(h,this)},ma={serialVersionUID:{configurable:!0},nameToTypeMap:{configurable:!0}};Qn.prototype.readResolve=function(){return Qn.nameToTypeMap.get(this._name)},Qn.prototype.toString=function(){return this._name},Qn.prototype.interfaces_=function(){return[$]},Qn.prototype.getClass=function(){return Qn},ma.serialVersionUID.get=function(){return-552860263173159e4},ma.nameToTypeMap.get=function(){return new ys},Object.defineProperties(Qn,ma),An.Type=Qn,An.FIXED=new Qn("FIXED"),An.FLOATING=new Qn("FLOATING"),An.FLOATING_SINGLE=new Qn("FLOATING SINGLE");var er=function l(){this._precisionModel=new An,this._SRID=0,this._coordinateSequenceFactory=l.getDefaultCoordinateSequenceFactory(),0===arguments.length||(1===arguments.length?O(arguments[0],at)?this._coordinateSequenceFactory=arguments[0]:arguments[0]instanceof An&&(this._precisionModel=arguments[0]):2===arguments.length?(this._precisionModel=arguments[0],this._SRID=arguments[1]):3===arguments.length&&(this._precisionModel=arguments[0],this._SRID=arguments[1],this._coordinateSequenceFactory=arguments[2]))},bo={serialVersionUID:{configurable:!0}};er.prototype.toGeometry=function(l){return l.isNull()?this.createPoint(null):l.getMinX()===l.getMaxX()&&l.getMinY()===l.getMaxY()?this.createPoint(new B(l.getMinX(),l.getMinY())):l.getMinX()===l.getMaxX()||l.getMinY()===l.getMaxY()?this.createLineString([new B(l.getMinX(),l.getMinY()),new B(l.getMaxX(),l.getMaxY())]):this.createPolygon(this.createLinearRing([new B(l.getMinX(),l.getMinY()),new B(l.getMinX(),l.getMaxY()),new B(l.getMaxX(),l.getMaxY()),new B(l.getMaxX(),l.getMinY()),new B(l.getMinX(),l.getMinY())]),null)},er.prototype.createLineString=function(l){return l?l instanceof Array?new Vr(this.getCoordinateSequenceFactory().create(l),this):O(l,jt)?new Vr(l,this):void 0:new Vr(this.getCoordinateSequenceFactory().create([]),this)},er.prototype.createMultiLineString=function(){return 0===arguments.length?new js(null,this):1===arguments.length?new js(arguments[0],this):void 0},er.prototype.buildGeometry=function(l){for(var h=null,m=!1,_=!1,C=l.iterator();C.hasNext();){var F=C.next(),rt=F.getClass();null===h&&(h=rt),rt!==h&&(m=!0),F.isGeometryCollectionOrDerived()&&(_=!0)}if(null===h)return this.createGeometryCollection();if(m||_)return this.createGeometryCollection(er.toGeometryArray(l));var Dt=l.iterator().next();if(l.size()>1){if(Dt instanceof rs)return this.createMultiPolygon(er.toPolygonArray(l));if(Dt instanceof Vr)return this.createMultiLineString(er.toLineStringArray(l));if(Dt instanceof Ls)return this.createMultiPoint(er.toPointArray(l));Nn.shouldNeverReachHere("Unhandled class: "+Dt.getClass().getName())}return Dt},er.prototype.createMultiPointFromCoords=function(l){return this.createMultiPoint(null!==l?this.getCoordinateSequenceFactory().create(l):null)},er.prototype.createPoint=function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof B){var l=arguments[0];return this.createPoint(null!==l?this.getCoordinateSequenceFactory().create([l]):null)}if(O(arguments[0],jt))return new Ls(arguments[0],this)}},er.prototype.getCoordinateSequenceFactory=function(){return this._coordinateSequenceFactory},er.prototype.createPolygon=function(){if(0===arguments.length)return new rs(null,null,this);if(1===arguments.length){if(O(arguments[0],jt))return this.createPolygon(this.createLinearRing(arguments[0]));if(arguments[0]instanceof Array)return this.createPolygon(this.createLinearRing(arguments[0]));if(arguments[0]instanceof eo)return this.createPolygon(arguments[0],null)}else if(2===arguments.length)return new rs(arguments[0],arguments[1],this)},er.prototype.getSRID=function(){return this._SRID},er.prototype.createGeometryCollection=function(){return 0===arguments.length?new zr(null,this):1===arguments.length?new zr(arguments[0],this):void 0},er.prototype.createGeometry=function(l){return new gs(this).edit(l,{edit:function(){if(2===arguments.length)return this._coordinateSequenceFactory.create(arguments[0])}})},er.prototype.getPrecisionModel=function(){return this._precisionModel},er.prototype.createLinearRing=function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var l=arguments[0];return this.createLinearRing(null!==l?this.getCoordinateSequenceFactory().create(l):null)}if(O(arguments[0],jt))return new eo(arguments[0],this)}},er.prototype.createMultiPolygon=function(){return 0===arguments.length?new Co(null,this):1===arguments.length?new Co(arguments[0],this):void 0},er.prototype.createMultiPoint=function(){if(0===arguments.length)return new Pa(null,this);if(1===arguments.length){if(arguments[0]instanceof Array)return new Pa(arguments[0],this);if(arguments[0]instanceof Array){var h=arguments[0];return this.createMultiPoint(null!==h?this.getCoordinateSequenceFactory().create(h):null)}if(O(arguments[0],jt)){var m=arguments[0];if(null===m)return this.createMultiPoint(new Array(0).fill(null));for(var _=new Array(m.size()).fill(null),C=0;C<m.size();C++){var F=this.getCoordinateSequenceFactory().create(1,m.getDimension());ti.copy(m,C,F,0,1),_[C]=this.createPoint(F)}return this.createMultiPoint(_)}}},er.prototype.interfaces_=function(){return[$]},er.prototype.getClass=function(){return er},er.toMultiPolygonArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},er.toGeometryArray=function(l){if(null===l)return null;var h=new Array(l.size()).fill(null);return l.toArray(h)},er.getDefaultCoordinateSequenceFactory=function(){return Xs.instance()},er.toMultiLineStringArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},er.toLineStringArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},er.toMultiPointArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},er.toLinearRingArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},er.toPointArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},er.toPolygonArray=function(l){var h=new Array(l.size()).fill(null);return l.toArray(h)},er.createPointFromInternalCoord=function(l,h){return h.getPrecisionModel().makePrecise(l),h.getFactory().createPoint(l)},bo.serialVersionUID.get=function(){return-0x5ea75f2051eeb400},Object.defineProperties(er,bo);var Yu=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"],ga=function(l){this.geometryFactory=l||new er};ga.prototype.read=function(l){var h,m=(h="string"==typeof l?JSON.parse(l):l).type;if(!Xn[m])throw new Error("Unknown GeoJSON type: "+h.type);return-1!==Yu.indexOf(m)?Xn[m].apply(this,[h.coordinates]):Xn[m].apply(this,"GeometryCollection"===m?[h.geometries]:[h])},ga.prototype.write=function(l){var h=l.getGeometryType();if(!Cs[h])throw new Error("Geometry is not supported");return Cs[h].apply(this,[l])};var Xn={Feature:function(l){var h={};for(var m in l)h[m]=l[m];if(l.geometry){if(!Xn[l.geometry.type])throw new Error("Unknown GeoJSON type: "+l.type);h.geometry=this.read(l.geometry)}return l.bbox&&(h.bbox=Xn.bbox.apply(this,[l.bbox])),h},FeatureCollection:function(l){var h={};if(l.features){h.features=[];for(var m=0;m<l.features.length;++m)h.features.push(this.read(l.features[m]))}return l.bbox&&(h.bbox=this.parse.bbox.apply(this,[l.bbox])),h},coordinates:function(l){for(var h=[],m=0;m<l.length;++m){var _=l[m];h.push(new B(_[0],_[1]))}return h},bbox:function(l){return this.geometryFactory.createLinearRing([new B(l[0],l[1]),new B(l[2],l[1]),new B(l[2],l[3]),new B(l[0],l[3]),new B(l[0],l[1])])},Point:function(l){var h=new B(l[0],l[1]);return this.geometryFactory.createPoint(h)},MultiPoint:function(l){for(var h=[],m=0;m<l.length;++m)h.push(Xn.Point.apply(this,[l[m]]));return this.geometryFactory.createMultiPoint(h)},LineString:function(l){var h=Xn.coordinates.apply(this,[l]);return this.geometryFactory.createLineString(h)},MultiLineString:function(l){for(var h=[],m=0;m<l.length;++m)h.push(Xn.LineString.apply(this,[l[m]]));return this.geometryFactory.createMultiLineString(h)},Polygon:function(l){for(var h=Xn.coordinates.apply(this,[l[0]]),m=this.geometryFactory.createLinearRing(h),_=[],C=1;C<l.length;++C){var rt=Xn.coordinates.apply(this,[l[C]]),Dt=this.geometryFactory.createLinearRing(rt);_.push(Dt)}return this.geometryFactory.createPolygon(m,_)},MultiPolygon:function(l){for(var h=[],m=0;m<l.length;++m)h.push(Xn.Polygon.apply(this,[l[m]]));return this.geometryFactory.createMultiPolygon(h)},GeometryCollection:function(l){for(var h=[],m=0;m<l.length;++m)h.push(this.read(l[m]));return this.geometryFactory.createGeometryCollection(h)}},Cs={coordinate:function(l){return[l.x,l.y]},Point:function(l){return{type:"Point",coordinates:Cs.coordinate.apply(this,[l.getCoordinate()])}},MultiPoint:function(l){for(var h=[],m=0;m<l._geometries.length;++m){var C=Cs.Point.apply(this,[l._geometries[m]]);h.push(C.coordinates)}return{type:"MultiPoint",coordinates:h}},LineString:function(l){for(var h=[],m=l.getCoordinates(),_=0;_<m.length;++_)h.push(Cs.coordinate.apply(this,[m[_]]));return{type:"LineString",coordinates:h}},MultiLineString:function(l){for(var h=[],m=0;m<l._geometries.length;++m){var C=Cs.LineString.apply(this,[l._geometries[m]]);h.push(C.coordinates)}return{type:"MultiLineString",coordinates:h}},Polygon:function(l){var h=[],m=Cs.LineString.apply(this,[l._shell]);h.push(m.coordinates);for(var _=0;_<l._holes.length;++_){var F=Cs.LineString.apply(this,[l._holes[_]]);h.push(F.coordinates)}return{type:"Polygon",coordinates:h}},MultiPolygon:function(l){for(var h=[],m=0;m<l._geometries.length;++m){var C=Cs.Polygon.apply(this,[l._geometries[m]]);h.push(C.coordinates)}return{type:"MultiPolygon",coordinates:h}},GeometryCollection:function(l){for(var h=[],m=0;m<l._geometries.length;++m){var _=l._geometries[m],C=_.getGeometryType();h.push(Cs[C].apply(this,[_]))}return{type:"GeometryCollection",geometries:h}}},Yi=function(l){this.geometryFactory=l||new er,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new ga(this.geometryFactory)};Yi.prototype.read=function(l){var h=this.parser.read(l);return this.precisionModel.getType()===An.FIXED&&this.reducePrecision(h),h},Yi.prototype.reducePrecision=function(l){var h,m;if(l.coordinate)this.precisionModel.makePrecise(l.coordinate);else if(l.points)for(h=0,m=l.points.length;h<m;h++)this.precisionModel.makePrecise(l.points[h]);else if(l.geometries)for(h=0,m=l.geometries.length;h<m;h++)this.reducePrecision(l.geometries[h])};var Ra=function(){this.parser=new ga(this.geometryFactory)};Ra.prototype.write=function(l){return this.parser.write(l)};var an=function(){},ei={ON:{configurable:!0},LEFT:{configurable:!0},RIGHT:{configurable:!0}};an.prototype.interfaces_=function(){return[]},an.prototype.getClass=function(){return an},an.opposite=function(l){return l===an.LEFT?an.RIGHT:l===an.RIGHT?an.LEFT:l},ei.ON.get=function(){return 0},ei.LEFT.get=function(){return 1},ei.RIGHT.get=function(){return 2},Object.defineProperties(an,ei),(K.prototype=new Error).name="EmptyStackException",(st.prototype=new En).add=function(l){return this.array_.push(l),!0},st.prototype.get=function(l){if(l<0||l>=this.size())throw new Error;return this.array_[l]},st.prototype.push=function(l){return this.array_.push(l),l},st.prototype.pop=function(l){if(0===this.array_.length)throw new K;return this.array_.pop()},st.prototype.peek=function(){if(0===this.array_.length)throw new K;return this.array_[this.array_.length-1]},st.prototype.empty=function(){return 0===this.array_.length},st.prototype.isEmpty=function(){return this.empty()},st.prototype.search=function(l){return this.array_.indexOf(l)},st.prototype.size=function(){return this.array_.length},st.prototype.toArray=function(){for(var l=[],h=0,m=this.array_.length;h<m;h++)l.push(this.array_[h]);return l};var Fn=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null};Fn.prototype.getCoordinate=function(){return this._minCoord},Fn.prototype.getRightmostSide=function(l,h){var m=this.getRightmostSideOfSegment(l,h);return m<0&&(m=this.getRightmostSideOfSegment(l,h-1)),m<0&&(this._minCoord=null,this.checkForRightmostCoordinate(l)),m},Fn.prototype.findRightmostEdgeAtVertex=function(){var l=this._minDe.getEdge().getCoordinates();Nn.isTrue(this._minIndex>0&&this._minIndex<l.length,"rightmost point expected to be interior vertex of edge");var h=l[this._minIndex-1],m=l[this._minIndex+1],_=yn.computeOrientation(this._minCoord,m,h),C=!1;(h.y<this._minCoord.y&&m.y<this._minCoord.y&&_===yn.COUNTERCLOCKWISE||h.y>this._minCoord.y&&m.y>this._minCoord.y&&_===yn.CLOCKWISE)&&(C=!0),C&&(this._minIndex=this._minIndex-1)},Fn.prototype.getRightmostSideOfSegment=function(l,h){var m=l.getEdge().getCoordinates();if(h<0||h+1>=m.length||m[h].y===m[h+1].y)return-1;var _=an.LEFT;return m[h].y<m[h+1].y&&(_=an.RIGHT),_},Fn.prototype.getEdge=function(){return this._orientedDe},Fn.prototype.checkForRightmostCoordinate=function(l){for(var h=l.getEdge().getCoordinates(),m=0;m<h.length-1;m++)(null===this._minCoord||h[m].x>this._minCoord.x)&&(this._minDe=l,this._minIndex=m,this._minCoord=h[m])},Fn.prototype.findRightmostEdgeAtNode=function(){var l=this._minDe.getNode().getEdges();this._minDe=l.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)},Fn.prototype.findEdge=function(l){for(var h=l.iterator();h.hasNext();){var m=h.next();m.isForward()&&this.checkForRightmostCoordinate(m)}Nn.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===an.LEFT&&(this._orientedDe=this._minDe.getSym())},Fn.prototype.interfaces_=function(){return[]},Fn.prototype.getClass=function(){return Fn};var Ss=function(l){function h(m,_){l.call(this,h.msgWithCoord(m,_)),this.pt=_?new B(_):null,this.name="TopologyException"}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.getCoordinate=function(){return this.pt},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.msgWithCoord=function(m,_){return _?m:m+" [ "+_+" ]"},h}(Wn),wo=function(){this.array_=[]};wo.prototype.addLast=function(l){this.array_.push(l)},wo.prototype.removeFirst=function(){return this.array_.shift()},wo.prototype.isEmpty=function(){return 0===this.array_.length};var ks=function(){this._finder=null,this._dirEdgeList=new ue,this._nodes=new ue,this._rightMostCoord=null,this._env=null,this._finder=new Fn};ks.prototype.clearVisitedEdges=function(){for(var l=this._dirEdgeList.iterator();l.hasNext();)l.next().setVisited(!1)},ks.prototype.getRightmostCoordinate=function(){return this._rightMostCoord},ks.prototype.computeNodeDepth=function(l){for(var h=null,m=l.getEdges().iterator();m.hasNext();){var _=m.next();if(_.isVisited()||_.getSym().isVisited()){h=_;break}}if(null===h)throw new Ss("unable to find edge to compute depths at "+l.getCoordinate());l.getEdges().computeDepths(h);for(var C=l.getEdges().iterator();C.hasNext();){var F=C.next();F.setVisited(!0),this.copySymDepths(F)}},ks.prototype.computeDepth=function(l){this.clearVisitedEdges();var h=this._finder.getEdge();h.setEdgeDepths(an.RIGHT,l),this.copySymDepths(h),this.computeDepths(h)},ks.prototype.create=function(l){this.addReachable(l),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()},ks.prototype.findResultEdges=function(){for(var l=this._dirEdgeList.iterator();l.hasNext();){var h=l.next();h.getDepth(an.RIGHT)>=1&&h.getDepth(an.LEFT)<=0&&!h.isInteriorAreaEdge()&&h.setInResult(!0)}},ks.prototype.computeDepths=function(l){var h=new Jr,m=new wo,_=l.getNode();for(m.addLast(_),h.add(_),l.setVisited(!0);!m.isEmpty();){var C=m.removeFirst();h.add(C),this.computeNodeDepth(C);for(var F=C.getEdges().iterator();F.hasNext();){var rt=F.next().getSym();if(!rt.isVisited()){var Dt=rt.getNode();h.contains(Dt)||(m.addLast(Dt),h.add(Dt))}}}},ks.prototype.compareTo=function(l){return this._rightMostCoord.x<l._rightMostCoord.x?-1:this._rightMostCoord.x>l._rightMostCoord.x?1:0},ks.prototype.getEnvelope=function(){if(null===this._env){for(var l=new De,h=this._dirEdgeList.iterator();h.hasNext();)for(var m=h.next().getEdge().getCoordinates(),_=0;_<m.length-1;_++)l.expandToInclude(m[_]);this._env=l}return this._env},ks.prototype.addReachable=function(l){var h=new st;for(h.add(l);!h.empty();){var m=h.pop();this.add(m,h)}},ks.prototype.copySymDepths=function(l){var h=l.getSym();h.setDepth(an.LEFT,l.getDepth(an.RIGHT)),h.setDepth(an.RIGHT,l.getDepth(an.LEFT))},ks.prototype.add=function(l,h){l.setVisited(!0),this._nodes.add(l);for(var m=l.getEdges().iterator();m.hasNext();){var _=m.next();this._dirEdgeList.add(_);var C=_.getSym().getNode();C.isVisited()||h.push(C)}},ks.prototype.getNodes=function(){return this._nodes},ks.prototype.getDirectedEdges=function(){return this._dirEdgeList},ks.prototype.interfaces_=function(){return[q]},ks.prototype.getClass=function(){return ks};var Ur=function l(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array)this.init(arguments[0].length);else if(Number.isInteger(arguments[0])){var m=arguments[0];this.init(1),this.location[an.ON]=m}else if(arguments[0]instanceof l){var _=arguments[0];if(this.init(_.location.length),null!==_)for(var C=0;C<this.location.length;C++)this.location[C]=_.location[C]}}else if(3===arguments.length){var F=arguments[0],rt=arguments[1],Dt=arguments[2];this.init(3),this.location[an.ON]=F,this.location[an.LEFT]=rt,this.location[an.RIGHT]=Dt}};Ur.prototype.setAllLocations=function(l){for(var h=0;h<this.location.length;h++)this.location[h]=l},Ur.prototype.isNull=function(){for(var l=0;l<this.location.length;l++)if(this.location[l]!==nt.NONE)return!1;return!0},Ur.prototype.setAllLocationsIfNull=function(l){for(var h=0;h<this.location.length;h++)this.location[h]===nt.NONE&&(this.location[h]=l)},Ur.prototype.isLine=function(){return 1===this.location.length},Ur.prototype.merge=function(l){if(l.location.length>this.location.length){var h=new Array(3).fill(null);h[an.ON]=this.location[an.ON],h[an.LEFT]=nt.NONE,h[an.RIGHT]=nt.NONE,this.location=h}for(var m=0;m<this.location.length;m++)this.location[m]===nt.NONE&&m<l.location.length&&(this.location[m]=l.location[m])},Ur.prototype.getLocations=function(){return this.location},Ur.prototype.flip=function(){if(this.location.length<=1)return null;var l=this.location[an.LEFT];this.location[an.LEFT]=this.location[an.RIGHT],this.location[an.RIGHT]=l},Ur.prototype.toString=function(){var l=new vt;return this.location.length>1&&l.append(nt.toLocationSymbol(this.location[an.LEFT])),l.append(nt.toLocationSymbol(this.location[an.ON])),this.location.length>1&&l.append(nt.toLocationSymbol(this.location[an.RIGHT])),l.toString()},Ur.prototype.setLocations=function(l,h,m){this.location[an.ON]=l,this.location[an.LEFT]=h,this.location[an.RIGHT]=m},Ur.prototype.get=function(l){return l<this.location.length?this.location[l]:nt.NONE},Ur.prototype.isArea=function(){return this.location.length>1},Ur.prototype.isAnyNull=function(){for(var l=0;l<this.location.length;l++)if(this.location[l]===nt.NONE)return!0;return!1},Ur.prototype.setLocation=function(){1===arguments.length?this.setLocation(an.ON,arguments[0]):2===arguments.length&&(this.location[arguments[0]]=arguments[1])},Ur.prototype.init=function(l){this.location=new Array(l).fill(null),this.setAllLocations(nt.NONE)},Ur.prototype.isEqualOnSide=function(l,h){return this.location[h]===l.location[h]},Ur.prototype.allPositionsEqual=function(l){for(var h=0;h<this.location.length;h++)if(this.location[h]!==l)return!1;return!0},Ur.prototype.interfaces_=function(){return[]},Ur.prototype.getClass=function(){return Ur};var We=function l(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var h=arguments[0];this.elt[0]=new Ur(h),this.elt[1]=new Ur(h)}else if(arguments[0]instanceof l){var m=arguments[0];this.elt[0]=new Ur(m.elt[0]),this.elt[1]=new Ur(m.elt[1])}}else if(2===arguments.length){var _=arguments[0],C=arguments[1];this.elt[0]=new Ur(nt.NONE),this.elt[1]=new Ur(nt.NONE),this.elt[_].setLocation(C)}else if(3===arguments.length){var F=arguments[0],rt=arguments[1],Dt=arguments[2];this.elt[0]=new Ur(F,rt,Dt),this.elt[1]=new Ur(F,rt,Dt)}else if(4===arguments.length){var qt=arguments[0],fe=arguments[1],ke=arguments[2],Ge=arguments[3];this.elt[0]=new Ur(nt.NONE,nt.NONE,nt.NONE),this.elt[1]=new Ur(nt.NONE,nt.NONE,nt.NONE),this.elt[qt].setLocations(fe,ke,Ge)}};We.prototype.getGeometryCount=function(){var l=0;return this.elt[0].isNull()||l++,this.elt[1].isNull()||l++,l},We.prototype.setAllLocations=function(l,h){this.elt[l].setAllLocations(h)},We.prototype.isNull=function(l){return this.elt[l].isNull()},We.prototype.setAllLocationsIfNull=function(){if(1===arguments.length){var l=arguments[0];this.setAllLocationsIfNull(0,l),this.setAllLocationsIfNull(1,l)}else 2===arguments.length&&this.elt[arguments[0]].setAllLocationsIfNull(arguments[1])},We.prototype.isLine=function(l){return this.elt[l].isLine()},We.prototype.merge=function(l){for(var h=0;h<2;h++)null===this.elt[h]&&null!==l.elt[h]?this.elt[h]=new Ur(l.elt[h]):this.elt[h].merge(l.elt[h])},We.prototype.flip=function(){this.elt[0].flip(),this.elt[1].flip()},We.prototype.getLocation=function(){return 1===arguments.length?this.elt[arguments[0]].get(an.ON):2===arguments.length?this.elt[arguments[0]].get(arguments[1]):void 0},We.prototype.toString=function(){var l=new vt;return null!==this.elt[0]&&(l.append("A:"),l.append(this.elt[0].toString())),null!==this.elt[1]&&(l.append(" B:"),l.append(this.elt[1].toString())),l.toString()},We.prototype.isArea=function(){return 0===arguments.length?this.elt[0].isArea()||this.elt[1].isArea():1===arguments.length?this.elt[arguments[0]].isArea():void 0},We.prototype.isAnyNull=function(l){return this.elt[l].isAnyNull()},We.prototype.setLocation=function(){2===arguments.length?this.elt[arguments[0]].setLocation(an.ON,arguments[1]):3===arguments.length&&this.elt[arguments[0]].setLocation(arguments[1],arguments[2])},We.prototype.isEqualOnSide=function(l,h){return this.elt[0].isEqualOnSide(l.elt[0],h)&&this.elt[1].isEqualOnSide(l.elt[1],h)},We.prototype.allPositionsEqual=function(l,h){return this.elt[l].allPositionsEqual(h)},We.prototype.toLine=function(l){this.elt[l].isArea()&&(this.elt[l]=new Ur(this.elt[l].location[0]))},We.prototype.interfaces_=function(){return[]},We.prototype.getClass=function(){return We},We.toLineLabel=function(l){for(var h=new We(nt.NONE),m=0;m<2;m++)h.setLocation(m,l.getLocation(m));return h};var Kr=function(){this._startDe=null,this._maxNodeDegree=-1,this._edges=new ue,this._pts=new ue,this._label=new We(nt.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new ue,this._geometryFactory=null;var l=arguments[0];this._geometryFactory=arguments[1],this.computePoints(l),this.computeRing()};Kr.prototype.computeRing=function(){if(null!==this._ring)return null;for(var l=new Array(this._pts.size()).fill(null),h=0;h<this._pts.size();h++)l[h]=this._pts.get(h);this._ring=this._geometryFactory.createLinearRing(l),this._isHole=yn.isCCW(this._ring.getCoordinates())},Kr.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},Kr.prototype.computePoints=function(l){this._startDe=l;var h=l,m=!0;do{if(null===h)throw new Ss("Found null DirectedEdge");if(h.getEdgeRing()===this)throw new Ss("Directed Edge visited twice during ring-building at "+h.getCoordinate());this._edges.add(h);var _=h.getLabel();Nn.isTrue(_.isArea()),this.mergeLabel(_),this.addPoints(h.getEdge(),h.isForward(),m),m=!1,this.setEdgeRing(h,this),h=this.getNext(h)}while(h!==this._startDe)},Kr.prototype.getLinearRing=function(){return this._ring},Kr.prototype.getCoordinate=function(l){return this._pts.get(l)},Kr.prototype.computeMaxNodeDegree=function(){this._maxNodeDegree=0;var l=this._startDe;do{var h=l.getNode().getEdges().getOutgoingDegree(this);h>this._maxNodeDegree&&(this._maxNodeDegree=h),l=this.getNext(l)}while(l!==this._startDe);this._maxNodeDegree*=2},Kr.prototype.addPoints=function(l,h,m){var _=l.getCoordinates();if(h){var C=1;m&&(C=0);for(var F=C;F<_.length;F++)this._pts.add(_[F])}else{var rt=_.length-2;m&&(rt=_.length-1);for(var Dt=rt;Dt>=0;Dt--)this._pts.add(_[Dt])}},Kr.prototype.isHole=function(){return this._isHole},Kr.prototype.setInResult=function(){var l=this._startDe;do{l.getEdge().setInResult(!0),l=l.getNext()}while(l!==this._startDe)},Kr.prototype.containsPoint=function(l){var h=this.getLinearRing();if(!h.getEnvelopeInternal().contains(l)||!yn.isPointInRing(l,h.getCoordinates()))return!1;for(var m=this._holes.iterator();m.hasNext();)if(m.next().containsPoint(l))return!1;return!0},Kr.prototype.addHole=function(l){this._holes.add(l)},Kr.prototype.isShell=function(){return null===this._shell},Kr.prototype.getLabel=function(){return this._label},Kr.prototype.getEdges=function(){return this._edges},Kr.prototype.getMaxNodeDegree=function(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree},Kr.prototype.getShell=function(){return this._shell},Kr.prototype.mergeLabel=function(){if(1===arguments.length){var l=arguments[0];this.mergeLabel(l,0),this.mergeLabel(l,1)}else if(2===arguments.length){var m=arguments[1],_=arguments[0].getLocation(m,an.RIGHT);if(_===nt.NONE)return null;if(this._label.getLocation(m)===nt.NONE)return this._label.setLocation(m,_),null}},Kr.prototype.setShell=function(l){this._shell=l,null!==l&&l.addHole(this)},Kr.prototype.toPolygon=function(l){for(var h=new Array(this._holes.size()).fill(null),m=0;m<this._holes.size();m++)h[m]=this._holes.get(m).getLinearRing();return l.createPolygon(this.getLinearRing(),h)},Kr.prototype.interfaces_=function(){return[]},Kr.prototype.getClass=function(){return Kr};var mr=function(l){function h(){l.call(this,arguments[0],arguments[1])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.setEdgeRing=function(m,_){m.setMinEdgeRing(_)},h.prototype.getNext=function(m){return m.getNextMin()},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Kr),ai=function(l){function h(){l.call(this,arguments[0],arguments[1])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.buildMinimalRings=function(){var m=new ue,_=this._startDe;do{if(null===_.getMinEdgeRing()){var C=new mr(_,this._geometryFactory);m.add(C)}_=_.getNext()}while(_!==this._startDe);return m},h.prototype.setEdgeRing=function(m,_){m.setEdgeRing(_)},h.prototype.linkDirectedEdgesForMinimalEdgeRings=function(){var m=this._startDe;do{m.getNode().getEdges().linkMinimalDirectedEdges(this),m=m.getNext()}while(m!==this._startDe)},h.prototype.getNext=function(m){return m.getNext()},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Kr),Kn=function(){this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0!==arguments.length&&1===arguments.length&&(this._label=arguments[0])};Kn.prototype.setVisited=function(l){this._isVisited=l},Kn.prototype.setInResult=function(l){this._isInResult=l},Kn.prototype.isCovered=function(){return this._isCovered},Kn.prototype.isCoveredSet=function(){return this._isCoveredSet},Kn.prototype.setLabel=function(l){this._label=l},Kn.prototype.getLabel=function(){return this._label},Kn.prototype.setCovered=function(l){this._isCovered=l,this._isCoveredSet=!0},Kn.prototype.updateIM=function(l){Nn.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(l)},Kn.prototype.isInResult=function(){return this._isInResult},Kn.prototype.isVisited=function(){return this._isVisited},Kn.prototype.interfaces_=function(){return[]},Kn.prototype.getClass=function(){return Kn};var Pr=function(l){function h(){l.call(this),this._coord=null,this._edges=null;var _=arguments[1];this._coord=arguments[0],this._edges=_,this._label=new We(0,nt.NONE)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.isIncidentEdgeInResult=function(){for(var m=this.getEdges().getEdges().iterator();m.hasNext();)if(m.next().getEdge().isInResult())return!0;return!1},h.prototype.isIsolated=function(){return 1===this._label.getGeometryCount()},h.prototype.getCoordinate=function(){return this._coord},h.prototype.print=function(m){m.println("node "+this._coord+" lbl: "+this._label)},h.prototype.computeIM=function(m){},h.prototype.computeMergedLocation=function(m,_){var C=nt.NONE;if(C=this._label.getLocation(_),!m.isNull(_)){var F=m.getLocation(_);C!==nt.BOUNDARY&&(C=F)}return C},h.prototype.setLabel=function(){if(2!==arguments.length)return l.prototype.setLabel.apply(this,arguments);var m=arguments[0],_=arguments[1];null===this._label?this._label=new We(m,_):this._label.setLocation(m,_)},h.prototype.getEdges=function(){return this._edges},h.prototype.mergeLabel=function(){if(arguments[0]instanceof h)this.mergeLabel(arguments[0]._label);else if(arguments[0]instanceof We)for(var _=arguments[0],C=0;C<2;C++){var F=this.computeMergedLocation(_,C);this._label.getLocation(C)===nt.NONE&&this._label.setLocation(C,F)}},h.prototype.add=function(m){this._edges.insert(m),m.setNode(this)},h.prototype.setLabelBoundary=function(m){if(null===this._label)return null;var _=nt.NONE;null!==this._label&&(_=this._label.getLocation(m)),this._label.setLocation(m,_===nt.BOUNDARY?nt.INTERIOR:nt.BOUNDARY)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Kn),wr=function(){this.nodeMap=new Z,this.nodeFact=null,this.nodeFact=arguments[0]};wr.prototype.find=function(l){return this.nodeMap.get(l)},wr.prototype.addNode=function(){if(arguments[0]instanceof B){var l=arguments[0],h=this.nodeMap.get(l);return null===h&&(h=this.nodeFact.createNode(l),this.nodeMap.put(l,h)),h}if(arguments[0]instanceof Pr){var m=arguments[0],_=this.nodeMap.get(m.getCoordinate());return null===_?(this.nodeMap.put(m.getCoordinate(),m),m):(_.mergeLabel(m),_)}},wr.prototype.print=function(l){for(var h=this.iterator();h.hasNext();)h.next().print(l)},wr.prototype.iterator=function(){return this.nodeMap.values().iterator()},wr.prototype.values=function(){return this.nodeMap.values()},wr.prototype.getBoundaryNodes=function(l){for(var h=new ue,m=this.iterator();m.hasNext();){var _=m.next();_.getLabel().getLocation(l)===nt.BOUNDARY&&h.add(_)}return h},wr.prototype.add=function(l){var h=l.getCoordinate();this.addNode(h).add(l)},wr.prototype.interfaces_=function(){return[]},wr.prototype.getClass=function(){return wr};var Wr=function(){},Ds={NE:{configurable:!0},NW:{configurable:!0},SW:{configurable:!0},SE:{configurable:!0}};Wr.prototype.interfaces_=function(){return[]},Wr.prototype.getClass=function(){return Wr},Wr.isNorthern=function(l){return l===Wr.NE||l===Wr.NW},Wr.isOpposite=function(l,h){return l!==h&&(l-h+4)%4==2},Wr.commonHalfPlane=function(l,h){if(l===h)return l;if((l-h+4)%4==2)return-1;var m=l<h?l:h;return 0===m&&3===(l>h?l:h)?3:m},Wr.isInHalfPlane=function(l,h){return h===Wr.SE?l===Wr.SE||l===Wr.SW:l===h||l===h+1},Wr.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var l=arguments[0],h=arguments[1];if(0===l&&0===h)throw new dt("Cannot compute the quadrant for point ( "+l+", "+h+" )");return l>=0?h>=0?Wr.NE:Wr.SE:h>=0?Wr.NW:Wr.SW}if(arguments[0]instanceof B&&arguments[1]instanceof B){var m=arguments[0],_=arguments[1];if(_.x===m.x&&_.y===m.y)throw new dt("Cannot compute the quadrant for two identical points "+m);return _.x>=m.x?_.y>=m.y?Wr.NE:Wr.SE:_.y>=m.y?Wr.NW:Wr.SW}},Ds.NE.get=function(){return 0},Ds.NW.get=function(){return 1},Ds.SW.get=function(){return 2},Ds.SE.get=function(){return 3},Object.defineProperties(Wr,Ds);var ss=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length)this._edge=arguments[0];else if(3===arguments.length){var m=arguments[1],_=arguments[2];this._edge=arguments[0],this.init(m,_),this._label=null}else if(4===arguments.length){var F=arguments[1],rt=arguments[2],Dt=arguments[3];this._edge=arguments[0],this.init(F,rt),this._label=Dt}};ss.prototype.compareDirection=function(l){return this._dx===l._dx&&this._dy===l._dy?0:this._quadrant>l._quadrant?1:this._quadrant<l._quadrant?-1:yn.computeOrientation(l._p0,l._p1,this._p1)},ss.prototype.getDy=function(){return this._dy},ss.prototype.getCoordinate=function(){return this._p0},ss.prototype.setNode=function(l){this._node=l},ss.prototype.print=function(l){var h=Math.atan2(this._dy,this._dx),m=this.getClass().getName(),_=m.lastIndexOf("."),C=m.substring(_+1);l.print("  "+C+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+h+"   "+this._label)},ss.prototype.compareTo=function(l){return this.compareDirection(l)},ss.prototype.getDirectedCoordinate=function(){return this._p1},ss.prototype.getDx=function(){return this._dx},ss.prototype.getLabel=function(){return this._label},ss.prototype.getEdge=function(){return this._edge},ss.prototype.getQuadrant=function(){return this._quadrant},ss.prototype.getNode=function(){return this._node},ss.prototype.toString=function(){var l=Math.atan2(this._dy,this._dx),h=this.getClass().getName(),m=h.lastIndexOf(".");return"  "+h.substring(m+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+l+"   "+this._label},ss.prototype.computeLabel=function(l){},ss.prototype.init=function(l,h){this._p0=l,this._p1=h,this._dx=h.x-l.x,this._dy=h.y-l.y,this._quadrant=Wr.quadrant(this._dx,this._dy),Nn.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")},ss.prototype.interfaces_=function(){return[q]},ss.prototype.getClass=function(){return ss};var wu=function(l){function h(){var m=arguments[0],_=arguments[1];if(l.call(this,m),this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999],this._isForward=_,_)this.init(m.getCoordinate(0),m.getCoordinate(1));else{var C=m.getNumPoints()-1;this.init(m.getCoordinate(C),m.getCoordinate(C-1))}this.computeDirectedLabel()}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.getNextMin=function(){return this._nextMin},h.prototype.getDepth=function(m){return this._depth[m]},h.prototype.setVisited=function(m){this._isVisited=m},h.prototype.computeDirectedLabel=function(){this._label=new We(this._edge.getLabel()),this._isForward||this._label.flip()},h.prototype.getNext=function(){return this._next},h.prototype.setDepth=function(m,_){if(-999!==this._depth[m]&&this._depth[m]!==_)throw new Ss("assigned depths do not match",this.getCoordinate());this._depth[m]=_},h.prototype.isInteriorAreaEdge=function(){for(var m=!0,_=0;_<2;_++)this._label.isArea(_)&&this._label.getLocation(_,an.LEFT)===nt.INTERIOR&&this._label.getLocation(_,an.RIGHT)===nt.INTERIOR||(m=!1);return m},h.prototype.setNextMin=function(m){this._nextMin=m},h.prototype.print=function(m){l.prototype.print.call(this,m),m.print(" "+this._depth[an.LEFT]+"/"+this._depth[an.RIGHT]),m.print(" ("+this.getDepthDelta()+")"),this._isInResult&&m.print(" inResult")},h.prototype.setMinEdgeRing=function(m){this._minEdgeRing=m},h.prototype.isLineEdge=function(){var m=this._label.isLine(0)||this._label.isLine(1),_=!this._label.isArea(0)||this._label.allPositionsEqual(0,nt.EXTERIOR),C=!this._label.isArea(1)||this._label.allPositionsEqual(1,nt.EXTERIOR);return m&&_&&C},h.prototype.setEdgeRing=function(m){this._edgeRing=m},h.prototype.getMinEdgeRing=function(){return this._minEdgeRing},h.prototype.getDepthDelta=function(){var m=this._edge.getDepthDelta();return this._isForward||(m=-m),m},h.prototype.setInResult=function(m){this._isInResult=m},h.prototype.getSym=function(){return this._sym},h.prototype.isForward=function(){return this._isForward},h.prototype.getEdge=function(){return this._edge},h.prototype.printEdge=function(m){this.print(m),m.print(" "),this._isForward?this._edge.print(m):this._edge.printReverse(m)},h.prototype.setSym=function(m){this._sym=m},h.prototype.setVisitedEdge=function(m){this.setVisited(m),this._sym.setVisited(m)},h.prototype.setEdgeDepths=function(m,_){var C=this.getEdge().getDepthDelta();this._isForward||(C=-C);var F=1;m===an.LEFT&&(F=-1);var rt=an.opposite(m),Dt=_+C*F;this.setDepth(m,_),this.setDepth(rt,Dt)},h.prototype.getEdgeRing=function(){return this._edgeRing},h.prototype.isInResult=function(){return this._isInResult},h.prototype.setNext=function(m){this._next=m},h.prototype.isVisited=function(){return this._isVisited},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.depthFactor=function(m,_){return m===nt.EXTERIOR&&_===nt.INTERIOR?1:m===nt.INTERIOR&&_===nt.EXTERIOR?-1:0},h}(ss),Fo=function(){};Fo.prototype.createNode=function(l){return new Pr(l,null)},Fo.prototype.interfaces_=function(){return[]},Fo.prototype.getClass=function(){return Fo};var Or=function(){this._edges=new ue,this._nodes=null,this._edgeEndList=new ue,0===arguments.length?this._nodes=new wr(new Fo):1===arguments.length&&(this._nodes=new wr(arguments[0]))};Or.prototype.printEdges=function(l){l.println("Edges:");for(var h=0;h<this._edges.size();h++){l.println("edge "+h+":");var m=this._edges.get(h);m.print(l),m.eiList.print(l)}},Or.prototype.find=function(l){return this._nodes.find(l)},Or.prototype.addNode=function(){return arguments[0]instanceof Pr||arguments[0]instanceof B?this._nodes.addNode(arguments[0]):void 0},Or.prototype.getNodeIterator=function(){return this._nodes.iterator()},Or.prototype.linkResultDirectedEdges=function(){for(var l=this._nodes.iterator();l.hasNext();)l.next().getEdges().linkResultDirectedEdges()},Or.prototype.debugPrintln=function(l){Xe.out.println(l)},Or.prototype.isBoundaryNode=function(l,h){var m=this._nodes.find(h);if(null===m)return!1;var _=m.getLabel();return null!==_&&_.getLocation(l)===nt.BOUNDARY},Or.prototype.linkAllDirectedEdges=function(){for(var l=this._nodes.iterator();l.hasNext();)l.next().getEdges().linkAllDirectedEdges()},Or.prototype.matchInSameDirection=function(l,h,m,_){return!!l.equals(m)&&yn.computeOrientation(l,h,_)===yn.COLLINEAR&&Wr.quadrant(l,h)===Wr.quadrant(m,_)},Or.prototype.getEdgeEnds=function(){return this._edgeEndList},Or.prototype.debugPrint=function(l){Xe.out.print(l)},Or.prototype.getEdgeIterator=function(){return this._edges.iterator()},Or.prototype.findEdgeInSameDirection=function(l,h){for(var m=0;m<this._edges.size();m++){var _=this._edges.get(m),C=_.getCoordinates();if(this.matchInSameDirection(l,h,C[0],C[1])||this.matchInSameDirection(l,h,C[C.length-1],C[C.length-2]))return _}return null},Or.prototype.insertEdge=function(l){this._edges.add(l)},Or.prototype.findEdgeEnd=function(l){for(var h=this.getEdgeEnds().iterator();h.hasNext();){var m=h.next();if(m.getEdge()===l)return m}return null},Or.prototype.addEdges=function(l){for(var h=l.iterator();h.hasNext();){var m=h.next();this._edges.add(m);var _=new wu(m,!0),C=new wu(m,!1);_.setSym(C),C.setSym(_),this.add(_),this.add(C)}},Or.prototype.add=function(l){this._nodes.add(l),this._edgeEndList.add(l)},Or.prototype.getNodes=function(){return this._nodes.values()},Or.prototype.findEdge=function(l,h){for(var m=0;m<this._edges.size();m++){var _=this._edges.get(m),C=_.getCoordinates();if(l.equals(C[0])&&h.equals(C[1]))return _}return null},Or.prototype.interfaces_=function(){return[]},Or.prototype.getClass=function(){return Or},Or.linkResultDirectedEdges=function(l){for(var h=l.iterator();h.hasNext();)h.next().getEdges().linkResultDirectedEdges()};var os=function(){this._geometryFactory=null,this._shellList=new ue,this._geometryFactory=arguments[0]};os.prototype.sortShellsAndHoles=function(l,h,m){for(var _=l.iterator();_.hasNext();){var C=_.next();C.isHole()?m.add(C):h.add(C)}},os.prototype.computePolygons=function(l){for(var h=new ue,m=l.iterator();m.hasNext();){var _=m.next().toPolygon(this._geometryFactory);h.add(_)}return h},os.prototype.placeFreeHoles=function(l,h){for(var m=h.iterator();m.hasNext();){var _=m.next();if(null===_.getShell()){var C=this.findEdgeRingContaining(_,l);if(null===C)throw new Ss("unable to assign hole to a shell",_.getCoordinate(0));_.setShell(C)}}},os.prototype.buildMinimalEdgeRings=function(l,h,m){for(var _=new ue,C=l.iterator();C.hasNext();){var F=C.next();if(F.getMaxNodeDegree()>2){F.linkDirectedEdgesForMinimalEdgeRings();var rt=F.buildMinimalRings(),Dt=this.findShell(rt);null!==Dt?(this.placePolygonHoles(Dt,rt),h.add(Dt)):m.addAll(rt)}else _.add(F)}return _},os.prototype.containsPoint=function(l){for(var h=this._shellList.iterator();h.hasNext();)if(h.next().containsPoint(l))return!0;return!1},os.prototype.buildMaximalEdgeRings=function(l){for(var h=new ue,m=l.iterator();m.hasNext();){var _=m.next();if(_.isInResult()&&_.getLabel().isArea()&&null===_.getEdgeRing()){var C=new ai(_,this._geometryFactory);h.add(C),C.setInResult()}}return h},os.prototype.placePolygonHoles=function(l,h){for(var m=h.iterator();m.hasNext();){var _=m.next();_.isHole()&&_.setShell(l)}},os.prototype.getPolygons=function(){return this.computePolygons(this._shellList)},os.prototype.findEdgeRingContaining=function(l,h){for(var m=l.getLinearRing(),_=m.getEnvelopeInternal(),C=m.getCoordinateN(0),F=null,rt=null,Dt=h.iterator();Dt.hasNext();){var qt=Dt.next(),fe=qt.getLinearRing(),ke=fe.getEnvelopeInternal();null!==F&&(rt=F.getLinearRing().getEnvelopeInternal());var Ge=!1;ke.contains(_)&&yn.isPointInRing(C,fe.getCoordinates())&&(Ge=!0),Ge&&(null===F||rt.contains(ke))&&(F=qt)}return F},os.prototype.findShell=function(l){for(var h=0,m=null,_=l.iterator();_.hasNext();){var C=_.next();C.isHole()||(m=C,h++)}return Nn.isTrue(h<=1,"found two shells in MinimalEdgeRing list"),m},os.prototype.add=function(){if(1===arguments.length){var l=arguments[0];this.add(l.getEdgeEnds(),l.getNodes())}else if(2===arguments.length){var h=arguments[0];Or.linkResultDirectedEdges(arguments[1]);var _=this.buildMaximalEdgeRings(h),C=new ue,F=this.buildMinimalEdgeRings(_,this._shellList,C);this.sortShellsAndHoles(F,this._shellList,C),this.placeFreeHoles(this._shellList,C)}},os.prototype.interfaces_=function(){return[]},os.prototype.getClass=function(){return os};var _e=function(){};_e.prototype.getBounds=function(){},_e.prototype.interfaces_=function(){return[]},_e.prototype.getClass=function(){return _e};var z=function(){this._bounds=null,this._item=null;var h=arguments[1];this._bounds=arguments[0],this._item=h};z.prototype.getItem=function(){return this._item},z.prototype.getBounds=function(){return this._bounds},z.prototype.interfaces_=function(){return[_e,$]},z.prototype.getClass=function(){return z};var I=function(){this._size=null,this._items=null,this._size=0,this._items=new ue,this._items.add(null)};I.prototype.poll=function(){if(this.isEmpty())return null;var l=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),l},I.prototype.size=function(){return this._size},I.prototype.reorder=function(l){for(var h=null,m=this._items.get(l);2*l<=this._size&&((h=2*l)!==this._size&&this._items.get(h+1).compareTo(this._items.get(h))<0&&h++,this._items.get(h).compareTo(m)<0);l=h)this._items.set(l,this._items.get(h));this._items.set(l,m)},I.prototype.clear=function(){this._size=0,this._items.clear()},I.prototype.isEmpty=function(){return 0===this._size},I.prototype.add=function(l){this._items.add(null),this._size+=1;var h=this._size;for(this._items.set(0,l);l.compareTo(this._items.get(Math.trunc(h/2)))<0;h/=2)this._items.set(h,this._items.get(Math.trunc(h/2)));this._items.set(h,l)},I.prototype.interfaces_=function(){return[]},I.prototype.getClass=function(){return I};var M=function(){};M.prototype.visitItem=function(l){},M.prototype.interfaces_=function(){return[]},M.prototype.getClass=function(){return M};var tt=function(){};tt.prototype.insert=function(l,h){},tt.prototype.remove=function(l,h){},tt.prototype.query=function(){},tt.prototype.interfaces_=function(){return[]},tt.prototype.getClass=function(){return tt};var bt=function(){this._childBoundables=new ue,this._bounds=null,this._level=null,0!==arguments.length&&1===arguments.length&&(this._level=arguments[0])},At={serialVersionUID:{configurable:!0}};bt.prototype.getLevel=function(){return this._level},bt.prototype.size=function(){return this._childBoundables.size()},bt.prototype.getChildBoundables=function(){return this._childBoundables},bt.prototype.addChildBoundable=function(l){Nn.isTrue(null===this._bounds),this._childBoundables.add(l)},bt.prototype.isEmpty=function(){return this._childBoundables.isEmpty()},bt.prototype.getBounds=function(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds},bt.prototype.interfaces_=function(){return[_e,$]},bt.prototype.getClass=function(){return bt},At.serialVersionUID.get=function(){return 0x5a1e55ec41369800},Object.defineProperties(bt,At);var Yt=function(){};Yt.reverseOrder=function(){return{compare:function(l,h){return h.compareTo(l)}}},Yt.min=function(l){return Yt.sort(l),l.get(0)},Yt.sort=function(l,h){var m=l.toArray();h?kr.sort(m,h):kr.sort(m);for(var _=l.iterator(),C=0,F=m.length;C<F;C++)_.next(),_.set(m[C])},Yt.singletonList=function(l){var h=new ue;return h.add(l),h};var kt=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;var h=arguments[1],m=arguments[2];this._boundable1=arguments[0],this._boundable2=h,this._itemDistance=m,this._distance=this.distance()};kt.prototype.expandToQueue=function(l,h){var m=kt.isComposite(this._boundable1),_=kt.isComposite(this._boundable2);if(m&&_)return kt.area(this._boundable1)>kt.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,l,h),null):(this.expand(this._boundable2,this._boundable1,l,h),null);if(m)return this.expand(this._boundable1,this._boundable2,l,h),null;if(_)return this.expand(this._boundable2,this._boundable1,l,h),null;throw new dt("neither boundable is composite")},kt.prototype.isLeaves=function(){return!(kt.isComposite(this._boundable1)||kt.isComposite(this._boundable2))},kt.prototype.compareTo=function(l){return this._distance<l._distance?-1:this._distance>l._distance?1:0},kt.prototype.expand=function(l,h,m,_){for(var C=l.getChildBoundables().iterator();C.hasNext();){var F=C.next(),rt=new kt(F,h,this._itemDistance);rt.getDistance()<_&&m.add(rt)}},kt.prototype.getBoundable=function(l){return 0===l?this._boundable1:this._boundable2},kt.prototype.getDistance=function(){return this._distance},kt.prototype.distance=function(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())},kt.prototype.interfaces_=function(){return[q]},kt.prototype.getClass=function(){return kt},kt.area=function(l){return l.getBounds().getArea()},kt.isComposite=function(l){return l instanceof bt};var ae=function l(){if(this._root=null,this._built=!1,this._itemBoundables=new ue,this._nodeCapacity=null,0===arguments.length)this._nodeCapacity=l.DEFAULT_NODE_CAPACITY;else if(1===arguments.length){var m=arguments[0];Nn.isTrue(m>1,"Node capacity must be greater than 1"),this._nodeCapacity=m}},nn={IntersectsOp:{configurable:!0},serialVersionUID:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};ae.prototype.getNodeCapacity=function(){return this._nodeCapacity},ae.prototype.lastNode=function(l){return l.get(l.size()-1)},ae.prototype.size=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){for(var l=0,h=arguments[0].getChildBoundables().iterator();h.hasNext();){var m=h.next();m instanceof bt?l+=this.size(m):m instanceof z&&(l+=1)}return l}},ae.prototype.removeItem=function(l,h){for(var m=null,_=l.getChildBoundables().iterator();_.hasNext();){var C=_.next();C instanceof z&&C.getItem()===h&&(m=C)}return null!==m&&(l.getChildBoundables().remove(m),!0)},ae.prototype.itemsTree=function(){if(0===arguments.length){this.build();var l=this.itemsTree(this._root);return null===l?new ue:l}if(1===arguments.length){for(var h=arguments[0],m=new ue,_=h.getChildBoundables().iterator();_.hasNext();){var C=_.next();if(C instanceof bt){var F=this.itemsTree(C);null!==F&&m.add(F)}else C instanceof z?m.add(C.getItem()):Nn.shouldNeverReachHere()}return m.size()<=0?null:m}},ae.prototype.insert=function(l,h){Nn.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new z(l,h))},ae.prototype.boundablesAtLevel=function(){if(1===arguments.length){var l=arguments[0],h=new ue;return this.boundablesAtLevel(l,this._root,h),h}if(3===arguments.length){var m=arguments[0],_=arguments[1],C=arguments[2];if(Nn.isTrue(m>-2),_.getLevel()===m)return C.add(_),null;for(var F=_.getChildBoundables().iterator();F.hasNext();){var rt=F.next();rt instanceof bt?this.boundablesAtLevel(m,rt,C):(Nn.isTrue(rt instanceof z),-1===m&&C.add(rt))}return null}},ae.prototype.query=function(){if(1===arguments.length){var l=arguments[0];this.build();var h=new ue;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),l)&&this.query(l,this._root,h),h}if(2===arguments.length){var m=arguments[0],_=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),m)&&this.query(m,this._root,_)}else if(3===arguments.length)if(O(arguments[2],M)&&arguments[0]instanceof Object&&arguments[1]instanceof bt)for(var C=arguments[0],rt=arguments[2],Dt=arguments[1].getChildBoundables(),qt=0;qt<Dt.size();qt++){var fe=Dt.get(qt);this.getIntersectsOp().intersects(fe.getBounds(),C)&&(fe instanceof bt?this.query(C,fe,rt):fe instanceof z?rt.visitItem(fe.getItem()):Nn.shouldNeverReachHere())}else if(O(arguments[2],En)&&arguments[0]instanceof Object&&arguments[1]instanceof bt)for(var ke=arguments[0],xn=arguments[2],Sn=arguments[1].getChildBoundables(),Un=0;Un<Sn.size();Un++){var ur=Sn.get(Un);this.getIntersectsOp().intersects(ur.getBounds(),ke)&&(ur instanceof bt?this.query(ke,ur,xn):ur instanceof z?xn.add(ur.getItem()):Nn.shouldNeverReachHere())}},ae.prototype.build=function(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0},ae.prototype.getRoot=function(){return this.build(),this._root},ae.prototype.remove=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),l)&&this.remove(l,this._root,h)}if(3===arguments.length){var m=arguments[0],_=arguments[1],C=arguments[2],F=this.removeItem(_,C);if(F)return!0;for(var rt=null,Dt=_.getChildBoundables().iterator();Dt.hasNext();){var qt=Dt.next();if(this.getIntersectsOp().intersects(qt.getBounds(),m)&&qt instanceof bt&&(F=this.remove(m,qt,C))){rt=qt;break}}return null!==rt&&rt.getChildBoundables().isEmpty()&&_.getChildBoundables().remove(rt),F}},ae.prototype.createHigherLevels=function(l,h){Nn.isTrue(!l.isEmpty());var m=this.createParentBoundables(l,h+1);return 1===m.size()?m.get(0):this.createHigherLevels(m,h+1)},ae.prototype.depth=function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){for(var l=0,h=arguments[0].getChildBoundables().iterator();h.hasNext();){var m=h.next();if(m instanceof bt){var _=this.depth(m);_>l&&(l=_)}}return l+1}},ae.prototype.createParentBoundables=function(l,h){Nn.isTrue(!l.isEmpty());var m=new ue;m.add(this.createNode(h));var _=new ue(l);Yt.sort(_,this.getComparator());for(var C=_.iterator();C.hasNext();){var F=C.next();this.lastNode(m).getChildBoundables().size()===this.getNodeCapacity()&&m.add(this.createNode(h)),this.lastNode(m).addChildBoundable(F)}return m},ae.prototype.isEmpty=function(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()},ae.prototype.interfaces_=function(){return[$]},ae.prototype.getClass=function(){return ae},ae.compareDoubles=function(l,h){return l>h?1:l<h?-1:0},nn.IntersectsOp.get=function(){return Ye},nn.serialVersionUID.get=function(){return-0x35ef64c82d4c5400},nn.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(ae,nn);var Ye=function(){},$e=function(){};$e.prototype.distance=function(l,h){},$e.prototype.interfaces_=function(){return[]},$e.prototype.getClass=function(){return $e};var Cn=function(l){function h(_){l.call(this,_=_||h.DEFAULT_NODE_CAPACITY)}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={STRtreeNode:{configurable:!0},serialVersionUID:{configurable:!0},xComparator:{configurable:!0},yComparator:{configurable:!0},intersectsOp:{configurable:!0},DEFAULT_NODE_CAPACITY:{configurable:!0}};return h.prototype.createParentBoundablesFromVerticalSlices=function(_,C){Nn.isTrue(_.length>0);for(var F=new ue,rt=0;rt<_.length;rt++)F.addAll(this.createParentBoundablesFromVerticalSlice(_[rt],C));return F},h.prototype.createNode=function(_){return new $n(_)},h.prototype.size=function(){return 0===arguments.length?l.prototype.size.call(this):l.prototype.size.apply(this,arguments)},h.prototype.insert=function(){if(2!==arguments.length)return l.prototype.insert.apply(this,arguments);var _=arguments[0],C=arguments[1];if(_.isNull())return null;l.prototype.insert.call(this,_,C)},h.prototype.getIntersectsOp=function(){return h.intersectsOp},h.prototype.verticalSlices=function(_,C){for(var F=Math.trunc(Math.ceil(_.size()/C)),rt=new Array(C).fill(null),Dt=_.iterator(),qt=0;qt<C;qt++){rt[qt]=new ue;for(var fe=0;Dt.hasNext()&&fe<F;){var ke=Dt.next();rt[qt].add(ke),fe++}}return rt},h.prototype.query=function(){if(1===arguments.length)return l.prototype.query.call(this,arguments[0]);2===arguments.length?l.prototype.query.call(this,arguments[0],arguments[1]):3===arguments.length&&(O(arguments[2],M)&&arguments[0]instanceof Object&&arguments[1]instanceof bt||O(arguments[2],En)&&arguments[0]instanceof Object&&arguments[1]instanceof bt)&&l.prototype.query.call(this,arguments[0],arguments[1],arguments[2])},h.prototype.getComparator=function(){return h.yComparator},h.prototype.createParentBoundablesFromVerticalSlice=function(_,C){return l.prototype.createParentBoundables.call(this,_,C)},h.prototype.remove=function(){return 2===arguments.length?l.prototype.remove.call(this,arguments[0],arguments[1]):l.prototype.remove.apply(this,arguments)},h.prototype.depth=function(){return 0===arguments.length?l.prototype.depth.call(this):l.prototype.depth.apply(this,arguments)},h.prototype.createParentBoundables=function(_,C){Nn.isTrue(!_.isEmpty());var F=Math.trunc(Math.ceil(_.size()/this.getNodeCapacity())),rt=new ue(_);Yt.sort(rt,h.xComparator);var Dt=this.verticalSlices(rt,Math.trunc(Math.ceil(Math.sqrt(F))));return this.createParentBoundablesFromVerticalSlices(Dt,C)},h.prototype.nearestNeighbour=function(){if(1===arguments.length){if(O(arguments[0],$e)){var _=arguments[0],C=new kt(this.getRoot(),this.getRoot(),_);return this.nearestNeighbour(C)}if(arguments[0]instanceof kt)return this.nearestNeighbour(arguments[0],lt.POSITIVE_INFINITY)}else if(2===arguments.length){if(arguments[0]instanceof h&&O(arguments[1],$e)){var rt=arguments[0],Dt=arguments[1],qt=new kt(this.getRoot(),rt.getRoot(),Dt);return this.nearestNeighbour(qt)}if(arguments[0]instanceof kt&&"number"==typeof arguments[1]){var fe=arguments[0],ke=arguments[1],Ge=null,xn=new I;for(xn.add(fe);!xn.isEmpty()&&ke>0;){var Sn=xn.poll(),Un=Sn.getDistance();if(Un>=ke)break;Sn.isLeaves()?(ke=Un,Ge=Sn):Sn.expandToQueue(xn,ke)}return[Ge.getBoundable(0).getItem(),Ge.getBoundable(1).getItem()]}}else if(3===arguments.length){var Do=arguments[2],Fa=new z(arguments[0],arguments[1]),ml=new kt(this.getRoot(),Fa,Do);return this.nearestNeighbour(ml)[0]}},h.prototype.interfaces_=function(){return[tt,$]},h.prototype.getClass=function(){return h},h.centreX=function(_){return h.avg(_.getMinX(),_.getMaxX())},h.avg=function(_,C){return(_+C)/2},h.centreY=function(_){return h.avg(_.getMinY(),_.getMaxY())},m.STRtreeNode.get=function(){return $n},m.serialVersionUID.get=function(){return 0x39920f7d5f261e0},m.xComparator.get=function(){return{interfaces_:function(){return[pt]},compare:function(_,C){return l.compareDoubles(h.centreX(_.getBounds()),h.centreX(C.getBounds()))}}},m.yComparator.get=function(){return{interfaces_:function(){return[pt]},compare:function(_,C){return l.compareDoubles(h.centreY(_.getBounds()),h.centreY(C.getBounds()))}}},m.intersectsOp.get=function(){return{interfaces_:function(){return[l.IntersectsOp]},intersects:function(_,C){return _.intersects(C)}}},m.DEFAULT_NODE_CAPACITY.get=function(){return 10},Object.defineProperties(h,m),h}(ae),$n=function(l){function h(){l.call(this,arguments[0])}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.computeBounds=function(){for(var m=null,_=this.getChildBoundables().iterator();_.hasNext();){var C=_.next();null===m?m=new De(C.getBounds()):m.expandToInclude(C.getBounds())}return m},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(bt),Vn=function(){};Vn.prototype.interfaces_=function(){return[]},Vn.prototype.getClass=function(){return Vn},Vn.relativeSign=function(l,h){return l<h?-1:l>h?1:0},Vn.compare=function(l,h,m){if(h.equals2D(m))return 0;var _=Vn.relativeSign(h.x,m.x),C=Vn.relativeSign(h.y,m.y);switch(l){case 0:return Vn.compareValue(_,C);case 1:return Vn.compareValue(C,_);case 2:return Vn.compareValue(C,-_);case 3:return Vn.compareValue(-_,C);case 4:return Vn.compareValue(-_,-C);case 5:return Vn.compareValue(-C,-_);case 6:return Vn.compareValue(-C,_);case 7:return Vn.compareValue(_,-C)}return Nn.shouldNeverReachHere("invalid octant value"),0},Vn.compareValue=function(l,h){return l<0?-1:l>0?1:h<0?-1:h>0?1:0};var vr=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;var l=arguments[0],h=arguments[1],m=arguments[2],_=arguments[3];this._segString=l,this.coord=new B(h),this.segmentIndex=m,this._segmentOctant=_,this._isInterior=!h.equals2D(l.getCoordinate(m))};vr.prototype.getCoordinate=function(){return this.coord},vr.prototype.print=function(l){l.print(this.coord),l.print(" seg # = "+this.segmentIndex)},vr.prototype.compareTo=function(l){var h=l;return this.segmentIndex<h.segmentIndex?-1:this.segmentIndex>h.segmentIndex?1:this.coord.equals2D(h.coord)?0:Vn.compare(this._segmentOctant,this.coord,h.coord)},vr.prototype.isEndPoint=function(l){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===l},vr.prototype.isInterior=function(){return this._isInterior},vr.prototype.interfaces_=function(){return[q]},vr.prototype.getClass=function(){return vr};var bn=function(){this._nodeMap=new Z,this._edge=null,this._edge=arguments[0]};bn.prototype.getSplitCoordinates=function(){var l=new mn;this.addEndpoints();for(var h=this.iterator(),m=h.next();h.hasNext();){var _=h.next();this.addEdgeCoordinates(m,_,l),m=_}return l.toCoordinateArray()},bn.prototype.addCollapsedNodes=function(){var l=new ue;this.findCollapsesFromInsertedNodes(l),this.findCollapsesFromExistingVertices(l);for(var h=l.iterator();h.hasNext();){var m=h.next().intValue();this.add(this._edge.getCoordinate(m),m)}},bn.prototype.print=function(l){l.println("Intersections:");for(var h=this.iterator();h.hasNext();)h.next().print(l)},bn.prototype.findCollapsesFromExistingVertices=function(l){for(var h=0;h<this._edge.size()-2;h++){var m=this._edge.getCoordinate(h),_=this._edge.getCoordinate(h+2);m.equals2D(_)&&l.add(new xt(h+1))}},bn.prototype.addEdgeCoordinates=function(l,h,m){var _=this._edge.getCoordinate(h.segmentIndex),C=h.isInterior()||!h.coord.equals2D(_);m.add(new B(l.coord),!1);for(var F=l.segmentIndex+1;F<=h.segmentIndex;F++)m.add(this._edge.getCoordinate(F));C&&m.add(new B(h.coord))},bn.prototype.iterator=function(){return this._nodeMap.values().iterator()},bn.prototype.addSplitEdges=function(l){this.addEndpoints(),this.addCollapsedNodes();for(var h=this.iterator(),m=h.next();h.hasNext();){var _=h.next(),C=this.createSplitEdge(m,_);l.add(C),m=_}},bn.prototype.findCollapseIndex=function(l,h,m){if(!l.coord.equals2D(h.coord))return!1;var _=h.segmentIndex-l.segmentIndex;return h.isInterior()||_--,1===_&&(m[0]=l.segmentIndex+1,!0)},bn.prototype.findCollapsesFromInsertedNodes=function(l){for(var h=new Array(1).fill(null),m=this.iterator(),_=m.next();m.hasNext();){var C=m.next();this.findCollapseIndex(_,C,h)&&l.add(new xt(h[0])),_=C}},bn.prototype.getEdge=function(){return this._edge},bn.prototype.addEndpoints=function(){var l=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(l),l)},bn.prototype.createSplitEdge=function(l,h){var m=h.segmentIndex-l.segmentIndex+2,_=this._edge.getCoordinate(h.segmentIndex),C=h.isInterior()||!h.coord.equals2D(_);C||m--;var F=new Array(m).fill(null),rt=0;F[rt++]=new B(l.coord);for(var Dt=l.segmentIndex+1;Dt<=h.segmentIndex;Dt++)F[rt++]=this._edge.getCoordinate(Dt);return C&&(F[rt]=new B(h.coord)),new Xr(F,this._edge.getData())},bn.prototype.add=function(l,h){var m=new vr(this._edge,l,h,this._edge.getSegmentOctant(h)),_=this._nodeMap.get(m);return null!==_?(Nn.isTrue(_.coord.equals2D(l),"Found equal nodes with different coordinates"),_):(this._nodeMap.put(m,m),m)},bn.prototype.checkSplitEdgesCorrectness=function(l){var h=this._edge.getCoordinates(),m=l.get(0).getCoordinate(0);if(!m.equals2D(h[0]))throw new Wn("bad split edge start point at "+m);var _=l.get(l.size()-1).getCoordinates(),C=_[_.length-1];if(!C.equals2D(h[h.length-1]))throw new Wn("bad split edge end point at "+C)},bn.prototype.interfaces_=function(){return[]},bn.prototype.getClass=function(){return bn};var _r=function(){};_r.prototype.interfaces_=function(){return[]},_r.prototype.getClass=function(){return _r},_r.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var l=arguments[0],h=arguments[1];if(0===l&&0===h)throw new dt("Cannot compute the octant for point ( "+l+", "+h+" )");var m=Math.abs(l),_=Math.abs(h);return l>=0?h>=0?m>=_?0:1:m>=_?7:6:h>=0?m>=_?3:2:m>=_?4:5}if(arguments[0]instanceof B&&arguments[1]instanceof B){var C=arguments[0],F=arguments[1],rt=F.x-C.x,Dt=F.y-C.y;if(0===rt&&0===Dt)throw new dt("Cannot compute the octant for two identical points "+C);return _r.octant(rt,Dt)}};var ni=function(){};ni.prototype.getCoordinates=function(){},ni.prototype.size=function(){},ni.prototype.getCoordinate=function(l){},ni.prototype.isClosed=function(){},ni.prototype.setData=function(l){},ni.prototype.getData=function(){},ni.prototype.interfaces_=function(){return[]},ni.prototype.getClass=function(){return ni};var Zs=function(){};Zs.prototype.addIntersection=function(l,h){},Zs.prototype.interfaces_=function(){return[ni]},Zs.prototype.getClass=function(){return Zs};var Xr=function(){this._nodeList=new bn(this),this._pts=null,this._data=null;var h=arguments[1];this._pts=arguments[0],this._data=h};Xr.prototype.getCoordinates=function(){return this._pts},Xr.prototype.size=function(){return this._pts.length},Xr.prototype.getCoordinate=function(l){return this._pts[l]},Xr.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},Xr.prototype.getSegmentOctant=function(l){return l===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(l),this.getCoordinate(l+1))},Xr.prototype.setData=function(l){this._data=l},Xr.prototype.safeOctant=function(l,h){return l.equals2D(h)?0:_r.octant(l,h)},Xr.prototype.getData=function(){return this._data},Xr.prototype.addIntersection=function(){if(2===arguments.length)this.addIntersectionNode(arguments[0],arguments[1]);else if(4===arguments.length){var _=arguments[1],F=new B(arguments[0].getIntersection(arguments[3]));this.addIntersection(F,_)}},Xr.prototype.toString=function(){return Je.toLineString(new pr(this._pts))},Xr.prototype.getNodeList=function(){return this._nodeList},Xr.prototype.addIntersectionNode=function(l,h){var m=h,_=m+1;return _<this._pts.length&&l.equals2D(this._pts[_])&&(m=_),this._nodeList.add(l,m)},Xr.prototype.addIntersections=function(l,h,m){for(var _=0;_<l.getIntersectionNum();_++)this.addIntersection(l,h,m,_)},Xr.prototype.interfaces_=function(){return[Zs]},Xr.prototype.getClass=function(){return Xr},Xr.getNodedSubstrings=function(){if(1===arguments.length){var l=arguments[0],h=new ue;return Xr.getNodedSubstrings(l,h),h}if(2===arguments.length)for(var _=arguments[1],C=arguments[0].iterator();C.hasNext();)C.next().getNodeList().addSplitEdges(_)};var tn=function(){if(this.p0=null,this.p1=null,0===arguments.length)this.p0=new B,this.p1=new B;else if(1===arguments.length){var l=arguments[0];this.p0=new B(l.p0),this.p1=new B(l.p1)}else if(2===arguments.length)this.p0=arguments[0],this.p1=arguments[1];else if(4===arguments.length){var _=arguments[2],C=arguments[3];this.p0=new B(arguments[0],arguments[1]),this.p1=new B(_,C)}},Iu={serialVersionUID:{configurable:!0}};tn.prototype.minX=function(){return Math.min(this.p0.x,this.p1.x)},tn.prototype.orientationIndex=function(){if(arguments[0]instanceof tn){var l=arguments[0],h=yn.orientationIndex(this.p0,this.p1,l.p0),m=yn.orientationIndex(this.p0,this.p1,l.p1);return h>=0&&m>=0||h<=0&&m<=0?Math.max(h,m):0}if(arguments[0]instanceof B)return yn.orientationIndex(this.p0,this.p1,arguments[0])},tn.prototype.toGeometry=function(l){return l.createLineString([this.p0,this.p1])},tn.prototype.isVertical=function(){return this.p0.x===this.p1.x},tn.prototype.equals=function(l){if(!(l instanceof tn))return!1;var h=l;return this.p0.equals(h.p0)&&this.p1.equals(h.p1)},tn.prototype.intersection=function(l){var h=new di;return h.computeIntersection(this.p0,this.p1,l.p0,l.p1),h.hasIntersection()?h.getIntersection(0):null},tn.prototype.project=function(){if(arguments[0]instanceof B){var l=arguments[0];if(l.equals(this.p0)||l.equals(this.p1))return new B(l);var h=this.projectionFactor(l),m=new B;return m.x=this.p0.x+h*(this.p1.x-this.p0.x),m.y=this.p0.y+h*(this.p1.y-this.p0.y),m}if(arguments[0]instanceof tn){var _=arguments[0],C=this.projectionFactor(_.p0),F=this.projectionFactor(_.p1);if(C>=1&&F>=1||C<=0&&F<=0)return null;var rt=this.project(_.p0);C<0&&(rt=this.p0),C>1&&(rt=this.p1);var Dt=this.project(_.p1);return F<0&&(Dt=this.p0),F>1&&(Dt=this.p1),new tn(rt,Dt)}},tn.prototype.normalize=function(){this.p1.compareTo(this.p0)<0&&this.reverse()},tn.prototype.angle=function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},tn.prototype.getCoordinate=function(l){return 0===l?this.p0:this.p1},tn.prototype.distancePerpendicular=function(l){return yn.distancePointLinePerpendicular(l,this.p0,this.p1)},tn.prototype.minY=function(){return Math.min(this.p0.y,this.p1.y)},tn.prototype.midPoint=function(){return tn.midPoint(this.p0,this.p1)},tn.prototype.projectionFactor=function(l){if(l.equals(this.p0))return 0;if(l.equals(this.p1))return 1;var h=this.p1.x-this.p0.x,m=this.p1.y-this.p0.y,_=h*h+m*m;return _<=0?lt.NaN:((l.x-this.p0.x)*h+(l.y-this.p0.y)*m)/_},tn.prototype.closestPoints=function(l){var h=this.intersection(l);if(null!==h)return[h,h];var m=new Array(2).fill(null),_=lt.MAX_VALUE,C=null,F=this.closestPoint(l.p0);_=F.distance(l.p0),m[0]=F,m[1]=l.p0;var rt=this.closestPoint(l.p1);(C=rt.distance(l.p1))<_&&(_=C,m[0]=rt,m[1]=l.p1);var Dt=l.closestPoint(this.p0);(C=Dt.distance(this.p0))<_&&(_=C,m[0]=this.p0,m[1]=Dt);var qt=l.closestPoint(this.p1);return(C=qt.distance(this.p1))<_&&(_=C,m[0]=this.p1,m[1]=qt),m},tn.prototype.closestPoint=function(l){var h=this.projectionFactor(l);return h>0&&h<1?this.project(l):this.p0.distance(l)<this.p1.distance(l)?this.p0:this.p1},tn.prototype.maxX=function(){return Math.max(this.p0.x,this.p1.x)},tn.prototype.getLength=function(){return this.p0.distance(this.p1)},tn.prototype.compareTo=function(l){var h=l,m=this.p0.compareTo(h.p0);return 0!==m?m:this.p1.compareTo(h.p1)},tn.prototype.reverse=function(){var l=this.p0;this.p0=this.p1,this.p1=l},tn.prototype.equalsTopo=function(l){return this.p0.equals(l.p0)&&(this.p1.equals(l.p1)||this.p0.equals(l.p1))&&this.p1.equals(l.p0)},tn.prototype.lineIntersection=function(l){try{return Ue.intersection(this.p0,this.p1,l.p0,l.p1)}catch(h){if(!(h instanceof Me))throw h}return null},tn.prototype.maxY=function(){return Math.max(this.p0.y,this.p1.y)},tn.prototype.pointAlongOffset=function(l,h){var m=this.p0.x+l*(this.p1.x-this.p0.x),_=this.p0.y+l*(this.p1.y-this.p0.y),C=this.p1.x-this.p0.x,F=this.p1.y-this.p0.y,rt=Math.sqrt(C*C+F*F),Dt=0,qt=0;if(0!==h){if(rt<=0)throw new Error("Cannot compute offset from zero-length line segment");Dt=h*C/rt,qt=h*F/rt}return new B(m-qt,_+Dt)},tn.prototype.setCoordinates=function(){if(1===arguments.length){var l=arguments[0];this.setCoordinates(l.p0,l.p1)}else if(2===arguments.length){var h=arguments[0],m=arguments[1];this.p0.x=h.x,this.p0.y=h.y,this.p1.x=m.x,this.p1.y=m.y}},tn.prototype.segmentFraction=function(l){var h=this.projectionFactor(l);return h<0?h=0:(h>1||lt.isNaN(h))&&(h=1),h},tn.prototype.toString=function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},tn.prototype.isHorizontal=function(){return this.p0.y===this.p1.y},tn.prototype.distance=function(){if(arguments[0]instanceof tn){var l=arguments[0];return yn.distanceLineLine(this.p0,this.p1,l.p0,l.p1)}if(arguments[0]instanceof B)return yn.distancePointLine(arguments[0],this.p0,this.p1)},tn.prototype.pointAlong=function(l){var h=new B;return h.x=this.p0.x+l*(this.p1.x-this.p0.x),h.y=this.p0.y+l*(this.p1.y-this.p0.y),h},tn.prototype.hashCode=function(){var l=lt.doubleToLongBits(this.p0.x);l^=31*lt.doubleToLongBits(this.p0.y);var h=Math.trunc(l)^Math.trunc(l>>32),m=lt.doubleToLongBits(this.p1.x);return m^=31*lt.doubleToLongBits(this.p1.y),h^Math.trunc(m)^Math.trunc(m>>32)},tn.prototype.interfaces_=function(){return[q,$]},tn.prototype.getClass=function(){return tn},tn.midPoint=function(l,h){return new B((l.x+h.x)/2,(l.y+h.y)/2)},Iu.serialVersionUID.get=function(){return 0x2d2172135f411c00},Object.defineProperties(tn,Iu);var xr=function(){this.tempEnv1=new De,this.tempEnv2=new De,this._overlapSeg1=new tn,this._overlapSeg2=new tn};xr.prototype.overlap=function(){if(2!==arguments.length&&4===arguments.length){var m=arguments[2],_=arguments[3];arguments[0].getLineSegment(arguments[1],this._overlapSeg1),m.getLineSegment(_,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}},xr.prototype.interfaces_=function(){return[]},xr.prototype.getClass=function(){return xr};var Qi=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;var h=arguments[1],m=arguments[2],_=arguments[3];this._pts=arguments[0],this._start=h,this._end=m,this._context=_};Qi.prototype.getLineSegment=function(l,h){h.p0=this._pts[l],h.p1=this._pts[l+1]},Qi.prototype.computeSelect=function(l,h,m,_){if(_.tempEnv1.init(this._pts[h],this._pts[m]),m-h==1)return _.select(this,h),null;if(!l.intersects(_.tempEnv1))return null;var rt=Math.trunc((h+m)/2);h<rt&&this.computeSelect(l,h,rt,_),rt<m&&this.computeSelect(l,rt,m,_)},Qi.prototype.getCoordinates=function(){for(var l=new Array(this._end-this._start+1).fill(null),h=0,m=this._start;m<=this._end;m++)l[h++]=this._pts[m];return l},Qi.prototype.computeOverlaps=function(l,h){this.computeOverlapsInternal(this._start,this._end,l,l._start,l._end,h)},Qi.prototype.setId=function(l){this._id=l},Qi.prototype.select=function(l,h){this.computeSelect(l,this._start,this._end,h)},Qi.prototype.getEnvelope=function(){return null===this._env&&(this._env=new De(this._pts[this._start],this._pts[this._end])),this._env},Qi.prototype.getEndIndex=function(){return this._end},Qi.prototype.getStartIndex=function(){return this._start},Qi.prototype.getContext=function(){return this._context},Qi.prototype.getId=function(){return this._id},Qi.prototype.computeOverlapsInternal=function(l,h,m,_,C,F){var rt=this._pts[l],Dt=this._pts[h],qt=m._pts[_],fe=m._pts[C];if(h-l==1&&C-_==1)return F.overlap(this,l,m,_),null;if(F.tempEnv1.init(rt,Dt),F.tempEnv2.init(qt,fe),!F.tempEnv1.intersects(F.tempEnv2))return null;var ke=Math.trunc((l+h)/2),Ge=Math.trunc((_+C)/2);l<ke&&(_<Ge&&this.computeOverlapsInternal(l,ke,m,_,Ge,F),Ge<C&&this.computeOverlapsInternal(l,ke,m,Ge,C,F)),ke<h&&(_<Ge&&this.computeOverlapsInternal(ke,h,m,_,Ge,F),Ge<C&&this.computeOverlapsInternal(ke,h,m,Ge,C,F))},Qi.prototype.interfaces_=function(){return[]},Qi.prototype.getClass=function(){return Qi};var fo=function(){};fo.prototype.interfaces_=function(){return[]},fo.prototype.getClass=function(){return fo},fo.getChainStartIndices=function(l){var h=0,m=new ue;m.add(new xt(h));do{var _=fo.findChainEnd(l,h);m.add(new xt(_)),h=_}while(h<l.length-1);return fo.toIntArray(m)},fo.findChainEnd=function(l,h){for(var m=h;m<l.length-1&&l[m].equals2D(l[m+1]);)m++;if(m>=l.length-1)return l.length-1;for(var _=Wr.quadrant(l[m],l[m+1]),C=h+1;C<l.length&&(l[C-1].equals2D(l[C])||Wr.quadrant(l[C-1],l[C])===_);)C++;return C-1},fo.getChains=function(){if(1===arguments.length)return fo.getChains(arguments[0],null);if(2===arguments.length){for(var h=arguments[0],m=arguments[1],_=new ue,C=fo.getChainStartIndices(h),F=0;F<C.length-1;F++){var rt=new Qi(h,C[F],C[F+1],m);_.add(rt)}return _}},fo.toIntArray=function(l){for(var h=new Array(l.size()).fill(null),m=0;m<h.length;m++)h[m]=l.get(m).intValue();return h};var vs=function(){};vs.prototype.computeNodes=function(l){},vs.prototype.getNodedSubstrings=function(){},vs.prototype.interfaces_=function(){return[]},vs.prototype.getClass=function(){return vs};var Lu=function(){this._segInt=null,0!==arguments.length&&1===arguments.length&&this.setSegmentIntersector(arguments[0])};Lu.prototype.setSegmentIntersector=function(l){this._segInt=l},Lu.prototype.interfaces_=function(){return[vs]},Lu.prototype.getClass=function(){return Lu};var Oc=function(l){function h(_){_?l.call(this,_):l.call(this),this._monoChains=new ue,this._index=new Cn,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0}l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h;var m={SegmentOverlapAction:{configurable:!0}};return h.prototype.getMonotoneChains=function(){return this._monoChains},h.prototype.getNodedSubstrings=function(){return Xr.getNodedSubstrings(this._nodedSegStrings)},h.prototype.getIndex=function(){return this._index},h.prototype.add=function(_){for(var C=fo.getChains(_.getCoordinates(),_).iterator();C.hasNext();){var F=C.next();F.setId(this._idCounter++),this._index.insert(F.getEnvelope(),F),this._monoChains.add(F)}},h.prototype.computeNodes=function(_){this._nodedSegStrings=_;for(var C=_.iterator();C.hasNext();)this.add(C.next());this.intersectChains()},h.prototype.intersectChains=function(){for(var _=new as(this._segInt),C=this._monoChains.iterator();C.hasNext();)for(var F=C.next(),rt=this._index.query(F.getEnvelope()).iterator();rt.hasNext();){var Dt=rt.next();if(Dt.getId()>F.getId()&&(F.computeOverlaps(Dt,_),this._nOverlaps++),this._segInt.isDone())return null}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},m.SegmentOverlapAction.get=function(){return as},Object.defineProperties(h,m),h}(Lu),as=function(l){function h(){l.call(this),this._si=null,this._si=arguments[0]}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.overlap=function(){if(4!==arguments.length)return l.prototype.overlap.apply(this,arguments);var _=arguments[1],C=arguments[2],F=arguments[3],rt=arguments[0].getContext(),Dt=C.getContext();this._si.processIntersections(rt,_,Dt,F)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(xr),Zr=function l(){if(this._quadrantSegments=l.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=l.CAP_ROUND,this._joinStyle=l.JOIN_ROUND,this._mitreLimit=l.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=l.DEFAULT_SIMPLIFY_FACTOR,0!==arguments.length)if(1===arguments.length)this.setQuadrantSegments(arguments[0]);else if(2===arguments.length){var _=arguments[1];this.setQuadrantSegments(arguments[0]),this.setEndCapStyle(_)}else if(4===arguments.length){var F=arguments[1],rt=arguments[2],Dt=arguments[3];this.setQuadrantSegments(arguments[0]),this.setEndCapStyle(F),this.setJoinStyle(rt),this.setMitreLimit(Dt)}},eu={CAP_ROUND:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},JOIN_ROUND:{configurable:!0},JOIN_MITRE:{configurable:!0},JOIN_BEVEL:{configurable:!0},DEFAULT_QUADRANT_SEGMENTS:{configurable:!0},DEFAULT_MITRE_LIMIT:{configurable:!0},DEFAULT_SIMPLIFY_FACTOR:{configurable:!0}};Zr.prototype.getEndCapStyle=function(){return this._endCapStyle},Zr.prototype.isSingleSided=function(){return this._isSingleSided},Zr.prototype.setQuadrantSegments=function(l){this._quadrantSegments=l,0===this._quadrantSegments&&(this._joinStyle=Zr.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=Zr.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),l<=0&&(this._quadrantSegments=1),this._joinStyle!==Zr.JOIN_ROUND&&(this._quadrantSegments=Zr.DEFAULT_QUADRANT_SEGMENTS)},Zr.prototype.getJoinStyle=function(){return this._joinStyle},Zr.prototype.setJoinStyle=function(l){this._joinStyle=l},Zr.prototype.setSimplifyFactor=function(l){this._simplifyFactor=l<0?0:l},Zr.prototype.getSimplifyFactor=function(){return this._simplifyFactor},Zr.prototype.getQuadrantSegments=function(){return this._quadrantSegments},Zr.prototype.setEndCapStyle=function(l){this._endCapStyle=l},Zr.prototype.getMitreLimit=function(){return this._mitreLimit},Zr.prototype.setMitreLimit=function(l){this._mitreLimit=l},Zr.prototype.setSingleSided=function(l){this._isSingleSided=l},Zr.prototype.interfaces_=function(){return[]},Zr.prototype.getClass=function(){return Zr},Zr.bufferDistanceError=function(l){var h=Math.PI/2/l;return 1-Math.cos(h/2)},eu.CAP_ROUND.get=function(){return 1},eu.CAP_FLAT.get=function(){return 2},eu.CAP_SQUARE.get=function(){return 3},eu.JOIN_ROUND.get=function(){return 1},eu.JOIN_MITRE.get=function(){return 2},eu.JOIN_BEVEL.get=function(){return 3},eu.DEFAULT_QUADRANT_SEGMENTS.get=function(){return 8},eu.DEFAULT_MITRE_LIMIT.get=function(){return 5},eu.DEFAULT_SIMPLIFY_FACTOR.get=function(){return.01},Object.defineProperties(Zr,eu);var In=function(l){this._distanceTol=null,this._isDeleted=null,this._angleOrientation=yn.COUNTERCLOCKWISE,this._inputLine=l||null},fu={INIT:{configurable:!0},DELETE:{configurable:!0},KEEP:{configurable:!0},NUM_PTS_TO_CHECK:{configurable:!0}};In.prototype.isDeletable=function(l,h,m,_){var C=this._inputLine[l],F=this._inputLine[h],rt=this._inputLine[m];return!!this.isConcave(C,F,rt)&&!!this.isShallow(C,F,rt,_)&&this.isShallowSampled(C,F,l,m,_)},In.prototype.deleteShallowConcavities=function(){for(var l=1,h=this.findNextNonDeletedIndex(l),m=this.findNextNonDeletedIndex(h),_=!1;m<this._inputLine.length;){var C=!1;this.isDeletable(l,h,m,this._distanceTol)&&(this._isDeleted[h]=In.DELETE,C=!0,_=!0),h=this.findNextNonDeletedIndex(l=C?m:h),m=this.findNextNonDeletedIndex(h)}return _},In.prototype.isShallowConcavity=function(l,h,m,_){return yn.computeOrientation(l,h,m)===this._angleOrientation&&yn.distancePointLine(h,l,m)<_},In.prototype.isShallowSampled=function(l,h,m,_,C){var F=Math.trunc((_-m)/In.NUM_PTS_TO_CHECK);F<=0&&(F=1);for(var rt=m;rt<_;rt+=F)if(!this.isShallow(l,h,this._inputLine[rt],C))return!1;return!0},In.prototype.isConcave=function(l,h,m){return yn.computeOrientation(l,h,m)===this._angleOrientation},In.prototype.simplify=function(l){this._distanceTol=Math.abs(l),l<0&&(this._angleOrientation=yn.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);var h=!1;do{h=this.deleteShallowConcavities()}while(h);return this.collapseLine()},In.prototype.findNextNonDeletedIndex=function(l){for(var h=l+1;h<this._inputLine.length&&this._isDeleted[h]===In.DELETE;)h++;return h},In.prototype.isShallow=function(l,h,m,_){return yn.distancePointLine(h,l,m)<_},In.prototype.collapseLine=function(){for(var l=new mn,h=0;h<this._inputLine.length;h++)this._isDeleted[h]!==In.DELETE&&l.add(this._inputLine[h]);return l.toCoordinateArray()},In.prototype.interfaces_=function(){return[]},In.prototype.getClass=function(){return In},In.simplify=function(l,h){return new In(l).simplify(h)},fu.INIT.get=function(){return 0},fu.DELETE.get=function(){return 1},fu.KEEP.get=function(){return 1},fu.NUM_PTS_TO_CHECK.get=function(){return 10},Object.defineProperties(In,fu);var $o=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new ue},Gl={COORDINATE_ARRAY_TYPE:{configurable:!0}};$o.prototype.getCoordinates=function(){return this._ptList.toArray($o.COORDINATE_ARRAY_TYPE)},$o.prototype.setPrecisionModel=function(l){this._precisionModel=l},$o.prototype.addPt=function(l){var h=new B(l);if(this._precisionModel.makePrecise(h),this.isRedundant(h))return null;this._ptList.add(h)},$o.prototype.revere=function(){},$o.prototype.addPts=function(l,h){if(h)for(var m=0;m<l.length;m++)this.addPt(l[m]);else for(var _=l.length-1;_>=0;_--)this.addPt(l[_])},$o.prototype.isRedundant=function(l){if(this._ptList.size()<1)return!1;var h=this._ptList.get(this._ptList.size()-1);return l.distance(h)<this._minimimVertexDistance},$o.prototype.toString=function(){return(new er).createLineString(this.getCoordinates()).toString()},$o.prototype.closeRing=function(){if(this._ptList.size()<1)return null;var l=new B(this._ptList.get(0)),h=this._ptList.get(this._ptList.size()-1);if(l.equals(h))return null;this._ptList.add(l)},$o.prototype.setMinimumVertexDistance=function(l){this._minimimVertexDistance=l},$o.prototype.interfaces_=function(){return[]},$o.prototype.getClass=function(){return $o},Gl.COORDINATE_ARRAY_TYPE.get=function(){return new Array(0).fill(null)},Object.defineProperties($o,Gl);var Ir=function(){},pu={PI_TIMES_2:{configurable:!0},PI_OVER_2:{configurable:!0},PI_OVER_4:{configurable:!0},COUNTERCLOCKWISE:{configurable:!0},CLOCKWISE:{configurable:!0},NONE:{configurable:!0}};Ir.prototype.interfaces_=function(){return[]},Ir.prototype.getClass=function(){return Ir},Ir.toDegrees=function(l){return 180*l/Math.PI},Ir.normalize=function(l){for(;l>Math.PI;)l-=Ir.PI_TIMES_2;for(;l<=-Math.PI;)l+=Ir.PI_TIMES_2;return l},Ir.angle=function(){if(1===arguments.length){var l=arguments[0];return Math.atan2(l.y,l.x)}if(2===arguments.length){var h=arguments[0],m=arguments[1];return Math.atan2(m.y-h.y,m.x-h.x)}},Ir.isAcute=function(l,h,m){return(l.x-h.x)*(m.x-h.x)+(l.y-h.y)*(m.y-h.y)>0},Ir.isObtuse=function(l,h,m){return(l.x-h.x)*(m.x-h.x)+(l.y-h.y)*(m.y-h.y)<0},Ir.interiorAngle=function(l,h,m){var _=Ir.angle(h,l),C=Ir.angle(h,m);return Math.abs(C-_)},Ir.normalizePositive=function(l){if(l<0){for(;l<0;)l+=Ir.PI_TIMES_2;l>=Ir.PI_TIMES_2&&(l=0)}else{for(;l>=Ir.PI_TIMES_2;)l-=Ir.PI_TIMES_2;l<0&&(l=0)}return l},Ir.angleBetween=function(l,h,m){var _=Ir.angle(h,l),C=Ir.angle(h,m);return Ir.diff(_,C)},Ir.diff=function(l,h){var m=null;return(m=l<h?h-l:l-h)>Math.PI&&(m=2*Math.PI-m),m},Ir.toRadians=function(l){return l*Math.PI/180},Ir.getTurn=function(l,h){var m=Math.sin(h-l);return m>0?Ir.COUNTERCLOCKWISE:m<0?Ir.CLOCKWISE:Ir.NONE},Ir.angleBetweenOriented=function(l,h,m){var _=Ir.angle(h,l),C=Ir.angle(h,m)-_;return C<=-Math.PI?C+Ir.PI_TIMES_2:C>Math.PI?C-Ir.PI_TIMES_2:C},pu.PI_TIMES_2.get=function(){return 2*Math.PI},pu.PI_OVER_2.get=function(){return Math.PI/2},pu.PI_OVER_4.get=function(){return Math.PI/4},pu.COUNTERCLOCKWISE.get=function(){return yn.COUNTERCLOCKWISE},pu.CLOCKWISE.get=function(){return yn.CLOCKWISE},pu.NONE.get=function(){return yn.COLLINEAR},Object.defineProperties(Ir,pu);var Hr=function l(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new tn,this._seg1=new tn,this._offset0=new tn,this._offset1=new tn,this._side=0,this._hasNarrowConcaveAngle=!1;var m=arguments[1],_=arguments[2];this._precisionModel=arguments[0],this._bufParams=m,this._li=new di,this._filletAngleQuantum=Math.PI/2/m.getQuadrantSegments(),m.getQuadrantSegments()>=8&&m.getJoinStyle()===Zr.JOIN_ROUND&&(this._closingSegLengthFactor=l.MAX_CLOSING_SEG_LEN_FACTOR),this.init(_)},Qu={OFFSET_SEGMENT_SEPARATION_FACTOR:{configurable:!0},INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},CURVE_VERTEX_SNAP_DISTANCE_FACTOR:{configurable:!0},MAX_CLOSING_SEG_LEN_FACTOR:{configurable:!0}};Hr.prototype.addNextSegment=function(l,h){if(this._s0=this._s1,this._s1=this._s2,this._s2=l,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;var m=yn.computeOrientation(this._s0,this._s1,this._s2),_=m===yn.CLOCKWISE&&this._side===an.LEFT||m===yn.COUNTERCLOCKWISE&&this._side===an.RIGHT;0===m?this.addCollinear(h):_?this.addOutsideTurn(m,h):this.addInsideTurn(m,h)},Hr.prototype.addLineEndCap=function(l,h){var m=new tn(l,h),_=new tn;this.computeOffsetSegment(m,an.LEFT,this._distance,_);var C=new tn;this.computeOffsetSegment(m,an.RIGHT,this._distance,C);var Dt=Math.atan2(h.y-l.y,h.x-l.x);switch(this._bufParams.getEndCapStyle()){case Zr.CAP_ROUND:this._segList.addPt(_.p1),this.addFilletArc(h,Dt+Math.PI/2,Dt-Math.PI/2,yn.CLOCKWISE,this._distance),this._segList.addPt(C.p1);break;case Zr.CAP_FLAT:this._segList.addPt(_.p1),this._segList.addPt(C.p1);break;case Zr.CAP_SQUARE:var qt=new B;qt.x=Math.abs(this._distance)*Math.cos(Dt),qt.y=Math.abs(this._distance)*Math.sin(Dt);var fe=new B(_.p1.x+qt.x,_.p1.y+qt.y),ke=new B(C.p1.x+qt.x,C.p1.y+qt.y);this._segList.addPt(fe),this._segList.addPt(ke)}},Hr.prototype.getCoordinates=function(){return this._segList.getCoordinates()},Hr.prototype.addMitreJoin=function(l,h,m,_){var C=!0,F=null;try{F=Ue.intersection(h.p0,h.p1,m.p0,m.p1),(_<=0?1:F.distance(l)/Math.abs(_))>this._bufParams.getMitreLimit()&&(C=!1)}catch(rt){if(!(rt instanceof Me))throw rt;F=new B(0,0),C=!1}C?this._segList.addPt(F):this.addLimitedMitreJoin(h,m,_,this._bufParams.getMitreLimit())},Hr.prototype.addFilletCorner=function(l,h,m,_,C){var Dt=Math.atan2(h.y-l.y,h.x-l.x),ke=Math.atan2(m.y-l.y,m.x-l.x);_===yn.CLOCKWISE?Dt<=ke&&(Dt+=2*Math.PI):Dt>=ke&&(Dt-=2*Math.PI),this._segList.addPt(h),this.addFilletArc(l,Dt,ke,_,C),this._segList.addPt(m)},Hr.prototype.addOutsideTurn=function(l,h){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*Hr.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===Zr.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===Zr.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(h&&this._segList.addPt(this._offset0.p1),this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,l,this._distance),this._segList.addPt(this._offset1.p0))},Hr.prototype.createSquare=function(l){this._segList.addPt(new B(l.x+this._distance,l.y+this._distance)),this._segList.addPt(new B(l.x+this._distance,l.y-this._distance)),this._segList.addPt(new B(l.x-this._distance,l.y-this._distance)),this._segList.addPt(new B(l.x-this._distance,l.y+this._distance)),this._segList.closeRing()},Hr.prototype.addSegments=function(l,h){this._segList.addPts(l,h)},Hr.prototype.addFirstSegment=function(){this._segList.addPt(this._offset1.p0)},Hr.prototype.addLastSegment=function(){this._segList.addPt(this._offset1.p1)},Hr.prototype.initSideSegments=function(l,h,m){this._s1=l,this._s2=h,this._side=m,this._seg1.setCoordinates(l,h),this.computeOffsetSegment(this._seg1,m,this._distance,this._offset1)},Hr.prototype.addLimitedMitreJoin=function(l,h,m,_){var C=this._seg0.p1,F=Ir.angle(C,this._seg0.p0),rt=Ir.angleBetweenOriented(this._seg0.p0,C,this._seg1.p1)/2,Dt=Ir.normalize(F+rt),qt=Ir.normalize(Dt+Math.PI),fe=_*m,ke=m-fe*Math.abs(Math.sin(rt)),Ge=C.x+fe*Math.cos(qt),xn=C.y+fe*Math.sin(qt),Sn=new B(Ge,xn),Un=new tn(C,Sn),ur=Un.pointAlongOffset(1,ke),Ji=Un.pointAlongOffset(1,-ke);this._side===an.LEFT?(this._segList.addPt(ur),this._segList.addPt(Ji)):(this._segList.addPt(Ji),this._segList.addPt(ur))},Hr.prototype.computeOffsetSegment=function(l,h,m,_){var C=h===an.LEFT?1:-1,F=l.p1.x-l.p0.x,rt=l.p1.y-l.p0.y,Dt=Math.sqrt(F*F+rt*rt),qt=C*m*F/Dt,fe=C*m*rt/Dt;_.p0.x=l.p0.x-fe,_.p0.y=l.p0.y+qt,_.p1.x=l.p1.x-fe,_.p1.y=l.p1.y+qt},Hr.prototype.addFilletArc=function(l,h,m,_,C){var F=_===yn.CLOCKWISE?-1:1,rt=Math.abs(h-m),Dt=Math.trunc(rt/this._filletAngleQuantum+.5);if(Dt<1)return null;for(var qt=rt/Dt,fe=0,ke=new B;fe<rt;){var Ge=h+F*fe;ke.x=l.x+C*Math.cos(Ge),ke.y=l.y+C*Math.sin(Ge),this._segList.addPt(ke),fe+=qt}},Hr.prototype.addInsideTurn=function(l,h){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*Hr.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){var m=new B((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(m);var _=new B((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(_)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}},Hr.prototype.createCircle=function(l){var h=new B(l.x+this._distance,l.y);this._segList.addPt(h),this.addFilletArc(l,0,2*Math.PI,-1,this._distance),this._segList.closeRing()},Hr.prototype.addBevelJoin=function(l,h){this._segList.addPt(l.p1),this._segList.addPt(h.p0)},Hr.prototype.init=function(l){this._distance=l,this._maxCurveSegmentError=l*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new $o,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(l*Hr.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},Hr.prototype.addCollinear=function(l){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===Zr.JOIN_BEVEL||this._bufParams.getJoinStyle()===Zr.JOIN_MITRE?(l&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addFilletCorner(this._s1,this._offset0.p1,this._offset1.p0,yn.CLOCKWISE,this._distance))},Hr.prototype.closeRing=function(){this._segList.closeRing()},Hr.prototype.hasNarrowConcaveAngle=function(){return this._hasNarrowConcaveAngle},Hr.prototype.interfaces_=function(){return[]},Hr.prototype.getClass=function(){return Hr},Qu.OFFSET_SEGMENT_SEPARATION_FACTOR.get=function(){return.001},Qu.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return.001},Qu.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get=function(){return 1e-6},Qu.MAX_CLOSING_SEG_LEN_FACTOR.get=function(){return 80},Object.defineProperties(Hr,Qu);var he=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;var h=arguments[1];this._precisionModel=arguments[0],this._bufParams=h};he.prototype.getOffsetCurve=function(l,h){if(this._distance=h,0===h)return null;var m=h<0,_=Math.abs(h),C=this.getSegGen(_);l.length<=1?this.computePointCurve(l[0],C):this.computeOffsetCurve(l,m,C);var F=C.getCoordinates();return m&&un.reverse(F),F},he.prototype.computeSingleSidedBufferCurve=function(l,h,m){var _=this.simplifyTolerance(this._distance);if(h){m.addSegments(l,!0);var C=In.simplify(l,-_),F=C.length-1;m.initSideSegments(C[F],C[F-1],an.LEFT),m.addFirstSegment();for(var rt=F-2;rt>=0;rt--)m.addNextSegment(C[rt],!0)}else{m.addSegments(l,!1);var Dt=In.simplify(l,_),qt=Dt.length-1;m.initSideSegments(Dt[0],Dt[1],an.LEFT),m.addFirstSegment();for(var fe=2;fe<=qt;fe++)m.addNextSegment(Dt[fe],!0)}m.addLastSegment(),m.closeRing()},he.prototype.computeRingBufferCurve=function(l,h,m){var _=this.simplifyTolerance(this._distance);h===an.RIGHT&&(_=-_);var C=In.simplify(l,_),F=C.length-1;m.initSideSegments(C[F-1],C[0],h);for(var rt=1;rt<=F;rt++)m.addNextSegment(C[rt],1!==rt);m.closeRing()},he.prototype.computeLineBufferCurve=function(l,h){var m=this.simplifyTolerance(this._distance),_=In.simplify(l,m),C=_.length-1;h.initSideSegments(_[0],_[1],an.LEFT);for(var F=2;F<=C;F++)h.addNextSegment(_[F],!0);h.addLastSegment(),h.addLineEndCap(_[C-1],_[C]);var rt=In.simplify(l,-m),Dt=rt.length-1;h.initSideSegments(rt[Dt],rt[Dt-1],an.LEFT);for(var qt=Dt-2;qt>=0;qt--)h.addNextSegment(rt[qt],!0);h.addLastSegment(),h.addLineEndCap(rt[1],rt[0]),h.closeRing()},he.prototype.computePointCurve=function(l,h){switch(this._bufParams.getEndCapStyle()){case Zr.CAP_ROUND:h.createCircle(l);break;case Zr.CAP_SQUARE:h.createSquare(l)}},he.prototype.getLineCurve=function(l,h){if(this._distance=h,h<0&&!this._bufParams.isSingleSided()||0===h)return null;var m=Math.abs(h),_=this.getSegGen(m);return l.length<=1?this.computePointCurve(l[0],_):this._bufParams.isSingleSided()?this.computeSingleSidedBufferCurve(l,h<0,_):this.computeLineBufferCurve(l,_),_.getCoordinates()},he.prototype.getBufferParameters=function(){return this._bufParams},he.prototype.simplifyTolerance=function(l){return l*this._bufParams.getSimplifyFactor()},he.prototype.getRingCurve=function(l,h,m){if(this._distance=m,l.length<=2)return this.getLineCurve(l,m);if(0===m)return he.copyCoordinates(l);var _=this.getSegGen(m);return this.computeRingBufferCurve(l,h,_),_.getCoordinates()},he.prototype.computeOffsetCurve=function(l,h,m){var _=this.simplifyTolerance(this._distance);if(h){var C=In.simplify(l,-_),F=C.length-1;m.initSideSegments(C[F],C[F-1],an.LEFT),m.addFirstSegment();for(var rt=F-2;rt>=0;rt--)m.addNextSegment(C[rt],!0)}else{var Dt=In.simplify(l,_),qt=Dt.length-1;m.initSideSegments(Dt[0],Dt[1],an.LEFT),m.addFirstSegment();for(var fe=2;fe<=qt;fe++)m.addNextSegment(Dt[fe],!0)}m.addLastSegment()},he.prototype.getSegGen=function(l){return new Hr(this._precisionModel,this._bufParams,l)},he.prototype.interfaces_=function(){return[]},he.prototype.getClass=function(){return he},he.copyCoordinates=function(l){for(var h=new Array(l.length).fill(null),m=0;m<h.length;m++)h[m]=new B(l[m]);return h};var Bo=function(){this._subgraphs=null,this._seg=new tn,this._cga=new yn,this._subgraphs=arguments[0]},Hl={DepthSegment:{configurable:!0}};Bo.prototype.findStabbedSegments=function(){if(1===arguments.length){for(var l=arguments[0],h=new ue,m=this._subgraphs.iterator();m.hasNext();){var _=m.next(),C=_.getEnvelope();l.y<C.getMinY()||l.y>C.getMaxY()||this.findStabbedSegments(l,_.getDirectedEdges(),h)}return h}if(3===arguments.length)if(O(arguments[2],En)&&arguments[0]instanceof B&&arguments[1]instanceof wu){for(var F=arguments[0],rt=arguments[1],Dt=arguments[2],qt=rt.getEdge().getCoordinates(),fe=0;fe<qt.length-1;fe++)if(this._seg.p0=qt[fe],this._seg.p1=qt[fe+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),!(Math.max(this._seg.p0.x,this._seg.p1.x)<F.x||this._seg.isHorizontal()||F.y<this._seg.p0.y||F.y>this._seg.p1.y||yn.computeOrientation(this._seg.p0,this._seg.p1,F)===yn.RIGHT)){var ke=rt.getDepth(an.LEFT);this._seg.p0.equals(qt[fe])||(ke=rt.getDepth(an.RIGHT));var Ge=new ku(this._seg,ke);Dt.add(Ge)}}else if(O(arguments[2],En)&&arguments[0]instanceof B&&O(arguments[1],En))for(var xn=arguments[0],Un=arguments[2],ur=arguments[1].iterator();ur.hasNext();){var Ji=ur.next();Ji.isForward()&&this.findStabbedSegments(xn,Ji,Un)}},Bo.prototype.getDepth=function(l){var h=this.findStabbedSegments(l);return 0===h.size()?0:Yt.min(h)._leftDepth},Bo.prototype.interfaces_=function(){return[]},Bo.prototype.getClass=function(){return Bo},Hl.DepthSegment.get=function(){return ku},Object.defineProperties(Bo,Hl);var ku=function(){this._upwardSeg=null,this._leftDepth=null;var h=arguments[1];this._upwardSeg=new tn(arguments[0]),this._leftDepth=h};ku.prototype.compareTo=function(l){var h=l;if(this._upwardSeg.minX()>=h._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=h._upwardSeg.minX())return-1;var m=this._upwardSeg.orientationIndex(h._upwardSeg);return 0!==m||0!=(m=-1*h._upwardSeg.orientationIndex(this._upwardSeg))?m:this._upwardSeg.compareTo(h._upwardSeg)},ku.prototype.compareX=function(l,h){var m=l.p0.compareTo(h.p0);return 0!==m?m:l.p1.compareTo(h.p1)},ku.prototype.toString=function(){return this._upwardSeg.toString()},ku.prototype.interfaces_=function(){return[q]},ku.prototype.getClass=function(){return ku};var Br=function(l,h,m){this.p0=l||null,this.p1=h||null,this.p2=m||null};Br.prototype.area=function(){return Br.area(this.p0,this.p1,this.p2)},Br.prototype.signedArea=function(){return Br.signedArea(this.p0,this.p1,this.p2)},Br.prototype.interpolateZ=function(l){if(null===l)throw new dt("Supplied point is null.");return Br.interpolateZ(l,this.p0,this.p1,this.p2)},Br.prototype.longestSideLength=function(){return Br.longestSideLength(this.p0,this.p1,this.p2)},Br.prototype.isAcute=function(){return Br.isAcute(this.p0,this.p1,this.p2)},Br.prototype.circumcentre=function(){return Br.circumcentre(this.p0,this.p1,this.p2)},Br.prototype.area3D=function(){return Br.area3D(this.p0,this.p1,this.p2)},Br.prototype.centroid=function(){return Br.centroid(this.p0,this.p1,this.p2)},Br.prototype.inCentre=function(){return Br.inCentre(this.p0,this.p1,this.p2)},Br.prototype.interfaces_=function(){return[]},Br.prototype.getClass=function(){return Br},Br.area=function(l,h,m){return Math.abs(((m.x-l.x)*(h.y-l.y)-(h.x-l.x)*(m.y-l.y))/2)},Br.signedArea=function(l,h,m){return((m.x-l.x)*(h.y-l.y)-(h.x-l.x)*(m.y-l.y))/2},Br.det=function(l,h,m,_){return l*_-h*m},Br.interpolateZ=function(l,h,m,_){var C=h.x,F=h.y,rt=m.x-C,Dt=_.x-C,qt=m.y-F,fe=_.y-F,ke=rt*fe-Dt*qt,Ge=l.x-C,xn=l.y-F;return h.z+(fe*Ge-Dt*xn)/ke*(m.z-h.z)+(-qt*Ge+rt*xn)/ke*(_.z-h.z)},Br.longestSideLength=function(l,h,m){var _=l.distance(h),C=h.distance(m),F=m.distance(l),rt=_;return C>rt&&(rt=C),F>rt&&(rt=F),rt},Br.isAcute=function(l,h,m){return!!Ir.isAcute(l,h,m)&&!!Ir.isAcute(h,m,l)&&!!Ir.isAcute(m,l,h)},Br.circumcentre=function(l,h,m){var _=m.x,C=m.y,F=l.x-_,rt=l.y-C,Dt=h.x-_,qt=h.y-C,fe=2*Br.det(F,rt,Dt,qt),ke=Br.det(rt,F*F+rt*rt,qt,Dt*Dt+qt*qt),Ge=Br.det(F,F*F+rt*rt,Dt,Dt*Dt+qt*qt);return new B(_-ke/fe,C+Ge/fe)},Br.perpendicularBisector=function(l,h){var m=h.x-l.x,_=h.y-l.y,C=new Ue(l.x+m/2,l.y+_/2,1),F=new Ue(l.x-_+m/2,l.y+m+_/2,1);return new Ue(C,F)},Br.angleBisector=function(l,h,m){var _=h.distance(l),C=_/(_+h.distance(m));return new B(l.x+C*(m.x-l.x),l.y+C*(m.y-l.y))},Br.area3D=function(l,h,m){var _=h.x-l.x,C=h.y-l.y,F=h.z-l.z,rt=m.x-l.x,Dt=m.y-l.y,qt=m.z-l.z,fe=C*qt-F*Dt,ke=F*rt-_*qt,Ge=_*Dt-C*rt;return Math.sqrt(fe*fe+ke*ke+Ge*Ge)/2},Br.centroid=function(l,h,m){return new B((l.x+h.x+m.x)/3,(l.y+h.y+m.y)/3)},Br.inCentre=function(l,h,m){var _=h.distance(m),C=l.distance(m),F=l.distance(h),rt=_+C+F;return new B((_*l.x+C*h.x+F*m.x)/rt,(_*l.y+C*h.y+F*m.y)/rt)};var es=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new ue;var h=arguments[1],m=arguments[2];this._inputGeom=arguments[0],this._distance=h,this._curveBuilder=m};es.prototype.addPoint=function(l){if(this._distance<=0)return null;var h=l.getCoordinates(),m=this._curveBuilder.getLineCurve(h,this._distance);this.addCurve(m,nt.EXTERIOR,nt.INTERIOR)},es.prototype.addPolygon=function(l){var h=this._distance,m=an.LEFT;this._distance<0&&(h=-this._distance,m=an.RIGHT);var _=l.getExteriorRing(),C=un.removeRepeatedPoints(_.getCoordinates());if(this._distance<0&&this.isErodedCompletely(_,this._distance)||this._distance<=0&&C.length<3)return null;this.addPolygonRing(C,h,m,nt.EXTERIOR,nt.INTERIOR);for(var F=0;F<l.getNumInteriorRing();F++){var rt=l.getInteriorRingN(F),Dt=un.removeRepeatedPoints(rt.getCoordinates());this._distance>0&&this.isErodedCompletely(rt,-this._distance)||this.addPolygonRing(Dt,h,an.opposite(m),nt.INTERIOR,nt.EXTERIOR)}},es.prototype.isTriangleErodedCompletely=function(l,h){var m=new Br(l[0],l[1],l[2]),_=m.inCentre();return yn.distancePointLine(_,m.p0,m.p1)<Math.abs(h)},es.prototype.addLineString=function(l){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;var h=un.removeRepeatedPoints(l.getCoordinates()),m=this._curveBuilder.getLineCurve(h,this._distance);this.addCurve(m,nt.EXTERIOR,nt.INTERIOR)},es.prototype.addCurve=function(l,h,m){if(null===l||l.length<2)return null;var _=new Xr(l,new We(0,nt.BOUNDARY,h,m));this._curveList.add(_)},es.prototype.getCurves=function(){return this.add(this._inputGeom),this._curveList},es.prototype.addPolygonRing=function(l,h,m,_,C){if(0===h&&l.length<eo.MINIMUM_VALID_SIZE)return null;var F=_,rt=C;l.length>=eo.MINIMUM_VALID_SIZE&&yn.isCCW(l)&&(F=C,rt=_,m=an.opposite(m));var Dt=this._curveBuilder.getRingCurve(l,m,h);this.addCurve(Dt,F,rt)},es.prototype.add=function(l){if(l.isEmpty())return null;l instanceof rs?this.addPolygon(l):l instanceof Vr?this.addLineString(l):l instanceof Ls?this.addPoint(l):(l instanceof Pa||l instanceof js||l instanceof Co||l instanceof zr)&&this.addCollection(l)},es.prototype.isErodedCompletely=function(l,h){var m=l.getCoordinates();if(m.length<4)return h<0;if(4===m.length)return this.isTriangleErodedCompletely(m,h);var _=l.getEnvelopeInternal(),C=Math.min(_.getHeight(),_.getWidth());return h<0&&2*Math.abs(h)>C},es.prototype.addCollection=function(l){for(var h=0;h<l.getNumGeometries();h++){var m=l.getGeometryN(h);this.add(m)}},es.prototype.interfaces_=function(){return[]},es.prototype.getClass=function(){return es};var nu=function(){};nu.prototype.locate=function(l){},nu.prototype.interfaces_=function(){return[]},nu.prototype.getClass=function(){return nu};var ru=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;var l=arguments[0];this._parent=l,this._atStart=!0,this._index=0,this._max=l.getNumGeometries()};ru.prototype.next=function(){if(this._atStart)return this._atStart=!1,ru.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new H;var l=this._parent.getGeometryN(this._index++);return l instanceof zr?(this._subcollectionIterator=new ru(l),this._subcollectionIterator.next()):l},ru.prototype.remove=function(){throw new Error(this.getClass().getName())},ru.prototype.hasNext=function(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)},ru.prototype.interfaces_=function(){return[Xt]},ru.prototype.getClass=function(){return ru},ru.isAtomic=function(l){return!(l instanceof zr)};var us=function(){this._geom=null,this._geom=arguments[0]};us.prototype.locate=function(l){return us.locate(l,this._geom)},us.prototype.interfaces_=function(){return[nu]},us.prototype.getClass=function(){return us},us.isPointInRing=function(l,h){return!!h.getEnvelopeInternal().intersects(l)&&yn.isPointInRing(l,h.getCoordinates())},us.containsPointInPolygon=function(l,h){if(h.isEmpty())return!1;var m=h.getExteriorRing();if(!us.isPointInRing(l,m))return!1;for(var _=0;_<h.getNumInteriorRing();_++){var C=h.getInteriorRingN(_);if(us.isPointInRing(l,C))return!1}return!0},us.containsPoint=function(l,h){if(h instanceof rs)return us.containsPointInPolygon(l,h);if(h instanceof zr)for(var m=new ru(h);m.hasNext();){var _=m.next();if(_!==h&&us.containsPoint(l,_))return!0}return!1},us.locate=function(l,h){return h.isEmpty()?nt.EXTERIOR:us.containsPoint(l,h)?nt.INTERIOR:nt.EXTERIOR};var Fs=function(){this._edgeMap=new Z,this._edgeList=null,this._ptInAreaLocation=[nt.NONE,nt.NONE]};Fs.prototype.getNextCW=function(l){this.getEdges();var h=this._edgeList.indexOf(l),m=h-1;return 0===h&&(m=this._edgeList.size()-1),this._edgeList.get(m)},Fs.prototype.propagateSideLabels=function(l){for(var h=nt.NONE,m=this.iterator();m.hasNext();){var _=m.next().getLabel();_.isArea(l)&&_.getLocation(l,an.LEFT)!==nt.NONE&&(h=_.getLocation(l,an.LEFT))}if(h===nt.NONE)return null;for(var C=h,F=this.iterator();F.hasNext();){var rt=F.next(),Dt=rt.getLabel();if(Dt.getLocation(l,an.ON)===nt.NONE&&Dt.setLocation(l,an.ON,C),Dt.isArea(l)){var qt=Dt.getLocation(l,an.LEFT),fe=Dt.getLocation(l,an.RIGHT);if(fe!==nt.NONE){if(fe!==C)throw new Ss("side location conflict",rt.getCoordinate());qt===nt.NONE&&Nn.shouldNeverReachHere("found single null side (at "+rt.getCoordinate()+")"),C=qt}else Nn.isTrue(Dt.getLocation(l,an.LEFT)===nt.NONE,"found single null side"),Dt.setLocation(l,an.RIGHT,C),Dt.setLocation(l,an.LEFT,C)}}},Fs.prototype.getCoordinate=function(){var l=this.iterator();return l.hasNext()?l.next().getCoordinate():null},Fs.prototype.print=function(l){Xe.out.println("EdgeEndStar:   "+this.getCoordinate());for(var h=this.iterator();h.hasNext();)h.next().print(l)},Fs.prototype.isAreaLabelsConsistent=function(l){return this.computeEdgeEndLabels(l.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},Fs.prototype.checkAreaLabelsConsistent=function(l){var h=this.getEdges();if(h.size()<=0)return!0;var m=h.size()-1,_=h.get(m).getLabel().getLocation(l,an.LEFT);Nn.isTrue(_!==nt.NONE,"Found unlabelled area edge");for(var C=_,F=this.iterator();F.hasNext();){var rt=F.next().getLabel();Nn.isTrue(rt.isArea(l),"Found non-area edge");var Dt=rt.getLocation(l,an.LEFT),qt=rt.getLocation(l,an.RIGHT);if(Dt===qt||qt!==C)return!1;C=Dt}return!0},Fs.prototype.findIndex=function(l){this.iterator();for(var h=0;h<this._edgeList.size();h++)if(this._edgeList.get(h)===l)return h;return-1},Fs.prototype.iterator=function(){return this.getEdges().iterator()},Fs.prototype.getEdges=function(){return null===this._edgeList&&(this._edgeList=new ue(this._edgeMap.values())),this._edgeList},Fs.prototype.getLocation=function(l,h,m){return this._ptInAreaLocation[l]===nt.NONE&&(this._ptInAreaLocation[l]=us.locate(h,m[l].getGeometry())),this._ptInAreaLocation[l]},Fs.prototype.toString=function(){var l=new vt;l.append("EdgeEndStar:   "+this.getCoordinate()),l.append("\n");for(var h=this.iterator();h.hasNext();){var m=h.next();l.append(m),l.append("\n")}return l.toString()},Fs.prototype.computeEdgeEndLabels=function(l){for(var h=this.iterator();h.hasNext();)h.next().computeLabel(l)},Fs.prototype.computeLabelling=function(l){this.computeEdgeEndLabels(l[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var h=[!1,!1],m=this.iterator();m.hasNext();)for(var _=m.next().getLabel(),C=0;C<2;C++)_.isLine(C)&&_.getLocation(C)===nt.BOUNDARY&&(h[C]=!0);for(var F=this.iterator();F.hasNext();)for(var rt=F.next(),Dt=rt.getLabel(),qt=0;qt<2;qt++)if(Dt.isAnyNull(qt)){var fe=nt.NONE;if(h[qt])fe=nt.EXTERIOR;else{var ke=rt.getCoordinate();fe=this.getLocation(qt,ke,l)}Dt.setAllLocationsIfNull(qt,fe)}},Fs.prototype.getDegree=function(){return this._edgeMap.size()},Fs.prototype.insertEdgeEnd=function(l,h){this._edgeMap.put(l,h),this._edgeList=null},Fs.prototype.interfaces_=function(){return[]},Fs.prototype.getClass=function(){return Fs};var ya=function(l){function h(){l.call(this),this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.linkResultDirectedEdges=function(){this.getResultAreaEdges();for(var m=null,_=null,C=this._SCANNING_FOR_INCOMING,F=0;F<this._resultAreaEdgeList.size();F++){var rt=this._resultAreaEdgeList.get(F),Dt=rt.getSym();if(rt.getLabel().isArea())switch(null===m&&rt.isInResult()&&(m=rt),C){case this._SCANNING_FOR_INCOMING:if(!Dt.isInResult())continue;_=Dt,C=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!rt.isInResult())continue;_.setNext(rt),C=this._SCANNING_FOR_INCOMING}}if(C===this._LINKING_TO_OUTGOING){if(null===m)throw new Ss("no outgoing dirEdge found",this.getCoordinate());Nn.isTrue(m.isInResult(),"unable to link last incoming dirEdge"),_.setNext(m)}},h.prototype.insert=function(m){this.insertEdgeEnd(m,m)},h.prototype.getRightmostEdge=function(){var m=this.getEdges(),_=m.size();if(_<1)return null;var C=m.get(0);if(1===_)return C;var F=m.get(_-1),rt=C.getQuadrant(),Dt=F.getQuadrant();return Wr.isNorthern(rt)&&Wr.isNorthern(Dt)?C:Wr.isNorthern(rt)||Wr.isNorthern(Dt)?0!==C.getDy()?C:0!==F.getDy()?F:(Nn.shouldNeverReachHere("found two horizontal edges incident on node"),null):F},h.prototype.print=function(m){Xe.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var _=this.iterator();_.hasNext();){var C=_.next();m.print("out "),C.print(m),m.println(),m.print("in "),C.getSym().print(m),m.println()}},h.prototype.getResultAreaEdges=function(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new ue;for(var m=this.iterator();m.hasNext();){var _=m.next();(_.isInResult()||_.getSym().isInResult())&&this._resultAreaEdgeList.add(_)}return this._resultAreaEdgeList},h.prototype.updateLabelling=function(m){for(var _=this.iterator();_.hasNext();){var C=_.next().getLabel();C.setAllLocationsIfNull(0,m.getLocation(0)),C.setAllLocationsIfNull(1,m.getLocation(1))}},h.prototype.linkAllDirectedEdges=function(){this.getEdges();for(var m=null,_=null,C=this._edgeList.size()-1;C>=0;C--){var F=this._edgeList.get(C),rt=F.getSym();null===_&&(_=rt),null!==m&&rt.setNext(m),m=F}_.setNext(m)},h.prototype.computeDepths=function(){if(1===arguments.length){var m=arguments[0],_=this.findIndex(m),C=m.getDepth(an.LEFT),F=m.getDepth(an.RIGHT),rt=this.computeDepths(_+1,this._edgeList.size(),C);if(this.computeDepths(0,_,rt)!==F)throw new Ss("depth mismatch at "+m.getCoordinate())}else if(3===arguments.length){for(var qt=arguments[1],fe=arguments[2],ke=arguments[0];ke<qt;ke++){var Ge=this._edgeList.get(ke);Ge.setEdgeDepths(an.RIGHT,fe),fe=Ge.getDepth(an.LEFT)}return fe}},h.prototype.mergeSymLabels=function(){for(var m=this.iterator();m.hasNext();){var _=m.next();_.getLabel().merge(_.getSym().getLabel())}},h.prototype.linkMinimalDirectedEdges=function(m){for(var _=null,C=null,F=this._SCANNING_FOR_INCOMING,rt=this._resultAreaEdgeList.size()-1;rt>=0;rt--){var Dt=this._resultAreaEdgeList.get(rt),qt=Dt.getSym();switch(null===_&&Dt.getEdgeRing()===m&&(_=Dt),F){case this._SCANNING_FOR_INCOMING:if(qt.getEdgeRing()!==m)continue;C=qt,F=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(Dt.getEdgeRing()!==m)continue;C.setNextMin(Dt),F=this._SCANNING_FOR_INCOMING}}F===this._LINKING_TO_OUTGOING&&(Nn.isTrue(null!==_,"found null for first outgoing dirEdge"),Nn.isTrue(_.getEdgeRing()===m,"unable to link last incoming dirEdge"),C.setNextMin(_))},h.prototype.getOutgoingDegree=function(){if(0===arguments.length){for(var m=0,_=this.iterator();_.hasNext();)_.next().isInResult()&&m++;return m}if(1===arguments.length){for(var C=arguments[0],F=0,rt=this.iterator();rt.hasNext();)rt.next().getEdgeRing()===C&&F++;return F}},h.prototype.getLabel=function(){return this._label},h.prototype.findCoveredLineEdges=function(){for(var m=nt.NONE,_=this.iterator();_.hasNext();){var C=_.next(),F=C.getSym();if(!C.isLineEdge()){if(C.isInResult()){m=nt.INTERIOR;break}if(F.isInResult()){m=nt.EXTERIOR;break}}}if(m===nt.NONE)return null;for(var rt=m,Dt=this.iterator();Dt.hasNext();){var qt=Dt.next(),fe=qt.getSym();qt.isLineEdge()?qt.getEdge().setCovered(rt===nt.INTERIOR):(qt.isInResult()&&(rt=nt.EXTERIOR),fe.isInResult()&&(rt=nt.INTERIOR))}},h.prototype.computeLabelling=function(m){l.prototype.computeLabelling.call(this,m),this._label=new We(nt.NONE);for(var _=this.iterator();_.hasNext();)for(var C=_.next().getEdge().getLabel(),F=0;F<2;F++){var rt=C.getLocation(F);rt!==nt.INTERIOR&&rt!==nt.BOUNDARY||this._label.setLocation(F,nt.INTERIOR)}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Fs),zo=function(l){function h(){l.apply(this,arguments)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.createNode=function(m){return new Pr(m,new ya)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Fo),va=function l(){this._pts=null,this._orientation=null;var h=arguments[0];this._pts=h,this._orientation=l.orientation(h)};va.prototype.compareTo=function(l){return va.compareOriented(this._pts,this._orientation,l._pts,l._orientation)},va.prototype.interfaces_=function(){return[q]},va.prototype.getClass=function(){return va},va.orientation=function(l){return 1===un.increasingDirection(l)},va.compareOriented=function(l,h,m,_){for(var C=h?1:-1,F=_?1:-1,rt=h?l.length:-1,Dt=_?m.length:-1,qt=h?0:l.length-1,fe=_?0:m.length-1;;){var ke=l[qt].compareTo(m[fe]);if(0!==ke)return ke;var Ge=(qt+=C)===rt,xn=(fe+=F)===Dt;if(Ge&&!xn)return-1;if(!Ge&&xn)return 1;if(Ge&&xn)return 0}};var po=function(){this._edges=new ue,this._ocaMap=new Z};po.prototype.print=function(l){l.print("MULTILINESTRING ( ");for(var h=0;h<this._edges.size();h++){var m=this._edges.get(h);h>0&&l.print(","),l.print("(");for(var _=m.getCoordinates(),C=0;C<_.length;C++)C>0&&l.print(","),l.print(_[C].x+" "+_[C].y);l.println(")")}l.print(")  ")},po.prototype.addAll=function(l){for(var h=l.iterator();h.hasNext();)this.add(h.next())},po.prototype.findEdgeIndex=function(l){for(var h=0;h<this._edges.size();h++)if(this._edges.get(h).equals(l))return h;return-1},po.prototype.iterator=function(){return this._edges.iterator()},po.prototype.getEdges=function(){return this._edges},po.prototype.get=function(l){return this._edges.get(l)},po.prototype.findEqualEdge=function(l){var h=new va(l.getCoordinates());return this._ocaMap.get(h)},po.prototype.add=function(l){this._edges.add(l);var h=new va(l.getCoordinates());this._ocaMap.put(h,l)},po.prototype.interfaces_=function(){return[]},po.prototype.getClass=function(){return po};var qo=function(){};qo.prototype.processIntersections=function(l,h,m,_){},qo.prototype.isDone=function(){},qo.prototype.interfaces_=function(){return[]},qo.prototype.getClass=function(){return qo};var Hn=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0,this._li=arguments[0]};Hn.prototype.isTrivialIntersection=function(l,h,m,_){if(l===m&&1===this._li.getIntersectionNum()){if(Hn.isAdjacentSegments(h,_))return!0;if(l.isClosed()){var C=l.size()-1;if(0===h&&_===C||0===_&&h===C)return!0}}return!1},Hn.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},Hn.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},Hn.prototype.getLineIntersector=function(){return this._li},Hn.prototype.hasProperIntersection=function(){return this._hasProper},Hn.prototype.processIntersections=function(l,h,m,_){if(l===m&&h===_)return null;this.numTests++;var C=l.getCoordinates()[h],F=l.getCoordinates()[h+1],rt=m.getCoordinates()[_],Dt=m.getCoordinates()[_+1];this._li.computeIntersection(C,F,rt,Dt),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(l,h,m,_)||(this._hasIntersection=!0,l.addIntersections(this._li,h,0),m.addIntersections(this._li,_,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))},Hn.prototype.hasIntersection=function(){return this._hasIntersection},Hn.prototype.isDone=function(){return!1},Hn.prototype.hasInteriorIntersection=function(){return this._hasInterior},Hn.prototype.interfaces_=function(){return[qo]},Hn.prototype.getClass=function(){return Hn},Hn.isAdjacentSegments=function(l,h){return 1===Math.abs(l-h)};var Ao=function(){this.coord=null,this.segmentIndex=null,this.dist=null;var h=arguments[1],m=arguments[2];this.coord=new B(arguments[0]),this.segmentIndex=h,this.dist=m};Ao.prototype.getSegmentIndex=function(){return this.segmentIndex},Ao.prototype.getCoordinate=function(){return this.coord},Ao.prototype.print=function(l){l.print(this.coord),l.print(" seg # = "+this.segmentIndex),l.println(" dist = "+this.dist)},Ao.prototype.compareTo=function(l){return this.compare(l.segmentIndex,l.dist)},Ao.prototype.isEndPoint=function(l){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===l},Ao.prototype.toString=function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},Ao.prototype.getDistance=function(){return this.dist},Ao.prototype.compare=function(l,h){return this.segmentIndex<l?-1:this.segmentIndex>l?1:this.dist<h?-1:this.dist>h?1:0},Ao.prototype.interfaces_=function(){return[q]},Ao.prototype.getClass=function(){return Ao};var Mn=function(){this._nodeMap=new Z,this.edge=null,this.edge=arguments[0]};Mn.prototype.print=function(l){l.println("Intersections:");for(var h=this.iterator();h.hasNext();)h.next().print(l)},Mn.prototype.iterator=function(){return this._nodeMap.values().iterator()},Mn.prototype.addSplitEdges=function(l){this.addEndpoints();for(var h=this.iterator(),m=h.next();h.hasNext();){var _=h.next(),C=this.createSplitEdge(m,_);l.add(C),m=_}},Mn.prototype.addEndpoints=function(){var l=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[l],l,0)},Mn.prototype.createSplitEdge=function(l,h){var m=h.segmentIndex-l.segmentIndex+2,C=h.dist>0||!h.coord.equals2D(this.edge.pts[h.segmentIndex]);C||m--;var F=new Array(m).fill(null),rt=0;F[rt++]=new B(l.coord);for(var Dt=l.segmentIndex+1;Dt<=h.segmentIndex;Dt++)F[rt++]=this.edge.pts[Dt];return C&&(F[rt]=h.coord),new iu(F,new We(this.edge._label))},Mn.prototype.add=function(l,h,m){var _=new Ao(l,h,m),C=this._nodeMap.get(_);return null!==C?C:(this._nodeMap.put(_,_),_)},Mn.prototype.isIntersection=function(l){for(var h=this.iterator();h.hasNext();)if(h.next().coord.equals(l))return!0;return!1},Mn.prototype.interfaces_=function(){return[]},Mn.prototype.getClass=function(){return Mn};var ua=function(){};ua.prototype.getChainStartIndices=function(l){var h=0,m=new ue;m.add(new xt(h));do{var _=this.findChainEnd(l,h);m.add(new xt(_)),h=_}while(h<l.length-1);return ua.toIntArray(m)},ua.prototype.findChainEnd=function(l,h){for(var m=Wr.quadrant(l[h],l[h+1]),_=h+1;_<l.length&&Wr.quadrant(l[_-1],l[_])===m;)_++;return _-1},ua.prototype.interfaces_=function(){return[]},ua.prototype.getClass=function(){return ua},ua.toIntArray=function(l){for(var h=new Array(l.size()).fill(null),m=0;m<h.length;m++)h[m]=l.get(m).intValue();return h};var _a=function(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new De,this.env2=new De;var l=arguments[0];this.e=l,this.pts=l.getCoordinates();var h=new ua;this.startIndex=h.getChainStartIndices(this.pts)};_a.prototype.getCoordinates=function(){return this.pts},_a.prototype.getMaxX=function(l){var h=this.pts[this.startIndex[l]].x,m=this.pts[this.startIndex[l+1]].x;return h>m?h:m},_a.prototype.getMinX=function(l){var h=this.pts[this.startIndex[l]].x,m=this.pts[this.startIndex[l+1]].x;return h<m?h:m},_a.prototype.computeIntersectsForChain=function(){if(4===arguments.length){var l=arguments[0],h=arguments[1],m=arguments[2];this.computeIntersectsForChain(this.startIndex[l],this.startIndex[l+1],h,h.startIndex[m],h.startIndex[m+1],arguments[3])}else if(6===arguments.length){var C=arguments[0],F=arguments[1],rt=arguments[2],Dt=arguments[3],qt=arguments[4],fe=arguments[5],ke=this.pts[C],Ge=this.pts[F],xn=rt.pts[Dt],Sn=rt.pts[qt];if(F-C==1&&qt-Dt==1)return fe.addIntersections(this.e,C,rt.e,Dt),null;if(this.env1.init(ke,Ge),this.env2.init(xn,Sn),!this.env1.intersects(this.env2))return null;var Un=Math.trunc((C+F)/2),ur=Math.trunc((Dt+qt)/2);C<Un&&(Dt<ur&&this.computeIntersectsForChain(C,Un,rt,Dt,ur,fe),ur<qt&&this.computeIntersectsForChain(C,Un,rt,ur,qt,fe)),Un<F&&(Dt<ur&&this.computeIntersectsForChain(Un,F,rt,Dt,ur,fe),ur<qt&&this.computeIntersectsForChain(Un,F,rt,ur,qt,fe))}},_a.prototype.getStartIndexes=function(){return this.startIndex},_a.prototype.computeIntersects=function(l,h){for(var m=0;m<this.startIndex.length-1;m++)for(var _=0;_<l.startIndex.length-1;_++)this.computeIntersectsForChain(m,l,_,h)},_a.prototype.interfaces_=function(){return[]},_a.prototype.getClass=function(){return _a};var ls=function l(){this._depth=Array(2).fill().map(function(){return Array(3)});for(var h=0;h<2;h++)for(var m=0;m<3;m++)this._depth[h][m]=l.NULL_VALUE},mo={NULL_VALUE:{configurable:!0}};ls.prototype.getDepth=function(l,h){return this._depth[l][h]},ls.prototype.setDepth=function(l,h,m){this._depth[l][h]=m},ls.prototype.isNull=function(){if(0===arguments.length){for(var l=0;l<2;l++)for(var h=0;h<3;h++)if(this._depth[l][h]!==ls.NULL_VALUE)return!1;return!0}return 1===arguments.length?this._depth[arguments[0]][1]===ls.NULL_VALUE:2===arguments.length?this._depth[arguments[0]][arguments[1]]===ls.NULL_VALUE:void 0},ls.prototype.normalize=function(){for(var l=0;l<2;l++)if(!this.isNull(l)){var h=this._depth[l][1];this._depth[l][2]<h&&(h=this._depth[l][2]),h<0&&(h=0);for(var m=1;m<3;m++){var _=0;this._depth[l][m]>h&&(_=1),this._depth[l][m]=_}}},ls.prototype.getDelta=function(l){return this._depth[l][an.RIGHT]-this._depth[l][an.LEFT]},ls.prototype.getLocation=function(l,h){return this._depth[l][h]<=0?nt.EXTERIOR:nt.INTERIOR},ls.prototype.toString=function(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]},ls.prototype.add=function(){if(1===arguments.length)for(var l=arguments[0],h=0;h<2;h++)for(var m=1;m<3;m++){var _=l.getLocation(h,m);_!==nt.EXTERIOR&&_!==nt.INTERIOR||(this.isNull(h,m)?this._depth[h][m]=ls.depthAtLocation(_):this._depth[h][m]+=ls.depthAtLocation(_))}else 3===arguments.length&&arguments[2]===nt.INTERIOR&&this._depth[arguments[0]][arguments[1]]++},ls.prototype.interfaces_=function(){return[]},ls.prototype.getClass=function(){return ls},ls.depthAtLocation=function(l){return l===nt.EXTERIOR?0:l===nt.INTERIOR?1:ls.NULL_VALUE},mo.NULL_VALUE.get=function(){return-1},Object.defineProperties(ls,mo);var iu=function(l){function h(){if(l.call(this),this.pts=null,this._env=null,this.eiList=new Mn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new ls,this._depthDelta=0,1===arguments.length)h.call(this,arguments[0],null);else if(2===arguments.length){var C=arguments[1];this.pts=arguments[0],this._label=C}}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.getDepth=function(){return this._depth},h.prototype.getCollapsedEdge=function(){var m=new Array(2).fill(null);return m[0]=this.pts[0],m[1]=this.pts[1],new h(m,We.toLineLabel(this._label))},h.prototype.isIsolated=function(){return this._isIsolated},h.prototype.getCoordinates=function(){return this.pts},h.prototype.setIsolated=function(m){this._isIsolated=m},h.prototype.setName=function(m){this._name=m},h.prototype.equals=function(m){if(!(m instanceof h))return!1;var _=m;if(this.pts.length!==_.pts.length)return!1;for(var C=!0,F=!0,rt=this.pts.length,Dt=0;Dt<this.pts.length;Dt++)if(this.pts[Dt].equals2D(_.pts[Dt])||(C=!1),this.pts[Dt].equals2D(_.pts[--rt])||(F=!1),!C&&!F)return!1;return!0},h.prototype.getCoordinate=function(){return 0===arguments.length?this.pts.length>0?this.pts[0]:null:1===arguments.length?this.pts[arguments[0]]:void 0},h.prototype.print=function(m){m.print("edge "+this._name+": "),m.print("LINESTRING (");for(var _=0;_<this.pts.length;_++)_>0&&m.print(","),m.print(this.pts[_].x+" "+this.pts[_].y);m.print(")  "+this._label+" "+this._depthDelta)},h.prototype.computeIM=function(m){h.updateIM(this._label,m)},h.prototype.isCollapsed=function(){return!!this._label.isArea()&&3===this.pts.length&&!!this.pts[0].equals(this.pts[2])},h.prototype.isClosed=function(){return this.pts[0].equals(this.pts[this.pts.length-1])},h.prototype.getMaximumSegmentIndex=function(){return this.pts.length-1},h.prototype.getDepthDelta=function(){return this._depthDelta},h.prototype.getNumPoints=function(){return this.pts.length},h.prototype.printReverse=function(m){m.print("edge "+this._name+": ");for(var _=this.pts.length-1;_>=0;_--)m.print(this.pts[_]+" ");m.println("")},h.prototype.getMonotoneChainEdge=function(){return null===this._mce&&(this._mce=new _a(this)),this._mce},h.prototype.getEnvelope=function(){if(null===this._env){this._env=new De;for(var m=0;m<this.pts.length;m++)this._env.expandToInclude(this.pts[m])}return this._env},h.prototype.addIntersection=function(m,_,C,F){var rt=new B(m.getIntersection(F)),Dt=_,qt=m.getEdgeDistance(C,F),fe=Dt+1;fe<this.pts.length&&rt.equals2D(this.pts[fe])&&(Dt=fe,qt=0),this.eiList.add(rt,Dt,qt)},h.prototype.toString=function(){var m=new vt;m.append("edge "+this._name+": "),m.append("LINESTRING (");for(var _=0;_<this.pts.length;_++)_>0&&m.append(","),m.append(this.pts[_].x+" "+this.pts[_].y);return m.append(")  "+this._label+" "+this._depthDelta),m.toString()},h.prototype.isPointwiseEqual=function(m){if(this.pts.length!==m.pts.length)return!1;for(var _=0;_<this.pts.length;_++)if(!this.pts[_].equals2D(m.pts[_]))return!1;return!0},h.prototype.setDepthDelta=function(m){this._depthDelta=m},h.prototype.getEdgeIntersectionList=function(){return this.eiList},h.prototype.addIntersections=function(m,_,C){for(var F=0;F<m.getIntersectionNum();F++)this.addIntersection(m,_,C,F)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.updateIM=function(){if(2!==arguments.length)return l.prototype.updateIM.apply(this,arguments);var m=arguments[0],_=arguments[1];_.setAtLeastIfValid(m.getLocation(0,an.ON),m.getLocation(1,an.ON),1),m.isArea()&&(_.setAtLeastIfValid(m.getLocation(0,an.LEFT),m.getLocation(1,an.LEFT),2),_.setAtLeastIfValid(m.getLocation(0,an.RIGHT),m.getLocation(1,an.RIGHT),2))},h}(Kn),Ys=function(l){this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new po,this._bufParams=l||null};Ys.prototype.setWorkingPrecisionModel=function(l){this._workingPrecisionModel=l},Ys.prototype.insertUniqueEdge=function(l){var h=this._edgeList.findEqualEdge(l);if(null!==h){var m=h.getLabel(),_=l.getLabel();h.isPointwiseEqual(l)||(_=new We(l.getLabel())).flip(),m.merge(_);var C=Ys.depthDelta(_),F=h.getDepthDelta()+C;h.setDepthDelta(F)}else this._edgeList.add(l),l.setDepthDelta(Ys.depthDelta(l.getLabel()))},Ys.prototype.buildSubgraphs=function(l,h){for(var m=new ue,_=l.iterator();_.hasNext();){var C=_.next(),F=C.getRightmostCoordinate(),rt=new Bo(m).getDepth(F);C.computeDepth(rt),C.findResultEdges(),m.add(C),h.add(C.getDirectedEdges(),C.getNodes())}},Ys.prototype.createSubgraphs=function(l){for(var h=new ue,m=l.getNodes().iterator();m.hasNext();){var _=m.next();if(!_.isVisited()){var C=new ks;C.create(_),h.add(C)}}return Yt.sort(h,Yt.reverseOrder()),h},Ys.prototype.createEmptyResultGeometry=function(){return this._geomFact.createPolygon()},Ys.prototype.getNoder=function(l){if(null!==this._workingNoder)return this._workingNoder;var h=new Oc,m=new di;return m.setPrecisionModel(l),h.setSegmentIntersector(new Hn(m)),h},Ys.prototype.buffer=function(l,h){var m=this._workingPrecisionModel;null===m&&(m=l.getPrecisionModel()),this._geomFact=l.getFactory();var _=new he(m,this._bufParams),C=new es(l,h,_).getCurves();if(C.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(C,m),this._graph=new Or(new zo),this._graph.addEdges(this._edgeList.getEdges());var F=this.createSubgraphs(this._graph),rt=new os(this._geomFact);this.buildSubgraphs(F,rt);var Dt=rt.getPolygons();return Dt.size()<=0?this.createEmptyResultGeometry():this._geomFact.buildGeometry(Dt)},Ys.prototype.computeNodedEdges=function(l,h){var m=this.getNoder(h);m.computeNodes(l);for(var _=m.getNodedSubstrings().iterator();_.hasNext();){var C=_.next(),F=C.getCoordinates();if(2!==F.length||!F[0].equals2D(F[1])){var rt=C.getData(),Dt=new iu(C.getCoordinates(),new We(rt));this.insertUniqueEdge(Dt)}}},Ys.prototype.setNoder=function(l){this._workingNoder=l},Ys.prototype.interfaces_=function(){return[]},Ys.prototype.getClass=function(){return Ys},Ys.depthDelta=function(l){var h=l.getLocation(0,an.LEFT),m=l.getLocation(0,an.RIGHT);return h===nt.INTERIOR&&m===nt.EXTERIOR?1:h===nt.EXTERIOR&&m===nt.INTERIOR?-1:0},Ys.convertSegStrings=function(l){for(var h=new er,m=new ue;l.hasNext();){var _=l.next(),C=h.createLineString(_.getCoordinates());m.add(C)}return h.buildGeometry(m)};var $s=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){var h=arguments[1];this._noder=arguments[0],this._scaleFactor=h,this._offsetX=0,this._offsetY=0,this._isScaled=!this.isIntegerPrecision()}else if(4===arguments.length){var _=arguments[1],C=arguments[2],F=arguments[3];this._noder=arguments[0],this._scaleFactor=_,this._offsetX=C,this._offsetY=F,this._isScaled=!this.isIntegerPrecision()}};$s.prototype.rescale=function(){if(O(arguments[0],je))for(var l=arguments[0].iterator();l.hasNext();){var h=l.next();this.rescale(h.getCoordinates())}else if(arguments[0]instanceof Array){for(var m=arguments[0],_=0;_<m.length;_++)m[_].x=m[_].x/this._scaleFactor+this._offsetX,m[_].y=m[_].y/this._scaleFactor+this._offsetY;2===m.length&&m[0].equals2D(m[1])&&Xe.out.println(m)}},$s.prototype.scale=function(){if(O(arguments[0],je)){for(var l=arguments[0],h=new ue,m=l.iterator();m.hasNext();){var _=m.next();h.add(new Xr(this.scale(_.getCoordinates()),_.getData()))}return h}if(arguments[0]instanceof Array){for(var C=arguments[0],F=new Array(C.length).fill(null),rt=0;rt<C.length;rt++)F[rt]=new B(Math.round((C[rt].x-this._offsetX)*this._scaleFactor),Math.round((C[rt].y-this._offsetY)*this._scaleFactor),C[rt].z);return un.removeRepeatedPoints(F)}},$s.prototype.isIntegerPrecision=function(){return 1===this._scaleFactor},$s.prototype.getNodedSubstrings=function(){var l=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(l),l},$s.prototype.computeNodes=function(l){var h=l;this._isScaled&&(h=this.scale(l)),this._noder.computeNodes(h)},$s.prototype.interfaces_=function(){return[vs]},$s.prototype.getClass=function(){return $s};var Vo=function(){this._li=new di,this._segStrings=null,this._segStrings=arguments[0]},xa={fact:{configurable:!0}};Vo.prototype.checkEndPtVertexIntersections=function(){if(0===arguments.length)for(var l=this._segStrings.iterator();l.hasNext();){var h=l.next().getCoordinates();this.checkEndPtVertexIntersections(h[0],this._segStrings),this.checkEndPtVertexIntersections(h[h.length-1],this._segStrings)}else if(2===arguments.length)for(var m=arguments[0],_=arguments[1].iterator();_.hasNext();)for(var C=_.next().getCoordinates(),F=1;F<C.length-1;F++)if(C[F].equals(m))throw new Wn("found endpt/interior pt intersection at index "+F+" :pt "+m)},Vo.prototype.checkInteriorIntersections=function(){if(0===arguments.length)for(var l=this._segStrings.iterator();l.hasNext();)for(var h=l.next(),m=this._segStrings.iterator();m.hasNext();){var _=m.next();this.checkInteriorIntersections(h,_)}else if(2===arguments.length)for(var C=arguments[0],F=arguments[1],rt=C.getCoordinates(),Dt=F.getCoordinates(),qt=0;qt<rt.length-1;qt++)for(var fe=0;fe<Dt.length-1;fe++)this.checkInteriorIntersections(C,qt,F,fe);else if(4===arguments.length){var ke=arguments[0],Ge=arguments[1],xn=arguments[2],Sn=arguments[3];if(ke===xn&&Ge===Sn)return null;var Un=ke.getCoordinates()[Ge],ur=ke.getCoordinates()[Ge+1],Ji=xn.getCoordinates()[Sn],Do=xn.getCoordinates()[Sn+1];if(this._li.computeIntersection(Un,ur,Ji,Do),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,Un,ur)||this.hasInteriorIntersection(this._li,Ji,Do)))throw new Wn("found non-noded intersection at "+Un+"-"+ur+" and "+Ji+"-"+Do)}},Vo.prototype.checkValid=function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},Vo.prototype.checkCollapses=function(){if(0===arguments.length)for(var l=this._segStrings.iterator();l.hasNext();){var h=l.next();this.checkCollapses(h)}else if(1===arguments.length)for(var m=arguments[0].getCoordinates(),_=0;_<m.length-2;_++)this.checkCollapse(m[_],m[_+1],m[_+2])},Vo.prototype.hasInteriorIntersection=function(l,h,m){for(var _=0;_<l.getIntersectionNum();_++){var C=l.getIntersection(_);if(!C.equals(h)&&!C.equals(m))return!0}return!1},Vo.prototype.checkCollapse=function(l,h,m){if(l.equals(m))throw new Wn("found non-noded collapse at "+Vo.fact.createLineString([l,h,m]))},Vo.prototype.interfaces_=function(){return[]},Vo.prototype.getClass=function(){return Vo},xa.fact.get=function(){return new er},Object.defineProperties(Vo,xa);var mi=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;var l=arguments[0],h=arguments[1],m=arguments[2];if(this._originalPt=l,this._pt=l,this._scaleFactor=h,this._li=m,h<=0)throw new dt("Scale factor must be non-zero");1!==h&&(this._pt=new B(this.scale(l.x),this.scale(l.y)),this._p0Scaled=new B,this._p1Scaled=new B),this.initCorners(this._pt)},yi={SAFE_ENV_EXPANSION_FACTOR:{configurable:!0}};mi.prototype.intersectsScaled=function(l,h){var m=Math.min(l.x,h.x),_=Math.max(l.x,h.x),C=Math.min(l.y,h.y),F=Math.max(l.y,h.y),rt=this._maxx<m||this._minx>_||this._maxy<C||this._miny>F;if(rt)return!1;var Dt=this.intersectsToleranceSquare(l,h);return Nn.isTrue(!(rt&&Dt),"Found bad envelope test"),Dt},mi.prototype.initCorners=function(l){this._minx=l.x-.5,this._maxx=l.x+.5,this._miny=l.y-.5,this._maxy=l.y+.5,this._corner[0]=new B(this._maxx,this._maxy),this._corner[1]=new B(this._minx,this._maxy),this._corner[2]=new B(this._minx,this._miny),this._corner[3]=new B(this._maxx,this._miny)},mi.prototype.intersects=function(l,h){return 1===this._scaleFactor?this.intersectsScaled(l,h):(this.copyScaled(l,this._p0Scaled),this.copyScaled(h,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))},mi.prototype.scale=function(l){return Math.round(l*this._scaleFactor)},mi.prototype.getCoordinate=function(){return this._originalPt},mi.prototype.copyScaled=function(l,h){h.x=this.scale(l.x),h.y=this.scale(l.y)},mi.prototype.getSafeEnvelope=function(){if(null===this._safeEnv){var l=mi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new De(this._originalPt.x-l,this._originalPt.x+l,this._originalPt.y-l,this._originalPt.y+l)}return this._safeEnv},mi.prototype.intersectsPixelClosure=function(l,h){return this._li.computeIntersection(l,h,this._corner[0],this._corner[1]),!!(this._li.hasIntersection()||(this._li.computeIntersection(l,h,this._corner[1],this._corner[2]),this._li.hasIntersection()||(this._li.computeIntersection(l,h,this._corner[2],this._corner[3]),this._li.hasIntersection()||(this._li.computeIntersection(l,h,this._corner[3],this._corner[0]),this._li.hasIntersection()))))},mi.prototype.intersectsToleranceSquare=function(l,h){var m=!1,_=!1;return this._li.computeIntersection(l,h,this._corner[0],this._corner[1]),!!(this._li.isProper()||(this._li.computeIntersection(l,h,this._corner[1],this._corner[2]),this._li.isProper()||(this._li.hasIntersection()&&(m=!0),this._li.computeIntersection(l,h,this._corner[2],this._corner[3]),this._li.isProper()||(this._li.hasIntersection()&&(_=!0),this._li.computeIntersection(l,h,this._corner[3],this._corner[0]),this._li.isProper()||m&&_||l.equals(this._pt)||h.equals(this._pt)))))},mi.prototype.addSnappedNode=function(l,h){var m=l.getCoordinate(h),_=l.getCoordinate(h+1);return!!this.intersects(m,_)&&(l.addIntersection(this.getCoordinate(),h),!0)},mi.prototype.interfaces_=function(){return[]},mi.prototype.getClass=function(){return mi},yi.SAFE_ENV_EXPANSION_FACTOR.get=function(){return.75},Object.defineProperties(mi,yi);var La=function(){this.tempEnv1=new De,this.selectedSegment=new tn};La.prototype.select=function(){1!==arguments.length&&2===arguments.length&&(arguments[0].getLineSegment(arguments[1],this.selectedSegment),this.select(this.selectedSegment))},La.prototype.interfaces_=function(){return[]},La.prototype.getClass=function(){return La};var Su=function(){this._index=null,this._index=arguments[0]},Ga={HotPixelSnapAction:{configurable:!0}};Su.prototype.snap=function(){if(1===arguments.length)return this.snap(arguments[0],null,-1);if(3===arguments.length){var h=arguments[0],m=arguments[1],_=arguments[2],C=h.getSafeEnvelope(),F=new pl(h,m,_);return this._index.query(C,{interfaces_:function(){return[M]},visitItem:function(rt){rt.select(C,F)}}),F.isNodeAdded()}},Su.prototype.interfaces_=function(){return[]},Su.prototype.getClass=function(){return Su},Ga.HotPixelSnapAction.get=function(){return pl},Object.defineProperties(Su,Ga);var pl=function(l){function h(){l.call(this),this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;var _=arguments[1],C=arguments[2];this._hotPixel=arguments[0],this._parentEdge=_,this._hotPixelVertexIndex=C}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.isNodeAdded=function(){return this._isNodeAdded},h.prototype.select=function(){if(2!==arguments.length)return l.prototype.select.apply(this,arguments);var _=arguments[1],C=arguments[0].getContext();if(null!==this._parentEdge&&C===this._parentEdge&&_===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(C,_)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(La),Jo=function(){this._li=null,this._interiorIntersections=null,this._li=arguments[0],this._interiorIntersections=new ue};Jo.prototype.processIntersections=function(l,h,m,_){if(l===m&&h===_)return null;var C=l.getCoordinates()[h],F=l.getCoordinates()[h+1],rt=m.getCoordinates()[_],Dt=m.getCoordinates()[_+1];if(this._li.computeIntersection(C,F,rt,Dt),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(var qt=0;qt<this._li.getIntersectionNum();qt++)this._interiorIntersections.add(this._li.getIntersection(qt));l.addIntersections(this._li,h,0),m.addIntersections(this._li,_,1)}},Jo.prototype.isDone=function(){return!1},Jo.prototype.getInteriorIntersections=function(){return this._interiorIntersections},Jo.prototype.interfaces_=function(){return[qo]},Jo.prototype.getClass=function(){return Jo};var Uo=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;var l=arguments[0];this._pm=l,this._li=new di,this._li.setPrecisionModel(l),this._scaleFactor=l.getScale()};Uo.prototype.checkCorrectness=function(l){var h=Xr.getNodedSubstrings(l),m=new Vo(h);try{m.checkValid()}catch(_){if(!(_ instanceof we))throw _;_.printStackTrace()}},Uo.prototype.getNodedSubstrings=function(){return Xr.getNodedSubstrings(this._nodedSegStrings)},Uo.prototype.snapRound=function(l,h){var m=this.findInteriorIntersections(l,h);this.computeIntersectionSnaps(m),this.computeVertexSnaps(l)},Uo.prototype.findInteriorIntersections=function(l,h){var m=new Jo(h);return this._noder.setSegmentIntersector(m),this._noder.computeNodes(l),m.getInteriorIntersections()},Uo.prototype.computeVertexSnaps=function(){if(O(arguments[0],je))for(var l=arguments[0].iterator();l.hasNext();){var h=l.next();this.computeVertexSnaps(h)}else if(arguments[0]instanceof Xr)for(var m=arguments[0],_=m.getCoordinates(),C=0;C<_.length;C++){var F=new mi(_[C],this._scaleFactor,this._li);this._pointSnapper.snap(F,m,C)&&m.addIntersection(_[C],C)}},Uo.prototype.computeNodes=function(l){this._nodedSegStrings=l,this._noder=new Oc,this._pointSnapper=new Su(this._noder.getIndex()),this.snapRound(l,this._li)},Uo.prototype.computeIntersectionSnaps=function(l){for(var h=l.iterator();h.hasNext();){var m=h.next(),_=new mi(m,this._scaleFactor,this._li);this._pointSnapper.snap(_)}},Uo.prototype.interfaces_=function(){return[vs]},Uo.prototype.getClass=function(){return Uo};var Ts=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new Zr,this._resultGeometry=null,this._saveException=null,1===arguments.length)this._argGeom=arguments[0];else if(2===arguments.length){var m=arguments[1];this._argGeom=arguments[0],this._bufParams=m}},Du={CAP_ROUND:{configurable:!0},CAP_BUTT:{configurable:!0},CAP_FLAT:{configurable:!0},CAP_SQUARE:{configurable:!0},MAX_PRECISION_DIGITS:{configurable:!0}};Ts.prototype.bufferFixedPrecision=function(l){var h=new $s(new Uo(new An(1)),l.getScale()),m=new Ys(this._bufParams);m.setWorkingPrecisionModel(l),m.setNoder(h),this._resultGeometry=m.buffer(this._argGeom,this._distance)},Ts.prototype.bufferReducedPrecision=function(){var l=this;if(0===arguments.length){for(var h=Ts.MAX_PRECISION_DIGITS;h>=0;h--){try{l.bufferReducedPrecision(h)}catch(F){if(!(F instanceof Ss))throw F;l._saveException=F}if(null!==l._resultGeometry)return null}throw this._saveException}if(1===arguments.length){var _=Ts.precisionScaleFactor(this._argGeom,this._distance,arguments[0]),C=new An(_);this.bufferFixedPrecision(C)}},Ts.prototype.computeGeometry=function(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;var l=this._argGeom.getFactory().getPrecisionModel();l.getType()===An.FIXED?this.bufferFixedPrecision(l):this.bufferReducedPrecision()},Ts.prototype.setQuadrantSegments=function(l){this._bufParams.setQuadrantSegments(l)},Ts.prototype.bufferOriginalPrecision=function(){try{var l=new Ys(this._bufParams);this._resultGeometry=l.buffer(this._argGeom,this._distance)}catch(h){if(!(h instanceof Wn))throw h;this._saveException=h}},Ts.prototype.getResultGeometry=function(l){return this._distance=l,this.computeGeometry(),this._resultGeometry},Ts.prototype.setEndCapStyle=function(l){this._bufParams.setEndCapStyle(l)},Ts.prototype.interfaces_=function(){return[]},Ts.prototype.getClass=function(){return Ts},Ts.bufferOp=function(){if(2===arguments.length){var h=arguments[1];return new Ts(arguments[0]).getResultGeometry(h)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Gn&&"number"==typeof arguments[1]){var _=arguments[1],C=arguments[2],F=new Ts(arguments[0]);return F.setQuadrantSegments(C),F.getResultGeometry(_)}if(arguments[2]instanceof Zr&&arguments[0]instanceof Gn&&"number"==typeof arguments[1]){var Dt=arguments[1];return new Ts(arguments[0],arguments[2]).getResultGeometry(Dt)}}else if(4===arguments.length){var ke=arguments[1],Ge=arguments[2],xn=arguments[3],Sn=new Ts(arguments[0]);return Sn.setQuadrantSegments(Ge),Sn.setEndCapStyle(xn),Sn.getResultGeometry(ke)}},Ts.precisionScaleFactor=function(l,h,m){var _=l.getEnvelopeInternal(),C=Ct.max(Math.abs(_.getMaxX()),Math.abs(_.getMaxY()),Math.abs(_.getMinX()),Math.abs(_.getMinY()))+2*(h>0?h:0),F=m-Math.trunc(Math.log(C)/Math.log(10)+1);return Math.pow(10,F)},Du.CAP_ROUND.get=function(){return Zr.CAP_ROUND},Du.CAP_BUTT.get=function(){return Zr.CAP_FLAT},Du.CAP_FLAT.get=function(){return Zr.CAP_FLAT},Du.CAP_SQUARE.get=function(){return Zr.CAP_SQUARE},Du.MAX_PRECISION_DIGITS.get=function(){return 12},Object.defineProperties(Ts,Du);var Bs=function(){this._pt=[new B,new B],this._distance=lt.NaN,this._isNull=!0};Bs.prototype.getCoordinates=function(){return this._pt},Bs.prototype.getCoordinate=function(l){return this._pt[l]},Bs.prototype.setMinimum=function(){if(1===arguments.length){var l=arguments[0];this.setMinimum(l._pt[0],l._pt[1])}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this._isNull)return this.initialize(h,m),null;var _=h.distance(m);_<this._distance&&this.initialize(h,m,_)}},Bs.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var l=arguments[0],h=arguments[1];this._pt[0].setCoordinate(l),this._pt[1].setCoordinate(h),this._distance=l.distance(h),this._isNull=!1}else if(3===arguments.length){var _=arguments[1],C=arguments[2];this._pt[0].setCoordinate(arguments[0]),this._pt[1].setCoordinate(_),this._distance=C,this._isNull=!1}},Bs.prototype.getDistance=function(){return this._distance},Bs.prototype.setMaximum=function(){if(1===arguments.length){var l=arguments[0];this.setMaximum(l._pt[0],l._pt[1])}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this._isNull)return this.initialize(h,m),null;var _=h.distance(m);_>this._distance&&this.initialize(h,m,_)}},Bs.prototype.interfaces_=function(){return[]},Bs.prototype.getClass=function(){return Bs};var Wo=function(){};Wo.prototype.interfaces_=function(){return[]},Wo.prototype.getClass=function(){return Wo},Wo.computeDistance=function(){if(arguments[2]instanceof Bs&&arguments[0]instanceof Vr&&arguments[1]instanceof B)for(var h=arguments[1],m=arguments[2],_=arguments[0].getCoordinates(),C=new tn,F=0;F<_.length-1;F++){C.setCoordinates(_[F],_[F+1]);var rt=C.closestPoint(h);m.setMinimum(rt,h)}else if(arguments[2]instanceof Bs&&arguments[0]instanceof rs&&arguments[1]instanceof B){var Dt=arguments[0],qt=arguments[1],fe=arguments[2];Wo.computeDistance(Dt.getExteriorRing(),qt,fe);for(var ke=0;ke<Dt.getNumInteriorRing();ke++)Wo.computeDistance(Dt.getInteriorRingN(ke),qt,fe)}else if(arguments[2]instanceof Bs&&arguments[0]instanceof Gn&&arguments[1]instanceof B){var Ge=arguments[0],xn=arguments[1],Sn=arguments[2];if(Ge instanceof Vr)Wo.computeDistance(Ge,xn,Sn);else if(Ge instanceof rs)Wo.computeDistance(Ge,xn,Sn);else if(Ge instanceof zr)for(var Un=Ge,ur=0;ur<Un.getNumGeometries();ur++){var Ji=Un.getGeometryN(ur);Wo.computeDistance(Ji,xn,Sn)}else Sn.setMinimum(Ge.getCoordinate(),xn)}else if(arguments[2]instanceof Bs&&arguments[0]instanceof tn&&arguments[1]instanceof B){var Fa=arguments[1],ml=arguments[2],Kl=arguments[0].closestPoint(Fa);ml.setMinimum(Kl,Fa)}};var Ea=function(l){this._maxPtDist=new Bs,this._inputGeom=l||null},Tu={MaxPointDistanceFilter:{configurable:!0},MaxMidpointDistanceFilter:{configurable:!0}};Ea.prototype.computeMaxMidpointDistance=function(l){var h=new Ha(this._inputGeom);l.apply(h),this._maxPtDist.setMaximum(h.getMaxPointDistance())},Ea.prototype.computeMaxVertexDistance=function(l){var h=new mu(this._inputGeom);l.apply(h),this._maxPtDist.setMaximum(h.getMaxPointDistance())},Ea.prototype.findDistance=function(l){return this.computeMaxVertexDistance(l),this.computeMaxMidpointDistance(l),this._maxPtDist.getDistance()},Ea.prototype.getDistancePoints=function(){return this._maxPtDist},Ea.prototype.interfaces_=function(){return[]},Ea.prototype.getClass=function(){return Ea},Tu.MaxPointDistanceFilter.get=function(){return mu},Tu.MaxMidpointDistanceFilter.get=function(){return Ha},Object.defineProperties(Ea,Tu);var mu=function(l){this._maxPtDist=new Bs,this._minPtDist=new Bs,this._geom=l||null};mu.prototype.filter=function(l){this._minPtDist.initialize(),Wo.computeDistance(this._geom,l,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},mu.prototype.getMaxPointDistance=function(){return this._maxPtDist},mu.prototype.interfaces_=function(){return[Et]},mu.prototype.getClass=function(){return mu};var Ha=function(l){this._maxPtDist=new Bs,this._minPtDist=new Bs,this._geom=l||null};Ha.prototype.filter=function(l,h){if(0===h)return null;var m=l.getCoordinate(h-1),_=l.getCoordinate(h),C=new B((m.x+_.x)/2,(m.y+_.y)/2);this._minPtDist.initialize(),Wo.computeDistance(this._geom,C,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},Ha.prototype.isDone=function(){return!1},Ha.prototype.isGeometryChanged=function(){return!1},Ha.prototype.getMaxPointDistance=function(){return this._maxPtDist},Ha.prototype.interfaces_=function(){return[oi]},Ha.prototype.getClass=function(){return Ha};var Ca=function(l){this._comps=l||null};Ca.prototype.filter=function(l){l instanceof rs&&this._comps.add(l)},Ca.prototype.interfaces_=function(){return[fi]},Ca.prototype.getClass=function(){return Ca},Ca.getPolygons=function(){if(1===arguments.length)return Ca.getPolygons(arguments[0],new ue);if(2===arguments.length){var h=arguments[0],m=arguments[1];return h instanceof rs?m.add(h):h instanceof zr&&h.apply(new Ca(m)),m}};var Qs=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length)this._lines=arguments[0];else if(2===arguments.length){var m=arguments[1];this._lines=arguments[0],this._isForcedToLineString=m}};Qs.prototype.filter=function(l){if(this._isForcedToLineString&&l instanceof eo){var h=l.getFactory().createLineString(l.getCoordinateSequence());return this._lines.add(h),null}l instanceof Vr&&this._lines.add(l)},Qs.prototype.setForceToLineString=function(l){this._isForcedToLineString=l},Qs.prototype.interfaces_=function(){return[xo]},Qs.prototype.getClass=function(){return Qs},Qs.getGeometry=function(){if(1===arguments.length){var l=arguments[0];return l.getFactory().buildGeometry(Qs.getLines(l))}if(2===arguments.length){var h=arguments[0],m=arguments[1];return h.getFactory().buildGeometry(Qs.getLines(h,m))}},Qs.getLines=function(){if(1===arguments.length)return Qs.getLines(arguments[0],!1);if(2===arguments.length){if(O(arguments[0],je)&&O(arguments[1],je)){for(var m=arguments[1],_=arguments[0].iterator();_.hasNext();){var C=_.next();Qs.getLines(C,m)}return m}if(arguments[0]instanceof Gn&&"boolean"==typeof arguments[1]){var F=arguments[0],rt=arguments[1],Dt=new ue;return F.apply(new Qs(Dt,rt)),Dt}if(arguments[0]instanceof Gn&&O(arguments[1],je)){var qt=arguments[0],fe=arguments[1];return qt instanceof Vr?fe.add(qt):qt.apply(new Qs(fe)),fe}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&O(arguments[0],je)&&O(arguments[1],je)){for(var Ge=arguments[1],xn=arguments[2],Sn=arguments[0].iterator();Sn.hasNext();){var Un=Sn.next();Qs.getLines(Un,Ge,xn)}return Ge}if("boolean"==typeof arguments[2]&&arguments[0]instanceof Gn&&O(arguments[1],je)){var Ji=arguments[1];return arguments[0].apply(new Qs(Ji,arguments[2])),Ji}}};var ta=function(){if(this._boundaryRule=Rt.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0!==arguments.length&&1===arguments.length){var l=arguments[0];if(null===l)throw new dt("Rule must be non-null");this._boundaryRule=l}};ta.prototype.locateInternal=function(){if(arguments[0]instanceof B&&arguments[1]instanceof rs){var l=arguments[0],h=arguments[1];if(h.isEmpty())return nt.EXTERIOR;var m=h.getExteriorRing(),_=this.locateInPolygonRing(l,m);if(_===nt.EXTERIOR)return nt.EXTERIOR;if(_===nt.BOUNDARY)return nt.BOUNDARY;for(var C=0;C<h.getNumInteriorRing();C++){var F=h.getInteriorRingN(C),rt=this.locateInPolygonRing(l,F);if(rt===nt.INTERIOR)return nt.EXTERIOR;if(rt===nt.BOUNDARY)return nt.BOUNDARY}return nt.INTERIOR}if(arguments[0]instanceof B&&arguments[1]instanceof Vr){var Dt=arguments[0],qt=arguments[1];if(!qt.getEnvelopeInternal().intersects(Dt))return nt.EXTERIOR;var fe=qt.getCoordinates();return qt.isClosed()||!Dt.equals(fe[0])&&!Dt.equals(fe[fe.length-1])?yn.isOnLine(Dt,fe)?nt.INTERIOR:nt.EXTERIOR:nt.BOUNDARY}if(arguments[0]instanceof B&&arguments[1]instanceof Ls){var ke=arguments[0];return arguments[1].getCoordinate().equals2D(ke)?nt.INTERIOR:nt.EXTERIOR}},ta.prototype.locateInPolygonRing=function(l,h){return h.getEnvelopeInternal().intersects(l)?yn.locatePointInRing(l,h.getCoordinates()):nt.EXTERIOR},ta.prototype.intersects=function(l,h){return this.locate(l,h)!==nt.EXTERIOR},ta.prototype.updateLocationInfo=function(l){l===nt.INTERIOR&&(this._isIn=!0),l===nt.BOUNDARY&&this._numBoundaries++},ta.prototype.computeLocation=function(l,h){if(h instanceof Ls&&this.updateLocationInfo(this.locateInternal(l,h)),h instanceof Vr)this.updateLocationInfo(this.locateInternal(l,h));else if(h instanceof rs)this.updateLocationInfo(this.locateInternal(l,h));else if(h instanceof js)for(var m=h,_=0;_<m.getNumGeometries();_++){var C=m.getGeometryN(_);this.updateLocationInfo(this.locateInternal(l,C))}else if(h instanceof Co)for(var F=h,rt=0;rt<F.getNumGeometries();rt++){var Dt=F.getGeometryN(rt);this.updateLocationInfo(this.locateInternal(l,Dt))}else if(h instanceof zr)for(var qt=new ru(h);qt.hasNext();){var fe=qt.next();fe!==h&&this.computeLocation(l,fe)}},ta.prototype.locate=function(l,h){return h.isEmpty()?nt.EXTERIOR:h instanceof Vr||h instanceof rs?this.locateInternal(l,h):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(l,h),this._boundaryRule.isInBoundary(this._numBoundaries)?nt.BOUNDARY:this._numBoundaries>0||this._isIn?nt.INTERIOR:nt.EXTERIOR)},ta.prototype.interfaces_=function(){return[]},ta.prototype.getClass=function(){return ta};var go=function l(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length)l.call(this,arguments[0],l.INSIDE_AREA,arguments[1]);else if(3===arguments.length){var C=arguments[1],F=arguments[2];this._component=arguments[0],this._segIndex=C,this._pt=F}},ka={INSIDE_AREA:{configurable:!0}};go.prototype.isInsideArea=function(){return this._segIndex===go.INSIDE_AREA},go.prototype.getCoordinate=function(){return this._pt},go.prototype.getGeometryComponent=function(){return this._component},go.prototype.getSegmentIndex=function(){return this._segIndex},go.prototype.interfaces_=function(){return[]},go.prototype.getClass=function(){return go},ka.INSIDE_AREA.get=function(){return-1},Object.defineProperties(go,ka);var gu=function(l){this._pts=l||null};gu.prototype.filter=function(l){l instanceof Ls&&this._pts.add(l)},gu.prototype.interfaces_=function(){return[fi]},gu.prototype.getClass=function(){return gu},gu.getPoints=function(){if(1===arguments.length){var l=arguments[0];return l instanceof Ls?Yt.singletonList(l):gu.getPoints(l,new ue)}if(2===arguments.length){var h=arguments[0],m=arguments[1];return h instanceof Ls?m.add(h):h instanceof zr&&h.apply(new gu(m)),m}};var Io=function(){this._locations=null,this._locations=arguments[0]};Io.prototype.filter=function(l){(l instanceof Ls||l instanceof Vr||l instanceof rs)&&this._locations.add(new go(l,0,l.getCoordinate()))},Io.prototype.interfaces_=function(){return[fi]},Io.prototype.getClass=function(){return Io},Io.getLocations=function(l){var h=new ue;return l.apply(new Io(h)),h};var cs=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new ta,this._minDistanceLocation=null,this._minDistance=lt.MAX_VALUE,2===arguments.length)this._geom=[arguments[0],arguments[1]],this._terminateDistance=0;else if(3===arguments.length){var m=arguments[0],_=arguments[1],C=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=m,this._geom[1]=_,this._terminateDistance=C}};cs.prototype.computeContainmentDistance=function(){if(0===arguments.length){var l=new Array(2).fill(null);if(this.computeContainmentDistance(0,l),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,l)}else if(2===arguments.length){var h=arguments[0],m=arguments[1],_=1-h,C=Ca.getPolygons(this._geom[h]);if(C.size()>0){var F=Io.getLocations(this._geom[_]);if(this.computeContainmentDistance(F,C,m),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[_]=m[0],this._minDistanceLocation[h]=m[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&O(arguments[0],En)&&O(arguments[1],En)){for(var rt=arguments[0],Dt=arguments[1],qt=arguments[2],fe=0;fe<rt.size();fe++)for(var ke=rt.get(fe),Ge=0;Ge<Dt.size();Ge++)if(this.computeContainmentDistance(ke,Dt.get(Ge),qt),this._minDistance<=this._terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof go&&arguments[1]instanceof rs){var xn=arguments[0],Sn=arguments[1],Un=arguments[2],ur=xn.getCoordinate();if(nt.EXTERIOR!==this._ptLocator.locate(ur,Sn))return this._minDistance=0,Un[0]=xn,Un[1]=new go(Sn,ur),null}},cs.prototype.computeMinDistanceLinesPoints=function(l,h,m){for(var _=0;_<l.size();_++)for(var C=l.get(_),F=0;F<h.size();F++){var rt=h.get(F);if(this.computeMinDistance(C,rt,m),this._minDistance<=this._terminateDistance)return null}},cs.prototype.computeFacetDistance=function(){var l=new Array(2).fill(null),h=Qs.getLines(this._geom[0]),m=Qs.getLines(this._geom[1]),_=gu.getPoints(this._geom[0]),C=gu.getPoints(this._geom[1]);return this.computeMinDistanceLines(h,m,l),this.updateMinDistance(l,!1),this._minDistance<=this._terminateDistance?null:(l[0]=null,l[1]=null,this.computeMinDistanceLinesPoints(h,C,l),this.updateMinDistance(l,!1),this._minDistance<=this._terminateDistance?null:(l[0]=null,l[1]=null,this.computeMinDistanceLinesPoints(m,_,l),this.updateMinDistance(l,!0),this._minDistance<=this._terminateDistance?null:(l[0]=null,l[1]=null,this.computeMinDistancePoints(_,C,l),void this.updateMinDistance(l,!1))))},cs.prototype.nearestLocations=function(){return this.computeMinDistance(),this._minDistanceLocation},cs.prototype.updateMinDistance=function(l,h){if(null===l[0])return null;h?(this._minDistanceLocation[0]=l[1],this._minDistanceLocation[1]=l[0]):(this._minDistanceLocation[0]=l[0],this._minDistanceLocation[1]=l[1])},cs.prototype.nearestPoints=function(){return this.computeMinDistance(),[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]},cs.prototype.computeMinDistance=function(){if(0===arguments.length){if(null!==this._minDistanceLocation||(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance))return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Vr&&arguments[1]instanceof Ls){var l=arguments[0],h=arguments[1],m=arguments[2];if(l.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this._minDistance)return null;for(var _=l.getCoordinates(),C=h.getCoordinate(),F=0;F<_.length-1;F++){var rt=yn.distancePointLine(C,_[F],_[F+1]);if(rt<this._minDistance){this._minDistance=rt;var Dt=new tn(_[F],_[F+1]).closestPoint(C);m[0]=new go(l,F,Dt),m[1]=new go(h,0,C)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Vr&&arguments[1]instanceof Vr){var qt=arguments[0],fe=arguments[1],ke=arguments[2];if(qt.getEnvelopeInternal().distance(fe.getEnvelopeInternal())>this._minDistance)return null;for(var Ge=qt.getCoordinates(),xn=fe.getCoordinates(),Sn=0;Sn<Ge.length-1;Sn++)for(var Un=0;Un<xn.length-1;Un++){var ur=yn.distanceLineLine(Ge[Sn],Ge[Sn+1],xn[Un],xn[Un+1]);if(ur<this._minDistance){this._minDistance=ur;var Ji=new tn(Ge[Sn],Ge[Sn+1]),Do=new tn(xn[Un],xn[Un+1]),Fa=Ji.closestPoints(Do);ke[0]=new go(qt,Sn,Fa[0]),ke[1]=new go(fe,Un,Fa[1])}if(this._minDistance<=this._terminateDistance)return null}}},cs.prototype.computeMinDistancePoints=function(l,h,m){for(var _=0;_<l.size();_++)for(var C=l.get(_),F=0;F<h.size();F++){var rt=h.get(F),Dt=C.getCoordinate().distance(rt.getCoordinate());if(Dt<this._minDistance&&(this._minDistance=Dt,m[0]=new go(C,0,C.getCoordinate()),m[1]=new go(rt,0,rt.getCoordinate())),this._minDistance<=this._terminateDistance)return null}},cs.prototype.distance=function(){if(null===this._geom[0]||null===this._geom[1])throw new dt("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)},cs.prototype.computeMinDistanceLines=function(l,h,m){for(var _=0;_<l.size();_++)for(var C=l.get(_),F=0;F<h.size();F++){var rt=h.get(F);if(this.computeMinDistance(C,rt,m),this._minDistance<=this._terminateDistance)return null}},cs.prototype.interfaces_=function(){return[]},cs.prototype.getClass=function(){return cs},cs.distance=function(l,h){return new cs(l,h).distance()},cs.isWithinDistance=function(l,h,m){return new cs(l,h,m).distance()<=m},cs.nearestPoints=function(l,h){return new cs(l,h).nearestPoints()};var So=function(){this._pt=[new B,new B],this._distance=lt.NaN,this._isNull=!0};So.prototype.getCoordinates=function(){return this._pt},So.prototype.getCoordinate=function(l){return this._pt[l]},So.prototype.setMinimum=function(){if(1===arguments.length){var l=arguments[0];this.setMinimum(l._pt[0],l._pt[1])}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this._isNull)return this.initialize(h,m),null;var _=h.distance(m);_<this._distance&&this.initialize(h,m,_)}},So.prototype.initialize=function(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){var l=arguments[0],h=arguments[1];this._pt[0].setCoordinate(l),this._pt[1].setCoordinate(h),this._distance=l.distance(h),this._isNull=!1}else if(3===arguments.length){var _=arguments[1],C=arguments[2];this._pt[0].setCoordinate(arguments[0]),this._pt[1].setCoordinate(_),this._distance=C,this._isNull=!1}},So.prototype.toString=function(){return Je.toLineString(this._pt[0],this._pt[1])},So.prototype.getDistance=function(){return this._distance},So.prototype.setMaximum=function(){if(1===arguments.length){var l=arguments[0];this.setMaximum(l._pt[0],l._pt[1])}else if(2===arguments.length){var h=arguments[0],m=arguments[1];if(this._isNull)return this.initialize(h,m),null;var _=h.distance(m);_>this._distance&&this.initialize(h,m,_)}},So.prototype.interfaces_=function(){return[]},So.prototype.getClass=function(){return So};var la=function(){};la.prototype.interfaces_=function(){return[]},la.prototype.getClass=function(){return la},la.computeDistance=function(){if(arguments[2]instanceof So&&arguments[0]instanceof Vr&&arguments[1]instanceof B)for(var l=arguments[0],h=arguments[1],m=arguments[2],_=new tn,C=l.getCoordinates(),F=0;F<C.length-1;F++){_.setCoordinates(C[F],C[F+1]);var rt=_.closestPoint(h);m.setMinimum(rt,h)}else if(arguments[2]instanceof So&&arguments[0]instanceof rs&&arguments[1]instanceof B){var Dt=arguments[0],qt=arguments[1],fe=arguments[2];la.computeDistance(Dt.getExteriorRing(),qt,fe);for(var ke=0;ke<Dt.getNumInteriorRing();ke++)la.computeDistance(Dt.getInteriorRingN(ke),qt,fe)}else if(arguments[2]instanceof So&&arguments[0]instanceof Gn&&arguments[1]instanceof B){var Ge=arguments[0],xn=arguments[1],Sn=arguments[2];if(Ge instanceof Vr)la.computeDistance(Ge,xn,Sn);else if(Ge instanceof rs)la.computeDistance(Ge,xn,Sn);else if(Ge instanceof zr)for(var Un=Ge,ur=0;ur<Un.getNumGeometries();ur++){var Ji=Un.getGeometryN(ur);la.computeDistance(Ji,xn,Sn)}else Sn.setMinimum(Ge.getCoordinate(),xn)}else if(arguments[2]instanceof So&&arguments[0]instanceof tn&&arguments[1]instanceof B){var Fa=arguments[1],ml=arguments[2],Kl=arguments[0].closestPoint(Fa);ml.setMinimum(Kl,Fa)}};var ns=function(){this._g0=null,this._g1=null,this._ptDist=new So,this._densifyFrac=0;var h=arguments[1];this._g0=arguments[0],this._g1=h},wl={MaxPointDistanceFilter:{configurable:!0},MaxDensifiedByFractionDistanceFilter:{configurable:!0}};ns.prototype.getCoordinates=function(){return this._ptDist.getCoordinates()},ns.prototype.setDensifyFraction=function(l){if(l>1||l<=0)throw new dt("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=l},ns.prototype.compute=function(l,h){this.computeOrientedDistance(l,h,this._ptDist),this.computeOrientedDistance(h,l,this._ptDist)},ns.prototype.distance=function(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()},ns.prototype.computeOrientedDistance=function(l,h,m){var _=new Nu(h);if(l.apply(_),m.setMaximum(_.getMaxPointDistance()),this._densifyFrac>0){var C=new Go(h,this._densifyFrac);l.apply(C),m.setMaximum(C.getMaxPointDistance())}},ns.prototype.orientedDistance=function(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()},ns.prototype.interfaces_=function(){return[]},ns.prototype.getClass=function(){return ns},ns.distance=function(){if(2===arguments.length)return new ns(arguments[0],arguments[1]).distance();if(3===arguments.length){var C=arguments[2],F=new ns(arguments[0],arguments[1]);return F.setDensifyFraction(C),F.distance()}},wl.MaxPointDistanceFilter.get=function(){return Nu},wl.MaxDensifiedByFractionDistanceFilter.get=function(){return Go},Object.defineProperties(ns,wl);var Nu=function(){this._maxPtDist=new So,this._minPtDist=new So,this._euclideanDist=new la,this._geom=null,this._geom=arguments[0]};Nu.prototype.filter=function(l){this._minPtDist.initialize(),la.computeDistance(this._geom,l,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)},Nu.prototype.getMaxPointDistance=function(){return this._maxPtDist},Nu.prototype.interfaces_=function(){return[Et]},Nu.prototype.getClass=function(){return Nu};var Go=function(){this._maxPtDist=new So,this._minPtDist=new So,this._geom=null,this._numSubSegs=0;var h=arguments[1];this._geom=arguments[0],this._numSubSegs=Math.trunc(Math.round(1/h))};Go.prototype.filter=function(l,h){if(0===h)return null;for(var m=l.getCoordinate(h-1),_=l.getCoordinate(h),C=(_.x-m.x)/this._numSubSegs,F=(_.y-m.y)/this._numSubSegs,rt=0;rt<this._numSubSegs;rt++){var fe=new B(m.x+rt*C,m.y+rt*F);this._minPtDist.initialize(),la.computeDistance(this._geom,fe,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}},Go.prototype.isDone=function(){return!1},Go.prototype.isGeometryChanged=function(){return!1},Go.prototype.getMaxPointDistance=function(){return this._maxPtDist},Go.prototype.interfaces_=function(){return[oi]},Go.prototype.getClass=function(){return Go};var hs=function(l,h,m){this._minValidDistance=null,this._maxValidDistance=null,this._minDistanceFound=null,this._maxDistanceFound=null,this._isValid=!0,this._errMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=l||null,this._bufDistance=h||null,this._result=m||null},ca={VERBOSE:{configurable:!0},MAX_DISTANCE_DIFF_FRAC:{configurable:!0}};hs.prototype.checkMaximumDistance=function(l,h,m){var _=new ns(h,l);if(_.setDensifyFraction(.25),this._maxDistanceFound=_.orientedDistance(),this._maxDistanceFound>m){this._isValid=!1;var C=_.getCoordinates();this._errorLocation=C[1],this._errorIndicator=l.getFactory().createLineString(C),this._errMsg="Distance between buffer curve and input is too large ("+this._maxDistanceFound+" at "+Je.toLineString(C[0],C[1])+")"}},hs.prototype.isValid=function(){var l=Math.abs(this._bufDistance),h=hs.MAX_DISTANCE_DIFF_FRAC*l;return this._minValidDistance=l-h,this._maxValidDistance=l+h,!(!this._input.isEmpty()&&!this._result.isEmpty())||(this._bufDistance>0?this.checkPositiveValid():this.checkNegativeValid(),hs.VERBOSE&&Xe.out.println("Min Dist= "+this._minDistanceFound+"  err= "+(1-this._minDistanceFound/this._bufDistance)+"  Max Dist= "+this._maxDistanceFound+"  err= "+(this._maxDistanceFound/this._bufDistance-1)),this._isValid)},hs.prototype.checkNegativeValid=function(){if(!(this._input instanceof rs||this._input instanceof Co||this._input instanceof zr))return null;var l=this.getPolygonLines(this._input);if(this.checkMinimumDistance(l,this._result,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(l,this._result,this._maxValidDistance)},hs.prototype.getErrorIndicator=function(){return this._errorIndicator},hs.prototype.checkMinimumDistance=function(l,h,m){var _=new cs(l,h,m);if(this._minDistanceFound=_.distance(),this._minDistanceFound<m){this._isValid=!1;var C=_.nearestPoints();this._errorLocation=_.nearestPoints()[1],this._errorIndicator=l.getFactory().createLineString(C),this._errMsg="Distance between buffer curve and input is too small ("+this._minDistanceFound+" at "+Je.toLineString(C[0],C[1])+" )"}},hs.prototype.checkPositiveValid=function(){var l=this._result.getBoundary();if(this.checkMinimumDistance(this._input,l,this._minValidDistance),!this._isValid)return null;this.checkMaximumDistance(this._input,l,this._maxValidDistance)},hs.prototype.getErrorLocation=function(){return this._errorLocation},hs.prototype.getPolygonLines=function(l){for(var h=new ue,m=new Qs(h),_=Ca.getPolygons(l).iterator();_.hasNext();)_.next().apply(m);return l.getFactory().buildGeometry(h)},hs.prototype.getErrorMessage=function(){return this._errMsg},hs.prototype.interfaces_=function(){return[]},hs.prototype.getClass=function(){return hs},ca.VERBOSE.get=function(){return!1},ca.MAX_DISTANCE_DIFF_FRAC.get=function(){return.012},Object.defineProperties(hs,ca);var no=function(l,h,m){this._isValid=!0,this._errorMsg=null,this._errorLocation=null,this._errorIndicator=null,this._input=l||null,this._distance=h||null,this._result=m||null},jl={VERBOSE:{configurable:!0},MAX_ENV_DIFF_FRAC:{configurable:!0}};no.prototype.isValid=function(){return this.checkPolygonal(),this._isValid?(this.checkExpectedEmpty(),this._isValid?(this.checkEnvelope(),this._isValid?(this.checkArea(),this._isValid?(this.checkDistance(),this._isValid):this._isValid):this._isValid):this._isValid):this._isValid},no.prototype.checkEnvelope=function(){if(this._distance<0)return null;var l=this._distance*no.MAX_ENV_DIFF_FRAC;0===l&&(l=.001);var h=new De(this._input.getEnvelopeInternal());h.expandBy(this._distance);var m=new De(this._result.getEnvelopeInternal());m.expandBy(l),m.contains(h)||(this._isValid=!1,this._errorMsg="Buffer envelope is incorrect",this._errorIndicator=this._input.getFactory().toGeometry(m)),this.report("Envelope")},no.prototype.checkDistance=function(){var l=new hs(this._input,this._distance,this._result);l.isValid()||(this._isValid=!1,this._errorMsg=l.getErrorMessage(),this._errorLocation=l.getErrorLocation(),this._errorIndicator=l.getErrorIndicator()),this.report("Distance")},no.prototype.checkArea=function(){var l=this._input.getArea(),h=this._result.getArea();this._distance>0&&l>h&&(this._isValid=!1,this._errorMsg="Area of positive buffer is smaller than input",this._errorIndicator=this._result),this._distance<0&&l<h&&(this._isValid=!1,this._errorMsg="Area of negative buffer is larger than input",this._errorIndicator=this._result),this.report("Area")},no.prototype.checkPolygonal=function(){this._result instanceof rs||this._result instanceof Co||(this._isValid=!1),this._errorMsg="Result is not polygonal",this._errorIndicator=this._result,this.report("Polygonal")},no.prototype.getErrorIndicator=function(){return this._errorIndicator},no.prototype.getErrorLocation=function(){return this._errorLocation},no.prototype.checkExpectedEmpty=function(){return this._input.getDimension()>=2||this._distance>0?null:(this._result.isEmpty()||(this._isValid=!1,this._errorMsg="Result is non-empty",this._errorIndicator=this._result),void this.report("ExpectedEmpty"))},no.prototype.report=function(l){if(!no.VERBOSE)return null;Xe.out.println("Check "+l+": "+(this._isValid?"passed":"FAILED"))},no.prototype.getErrorMessage=function(){return this._errorMsg},no.prototype.interfaces_=function(){return[]},no.prototype.getClass=function(){return no},no.isValidMsg=function(l,h,m){var _=new no(l,h,m);return _.isValid()?null:_.getErrorMessage()},no.isValid=function(l,h,m){return!!new no(l,h,m).isValid()},jl.VERBOSE.get=function(){return!1},jl.MAX_ENV_DIFF_FRAC.get=function(){return.012},Object.defineProperties(no,jl);var ja=function(){this._pts=null,this._data=null;var h=arguments[1];this._pts=arguments[0],this._data=h};ja.prototype.getCoordinates=function(){return this._pts},ja.prototype.size=function(){return this._pts.length},ja.prototype.getCoordinate=function(l){return this._pts[l]},ja.prototype.isClosed=function(){return this._pts[0].equals(this._pts[this._pts.length-1])},ja.prototype.getSegmentOctant=function(l){return l===this._pts.length-1?-1:_r.octant(this.getCoordinate(l),this.getCoordinate(l+1))},ja.prototype.setData=function(l){this._data=l},ja.prototype.getData=function(){return this._data},ja.prototype.toString=function(){return Je.toLineString(new pr(this._pts))},ja.prototype.interfaces_=function(){return[ni]},ja.prototype.getClass=function(){return ja};var Yr=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new ue,this._intersectionCount=0,this._keepIntersections=!0,this._li=arguments[0],this._interiorIntersection=null};Yr.prototype.getInteriorIntersection=function(){return this._interiorIntersection},Yr.prototype.setCheckEndSegmentsOnly=function(l){this._isCheckEndSegmentsOnly=l},Yr.prototype.getIntersectionSegments=function(){return this._intSegments},Yr.prototype.count=function(){return this._intersectionCount},Yr.prototype.getIntersections=function(){return this._intersections},Yr.prototype.setFindAllIntersections=function(l){this._findAllIntersections=l},Yr.prototype.setKeepIntersections=function(l){this._keepIntersections=l},Yr.prototype.processIntersections=function(l,h,m,_){if(!this._findAllIntersections&&this.hasIntersection()||l===m&&h===_||this._isCheckEndSegmentsOnly&&!this.isEndSegment(l,h)&&!this.isEndSegment(m,_))return null;var C=l.getCoordinates()[h],F=l.getCoordinates()[h+1],rt=m.getCoordinates()[_],Dt=m.getCoordinates()[_+1];this._li.computeIntersection(C,F,rt,Dt),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=C,this._intSegments[1]=F,this._intSegments[2]=rt,this._intSegments[3]=Dt,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)},Yr.prototype.isEndSegment=function(l,h){return 0===h||h>=l.size()-2},Yr.prototype.hasIntersection=function(){return null!==this._interiorIntersection},Yr.prototype.isDone=function(){return!this._findAllIntersections&&null!==this._interiorIntersection},Yr.prototype.interfaces_=function(){return[qo]},Yr.prototype.getClass=function(){return Yr},Yr.createAllIntersectionsFinder=function(l){var h=new Yr(l);return h.setFindAllIntersections(!0),h},Yr.createAnyIntersectionFinder=function(l){return new Yr(l)},Yr.createIntersectionCounter=function(l){var h=new Yr(l);return h.setFindAllIntersections(!0),h.setKeepIntersections(!1),h};var ha=function(){this._li=new di,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0,this._segStrings=arguments[0]};ha.prototype.execute=function(){if(null!==this._segInt)return null;this.checkInteriorIntersections()},ha.prototype.getIntersections=function(){return this._segInt.getIntersections()},ha.prototype.isValid=function(){return this.execute(),this._isValid},ha.prototype.setFindAllIntersections=function(l){this._findAllIntersections=l},ha.prototype.checkInteriorIntersections=function(){this._isValid=!0,this._segInt=new Yr(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);var l=new Oc;if(l.setSegmentIntersector(this._segInt),l.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null},ha.prototype.checkValid=function(){if(this.execute(),!this._isValid)throw new Ss(this.getErrorMessage(),this._segInt.getInteriorIntersection())},ha.prototype.getErrorMessage=function(){if(this._isValid)return"no intersections found";var l=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Je.toLineString(l[0],l[1])+" and "+Je.toLineString(l[2],l[3])},ha.prototype.interfaces_=function(){return[]},ha.prototype.getClass=function(){return ha},ha.computeIntersections=function(l){var h=new ha(l);return h.setFindAllIntersections(!0),h.isValid(),h.getIntersections()};var yu=function l(){this._nv=null,this._nv=new ha(l.toSegmentStrings(arguments[0]))};yu.prototype.checkValid=function(){this._nv.checkValid()},yu.prototype.interfaces_=function(){return[]},yu.prototype.getClass=function(){return yu},yu.toSegmentStrings=function(l){for(var h=new ue,m=l.iterator();m.hasNext();){var _=m.next();h.add(new ja(_.getCoordinates(),_))}return h},yu.checkValid=function(l){new yu(l).checkValid()};var or=function(l){this._mapOp=l};or.prototype.map=function(l){for(var h=new ue,m=0;m<l.getNumGeometries();m++){var _=this._mapOp.map(l.getGeometryN(m));_.isEmpty()||h.add(_)}return l.getFactory().createGeometryCollection(er.toGeometryArray(h))},or.prototype.interfaces_=function(){return[]},or.prototype.getClass=function(){return or},or.map=function(l,h){return new or(h).map(l)};var bs=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new ue,this._resultLineList=new ue;var h=arguments[1],m=arguments[2];this._op=arguments[0],this._geometryFactory=h,this._ptLocator=m};bs.prototype.collectLines=function(l){for(var h=this._op.getGraph().getEdgeEnds().iterator();h.hasNext();){var m=h.next();this.collectLineEdge(m,l,this._lineEdgesList),this.collectBoundaryTouchEdge(m,l,this._lineEdgesList)}},bs.prototype.labelIsolatedLine=function(l,h){var m=this._ptLocator.locate(l.getCoordinate(),this._op.getArgGeometry(h));l.getLabel().setLocation(h,m)},bs.prototype.build=function(l){return this.findCoveredLineEdges(),this.collectLines(l),this.buildLines(l),this._resultLineList},bs.prototype.collectLineEdge=function(l,h,m){var _=l.getLabel(),C=l.getEdge();l.isLineEdge()&&(l.isVisited()||!cr.isResultOfOp(_,h)||C.isCovered()||(m.add(C),l.setVisitedEdge(!0)))},bs.prototype.findCoveredLineEdges=function(){for(var l=this._op.getGraph().getNodes().iterator();l.hasNext();)l.next().getEdges().findCoveredLineEdges();for(var h=this._op.getGraph().getEdgeEnds().iterator();h.hasNext();){var m=h.next(),_=m.getEdge();if(m.isLineEdge()&&!_.isCoveredSet()){var C=this._op.isCoveredByA(m.getCoordinate());_.setCovered(C)}}},bs.prototype.labelIsolatedLines=function(l){for(var h=l.iterator();h.hasNext();){var m=h.next(),_=m.getLabel();m.isIsolated()&&(_.isNull(0)?this.labelIsolatedLine(m,0):this.labelIsolatedLine(m,1))}},bs.prototype.buildLines=function(l){for(var h=this._lineEdgesList.iterator();h.hasNext();){var m=h.next(),_=this._geometryFactory.createLineString(m.getCoordinates());this._resultLineList.add(_),m.setInResult(!0)}},bs.prototype.collectBoundaryTouchEdge=function(l,h,m){var _=l.getLabel();return l.isLineEdge()||l.isVisited()||l.isInteriorAreaEdge()||l.getEdge().isInResult()?null:(Nn.isTrue(!(l.isInResult()||l.getSym().isInResult())||!l.getEdge().isInResult()),void(cr.isResultOfOp(_,h)&&h===cr.INTERSECTION&&(m.add(l.getEdge()),l.setVisitedEdge(!0))))},bs.prototype.interfaces_=function(){return[]},bs.prototype.getClass=function(){return bs};var Tr=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new ue;var h=arguments[1];this._op=arguments[0],this._geometryFactory=h};Tr.prototype.filterCoveredNodeToPoint=function(l){var h=l.getCoordinate();if(!this._op.isCoveredByLA(h)){var m=this._geometryFactory.createPoint(h);this._resultPointList.add(m)}},Tr.prototype.extractNonCoveredResultNodes=function(l){for(var h=this._op.getGraph().getNodes().iterator();h.hasNext();){var m=h.next();if(!(m.isInResult()||m.isIncidentEdgeInResult()||0!==m.getEdges().getDegree()&&l!==cr.INTERSECTION)){var _=m.getLabel();cr.isResultOfOp(_,l)&&this.filterCoveredNodeToPoint(m)}}},Tr.prototype.build=function(l){return this.extractNonCoveredResultNodes(l),this._resultPointList},Tr.prototype.interfaces_=function(){return[]},Tr.prototype.getClass=function(){return Tr};var ri=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};ri.prototype.transformPoint=function(l,h){return this._factory.createPoint(this.transformCoordinates(l.getCoordinateSequence(),l))},ri.prototype.transformPolygon=function(l,h){var m=!0,_=this.transformLinearRing(l.getExteriorRing(),l);null!==_&&_ instanceof eo&&!_.isEmpty()||(m=!1);for(var C=new ue,F=0;F<l.getNumInteriorRing();F++){var rt=this.transformLinearRing(l.getInteriorRingN(F),l);null===rt||rt.isEmpty()||(rt instanceof eo||(m=!1),C.add(rt))}if(m)return this._factory.createPolygon(_,C.toArray([]));var Dt=new ue;return null!==_&&Dt.add(_),Dt.addAll(C),this._factory.buildGeometry(Dt)},ri.prototype.createCoordinateSequence=function(l){return this._factory.getCoordinateSequenceFactory().create(l)},ri.prototype.getInputGeometry=function(){return this._inputGeom},ri.prototype.transformMultiLineString=function(l,h){for(var m=new ue,_=0;_<l.getNumGeometries();_++){var C=this.transformLineString(l.getGeometryN(_),l);null!==C&&(C.isEmpty()||m.add(C))}return this._factory.buildGeometry(m)},ri.prototype.transformCoordinates=function(l,h){return this.copy(l)},ri.prototype.transformLineString=function(l,h){return this._factory.createLineString(this.transformCoordinates(l.getCoordinateSequence(),l))},ri.prototype.transformMultiPoint=function(l,h){for(var m=new ue,_=0;_<l.getNumGeometries();_++){var C=this.transformPoint(l.getGeometryN(_),l);null!==C&&(C.isEmpty()||m.add(C))}return this._factory.buildGeometry(m)},ri.prototype.transformMultiPolygon=function(l,h){for(var m=new ue,_=0;_<l.getNumGeometries();_++){var C=this.transformPolygon(l.getGeometryN(_),l);null!==C&&(C.isEmpty()||m.add(C))}return this._factory.buildGeometry(m)},ri.prototype.copy=function(l){return l.copy()},ri.prototype.transformGeometryCollection=function(l,h){for(var m=new ue,_=0;_<l.getNumGeometries();_++){var C=this.transform(l.getGeometryN(_));null!==C&&(this._pruneEmptyGeometry&&C.isEmpty()||m.add(C))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(er.toGeometryArray(m)):this._factory.buildGeometry(m)},ri.prototype.transform=function(l){if(this._inputGeom=l,this._factory=l.getFactory(),l instanceof Ls)return this.transformPoint(l,null);if(l instanceof Pa)return this.transformMultiPoint(l,null);if(l instanceof eo)return this.transformLinearRing(l,null);if(l instanceof Vr)return this.transformLineString(l,null);if(l instanceof js)return this.transformMultiLineString(l,null);if(l instanceof rs)return this.transformPolygon(l,null);if(l instanceof Co)return this.transformMultiPolygon(l,null);if(l instanceof zr)return this.transformGeometryCollection(l,null);throw new dt("Unknown Geometry subtype: "+l.getClass().getName())},ri.prototype.transformLinearRing=function(l,h){var m=this.transformCoordinates(l.getCoordinateSequence(),l);if(null===m)return this._factory.createLinearRing(null);var _=m.size();return _>0&&_<4&&!this._preserveType?this._factory.createLineString(m):this._factory.createLinearRing(m)},ri.prototype.interfaces_=function(){return[]},ri.prototype.getClass=function(){return ri};var ds=function l(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new tn,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Vr&&"number"==typeof arguments[1]){var m=arguments[1];l.call(this,arguments[0].getCoordinates(),m)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var _=arguments[0],C=arguments[1];this._srcPts=_,this._isClosed=l.isClosed(_),this._snapTolerance=C}};ds.prototype.snapVertices=function(l,h){for(var m=this._isClosed?l.size()-1:l.size(),_=0;_<m;_++){var C=l.get(_),F=this.findSnapForVertex(C,h);null!==F&&(l.set(_,new B(F)),0===_&&this._isClosed&&l.set(l.size()-1,new B(F)))}},ds.prototype.findSnapForVertex=function(l,h){for(var m=0;m<h.length;m++){if(l.equals2D(h[m]))return null;if(l.distance(h[m])<this._snapTolerance)return h[m]}return null},ds.prototype.snapTo=function(l){var h=new mn(this._srcPts);return this.snapVertices(h,l),this.snapSegments(h,l),h.toCoordinateArray()},ds.prototype.snapSegments=function(l,h){if(0===h.length)return null;var m=h.length;h[0].equals2D(h[h.length-1])&&(m=h.length-1);for(var _=0;_<m;_++){var C=h[_],F=this.findSegmentIndexToSnap(C,l);F>=0&&l.add(F+1,new B(C),!1)}},ds.prototype.findSegmentIndexToSnap=function(l,h){for(var m=lt.MAX_VALUE,_=-1,C=0;C<h.size()-1;C++){if(this._seg.p0=h.get(C),this._seg.p1=h.get(C+1),this._seg.p0.equals2D(l)||this._seg.p1.equals2D(l)){if(this._allowSnappingToSourceVertices)continue;return-1}var F=this._seg.distance(l);F<this._snapTolerance&&F<m&&(m=F,_=C)}return _},ds.prototype.setAllowSnappingToSourceVertices=function(l){this._allowSnappingToSourceVertices=l},ds.prototype.interfaces_=function(){return[]},ds.prototype.getClass=function(){return ds},ds.isClosed=function(l){return!(l.length<=1)&&l[0].equals2D(l[l.length-1])};var gt=function(l){this._srcGeom=l||null},ct={SNAP_PRECISION_FACTOR:{configurable:!0}};gt.prototype.snapTo=function(l,h){var m=this.extractTargetCoordinates(l);return new _t(h,m).transform(this._srcGeom)},gt.prototype.snapToSelf=function(l,h){var m=this.extractTargetCoordinates(this._srcGeom),_=new _t(l,m,!0).transform(this._srcGeom),C=_;return h&&O(C,Ma)&&(C=_.buffer(0)),C},gt.prototype.computeSnapTolerance=function(l){return this.computeMinimumSegmentLength(l)/10},gt.prototype.extractTargetCoordinates=function(l){for(var h=new it,m=l.getCoordinates(),_=0;_<m.length;_++)h.add(m[_]);return h.toArray(new Array(0).fill(null))},gt.prototype.computeMinimumSegmentLength=function(l){for(var h=lt.MAX_VALUE,m=0;m<l.length-1;m++){var _=l[m].distance(l[m+1]);_<h&&(h=_)}return h},gt.prototype.interfaces_=function(){return[]},gt.prototype.getClass=function(){return gt},gt.snap=function(l,h,m){var _=new Array(2).fill(null),C=new gt(l);_[0]=C.snapTo(h,m);var F=new gt(h);return _[1]=F.snapTo(_[0],m),_},gt.computeOverlaySnapTolerance=function(){if(1===arguments.length){var l=arguments[0],h=gt.computeSizeBasedSnapTolerance(l),m=l.getPrecisionModel();if(m.getType()===An.FIXED){var _=1/m.getScale()*2/1.415;_>h&&(h=_)}return h}if(2===arguments.length){var F=arguments[1];return Math.min(gt.computeOverlaySnapTolerance(arguments[0]),gt.computeOverlaySnapTolerance(F))}},gt.computeSizeBasedSnapTolerance=function(l){var h=l.getEnvelopeInternal();return Math.min(h.getHeight(),h.getWidth())*gt.SNAP_PRECISION_FACTOR},gt.snapToSelf=function(l,h,m){return new gt(l).snapToSelf(h,m)},ct.SNAP_PRECISION_FACTOR.get=function(){return 1e-9},Object.defineProperties(gt,ct);var _t=function(l){function h(m,_,C){l.call(this),this._snapTolerance=m||null,this._snapPts=_||null,this._isSelfSnap=void 0!==C&&C}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.snapLine=function(m,_){var C=new ds(m,this._snapTolerance);return C.setAllowSnappingToSourceVertices(this._isSelfSnap),C.snapTo(_)},h.prototype.transformCoordinates=function(m,_){var C=m.toCoordinateArray(),F=this.snapLine(C,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(F)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(ri),Nt=function(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=0,this._commonSignExp=null};Nt.prototype.getCommon=function(){return lt.longBitsToDouble(this._commonBits)},Nt.prototype.add=function(l){var h=lt.doubleToLongBits(l);return this._isFirst?(this._commonBits=h,this._commonSignExp=Nt.signExpBits(this._commonBits),this._isFirst=!1,null):Nt.signExpBits(h)!==this._commonSignExp?(this._commonBits=0,null):(this._commonMantissaBitsCount=Nt.numCommonMostSigMantissaBits(this._commonBits,h),void(this._commonBits=Nt.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))))},Nt.prototype.toString=function(){if(1===arguments.length){var l=arguments[0],h=lt.longBitsToDouble(l),m="0000000000000000000000000000000000000000000000000000000000000000"+lt.toBinaryString(l),_=m.substring(m.length-64);return _.substring(0,1)+"  "+_.substring(1,12)+"(exp) "+_.substring(12)+" [ "+h+" ]"}},Nt.prototype.interfaces_=function(){return[]},Nt.prototype.getClass=function(){return Nt},Nt.getBit=function(l,h){return l&1<<h?1:0},Nt.signExpBits=function(l){return l>>52},Nt.zeroLowerBits=function(l,h){return l&~((1<<h)-1)},Nt.numCommonMostSigMantissaBits=function(l,h){for(var m=0,_=52;_>=0;_--){if(Nt.getBit(l,_)!==Nt.getBit(h,_))return m;m++}return 52};var Kt=function(){this._commonCoord=null,this._ccFilter=new Ee},de={CommonCoordinateFilter:{configurable:!0},Translater:{configurable:!0}};Kt.prototype.addCommonBits=function(l){var h=new Te(this._commonCoord);l.apply(h),l.geometryChanged()},Kt.prototype.removeCommonBits=function(l){if(0===this._commonCoord.x&&0===this._commonCoord.y)return l;var h=new B(this._commonCoord);h.x=-h.x,h.y=-h.y;var m=new Te(h);return l.apply(m),l.geometryChanged(),l},Kt.prototype.getCommonCoordinate=function(){return this._commonCoord},Kt.prototype.add=function(l){l.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()},Kt.prototype.interfaces_=function(){return[]},Kt.prototype.getClass=function(){return Kt},de.CommonCoordinateFilter.get=function(){return Ee},de.Translater.get=function(){return Te},Object.defineProperties(Kt,de);var Ee=function(){this._commonBitsX=new Nt,this._commonBitsY=new Nt};Ee.prototype.filter=function(l){this._commonBitsX.add(l.x),this._commonBitsY.add(l.y)},Ee.prototype.getCommonCoordinate=function(){return new B(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())},Ee.prototype.interfaces_=function(){return[Et]},Ee.prototype.getClass=function(){return Ee};var Te=function(){this.trans=null,this.trans=arguments[0]};Te.prototype.filter=function(l,h){var m=l.getOrdinate(h,0)+this.trans.x,_=l.getOrdinate(h,1)+this.trans.y;l.setOrdinate(h,0,m),l.setOrdinate(h,1,_)},Te.prototype.isDone=function(){return!1},Te.prototype.isGeometryChanged=function(){return!0},Te.prototype.interfaces_=function(){return[oi]},Te.prototype.getClass=function(){return Te};var xe=function(l,h){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null,this._geom[0]=l,this._geom[1]=h,this.computeSnapTolerance()};xe.prototype.selfSnap=function(l){return new gt(l).snapTo(l,this._snapTolerance)},xe.prototype.removeCommonBits=function(l){this._cbr=new Kt,this._cbr.add(l[0]),this._cbr.add(l[1]);var h=new Array(2).fill(null);return h[0]=this._cbr.removeCommonBits(l[0].copy()),h[1]=this._cbr.removeCommonBits(l[1].copy()),h},xe.prototype.prepareResult=function(l){return this._cbr.addCommonBits(l),l},xe.prototype.getResultGeometry=function(l){var h=this.snap(this._geom),m=cr.overlayOp(h[0],h[1],l);return this.prepareResult(m)},xe.prototype.checkValid=function(l){l.isValid()||Xe.out.println("Snapped geometry is invalid")},xe.prototype.computeSnapTolerance=function(){this._snapTolerance=gt.computeOverlaySnapTolerance(this._geom[0],this._geom[1])},xe.prototype.snap=function(l){var h=this.removeCommonBits(l);return gt.snap(h[0],h[1],this._snapTolerance)},xe.prototype.interfaces_=function(){return[]},xe.prototype.getClass=function(){return xe},xe.overlayOp=function(l,h,m){return new xe(l,h).getResultGeometry(m)},xe.union=function(l,h){return xe.overlayOp(l,h,cr.UNION)},xe.intersection=function(l,h){return xe.overlayOp(l,h,cr.INTERSECTION)},xe.symDifference=function(l,h){return xe.overlayOp(l,h,cr.SYMDIFFERENCE)},xe.difference=function(l,h){return xe.overlayOp(l,h,cr.DIFFERENCE)};var Pe=function(l,h){this._geom=new Array(2).fill(null),this._geom[0]=l,this._geom[1]=h};Pe.prototype.getResultGeometry=function(l){var h=null,m=!1,_=null;try{h=cr.overlayOp(this._geom[0],this._geom[1],l),m=!0}catch(C){if(!(C instanceof Wn))throw C;_=C}if(!m)try{h=xe.overlayOp(this._geom[0],this._geom[1],l)}catch(C){throw C instanceof Wn?_:C}return h},Pe.prototype.interfaces_=function(){return[]},Pe.prototype.getClass=function(){return Pe},Pe.overlayOp=function(l,h,m){return new Pe(l,h).getResultGeometry(m)},Pe.union=function(l,h){return Pe.overlayOp(l,h,cr.UNION)},Pe.intersection=function(l,h){return Pe.overlayOp(l,h,cr.INTERSECTION)},Pe.symDifference=function(l,h){return Pe.overlayOp(l,h,cr.SYMDIFFERENCE)},Pe.difference=function(l,h){return Pe.overlayOp(l,h,cr.DIFFERENCE)};var fn=function(){this.mce=null,this.chainIndex=null;var h=arguments[1];this.mce=arguments[0],this.chainIndex=h};fn.prototype.computeIntersections=function(l,h){this.mce.computeIntersectsForChain(this.chainIndex,l.mce,l.chainIndex,h)},fn.prototype.interfaces_=function(){return[]},fn.prototype.getClass=function(){return fn};var f=function l(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){var h=arguments[0],m=arguments[1];this._eventType=l.DELETE,this._xValue=h,this._insertEvent=m}else if(3===arguments.length){var _=arguments[0],C=arguments[1],F=arguments[2];this._eventType=l.INSERT,this._label=_,this._xValue=C,this._obj=F}},E={INSERT:{configurable:!0},DELETE:{configurable:!0}};f.prototype.isDelete=function(){return this._eventType===f.DELETE},f.prototype.setDeleteEventIndex=function(l){this._deleteEventIndex=l},f.prototype.getObject=function(){return this._obj},f.prototype.compareTo=function(l){return this._xValue<l._xValue?-1:this._xValue>l._xValue?1:this._eventType<l._eventType?-1:this._eventType>l._eventType?1:0},f.prototype.getInsertEvent=function(){return this._insertEvent},f.prototype.isInsert=function(){return this._eventType===f.INSERT},f.prototype.isSameLabel=function(l){return null!==this._label&&this._label===l._label},f.prototype.getDeleteEventIndex=function(){return this._deleteEventIndex},f.prototype.interfaces_=function(){return[q]},f.prototype.getClass=function(){return f},E.INSERT.get=function(){return 1},E.DELETE.get=function(){return 2},Object.defineProperties(f,E);var D=function(){};D.prototype.interfaces_=function(){return[]},D.prototype.getClass=function(){return D};var j=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;var h=arguments[1],m=arguments[2];this._li=arguments[0],this._includeProper=h,this._recordIsolated=m};j.prototype.isTrivialIntersection=function(l,h,m,_){if(l===m&&1===this._li.getIntersectionNum()){if(j.isAdjacentSegments(h,_))return!0;if(l.isClosed()){var C=l.getNumPoints()-1;if(0===h&&_===C||0===_&&h===C)return!0}}return!1},j.prototype.getProperIntersectionPoint=function(){return this._properIntersectionPoint},j.prototype.setIsDoneIfProperInt=function(l){this._isDoneWhenProperInt=l},j.prototype.hasProperInteriorIntersection=function(){return this._hasProperInterior},j.prototype.isBoundaryPointInternal=function(l,h){for(var m=h.iterator();m.hasNext();){var _=m.next().getCoordinate();if(l.isIntersection(_))return!0}return!1},j.prototype.hasProperIntersection=function(){return this._hasProper},j.prototype.hasIntersection=function(){return this._hasIntersection},j.prototype.isDone=function(){return this._isDone},j.prototype.isBoundaryPoint=function(l,h){return!(null===h||!this.isBoundaryPointInternal(l,h[0])&&!this.isBoundaryPointInternal(l,h[1]))},j.prototype.setBoundaryNodes=function(l,h){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=l,this._bdyNodes[1]=h},j.prototype.addIntersections=function(l,h,m,_){if(l===m&&h===_)return null;this.numTests++;var C=l.getCoordinates()[h],F=l.getCoordinates()[h+1],rt=m.getCoordinates()[_],Dt=m.getCoordinates()[_+1];this._li.computeIntersection(C,F,rt,Dt),this._li.hasIntersection()&&(this._recordIsolated&&(l.setIsolated(!1),m.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(l,h,m,_)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(l.addIntersections(this._li,h,0),m.addIntersections(this._li,_,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))},j.prototype.interfaces_=function(){return[]},j.prototype.getClass=function(){return j},j.isAdjacentSegments=function(l,h){return 1===Math.abs(l-h)};var mt=function(l){function h(){l.call(this),this.events=new ue,this.nOverlaps=null}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.prepareEvents=function(){Yt.sort(this.events);for(var m=0;m<this.events.size();m++){var _=this.events.get(m);_.isDelete()&&_.getInsertEvent().setDeleteEventIndex(m)}},h.prototype.computeIntersections=function(){if(1===arguments.length){var m=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var _=0;_<this.events.size();_++){var C=this.events.get(_);if(C.isInsert()&&this.processOverlaps(_,C.getDeleteEventIndex(),C,m),m.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof j&&O(arguments[0],En)&&O(arguments[1],En)){var F=arguments[0],rt=arguments[1],Dt=arguments[2];this.addEdges(F,F),this.addEdges(rt,rt),this.computeIntersections(Dt)}else if("boolean"==typeof arguments[2]&&O(arguments[0],En)&&arguments[1]instanceof j){var qt=arguments[0],fe=arguments[1];arguments[2]?this.addEdges(qt,null):this.addEdges(qt),this.computeIntersections(fe)}},h.prototype.addEdge=function(m,_){for(var C=m.getMonotoneChainEdge(),F=C.getStartIndexes(),rt=0;rt<F.length-1;rt++){var Dt=new fn(C,rt),qt=new f(_,C.getMinX(rt),Dt);this.events.add(qt),this.events.add(new f(C.getMaxX(rt),qt))}},h.prototype.processOverlaps=function(m,_,C,F){for(var rt=C.getObject(),Dt=m;Dt<_;Dt++){var qt=this.events.get(Dt);if(qt.isInsert()){var fe=qt.getObject();C.isSameLabel(qt)||(rt.computeIntersections(fe,F),this.nOverlaps++)}}},h.prototype.addEdges=function(){if(1===arguments.length)for(var m=arguments[0].iterator();m.hasNext();){var _=m.next();this.addEdge(_,_)}else if(2===arguments.length)for(var F=arguments[1],rt=arguments[0].iterator();rt.hasNext();){var Dt=rt.next();this.addEdge(Dt,F)}},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(D),Ft=function(){this._min=lt.POSITIVE_INFINITY,this._max=lt.NEGATIVE_INFINITY},ce={NodeComparator:{configurable:!0}};Ft.prototype.getMin=function(){return this._min},Ft.prototype.intersects=function(l,h){return!(this._min>h||this._max<l)},Ft.prototype.getMax=function(){return this._max},Ft.prototype.toString=function(){return Je.toLineString(new B(this._min,0),new B(this._max,0))},Ft.prototype.interfaces_=function(){return[]},Ft.prototype.getClass=function(){return Ft},ce.NodeComparator.get=function(){return ye},Object.defineProperties(Ft,ce);var ye=function(){};ye.prototype.compare=function(l,h){var C=(l._min+l._max)/2,F=(h._min+h._max)/2;return C<F?-1:C>F?1:0},ye.prototype.interfaces_=function(){return[pt]},ye.prototype.getClass=function(){return ye};var Ve=function(l){function h(){l.call(this),this._item=null;var _=arguments[1],C=arguments[2];this._min=arguments[0],this._max=_,this._item=C}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.query=function(m,_,C){if(!this.intersects(m,_))return null;C.visitItem(this._item)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Ft),sn=function(l){function h(){l.call(this),this._node1=null,this._node2=null;var _=arguments[1];this._node1=arguments[0],this._node2=_,this.buildExtent(this._node1,this._node2)}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.buildExtent=function(m,_){this._min=Math.min(m._min,_._min),this._max=Math.max(m._max,_._max)},h.prototype.query=function(m,_,C){if(!this.intersects(m,_))return null;null!==this._node1&&this._node1.query(m,_,C),null!==this._node2&&this._node2.query(m,_,C)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(Ft),wn=function(){this._leaves=new ue,this._root=null,this._level=0};wn.prototype.buildTree=function(){Yt.sort(this._leaves,new Ft.NodeComparator);for(var l=this._leaves,h=null,m=new ue;;){if(this.buildLevel(l,m),1===m.size())return m.get(0);h=l,l=m,m=h}},wn.prototype.insert=function(l,h,m){if(null!==this._root)throw new Error("Index cannot be added to once it has been queried");this._leaves.add(new Ve(l,h,m))},wn.prototype.query=function(l,h,m){this.init(),this._root.query(l,h,m)},wn.prototype.buildRoot=function(){if(null!==this._root)return null;this._root=this.buildTree()},wn.prototype.printNode=function(l){Xe.out.println(Je.toLineString(new B(l._min,this._level),new B(l._max,this._level)))},wn.prototype.init=function(){if(null!==this._root)return null;this.buildRoot()},wn.prototype.buildLevel=function(l,h){this._level++,h.clear();for(var m=0;m<l.size();m+=2){var _=l.get(m);if(null===(m+1<l.size()?l.get(m):null))h.add(_);else{var C=new sn(l.get(m),l.get(m+1));h.add(C)}}},wn.prototype.interfaces_=function(){return[]},wn.prototype.getClass=function(){return wn};var Pn=function(){this._items=new ue};Pn.prototype.visitItem=function(l){this._items.add(l)},Pn.prototype.getItems=function(){return this._items},Pn.prototype.interfaces_=function(){return[M]},Pn.prototype.getClass=function(){return Pn};var Nr=function(){this._index=null;var l=arguments[0];if(!O(l,Ma))throw new dt("Argument must be Polygonal");this._index=new ro(l)},yo={SegmentVisitor:{configurable:!0},IntervalIndexedGeometry:{configurable:!0}};Nr.prototype.locate=function(l){var h=new ii(l),m=new qi(h);return this._index.query(l.y,l.y,m),h.getLocation()},Nr.prototype.interfaces_=function(){return[nu]},Nr.prototype.getClass=function(){return Nr},yo.SegmentVisitor.get=function(){return qi},yo.IntervalIndexedGeometry.get=function(){return ro},Object.defineProperties(Nr,yo);var qi=function(){this._counter=null,this._counter=arguments[0]};qi.prototype.visitItem=function(l){var h=l;this._counter.countSegment(h.getCoordinate(0),h.getCoordinate(1))},qi.prototype.interfaces_=function(){return[M]},qi.prototype.getClass=function(){return qi};var ro=function(){this._index=new wn,this.init(arguments[0])};ro.prototype.init=function(l){for(var h=Qs.getLines(l).iterator();h.hasNext();){var m=h.next().getCoordinates();this.addLine(m)}},ro.prototype.addLine=function(l){for(var h=1;h<l.length;h++){var m=new tn(l[h-1],l[h]),_=Math.min(m.p0.y,m.p1.y),C=Math.max(m.p0.y,m.p1.y);this._index.insert(_,C,m)}},ro.prototype.query=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1],m=new Pn;return this._index.query(l,h,m),m.getItems()}3===arguments.length&&this._index.query(arguments[0],arguments[1],arguments[2])},ro.prototype.interfaces_=function(){return[]},ro.prototype.getClass=function(){return ro};var Ho=function(l){function h(){if(l.call(this),this._parentGeom=null,this._lineEdgeMap=new ys,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new ta,2===arguments.length){var _=arguments[1],C=Rt.OGC_SFS_BOUNDARY_RULE;this._argIndex=arguments[0],this._parentGeom=_,this._boundaryNodeRule=C,null!==_&&this.add(_)}else if(3===arguments.length){var rt=arguments[1],Dt=arguments[2];this._argIndex=arguments[0],this._parentGeom=rt,this._boundaryNodeRule=Dt,null!==rt&&this.add(rt)}}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.insertBoundaryPoint=function(m,_){var C=this._nodes.addNode(_).getLabel(),F=1;C.getLocation(m,an.ON)===nt.BOUNDARY&&F++;var rt=h.determineBoundary(this._boundaryNodeRule,F);C.setLocation(m,rt)},h.prototype.computeSelfNodes=function(){if(2===arguments.length)return this.computeSelfNodes(arguments[0],arguments[1],!1);if(3===arguments.length){var F=arguments[1],rt=arguments[2],Dt=new j(arguments[0],!0,!1);return Dt.setIsDoneIfProperInt(rt),this.createEdgeSetIntersector().computeIntersections(this._edges,Dt,F||!(this._parentGeom instanceof eo||this._parentGeom instanceof rs||this._parentGeom instanceof Co)),this.addSelfIntersectionNodes(this._argIndex),Dt}},h.prototype.computeSplitEdges=function(m){for(var _=this._edges.iterator();_.hasNext();)_.next().eiList.addSplitEdges(m)},h.prototype.computeEdgeIntersections=function(m,_,C){var F=new j(_,C,!0);return F.setBoundaryNodes(this.getBoundaryNodes(),m.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,m._edges,F),F},h.prototype.getGeometry=function(){return this._parentGeom},h.prototype.getBoundaryNodeRule=function(){return this._boundaryNodeRule},h.prototype.hasTooFewPoints=function(){return this._hasTooFewPoints},h.prototype.addPoint=function(){if(arguments[0]instanceof Ls){var m=arguments[0].getCoordinate();this.insertPoint(this._argIndex,m,nt.INTERIOR)}else arguments[0]instanceof B&&this.insertPoint(this._argIndex,arguments[0],nt.INTERIOR)},h.prototype.addPolygon=function(m){this.addPolygonRing(m.getExteriorRing(),nt.EXTERIOR,nt.INTERIOR);for(var _=0;_<m.getNumInteriorRing();_++){var C=m.getInteriorRingN(_);this.addPolygonRing(C,nt.INTERIOR,nt.EXTERIOR)}},h.prototype.addEdge=function(m){this.insertEdge(m);var _=m.getCoordinates();this.insertPoint(this._argIndex,_[0],nt.BOUNDARY),this.insertPoint(this._argIndex,_[_.length-1],nt.BOUNDARY)},h.prototype.addLineString=function(m){var _=un.removeRepeatedPoints(m.getCoordinates());if(_.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=_[0],null;var C=new iu(_,new We(this._argIndex,nt.INTERIOR));this._lineEdgeMap.put(m,C),this.insertEdge(C),Nn.isTrue(_.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,_[0]),this.insertBoundaryPoint(this._argIndex,_[_.length-1])},h.prototype.getInvalidPoint=function(){return this._invalidPoint},h.prototype.getBoundaryPoints=function(){for(var m=this.getBoundaryNodes(),_=new Array(m.size()).fill(null),C=0,F=m.iterator();F.hasNext();){var rt=F.next();_[C++]=rt.getCoordinate().copy()}return _},h.prototype.getBoundaryNodes=function(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes},h.prototype.addSelfIntersectionNode=function(m,_,C){if(this.isBoundaryNode(m,_))return null;C===nt.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(m,_):this.insertPoint(m,_,C)},h.prototype.addPolygonRing=function(m,_,C){if(m.isEmpty())return null;var F=un.removeRepeatedPoints(m.getCoordinates());if(F.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=F[0],null;var rt=_,Dt=C;yn.isCCW(F)&&(rt=C,Dt=_);var qt=new iu(F,new We(this._argIndex,nt.BOUNDARY,rt,Dt));this._lineEdgeMap.put(m,qt),this.insertEdge(qt),this.insertPoint(this._argIndex,F[0],nt.BOUNDARY)},h.prototype.insertPoint=function(m,_,C){var F=this._nodes.addNode(_),rt=F.getLabel();null===rt?F._label=new We(m,C):rt.setLocation(m,C)},h.prototype.createEdgeSetIntersector=function(){return new mt},h.prototype.addSelfIntersectionNodes=function(m){for(var _=this._edges.iterator();_.hasNext();)for(var C=_.next(),F=C.getLabel().getLocation(m),rt=C.eiList.iterator();rt.hasNext();){var Dt=rt.next();this.addSelfIntersectionNode(m,Dt.coord,F)}},h.prototype.add=function(){if(1!==arguments.length)return l.prototype.add.apply(this,arguments);var m=arguments[0];if(m.isEmpty())return null;if(m instanceof Co&&(this._useBoundaryDeterminationRule=!1),m instanceof rs)this.addPolygon(m);else if(m instanceof Vr)this.addLineString(m);else if(m instanceof Ls)this.addPoint(m);else if(m instanceof Pa)this.addCollection(m);else if(m instanceof js)this.addCollection(m);else if(m instanceof Co)this.addCollection(m);else{if(!(m instanceof zr))throw new Error(m.getClass().getName());this.addCollection(m)}},h.prototype.addCollection=function(m){for(var _=0;_<m.getNumGeometries();_++){var C=m.getGeometryN(_);this.add(C)}},h.prototype.locate=function(m){return O(this._parentGeom,Ma)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new Nr(this._parentGeom)),this._areaPtLocator.locate(m)):this._ptLocator.locate(m,this._parentGeom)},h.prototype.findEdge=function(){return 1===arguments.length?this._lineEdgeMap.get(arguments[0]):l.prototype.findEdge.apply(this,arguments)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h.determineBoundary=function(m,_){return m.isInBoundary(_)?nt.BOUNDARY:nt.INTERIOR},h}(Or),ea=function(){if(this._li=new di,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){var l=arguments[0];this.setComputationPrecision(l.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Ho(0,l)}else if(2===arguments.length){var h=arguments[0],m=arguments[1],_=Rt.OGC_SFS_BOUNDARY_RULE;h.getPrecisionModel().compareTo(m.getPrecisionModel())>=0?this.setComputationPrecision(h.getPrecisionModel()):this.setComputationPrecision(m.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Ho(0,h,_),this._arg[1]=new Ho(1,m,_)}else if(3===arguments.length){var C=arguments[0],F=arguments[1],rt=arguments[2];C.getPrecisionModel().compareTo(F.getPrecisionModel())>=0?this.setComputationPrecision(C.getPrecisionModel()):this.setComputationPrecision(F.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Ho(0,C,rt),this._arg[1]=new Ho(1,F,rt)}};ea.prototype.getArgGeometry=function(l){return this._arg[l].getGeometry()},ea.prototype.setComputationPrecision=function(l){this._resultPrecisionModel=l,this._li.setPrecisionModel(this._resultPrecisionModel)},ea.prototype.interfaces_=function(){return[]},ea.prototype.getClass=function(){return ea};var da=function(){};da.prototype.interfaces_=function(){return[]},da.prototype.getClass=function(){return da},da.map=function(){if(arguments[0]instanceof Gn&&O(arguments[1],da.MapOp)){for(var l=arguments[0],h=arguments[1],m=new ue,_=0;_<l.getNumGeometries();_++){var C=h.map(l.getGeometryN(_));null!==C&&m.add(C)}return l.getFactory().buildGeometry(m)}if(O(arguments[0],je)&&O(arguments[1],da.MapOp)){for(var F=arguments[0],rt=arguments[1],Dt=new ue,qt=F.iterator();qt.hasNext();){var fe=qt.next(),ke=rt.map(fe);null!==ke&&Dt.add(ke)}return Dt}},da.MapOp=function(){};var cr=function(l){function h(){var m=arguments[0];l.call(this,m,arguments[1]),this._ptLocator=new ta,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new po,this._resultPolyList=new ue,this._resultLineList=new ue,this._resultPointList=new ue,this._graph=new Or(new zo),this._geomFact=m.getFactory()}return l&&(h.__proto__=l),(h.prototype=Object.create(l&&l.prototype)).constructor=h,h.prototype.insertUniqueEdge=function(m){var _=this._edgeList.findEqualEdge(m);if(null!==_){var C=_.getLabel(),F=m.getLabel();_.isPointwiseEqual(m)||(F=new We(m.getLabel())).flip();var rt=_.getDepth();rt.isNull()&&rt.add(C),rt.add(F),C.merge(F)}else this._edgeList.add(m)},h.prototype.getGraph=function(){return this._graph},h.prototype.cancelDuplicateResultEdges=function(){for(var m=this._graph.getEdgeEnds().iterator();m.hasNext();){var _=m.next(),C=_.getSym();_.isInResult()&&C.isInResult()&&(_.setInResult(!1),C.setInResult(!1))}},h.prototype.isCoveredByLA=function(m){return!!this.isCovered(m,this._resultLineList)||!!this.isCovered(m,this._resultPolyList)},h.prototype.computeGeometry=function(m,_,C,F){var rt=new ue;return rt.addAll(m),rt.addAll(_),rt.addAll(C),rt.isEmpty()?h.createEmptyResult(F,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(rt)},h.prototype.mergeSymLabels=function(){for(var m=this._graph.getNodes().iterator();m.hasNext();)m.next().getEdges().mergeSymLabels()},h.prototype.isCovered=function(m,_){for(var C=_.iterator();C.hasNext();){var F=C.next();if(this._ptLocator.locate(m,F)!==nt.EXTERIOR)return!0}return!1},h.prototype.replaceCollapsedEdges=function(){for(var m=new ue,_=this._edgeList.iterator();_.hasNext();){var C=_.next();C.isCollapsed()&&(_.remove(),m.add(C.getCollapsedEdge()))}this._edgeList.addAll(m)},h.prototype.updateNodeLabelling=function(){for(var m=this._graph.getNodes().iterator();m.hasNext();){var _=m.next(),C=_.getEdges().getLabel();_.getLabel().merge(C)}},h.prototype.getResultGeometry=function(m){return this.computeOverlay(m),this._resultGeom},h.prototype.insertUniqueEdges=function(m){for(var _=m.iterator();_.hasNext();){var C=_.next();this.insertUniqueEdge(C)}},h.prototype.computeOverlay=function(m){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);var _=new ue;this._arg[0].computeSplitEdges(_),this._arg[1].computeSplitEdges(_),this.insertUniqueEdges(_),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),yu.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(m),this.cancelDuplicateResultEdges();var C=new os(this._geomFact);C.add(this._graph),this._resultPolyList=C.getPolygons();var F=new bs(this,this._geomFact,this._ptLocator);this._resultLineList=F.build(m);var rt=new Tr(this,this._geomFact,this._ptLocator);this._resultPointList=rt.build(m),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,m)},h.prototype.labelIncompleteNode=function(m,_){var C=this._ptLocator.locate(m.getCoordinate(),this._arg[_].getGeometry());m.getLabel().setLocation(_,C)},h.prototype.copyPoints=function(m){for(var _=this._arg[m].getNodeIterator();_.hasNext();){var C=_.next();this._graph.addNode(C.getCoordinate()).setLabel(m,C.getLabel().getLocation(m))}},h.prototype.findResultAreaEdges=function(m){for(var _=this._graph.getEdgeEnds().iterator();_.hasNext();){var C=_.next(),F=C.getLabel();F.isArea()&&!C.isInteriorAreaEdge()&&h.isResultOfOp(F.getLocation(0,an.RIGHT),F.getLocation(1,an.RIGHT),m)&&C.setInResult(!0)}},h.prototype.computeLabelsFromDepths=function(){for(var m=this._edgeList.iterator();m.hasNext();){var _=m.next(),C=_.getLabel(),F=_.getDepth();if(!F.isNull()){F.normalize();for(var rt=0;rt<2;rt++)C.isNull(rt)||!C.isArea()||F.isNull(rt)||(0===F.getDelta(rt)?C.toLine(rt):(Nn.isTrue(!F.isNull(rt,an.LEFT),"depth of LEFT side has not been initialized"),C.setLocation(rt,an.LEFT,F.getLocation(rt,an.LEFT)),Nn.isTrue(!F.isNull(rt,an.RIGHT),"depth of RIGHT side has not been initialized"),C.setLocation(rt,an.RIGHT,F.getLocation(rt,an.RIGHT))))}}},h.prototype.computeLabelling=function(){for(var m=this._graph.getNodes().iterator();m.hasNext();)m.next().getEdges().computeLabelling(this._arg);this.mergeSymLabels(),this.updateNodeLabelling()},h.prototype.labelIncompleteNodes=function(){for(var m=this._graph.getNodes().iterator();m.hasNext();){var _=m.next(),C=_.getLabel();_.isIsolated()&&(C.isNull(0)?this.labelIncompleteNode(_,0):this.labelIncompleteNode(_,1)),_.getEdges().updateLabelling(C)}},h.prototype.isCoveredByA=function(m){return!!this.isCovered(m,this._resultPolyList)},h.prototype.interfaces_=function(){return[]},h.prototype.getClass=function(){return h},h}(ea);cr.overlayOp=function(l,h,m){return new cr(l,h).getResultGeometry(m)},cr.intersection=function(l,h){if(l.isEmpty()||h.isEmpty())return cr.createEmptyResult(cr.INTERSECTION,l,h,l.getFactory());if(l.isGeometryCollection()){var m=h;return or.map(l,{interfaces_:function(){return[da.MapOp]},map:function(_){return _.intersection(m)}})}return l.checkNotGeometryCollection(l),l.checkNotGeometryCollection(h),Pe.overlayOp(l,h,cr.INTERSECTION)},cr.symDifference=function(l,h){if(l.isEmpty()||h.isEmpty()){if(l.isEmpty()&&h.isEmpty())return cr.createEmptyResult(cr.SYMDIFFERENCE,l,h,l.getFactory());if(l.isEmpty())return h.copy();if(h.isEmpty())return l.copy()}return l.checkNotGeometryCollection(l),l.checkNotGeometryCollection(h),Pe.overlayOp(l,h,cr.SYMDIFFERENCE)},cr.resultDimension=function(l,h,m){var _=h.getDimension(),C=m.getDimension(),F=-1;switch(l){case cr.INTERSECTION:F=Math.min(_,C);break;case cr.UNION:F=Math.max(_,C);break;case cr.DIFFERENCE:F=_;break;case cr.SYMDIFFERENCE:F=Math.max(_,C)}return F},cr.createEmptyResult=function(l,h,m,_){var C=null;switch(cr.resultDimension(l,h,m)){case-1:C=_.createGeometryCollection(new Array(0).fill(null));break;case 0:C=_.createPoint();break;case 1:C=_.createLineString();break;case 2:C=_.createPolygon()}return C},cr.difference=function(l,h){return l.isEmpty()?cr.createEmptyResult(cr.DIFFERENCE,l,h,l.getFactory()):h.isEmpty()?l.copy():(l.checkNotGeometryCollection(l),l.checkNotGeometryCollection(h),Pe.overlayOp(l,h,cr.DIFFERENCE))},cr.isResultOfOp=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1],m=l.getLocation(0),_=l.getLocation(1);return cr.isResultOfOp(m,_,h)}if(3===arguments.length){var C=arguments[0],F=arguments[1];switch(C===nt.BOUNDARY&&(C=nt.INTERIOR),F===nt.BOUNDARY&&(F=nt.INTERIOR),arguments[2]){case cr.INTERSECTION:return C===nt.INTERIOR&&F===nt.INTERIOR;case cr.UNION:return C===nt.INTERIOR||F===nt.INTERIOR;case cr.DIFFERENCE:return C===nt.INTERIOR&&F!==nt.INTERIOR;case cr.SYMDIFFERENCE:return C===nt.INTERIOR&&F!==nt.INTERIOR||C!==nt.INTERIOR&&F===nt.INTERIOR}return!1}},cr.INTERSECTION=1,cr.UNION=2,cr.DIFFERENCE=3,cr.SYMDIFFERENCE=4;var su=function(){this._g=null,this._boundaryDistanceTolerance=null,this._linework=null,this._ptLocator=new ta,this._seg=new tn;var l=arguments[0],h=arguments[1];this._g=l,this._boundaryDistanceTolerance=h,this._linework=this.extractLinework(l)};su.prototype.isWithinToleranceOfBoundary=function(l){for(var h=0;h<this._linework.getNumGeometries();h++)for(var m=this._linework.getGeometryN(h).getCoordinateSequence(),_=0;_<m.size()-1;_++)if(m.getCoordinate(_,this._seg.p0),m.getCoordinate(_+1,this._seg.p1),this._seg.distance(l)<=this._boundaryDistanceTolerance)return!0;return!1},su.prototype.getLocation=function(l){return this.isWithinToleranceOfBoundary(l)?nt.BOUNDARY:this._ptLocator.locate(l,this._g)},su.prototype.extractLinework=function(l){var h=new Rr;l.apply(h);var m=h.getLinework(),_=er.toLineStringArray(m);return l.getFactory().createMultiLineString(_)},su.prototype.interfaces_=function(){return[]},su.prototype.getClass=function(){return su};var Rr=function(){this._linework=null,this._linework=new ue};Rr.prototype.getLinework=function(){return this._linework},Rr.prototype.filter=function(l){if(l instanceof rs){var h=l;this._linework.add(h.getExteriorRing());for(var m=0;m<h.getNumInteriorRing();m++)this._linework.add(h.getInteriorRingN(m))}},Rr.prototype.interfaces_=function(){return[fi]},Rr.prototype.getClass=function(){return Rr};var Il=function(){this._g=null,this._doLeft=!0,this._doRight=!0,this._g=arguments[0]};Il.prototype.extractPoints=function(l,h,m){for(var _=l.getCoordinates(),C=0;C<_.length-1;C++)this.computeOffsetPoints(_[C],_[C+1],h,m)},Il.prototype.setSidesToGenerate=function(l,h){this._doLeft=l,this._doRight=h},Il.prototype.getPoints=function(l){for(var h=new ue,m=Qs.getLines(this._g).iterator();m.hasNext();){var _=m.next();this.extractPoints(_,l,h)}return h},Il.prototype.computeOffsetPoints=function(l,h,m,_){var C=h.x-l.x,F=h.y-l.y,rt=Math.sqrt(C*C+F*F),Dt=m*C/rt,qt=m*F/rt,fe=(h.x+l.x)/2,ke=(h.y+l.y)/2;if(this._doLeft){var Ge=new B(fe-qt,ke+Dt);_.add(Ge)}if(this._doRight){var xn=new B(fe+qt,ke-Dt);_.add(xn)}},Il.prototype.interfaces_=function(){return[]},Il.prototype.getClass=function(){return Il};var qs=function l(){this._geom=null,this._locFinder=null,this._location=new Array(3).fill(null),this._invalidLocation=null,this._boundaryDistanceTolerance=l.TOLERANCE,this._testCoords=new ue;var h=arguments[0],m=arguments[1],_=arguments[2];this._boundaryDistanceTolerance=l.computeBoundaryDistanceTolerance(h,m),this._geom=[h,m,_],this._locFinder=[new su(this._geom[0],this._boundaryDistanceTolerance),new su(this._geom[1],this._boundaryDistanceTolerance),new su(this._geom[2],this._boundaryDistanceTolerance)]},Ns={TOLERANCE:{configurable:!0}};qs.prototype.reportResult=function(l,h,m){Xe.out.println("Overlay result invalid - A:"+nt.toLocationSymbol(h[0])+" B:"+nt.toLocationSymbol(h[1])+" expected:"+(m?"i":"e")+" actual:"+nt.toLocationSymbol(h[2]))},qs.prototype.isValid=function(l){return this.addTestPts(this._geom[0]),this.addTestPts(this._geom[1]),this.checkValid(l)},qs.prototype.checkValid=function(){if(1===arguments.length){for(var l=arguments[0],h=0;h<this._testCoords.size();h++){var m=this._testCoords.get(h);if(!this.checkValid(l,m))return this._invalidLocation=m,!1}return!0}if(2===arguments.length){var _=arguments[0],C=arguments[1];return this._location[0]=this._locFinder[0].getLocation(C),this._location[1]=this._locFinder[1].getLocation(C),this._location[2]=this._locFinder[2].getLocation(C),!!qs.hasLocation(this._location,nt.BOUNDARY)||this.isValidResult(_,this._location)}},qs.prototype.addTestPts=function(l){var h=new Il(l);this._testCoords.addAll(h.getPoints(5*this._boundaryDistanceTolerance))},qs.prototype.isValidResult=function(l,h){var m=cr.isResultOfOp(h[0],h[1],l),_=!(m^h[2]===nt.INTERIOR);return _||this.reportResult(l,h,m),_},qs.prototype.getInvalidLocation=function(){return this._invalidLocation},qs.prototype.interfaces_=function(){return[]},qs.prototype.getClass=function(){return qs},qs.hasLocation=function(l,h){for(var m=0;m<3;m++)if(l[m]===h)return!0;return!1},qs.computeBoundaryDistanceTolerance=function(l,h){return Math.min(gt.computeSizeBasedSnapTolerance(l),gt.computeSizeBasedSnapTolerance(h))},qs.isValid=function(l,h,m,_){return new qs(l,h,_).isValid(m)},Ns.TOLERANCE.get=function(){return 1e-6},Object.defineProperties(qs,Ns);var ws=function l(h){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null,this._geomFactory=l.extractFactory(h),this._inputGeoms=h};ws.prototype.extractElements=function(l,h){if(null===l)return null;for(var m=0;m<l.getNumGeometries();m++){var _=l.getGeometryN(m);this._skipEmpty&&_.isEmpty()||h.add(_)}},ws.prototype.combine=function(){for(var l=new ue,h=this._inputGeoms.iterator();h.hasNext();){var m=h.next();this.extractElements(m,l)}return 0===l.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection(null):null:this._geomFactory.buildGeometry(l)},ws.prototype.interfaces_=function(){return[]},ws.prototype.getClass=function(){return ws},ws.combine=function(){return 1===arguments.length?new ws(arguments[0]).combine():2===arguments.length?new ws(ws.createList(arguments[0],arguments[1])).combine():3===arguments.length?new ws(ws.createList(arguments[0],arguments[1],arguments[2])).combine():void 0},ws.extractFactory=function(l){return l.isEmpty()?null:l.iterator().next().getFactory()},ws.createList=function(){if(2===arguments.length){var l=arguments[0],h=arguments[1],m=new ue;return m.add(l),m.add(h),m}if(3===arguments.length){var _=arguments[0],C=arguments[1],F=arguments[2],rt=new ue;return rt.add(_),rt.add(C),rt.add(F),rt}};var Is=function(){this._inputPolys=null,this._geomFactory=null,this._inputPolys=arguments[0],null===this._inputPolys&&(this._inputPolys=new ue)},na={STRTREE_NODE_CAPACITY:{configurable:!0}};Is.prototype.reduceToGeometries=function(l){for(var h=new ue,m=l.iterator();m.hasNext();){var _=m.next(),C=null;O(_,En)?C=this.unionTree(_):_ instanceof Gn&&(C=_),h.add(C)}return h},Is.prototype.extractByEnvelope=function(l,h,m){for(var _=new ue,C=0;C<h.getNumGeometries();C++){var F=h.getGeometryN(C);F.getEnvelopeInternal().intersects(l)?_.add(F):m.add(F)}return this._geomFactory.buildGeometry(_)},Is.prototype.unionOptimized=function(l,h){var m=l.getEnvelopeInternal(),_=h.getEnvelopeInternal();if(!m.intersects(_))return ws.combine(l,h);if(l.getNumGeometries()<=1&&h.getNumGeometries()<=1)return this.unionActual(l,h);var C=m.intersection(_);return this.unionUsingEnvelopeIntersection(l,h,C)},Is.prototype.union=function(){if(null===this._inputPolys)throw new Error("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();for(var l=new Cn(Is.STRTREE_NODE_CAPACITY),h=this._inputPolys.iterator();h.hasNext();){var m=h.next();l.insert(m.getEnvelopeInternal(),m)}this._inputPolys=null;var _=l.itemsTree();return this.unionTree(_)},Is.prototype.binaryUnion=function(){if(1===arguments.length){var l=arguments[0];return this.binaryUnion(l,0,l.size())}if(3===arguments.length){var h=arguments[0],m=arguments[1],_=arguments[2];if(_-m<=1){var C=Is.getGeometry(h,m);return this.unionSafe(C,null)}if(_-m==2)return this.unionSafe(Is.getGeometry(h,m),Is.getGeometry(h,m+1));var F=Math.trunc((_+m)/2),rt=this.binaryUnion(h,m,F),Dt=this.binaryUnion(h,F,_);return this.unionSafe(rt,Dt)}},Is.prototype.repeatedUnion=function(l){for(var h=null,m=l.iterator();m.hasNext();){var _=m.next();h=null===h?_.copy():h.union(_)}return h},Is.prototype.unionSafe=function(l,h){return null===l&&null===h?null:null===l?h.copy():null===h?l.copy():this.unionOptimized(l,h)},Is.prototype.unionActual=function(l,h){return Is.restrictToPolygons(l.union(h))},Is.prototype.unionTree=function(l){var h=this.reduceToGeometries(l);return this.binaryUnion(h)},Is.prototype.unionUsingEnvelopeIntersection=function(l,h,m){var _=new ue,C=this.extractByEnvelope(m,l,_),F=this.extractByEnvelope(m,h,_),rt=this.unionActual(C,F);return _.add(rt),ws.combine(_)},Is.prototype.bufferUnion=function(){if(1===arguments.length){var l=arguments[0];return l.get(0).getFactory().buildGeometry(l).buffer(0)}if(2===arguments.length){var h=arguments[0],m=arguments[1];return h.getFactory().createGeometryCollection([h,m]).buffer(0)}},Is.prototype.interfaces_=function(){return[]},Is.prototype.getClass=function(){return Is},Is.restrictToPolygons=function(l){if(O(l,Ma))return l;var h=Ca.getPolygons(l);return 1===h.size()?h.get(0):l.getFactory().createMultiPolygon(er.toPolygonArray(h))},Is.getGeometry=function(l,h){return h>=l.size()?null:l.get(h)},Is.union=function(l){return new Is(l).union()},na.STRTREE_NODE_CAPACITY.get=function(){return 4},Object.defineProperties(Is,na);var qu=function(){};qu.prototype.interfaces_=function(){return[]},qu.prototype.getClass=function(){return qu},qu.union=function(l,h){if(l.isEmpty()||h.isEmpty()){if(l.isEmpty()&&h.isEmpty())return cr.createEmptyResult(cr.UNION,l,h,l.getFactory());if(l.isEmpty())return h.copy();if(h.isEmpty())return l.copy()}return l.checkNotGeometryCollection(l),l.checkNotGeometryCollection(h),Pe.overlayOp(l,h,cr.UNION)},y.GeoJSONReader=Yi,y.GeoJSONWriter=Ra,y.OverlayOp=cr,y.UnionOp=qu,y.BufferOp=Ts,Object.defineProperty(y,"__esModule",{value:!0})}(ut)},5410:()=>{},8628:()=>{},1601:()=>{},7792:()=>{},4977:()=>{},5042:()=>{},7156:Lt=>{function ut($,V,H,Q,Y,R,W){try{var k=$[R](W),A=k.value}catch(X){return void H(X)}k.done?V(A):Promise.resolve(A).then(Q,Y)}Lt.exports=function y($){return function(){var V=this,H=arguments;return new Promise(function(Q,Y){var R=$.apply(V,H);function W(A){ut(R,Q,Y,W,k,"next",A)}function k(A){ut(R,Q,Y,W,k,"throw",A)}W(void 0)})}},Lt.exports.__esModule=!0,Lt.exports.default=Lt.exports},5861:(Lt,ut,y)=>{"use strict";function $(H,Q,Y,R,W,k,A){try{var X=H[k](A),Z=X.value}catch(G){return void Y(G)}X.done?Q(Z):Promise.resolve(Z).then(R,W)}function V(H){return function(){var Q=this,Y=arguments;return new Promise(function(R,W){var k=H.apply(Q,Y);function A(Z){$(k,R,W,A,X,"next",Z)}function X(Z){$(k,R,W,A,X,"throw",Z)}A(void 0)})}}y.d(ut,{Z:()=>V})}},Lt=>{Lt(Lt.s=1324)}]);